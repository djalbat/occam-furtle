"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return TermNode;
    }
});
const _occamlanguages = require("occam-languages");
const _ruleNames = require("../ruleNames");
class TermNode extends _occamlanguages.NonTerminalNode {
    getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
    }
    getPrimitiveNode() {
        const ruleName = _ruleNames.PRIMITIVE_RULE_NAME, primitiveNode = this.getNodeByRuleName(ruleName);
        return primitiveNode;
    }
    getNegatedTermNode() {
        const ruleName = _ruleNames.NEGATED_TERM_RULE_NAME, negatedTermNode = this.getNodeByRuleName(ruleName);
        return negatedTermNode;
    }
    getLogicalTermNode() {
        const ruleName = _ruleNames.LOGICAL_TERM_RULE_NAME, logicalTermRuleName = this.getNodeByRuleName(ruleName);
        return logicalTermRuleName;
    }
    getBracketedTermNode() {
        const ruleName = _ruleNames.BRACKETED_TERM_RULE_NAME, bracketedTermRuleName = this.getNodeByRuleName(ruleName);
        return bracketedTermRuleName;
    }
    getComparisonTermNode() {
        const ruleName = _ruleNames.COMPARISON_TERM_RULE_NAME, comparisonNode = this.getNodeByRuleName(ruleName);
        return comparisonNode;
    }
    static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === undefined) {
            precedence = opacity; ///
            opacity = childNodes; ///
            childNodes = ruleName; ///
            ruleName = Class; ///
            Class = TermNode;
        }
        const termNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return termNode;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL3Rlcm0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgUFJJTUlUSVZFX1JVTEVfTkFNRSxcbiAgICAgICAgIE5FR0FURURfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgQlJBQ0tFVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgQ09NUEFSSVNPTl9URVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgZ2V0UHJpbWl0aXZlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBSSU1JVElWRV9SVUxFX05BTUUsXG4gICAgICAgICAgcHJpbWl0aXZlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByaW1pdGl2ZU5vZGU7XG4gIH1cblxuICBnZXROZWdhdGVkVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBORUdBVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIG5lZ2F0ZWRUZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5lZ2F0ZWRUZXJtTm9kZTtcbiAgfVxuXG4gIGdldExvZ2ljYWxUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IExPR0lDQUxfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgbG9naWNhbFRlcm1SdWxlTmFtZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGxvZ2ljYWxUZXJtUnVsZU5hbWU7XG4gIH1cblxuICBnZXRCcmFja2V0ZWRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICBicmFja2V0ZWRUZXJtUnVsZU5hbWUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBicmFja2V0ZWRUZXJtUnVsZU5hbWU7XG4gIH1cblxuICBnZXRDb21wYXJpc29uVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIGNvbXBhcmlzb25Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gY29tcGFyaXNvbk5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBvcGFjaXR5OyAvLy9cblxuICAgICAgb3BhY2l0eSA9IGNoaWxkTm9kZXM7IC8vL1xuXG4gICAgICBjaGlsZE5vZGVzID0gcnVsZU5hbWU7ICAvLy9cblxuICAgICAgcnVsZU5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gVGVybU5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgdGVybU5vZGUgPSBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJUZXJtTm9kZSIsIk5vblRlcm1pbmFsTm9kZSIsImdldFZhcmlhYmxlTm9kZSIsInJ1bGVOYW1lIiwiVkFSSUFCTEVfUlVMRV9OQU1FIiwidmFyaWFibGVOb2RlIiwiZ2V0Tm9kZUJ5UnVsZU5hbWUiLCJnZXRQcmltaXRpdmVOb2RlIiwiUFJJTUlUSVZFX1JVTEVfTkFNRSIsInByaW1pdGl2ZU5vZGUiLCJnZXROZWdhdGVkVGVybU5vZGUiLCJORUdBVEVEX1RFUk1fUlVMRV9OQU1FIiwibmVnYXRlZFRlcm1Ob2RlIiwiZ2V0TG9naWNhbFRlcm1Ob2RlIiwiTE9HSUNBTF9URVJNX1JVTEVfTkFNRSIsImxvZ2ljYWxUZXJtUnVsZU5hbWUiLCJnZXRCcmFja2V0ZWRUZXJtTm9kZSIsIkJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSIsImJyYWNrZXRlZFRlcm1SdWxlTmFtZSIsImdldENvbXBhcmlzb25UZXJtTm9kZSIsIkNPTVBBUklTT05fVEVSTV9SVUxFX05BTUUiLCJjb21wYXJpc29uTm9kZSIsImZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZSIsIkNsYXNzIiwiY2hpbGROb2RlcyIsIm9wYWNpdHkiLCJwcmVjZWRlbmNlIiwidW5kZWZpbmVkIiwidGVybU5vZGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7OytCQVdBOzs7ZUFBcUJBOzs7Z0NBVFc7MkJBT1U7QUFFM0IsTUFBTUEsaUJBQWlCQywrQkFBZTtJQUNuREMsa0JBQWtCO1FBQ2hCLE1BQU1DLFdBQVdDLDZCQUFrQixFQUM3QkMsZUFBZSxJQUFJLENBQUNDLGlCQUFpQixDQUFDSDtRQUU1QyxPQUFPRTtJQUNUO0lBRUFFLG1CQUFtQjtRQUNqQixNQUFNSixXQUFXSyw4QkFBbUIsRUFDOUJDLGdCQUFnQixJQUFJLENBQUNILGlCQUFpQixDQUFDSDtRQUU3QyxPQUFPTTtJQUNUO0lBRUFDLHFCQUFxQjtRQUNuQixNQUFNUCxXQUFXUSxpQ0FBc0IsRUFDakNDLGtCQUFrQixJQUFJLENBQUNOLGlCQUFpQixDQUFDSDtRQUUvQyxPQUFPUztJQUNUO0lBRUFDLHFCQUFxQjtRQUNuQixNQUFNVixXQUFXVyxpQ0FBc0IsRUFDakNDLHNCQUFzQixJQUFJLENBQUNULGlCQUFpQixDQUFDSDtRQUVuRCxPQUFPWTtJQUNUO0lBRUFDLHVCQUF1QjtRQUNyQixNQUFNYixXQUFXYyxtQ0FBd0IsRUFDbkNDLHdCQUF3QixJQUFJLENBQUNaLGlCQUFpQixDQUFDSDtRQUVyRCxPQUFPZTtJQUNUO0lBRUFDLHdCQUF3QjtRQUN0QixNQUFNaEIsV0FBV2lCLG9DQUF5QixFQUNwQ0MsaUJBQWlCLElBQUksQ0FBQ2YsaUJBQWlCLENBQUNIO1FBRTlDLE9BQU9rQjtJQUNUO0lBRUEsT0FBT0MsMkNBQTJDQyxLQUFLLEVBQUVwQixRQUFRLEVBQUVxQixVQUFVLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFO1FBQ2xHLElBQUlBLGVBQWVDLFdBQVc7WUFDNUJELGFBQWFELFNBQVMsR0FBRztZQUV6QkEsVUFBVUQsWUFBWSxHQUFHO1lBRXpCQSxhQUFhckIsVUFBVyxHQUFHO1lBRTNCQSxXQUFXb0IsT0FBTyxHQUFHO1lBRXJCQSxRQUFRdkI7UUFDVjtRQUVBLE1BQU00QixXQUFXM0IsK0JBQWUsQ0FBQ3FCLDBDQUEwQyxDQUFDQyxPQUFPcEIsVUFBVXFCLFlBQVlDLFNBQVNDO1FBRWxILE9BQU9FO0lBQ1Q7QUFDRiJ9