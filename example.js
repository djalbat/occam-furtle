(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
  var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/easy/lib/offset.js
  var require_offset = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Offset;
      }
    });
    var Offset = class {
      constructor(top, left) {
        this.top = top;
        this.left = left;
      }
      getTop() {
        return this.top;
      }
      getLeft() {
        return this.left;
      }
      static fromDOMElement(domElement) {
        const {offsetTop, offsetLeft} = domElement, top = offsetTop, left = offsetLeft, offset = new Offset(top, left);
        return offset;
      }
    };
  });

  // node_modules/easy/lib/bounds.js
  var require_bounds = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Bounds;
      }
    });
    var Bounds = class {
      constructor(top, left, right, bottom) {
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
      }
      getTop() {
        return this.top;
      }
      getLeft() {
        return this.left;
      }
      getRight() {
        return this.right;
      }
      getBottom() {
        return this.bottom;
      }
      getWidth() {
        const width = this.right - this.left;
        return width;
      }
      getHeight() {
        const height = this.bottom - this.top;
        return height;
      }
      setTop(top) {
        this.top = top;
      }
      setLeft(left) {
        this.left = left;
      }
      setRight(right) {
        this.right = right;
      }
      setBottom(bottom) {
        this.bottom = bottom;
      }
      areOverlapping(bounds) {
        const bottom = bounds.getBottom(), right = bounds.getRight(), left = bounds.getLeft(), top = bounds.getTop(), overlapping = this.top < bottom && this.left < right && this.right > left && this.bottom > top;
        return overlapping;
      }
      areOverlappingByTopAndLeft(top, left) {
        const overlapping = this.top <= top && this.left <= left && this.right > left && this.bottom > top;
        return overlapping;
      }
      static fromDOMElement(domElement) {
        const {pageXOffset, pageYOffset} = window, boundingClientRect = domElement.getBoundingClientRect(), windowScrollTop = pageYOffset, windowScrollLeft = pageXOffset, top = boundingClientRect.top + windowScrollTop, left = boundingClientRect.left + windowScrollLeft, right = boundingClientRect.right + windowScrollLeft, bottom = boundingClientRect.bottom + windowScrollTop, bounds = new Bounds(top, left, right, bottom);
        return bounds;
      }
      static fromTopLeftWidthAndHeight(top, left, width, height) {
        const bottom = top + height, right = left + width, bounds = new Bounds(top, left, right, bottom);
        return bounds;
      }
    };
  });

  // node_modules/easy/lib/utilities/array.js
  var require_array = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get augment() {
        return augment;
      },
      get first() {
        return first2;
      },
      get flatten() {
        return flatten;
      },
      get guarantee() {
        return guarantee;
      },
      get push() {
        return push;
      }
    });
    function first2(array) {
      return array[0];
    }
    function push(array1, array2) {
      Array.prototype.push.apply(array1, array2);
    }
    function augment(array1, array2, test) {
      array1 = [
        ...array1
      ];
      array2.forEach((element, index) => {
        const passed = test(element, index);
        if (passed) {
          array1.push(element);
        }
      });
      return array1;
    }
    function flatten(array) {
      return array.reduce((array2, element) => {
        array2 = array2.concat(element);
        return array2;
      }, []);
    }
    function guarantee(arrayOrElement) {
      arrayOrElement = arrayOrElement || [];
      return arrayOrElement instanceof Array ? arrayOrElement : [
        arrayOrElement
      ];
    }
  });

  // node_modules/easy/lib/constants.js
  var require_constants = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BLOCK() {
        return BLOCK;
      },
      get BODY() {
        return BODY;
      },
      get BOOLEAN() {
        return BOOLEAN;
      },
      get CLASS() {
        return CLASS;
      },
      get CLASS_NAME() {
        return CLASS_NAME;
      },
      get DEFAULT_PROPERTIES() {
        return DEFAULT_PROPERTIES;
      },
      get DISABLED() {
        return DISABLED;
      },
      get DISPLAY() {
        return DISPLAY;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get FOR() {
        return FOR;
      },
      get FUNCTION() {
        return FUNCTION;
      },
      get HEIGHT() {
        return HEIGHT;
      },
      get HTML_FOR() {
        return HTML_FOR;
      },
      get IGNORED_PROPERTIES() {
        return IGNORED_PROPERTIES;
      },
      get NONE() {
        return NONE;
      },
      get OBJECT() {
        return OBJECT;
      },
      get SPACE() {
        return SPACE;
      },
      get STRING() {
        return STRING;
      },
      get SVG_NAMESPACE_URI() {
        return SVG_NAMESPACE_URI;
      },
      get UNDEFINED() {
        return UNDEFINED;
      },
      get WIDTH() {
        return WIDTH;
      },
      get WILDCARD() {
        return WILDCARD;
      }
    });
    var FOR = "for";
    var BODY = "body";
    var NONE = "none";
    var SPACE = " ";
    var CLASS = "class";
    var WIDTH = "width";
    var BLOCK = "block";
    var HEIGHT = "height";
    var OBJECT = "object";
    var STRING = "string";
    var DISPLAY = "display";
    var BOOLEAN = "boolean";
    var DISABLED = "disabled";
    var FUNCTION = "function";
    var WILDCARD = "*";
    var HTML_FOR = "htmlFor";
    var UNDEFINED = "undefined";
    var CLASS_NAME = "className";
    var EMPTY_STRING = "";
    var SVG_NAMESPACE_URI = "http://www.w3.org/2000/svg";
    var DEFAULT_PROPERTIES = "defaultProperties";
    var IGNORED_PROPERTIES = "ignoredProperties";
  });

  // node_modules/easy/lib/utilities/object.js
  var require_object = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combine() {
        return combine;
      },
      get prune() {
        return prune;
      }
    });
    var _constants = require_constants();
    function combine(target, source = {}) {
      target = {
        ...target
      };
      const names = Object.keys(source);
      names.forEach((name) => {
        const targetValue = target[name], sourceValue = source[name], targetHasOwnProperty = target.hasOwnProperty(name);
        target[name] = targetHasOwnProperty ? combineValues(targetValue, sourceValue) : sourceValue;
      });
      return target;
    }
    function prune(target, names = []) {
      target = {
        ...target
      };
      names.forEach((name) => {
        const targetHasOwnProperty = target.hasOwnProperty(name);
        if (targetHasOwnProperty) {
          delete target[name];
        }
      });
      return target;
    }
    function combineValues(targetValue, sourceValue) {
      const targetValueBoolean = isValueBoolean(targetValue), sourceValueBoolean = isValueBoolean(sourceValue), combinedValue = targetValueBoolean && sourceValueBoolean ? targetValue : `${targetValue} ${sourceValue}`;
      return combinedValue;
    }
    function isValueBoolean(value) {
      const valueBoolean = typeof value === _constants.BOOLEAN;
      return valueBoolean;
    }
  });

  // node_modules/easy/lib/utilities/string.js
  var require_string = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "camelCaseToSnakeCase", {
      enumerable: true,
      get: function() {
        return camelCaseToSnakeCase;
      }
    });
    function camelCaseToSnakeCase(string) {
      return string.replace(/([A-Z]+)/g, (match, characters) => {
        const upperCaseCharacters = characters.toLowerCase(), snakeCaseCharacters = `-${upperCaseCharacters}`;
        return snakeCaseCharacters;
      });
    }
  });

  // node_modules/easy/lib/utilities/name.js
  var require_name = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isHTMLAttributeName() {
        return isHTMLAttributeName;
      },
      get isSVGAttributeName() {
        return isSVGAttributeName;
      },
      get isSVGTagName() {
        return isSVGTagName;
      }
    });
    function isSVGTagName(tagName) {
      return svgTagNames.includes(tagName);
    }
    function isSVGAttributeName(attributeName) {
      return svgAttributeNames.includes(attributeName);
    }
    function isHTMLAttributeName(attributeName) {
      return htmlAttributeNames.includes(attributeName);
    }
    var svgTagNames = [
      "altGlyph",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "animation",
      "audio",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "discard",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "handler",
      "hatch",
      "hatchpath",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "listener",
      "marker",
      "mask",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "prefetch",
      "radialGradient",
      "rect",
      "script",
      "set",
      "solidcolor",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "tbreak",
      "text",
      "textArea",
      "textPath",
      "title",
      "tref",
      "tspan",
      "unknown",
      "use",
      "video",
      "view",
      "vkern"
    ];
    var svgAttributeNames = [
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "alphabetic",
      "amplitude",
      "arabic-form",
      "ascent",
      "attributeName",
      "attributeType",
      "azimuth",
      "bandwidth",
      "baseFrequency",
      "baseProfile",
      "baseline-shift",
      "bbox",
      "begin",
      "bias",
      "by",
      "calcMode",
      "cap-height",
      "clip",
      "className",
      "clip-path",
      "clip-rule",
      "clipPathUnits",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "contentScriptType",
      "contentStyleType",
      "crossorigin",
      "cursor",
      "cx",
      "cy",
      "d",
      "defaultAction",
      "descent",
      "diffuseConstant",
      "direction",
      "display",
      "divisor",
      "dominant-baseline",
      "download",
      "dur",
      "dx",
      "dy",
      "edgeMode",
      "editable",
      "elevation",
      "enable-background",
      "end",
      "event",
      "exponent",
      "externalResourcesRequired",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterRes",
      "filterUnits",
      "flood-color",
      "flood-opacity",
      "focusHighlight",
      "focusable",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "format",
      "fr",
      "from",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "handler",
      "hanging",
      "hatchContentUnits",
      "hatchUnits",
      "height",
      "horiz-adv-x",
      "horiz-origin-x",
      "horiz-origin-y",
      "href",
      "hreflang",
      "id",
      "ideographic",
      "image-rendering",
      "in",
      "in2",
      "initialVisibility",
      "intercept",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kernelMatrix",
      "kernelUnitLength",
      "kerning",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "letter-spacing",
      "lighting-color",
      "limitingConeAngle",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "mask",
      "maskContentUnits",
      "maskUnits",
      "mathematical",
      "max",
      "media",
      "mediaCharacterEncoding",
      "mediaContentEncodings",
      "mediaSize",
      "mediaTime",
      "method",
      "min",
      "mode",
      "name",
      "nav-down",
      "nav-down-left",
      "nav-down-right",
      "nav-left",
      "nav-next",
      "nav-prev",
      "nav-right",
      "nav-up",
      "nav-up-left",
      "nav-up-right",
      "numOctaves",
      "observer",
      "offset",
      "opacity",
      "operator",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "overlay",
      "overline-position",
      "overline-thickness",
      "panose-1",
      "path",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "phase",
      "pitch",
      "playbackOrder",
      "playbackorder",
      "pointer-events",
      "points",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "propagate",
      "r",
      "radius",
      "refX",
      "refY",
      "rendering-intent",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "requiredFonts",
      "requiredFormats",
      "restart",
      "result",
      "rotate",
      "rx",
      "ry",
      "scale",
      "seed",
      "shape-rendering",
      "side",
      "slope",
      "snapshotTime",
      "spacing",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "src",
      "startOffset",
      "stdDeviation",
      "stemh",
      "stemv",
      "stitchTiles",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "string",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "style",
      "surfaceScale",
      "syncBehavior",
      "syncBehaviorDefault",
      "syncMaster",
      "syncTolerance",
      "syncToleranceDefault",
      "systemLanguage",
      "tableValues",
      "target",
      "targetX",
      "targetY",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textLength",
      "timelineBegin",
      "timelinebegin",
      "title",
      "to",
      "transform",
      "transformBehavior",
      "type",
      "u1",
      "u2",
      "underline-position",
      "underline-thickness",
      "unicode",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "values",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "viewBox",
      "viewTarget",
      "visibility",
      "width",
      "widths",
      "word-spacing",
      "writing-mode",
      "x",
      "x-height",
      "x1",
      "x2",
      "xChannelSelector",
      "y",
      "y1",
      "y2",
      "yChannelSelector",
      "z",
      "zoomAndPan"
    ];
    var htmlAttributeNames = [
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "allow",
      "allowFullScreen",
      "allowTransparency",
      "alt",
      "async",
      "autoComplete",
      "autoFocus",
      "autoPlay",
      "capture",
      "cellPadding",
      "cellSpacing",
      "challenge",
      "charSet",
      "checked",
      "cite",
      "classID",
      "className",
      "colSpan",
      "cols",
      "content",
      "contentEditable",
      "contextMenu",
      "controls",
      "coords",
      "crossOrigin",
      "data",
      "dateTime",
      "default",
      "defer",
      "dir",
      "disabled",
      "download",
      "draggable",
      "encType",
      "form",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "frameBorder",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hrefLang",
      "htmlFor",
      "httpEquiv",
      "icon",
      "id",
      "inputMode",
      "integrity",
      "is",
      "keyParams",
      "keyType",
      "kind",
      "label",
      "lang",
      "list",
      "loop",
      "low",
      "manifest",
      "marginHeight",
      "marginWidth",
      "max",
      "maxLength",
      "media",
      "mediaGroup",
      "method",
      "min",
      "minLength",
      "multiple",
      "muted",
      "name",
      "noValidate",
      "nonce",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "poster",
      "preload",
      "profile",
      "radioGroup",
      "readOnly",
      "rel",
      "required",
      "reversed",
      "role",
      "rowSpan",
      "rows",
      "sandbox",
      "scope",
      "scoped",
      "scrolling",
      "seamless",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "spellCheck",
      "src",
      "srcDoc",
      "srcLang",
      "srcSet",
      "start",
      "step",
      "style",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "value",
      "width",
      "wmode",
      "wrap"
    ];
  });

  // node_modules/easy/lib/utilities/element.js
  var require_element = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get constructElement() {
        return constructElement;
      },
      get default() {
        return _default;
      },
      get destroyElement() {
        return destroyElement;
      },
      get mountElement() {
        return mountElement;
      },
      get unmountElement() {
        return unmountElement;
      }
    });
    function constructElement(element, domElement) {
      element.domElement = domElement;
      domElement.__element__ = element;
    }
    function destroyElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.forEach((element2) => {
        const domElement = element2.getDOMElement();
        delete element2.domElement;
        delete domElement.__element__;
      });
    }
    function mountElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.reverse();
      elements.forEach((element2) => {
        element2.didMount && element2.didMount();
      });
    }
    function unmountElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.forEach((element2) => {
        element2.willUnmount && element2.willUnmount();
      });
    }
    var _default = {
      constructElement,
      destroyElement,
      mountElement,
      unmountElement
    };
  });

  // node_modules/easy/lib/utilities/dom.js
  var require_dom = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ascendantDOMNodesFromDOMNode() {
        return ascendantDOMNodesFromDOMNode;
      },
      get descendantDOMNodesFromDOMNode() {
        return descendantDOMNodesFromDOMNode;
      },
      get domNodeMatchesSelector() {
        return domNodeMatchesSelector;
      },
      get elementsFromDOMElements() {
        return elementsFromDOMElements;
      },
      get filterDOMNodes() {
        return filterDOMNodes;
      },
      get filterDOMNodesBySelector() {
        return filterDOMNodesBySelector;
      }
    });
    var _array = require_array();
    var _constants = require_constants();
    function elementsFromDOMElements(domElements) {
      const domElementsWithElements = filterDOMNodes(domElements, (domElement) => {
        if (domElement.__element__) {
          return true;
        }
      }), elements = domElementsWithElements.map((domElement) => {
        const element = domElement.__element__;
        return element;
      });
      return elements;
    }
    function ascendantDOMNodesFromDOMNode(domNode, height, ascendantDOMNodes = []) {
      if (height > 0) {
        const parentDOMNode = domNode.parentElement;
        if (parentDOMNode !== null) {
          ascendantDOMNodes.push(parentDOMNode);
          height--;
          ascendantDOMNodesFromDOMNode(parentDOMNode, height, ascendantDOMNodes);
        }
      }
      return ascendantDOMNodes;
    }
    function descendantDOMNodesFromDOMNode(domNode, depth, descendantDOMNodes = []) {
      if (depth > 0) {
        const childDOMNodes = domNode.childNodes;
        (0, _array.push)(descendantDOMNodes, childDOMNodes);
        depth--;
        childDOMNodes.forEach((childDOMNode) => {
          descendantDOMNodesFromDOMNode(childDOMNode, depth, descendantDOMNodes);
        });
      }
      return descendantDOMNodes;
    }
    function filterDOMNodesBySelector(domNodes, selector) {
      const filteredDOMNodes = filterDOMNodes(domNodes, (domNode) => {
        if (domNodeMatchesSelector(domNode, selector)) {
          return true;
        }
      });
      return filteredDOMNodes;
    }
    function domNodeMatchesSelector(domNode, selector) {
      const domNodeType = domNode.nodeType;
      switch (domNodeType) {
        case Node.ELEMENT_NODE: {
          const domElement = domNode;
          return domElement.matches(selector);
        }
        case Node.TEXT_NODE: {
          if (selector === _constants.WILDCARD) {
            return true;
          }
        }
      }
      return false;
    }
    function filterDOMNodes(domNodes, test) {
      const filteredDOMNodes = [], domNodesLength = domNodes.length;
      for (let index = 0; index < domNodesLength; index++) {
        const domNode = domNodes[index], result = test(domNode);
        if (result) {
          filteredDOMNodes.push(domNode);
        }
      }
      return filteredDOMNodes;
    }
  });

  // node_modules/easy/lib/mixins/element.js
  var require_element2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get getAscendantElements() {
        return getAscendantElements;
      },
      get getChildElements() {
        return getChildElements;
      },
      get getDescendantElements() {
        return getDescendantElements;
      },
      get getNextSiblingElement() {
        return getNextSiblingElement;
      },
      get getParentElement() {
        return getParentElement;
      },
      get getPreviousSiblingElement() {
        return getPreviousSiblingElement;
      }
    });
    var _array = require_array();
    var _constants = require_constants();
    var _dom = require_dom();
    function getParentElement(selector = _constants.WILDCARD) {
      let parentElement = null;
      const parentDOMElement = this.domElement.parentElement;
      if (parentDOMElement !== null) {
        if (parentDOMElement.matches(selector)) {
          const parentDOMElements = [
            parentDOMElement
          ], parentElements = (0, _dom.elementsFromDOMElements)(parentDOMElements), firstParentElement = (0, _array.first)(parentElements);
          parentElement = firstParentElement || null;
        }
      }
      return parentElement;
    }
    function getChildElements(selector = _constants.WILDCARD) {
      const childDOMNodes = this.domElement.childNodes, childDOMElements = (0, _dom.filterDOMNodesBySelector)(childDOMNodes, selector), childElements = (0, _dom.elementsFromDOMElements)(childDOMElements);
      return childElements;
    }
    function getAscendantElements(selector = _constants.WILDCARD, maximumHeight = Infinity) {
      const height = maximumHeight, domNode = this.domElement, ascendantDOMNodes = (0, _dom.ascendantDOMNodesFromDOMNode)(domNode, height), ascendantDOMElements = (0, _dom.filterDOMNodesBySelector)(ascendantDOMNodes, selector), ascendantElements = (0, _dom.elementsFromDOMElements)(ascendantDOMElements);
      return ascendantElements;
    }
    function getDescendantElements(selector = _constants.WILDCARD, maximumDepth = Infinity) {
      const depth = maximumDepth, domNode = this.domElement, descendantDOMNodes = (0, _dom.descendantDOMNodesFromDOMNode)(domNode, depth), descendantDOMElements = (0, _dom.filterDOMNodesBySelector)(descendantDOMNodes, selector), descendantElements = (0, _dom.elementsFromDOMElements)(descendantDOMElements);
      return descendantElements;
    }
    function getNextSiblingElement(selector = _constants.WILDCARD) {
      let nextSiblingElement = null;
      const nextSiblingDOMNode = this.domElement.nextSibling;
      if (nextSiblingDOMNode !== null && (0, _dom.domNodeMatchesSelector)(nextSiblingDOMNode, selector)) {
        nextSiblingElement = nextSiblingDOMNode.__element__ || null;
      }
      return nextSiblingElement;
    }
    function getPreviousSiblingElement(selector = _constants.WILDCARD) {
      let previousSiblingElement = null;
      const previousSiblingDOMNode = this.domElement.previousSibling;
      if (previousSiblingDOMNode !== null && (0, _dom.domNodeMatchesSelector)(previousSiblingDOMNode, selector)) {
        previousSiblingElement = previousSiblingDOMNode.__element__ || null;
      }
      return previousSiblingElement;
    }
    var elementMixins = {
      getParentElement,
      getChildElements,
      getAscendantElements,
      getDescendantElements,
      getNextSiblingElement,
      getPreviousSiblingElement
    };
    var _default = elementMixins;
  });

  // node_modules/easy/lib/textElement.js
  var require_textElement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TextElement;
      }
    });
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _element = require_element();
    var _element1 = require_element2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TextElement = class {
      constructor(text) {
        const element = this, domElement = document.createTextNode(text);
        (0, _element.constructElement)(element, domElement);
      }
      getDOMElement() {
        return this.domElement;
      }
      getOffset() {
        const offset = _offset.default.fromDOMElement(this.domElement);
        return offset;
      }
      getBounds() {
        const bounds = _bounds.default.fromDOMElement(this.domElement);
        return bounds;
      }
      getWidth() {
        return this.domElement.offsetWidth;
      }
      getHeight() {
        return this.domElement.offsetHeight;
      }
      getText() {
        const nodeValue = this.domElement.nodeValue, text = nodeValue;
        return text;
      }
      setText(text) {
        const nodeValue = text;
        this.domElement.nodeValue = nodeValue;
      }
      prependTo(parentElement) {
        parentElement.prepend(this);
      }
      appendTo(parentElement) {
        parentElement.append(this);
      }
      addTo(parentElement) {
        parentElement.add(this);
      }
      removeFrom(parentElement) {
        parentElement.remove(this);
      }
      insertBefore(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, siblingDOMElement);
      }
      insertAfter(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, siblingDOMElement.nextSibling);
      }
      remove() {
        this.domElement.remove();
      }
      destroy() {
        const element = this;
        (0, _element.destroyElement)(element);
      }
    };
    Object.assign(TextElement.prototype, {
      getParentElement: _element1.getParentElement,
      getAscendantElements: _element1.getAscendantElements,
      getNextSiblingElement: _element1.getNextSiblingElement,
      getPreviousSiblingElement: _element1.getPreviousSiblingElement
    });
  });

  // node_modules/easy/lib/utilities/elements.js
  var require_elements = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get removeFalseyElements() {
        return removeFalseyElements;
      },
      get replaceStringsWithTextElements() {
        return replaceStringsWithTextElements;
      }
    });
    var _textElement = /* @__PURE__ */ _interop_require_default(require_textElement());
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function removeFalseyElements(elements) {
      elements = elements.reduce((elements2, element) => {
        if (element) {
          elements2.push(element);
        }
        return elements2;
      }, []);
      return elements;
    }
    function replaceStringsWithTextElements(elements) {
      elements = elements.map((element) => {
        if (typeof element === _constants.STRING) {
          const text = element, textElement = new _textElement.default(text);
          element = textElement;
        }
        return element;
      });
      return elements;
    }
  });

  // node_modules/easy/lib/eventTypes.js
  var require_eventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AUXCLICK_EVENT_TYPE() {
        return AUXCLICK_EVENT_TYPE;
      },
      get BLUR_EVENT_TYPE() {
        return BLUR_EVENT_TYPE;
      },
      get CHANGE_EVENT_TYPE() {
        return CHANGE_EVENT_TYPE;
      },
      get CLICK_EVENT_TYPE() {
        return CLICK_EVENT_TYPE;
      },
      get CONTEXTMENU_EVENT_TYPE() {
        return CONTEXTMENU_EVENT_TYPE;
      },
      get COPY_EVENT_TYPE() {
        return COPY_EVENT_TYPE;
      },
      get CUT_EVENT_TYPE() {
        return CUT_EVENT_TYPE;
      },
      get DBLCLICK_EVENT_TYPE() {
        return DBLCLICK_EVENT_TYPE;
      },
      get ERROR_EVENT_TYPE() {
        return ERROR_EVENT_TYPE;
      },
      get FOCUS_EVENT_TYPE() {
        return FOCUS_EVENT_TYPE;
      },
      get FULLSCREENCHANGE_EVENT_TYPE() {
        return FULLSCREENCHANGE_EVENT_TYPE;
      },
      get INPUT_EVENT_TYPE() {
        return INPUT_EVENT_TYPE;
      },
      get KEYDOWN_EVENT_TYPE() {
        return KEYDOWN_EVENT_TYPE;
      },
      get KEYUP_EVENT_TYPE() {
        return KEYUP_EVENT_TYPE;
      },
      get MOUSEDOWN_EVENT_TYPE() {
        return MOUSEDOWN_EVENT_TYPE;
      },
      get MOUSEMOVE_EVENT_TYPE() {
        return MOUSEMOVE_EVENT_TYPE;
      },
      get MOUSEOUT_EVENT_TYPE() {
        return MOUSEOUT_EVENT_TYPE;
      },
      get MOUSEOVER_EVENT_TYPE() {
        return MOUSEOVER_EVENT_TYPE;
      },
      get MOUSEUP_EVENT_TYPE() {
        return MOUSEUP_EVENT_TYPE;
      },
      get PASTE_EVENT_TYPE() {
        return PASTE_EVENT_TYPE;
      },
      get RESIZE_EVENT_TYPE() {
        return RESIZE_EVENT_TYPE;
      },
      get SCROLL_EVENT_TYPE() {
        return SCROLL_EVENT_TYPE;
      },
      get SELECTIONCHANGE_EVENT_TYPE() {
        return SELECTIONCHANGE_EVENT_TYPE;
      },
      get SELECT_EVENT_TYPE() {
        return SELECT_EVENT_TYPE;
      },
      get TOUCHEND_EVENT_TYPE() {
        return TOUCHEND_EVENT_TYPE;
      },
      get TOUCHMOVE_EVENT_TYPE() {
        return TOUCHMOVE_EVENT_TYPE;
      },
      get TOUCHSTART_EVENT_TYPE() {
        return TOUCHSTART_EVENT_TYPE;
      },
      get UNHANDLEDREJECTION_EVENT_TYPE() {
        return UNHANDLEDREJECTION_EVENT_TYPE;
      },
      get WHEEL_EVENT_TYPE() {
        return WHEEL_EVENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var CUT_EVENT_TYPE = "cut";
    var COPY_EVENT_TYPE = "copy";
    var BLUR_EVENT_TYPE = "blur";
    var ERROR_EVENT_TYPE = "error";
    var PASTE_EVENT_TYPE = "paste";
    var WHEEL_EVENT_TYPE = "wheel";
    var INPUT_EVENT_TYPE = "input";
    var FOCUS_EVENT_TYPE = "focus";
    var CLICK_EVENT_TYPE = "click";
    var KEYUP_EVENT_TYPE = "keyup";
    var SELECT_EVENT_TYPE = "select";
    var CHANGE_EVENT_TYPE = "change";
    var RESIZE_EVENT_TYPE = "resize";
    var SCROLL_EVENT_TYPE = "scroll";
    var KEYDOWN_EVENT_TYPE = "keydown";
    var MOUSEUP_EVENT_TYPE = "mouseup";
    var AUXCLICK_EVENT_TYPE = "auxclick";
    var MOUSEOUT_EVENT_TYPE = "mouseout";
    var DBLCLICK_EVENT_TYPE = "dblclick";
    var TOUCHEND_EVENT_TYPE = "touchend";
    var TOUCHMOVE_EVENT_TYPE = "touchmove";
    var MOUSEOVER_EVENT_TYPE = "mouseover";
    var MOUSEDOWN_EVENT_TYPE = "mousedown";
    var MOUSEMOVE_EVENT_TYPE = "mousemove";
    var TOUCHSTART_EVENT_TYPE = "touchstart";
    var CONTEXTMENU_EVENT_TYPE = "contextmenu";
    var SELECTIONCHANGE_EVENT_TYPE = "selectionchange";
    var FULLSCREENCHANGE_EVENT_TYPE = "fullscreenchange";
    var UNHANDLEDREJECTION_EVENT_TYPE = "unhandledrejection";
    var _default = {
      CUT_EVENT_TYPE,
      COPY_EVENT_TYPE,
      BLUR_EVENT_TYPE,
      ERROR_EVENT_TYPE,
      PASTE_EVENT_TYPE,
      WHEEL_EVENT_TYPE,
      INPUT_EVENT_TYPE,
      FOCUS_EVENT_TYPE,
      CLICK_EVENT_TYPE,
      KEYUP_EVENT_TYPE,
      SELECT_EVENT_TYPE,
      CHANGE_EVENT_TYPE,
      RESIZE_EVENT_TYPE,
      SCROLL_EVENT_TYPE,
      KEYDOWN_EVENT_TYPE,
      MOUSEUP_EVENT_TYPE,
      AUXCLICK_EVENT_TYPE,
      MOUSEOUT_EVENT_TYPE,
      DBLCLICK_EVENT_TYPE,
      TOUCHEND_EVENT_TYPE,
      TOUCHMOVE_EVENT_TYPE,
      MOUSEOVER_EVENT_TYPE,
      MOUSEDOWN_EVENT_TYPE,
      MOUSEMOVE_EVENT_TYPE,
      TOUCHSTART_EVENT_TYPE,
      CONTEXTMENU_EVENT_TYPE,
      SELECTIONCHANGE_EVENT_TYPE,
      FULLSCREENCHANGE_EVENT_TYPE,
      UNHANDLEDREJECTION_EVENT_TYPE
    };
  });

  // node_modules/easy/lib/mixins/jsx.js
  var require_jsx = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _array = require_array();
    var _object = require_object();
    var _string = require_string();
    var _name = require_name();
    var _elements = require_elements();
    var _eventTypes = require_eventTypes();
    var _constants = require_constants();
    var DOUBLE_CLICK_EVENT_TYPE = "doubleclick";
    var SELECTION_CHANGE_EVENT_TYPE = "selectionChange";
    var FULL_SCREEN_CHANGE_EVENT_TYPE = "fullScreenChange";
    function applyProperties(properties, defaultProperties, ignoredProperties) {
      this.properties = (0, _object.combine)(properties, defaultProperties);
      properties = (0, _object.prune)(this.properties, ignoredProperties);
      const namespaceURI = this.domElement.namespaceURI, svg = namespaceURI === _constants.SVG_NAMESPACE_URI, propertiesKeys = Object.keys(properties), names = propertiesKeys;
      names.forEach((name) => {
        const value = properties[name], nameHandlerName = isNameHandlerName(name), nameCustomHandlerName = isNameCustomHandlerName(name);
        if (false) {
        } else if (nameHandlerName) {
          addHandler(this, name, value);
        } else if (nameCustomHandlerName) {
          addCustomHandler(this, name, value);
        } else {
          const nameAttributeName = isNameAttributeName(name, svg);
          if (nameAttributeName) {
            addAttribute(this, name, value);
          }
        }
      });
      const childElements = childElementsFromElement(this) || properties.childElements, context2 = {};
      childElements.forEach((childElement) => {
        updateContext(childElement, context2);
        this.add(childElement);
      });
      this.context = context2;
    }
    function getProperties() {
      return this.properties;
    }
    function getContext() {
      return this.context;
    }
    function assignContext(names) {
      if (names === void 0) {
        names = Object.keys(this.context);
      }
      names.forEach((name) => {
        const value = this.context[name], propertyName = name, descriptor = {
          value
        };
        Object.defineProperty(this, propertyName, descriptor);
        delete this.context[name];
      });
    }
    var jsxMixins = {
      applyProperties,
      getProperties,
      getContext,
      assignContext
    };
    var _default = jsxMixins;
    function childElementsFromElement(element) {
      let childElements = null;
      if (typeof element.childElements === _constants.FUNCTION) {
        childElements = element.childElements.call(element);
        childElements = (0, _array.guarantee)(childElements);
        childElements = (0, _elements.removeFalseyElements)(childElements);
        childElements = (0, _elements.replaceStringsWithTextElements)(childElements);
      }
      return childElements;
    }
    function updateContext(childElement, context2) {
      const parentContext = typeof childElement.parentContext === _constants.FUNCTION ? childElement.parentContext() : childElement.context;
      Object.assign(context2, parentContext);
    }
    function addHandler(element, name, value) {
      let eventType = name.substring(2).toLowerCase();
      switch (eventType) {
        case DOUBLE_CLICK_EVENT_TYPE: {
          eventType = _eventTypes.DBLCLICK_EVENT_TYPE;
          break;
        }
        case SELECTION_CHANGE_EVENT_TYPE: {
          eventType = _eventTypes.SELECTIONCHANGE_EVENT_TYPE;
          break;
        }
        case FULL_SCREEN_CHANGE_EVENT_TYPE: {
          eventType = _eventTypes.FULLSCREENCHANGE_EVENT_TYPE;
          break;
        }
      }
      const handler = value;
      element.onEvent(eventType, handler);
    }
    function addCustomHandler(element, name, value) {
      const customEventType = (0, _string.camelCaseToSnakeCase)(name).replace(/on-custom-/, ""), customHandler = value;
      element.onCustomEvent(customEventType, customHandler);
    }
    function addAttribute(element, name, value) {
      if (name === _constants.CLASS_NAME) {
        name = _constants.CLASS;
      }
      if (name === _constants.HTML_FOR) {
        name = _constants.FOR;
      }
      if (typeof value === _constants.OBJECT) {
        const keys = Object.keys(value);
        keys.forEach((key) => {
          element.domElement[name][key] = value[key];
        });
      } else if (typeof value === _constants.BOOLEAN) {
        if (value) {
          value = name;
          element.addAttribute(name, value);
        }
      } else {
        element.addAttribute(name, value);
      }
    }
    function isNameHandlerName(name) {
      const nameHandlerName = /^on(?!Custom)/.test(name);
      return nameHandlerName;
    }
    function isNameAttributeName(name, svg) {
      const nameAttributeName = svg ? (0, _name.isSVGAttributeName)(name) : (0, _name.isHTMLAttributeName)(name);
      return nameAttributeName;
    }
    function isNameCustomHandlerName(name) {
      const nameCustomHandlerName = /^onCustom/.test(name);
      return nameCustomHandlerName;
    }
  });

  // node_modules/easy/lib/mixins/key.js
  var require_key = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onKeyUp(keyUpHandler, element) {
      this.onEvent(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function offKeyUp(keyUpHandler, element) {
      this.offEvent(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function onKeyDown(keyDownHandler, element) {
      this.onEvent(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    function offKeyDown(keyDownHandler, element) {
      this.offEvent(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    var keyMixins = {
      onKeyUp,
      offKeyUp,
      onKeyDown,
      offKeyDown
    };
    var _default = keyMixins;
  });

  // node_modules/easy/lib/mixins/state.js
  var require_state = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    function getState() {
      return this.state;
    }
    function setState(state) {
      this.state = state;
    }
    function updateState(state) {
      this.state === void 0 ? this.state = state : Object.assign(this.state, state);
    }
    var stateMixins = {
      getState,
      setState,
      updateState
    };
    var _default = stateMixins;
  });

  // node_modules/easy/lib/mixins/event.js
  var require_event = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    function onEvent(eventTypes, handler, element = this) {
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach((eventType) => {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          const resizeEventListeners = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            this.resizeObserver = new ResizeObserver((entries) => {
              const resizeEventListeners2 = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE);
              resizeEventListeners2.forEach((resizeEventListener) => {
                const event = null;
                resizeEventListener(event);
              });
            });
            this.resizeObserver.observe(this.domElement);
          }
          this.addEventListener(eventType, handler, element);
        } else {
          const eventListener = this.addEventListener(eventType, handler, element);
          this.domElement.addEventListener(eventType, eventListener);
        }
      });
    }
    function offEvent(eventTypes, handler, element = this) {
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach((eventType) => {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          this.removeEventListener(eventType, handler, element);
          const resizeEventListeners = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            this.resizeObserver.unobserve(this.domElement);
            delete this.resizeObserver;
          }
        } else {
          const eventListener = this.removeEventListener(eventType, handler, element);
          this.domElement.removeEventListener(eventType, eventListener);
        }
      });
    }
    function addEventListener(eventType, handler, element) {
      const eventListener = this.createEventListener(eventType, handler, element);
      if (!this.eventListeners) {
        this.eventListeners = [];
      }
      this.eventListeners.push(eventListener);
      return eventListener;
    }
    function removeEventListener(eventType, handler, element) {
      const eventListener = this.findEventListener(eventType, handler, element), index = this.eventListeners.indexOf(eventListener), start = index, deleteCount = 1;
      this.eventListeners.splice(start, deleteCount);
      if (this.eventListeners.length === 0) {
        delete this.eventListeners;
      }
      return eventListener;
    }
    function findEventListener(eventType, handler, element) {
      const eventListener = this.eventListeners.find((eventListener2) => {
        if (eventListener2.element === element && eventListener2.handler === handler && eventListener2.eventType === eventType) {
          return true;
        }
      });
      return eventListener;
    }
    function findEventListeners(eventType) {
      const eventListeners = [];
      if (this.eventListeners) {
        this.eventListeners.forEach((eventListener) => {
          const found = eventListener.eventType === eventType;
          if (found) {
            eventListeners.push(eventListener);
          }
        });
      }
      return eventListeners;
    }
    function createEventListener(eventType, handler, element) {
      let eventListener;
      const handlerElement = element;
      eventListener = (event) => {
        const element2 = this;
        handler.call(handlerElement, event, element2);
      };
      Object.assign(eventListener, {
        element,
        handler,
        eventType
      });
      return eventListener;
    }
    var eventMixins = {
      onEvent,
      offEvent,
      addEventListener,
      removeEventListener,
      findEventListener,
      findEventListeners,
      createEventListener
    };
    var _default = eventMixins;
  });

  // node_modules/easy/lib/mixins/mouse.js
  var require_mouse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onMouseUp(mouseUpHandler, element) {
      this.onEvent(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function offMouseUp(mouseUpHandler, element) {
      this.offEvent(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function onMouseOut(mouseOutHandler, element) {
      this.onEvent(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function offMouseOut(mouseOutHandler, element) {
      this.offEvent(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function onMouseDown(mouseDownHandler, element) {
      this.onEvent(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function offMouseDown(mouseDownHandler, element) {
      this.offEvent(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function onMouseOver(mouseOverHandler, element) {
      this.onEvent(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function offMouseOver(mouseOverHandler, element) {
      this.offEvent(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function onMouseMove(mouseMoveHandler, element) {
      this.onEvent(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    function offMouseMove(mouseMoveHandler, element) {
      this.offEvent(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    var mouseMixins = {
      onMouseUp,
      offMouseUp,
      onMouseOut,
      offMouseOut,
      onMouseDown,
      offMouseDown,
      onMouseOver,
      offMouseOver,
      onMouseMove,
      offMouseMove
    };
    var _default = mouseMixins;
  });

  // node_modules/easy/lib/mixins/click.js
  var require_click = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onClick(clickHandler, element) {
      this.onEvent(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function offClick(clickHandler, element) {
      this.offEvent(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function onAuxClick(auxClickHandler, element) {
      this.onEvent(_eventTypes.AUXCLICK_EVENT_TYPE, auxClickHandler, element);
    }
    function offAuxClick(auxClickHandler, element) {
      this.offEvent(_eventTypes.AUXCLICK_EVENT_TYPE, auxClickHandler, element);
    }
    function onDoubleClick(doubleClickHandler, element) {
      this.onEvent(_eventTypes.DBLCLICK_EVENT_TYPE, doubleClickHandler, element);
    }
    function offDoubleClick(doubleClickHandler, element) {
      this.offEvent(_eventTypes.DBLCLICK_EVENT_TYPE, doubleClickHandler, element);
    }
    var clickMixins = {
      onClick,
      offClick,
      onAuxClick,
      offAuxClick,
      onDoubleClick,
      offDoubleClick
    };
    var _default = clickMixins;
  });

  // node_modules/easy/lib/mixins/touch.js
  var require_touch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onTouchStart(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHSTART_EVENT_TYPE, touchStartHandler);
    }
    function offTouchStart(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHSTART_EVENT_TYPE, touchStartHandler);
    }
    function onTouchMove(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHMOVE_EVENT_TYPE, touchStartHandler);
    }
    function offTouchMove(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHMOVE_EVENT_TYPE, touchStartHandler);
    }
    function onTouchEnd(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHEND_EVENT_TYPE, touchStartHandler);
    }
    function offTouchEnd(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHEND_EVENT_TYPE, touchStartHandler);
    }
    var clickMixins = {
      onTouchStart,
      offTouchStart,
      onTouchMove,
      offTouchMove,
      onTouchEnd,
      offTouchEnd
    };
    var _default = clickMixins;
  });

  // node_modules/easy/lib/mixins/scroll.js
  var require_scroll = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get offScroll() {
        return offScroll;
      },
      get onScroll() {
        return onScroll;
      }
    });
    var _eventTypes = require_eventTypes();
    function onScroll(scrollHandler, element) {
      this.onEvent(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function offScroll(scrollHandler, element) {
      this.offEvent(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function scrollTo(scrollTop, scrollLeft) {
      this.domElement.scrollTo(scrollLeft, scrollTop);
    }
    function getScrollTop() {
      return this.domElement.scrollTop;
    }
    function getScrollLeft() {
      return this.domElement.scrollLeft;
    }
    function getScrollWidth() {
      return this.domElement.scrollWidth;
    }
    function getScrollHeight() {
      return this.domElement.scrollHeight;
    }
    function setScrollTop(scrollTop) {
      this.domElement.scrollTop = scrollTop;
    }
    function setScrollLeft(scrollLeft) {
      this.domElement.scrollLeft = scrollLeft;
    }
    var scrollMixins = {
      onScroll,
      offScroll,
      scrollTo,
      getScrollTop,
      getScrollLeft,
      getScrollWidth,
      getScrollHeight,
      setScrollTop,
      setScrollLeft
    };
    var _default = scrollMixins;
  });

  // node_modules/easy/lib/mixins/resize.js
  var require_resize = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onResize(resizeHandler, element) {
      this.onEvent(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    function offResize(resizeHandler, element) {
      this.offEvent(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    var resizeMixins = {
      onResize,
      offResize
    };
    var _default = resizeMixins;
  });

  // node_modules/easy/lib/mixins/fullScreen.js
  var require_fullScreen = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onFullScreenChange(fullScreenChangeHandler, element) {
      this.onEvent(_eventTypes.FULLSCREENCHANGE_EVENT_TYPE, fullScreenChangeHandler, element);
    }
    function offFullScreenChange(fullScreenChangeHandler, element) {
      this.offEvent(_eventTypes.FULLSCREENCHANGE_EVENT_TYPE, fullScreenChangeHandler, element);
    }
    function requestFullScreen(errorHandler) {
      const domElement = this.getDOMElement();
      domElement.requestFullscreen().catch(errorHandler);
    }
    function exitFullScreen() {
      document.exitFullscreen();
    }
    function isFullScreen() {
      const {fullscreenElement} = document, fullScreen = fullscreenElement !== null;
      return fullScreen;
    }
    var fullscreenMixins = {
      onFullScreenChange,
      offFullScreenChange,
      requestFullScreen,
      exitFullScreen,
      isFullScreen
    };
    var _default = fullscreenMixins;
  });

  // node_modules/easy/lib/utilities/async.js
  var require_async = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "forEach", {
      enumerable: true,
      get: function() {
        return forEach;
      }
    });
    function forEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
  });

  // node_modules/easy/lib/mixins/customEvent.js
  var require_customEvent = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants();
    var _async = require_async();
    function onCustomEvent(customEventTypes, customHandler, element = this) {
      customEventTypes = customEventTypes.split(_constants.SPACE);
      customEventTypes.forEach((customEventType) => {
        this.addCustomEventListener(customEventType, customHandler, element);
      });
    }
    function offCustomEvent(customEventTypes, customHandler, element = this) {
      customEventTypes = customEventTypes.split(_constants.SPACE);
      customEventTypes.forEach((customEventType) => {
        this.removeCustomEventListener(customEventType, customHandler, element);
      });
    }
    function callCustomHandlers(customEventType, ...remainingArguments) {
      const customEventListeners = this.findCustomEventListeners(customEventType);
      customEventListeners.forEach((customEventListener) => {
        const {customHandler, element: customHandlerElement} = customEventListener;
        customHandler.call(customHandlerElement, ...remainingArguments);
      });
    }
    function callCustomHandlersAsync(customEventType, ...remainingArguments) {
      const customEventListeners = this.findCustomEventListeners(customEventType), done = remainingArguments.pop();
      (0, _async.forEach)(customEventListeners, (customEventListener, next) => {
        const {customHandler, element: customHandlerElement} = customEventListener, done2 = next;
        customHandler.call(customHandlerElement, ...remainingArguments, done2);
      }, done);
    }
    function addCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.createCustomEventListener(customEventType, customHandler, element);
      if (!this.customEventListeners) {
        this.customEventListeners = [];
      }
      this.customEventListeners.push(customEventListener);
      return customEventListener;
    }
    function removeCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.findCustomEventListener(customEventType, customHandler, element), index = this.customEventListeners.indexOf(customEventListener), start = index, deleteCount = 1;
      this.customEventListeners.splice(start, deleteCount);
      if (this.customEventListeners.length === 0) {
        delete this.customEventListeners;
      }
      return customEventListener;
    }
    function findCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.customEventListeners.find((customEventListener2) => {
        if (customEventListener2.element === element && customEventListener2.customHandler === customHandler && customEventListener2.customEventType === customEventType) {
          return true;
        }
      });
      return customEventListener;
    }
    function findCustomEventListeners(customEventType) {
      const customEventListeners = [];
      if (this.customEventListeners) {
        this.customEventListeners.forEach((customEventListener) => {
          const found = customEventListener.customEventType === customEventType;
          if (found) {
            customEventListeners.push(customEventListener);
          }
        });
      }
      return customEventListeners;
    }
    function createCustomEventListener(customEventType, customHandler, element) {
      let customEventListener;
      customEventListener = () => {
      };
      Object.assign(customEventListener, {
        element,
        customHandler,
        customEventType
      });
      return customEventListener;
    }
    var customEventMixins = {
      onCustomEvent,
      offCustomEvent,
      callCustomHandlers,
      callCustomHandlersAsync,
      addCustomEventListener,
      removeCustomEventListener,
      findCustomEventListener,
      findCustomEventListeners,
      createCustomEventListener
    };
    var _default = customEventMixins;
  });

  // node_modules/easy/lib/element.js
  var require_element3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Element;
      }
    });
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _jsx = /* @__PURE__ */ _interop_require_default(require_jsx());
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _state = /* @__PURE__ */ _interop_require_default(require_state());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _touch = /* @__PURE__ */ _interop_require_default(require_touch());
    var _scroll = /* @__PURE__ */ _interop_require_default(require_scroll());
    var _resize = /* @__PURE__ */ _interop_require_default(require_resize());
    var _element = /* @__PURE__ */ _interop_require_default(require_element2());
    var _fullScreen = /* @__PURE__ */ _interop_require_default(require_fullScreen());
    var _customEvent = /* @__PURE__ */ _interop_require_default(require_customEvent());
    var _array = require_array();
    var _object = require_object();
    var _name = require_name();
    var _element1 = require_element();
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Element = class {
      constructor(selector) {
        if (selector !== null) {
          const element = this, domElement = document.querySelector(selector);
          (0, _element1.constructElement)(element, domElement);
        }
      }
      getDOMElement() {
        return this.domElement;
      }
      getOffset() {
        const offset = _offset.default.fromDOMElement(this.domElement);
        return offset;
      }
      getBounds() {
        const bounds = _bounds.default.fromDOMElement(this.domElement);
        return bounds;
      }
      getWidth() {
        return this.domElement.offsetWidth;
      }
      getHeight() {
        return this.domElement.offsetHeight;
      }
      getInnerWidth() {
        return this.domElement.clientWidth;
      }
      getInnerHeight() {
        return this.domElement.clientHeight;
      }
      setWidth(width) {
        width = `${width}px`;
        this.style(_constants.WIDTH, width);
      }
      setHeight(height) {
        height = `${height}px`;
        this.style(_constants.HEIGHT, height);
      }
      hasAttribute(name) {
        return this.domElement.hasAttribute(name);
      }
      getAttribute(name) {
        return this.domElement.getAttribute(name);
      }
      setAttribute(name, value) {
        this.domElement.setAttribute(name, value);
      }
      clearAttribute(name) {
        this.domElement.removeAttribute(name);
      }
      addAttribute(name, value) {
        this.setAttribute(name, value);
      }
      removeAttribute(name) {
        this.clearAttribute(name);
      }
      hasClass(className) {
        return this.domElement.classList.contains(className);
      }
      setClass(className) {
        this.domElement.className = className;
      }
      addClass(className) {
        this.domElement.classList.add(className);
      }
      removeClass(className) {
        this.domElement.classList.remove(className);
      }
      toggleClass(className) {
        this.domElement.classList.toggle(className);
      }
      removeAllClasses() {
        this.domElement.className = _constants.EMPTY_STRING;
      }
      addTo(parentElement) {
        parentElement.add(this);
      }
      appendTo(parentElement) {
        parentElement.append(this);
      }
      prependTo(parentElement) {
        parentElement.prepend(this);
      }
      removeFrom(parentElement) {
        parentElement.remove(this);
      }
      insert(element) {
        this.append(element);
      }
      add(element) {
        this.append(element);
      }
      remove(element) {
        if (element) {
          element.remove();
          return;
        }
        this.domElement.remove();
      }
      prepend(element) {
        const domElement = element.domElement, referenceDOMElement = this.domElement.firstChild;
        this.domElement.insertBefore(domElement, referenceDOMElement);
      }
      append(element) {
        const domElement = element.domElement, referenceDOMElement = null;
        this.domElement.insertBefore(domElement, referenceDOMElement);
      }
      insertBefore(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, referenceDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, referenceDOMElement);
      }
      insertAfter(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, referenceDOMElement = siblingElement.domElement.nextSibling;
        parentDOMNode.insertBefore(this.domElement, referenceDOMElement);
      }
      mount(element) {
        this.add(element);
        (0, _element1.mountElement)(element);
      }
      unmount(element) {
        (0, _element1.unmountElement)(element);
        this.remove(element);
      }
      mountBefore(siblingElement) {
        this.insertBefore(siblingElement);
        const element = this;
        (0, _element1.mountElement)(element);
      }
      mountAfter(siblingElement) {
        this.insertAfter(siblingElement);
        const element = this;
        (0, _element1.mountElement)(element);
      }
      show(displayStyle = _constants.BLOCK) {
        this.display(displayStyle);
      }
      hide() {
        this.style(_constants.DISPLAY, _constants.NONE);
      }
      display(display) {
        this.style(_constants.DISPLAY, display);
      }
      enable() {
        this.clearAttribute(_constants.DISABLED);
      }
      disable() {
        this.setAttribute(_constants.DISABLED, _constants.DISABLED);
      }
      isEnabled() {
        const disabled = this.isDisabled(), enabled = !disabled;
        return enabled;
      }
      isDisabled() {
        const disabled = this.hasAttribute(_constants.DISABLED);
        return disabled;
      }
      isDisplayed() {
        const display = this.css(_constants.DISPLAY), displayed = display !== _constants.NONE;
        return displayed;
      }
      isShowing() {
        const displayed = this.isDisplayed(), showing = displayed;
        return showing;
      }
      isHidden() {
        const displayed = this.isDisplayed(), hidden = !displayed;
        return hidden;
      }
      style(name, value = null) {
        if (value !== null) {
          this.domElement.style[name] = value;
          return;
        }
        const style = this.domElement.style[name];
        return style;
      }
      html(html = null) {
        if (html !== null) {
          const innerHTML2 = html;
          this.domElement.innerHTML = innerHTML2;
          return;
        }
        const innerHTML = this.domElement.innerHTML;
        html = innerHTML;
        return html;
      }
      css(css = null) {
        if (css === null) {
          css = {};
          const computedStyles = getComputedStyle(this.domElement);
          for (let index = 0; index < computedStyles.length; index++) {
            const computedStyle = computedStyles[index], name = computedStyle, value = computedStyles.getPropertyValue(name);
            css[name] = value;
          }
        } else if (typeof css === _constants.STRING) {
          let name = css;
          const computedStyles = getComputedStyle(this.domElement), value = computedStyles.getPropertyValue(name);
          css = value;
        } else {
          const names = Object.keys(css);
          names.forEach((name) => {
            const value = css[name];
            this.style(name, value);
          });
        }
        return css;
      }
      destroy() {
        const element = this;
        (0, _element1.destroyElement)(element);
      }
      static fromClass(Class, properties, ...remainingArguments) {
        const {tagName} = Class, element = elementFromTagName(Class, tagName, ...remainingArguments), defaultProperties = defaultPropertiesFromClass(Class), ignoredProperties = ignoredPropertiesFromClass(Class);
        element.applyProperties(properties, defaultProperties, ignoredProperties);
        element.initialise && element.initialise();
        return element;
      }
      static fromTagName(tagName, properties, ...remainingArguments) {
        const Class = Element, element = elementFromTagName(Class, tagName, ...remainingArguments), defaultProperties = {}, ignoredProperties = [];
        element.applyProperties(properties, defaultProperties, ignoredProperties);
        element.initialise && element.initialise();
        return element;
      }
    };
    Object.assign(Element.prototype, _jsx.default);
    Object.assign(Element.prototype, _key.default);
    Object.assign(Element.prototype, _mouse.default);
    Object.assign(Element.prototype, _click.default);
    Object.assign(Element.prototype, _state.default);
    Object.assign(Element.prototype, _event.default);
    Object.assign(Element.prototype, _touch.default);
    Object.assign(Element.prototype, _scroll.default);
    Object.assign(Element.prototype, _resize.default);
    Object.assign(Element.prototype, _element.default);
    Object.assign(Element.prototype, _fullScreen.default);
    Object.assign(Element.prototype, _customEvent.default);
    function elementFromTagName(Class, tagName, ...remainingArguments) {
      const selector = null, element = new (Function.prototype.bind.call(Class, null, selector, ...remainingArguments))(), domElement = (0, _name.isSVGTagName)(tagName) ? document.createElementNS(_constants.SVG_NAMESPACE_URI, tagName) : document.createElement(tagName);
      (0, _element1.constructElement)(element, domElement);
      return element;
    }
    function defaultPropertiesFromClass(Class, defaultProperties = {}) {
      if (Class.hasOwnProperty(_constants.DEFAULT_PROPERTIES)) {
        defaultProperties = (0, _object.combine)(defaultProperties, Class[_constants.DEFAULT_PROPERTIES]);
      }
      const superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        defaultProperties = defaultPropertiesFromClass(superClass, defaultProperties);
      }
      return defaultProperties;
    }
    function ignoredPropertiesFromClass(Class, ignoredProperties = []) {
      if (Class.hasOwnProperty(_constants.IGNORED_PROPERTIES)) {
        ignoredProperties = (0, _array.augment)(ignoredProperties, Class[_constants.IGNORED_PROPERTIES], (ignoredProperty) => {
          if (!ignoredProperties.includes(ignoredProperty)) {
            return true;
          }
        });
      }
      const superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        ignoredProperties = ignoredPropertiesFromClass(superClass, ignoredProperties);
      }
      return ignoredProperties;
    }
  });

  // node_modules/easy/lib/react.js
  var require_react = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _array = require_array();
    var _constants = require_constants();
    var _elements = require_elements();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createElement(firstArgument, properties, ...childElements) {
      let element = null;
      if (firstArgument) {
        childElements = sanitiseChildElements(childElements);
        properties = Object.assign({
          childElements
        }, properties);
        if (false) {
        } else if (isSubclassOf(firstArgument, _element.default)) {
          const Class = firstArgument;
          element = Class.fromClass(Class, properties);
        } else if (typeof firstArgument === _constants.STRING) {
          const tagName = firstArgument;
          element = _element.default.fromTagName(tagName, properties);
        } else if (typeof firstArgument === _constants.FUNCTION) {
          const elementFunction = firstArgument;
          element = elementFunction(properties);
        }
      }
      return element;
    }
    var React2 = {
      createElement
    };
    var _default = React2;
    function sanitiseChildElements(childElements) {
      childElements = (0, _array.flatten)(childElements);
      childElements = (0, _elements.removeFalseyElements)(childElements);
      childElements = (0, _elements.replaceStringsWithTextElements)(childElements);
      return childElements;
    }
    function isSubclassOf(argument, Class) {
      const subclassOf = argument.prototype instanceof Class;
      return subclassOf;
    }
  });

  // node_modules/easy/lib/mouseButtons.js
  var require_mouseButtons = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get LEFT_MOUSE_BUTTON() {
        return LEFT_MOUSE_BUTTON;
      },
      get MIDDLE_MOUSE_BUTTON() {
        return MIDDLE_MOUSE_BUTTON;
      },
      get RIGHT_MOUSE_BUTTON() {
        return RIGHT_MOUSE_BUTTON;
      },
      get default() {
        return _default;
      }
    });
    var LEFT_MOUSE_BUTTON = 0;
    var RIGHT_MOUSE_BUTTON = 2;
    var MIDDLE_MOUSE_BUTTON = 1;
    var _default = {
      LEFT_MOUSE_BUTTON,
      RIGHT_MOUSE_BUTTON,
      MIDDLE_MOUSE_BUTTON
    };
  });

  // node_modules/easy/lib/mixins/input.js
  var require_input = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onInput(inputHandler, element) {
      this.onEvent(_eventTypes.INPUT_EVENT_TYPE, inputHandler, element);
    }
    function offInput(inputHandler, element) {
      this.offEvent(_eventTypes.INPUT_EVENT_TYPE, inputHandler, element);
    }
    function onChange(changeHandler, element) {
      this.onEvent(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function offChange(changeHandler, element) {
      this.offEvent(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function getValue() {
      return this.domElement.value;
    }
    function setValue(value) {
      this.domElement.value = value;
    }
    function isReadOnly() {
      return this.domElement.readOnly;
    }
    function setReadOnly(readOnly) {
      this.domElement.readOnly = readOnly;
    }
    var inputMixins = {
      onInput,
      offInput,
      onChange,
      offChange,
      getValue,
      setValue,
      isReadOnly,
      setReadOnly
    };
    var _default = inputMixins;
  });

  // node_modules/easy/lib/mixins/focus.js
  var require_focus = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onBlur(blurHandler, element) {
      this.onEvent(_eventTypes.BLUR_EVENT_TYPE, blurHandler, element);
    }
    function offBlur(blurHandler, element) {
      this.offEvent(_eventTypes.BLUR_EVENT_TYPE, blurHandler, element);
    }
    function onFocus(focusHandler, element) {
      this.onEvent(_eventTypes.FOCUS_EVENT_TYPE, focusHandler, element);
    }
    function offFocus(focusHandler, element) {
      this.offEvent(_eventTypes.FOCUS_EVENT_TYPE, focusHandler, element);
    }
    function blur() {
      this.domElement.blur();
    }
    function focus() {
      this.domElement.focus();
    }
    function hasFocus() {
      const focus2 = document.activeElement === this.domElement;
      return focus2;
    }
    var focusMixins = {
      onBlur,
      offBlur,
      onFocus,
      offFocus,
      blur,
      focus,
      hasFocus
    };
    var _default = focusMixins;
  });

  // node_modules/easy/lib/mixins/selection.js
  var require_selection = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onCut(cutHandler, element) {
      this.onEvent(_eventTypes.CUT_EVENT_TYPE, cutHandler, element);
    }
    function offCut(cutHandler, element) {
      this.offEvent(_eventTypes.CUT_EVENT_TYPE, cutHandler, element);
    }
    function onCopy(copyHandler, element) {
      this.onEvent(_eventTypes.COPY_EVENT_TYPE, copyHandler, element);
    }
    function offCopy(copyHandler, element) {
      this.offEvent(_eventTypes.COPY_EVENT_TYPE, copyHandler, element);
    }
    function onPaste(pasteHandler, element) {
      this.onEvent(_eventTypes.PASTE_EVENT_TYPE, pasteHandler, element);
    }
    function offPaste(pasteHandler, element) {
      this.offEvent(_eventTypes.PASTE_EVENT_TYPE, pasteHandler, element);
    }
    function getSelectionStart() {
      return this.domElement.selectionStart;
    }
    function getSelectionEnd() {
      return this.domElement.selectionEnd;
    }
    function setSelectionStart(selectionStart) {
      this.domElement.selectionStart = selectionStart;
    }
    function setSelectionEnd(selectionEnd) {
      this.domElement.selectionEnd = selectionEnd;
    }
    function select() {
      this.domElement.select();
    }
    var selectionMixins = {
      onCut,
      offCut,
      onCopy,
      offCopy,
      onPaste,
      offPaste,
      getSelectionStart,
      getSelectionEnd,
      setSelectionStart,
      setSelectionEnd,
      select
    };
    var _default = selectionMixins;
  });

  // node_modules/easy/lib/document.js
  var require_document = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Document = class {
      constructor() {
        this.domElement = document;
      }
      getDOMElement() {
        return this.domElement;
      }
      getSelection() {
        return this.domElement.getSelection();
      }
      createRange() {
        return this.domElement.createRange();
      }
      createTextNode(data) {
        return this.domElement.createTextNode(data);
      }
      onSelectionChange(selectionChangeHandler, element) {
        this.onEvent(_eventTypes.SELECTIONCHANGE_EVENT_TYPE, selectionChangeHandler, element);
      }
      offSelectionChange(selectionChangeHandler, element) {
        this.offEvent(_eventTypes.SELECTIONCHANGE_EVENT_TYPE, selectionChangeHandler, element);
      }
      createEventListener(eventType, handler, element) {
        let eventListener;
        const handlerElement = element;
        eventListener = (event) => {
          if (eventType === _eventTypes.SELECTIONCHANGE_EVENT_TYPE) {
            const {domElement} = handlerElement, {currentTarget} = event, {activeElement} = currentTarget;
            if (domElement !== activeElement) {
              return;
            }
          }
          const element2 = this;
          handler.call(handlerElement, event, element2);
        };
        Object.assign(eventListener, {
          element,
          handler,
          eventType
        });
        return eventListener;
      }
    };
    Object.assign(Document.prototype, _key.default);
    Object.assign(Document.prototype, _event.default);
    Object.assign(Document.prototype, _mouse.default);
    Object.assign(Document.prototype, _click.default);
    var _default = typeof document === _constants.UNDEFINED ? void 0 : new Document();
  });

  // node_modules/easy/lib/window.js
  var require_window = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    var _scroll = require_scroll();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Window = class {
      constructor() {
        this.domElement = window;
      }
      getDOMElement() {
        return this.domElement;
      }
      assign(...sources) {
        const target = this.domElement;
        Object.assign(target, ...sources);
      }
      reload() {
        window.location.reload();
      }
      getWidth() {
        return this.domElement.innerWidth;
      }
      getHeight() {
        return this.domElement.innerHeight;
      }
      getScrollTop() {
        return this.domElement.pageYOffset;
      }
      getScrollLeft() {
        return this.domElement.pageXOffset;
      }
      getSelection() {
        return this.domElement.getSelection();
      }
      getScreenWidth() {
        return this.domElement.screen.width;
      }
      getScreenHeight() {
        return this.domElement.screen.height;
      }
      scrollTo(scrollTop, scrollLeft) {
        this.domElement.scrollTo(scrollLeft, scrollTop);
      }
      onResize(resizeHandler, element) {
        const eventType = _eventTypes.RESIZE_EVENT_TYPE, eventListener = this.addEventListener(eventType, resizeHandler, element);
        this.domElement.addEventListener(eventType, eventListener);
      }
      offResize(resizeHandler, element) {
        const eventType = _eventTypes.RESIZE_EVENT_TYPE, eventListener = this.removeEventListener(eventType, resizeHandler, element);
        this.domElement.removeEventListener(eventType, eventListener);
      }
    };
    Object.assign(Window.prototype, _key.default);
    Object.assign(Window.prototype, _event.default);
    Object.assign(Window.prototype, _mouse.default);
    Object.assign(Window.prototype, _click.default);
    Object.assign(Window.prototype, _focus.default);
    Object.assign(Window.prototype, {
      onScroll: _scroll.onScroll,
      offScroll: _scroll.offScroll
    });
    var _default = typeof window === _constants.UNDEFINED ? void 0 : new Window();
  });

  // node_modules/easy/lib/element/body.js
  var require_body = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Body;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Body = class extends _element.default {
      constructor(selector = _constants.BODY) {
        super(selector);
      }
    };
    __publicField(Body, "tagName", "body");
  });

  // node_modules/easy/lib/element/link.js
  var require_link = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Link;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Link = class extends _element.default {
      getHRef() {
        return this.getAttribute("href");
      }
      setHRef(href) {
        return this.setAttribute("href", href);
      }
    };
    __publicField(Link, "tagName", "a");
    Object.assign(Link.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/input.js
  var require_input2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Input;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Input = class extends _element.default {
    };
    __publicField(Input, "tagName", "input");
    Object.assign(Input.prototype, _input.default);
    Object.assign(Input.prototype, _focus.default);
    Object.assign(Input.prototype, _selection.default);
  });

  // node_modules/easy/lib/element/button.js
  var require_button = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Button;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Button = class extends _element.default {
    };
    __publicField(Button, "tagName", "button");
    Object.assign(Button.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/select.js
  var require_select = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Select;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Select = class extends _element.default {
    };
    __publicField(Select, "tagName", "select");
    Object.assign(Select.prototype, _input.default);
    Object.assign(Select.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/checkbox.js
  var require_checkbox = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Checkbox;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Checkbox = class extends _element.default {
      isChecked() {
        return this.domElement.checked;
      }
      check(checked = true) {
        this.domElement.checked = checked;
      }
    };
    __publicField(Checkbox, "tagName", "input");
    __publicField(Checkbox, "defaultProperties", {
      type: "checkbox"
    });
    Object.assign(Checkbox.prototype, _input.default);
    Object.assign(Checkbox.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/textarea.js
  var require_textarea = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Textarea;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Textarea = class extends _element.default {
    };
    __publicField(Textarea, "tagName", "textarea");
    Object.assign(Textarea.prototype, _input.default);
    Object.assign(Textarea.prototype, _focus.default);
    Object.assign(Textarea.prototype, _selection.default);
  });

  // node_modules/easy/lib/index.js
  var require_lib = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Body() {
        return _body.default;
      },
      get Bounds() {
        return _bounds.default;
      },
      get Button() {
        return _button.default;
      },
      get Checkbox() {
        return _checkbox.default;
      },
      get Element() {
        return _element1.default;
      },
      get Input() {
        return _input1.default;
      },
      get Link() {
        return _link.default;
      },
      get Offset() {
        return _offset.default;
      },
      get React() {
        return _react.default;
      },
      get Select() {
        return _select.default;
      },
      get TextElement() {
        return _textElement.default;
      },
      get Textarea() {
        return _textarea.default;
      },
      get customEventMixins() {
        return _customEvent.default;
      },
      get document() {
        return _document.default;
      },
      get elementUtilities() {
        return _element.default;
      },
      get eventTypes() {
        return _eventTypes.default;
      },
      get focusMixins() {
        return _focus.default;
      },
      get inputMixins() {
        return _input.default;
      },
      get mouseButtons() {
        return _mouseButtons.default;
      },
      get selectionMixins() {
        return _selection.default;
      },
      get window() {
        return _window.default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_default(require_react());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _eventTypes = /* @__PURE__ */ _interop_require_default(require_eventTypes());
    var _mouseButtons = /* @__PURE__ */ _interop_require_default(require_mouseButtons());
    var _element = /* @__PURE__ */ _interop_require_default(require_element());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    var _customEvent = /* @__PURE__ */ _interop_require_default(require_customEvent());
    var _element1 = /* @__PURE__ */ _interop_require_default(require_element3());
    var _textElement = /* @__PURE__ */ _interop_require_default(require_textElement());
    var _document = /* @__PURE__ */ _interop_require_default(require_document());
    var _window = /* @__PURE__ */ _interop_require_default(require_window());
    var _body = /* @__PURE__ */ _interop_require_default(require_body());
    var _link = /* @__PURE__ */ _interop_require_default(require_link());
    var _input1 = /* @__PURE__ */ _interop_require_default(require_input2());
    var _button = /* @__PURE__ */ _interop_require_default(require_button());
    var _select = /* @__PURE__ */ _interop_require_default(require_select());
    var _checkbox = /* @__PURE__ */ _interop_require_default(require_checkbox());
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/juxtapose/lib/juxtapose.js
  var require_juxtapose = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _easy = require_lib();
    Object.assign(globalThis, {
      React: _easy.React
    });
  });

  // node_modules/juxtapose/lib/index.js
  var require_lib2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_juxtapose();
  });

  // node_modules/with-style/lib/tagNames.js
  var require_tagNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var tagNames = [
      "a",
      "abbr",
      "address",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ];
    var _default = tagNames;
  });

  // node_modules/necessary/lib/levels.js
  var require_levels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DEBUG_LEVEL() {
        return DEBUG_LEVEL;
      },
      get ERROR_LEVEL() {
        return ERROR_LEVEL;
      },
      get FATAL_LEVEL() {
        return FATAL_LEVEL;
      },
      get INFO_LEVEL() {
        return INFO_LEVEL;
      },
      get TRACE_LEVEL() {
        return TRACE_LEVEL;
      },
      get WARNING_LEVEL() {
        return WARNING_LEVEL;
      },
      get default() {
        return _default;
      }
    });
    var TRACE_LEVEL = "trace";
    var DEBUG_LEVEL = "debug";
    var INFO_LEVEL = "info";
    var WARNING_LEVEL = "warning";
    var ERROR_LEVEL = "error";
    var FATAL_LEVEL = "fatal";
    var _default = {
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL,
      FATAL_LEVEL
    };
  });

  // node_modules/necessary/lib/methods.js
  var require_methods = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DELETE_METHOD() {
        return DELETE_METHOD;
      },
      get GET_METHOD() {
        return GET_METHOD;
      },
      get OPTIONS_METHOD() {
        return OPTIONS_METHOD;
      },
      get PATCH_METHOD() {
        return PATCH_METHOD;
      },
      get POST_METHOD() {
        return POST_METHOD;
      },
      get default() {
        return _default;
      }
    });
    var GET_METHOD = "GET";
    var POST_METHOD = "POST";
    var PATCH_METHOD = "PATCH";
    var DELETE_METHOD = "DELETE";
    var OPTIONS_METHOD = "OPTIONS";
    var _default = {
      GET_METHOD,
      POST_METHOD,
      PATCH_METHOD,
      DELETE_METHOD,
      OPTIONS_METHOD
    };
  });

  // node_modules/necessary/lib/headers.js
  var require_headers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ACCEPT_HEADER() {
        return ACCEPT_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_HEADERS_HEADER() {
        return ACCESS_CONTROL_ALLOW_HEADERS_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_METHODS_HEADER() {
        return ACCESS_CONTROL_ALLOW_METHODS_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_ORIGIN_HEADER() {
        return ACCESS_CONTROL_ALLOW_ORIGIN_HEADER;
      },
      get ACCESS_CONTROL_REQUEST_METHOD_HEADER() {
        return ACCESS_CONTROL_REQUEST_METHOD_HEADER;
      },
      get AUTHORIZATION_HEADER() {
        return AUTHORIZATION_HEADER;
      },
      get CACHE_CONTROL_HEADER() {
        return CACHE_CONTROL_HEADER;
      },
      get CONTENT_DISPOSITION_HEADER() {
        return CONTENT_DISPOSITION_HEADER;
      },
      get CONTENT_LENGTH_HEADER() {
        return CONTENT_LENGTH_HEADER;
      },
      get CONTENT_TYPE_HEADER() {
        return CONTENT_TYPE_HEADER;
      },
      get LOCATION_HEADER() {
        return LOCATION_HEADER;
      },
      get PRAGMA_HEADER() {
        return PRAGMA_HEADER;
      },
      get TRANSFER_ENCODING_HEADER() {
        return TRANSFER_ENCODING_HEADER;
      },
      get USER_AGENT_HEADER() {
        return USER_AGENT_HEADER;
      },
      get default() {
        return _default;
      }
    });
    var PRAGMA_HEADER = "pragma";
    var ACCEPT_HEADER = "accept";
    var LOCATION_HEADER = "location";
    var USER_AGENT_HEADER = "user-agent";
    var CONTENT_TYPE_HEADER = "content-type";
    var AUTHORIZATION_HEADER = "authorization";
    var CACHE_CONTROL_HEADER = "cache-control";
    var CONTENT_LENGTH_HEADER = "content-length";
    var TRANSFER_ENCODING_HEADER = "transfer-encoding";
    var CONTENT_DISPOSITION_HEADER = "content-disposition";
    var ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = "access-control-allow-origin";
    var ACCESS_CONTROL_ALLOW_METHODS_HEADER = "access-control-allow-methods";
    var ACCESS_CONTROL_ALLOW_HEADERS_HEADER = "access-control-allow-headers";
    var ACCESS_CONTROL_REQUEST_METHOD_HEADER = "access-control-request-method";
    var _default = {
      PRAGMA_HEADER,
      ACCEPT_HEADER,
      LOCATION_HEADER,
      USER_AGENT_HEADER,
      CONTENT_TYPE_HEADER,
      AUTHORIZATION_HEADER,
      CACHE_CONTROL_HEADER,
      CONTENT_LENGTH_HEADER,
      TRANSFER_ENCODING_HEADER,
      CONTENT_DISPOSITION_HEADER,
      ACCESS_CONTROL_ALLOW_ORIGIN_HEADER,
      ACCESS_CONTROL_ALLOW_METHODS_HEADER,
      ACCESS_CONTROL_ALLOW_HEADERS_HEADER,
      ACCESS_CONTROL_REQUEST_METHOD_HEADER
    };
  });

  // node_modules/necessary/lib/keyCodes.js
  var require_keyCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ARROW_DOWN_KEY_CODE() {
        return ARROW_DOWN_KEY_CODE;
      },
      get ARROW_LEFT_KEY_CODE() {
        return ARROW_LEFT_KEY_CODE;
      },
      get ARROW_RIGHT_KEY_CODE() {
        return ARROW_RIGHT_KEY_CODE;
      },
      get ARROW_UP_KEY_CODE() {
        return ARROW_UP_KEY_CODE;
      },
      get BACKSPACE_KEY_CODE() {
        return BACKSPACE_KEY_CODE;
      },
      get DELETE_KEY_CODE() {
        return DELETE_KEY_CODE;
      },
      get ENTER_KEY_CODE() {
        return ENTER_KEY_CODE;
      },
      get ESCAPE_KEY_CODE() {
        return ESCAPE_KEY_CODE;
      },
      get SHIFT_KEY_CODE() {
        return SHIFT_KEY_CODE;
      },
      get TAB_KEY_CODE() {
        return TAB_KEY_CODE;
      },
      get default() {
        return _default;
      }
    });
    var TAB_KEY_CODE = 9;
    var SHIFT_KEY_CODE = 16;
    var ENTER_KEY_CODE = 13;
    var ESCAPE_KEY_CODE = 27;
    var DELETE_KEY_CODE = 46;
    var BACKSPACE_KEY_CODE = 8;
    var ARROW_UP_KEY_CODE = 38;
    var ARROW_DOWN_KEY_CODE = 40;
    var ARROW_LEFT_KEY_CODE = 37;
    var ARROW_RIGHT_KEY_CODE = 39;
    var _default = {
      TAB_KEY_CODE,
      SHIFT_KEY_CODE,
      ENTER_KEY_CODE,
      ESCAPE_KEY_CODE,
      DELETE_KEY_CODE,
      BACKSPACE_KEY_CODE,
      ARROW_UP_KEY_CODE,
      ARROW_DOWN_KEY_CODE,
      ARROW_LEFT_KEY_CODE,
      ARROW_RIGHT_KEY_CODE
    };
  });

  // node_modules/necessary/lib/encodings.js
  var require_encodings = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BASE64_ENCODING() {
        return BASE64_ENCODING;
      },
      get UTF8_ENCODING() {
        return UTF8_ENCODING;
      },
      get UTF_8_ENCODING() {
        return UTF_8_ENCODING;
      },
      get default() {
        return _default;
      }
    });
    var UTF8_ENCODING = "utf8";
    var UTF_8_ENCODING = "utf-8";
    var BASE64_ENCODING = "base64";
    var _default = {
      UTF8_ENCODING,
      UTF_8_ENCODING,
      BASE64_ENCODING
    };
  });

  // node_modules/necessary/lib/characters.js
  var require_characters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AMPERSAND_CHARACTER() {
        return AMPERSAND_CHARACTER;
      },
      get ASTERISK_CHARACTER() {
        return ASTERISK_CHARACTER;
      },
      get BACKSLASH_CHARACTER() {
        return BACKSLASH_CHARACTER;
      },
      get BACKSPACE_CHARACTER() {
        return BACKSPACE_CHARACTER;
      },
      get BACKTICK_DELIMITER() {
        return BACKTICK_DELIMITER;
      },
      get BAR_CHARACTER() {
        return BAR_CHARACTER;
      },
      get CARRIAGE_RETURN_CHARACTER() {
        return CARRIAGE_RETURN_CHARACTER;
      },
      get CLOSING_BRACKET_CHARACTER() {
        return CLOSING_BRACKET_CHARACTER;
      },
      get CLOSING_CURLY_BRACKET_CHARACTER() {
        return CLOSING_CURLY_BRACKET_CHARACTER;
      },
      get CLOSING_SQUARE_BRACKET_CHARACTER() {
        return CLOSING_SQUARE_BRACKET_CHARACTER;
      },
      get COLON_CHARACTER() {
        return COLON_CHARACTER;
      },
      get COMMA_CHARACTER() {
        return COMMA_CHARACTER;
      },
      get CTRL_C_CHARACTER() {
        return CTRL_C_CHARACTER;
      },
      get DASH_CHARACTER() {
        return DASH_CHARACTER;
      },
      get DOLLAR_CHARACTER() {
        return DOLLAR_CHARACTER;
      },
      get DOWN_CHARACTER() {
        return DOWN_CHARACTER;
      },
      get ESCAPE_CHARACTER() {
        return ESCAPE_CHARACTER;
      },
      get ETX_CHARACTER() {
        return ETX_CHARACTER;
      },
      get EXCLAMATION_MARK_CHARACTER() {
        return EXCLAMATION_MARK_CHARACTER;
      },
      get FORWARD_SLASH_CHARACTER() {
        return FORWARD_SLASH_CHARACTER;
      },
      get HAT_CHARACTER() {
        return HAT_CHARACTER;
      },
      get LEFT_CHARACTER() {
        return LEFT_CHARACTER;
      },
      get NEW_LINE_CHARACTER() {
        return NEW_LINE_CHARACTER;
      },
      get OPENING_BRACKET_CHARACTER() {
        return OPENING_BRACKET_CHARACTER;
      },
      get OPENING_CURLY_BRACKET_CHARACTER() {
        return OPENING_CURLY_BRACKET_CHARACTER;
      },
      get OPENING_SQUARE_BRACKET_CHARACTER() {
        return OPENING_SQUARE_BRACKET_CHARACTER;
      },
      get PERIOD_CHARACTER() {
        return PERIOD_CHARACTER;
      },
      get PLUS_CHARACTER() {
        return PLUS_CHARACTER;
      },
      get QUESTION_MARK_CHARACTER() {
        return QUESTION_MARK_CHARACTER;
      },
      get RIGHT_CHARACTER() {
        return RIGHT_CHARACTER;
      },
      get SPACE_CHARACTER() {
        return SPACE_CHARACTER;
      },
      get UP_CHARACTER() {
        return UP_CHARACTER;
      },
      get WILDCARD_CHARACTER() {
        return WILDCARD_CHARACTER;
      },
      get default() {
        return _default;
      }
    });
    var UP_CHARACTER = "[A";
    var ETX_CHARACTER = "";
    var BAR_CHARACTER = "|";
    var HAT_CHARACTER = "^";
    var PLUS_CHARACTER = "+";
    var DASH_CHARACTER = "-";
    var DOWN_CHARACTER = "[B";
    var LEFT_CHARACTER = "[D";
    var RIGHT_CHARACTER = "[C";
    var SPACE_CHARACTER = " ";
    var COMMA_CHARACTER = ",";
    var COLON_CHARACTER = ":";
    var PERIOD_CHARACTER = ".";
    var DOLLAR_CHARACTER = "$";
    var CTRL_C_CHARACTER = "^C";
    var ESCAPE_CHARACTER = "";
    var ASTERISK_CHARACTER = "*";
    var WILDCARD_CHARACTER = "*";
    var BACKTICK_DELIMITER = "`";
    var NEW_LINE_CHARACTER = "\n";
    var AMPERSAND_CHARACTER = "&";
    var BACKSLASH_CHARACTER = "\\";
    var BACKSPACE_CHARACTER = String.fromCharCode(127);
    var QUESTION_MARK_CHARACTER = "?";
    var FORWARD_SLASH_CHARACTER = "/";
    var OPENING_BRACKET_CHARACTER = "(";
    var CLOSING_BRACKET_CHARACTER = ")";
    var CARRIAGE_RETURN_CHARACTER = "\r";
    var EXCLAMATION_MARK_CHARACTER = "!";
    var OPENING_CURLY_BRACKET_CHARACTER = "{";
    var CLOSING_CURLY_BRACKET_CHARACTER = "}";
    var OPENING_SQUARE_BRACKET_CHARACTER = "[";
    var CLOSING_SQUARE_BRACKET_CHARACTER = "]";
    var _default = {
      UP_CHARACTER,
      ETX_CHARACTER,
      BAR_CHARACTER,
      HAT_CHARACTER,
      PLUS_CHARACTER,
      DASH_CHARACTER,
      DOWN_CHARACTER,
      LEFT_CHARACTER,
      RIGHT_CHARACTER,
      SPACE_CHARACTER,
      COMMA_CHARACTER,
      COLON_CHARACTER,
      PERIOD_CHARACTER,
      DOLLAR_CHARACTER,
      CTRL_C_CHARACTER,
      ESCAPE_CHARACTER,
      ASTERISK_CHARACTER,
      WILDCARD_CHARACTER,
      BACKTICK_DELIMITER,
      NEW_LINE_CHARACTER,
      AMPERSAND_CHARACTER,
      BACKSLASH_CHARACTER,
      BACKSPACE_CHARACTER,
      QUESTION_MARK_CHARACTER,
      FORWARD_SLASH_CHARACTER,
      OPENING_BRACKET_CHARACTER,
      CLOSING_BRACKET_CHARACTER,
      CARRIAGE_RETURN_CHARACTER,
      EXCLAMATION_MARK_CHARACTER,
      OPENING_CURLY_BRACKET_CHARACTER,
      CLOSING_CURLY_BRACKET_CHARACTER,
      OPENING_SQUARE_BRACKET_CHARACTER,
      CLOSING_SQUARE_BRACKET_CHARACTER
    };
  });

  // node_modules/necessary/lib/statusCodes.js
  var require_statusCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BAD_GATEWAY_502_STATUS_CODE() {
        return BAD_GATEWAY_502_STATUS_CODE;
      },
      get BAD_REQUEST_400_STATUS_CODE() {
        return BAD_REQUEST_400_STATUS_CODE;
      },
      get CONFLICT_409_STATUS_CODE() {
        return CONFLICT_409_STATUS_CODE;
      },
      get CREATED_201_STATUS_CODE() {
        return CREATED_201_STATUS_CODE;
      },
      get FORBIDDEN_403_STATUS_CODE() {
        return FORBIDDEN_403_STATUS_CODE;
      },
      get FOUND_302_STATUS_CODE() {
        return FOUND_302_STATUS_CODE;
      },
      get INTERNAL_SERVER_ERROR_500_STATUS_CODE() {
        return INTERNAL_SERVER_ERROR_500_STATUS_CODE;
      },
      get METHOD_NOT_ALLOWED_405_STATUS_CODE() {
        return METHOD_NOT_ALLOWED_405_STATUS_CODE;
      },
      get NOT_ACCEPTABLE_406_STATUS_CODE() {
        return NOT_ACCEPTABLE_406_STATUS_CODE;
      },
      get NOT_FOUND_404_STATUS_CODE() {
        return NOT_FOUND_404_STATUS_CODE;
      },
      get NO_CONTENT_204_STATUS_CODE() {
        return NO_CONTENT_204_STATUS_CODE;
      },
      get OK_200_STATUS_CODE() {
        return OK_200_STATUS_CODE;
      },
      get REQUEST_TIMEOUT_408_STATUS_CODE() {
        return REQUEST_TIMEOUT_408_STATUS_CODE;
      },
      get SEE_OTHER_303_STATUS_CODE() {
        return SEE_OTHER_303_STATUS_CODE;
      },
      get SERVICE_UNAVAILABLE_503_STATUS_CODE() {
        return SERVICE_UNAVAILABLE_503_STATUS_CODE;
      },
      get TOO_MANY_REQUESTS_429_STATUS_CODE() {
        return TOO_MANY_REQUESTS_429_STATUS_CODE;
      },
      get UNAUTHORIZED_401_STATUS_CODE() {
        return UNAUTHORIZED_401_STATUS_CODE;
      },
      get UNPROCESSABLE_ENTITY_422_STATUS_CODE() {
        return UNPROCESSABLE_ENTITY_422_STATUS_CODE;
      },
      get ZERO_0_STATUS_CODE() {
        return ZERO_0_STATUS_CODE;
      },
      get default() {
        return _default;
      }
    });
    var ZERO_0_STATUS_CODE = 0;
    var OK_200_STATUS_CODE = 200;
    var FOUND_302_STATUS_CODE = 302;
    var CREATED_201_STATUS_CODE = 201;
    var CONFLICT_409_STATUS_CODE = 409;
    var SEE_OTHER_303_STATUS_CODE = 303;
    var FORBIDDEN_403_STATUS_CODE = 403;
    var NOT_FOUND_404_STATUS_CODE = 404;
    var NO_CONTENT_204_STATUS_CODE = 204;
    var BAD_GATEWAY_502_STATUS_CODE = 502;
    var BAD_REQUEST_400_STATUS_CODE = 400;
    var UNAUTHORIZED_401_STATUS_CODE = 401;
    var NOT_ACCEPTABLE_406_STATUS_CODE = 406;
    var REQUEST_TIMEOUT_408_STATUS_CODE = 408;
    var TOO_MANY_REQUESTS_429_STATUS_CODE = 429;
    var METHOD_NOT_ALLOWED_405_STATUS_CODE = 405;
    var SERVICE_UNAVAILABLE_503_STATUS_CODE = 503;
    var UNPROCESSABLE_ENTITY_422_STATUS_CODE = 422;
    var INTERNAL_SERVER_ERROR_500_STATUS_CODE = 500;
    var _default = {
      ZERO_0_STATUS_CODE,
      OK_200_STATUS_CODE,
      FOUND_302_STATUS_CODE,
      CREATED_201_STATUS_CODE,
      CONFLICT_409_STATUS_CODE,
      SEE_OTHER_303_STATUS_CODE,
      FORBIDDEN_403_STATUS_CODE,
      NOT_FOUND_404_STATUS_CODE,
      NO_CONTENT_204_STATUS_CODE,
      BAD_GATEWAY_502_STATUS_CODE,
      BAD_REQUEST_400_STATUS_CODE,
      UNAUTHORIZED_401_STATUS_CODE,
      NOT_ACCEPTABLE_406_STATUS_CODE,
      REQUEST_TIMEOUT_408_STATUS_CODE,
      TOO_MANY_REQUESTS_429_STATUS_CODE,
      METHOD_NOT_ALLOWED_405_STATUS_CODE,
      SERVICE_UNAVAILABLE_503_STATUS_CODE,
      UNPROCESSABLE_ENTITY_422_STATUS_CODE,
      INTERNAL_SERVER_ERROR_500_STATUS_CODE
    };
  });

  // node_modules/necessary/lib/contentTypes.js
  var require_contentTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE() {
        return APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get APPLICATION_JSON_CONTENT_TYPE() {
        return APPLICATION_JSON_CONTENT_TYPE;
      },
      get APPLICATION_OCTET_STREAM_CONTENT_TYPE() {
        return APPLICATION_OCTET_STREAM_CONTENT_TYPE;
      },
      get APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE() {
        return APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE() {
        return APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE;
      },
      get TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE() {
        return TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get TEXT_HTML_CONTENT_TYPE() {
        return TEXT_HTML_CONTENT_TYPE;
      },
      get TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE() {
        return TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get TEXT_PLAIN_CONTENT_TYPE() {
        return TEXT_PLAIN_CONTENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var TEXT_HTML_CONTENT_TYPE = "text/html";
    var TEXT_PLAIN_CONTENT_TYPE = "text/plain";
    var APPLICATION_JSON_CONTENT_TYPE = "application/json";
    var TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE = "text/html; charset=utf-8";
    var TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE = "text/plain; charset=utf-8";
    var APPLICATION_OCTET_STREAM_CONTENT_TYPE = "application/octet-stream";
    var APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE = "application/x-www-form-urlencoded";
    var APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE = "application/json; charset=utf-8";
    var APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE = "application/x-www-form-urlencoded; charset=utf-8";
    var _default = {
      TEXT_HTML_CONTENT_TYPE,
      TEXT_PLAIN_CONTENT_TYPE,
      APPLICATION_JSON_CONTENT_TYPE,
      TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE,
      TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_OCTET_STREAM_CONTENT_TYPE,
      APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE
    };
  });

  // node_modules/necessary/lib/statusMessages.js
  var require_statusMessages = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BAD_GATEWAY_502_STATUS_MESSAGE() {
        return BAD_GATEWAY_502_STATUS_MESSAGE;
      },
      get BAD_REQUEST_400_STATUS_MESSAGE() {
        return BAD_REQUEST_400_STATUS_MESSAGE;
      },
      get CONFLICT_409_STATUS_MESSAGE() {
        return CONFLICT_409_STATUS_MESSAGE;
      },
      get CREATED_201_STATUS_MESSAGE() {
        return CREATED_201_STATUS_MESSAGE;
      },
      get FORBIDDEN_403_STATUS_MESSAGE() {
        return FORBIDDEN_403_STATUS_MESSAGE;
      },
      get FOUND_302_STATUS_MESSAGE() {
        return FOUND_302_STATUS_MESSAGE;
      },
      get INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE() {
        return INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE;
      },
      get METHOD_NOT_ALLOWED_405_STATUS_MESSAGE() {
        return METHOD_NOT_ALLOWED_405_STATUS_MESSAGE;
      },
      get NOT_ACCEPTABLE_406_STATUS_MESSAGE() {
        return NOT_ACCEPTABLE_406_STATUS_MESSAGE;
      },
      get NOT_FOUND_404_STATUS_MESSAGE() {
        return NOT_FOUND_404_STATUS_MESSAGE;
      },
      get NO_CONTENT_204_STATUS_MESSAGE() {
        return NO_CONTENT_204_STATUS_MESSAGE;
      },
      get OK_200_STATUS_MESSAGE() {
        return OK_200_STATUS_MESSAGE;
      },
      get REQUEST_TIMEOUT_408_STATUS_MESSAGE() {
        return REQUEST_TIMEOUT_408_STATUS_MESSAGE;
      },
      get SEE_OTHER_303_STATUS_MESSAGE() {
        return SEE_OTHER_303_STATUS_MESSAGE;
      },
      get SERVICE_UNAVAILABLE_503_STATUS_MESSAGE() {
        return SERVICE_UNAVAILABLE_503_STATUS_MESSAGE;
      },
      get TOO_MANY_REQUESTS_429_STATUS_MESSAGE() {
        return TOO_MANY_REQUESTS_429_STATUS_MESSAGE;
      },
      get UNAUTHORIZED_401_STATUS_MESSAGE() {
        return UNAUTHORIZED_401_STATUS_MESSAGE;
      },
      get UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE() {
        return UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE;
      },
      get ZERO_0_STATUS_MESSAGE() {
        return ZERO_0_STATUS_MESSAGE;
      },
      get default() {
        return _default;
      }
    });
    var ZERO_0_STATUS_MESSAGE = "";
    var OK_200_STATUS_MESSAGE = "OK";
    var FOUND_302_STATUS_MESSAGE = "Found";
    var CREATED_201_STATUS_MESSAGE = "Created";
    var CONFLICT_409_STATUS_MESSAGE = "Conflict";
    var SEE_OTHER_303_STATUS_MESSAGE = "See other";
    var FORBIDDEN_403_STATUS_MESSAGE = "Forbidden";
    var NOT_FOUND_404_STATUS_MESSAGE = "Not found";
    var NO_CONTENT_204_STATUS_MESSAGE = "No content";
    var BAD_GATEWAY_502_STATUS_MESSAGE = "Bad gateway";
    var BAD_REQUEST_400_STATUS_MESSAGE = "Bad request";
    var UNAUTHORIZED_401_STATUS_MESSAGE = "Unauthorized";
    var NOT_ACCEPTABLE_406_STATUS_MESSAGE = "Not Acceptable";
    var REQUEST_TIMEOUT_408_STATUS_MESSAGE = "Request timeout";
    var TOO_MANY_REQUESTS_429_STATUS_MESSAGE = "Too many requests";
    var METHOD_NOT_ALLOWED_405_STATUS_MESSAGE = "Method not allowed";
    var SERVICE_UNAVAILABLE_503_STATUS_MESSAGE = "Service unavailable";
    var UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE = "Unprocessable Entity";
    var INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE = "Internal server error";
    var _default = {
      ZERO_0_STATUS_MESSAGE,
      OK_200_STATUS_MESSAGE,
      FOUND_302_STATUS_MESSAGE,
      CREATED_201_STATUS_MESSAGE,
      CONFLICT_409_STATUS_MESSAGE,
      SEE_OTHER_303_STATUS_MESSAGE,
      FORBIDDEN_403_STATUS_MESSAGE,
      NOT_FOUND_404_STATUS_MESSAGE,
      NO_CONTENT_204_STATUS_MESSAGE,
      BAD_GATEWAY_502_STATUS_MESSAGE,
      BAD_REQUEST_400_STATUS_MESSAGE,
      UNAUTHORIZED_401_STATUS_MESSAGE,
      NOT_ACCEPTABLE_406_STATUS_MESSAGE,
      REQUEST_TIMEOUT_408_STATUS_MESSAGE,
      TOO_MANY_REQUESTS_429_STATUS_MESSAGE,
      METHOD_NOT_ALLOWED_405_STATUS_MESSAGE,
      SERVICE_UNAVAILABLE_503_STATUS_MESSAGE,
      UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE,
      INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE
    };
  });

  // node_modules/necessary/lib/constants.js
  var require_constants2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN() {
        return BOOLEAN;
      },
      get DATA() {
        return DATA;
      },
      get DEFAULT() {
        return DEFAULT;
      },
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ENVIRONMENT() {
        return ENVIRONMENT;
      },
      get ERROR() {
        return ERROR;
      },
      get FUNCTION() {
        return FUNCTION;
      },
      get NUMBER() {
        return NUMBER;
      },
      get PACKAGE_JSON() {
        return PACKAGE_JSON;
      },
      get STRING() {
        return STRING;
      },
      get ZERO() {
        return ZERO;
      }
    });
    var ZERO = "0";
    var DATA = "data";
    var ERROR = "error";
    var STRING = "string";
    var NUMBER = "number";
    var BOOLEAN = "boolean";
    var DEFAULT = "default";
    var FUNCTION = "function";
    var ENVIRONMENT = "ENVIRONMENT";
    var EMPTY_STRING = "";
    var DOUBLE_SPACE = "  ";
    var PACKAGE_JSON = "package.json";
  });

  // node_modules/necessary/lib/utilities/array.js
  var require_array2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get augment() {
        return augment;
      },
      get back() {
        return back;
      },
      get backwardsEvery() {
        return backwardsEvery;
      },
      get backwardsFind() {
        return backwardsFind;
      },
      get backwardsFindIndex() {
        return backwardsFindIndex;
      },
      get backwardsForEach() {
        return backwardsForEach;
      },
      get backwardsReduce() {
        return backwardsReduce;
      },
      get backwardsSome() {
        return backwardsSome;
      },
      get clear() {
        return clear;
      },
      get combine() {
        return combine;
      },
      get compare() {
        return compare;
      },
      get compress() {
        return compress;
      },
      get concat() {
        return concat;
      },
      get copy() {
        return copy;
      },
      get correlate() {
        return correlate;
      },
      get default() {
        return _default;
      },
      get eighth() {
        return eighth;
      },
      get eighthLast() {
        return eighthLast;
      },
      get extract() {
        return extract;
      },
      get fifth() {
        return fifth;
      },
      get fifthLast() {
        return fifthLast;
      },
      get filter() {
        return filter;
      },
      get find() {
        return find;
      },
      get first() {
        return first2;
      },
      get firstLast() {
        return firstLast;
      },
      get forwardsEvery() {
        return forwardsEvery;
      },
      get forwardsFind() {
        return forwardsFind;
      },
      get forwardsFindIndex() {
        return forwardsFindIndex;
      },
      get forwardsForEach() {
        return forwardsForEach;
      },
      get forwardsReduce() {
        return forwardsReduce;
      },
      get forwardsSome() {
        return forwardsSome;
      },
      get fourth() {
        return fourth;
      },
      get fourthLast() {
        return fourthLast;
      },
      get front() {
        return front;
      },
      get head() {
        return head;
      },
      get last() {
        return last;
      },
      get match() {
        return match;
      },
      get merge() {
        return merge;
      },
      get ninth() {
        return ninth;
      },
      get ninthLast() {
        return ninthLast;
      },
      get patch() {
        return patch;
      },
      get prune() {
        return prune;
      },
      get push() {
        return push;
      },
      get replace() {
        return replace;
      },
      get resolve() {
        return resolve;
      },
      get reverse() {
        return reverse;
      },
      get second() {
        return second;
      },
      get secondLast() {
        return secondLast;
      },
      get separate() {
        return separate;
      },
      get seventh() {
        return seventh;
      },
      get seventhLast() {
        return seventhLast;
      },
      get sixth() {
        return sixth;
      },
      get sixthLast() {
        return sixthLast;
      },
      get splice() {
        return splice;
      },
      get tail() {
        return tail;
      },
      get tenth() {
        return tenth;
      },
      get third() {
        return third;
      },
      get thirdLast() {
        return thirdLast;
      },
      get unshift() {
        return unshift;
      }
    });
    function first2(array) {
      return array[0];
    }
    function second(array) {
      return array[1];
    }
    function third(array) {
      return array[2];
    }
    function fourth(array) {
      return array[3];
    }
    function fifth(array) {
      return array[4];
    }
    function sixth(array) {
      return array[5];
    }
    function seventh(array) {
      return array[6];
    }
    function eighth(array) {
      return array[7];
    }
    function ninth(array) {
      return array[8];
    }
    function tenth(array) {
      return array[9];
    }
    function firstLast(array) {
      return array[array.length - 1];
    }
    function secondLast(array) {
      return array[array.length - 2];
    }
    function thirdLast(array) {
      return array[array.length - 3];
    }
    function fourthLast(array) {
      return array[array.length - 4];
    }
    function fifthLast(array) {
      return array[array.length - 5];
    }
    function sixthLast(array) {
      return array[array.length - 6];
    }
    function seventhLast(array) {
      return array[array.length - 7];
    }
    function eighthLast(array) {
      return array[array.length - 8];
    }
    function ninthLast(array) {
      return array[array.length - 9];
    }
    function last(array) {
      return array[array.length - 1];
    }
    function head(array) {
      return array.slice(0, 1);
    }
    function tail(array) {
      return array.slice(1);
    }
    function back(array) {
      return array.slice(array.length - 1);
    }
    function front(array) {
      return array.slice(0, Math.max(1, array.length - 1));
    }
    function push(arrayA, arrayB) {
      Array.prototype.push.apply(arrayA, arrayB);
    }
    function unshift(arrayA, arrayB) {
      Array.prototype.unshift.apply(arrayA, arrayB);
    }
    function concat(arrayA, elementOrArray2) {
      const arrayB = elementOrArray2 instanceof Array ? elementOrArray2 : [
        elementOrArray2
      ];
      push(arrayA, arrayB);
    }
    function clear(array) {
      const start = 0;
      return array.splice(start);
    }
    function copy(arrayA, arrayB) {
      const start = 0, deleteCount = arrayB.length;
      splice(arrayA, start, deleteCount, arrayB);
    }
    function merge(arrayA, arrayB) {
      Array.prototype.push.apply(arrayA, arrayB);
    }
    function match(arrayA, arrayB, callback) {
      let matches = false;
      const arrayALength = arrayA.length, arrayBLength = arrayB.length;
      if (arrayALength === arrayBLength) {
        matches = arrayA.every((elementA, index) => {
          const elementB = arrayB[index], passed = callback(elementA, elementB, index);
          if (passed) {
            return true;
          }
        });
      }
      return matches;
    }
    function compare(arrayA, arrayB, callback) {
      let coupled = false;
      const arrayALength = arrayA.length, arrayBLength = arrayB.length;
      if (arrayALength === arrayBLength) {
        arrayB = [
          ...arrayB
        ];
        coupled = arrayA.every((elementA, index) => {
          const elementB = extract(arrayB, (elementB2) => {
            const result = callback(elementA, elementB2);
            if (result) {
              return true;
            }
          }) || null;
          if (elementB !== null) {
            return true;
          }
        });
      }
      return coupled;
    }
    function correlate(arrayA, arrayB, callback) {
      arrayB = [
        ...arrayB
      ];
      const correlates = arrayA.every((elementA) => {
        const elementB = extract(arrayB, (elementB2) => {
          const result = callback(elementA, elementB2);
          if (result) {
            return true;
          }
        }) || null;
        if (elementB !== null) {
          return true;
        }
      });
      return correlates;
    }
    function resolve(arrayA, arrayB, callback) {
      let resolved;
      arrayA = [
        ...arrayA
      ];
      for (; ; ) {
        const arrayALength2 = arrayA.length;
        if (arrayALength2 === 0) {
          break;
        }
        let resolved2 = false;
        arrayA.forEach((elementA) => {
          const passed = callback(elementA);
          if (passed) {
            const elementB = elementA;
            arrayB.push(elementB);
            resolved2 = true;
          }
        });
        if (!resolved2) {
          break;
        }
        filter(arrayA, (elementA) => {
          const arrayBIncludesElementA = arrayB.includes(elementA);
          if (!arrayBIncludesElementA) {
            return true;
          }
        });
      }
      const arrayALength = arrayA.length;
      resolved = arrayALength === 0;
      return resolved;
    }
    function find(array, callback) {
      const elements = [];
      forwardsForEach(array, (element, index) => {
        const passed = callback(element, index);
        if (passed) {
          elements.push(element);
        }
      });
      return elements;
    }
    function replace(array, element, callback) {
      let start;
      const found = array.some((element2, index) => {
        const passed = callback(element2, index);
        if (passed) {
          start = index;
          return true;
        }
      });
      if (found) {
        const deleteCount = 1;
        array.splice(start, deleteCount, element);
      }
      return found;
    }
    function splice(arrayA, start, deleteCount = Infinity, arrayB = []) {
      const args = [
        start,
        deleteCount,
        ...arrayB
      ], deletedElements = Array.prototype.splice.apply(arrayA, args);
      return deletedElements;
    }
    function filter(array, callback) {
      const deletedElements = [];
      backwardsForEach(array, (element, index) => {
        const passed = callback(element, index);
        if (!passed) {
          const start = index, deleteCount = 1, deletedElements2 = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements2);
          deletedElements2.unshift(firstDeletedElement);
        }
      });
      return deletedElements;
    }
    function prune(array, callback) {
      let deletedElement = void 0;
      array.some((element, index) => {
        const passed = callback(element, index);
        if (!passed) {
          const start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements);
          deletedElement = firstDeletedElement;
          return true;
        }
      });
      return deletedElement;
    }
    function extract(array, callback) {
      let deletedElement = void 0;
      array.some((element, index) => {
        const passed = callback(element, index);
        if (passed) {
          const start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements);
          deletedElement = firstDeletedElement;
          return true;
        }
      });
      return deletedElement;
    }
    function patch(array, element, callback) {
      const found = array.some((element2, index) => {
        const passed = callback(element2, index);
        if (passed) {
          return true;
        }
      });
      if (found) {
        array.push(element);
      }
      return found;
    }
    function compress(array, callback) {
      let index1 = 0, length = array.length;
      while (index1 < length) {
        const elementB = array[index1];
        for (let index2 = length - 1; index2 > index1; index2--) {
          const elementA = array[index2], passed = callback(elementA, elementB);
          if (!passed) {
            const start = index2, deleteCount = 1;
            array.splice(start, deleteCount);
          }
        }
        index1++;
        length = array.length;
      }
    }
    function combine(arrayA, arrayB, callback) {
      const array = [
        ...arrayA,
        ...arrayB
      ];
      compress(array, callback);
      return array;
    }
    function reverse(array) {
      array = [
        ...array
      ].reverse();
      return array;
    }
    function augment(arrayA, arrayB, callback) {
      arrayB.forEach((element, index) => {
        const passed = callback(element, index);
        if (passed) {
          arrayA.push(element);
        }
      });
    }
    function separate(array, arrayA, arrayB, callback) {
      array.forEach((element, index) => {
        const passed = callback(element, index);
        passed ? arrayA.push(element) : arrayB.push(element);
      });
    }
    function forwardsFind(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return element;
        }
      }
      return false;
    }
    function backwardsFind(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return element;
        }
      }
      return false;
    }
    function forwardsSome(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return true;
        }
      }
      return false;
    }
    function backwardsSome(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return true;
        }
      }
      return false;
    }
    function forwardsEvery(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    function backwardsEvery(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    function forwardsReduce(array, callback, initialValue) {
      let value = initialValue;
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index];
        value = callback(value, element, index);
      }
      return value;
    }
    function backwardsReduce(array, callback, initialValue) {
      let value = initialValue;
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index];
        value = callback(value, element, index);
      }
      return value;
    }
    function forwardsForEach(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index];
        callback(element, index);
      }
    }
    function backwardsForEach(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index];
        callback(element, index);
      }
    }
    function forwardsFindIndex(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return index;
        }
      }
      return -1;
    }
    function backwardsFindIndex(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return index;
        }
      }
      return -1;
    }
    var _default = {
      first: first2,
      second,
      third,
      fourth,
      fifth,
      sixth,
      seventh,
      eighth,
      ninth,
      firstLast,
      secondLast,
      thirdLast,
      fourthLast,
      fifthLast,
      sixthLast,
      seventhLast,
      eighthLast,
      ninthLast,
      last,
      head,
      tail,
      back,
      front,
      push,
      unshift,
      concat,
      clear,
      copy,
      merge,
      match,
      compare,
      correlate,
      resolve,
      find,
      replace,
      splice,
      filter,
      prune,
      extract,
      patch,
      compress,
      combine,
      reverse,
      augment,
      separate,
      forwardsFind,
      backwardsFind,
      forwardsSome,
      backwardsSome,
      forwardsEvery,
      backwardsEvery,
      forwardsReduce,
      backwardsReduce,
      forwardsForEach,
      backwardsForEach,
      forwardsFindIndex,
      backwardsFindIndex
    };
  });

  // node_modules/necessary/lib/utilities/path.js
  var require_path = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get bottommostNameFromPath() {
        return bottommostNameFromPath;
      },
      get combinePaths() {
        return combinePaths;
      },
      get concatenatePaths() {
        return concatenatePaths;
      },
      get default() {
        return _default;
      },
      get isPathAbsolutePath() {
        return isPathAbsolutePath;
      },
      get isPathName() {
        return isPathName;
      },
      get isPathRelativePath() {
        return isPathRelativePath;
      },
      get isPathTopmostName() {
        return isPathTopmostName;
      },
      get isTopmostNameInAbsolutePath() {
        return isTopmostNameInAbsolutePath;
      },
      get pathWithoutBottommostNameFromPath() {
        return pathWithoutBottommostNameFromPath;
      },
      get pathWithoutTopmostDirectoryNameFromPath() {
        return pathWithoutTopmostDirectoryNameFromPath;
      },
      get topmostDirectoryNameFromPath() {
        return topmostDirectoryNameFromPath;
      },
      get topmostDirectoryPathFromPath() {
        return topmostDirectoryPathFromPath;
      }
    });
    var _constants = require_constants2();
    var _array = require_array2();
    function isPathName(path) {
      path = path.replace(/^\//, _constants.EMPTY_STRING).replace(/\/$/, _constants.EMPTY_STRING);
      const pathName = /\//.test(path) === false;
      return pathName;
    }
    function isPathTopmostName(path) {
      const pathName = isPathName(path), pathAbsolutePath = isPathAbsolutePath(path), pathTopmostName = pathName && pathAbsolutePath;
      return pathTopmostName;
    }
    function isPathRelativePath(path) {
      const pathRelativePath = !/^\//.test(path);
      return pathRelativePath;
    }
    function isPathAbsolutePath(path) {
      const pathAbsolutePath = /^\//.test(path);
      return pathAbsolutePath;
    }
    function isTopmostNameInAbsolutePath(topmostName, absolutePath) {
      const regExp = new RegExp(`^${topmostName}(?:\\/.+)?$`), topmostNameInAbsolutePath = regExp.test(absolutePath);
      return topmostNameInAbsolutePath;
    }
    function combinePaths(path, relativePath) {
      let combinedPath = null;
      const pathNames = path.split(/\//), relativePathNames = relativePath.split(/\//);
      let lastPathName, firstRelativePathName = (0, _array.first)(relativePathNames);
      if (firstRelativePathName === ".") {
        relativePathNames.shift();
      }
      firstRelativePathName = (0, _array.first)(relativePathNames);
      lastPathName = (0, _array.last)(pathNames);
      while (firstRelativePathName === ".." && lastPathName !== void 0) {
        relativePathNames.shift();
        pathNames.pop();
        firstRelativePathName = (0, _array.first)(relativePathNames);
        lastPathName = (0, _array.last)(pathNames);
      }
      if (lastPathName !== void 0) {
        const combinedPathNames = [].concat(pathNames).concat(relativePathNames);
        combinedPath = combinedPathNames.join("/");
      }
      return combinedPath;
    }
    function concatenatePaths(path, relativePath, ...remainingArguments) {
      let concatenatedPath;
      path = path.replace(/\/$/, _constants.EMPTY_STRING);
      concatenatedPath = `${path}/${relativePath}`;
      const remainingAArgumentsLength = remainingArguments.length;
      if (remainingAArgumentsLength > 0) {
        const path2 = concatenatedPath, relativePath2 = remainingArguments.shift();
        concatenatedPath = concatenatePaths(path2, relativePath2, ...remainingArguments);
      }
      return concatenatedPath;
    }
    function bottommostNameFromPath(path) {
      let bottommostName = null;
      const matches = path.match(/^.*\/([^\/]+\/?)$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        bottommostName = secondMatch;
      }
      return bottommostName;
    }
    function topmostDirectoryPathFromPath(path) {
      const matches = path.match(/^(.+)\/[^\/]+\/?$/), secondMatch = (0, _array.second)(matches), topmostDirectoryPath = secondMatch;
      return topmostDirectoryPath;
    }
    function topmostDirectoryNameFromPath(path) {
      let topmostDirectoryName = null;
      const matches = path.match(/^([^\/]+)\/.+$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        topmostDirectoryName = secondMatch;
      }
      return topmostDirectoryName;
    }
    function pathWithoutBottommostNameFromPath(path) {
      let pathWithoutBottommostName = null;
      const matches = path.match(/^(.*)\/[^\/]+\/?$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        pathWithoutBottommostName = secondMatch;
      }
      return pathWithoutBottommostName;
    }
    function pathWithoutTopmostDirectoryNameFromPath(path) {
      let pathWithoutTopmostDirectoryName = null;
      const matches = path.match(/^[^\/]+\/(.+)$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        pathWithoutTopmostDirectoryName = secondMatch;
      }
      return pathWithoutTopmostDirectoryName;
    }
    var _default = {
      isPathName,
      isPathTopmostName,
      isPathRelativePath,
      isPathAbsolutePath,
      isTopmostNameInAbsolutePath,
      combinePaths,
      concatenatePaths,
      bottommostNameFromPath,
      topmostDirectoryPathFromPath,
      topmostDirectoryNameFromPath,
      pathWithoutBottommostNameFromPath,
      pathWithoutTopmostDirectoryNameFromPath
    };
  });

  // node_modules/necessary/lib/utilities/http.js
  var require_http = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get hostnameFromHost() {
        return hostnameFromHost;
      },
      get overwrite() {
        return overwrite;
      },
      get portFromHost() {
        return portFromHost;
      },
      get queryStringFromQuery() {
        return queryStringFromQuery;
      },
      get secureFromHost() {
        return secureFromHost;
      },
      get underwrite() {
        return underwrite;
      },
      get urlFromHostURIAndQuery() {
        return urlFromHostURIAndQuery;
      }
    });
    var _array = require_array2();
    var _constants = require_constants2();
    var _characters = require_characters();
    function overwrite(headers, name, value) {
      const lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName = existingNames.find((existingName2) => {
        const existingLowerCaseName = existingName2.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName !== null) {
        headers[existingName] = value;
      }
    }
    function underwrite(headers, name, value) {
      const lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName = existingNames.find((existingName2) => {
        const existingLowerCaseName = existingName2.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName === null) {
        headers[name] = value;
      }
    }
    function portFromHost(host) {
      let port;
      const matches = host.match(/^https?:\/\/([^\/]+)/), secondMatch = (0, _array.second)(matches), index = secondMatch.indexOf(_characters.COLON_CHARACTER);
      if (index === -1) {
        const secure = secureFromHost(host);
        port = secure ? 443 : 80;
      } else {
        const start = index + 1, portString = secondMatch.substring(start);
        port = Number(portString);
      }
      return port;
    }
    function secureFromHost(host) {
      const secure = /^https:\/\//.test(host);
      return secure;
    }
    function hostnameFromHost(host) {
      const matches = host.match(/^https?:\/\/([^:\/]+)/), secondMatch = (0, _array.second)(matches), hostname = secondMatch;
      return hostname;
    }
    function queryStringFromQuery(query) {
      const names = Object.keys(query), namesLength = names.length, lastIndex = namesLength - 1, queryString = names.reduce((queryString2, name, index) => {
        const value = query[name], encodedName = encodeURIComponent(name), encodedValue = encodeURIComponent(value), ampersandOrNothing = index !== lastIndex ? _characters.AMPERSAND_CHARACTER : _constants.EMPTY_STRING;
        queryString2 += `${encodedName}=${encodedValue}${ampersandOrNothing}`;
        return queryString2;
      }, _constants.EMPTY_STRING);
      return queryString;
    }
    function urlFromHostURIAndQuery(host, uri, query) {
      const queryString = queryStringFromQuery(query), url = queryString === _constants.EMPTY_STRING ? `${host}${uri}` : `${host}${uri}?${queryString}`;
      return url;
    }
    var _default = {
      overwrite,
      underwrite,
      portFromHost,
      secureFromHost,
      hostnameFromHost,
      queryStringFromQuery,
      urlFromHostURIAndQuery
    };
  });

  // node_modules/necessary/lib/utilities/string.js
  var require_string2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get indexOf() {
        return indexOf;
      },
      get strcmp() {
        return strcmp;
      },
      get strlen() {
        return strlen;
      },
      get substring() {
        return substring;
      }
    });
    var _constants = require_constants2();
    function strlen(string) {
      let length = 0;
      const iterator = string[Symbol.iterator]();
      let character = iterator.next();
      while (!character.done) {
        character = iterator.next();
        length++;
      }
      return length;
    }
    function strcmp(stringA, stringB) {
      let difference;
      const iteratorA = stringA[Symbol.iterator](), iteratorB = stringB[Symbol.iterator]();
      let characterA = iteratorA.next(), characterB = iteratorB.next(), codePointA, codePointB;
      while (true) {
        codePointA = characterA.value ? characterA.value.codePointAt(0) : 0;
        codePointB = characterB.value ? characterB.value.codePointAt(0) : 0;
        difference = codePointB - codePointA;
        if (difference !== 0) {
          break;
        }
        if (characterA.done || characterB.done) {
          break;
        }
        characterA = iteratorA.next();
        characterB = iteratorB.next();
      }
      return difference;
    }
    function indexOf(string, searchString) {
      let index = -1, found = false;
      const searchStringLength = strlen(searchString);
      if (searchStringLength > 0) {
        let character;
        const iterator = string[Symbol.iterator](), searchIterator = searchString[Symbol.iterator](), searchCharacter = searchIterator.next();
        character = iterator.next();
        index++;
        while (!character.done) {
          if (character.value === searchCharacter.value) {
            const start = index, end = start + searchStringLength, subString = substring(string, start, end), difference = strcmp(subString, searchString);
            if (difference === 0) {
              found = true;
              break;
            }
          }
          character = iterator.next();
          index++;
        }
      }
      if (!found) {
        index = -1;
      }
      return index;
    }
    function substring(string, start, end = Infinity) {
      let index = 0;
      const iterator = string[Symbol.iterator](), characters = [];
      let character = iterator.next();
      while (!character.done) {
        if (index === end) {
          break;
        }
        if (index >= start) {
          characters.push(character.value);
        }
        index++;
        character = iterator.next();
      }
      const substring1 = characters.join(_constants.EMPTY_STRING);
      return substring1;
    }
    var _default = {
      strcmp,
      strlen,
      indexOf,
      substring
    };
  });

  // node_modules/necessary/lib/utilities/version.js
  var require_version = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get migrate() {
        return migrate;
      }
    });
    function migrate(json, migrationMap, latestVersion) {
      let {version} = json;
      while (version !== latestVersion) {
        const migrateFunction = migrationMap[version];
        json = migrateFunction(json);
        ({version} = json);
      }
      return json;
    }
    var _default = {
      migrate
    };
  });

  // node_modules/necessary/lib/utilities/asynchronous.js
  var require_asynchronous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get backwardsForEach() {
        return backwardsForEach;
      },
      get default() {
        return _default;
      },
      get eventually() {
        return eventually;
      },
      get forEach() {
        return forEach;
      },
      get forwardsForEach() {
        return forwardsForEach;
      },
      get repeatedly() {
        return repeatedly;
      },
      get sequence() {
        return sequence;
      },
      get whilst() {
        return whilst;
      }
    });
    function whilst(operation, done, context2) {
      let count = -1;
      function next() {
        count++;
        const index = count;
        operation(next, done, context2, index);
      }
      next();
    }
    function forEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    function sequence(operations, done, context2) {
      const length = operations.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, operation = operations[index];
          operation(next, done, context2, index);
        }
      }
      next();
    }
    function eventually(operations, done, context2) {
      const length = operations.length;
      if (length === 0) {
        done();
        return;
      }
      let count = 0;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        }
      }
      operations.forEach((operation, index) => {
        operation(next, done, context2, index);
      });
    }
    function repeatedly(operation, length, done, context2) {
      if (length === 0) {
        done();
        return;
      }
      let count = 0;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        }
      }
      for (let index = 0; index < length; index++) {
        operation(next, done, context2, index);
      }
    }
    function forwardsForEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    function backwardsForEach(array, operation, done, context2) {
      const length = array.length;
      let count = length;
      function next() {
        count--;
        const terminate = count === -1;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    var _default = {
      whilst,
      forEach,
      sequence,
      eventually,
      repeatedly,
      forwardsForEach,
      backwardsForEach
    };
  });

  // node_modules/necessary/lib/utilities/ajax.js
  var require_ajax = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get get() {
        return get;
      },
      get post() {
        return post;
      },
      get request() {
        return request;
      }
    });
    var _constants = require_constants2();
    var _methods = require_methods();
    var _contentTypes = require_contentTypes();
    var _headers = require_headers();
    var _http = require_http();
    function get(host, uri, query, headers, responseType, callback) {
      if (typeof headers === _constants.FUNCTION) {
        callback = headers;
        responseType = null;
        headers = {};
      }
      if (typeof responseType === _constants.FUNCTION) {
        callback = responseType;
        if (typeof headers === _constants.STRING) {
          responseType = headers;
          headers = {};
        } else {
          responseType = null;
        }
      }
      const method = _methods.GET_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, content = null;
      underwriteAcceptHeader(headers, accept);
      request(host, uri, query, method, content, headers, responseType, callback);
    }
    function post(host, uri, query, content, headers, responseType, callback) {
      if (typeof headers === _constants.FUNCTION) {
        callback = headers;
        responseType = null;
        headers = {};
      }
      if (typeof responseType === _constants.FUNCTION) {
        callback = responseType;
        if (typeof headers === _constants.STRING) {
          responseType = headers;
          headers = {};
        } else {
          responseType = null;
        }
      }
      const method = _methods.POST_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, contentType = _contentTypes.APPLICATION_JSON_CONTENT_TYPE;
      underwriteAcceptHeader(headers, accept);
      underwriteContentTypeHeader(headers, contentType);
      request(host, uri, query, method, content, headers, responseType, callback);
    }
    function request(host, uri, query, method, content, headers, responseType, callback) {
      const url = (0, _http.urlFromHostURIAndQuery)(host, uri, query), accept = headers[_headers.ACCEPT_HEADER] || null, contentType = headers[_headers.CONTENT_TYPE_HEADER] || null, xmlHttpRequest = new XMLHttpRequest();
      if (contentType === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
        const json = content, jsonString = JSON.stringify(json);
        content = jsonString;
      }
      if (responseType !== null) {
        Object.assign(xmlHttpRequest, {
          responseType
        });
      }
      xmlHttpRequest.onreadystatechange = () => {
        const {readyState, status, response} = xmlHttpRequest, statusCode = status;
        if (readyState == 4) {
          let content2 = response;
          if (accept === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
            try {
              const jsonString = content2, json = JSON.parse(jsonString);
              content2 = json;
            } catch (error) {
              content2 = null;
            }
          }
          callback(content2, statusCode);
        }
      };
      xmlHttpRequest.open(method, url);
      if (accept !== null) {
        xmlHttpRequest.setRequestHeader(_headers.ACCEPT_HEADER, accept);
      }
      if (contentType !== null) {
        xmlHttpRequest.setRequestHeader(_headers.CONTENT_TYPE_HEADER, contentType);
      }
      content !== null ? xmlHttpRequest.send(content) : xmlHttpRequest.send();
    }
    var _default = {
      get,
      post,
      request
    };
    function underwriteAcceptHeader(headers, accept) {
      const name = _headers.ACCEPT_HEADER, value = accept;
      (0, _http.underwrite)(headers, name, value);
    }
    function underwriteContentTypeHeader(headers, contentTYpe) {
      const name = _headers.CONTENT_TYPE_HEADER, value = contentTYpe;
      (0, _http.underwrite)(headers, name, value);
    }
  });

  // node_modules/necessary/lib/browser.js
  var require_browser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ajaxUtilities() {
        return _ajax.default;
      },
      get arrayUtilities() {
        return _array.default;
      },
      get asynchronousUtilities() {
        return _asynchronous.default;
      },
      get characters() {
        return _characters.default;
      },
      get contentTypes() {
        return _contentTypes.default;
      },
      get encodings() {
        return _encodings.default;
      },
      get headers() {
        return _headers.default;
      },
      get httpUtilities() {
        return _http.default;
      },
      get keyCodes() {
        return _keyCodes.default;
      },
      get levels() {
        return _levels.default;
      },
      get methods() {
        return _methods.default;
      },
      get pathUtilities() {
        return _path.default;
      },
      get statusCodes() {
        return _statusCodes.default;
      },
      get statusMessages() {
        return _statusMessages.default;
      },
      get stringUtilities() {
        return _string.default;
      },
      get versionUtilities() {
        return _version.default;
      }
    });
    var _levels = /* @__PURE__ */ _interop_require_default(require_levels());
    var _methods = /* @__PURE__ */ _interop_require_default(require_methods());
    var _headers = /* @__PURE__ */ _interop_require_default(require_headers());
    var _keyCodes = /* @__PURE__ */ _interop_require_default(require_keyCodes());
    var _encodings = /* @__PURE__ */ _interop_require_default(require_encodings());
    var _characters = /* @__PURE__ */ _interop_require_default(require_characters());
    var _statusCodes = /* @__PURE__ */ _interop_require_default(require_statusCodes());
    var _contentTypes = /* @__PURE__ */ _interop_require_default(require_contentTypes());
    var _statusMessages = /* @__PURE__ */ _interop_require_default(require_statusMessages());
    var _path = /* @__PURE__ */ _interop_require_default(require_path());
    var _http = /* @__PURE__ */ _interop_require_default(require_http());
    var _array = /* @__PURE__ */ _interop_require_default(require_array2());
    var _string = /* @__PURE__ */ _interop_require_default(require_string2());
    var _version = /* @__PURE__ */ _interop_require_default(require_version());
    var _asynchronous = /* @__PURE__ */ _interop_require_default(require_asynchronous());
    var _ajax = /* @__PURE__ */ _interop_require_default(require_ajax());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-lexers/lib/constants.js
  var require_constants3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_AMPERSAND() {
        return ESCAPED_AMPERSAND;
      },
      get ESCAPED_GREATER_THAN() {
        return ESCAPED_GREATER_THAN;
      },
      get ESCAPED_LESS_THAN() {
        return ESCAPED_LESS_THAN;
      },
      get V() {
        return V;
      }
    });
    var V = "v";
    var EMPTY_STRING = "";
    var ESCAPED_AMPERSAND = "&amp;";
    var ESCAPED_LESS_THAN = "&lt;";
    var ESCAPED_GREATER_THAN = "&gt;";
  });

  // node_modules/occam-lexers/lib/utilities/content.js
  var require_content = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "sanitiseContent", {
      enumerable: true,
      get: function() {
        return sanitiseContent;
      }
    });
    var _constants = require_constants3();
    function sanitiseContent(content) {
      const sanitisedContent = content.replace(/&/g, _constants.ESCAPED_AMPERSAND).replace(/</g, _constants.ESCAPED_LESS_THAN).replace(/>/g, _constants.ESCAPED_GREATER_THAN);
      return sanitisedContent;
    }
  });

  // node_modules/occam-lexers/lib/types.js
  var require_types = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get commentType() {
        return commentType;
      },
      get default() {
        return _default;
      },
      get endOfLineCommentType() {
        return endOfLineCommentType;
      },
      get endOfLineType() {
        return endOfLineType;
      },
      get endOfMultiLineCommentType() {
        return endOfMultiLineCommentType;
      },
      get middleOfMultiLineCommentType() {
        return middleOfMultiLineCommentType;
      },
      get nameType() {
        return nameType;
      },
      get numberType() {
        return numberType;
      },
      get regularExpressionType() {
        return regularExpressionType;
      },
      get singleLineCommentType() {
        return singleLineCommentType;
      },
      get startOfMultiLineCommentType() {
        return startOfMultiLineCommentType;
      },
      get stringLiteralType() {
        return stringLiteralType;
      },
      get typeType() {
        return typeType;
      },
      get whitespaceType() {
        return whitespaceType;
      }
    });
    var typeType = "type";
    var nameType = "name";
    var numberType = "number";
    var commentType = "comment";
    var endOfLineType = "end-of-line";
    var whitespaceType = "whitespace";
    var stringLiteralType = "string-literal";
    var endOfLineCommentType = `${endOfLineType} ${commentType}`;
    var singleLineCommentType = `single-line ${commentType}`;
    var regularExpressionType = "regular-expression";
    var endOfMultiLineCommentType = `end-of-multi-line ${commentType}`;
    var startOfMultiLineCommentType = `start-of-multi-line ${commentType}`;
    var middleOfMultiLineCommentType = `middle-of-multi-line ${commentType}`;
    var _default = {
      typeType,
      nameType,
      numberType,
      commentType,
      endOfLineType,
      whitespaceType,
      stringLiteralType,
      endOfLineCommentType,
      singleLineCommentType,
      regularExpressionType,
      endOfMultiLineCommentType,
      startOfMultiLineCommentType,
      middleOfMultiLineCommentType
    };
  });

  // node_modules/occam-lexers/lib/token.js
  var require_token = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Token;
      }
    });
    var _necessary = require_browser();
    var _content = require_content();
    var _types = require_types();
    var {first: first2} = _necessary.arrayUtilities;
    var {strlen} = _necessary.stringUtilities;
    var Token = class {
      constructor(type, content, significant) {
        this.type = type;
        this.content = content;
        this.significant = significant;
      }
      getType() {
        return this.type;
      }
      getContent() {
        return this.content;
      }
      getContentLength(naive = false) {
        const contentLength = naive ? this.content.length : strlen(this.content);
        return contentLength;
      }
      isSignificant() {
        return this.significant;
      }
      isCommentToken() {
        const typeIncludesCommentType = this.type.includes(_types.commentType), commentToken = typeIncludesCommentType;
        return commentToken;
      }
      isEndOfLineToken() {
        const typeEndOfLineType = this.type.includes(_types.endOfLineType), endOfLineToken = typeEndOfLineType;
        return endOfLineToken;
      }
      isWhitespaceToken() {
        const typeWhitespaceType = this.type === _types.whitespaceType, whitespaceToken = typeWhitespaceType;
        return whitespaceToken;
      }
      match(token) {
        let matches = false;
        if (token !== null) {
          const type = token.getType(), content = token.getContent(), significant = token.isSignificant();
          matches = this.type === type && this.content === content && this.significant === significant;
        }
        return matches;
      }
      asHTML() {
        const className = this.type, sanitisedContent = (0, _content.sanitiseContent)(this.content), html = `<span class="${className}">${sanitisedContent}</span>`;
        return html;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, type = this.type, content = this.content, significant = this.significant, token = new Class(type, content, significant, ...remainingArguments);
        return token;
      }
      static match(Class, content, significant, ...remainingArguments) {
        let token = null;
        const {regularExpression} = Class, matches = content.match(regularExpression);
        if (matches !== null) {
          const {index} = matches;
          if (index === 0) {
            const firstMatch = first2(matches);
            content = firstMatch;
            const contentLength = content.length;
            if (contentLength > 0) {
              const {type} = Class;
              token = new Class(type, content, significant, ...remainingArguments);
            }
          }
        }
        return token;
      }
      static fromContent(Class, content, significant, ...remainingArguments) {
        const {type} = Class, token = new Class(type, content, significant, ...remainingArguments);
        return token;
      }
      static fromContentAndType(Class, content, type, significant, ...remainingArguments) {
        return new Class(type, content, significant, ...remainingArguments);
      }
    };
  });

  // node_modules/occam-lexers/lib/token/significant.js
  var require_significant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantToken;
      }
    });
    var _token = /* @__PURE__ */ _interop_require_default(require_token());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantToken = class extends _token.default {
      static match(Class, content, ...remainingArguments) {
        if (content === void 0) {
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.match(Class, content, significant, ...remainingArguments);
        return significantToken;
      }
      static fromContent(Class, content, ...remainingArguments) {
        if (content === void 0) {
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.fromContent(Class, content, significant, ...remainingArguments);
        return significantToken;
      }
      static fromContentAndType(Class, content, type, ...remainingArguments) {
        if (type === void 0) {
          type = content;
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.fromContentAndType(Class, content, type, significant, ...remainingArguments);
        return significantToken;
      }
    };
  });

  // node_modules/occam-lexers/lib/rule.js
  var require_rule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Rule;
      }
    });
    var _necessary = require_browser();
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _constants = require_constants3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var Rule = class {
      constructor(type, regularExpression) {
        this.type = type;
        this.regularExpression = regularExpression;
      }
      getType() {
        return this.type;
      }
      getRegularExpression() {
        return this.regularExpression;
      }
      match(content) {
        let significantToken = null;
        const matches = content.match(this.regularExpression);
        if (matches !== null) {
          const {index} = matches;
          if (index === 0) {
            const firstMatch = first2(matches);
            content = firstMatch;
            const contentLength = content.length;
            if (contentLength > 0) {
              significantToken = _significant.default.fromContentAndType(content, this.type);
            }
          }
        }
        return significantToken;
      }
      static fromToken(Token) {
        const {type, regularExpression} = Token, rule = new Rule(type, regularExpression);
        return rule;
      }
      static fromEntry(entry) {
        const entryKeys = Object.keys(entry), firstEntryKey = first2(entryKeys), type = firstEntryKey, regularExpressionPattern = entry[type], regularExpression = regularExpressionFromRegularExpressionPattern(regularExpressionPattern), rule = new Rule(type, regularExpression);
        return rule;
      }
      static fromTypeAndRegularExpressionPattern(type, regularExpressionPattern) {
        const regularExpression = regularExpressionFromRegularExpressionPattern(regularExpressionPattern), rule = new Rule(type, regularExpression);
        return rule;
      }
    };
    function regularExpressionFromRegularExpressionPattern(regularExpressionPattern) {
      const flags = _constants.V, regExp = new RegExp(regularExpressionPattern, flags), regularExpression = regExp;
      return regularExpression;
    }
  });

  // node_modules/occam-lexers/lib/specialSymbols.js
  var require_specialSymbols = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get asterisk() {
        return asterisk;
      },
      get closeBracket() {
        return closeBracket;
      },
      get default() {
        return _default;
      },
      get ellipsis() {
        return ellipsis;
      },
      get endOfLine() {
        return endOfLine;
      },
      get epsilon() {
        return epsilon;
      },
      get noWhitespace() {
        return noWhitespace;
      },
      get opaque() {
        return opaque;
      },
      get openBracket() {
        return openBracket;
      },
      get plus() {
        return plus;
      },
      get questionMark() {
        return questionMark;
      },
      get semiOpaque() {
        return semiOpaque;
      },
      get separator() {
        return separator;
      },
      get startOfContent() {
        return startOfContent;
      },
      get terminator() {
        return terminator;
      },
      get verticalBar() {
        return verticalBar;
      },
      get wildcard() {
        return wildcard;
      }
    });
    var plus = "+";
    var opaque = ".";
    var epsilon = "\u03B5";
    var wildcard = ".";
    var asterisk = "*";
    var ellipsis = "...";
    var separator = "::=";
    var semiOpaque = "..";
    var terminator = ";";
    var verticalBar = "|";
    var openBracket = "(";
    var closeBracket = ")";
    var questionMark = "?";
    var endOfLine = "<END_OF_LINE>";
    var noWhitespace = "<NO_WHITESPACE>";
    var startOfContent = "<START_OF_CONTENT>";
    var _default = {
      plus,
      opaque,
      epsilon,
      wildcard,
      asterisk,
      ellipsis,
      separator,
      semiOpaque,
      terminator,
      verticalBar,
      openBracket,
      closeBracket,
      questionMark,
      endOfLine,
      noWhitespace,
      startOfContent
    };
  });

  // node_modules/occam-lexers/lib/utilities/rules.js
  var require_rules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get rulesAsEntries() {
        return rulesAsEntries;
      }
    });
    function rulesAsEntries(rules) {
      const entries = rules.map((rule) => {
        const entry = ruleAsEntry(rule);
        return entry;
      });
      return entries;
    }
    var _default = {
      rulesAsEntries
    };
    function ruleAsEntry(rule) {
      const type = rule.getType(), regularExpression = rule.getRegularExpression(), {source} = regularExpression, entry = {
        [type]: source
      };
      return entry;
    }
  });

  // node_modules/occam-lexers/lib/utilities/lexer.js
  var require_lexer = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get lexerFromRules() {
        return lexerFromRules;
      },
      get rulesFromEntries() {
        return rulesFromEntries;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function rulesFromEntries(entries) {
      const rules = entries.map((entry) => {
        const rule = _rule.default.fromEntry(entry);
        return rule;
      });
      return rules;
    }
    function lexerFromRules(Class, rules) {
      const InCommentClasses = InCommentClassesFromClass(Class), NotInCommentClasses = NotInCommentClassesFromClass(Class), lexer = new Class(rules, InCommentClasses, NotInCommentClasses);
      return lexer;
    }
    var _default = {
      rulesFromEntries,
      lexerFromRules
    };
    function InCommentClassesFromClass(Class) {
      const {EndOfLineCommentToken, EndOfMultiLineCommentToken, MiddleOfMultiLineCommentToken} = Class;
      const InCommentClasses = [
        EndOfLineCommentToken,
        EndOfMultiLineCommentToken,
        MiddleOfMultiLineCommentToken
      ];
      return InCommentClasses;
    }
    function NotInCommentClassesFromClass(Class) {
      const {EndOfLineToken, WhitespaceToken, SingleLineCommentToken, RegularExpressionToken, StartOfMultiLineCommentToken, SinglyQuotedStringLiteralToken, DoublyQuotedStringLiteralToken} = Class;
      const NotInCommentClasses = [
        EndOfLineToken,
        WhitespaceToken,
        StartOfMultiLineCommentToken,
        SingleLineCommentToken,
        RegularExpressionToken,
        SinglyQuotedStringLiteralToken,
        DoublyQuotedStringLiteralToken
      ];
      return NotInCommentClasses;
    }
  });

  // node_modules/occam-lexers/lib/bnf/entries.js
  var require_entries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\||\\(|\\)|\\?|\\*|\\+|\\.\\.\\.|\\.\\.|\\.|::=|;|\u03B5|<START_OF_CONTENT>|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        number: "^(?:0|[1-9][0-9]*)"
      },
      {
        name: "^[\\w~]+"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-lexers/lib/utilities/token.js
  var require_token2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "inCommentFromTokenAndInComment", {
      enumerable: true,
      get: function() {
        return inCommentFromTokenAndInComment;
      }
    });
    function inCommentFromTokenAndInComment(token, inComment) {
      const tokenCommentToken = token.isCommentToken();
      if (tokenCommentToken) {
        const commentToken = token, commentTokenInCommentPreserving = commentToken.isInCommentPreserving();
        inComment = commentTokenInCommentPreserving;
      }
      return inComment;
    }
  });

  // node_modules/occam-lexers/lib/common/lexer.js
  var require_lexer2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CommonLexer;
      }
    });
    var _constants = require_constants3();
    var _token = require_token2();
    var _lexer = require_lexer();
    var CommonLexer = class {
      constructor(rules, InCommentClasses, NotInCommentClasses) {
        this.rules = rules;
        this.InCommentClasses = InCommentClasses;
        this.NotInCommentClasses = NotInCommentClasses;
      }
      getRules() {
        return this.rules;
      }
      getInCommentClasses() {
        return this.InCommentClasses;
      }
      getNotInCommentClasses() {
        return this.NotInCommentClasses;
      }
      tokenise(content, inComment = false) {
        const tokens = [];
        while (content !== _constants.EMPTY_STRING) {
          let token = null;
          const Classes = inComment ? this.InCommentClasses : this.NotInCommentClasses;
          Classes.some((Class) => {
            if (Class !== null) {
              token = Class.match(content);
              if (token !== null) {
                return true;
              }
            }
          });
          if (token === null) {
            let significantToken = null;
            this.rules.some((rule) => {
              significantToken = rule.match(content);
              if (significantToken !== null) {
                token = significantToken;
                return true;
              }
            });
          }
          if (token === null) {
            throw new Error(`The content '${content}' cannot be tokenised.`);
          }
          tokens.push(token);
          inComment = (0, _token.inCommentFromTokenAndInComment)(token, inComment);
          const naive = true, tokenContentLength = token.getContentLength(naive), start = tokenContentLength;
          content = content.substring(start);
        }
        return tokens;
      }
      static fromNothing(Class) {
        const {entries} = Class, rules = (0, _lexer.rulesFromEntries)(entries), lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
      static fromRules(Class, rules) {
        const lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
      static fromEntries(Class, entries) {
        const rules = (0, _lexer.rulesFromEntries)(entries), lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
    };
  });

  // node_modules/occam-lexers/lib/token/nonSignificant.js
  var require_nonSignificant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonSignificantToken;
      }
    });
    var _token = /* @__PURE__ */ _interop_require_default(require_token());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonSignificantToken = class extends _token.default {
      static match(Class, content) {
        const significant = false, nonSignificantToken = _token.default.match(Class, content, significant);
        return nonSignificantToken;
      }
      static fromContent(Class, content) {
        const significant = false, nonSignificantToken = _token.default.fromContent(Class, content, significant);
        return nonSignificantToken;
      }
      static fromContentAndType(Class, content, type) {
        const significant = false, nonSignificantToken = _token.default.fromContentAndType(Class, content, type, significant);
        return nonSignificantToken;
      }
    };
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/whitespace.js
  var require_whitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WhitespaceToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _WhitespaceToken = class extends _nonSignificant.default {
      static match(content) {
        return _nonSignificant.default.match(_WhitespaceToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_WhitespaceToken, content);
      }
    };
    var WhitespaceToken = _WhitespaceToken;
    __publicField(WhitespaceToken, "type", _types.whitespaceType);
    __publicField(WhitespaceToken, "regularExpression", /^[\t\v ]+/);
  });

  // node_modules/occam-lexers/lib/token/significant/regularExpression.js
  var require_regularExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _RegularExpressionToken = class extends _significant.default {
      static match(content) {
        return _significant.default.match(_RegularExpressionToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_RegularExpressionToken, content);
      }
    };
    var RegularExpressionToken = _RegularExpressionToken;
    __publicField(RegularExpressionToken, "type", _types.regularExpressionType);
    __publicField(RegularExpressionToken, "regularExpression", /^\/(?:\\[^\s]|[^\/\r\n\f])*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/endOfLine.js
  var require_endOfLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNonSignificantToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineNonSignificantToken = class extends _nonSignificant.default {
      asHTML() {
        const content = this.getContent(), html = content;
        return html;
      }
      static match(content) {
        return _nonSignificant.default.match(_EndOfLineNonSignificantToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_EndOfLineNonSignificantToken, content);
      }
    };
    var EndOfLineNonSignificantToken = _EndOfLineNonSignificantToken;
    __publicField(EndOfLineNonSignificantToken, "type", _types.endOfLineType);
    __publicField(EndOfLineNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral.js
  var require_stringLiteral = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralToken;
      }
    });
    var _necessary = require_browser();
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {substring} = _necessary.stringUtilities;
    var StringLiteralToken = class extends _significant.default {
      getString() {
        const content = this.getContent(), contentLength = this.getContentLength(), start = 1, end = contentLength - 1, string = substring(content, start, end);
        return string;
      }
      static match(Class, content) {
        return _significant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _significant.default.fromContent(Class, content);
      }
    };
    __publicField(StringLiteralToken, "type", _types.stringLiteralType);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/doublyQuoted.js
  var require_doublyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DoublyQuotedStringLiteralToken;
      }
    });
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _DoublyQuotedStringLiteralToken = class extends _stringLiteral.default {
      static match(content) {
        return _stringLiteral.default.match(_DoublyQuotedStringLiteralToken, content);
      }
      static fromContent(content) {
        return _stringLiteral.default.fromContent(_DoublyQuotedStringLiteralToken, content);
      }
    };
    var DoublyQuotedStringLiteralToken = _DoublyQuotedStringLiteralToken;
    __publicField(DoublyQuotedStringLiteralToken, "regularExpression", /^"(?:\\[^\s]|[^"\\\r\n])*"/);
  });

  // node_modules/occam-lexers/lib/bnf/lexer.js
  var require_lexer3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFLexer;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BNFLexer = class extends _lexer.default {
      tokensFromBNF(bnf) {
        const content = bnf, tokens = super.tokenise(content);
        return tokens;
      }
      static fromNothing() {
        return _lexer.default.fromNothing(_BNFLexer);
      }
      static fromRules(rules) {
        return _lexer.default.fromRules(_BNFLexer, rules);
      }
      static fromEntries(entries) {
        return _lexer.default.fromEntries(_BNFLexer, entries);
      }
    };
    var BNFLexer = _BNFLexer;
    __publicField(BNFLexer, "entries", _entries.default);
    __publicField(BNFLexer, "EndOfLineToken", _endOfLine.default);
    __publicField(BNFLexer, "WhitespaceToken", _whitespace.default);
    __publicField(BNFLexer, "EndOfLineCommentToken", null);
    __publicField(BNFLexer, "RegularExpressionToken", _regularExpression.default);
    __publicField(BNFLexer, "SingleLineCommentToken", null);
    __publicField(BNFLexer, "EndOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "StartOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(BNFLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/basic/entries.js
  var require_entries2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        digit: "^\\d+"
      },
      {
        bracket: "^(?:\\(|\\))"
      },
      {
        operator: "^(?:\\+|-|\\*|\\/)"
      },
      {
        unassigned: "^[^\\s]"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/singlyQuoted.js
  var require_singlyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SinglyQuotedStringLiteralToken;
      }
    });
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _SinglyQuotedStringLiteralToken = class extends _stringLiteral.default {
      static match(content) {
        return _stringLiteral.default.match(_SinglyQuotedStringLiteralToken, content);
      }
      static fromContent(content) {
        return _stringLiteral.default.fromContent(_SinglyQuotedStringLiteralToken, content);
      }
    };
    var SinglyQuotedStringLiteralToken = _SinglyQuotedStringLiteralToken;
    __publicField(SinglyQuotedStringLiteralToken, "regularExpression", /^'(?:\\[^\s]|[^'\\\r\n])*'/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine.js
  var require_singleLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SingleLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SingleLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = false;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(SingleLineCommentToken, "type", _types.singleLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/pythonStyle.js
  var require_pythonStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleSingleLineCommentToken;
      }
    });
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleSingleLineCommentToken = class extends _singleLine.default {
      static match(content) {
        return _singleLine.default.match(_PythonStyleSingleLineCommentToken, content);
      }
      static fromContent(content) {
        return _singleLine.default.fromContent(_PythonStyleSingleLineCommentToken, content);
      }
    };
    var PythonStyleSingleLineCommentToken = _PythonStyleSingleLineCommentToken;
    __publicField(PythonStyleSingleLineCommentToken, "regularExpression", /^#[^\r\n\f]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/endOfLine.js
  var require_endOfLine2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineCommentNonSignificantToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineCommentNonSignificantToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(content) {
        return _nonSignificant.default.match(_EndOfLineCommentNonSignificantToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_EndOfLineCommentNonSignificantToken, content);
      }
    };
    var EndOfLineCommentNonSignificantToken = _EndOfLineCommentNonSignificantToken;
    __publicField(EndOfLineCommentNonSignificantToken, "type", _types.endOfLineCommentType);
    __publicField(EndOfLineCommentNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf.js
  var require_endOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = false;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(EndOfMultiLineCommentToken, "type", _types.endOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/pythonStyle.js
  var require_pythonStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleEndOfMultiLineCommentToken;
      }
    });
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleEndOfMultiLineCommentToken = class extends _endOf.default {
      static match(content) {
        return _endOf.default.match(_PythonStyleEndOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _endOf.default.fromContent(_PythonStyleEndOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleEndOfMultiLineCommentToken = _PythonStyleEndOfMultiLineCommentToken;
    __publicField(PythonStyleEndOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf.js
  var require_startOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(StartOfMultiLineCommentToken, "type", _types.startOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/pythonStyle.js
  var require_pythonStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleStartOfMultiLineCommentToken;
      }
    });
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleStartOfMultiLineCommentToken = class extends _startOf.default {
      static match(content) {
        return _startOf.default.match(_PythonStyleStartOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _startOf.default.fromContent(_PythonStyleStartOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleStartOfMultiLineCommentToken = _PythonStyleStartOfMultiLineCommentToken;
    __publicField(PythonStyleStartOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf.js
  var require_middleOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return MiddleOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var MiddleOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(MiddleOfMultiLineCommentToken, "type", _types.middleOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/pythonStyle.js
  var require_pythonStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleMiddleOfMultiLineCommentToken;
      }
    });
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleMiddleOfMultiLineCommentToken = class extends _middleOf.default {
      static match(content) {
        return _middleOf.default.match(_PythonStyleMiddleOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _middleOf.default.fromContent(_PythonStyleMiddleOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleMiddleOfMultiLineCommentToken = _PythonStyleMiddleOfMultiLineCommentToken;
    __publicField(PythonStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n\f]+?(?=###)|[^\r\n\f]+)/);
  });

  // node_modules/occam-lexers/lib/basic/lexer.js
  var require_lexer4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BasicLexer;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries2());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _singlyQuoted = /* @__PURE__ */ _interop_require_default(require_singlyQuoted());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    var _pythonStyle = /* @__PURE__ */ _interop_require_default(require_pythonStyle());
    var _endOfLine1 = /* @__PURE__ */ _interop_require_default(require_endOfLine2());
    var _pythonStyle1 = /* @__PURE__ */ _interop_require_default(require_pythonStyle2());
    var _pythonStyle2 = /* @__PURE__ */ _interop_require_default(require_pythonStyle3());
    var _pythonStyle3 = /* @__PURE__ */ _interop_require_default(require_pythonStyle4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BasicLexer = class extends _lexer.default {
      static fromNothing() {
        return _lexer.default.fromNothing(_BasicLexer);
      }
      static fromRules(rules) {
        return _lexer.default.fromRules(_BasicLexer, rules);
      }
      static fromEntries(entries) {
        return _lexer.default.fromEntries(_BasicLexer, entries);
      }
    };
    var BasicLexer = _BasicLexer;
    __publicField(BasicLexer, "entries", _entries.default);
    __publicField(BasicLexer, "EndOfLineToken", _endOfLine.default);
    __publicField(BasicLexer, "WhitespaceToken", _whitespace.default);
    __publicField(BasicLexer, "EndOfLineCommentToken", _endOfLine1.default);
    __publicField(BasicLexer, "RegularExpressionToken", _regularExpression.default);
    __publicField(BasicLexer, "SingleLineCommentToken", _pythonStyle.default);
    __publicField(BasicLexer, "EndOfMultiLineCommentToken", _pythonStyle1.default);
    __publicField(BasicLexer, "StartOfMultiLineCommentToken", _pythonStyle2.default);
    __publicField(BasicLexer, "MiddleOfMultiLineCommentToken", _pythonStyle3.default);
    __publicField(BasicLexer, "SinglyQuotedStringLiteralToken", _singlyQuoted.default);
    __publicField(BasicLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/token/significant/endOfLine.js
  var require_endOfLine3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineSignificantToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineSignificantToken = class extends _significant.default {
      asHTML() {
        const content = this.getContent(), html = content;
        return html;
      }
      static match(content) {
        return _significant.default.match(_EndOfLineSignificantToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_EndOfLineSignificantToken, content);
      }
    };
    var EndOfLineSignificantToken = _EndOfLineSignificantToken;
    __publicField(EndOfLineSignificantToken, "type", _types.endOfLineType);
    __publicField(EndOfLineSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/significant/comment/endOfLine.js
  var require_endOfLine4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineCommentSignificantToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineCommentSignificantToken = class extends _significant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(content) {
        return _significant.default.match(_EndOfLineCommentSignificantToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_EndOfLineCommentSignificantToken, content);
      }
    };
    var EndOfLineCommentSignificantToken = _EndOfLineCommentSignificantToken;
    __publicField(EndOfLineCommentSignificantToken, "type", _types.endOfLineCommentType);
    __publicField(EndOfLineCommentSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/cStyle.js
  var require_cStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleSingleLineCommentToken;
      }
    });
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleSingleLineCommentToken = class extends _singleLine.default {
      static match(content) {
        return _singleLine.default.match(_CStyleSingleLineCommentToken, content);
      }
      static fromContent(content) {
        return _singleLine.default.fromContent(_CStyleSingleLineCommentToken, content);
      }
    };
    var CStyleSingleLineCommentToken = _CStyleSingleLineCommentToken;
    __publicField(CStyleSingleLineCommentToken, "regularExpression", /^\/\/[^\r\n\f]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/cStyle.js
  var require_cStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleEndOfMultiLineCommentToken;
      }
    });
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleEndOfMultiLineCommentToken = class extends _endOf.default {
      static match(content) {
        return _endOf.default.match(_CStyleEndOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _endOf.default.fromContent(_CStyleEndOfMultiLineCommentToken, content);
      }
    };
    var CStyleEndOfMultiLineCommentToken = _CStyleEndOfMultiLineCommentToken;
    __publicField(CStyleEndOfMultiLineCommentToken, "regularExpression", /^\*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/cStyle.js
  var require_cStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleStartOfMultiLineCommentToken;
      }
    });
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleStartOfMultiLineCommentToken = class extends _startOf.default {
      static match(content) {
        return _startOf.default.match(_CStyleStartOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _startOf.default.fromContent(_CStyleStartOfMultiLineCommentToken, content);
      }
    };
    var CStyleStartOfMultiLineCommentToken = _CStyleStartOfMultiLineCommentToken;
    __publicField(CStyleStartOfMultiLineCommentToken, "regularExpression", /^\/\*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/cStyle.js
  var require_cStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleMiddleOfMultiLineCommentToken;
      }
    });
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleMiddleOfMultiLineCommentToken = class extends _middleOf.default {
      static match(content) {
        return _middleOf.default.match(_CStyleMiddleOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _middleOf.default.fromContent(_CStyleMiddleOfMultiLineCommentToken, content);
      }
    };
    var CStyleMiddleOfMultiLineCommentToken = _CStyleMiddleOfMultiLineCommentToken;
    __publicField(CStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n\f]+?(?=\*\/)|[^\r\n\f]+)/);
  });

  // node_modules/occam-lexers/lib/index.js
  var require_lib3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BNFLexer() {
        return _lexer1.default;
      },
      get BasicLexer() {
        return _lexer2.default;
      },
      get CStyleEndOfMultiLineCommentToken() {
        return _cStyle1.default;
      },
      get CStyleMiddleOfMultiLineCommentToken() {
        return _cStyle3.default;
      },
      get CStyleSingleLineCommentToken() {
        return _cStyle.default;
      },
      get CStyleStartOfMultiLineCommentToken() {
        return _cStyle2.default;
      },
      get CommonLexer() {
        return _lexer3.default;
      },
      get DoublyQuotedStringLiteralToken() {
        return _doublyQuoted.default;
      },
      get EndOfLineCommentNonSignificantToken() {
        return _endOfLine3.default;
      },
      get EndOfLineCommentSignificantToken() {
        return _endOfLine2.default;
      },
      get EndOfLineNonSignificantToken() {
        return _endOfLine1.default;
      },
      get EndOfLineSignificantToken() {
        return _endOfLine.default;
      },
      get EndOfMultiLineCommentToken() {
        return _endOf.default;
      },
      get MiddleOfMultiLineCommentToken() {
        return _middleOf.default;
      },
      get NonSignificantToken() {
        return _nonSignificant.default;
      },
      get PythonStyleEndOfMultiLineCommentToken() {
        return _pythonStyle1.default;
      },
      get PythonStyleMiddleOfMultiLineCommentToken() {
        return _pythonStyle3.default;
      },
      get PythonStyleSingleLineCommentToken() {
        return _pythonStyle.default;
      },
      get PythonStyleStartOfMultiLineCommentToken() {
        return _pythonStyle2.default;
      },
      get RegularExpressionToken() {
        return _regularExpression.default;
      },
      get Rule() {
        return _rule.default;
      },
      get SignificantToken() {
        return _significant.default;
      },
      get SingleLineCommentToken() {
        return _singleLine.default;
      },
      get SinglyQuotedStringLiteralToken() {
        return _singlyQuoted.default;
      },
      get StartOfMultiLineCommentToken() {
        return _startOf.default;
      },
      get StringLiteralToken() {
        return _stringLiteral.default;
      },
      get WhitespaceToken() {
        return _whitespace.default;
      },
      get lexerUtilities() {
        return _lexer.default;
      },
      get rulesUtilities() {
        return _rules.default;
      },
      get specialSymbols() {
        return _specialSymbols.default;
      },
      get types() {
        return _types.default;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule());
    var _types = /* @__PURE__ */ _interop_require_default(require_types());
    var _specialSymbols = /* @__PURE__ */ _interop_require_default(require_specialSymbols());
    var _rules = /* @__PURE__ */ _interop_require_default(require_rules());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer());
    var _lexer1 = /* @__PURE__ */ _interop_require_default(require_lexer3());
    var _lexer2 = /* @__PURE__ */ _interop_require_default(require_lexer4());
    var _lexer3 = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine3());
    var _endOfLine1 = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _endOfLine2 = /* @__PURE__ */ _interop_require_default(require_endOfLine4());
    var _endOfLine3 = /* @__PURE__ */ _interop_require_default(require_endOfLine2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _singlyQuoted = /* @__PURE__ */ _interop_require_default(require_singlyQuoted());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    var _cStyle = /* @__PURE__ */ _interop_require_default(require_cStyle());
    var _cStyle1 = /* @__PURE__ */ _interop_require_default(require_cStyle2());
    var _cStyle2 = /* @__PURE__ */ _interop_require_default(require_cStyle3());
    var _cStyle3 = /* @__PURE__ */ _interop_require_default(require_cStyle4());
    var _pythonStyle = /* @__PURE__ */ _interop_require_default(require_pythonStyle());
    var _pythonStyle1 = /* @__PURE__ */ _interop_require_default(require_pythonStyle2());
    var _pythonStyle2 = /* @__PURE__ */ _interop_require_default(require_pythonStyle3());
    var _pythonStyle3 = /* @__PURE__ */ _interop_require_default(require_pythonStyle4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/entries.js
  var require_entries3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        media: "^@media"
      },
      {
        keyframes: "^@keyframes"
      },
      {
        colour: "^#(?:[0-9a-fA-F]{6}|[0-9a-fA-F]{3})"
      },
      {
        important: "^!important"
      },
      {
        percentage: "^(?:[0-9]+|[0-9]*\\.[0-9]+)%"
      },
      {
        frequency: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:hz|khz)"
      },
      {
        fraction: "^[1-9][0-9]*?fr"
      },
      {
        length: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:px|cm|mm|in|pt|pc)"
      },
      {
        angle: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:deg|rad|grad)"
      },
      {
        time: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:s|ms)"
      },
      {
        rems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)rem"
      },
      {
        ems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)em"
      },
      {
        number: "^[0-9]+|[0-9]*\\.[0-9]+"
      },
      {
        special: "^;|::|:|\\.|,|\\|=|~=|=|>|\\{|\\}|\\(|\\)|\\[|\\]"
      },
      {
        identifier: "^[_a-zA-Z0-9\\-]+"
      },
      {
        "logical-operator": "^(?:and|not)$"
      },
      {
        "plus-or-minus": "^[\\+\\-]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/with-style/lib/css/lexer.js
  var require_lexer5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CSSLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries3());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CSSLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CSSLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CSSLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CSSLexer, entries);
      }
    };
    var CSSLexer = _CSSLexer;
    __publicField(CSSLexer, "entries", _entries.default);
    __publicField(CSSLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(CSSLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CSSLexer, "EndOfLineCommentToken", null);
    __publicField(CSSLexer, "RegularExpressionToken", null);
    __publicField(CSSLexer, "SingleLineCommentToken", null);
    __publicField(CSSLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CSSLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-parsers/lib/bnf/bnf.js
  var require_bnf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

      document                 ::=  ( rule | error )+ ;

      rule                     ::=  name opacityModifier? "::=" definitions ";" ;

      name                     ::=  [name] ;

      definitions              ::=  definition ( "|" definition )* ;

      definition               ::=  part+ precedence? ;
 
      part                     ::=  nonTerminalPart quantifier*

                                 |  terminalPart quantifier*

                                 ;

      nonTerminalPart          ::=  choiceOfParts

                                 |  sequenceOfParts

                                 |  ruleName callAheadModifier?

                                 ;

      terminalPart             ::=  significantTokenType
  
                                 |  regularExpression
 
                                 |  stringLiteral
  
                                 |  endOfLine
  
                                 |  wildcard
  
                                 |  epsilon

                                 |  noWhitespace
                              
                                 |  startOfContent

                                 ;
                              
      sequenceOfParts          ::=  "(" part part+ ")" ;

      choiceOfParts            ::=  "(" partChoice ( "|" partChoice )+ ")" ;

      partChoice               ::=  part precedence? ;

      ruleName                 ::=  [name] ;

      significantTokenType     ::=  [type] ;

      regularExpression        ::=  [regular-expression] ;

      stringLiteral            ::=  [string-literal] ;

      precedence               ::=  "(" [number]? ")" ;
      
      endOfLine                ::=  "<END_OF_LINE>" ;
      
      wildcard                 ::=  "." ;

      epsilon                  ::=  "\u03B5" ;

      noWhitespace             ::=  "<NO_WHITESPACE>" ;                              

      startOfContent           ::+  "<START_OF_CONTENT>"; 
      
      quantifier               ::=  optionalQuantifier
 
                                 |  oneOrMoreQuantifier
  
                                 |  zeroOrMoreQuantifier
  
                                 ;

      opacityModifier          ::=  <NO_WHITESPACE>( "." | ".." );
      
      callAheadModifier        ::=  <NO_WHITESPACE>"..." ;

      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;

      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;

      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;

      error.                   ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-parsers/lib/constants.js
  var require_constants4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_BACKSLASH() {
        return ESCAPED_BACKSLASH;
      },
      get ESCAPED_DOUBLE_QUOTE() {
        return ESCAPED_DOUBLE_QUOTE;
      }
    });
    var EMPTY_STRING = "";
    var ESCAPED_BACKSLASH = "\\";
    var ESCAPED_DOUBLE_QUOTE = '"';
  });

  // node_modules/occam-parsers/lib/utilities/string.js
  var require_string3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "paddingFromPaddingLength", {
      enumerable: true,
      get: function() {
        return paddingFromPaddingLength;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {SPACE_CHARACTER} = _necessary.characters;
    function paddingFromPaddingLength(paddingLength) {
      let padding = _constants.EMPTY_STRING;
      for (let position = 0; position < paddingLength; position++) {
        padding += SPACE_CHARACTER;
      }
      return padding;
    }
  });

  // node_modules/occam-parsers/lib/rule.js
  var require_rule2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Rule;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var _occamlexers = require_lib3();
    var _string = require_string3();
    var {clear} = _necessary.arrayUtilities;
    var {opaque: opaqueSpecialSymbol, semiOpaque: semiOpaqueSpecialSymbol} = _occamlexers.specialSymbols;
    var Rule = class {
      constructor(name, opacity, definitions) {
        this.name = name;
        this.opacity = opacity;
        this.definitions = definitions;
      }
      getName() {
        return this.name;
      }
      getOpacity() {
        return this.opacity;
      }
      getDefinitions() {
        return this.definitions;
      }
      setName(name) {
        this.name = name;
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      setDefinitions(definitions) {
        this.definitions = definitions;
      }
      isOpaque() {
        const opaque = this.opacity === opaqueSpecialSymbol;
        return opaque;
      }
      isSemiOpaque() {
        const semiOpaque = this.opacity === semiOpaqueSpecialSymbol;
        return semiOpaque;
      }
      isTransparent() {
        const semiOpaque = this.opacity === null;
        return semiOpaque;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const opacity = this.opacity, ruleName = this.name, precedence = null, childNodes = [], NonTerminalNode = this.NonTerminalNodeFromRuleName(ruleName, state), nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), savedPrecedence = state.getSavedPrecedence();
        let node = nonTerminalNode;
        nodes.push(node);
        parsed = this.definitions.some((definition) => {
          let parsed2;
          clear(childNodes);
          const precedence2 = definition.getPrecedence();
          state.setPrecedence(precedence2);
          callback = () => {
            let parsed3;
            const precedence3 = state.getPrecedence();
            nonTerminalNode.setPrecedence(precedence3);
            parsed3 = true;
            if (parsed3) {
              node.setChildNodesParentNode();
            }
            const rewrittenNonTerminalNode = nonTerminalNode.rewrite(state);
            if (rewrittenNonTerminalNode !== null) {
              if (parsed3) {
                nodes.pop();
                node = rewrittenNonTerminalNode;
                nodes.push(node);
              }
            }
            if (parsed3) {
              const empty = node.isEmpty();
              if (empty) {
                parsed3 = false;
              }
            }
            if (parsed3) {
              const unprecedented = node.isUnprecedented();
              if (unprecedented) {
                parsed3 = false;
              }
            }
            if (parsed3) {
              if (callAhead !== null) {
                state.resetPrecedence(savedPrecedence);
                parsed3 = callAhead();
              }
            }
            if (rewrittenNonTerminalNode !== null) {
              if (!parsed3) {
                nodes.pop();
                node = nonTerminalNode;
                nodes.push(node);
              }
            }
            if (!parsed3) {
              node.resetChildNodesParentNode();
            }
            return parsed3;
          };
          parsed2 = definition.parse(childNodes, state, callback, callAhead);
          if (!parsed2) {
            state.resetPrecedence(savedPrecedence);
          }
          return parsed2;
        });
        if (!parsed) {
          nodes.pop();
        }
        if (callAhead === null) {
          state.resetPrecedence(savedPrecedence);
        }
        return parsed;
      }
      NonTerminalNodeFromRuleName(ruleName, state) {
        return state.NonTerminalNodeFromRuleName(ruleName);
      }
      asString(maximumRuleNameLength, multiLine = true) {
        const definitionsLength = this.definitions.length;
        multiLine = multiLine && definitionsLength > 1;
        const maximumPadding = (0, _string.paddingFromPaddingLength)(maximumRuleNameLength), definitionsString = this.definitions.reduce((definitionsString2, definition) => {
          const definitionString = definition.asString();
          if (definitionsString2 === _constants.EMPTY_STRING) {
            definitionsString2 = definitionString;
          } else {
            definitionsString2 = multiLine ? `${definitionsString2}

${maximumPadding}   | ${definitionString}` : `${definitionsString2} | ${definitionString}`;
          }
          return definitionsString2;
        }, _constants.EMPTY_STRING), ruleName = this.name, ruleNameLength = ruleName.length, opacityString = this.opacity === null ? _constants.EMPTY_STRING : this.opacity, opacityStringLength = opacityString.length, paddingLength = maximumRuleNameLength - ruleNameLength - opacityStringLength, padding = (0, _string.paddingFromPaddingLength)(paddingLength);
        const semicolonString = multiLine ? `

${maximumPadding}   ;` : " ;", string = `

${this.name}${opacityString}${padding} ::= ${definitionsString}${semicolonString}`;
        return string;
      }
      static fromNameOpacityAndDefinitions(Class, name, opacity, definitions) {
        if (definitions === void 0) {
          definitions = opacity;
          opacity = name;
          name = Class;
          Class = Rule;
        }
        const rule = new Class(name, opacity, definitions);
        return rule;
      }
    };
  });

  // node_modules/occam-parsers/lib/mixins/node.js
  var require_node = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var {push, first: first2, forwardsSome, backwardsSome} = _necessary.arrayUtilities;
    function getMultiplicity() {
      const childNodesLength = this.childNodes.length, multiplicity = childNodesLength;
      return multiplicity;
    }
    function mapChildNode(callback) {
      return this.childNodes.map(callback);
    }
    function someChildNode(callback) {
      return this.childNodes.some(callback);
    }
    function findChildNode(callback) {
      return this.childNodes.find(callback);
    }
    function everyChildNode(callback) {
      return this.childNodes.every(callback);
    }
    function filterChildNode(callback) {
      return this.childNodes.filter(callback);
    }
    function reduceChildNode(callback, initialValue) {
      return this.childNodes.reduce(callback, initialValue);
    }
    function forEachChildNode(callback) {
      this.childNodes.forEach(callback);
    }
    function forwardsSomeChildNode(callback) {
      return forwardsSome(this.childNodes, callback);
    }
    function backwardsSomeChildNode(callback) {
      return backwardsSome(this.childNodes, callback);
    }
    function indexOfChildNode(childNode) {
      return this.childNodes.indexOf(childNode);
    }
    function setChildNodesParentNode(childNodes) {
      if (childNodes === void 0) {
        childNodes = [
          ...this.childNodes
        ];
      }
      const parentNode = this;
      childNodes.forEach((childNode) => {
        childNode.setParentNode(parentNode);
      });
    }
    function resetChildNodesParentNode(childNodes) {
      if (childNodes === void 0) {
        childNodes = [
          ...this.childNodes
        ];
      }
      const parentNode = null;
      childNodes.forEach((childNode) => {
        childNode.setParentNode(parentNode);
      });
    }
    function addChildNode(addedChildNode, startIndex) {
      const addedChildNodes = [
        addedChildNode
      ];
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function addChildNodes(addedChildNodes, startIndex) {
      const deleteCount = 0;
      this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
    }
    function removeChildNode(removedChildNode) {
      let removedChildNodes;
      removedChildNodes = [
        removedChildNode
      ];
      removedChildNodes = this.removeChildNodes(removedChildNodes);
      return removedChildNodes;
    }
    function removeChildNodes(removedChildNodes) {
      if (removedChildNodes === void 0) {
        removedChildNodes = [
          ...this.childNodes
        ];
      }
      const removedChildNodesLength = removedChildNodes.length;
      if (removedChildNodesLength > 0) {
        const firstReplacedChildNode = first2(removedChildNodes), startIndex = this.childNodes.indexOf(firstReplacedChildNode), deleteCount = removedChildNodesLength, addedChildNodes = [];
        removedChildNodes = this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
      }
      return removedChildNodes;
    }
    function replaceChildNode(replacedChildNode, replacementChildNodes) {
      const replacedChildNodes = [
        replacedChildNode
      ];
      this.replaceChildNodes(replacedChildNodes, replacementChildNodes);
    }
    function replaceChildNodes(replacedChildNodes, replacementChildNodes) {
      const replacedChildNodesLength = replacedChildNodes.length, firstReplacedChildNode = first2(replacedChildNodes), startIndex = this.childNodes.indexOf(firstReplacedChildNode), deleteCount = replacedChildNodesLength;
      this.spliceChildNodes(startIndex, deleteCount, replacementChildNodes);
    }
    function appendChildNode(appendedChildNode) {
      const appendedChildNodes = [
        appendedChildNode
      ];
      this.appendChildNodes(appendedChildNodes);
    }
    function appendChildNodes(appendedChildNodes) {
      const addedChildNodes = appendedChildNodes, multiplicity = this.getMultiplicity(), startIndex = multiplicity;
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function prependChildNode(prependedChildNode) {
      const prependedChildNodes = [
        prependedChildNode
      ];
      this.prependChildNodes(prependedChildNodes);
    }
    function prependChildNodes(prependedChildNodes) {
      const addedChildNodes = prependedChildNodes, startIndex = 0;
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function spliceChildNodes(startIndex, deleteCount, addedChildNodes = []) {
      const removedChildNodes = this.childNodes.splice(startIndex, deleteCount, ...addedChildNodes);
      this.resetChildNodesParentNode(removedChildNodes);
      this.setChildNodesParentNode(addedChildNodes);
      return removedChildNodes;
    }
    function sliceChildNodes(startIndex, endIndex = Infinity) {
      const childNodes = this.childNodes.slice(startIndex, endIndex);
      return childNodes;
    }
    function getAncestorNodes() {
      const ancestorNodes = [];
      let ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        ancestorNodes.push(ancestorNode);
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
      }
      return ancestorNodes;
    }
    function mapAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.map(callback);
    }
    function someAncestorNode(callback) {
      let result = false;
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        result = !!callback(ancestorNode, index);
        if (result) {
          break;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      return result;
    }
    function findAncestorNode(callback) {
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        const result = callback(ancestorNode, index);
        if (result) {
          return ancestorNode;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      ancestorNode = void 0;
      return ancestorNode;
    }
    function everyAncestorNode(callback) {
      let result = true;
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        result = !!callback(ancestorNode, index);
        if (!result) {
          break;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      return result;
    }
    function filterAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.filter(callback);
    }
    function reduceAncestorNode(callback, initialValue) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.reduce(callback, initialValue);
    }
    function forEachAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      ancestorNodes.forEach(callback);
    }
    function getDescendantNodes(descendantNodes = []) {
      push(descendantNodes, this.childNodes);
      this.forEachChildNode((childNode) => {
        childNode.getDescendantNodes(descendantNodes);
      });
      return descendantNodes;
    }
    function mapDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.map(callback);
    }
    function someDescendantNode(callback) {
      let result = false;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        const childNode = this.childNodes[index], descendantNode = childNode;
        result = !!callback(descendantNode);
        if (result) {
          break;
        }
        result = childNode.someDescendantNode(callback);
        if (result) {
          break;
        }
      }
      return result;
    }
    function findDescendantNode(callback) {
      let descendantNode = void 0;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        let result;
        const childNode = this.childNodes[index];
        descendantNode = childNode;
        result = callback(descendantNode);
        if (result) {
          break;
        }
        descendantNode = childNode.findDescendantNode(callback);
        if (descendantNode !== void 0) {
          break;
        }
      }
      return descendantNode;
    }
    function everyDescendantNode(callback) {
      let result = true;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        const childNode = this.childNodes[index], descendantNode = childNode;
        result = !!callback(descendantNode);
        if (!result) {
          break;
        }
        result = childNode.everyDescendantNode(callback);
        if (!result) {
          break;
        }
      }
      return result;
    }
    function filterDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.filter(callback);
    }
    function reduceDescendantNode(callback, initialValue) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.reduce(callback, initialValue);
    }
    function forEachDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      descendantNodes.forEach(callback);
    }
    var nodeMixins = {
      getMultiplicity,
      mapChildNode,
      someChildNode,
      findChildNode,
      everyChildNode,
      filterChildNode,
      reduceChildNode,
      forEachChildNode,
      forwardsSomeChildNode,
      backwardsSomeChildNode,
      indexOfChildNode,
      setChildNodesParentNode,
      resetChildNodesParentNode,
      addChildNode,
      addChildNodes,
      removeChildNode,
      removeChildNodes,
      replaceChildNode,
      replaceChildNodes,
      appendChildNode,
      appendChildNodes,
      prependChildNode,
      prependChildNodes,
      spliceChildNodes,
      sliceChildNodes,
      getAncestorNodes,
      mapAncestorNode,
      someAncestorNode,
      findAncestorNode,
      everyAncestorNode,
      filterAncestorNode,
      reduceAncestorNode,
      forEachAncestorNode,
      getDescendantNodes,
      mapDescendantNode,
      someDescendantNode,
      findDescendantNode,
      everyDescendantNode,
      filterDescendantNode,
      reduceDescendantNode,
      forEachDescendantNode
    };
    var _default = nodeMixins;
  });

  // node_modules/occam-parsers/lib/parseTree.js
  var require_parseTree = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParseTree;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {last} = _necessary.arrayUtilities;
    var {NEW_LINE_CHARACTER, SPACE_CHARACTER} = _necessary.characters;
    var ParseTree = class {
      constructor(lines) {
        this.lines = lines;
      }
      clone() {
        const lines = this.lines.slice(), parseTree = new ParseTree(lines);
        return parseTree;
      }
      getWidth() {
        let width;
        let linesLength = this.lines.length;
        if (linesLength === 0) {
          width = 0;
        } else {
          const lastLine = last(this.lines), lastLineLength = lastLine.length;
          width = lastLineLength;
        }
        return width;
      }
      getDepth() {
        const linesLength = this.lines.length, depth = linesLength;
        return depth;
      }
      forEachLine(callback) {
        this.lines.forEach(callback);
      }
      appendToTop(parseTree) {
        parseTree.forEachLine((line) => {
          this.lines.unshift(line);
        });
      }
      appendToLeft(parseTree) {
        parseTree.forEachLine((line, index) => {
          this.lines[index] = line + this.lines[index];
        });
      }
      appendToRight(parseTree) {
        parseTree.forEachLine((line, index) => {
          this.lines[index] = this.lines[index] + line;
        });
      }
      appendToBottom(parseTree) {
        parseTree.forEachLine((line) => {
          this.lines.push(line);
        });
      }
      addTopMargin(topMarginDepth) {
        const width = this.getWidth(), topMarginWidth = width, topMarginString = marginStringFromMarginWidth(topMarginWidth);
        for (let index = 0; index < topMarginDepth; index++) {
          this.lines.unshift(topMarginString);
        }
      }
      addLeftMargin(leftMarginWidth) {
        const leftMarginString = marginStringFromMarginWidth(leftMarginWidth), linesLength = this.lines.length;
        for (let index = 0; index < linesLength; index++) {
          this.lines[index] = leftMarginString + this.lines[index];
        }
      }
      addRightMargin(rightMarginWidth) {
        const rightMarginString = marginStringFromMarginWidth(rightMarginWidth), linesLength = this.lines.length;
        for (let index = 0; index < linesLength; index++) {
          this.lines[index] = this.lines[index] + rightMarginString;
        }
      }
      addBottomMargin(bottomMarginDepth) {
        const width = this.getWidth(), bottomMarginWidth = width, bottomMarginString = marginStringFromMarginWidth(bottomMarginWidth);
        for (let index = 0; index < bottomMarginDepth; index++) {
          this.lines.push(bottomMarginString);
        }
      }
      popLine() {
        return this.lines.pop();
      }
      shiftLine() {
        return this.lines.shift();
      }
      pushLine(line) {
        this.lines.push(line);
      }
      unshiftLine(line) {
        this.lines.unshift(line);
      }
      asString() {
        const string = this.lines.reduce((string2, line) => {
          string2 += line + NEW_LINE_CHARACTER;
          return string2;
        }, _constants.EMPTY_STRING);
        return string;
      }
    };
    function marginStringFromMarginWidth(marginWidth, spaceCharacter) {
      spaceCharacter = spaceCharacter || SPACE_CHARACTER;
      let marginString = _constants.EMPTY_STRING;
      for (let index = 0; index < marginWidth; index++) {
        marginString += spaceCharacter;
      }
      return marginString;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/verticalBranch.js
  var require_verticalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VerticalBranchParseTree;
      }
    });
    var _necessary = require_browser();
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {BAR_CHARACTER} = _necessary.characters;
    var VerticalBranchParseTree = class extends _parseTree.default {
      constructor(lines, verticalBranchPosition) {
        super(lines);
        this.verticalBranchPosition = verticalBranchPosition;
      }
      getVerticalBranchPosition() {
        return this.verticalBranchPosition;
      }
      addLeftMargin(leftMarginWidth) {
        super.addLeftMargin(leftMarginWidth);
        this.verticalBranchPosition += leftMarginWidth;
      }
      static fromWidth(width) {
        const string = BAR_CHARACTER, verticalBranchPosition = 0, verticalBranchParseTree = VerticalBranchParseTree.fromStringAndVerticalBranchPosition(VerticalBranchParseTree, string, verticalBranchPosition), leftMarginWidth = Math.floor(width / 2), rightMarginWidth = width - leftMarginWidth - 1;
        verticalBranchParseTree.addLeftMargin(leftMarginWidth);
        verticalBranchParseTree.addRightMargin(rightMarginWidth);
        return verticalBranchParseTree;
      }
      static fromDepthAndVerticalBranchPosition(Class, depth, verticalBranchPosition) {
        const lines = linesFromDepth(depth), verticalBranchParseTree = new Class(lines, verticalBranchPosition);
        return verticalBranchParseTree;
      }
      static fromStringAndVerticalBranchPosition(Class, string, verticalBranchPosition) {
        if (verticalBranchPosition === void 0) {
          verticalBranchPosition = string;
          string = Class;
          Class = _parseTree.default;
        }
        const line = string, lines = [
          line
        ], verticalBranchParseTree = new Class(lines, verticalBranchPosition);
        return verticalBranchParseTree;
      }
    };
    function linesFromDepth(depth) {
      const lines = [];
      let index = 0;
      while (index < depth) {
        lines[index++] = _constants.EMPTY_STRING;
      }
      return lines;
    }
  });

  // node_modules/occam-parsers/lib/utilities/tokens.js
  var require_tokens = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lineIndexFromTokenIndexAndTokens", {
      enumerable: true,
      get: function() {
        return lineIndexFromTokenIndexAndTokens;
      }
    });
    function lineIndexFromTokenIndexAndTokens(tokenIndex, tokens) {
      let lineIndex = null;
      if (tokenIndex !== null) {
        lineIndex = 0;
        const start = 0, end = tokenIndex;
        tokens = tokens.slice(start, end);
        tokens.forEach((token) => {
          const tokenEndOfLineToken = token.isEndOfLineToken();
          if (tokenEndOfLineToken) {
            lineIndex++;
          }
        });
      }
      return lineIndex;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/ruleName.js
  var require_ruleName = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _constants = require_constants4();
    var _tokens = require_tokens();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {SPACE_CHARACTER} = _necessary.characters;
    var RuleNameParseTree = class extends _verticalBranch.default {
      static fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
        const ruleName = nonTerminalNode.getRuleName(), opacity = nonTerminalNode.getOpacity(), firstSignificantTokenIndex = nonTerminalNode.getFirstSignificantTokenIndex(tokens), lastSignificantTokenIndex = nonTerminalNode.getLastSignificantTokenIndex(tokens), firstLineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(firstSignificantTokenIndex, tokens), lastLineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(lastSignificantTokenIndex, tokens);
        let lineIndexes;
        if (firstLineIndex === lastLineIndex) {
          const lineIndex = firstLineIndex;
          if (lineIndex === null) {
            lineIndexes = _constants.EMPTY_STRING;
          } else {
            lineIndexes = ` [${lineIndex}]`;
          }
        } else {
          if (false) {
          } else if (firstLineIndex === null) {
            lineIndexes = ` [${lastLineIndex}]`;
          } else if (lastLineIndex === null) {
            lineIndexes = ` [${firstLineIndex}]`;
          } else {
            lineIndexes = ` [${firstLineIndex}-${lastLineIndex}]`;
          }
        }
        let string = `${ruleName}`;
        if (opacity !== null) {
          string = `${string}${opacity}`;
        }
        string = `${string}${lineIndexes}`;
        let precedence = nonTerminalNode.getPrecedence();
        if (precedence !== null) {
          if (precedence === Infinity) {
            precedence = SPACE_CHARACTER;
          }
          string = `${string} (${precedence})`;
        }
        const stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), ruleNameParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(RuleNameParseTree, string, verticalBranchPosition);
        ruleNameParseTree.appendToTop(verticalBranchParseTree);
        return ruleNameParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/horizontalBranch.js
  var require_horizontalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return HorizontalBranchParseTree;
      }
    });
    var _necessary = require_browser();
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {DASH_CHARACTER} = _necessary.characters;
    var HorizontalBranchParseTree = class extends _parseTree.default {
      static fromWidth(width) {
        const string = stringFromCharactersWidth(width, DASH_CHARACTER), line = string, lines = [
          line
        ], horizontalBranchParseTree = new HorizontalBranchParseTree(lines);
        return horizontalBranchParseTree;
      }
    };
    function stringFromCharactersWidth(charactersWidth, character) {
      let string = _constants.EMPTY_STRING;
      for (let index = 0; index < charactersWidth; index++) {
        string += character;
      }
      return string;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/childNodes.js
  var require_childNodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChildNodesParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _horizontalBranch = /* @__PURE__ */ _interop_require_default(require_horizontalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var ChildNodesParseTree = class extends _verticalBranch.default {
      static fromChildNodesAndTokens(childNodes, tokens) {
        let childNodesParseTree = null;
        const childNodesLength = childNodes.length;
        if (childNodesLength > 0) {
          const childNodeParseTrees = childNodes.reduce((childNodeParseTrees2, childNode) => {
            const childNodeParseTree = childNode.asParseTree(tokens);
            childNodeParseTrees2.push(childNodeParseTree);
            return childNodeParseTrees2;
          }, []), childNodeParseTreesLength = childNodeParseTrees.length;
          if (childNodeParseTreesLength === 1) {
            const firstChildNodeParseTree = first2(childNodeParseTrees);
            childNodesParseTree = firstChildNodeParseTree;
          } else {
            let firstVerticalBranchPosition, lastVerticalBranchPosition = 0, childNodeParseTreesWidth = 0, childNodeParseTreesDepth = 0;
            childNodeParseTrees.forEach((childNodeParseTree, index) => {
              const childNodeParseTreeWidth = childNodeParseTree.getWidth(), childNodeParseTreeDepth = childNodeParseTree.getDepth();
              if (index === 0) {
                const firstChildNodeParseTree = childNodeParseTree, firstChildNodeParseTreeVerticalBranchPosition = firstChildNodeParseTree.getVerticalBranchPosition();
                firstVerticalBranchPosition = firstChildNodeParseTreeVerticalBranchPosition;
              }
              if (index === childNodeParseTreesLength - 1) {
                const lastChildNodeParseTree = childNodeParseTree, lastChildNodeParseTreeVerticalBranchPosition = lastChildNodeParseTree.getVerticalBranchPosition();
                lastVerticalBranchPosition += lastChildNodeParseTreeVerticalBranchPosition;
              }
              if (index < childNodeParseTreesLength - 1) {
                lastVerticalBranchPosition += childNodeParseTreeWidth;
                lastVerticalBranchPosition += 1;
                childNodeParseTreesWidth += 1;
              }
              childNodeParseTreesWidth += childNodeParseTreeWidth;
              childNodeParseTreesDepth = Math.max(childNodeParseTreesDepth, childNodeParseTreeDepth);
            });
            const width = lastVerticalBranchPosition - firstVerticalBranchPosition + 1, verticalBranchParseTree = _verticalBranch.default.fromWidth(width), horizontalBranchParseTree = _horizontalBranch.default.fromWidth(width), leftMarginWidth = firstVerticalBranchPosition, rightMarginWidth = childNodeParseTreesWidth - width - leftMarginWidth;
            verticalBranchParseTree.addLeftMargin(leftMarginWidth);
            verticalBranchParseTree.addRightMargin(rightMarginWidth);
            horizontalBranchParseTree.addLeftMargin(leftMarginWidth);
            horizontalBranchParseTree.addRightMargin(rightMarginWidth);
            const verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), depth = childNodeParseTreesDepth;
            childNodesParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(ChildNodesParseTree, depth, verticalBranchPosition);
            childNodeParseTrees.forEach((childNodeParseTree, index) => {
              const childNodeParseTreeDepth = childNodeParseTree.getDepth(), clonedChildNodeParseTree = childNodeParseTree.clone();
              if (index < childNodeParseTreesLength - 1) {
                const rightMarginWidth2 = 1;
                clonedChildNodeParseTree.addRightMargin(rightMarginWidth2);
              }
              if (childNodeParseTreeDepth < childNodeParseTreesDepth) {
                const bottomMarginDepth = childNodeParseTreesDepth - childNodeParseTreeDepth;
                clonedChildNodeParseTree.addBottomMargin(bottomMarginDepth);
              }
              childNodesParseTree.appendToRight(clonedChildNodeParseTree);
            });
            childNodesParseTree.appendToTop(horizontalBranchParseTree);
            childNodesParseTree.appendToTop(verticalBranchParseTree);
          }
        }
        return childNodesParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/nonTerminalNode.js
  var require_nonTerminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNodeParseTree;
      }
    });
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName());
    var _childNodes = /* @__PURE__ */ _interop_require_default(require_childNodes());
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeParseTree = class extends _verticalBranch.default {
      static fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
        let nonTerminalNodeParseTree;
        const childNodes = nonTerminalNode.getChildNodes(), ruleNameParseTree = _ruleName.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), childNodesParseTree = _childNodes.default.fromChildNodesAndTokens(childNodes, tokens);
        if (childNodesParseTree === null) {
          const ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition(), verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, depth = ruleNameParseTreeDepth;
          nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree, depth, verticalBranchPosition);
          nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
        } else {
          let ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
          const childNodesParseTreeVerticalBranchPosition = childNodesParseTree.getVerticalBranchPosition(), verticalBranchPositionsDifference = ruleNameParseTreeVerticalBranchPosition - childNodesParseTreeVerticalBranchPosition;
          let leftMarginWidth;
          if (false) {
          } else if (verticalBranchPositionsDifference < 0) {
            leftMarginWidth = -verticalBranchPositionsDifference;
            ruleNameParseTree.addLeftMargin(leftMarginWidth);
          } else if (verticalBranchPositionsDifference > 0) {
            leftMarginWidth = +verticalBranchPositionsDifference;
            childNodesParseTree.addLeftMargin(leftMarginWidth);
          }
          const ruleNameParseTreeWidth = ruleNameParseTree.getWidth(), childNodesParseTreeWidth = childNodesParseTree.getWidth(), widthsDifference = ruleNameParseTreeWidth - childNodesParseTreeWidth;
          let rightMarginWidth;
          if (false) {
          } else if (widthsDifference < 0) {
            rightMarginWidth = -widthsDifference;
            ruleNameParseTree.addRightMargin(rightMarginWidth);
          } else if (widthsDifference > 0) {
            rightMarginWidth = +widthsDifference;
            childNodesParseTree.addRightMargin(rightMarginWidth);
          }
          ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
          const ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, depth = ruleNameParseTreeDepth;
          nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree, depth, verticalBranchPosition);
          nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
          nonTerminalNodeParseTree.appendToBottom(childNodesParseTree);
        }
        return nonTerminalNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/nonTerminal.js
  var require_nonTerminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNode;
      }
    });
    var _necessary = require_browser();
    var _occamlexers = require_lib3();
    var _node = /* @__PURE__ */ _interop_require_default(require_node());
    var _nonTerminalNode = /* @__PURE__ */ _interop_require_default(require_nonTerminalNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, match} = _necessary.arrayUtilities;
    var {opaque: opaqueSpecialSymbol, semiOpaque: semiOpaqueSpecialSymbol} = _occamlexers.specialSymbols;
    var NonTerminalNode = class {
      constructor(ruleName, parentNode, childNodes, opacity, precedence) {
        this.ruleName = ruleName;
        this.parentNode = parentNode;
        this.childNodes = childNodes;
        this.opacity = opacity;
        this.precedence = precedence;
      }
      getRuleName() {
        return this.ruleName;
      }
      getParentNode() {
        return this.parentNode;
      }
      getChildNodes() {
        return this.childNodes;
      }
      getOpacity() {
        return this.opacity;
      }
      getPrecedence() {
        return this.precedence;
      }
      setRuleName(ruleName) {
        this.ruleName = ruleName;
      }
      setParentNode(parentNode) {
        this.parentNode = parentNode;
      }
      setChildNodes(childNodes) {
        const startIndex = 0, deleteCount = Infinity, addedChildNodes = childNodes;
        this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      setPrecedence(precedence) {
        this.precedence = precedence;
      }
      isOpaque() {
        const opaque = this.opacity === opaqueSpecialSymbol;
        return opaque;
      }
      isSemiOpaque() {
        const semiOpaque = this.opacity === semiOpaqueSpecialSymbol;
        return semiOpaque;
      }
      isTransparent() {
        const semiOpaque = this.opacity === null;
        return semiOpaque;
      }
      isTerminalNode() {
        const terminalNode = false;
        return terminalNode;
      }
      isNonTerminalNode() {
        const nonTerminalNode = true;
        return nonTerminalNode;
      }
      getDescendantNodes(descendantNodes) {
        return descendantNodes;
      }
      getFirstSignificantTokenIndex(tokens) {
        let firstSignificantTokenIndex;
        this.forwardsSomeChildNode((childNode) => {
          const node = childNode;
          firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens);
          if (firstSignificantTokenIndex !== null) {
            return true;
          }
        });
        return firstSignificantTokenIndex;
      }
      getLastSignificantTokenIndex(tokens) {
        let lastSignificantTokenIndex;
        this.backwardsSomeChildNode((childNode) => {
          const node = childNode;
          lastSignificantTokenIndex = node.getLastSignificantTokenIndex(tokens);
          if (lastSignificantTokenIndex !== null) {
            return true;
          }
        });
        return lastSignificantTokenIndex;
      }
      getSignificantTokens(significantTokens = []) {
        this.childNodes.forEach((childNode) => {
          childNode.getSignificantTokens(significantTokens);
        });
        return significantTokens;
      }
      getMultiplicity() {
        const childNodesLength = this.childNodes.length, multiplicity = childNodesLength;
        return multiplicity;
      }
      isEmpty() {
        const multiplicity = this.getMultiplicity(), empty = multiplicity === 0;
        return empty;
      }
      isSingular() {
        const multiplicity = this.getMultiplicity(), singular = multiplicity === 1;
        return singular;
      }
      isLowerPrecedence(ruleName, precedence) {
        let lowerPrecedence;
        if (false) {
        } else if (this.precedence === null) {
          lowerPrecedence = false;
        } else if (this.precedence === Infinity) {
          const firstChildNode = first2(this.childNodes);
          lowerPrecedence = firstChildNode.isLowerPrecedence(ruleName, precedence);
        } else {
          lowerPrecedence = this.ruleName === ruleName && this.precedence < precedence;
        }
        return lowerPrecedence;
      }
      isUnprecedented() {
        let unprecedented = false;
        if (this.precedence !== null) {
          unprecedented = this.childNodes.some((childNode) => {
            const childNodeLowerPrecedence = childNode.isLowerPrecedence(this.ruleName, this.precedence);
            if (childNodeLowerPrecedence) {
              return true;
            }
          });
        }
        return unprecedented;
      }
      asParseTree(tokens) {
        const nonTerminalNode = this, nonTerminalNodeParseTree = _nonTerminalNode.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), parseTree = nonTerminalNodeParseTree;
        return parseTree;
      }
      match(node, depth = Infinity, exactly = false) {
        let matches = false;
        const nodeNonTerminalNode = node.isNonTerminalNode();
        if (nodeNonTerminalNode) {
          const nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
          if (this.ruleName === nonTerminalNodeRuleName) {
            const nonTerminalNodeOpacity = nonTerminalNode.getOpacity();
            if (this.opacity === nonTerminalNodeOpacity) {
              const precedence = this.getPrecedence(), nonTerminalNodePrecedence = nonTerminalNode.getPrecedence();
              if (precedence === nonTerminalNodePrecedence) {
                depth--;
                if (depth === 0) {
                  matches = true;
                } else {
                  const nonTerminalNodeChildNodes = nonTerminalNode.getChildNodes();
                  matches = match(this.childNodes, nonTerminalNodeChildNodes, (childNode, nonTerminalNodeChildNode) => {
                    const childNodeMatchesNonTerminalNodeChildNode = childNode.match(nonTerminalNodeChildNode, depth, exactly);
                    if (childNodeMatchesNonTerminalNodeChildNode) {
                      return true;
                    }
                  });
                }
              }
            }
          }
        }
        return matches;
      }
      rewrite(state) {
        const rewrittenNonTerminalNode = null;
        return rewrittenNonTerminalNode;
      }
      destroy() {
        this.forEachChildNode((childNode) => {
          childNode.destroy();
        });
        this.parentNode = null;
        this.childNodes = null;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, parentNode = null, ruleName = this.ruleName, childNodes = cloneChildNodes(this.childNodes), opacity = this.opacity, precedence = this.precedence, nonTerminalNode = new Class(ruleName, parentNode, childNodes, opacity, precedence, ...remainingArguments);
        nonTerminalNode.setChildNodesParentNode();
        return nonTerminalNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence, ...remainingArguments) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = NonTerminalNode;
        }
        const parentNode = null, nonTerminalNode = new Class(ruleName, parentNode, childNodes, opacity, precedence, ...remainingArguments);
        nonTerminalNode.setChildNodesParentNode();
        return nonTerminalNode;
      }
    };
    Object.assign(NonTerminalNode.prototype, _node.default);
    function cloneChildNodes(childNodes) {
      childNodes = childNodes.map((childNode) => {
        childNode = childNode.clone();
        return childNode;
      });
      return childNodes;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal.js
  var require_nonTerminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPart;
      }
    });
    var NonTerminalPart = class {
      constructor(type, callAhead) {
        this.type = type;
        this.callAhead = callAhead;
      }
      getType() {
        return this.type;
      }
      isCallAhead() {
        return this.callAhead;
      }
      isNonTerminalPart() {
        const nonTerminalPart = true;
        return nonTerminalPart;
      }
      isTerminalPart() {
        const terminalPart = false;
        return terminalPart;
      }
      isRuleNamePart() {
        const ruleNamePart = false;
        return ruleNamePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/partTypes.js
  var require_partTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ChoiceOfPartsPartType() {
        return ChoiceOfPartsPartType;
      },
      get OneOrMorePartsPartType() {
        return OneOrMorePartsPartType;
      },
      get OptionalPartPartType() {
        return OptionalPartPartType;
      },
      get RuleNamePartType() {
        return RuleNamePartType;
      },
      get SequenceOfPartsPartType() {
        return SequenceOfPartsPartType;
      },
      get ZeroOrMorePartsPartType() {
        return ZeroOrMorePartsPartType;
      },
      get default() {
        return _default;
      }
    });
    var RuleNamePartType = "ruleNamePart";
    var OptionalPartPartType = "optionalPart";
    var ChoiceOfPartsPartType = "choiceOfParts";
    var OneOrMorePartsPartType = "oneOrMoreParts";
    var ZeroOrMorePartsPartType = "zeroOrMoreParts";
    var SequenceOfPartsPartType = "sequenceOfParts";
    var _default = {
      RuleNamePartType,
      OptionalPartPartType,
      ChoiceOfPartsPartType,
      OneOrMorePartsPartType,
      ZeroOrMorePartsPartType,
      SequenceOfPartsPartType
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/optionalPart.js
  var require_optionalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return OptionalPartPart;
      },
      get parseOptionalPart() {
        return parseOptionalPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {questionMark} = _occamlexers.specialSymbols;
    var OptionalPartPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseOptionalPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${questionMark}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.OptionalPartPartType, callAhead = false, optionalPartPart = new OptionalPartPart(type, callAhead, part);
        return optionalPartPart;
      }
    };
    function parseOptionalPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        parsed = true;
      } else {
        parsed = callAhead();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback, callAhead);
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/zeroOrMoreParts.js
  var require_zeroOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return ZeroOrMorePartsPart;
      },
      get parseZeroOrMorePartsPart() {
        return parseZeroOrMorePartsPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asterisk} = _occamlexers.specialSymbols;
    var ZeroOrMorePartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseZeroOrMorePartsPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${asterisk}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.ZeroOrMorePartsPartType, callAhead = false, zeroOrMorePartsPart = new ZeroOrMorePartsPart(type, callAhead, part);
        return zeroOrMorePartsPart;
      }
    };
    function parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        if (parsed) {
          parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead);
        }
        parsed = true;
      } else {
        parsed = callAhead();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback, () => {
            let parsed2;
            parsed2 = parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead);
            return parsed2;
          });
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/oneOrMoreParts.js
  var require_oneOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return OneOrMorePartsPart;
      },
      get parseOneOrMorePartsPart() {
        return parseOneOrMorePartsPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    var _zeroOrMoreParts = require_zeroOrMoreParts();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {plus} = _occamlexers.specialSymbols;
    var OneOrMorePartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseOneOrMorePartsPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${plus}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.OneOrMorePartsPartType, callAhead = false, oneOrMorePartsPart = new OneOrMorePartsPart(type, callAhead, part);
        return oneOrMorePartsPart;
      }
    };
    function parseOneOrMorePartsPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        if (parsed) {
          (0, _zeroOrMoreParts.parseZeroOrMorePartsPart)(part, nodes, state, callback, callAhead);
        }
      } else {
        parsed = part.parse(nodes, state, callback, () => {
          let parsed2;
          parsed2 = (0, _zeroOrMoreParts.parseZeroOrMorePartsPart)(part, nodes, state, callback, callAhead);
          return parsed2;
        });
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/ruleNames.js
  var require_ruleNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CALL_AHEAD_MODIFIER_RULE_NAME() {
        return CALL_AHEAD_MODIFIER_RULE_NAME;
      },
      get CHOICE_OF_PARTS_RULE_NAME() {
        return CHOICE_OF_PARTS_RULE_NAME;
      },
      get DEFINITIONS_RULE_NAME() {
        return DEFINITIONS_RULE_NAME;
      },
      get DEFINITION_RULE_NAME() {
        return DEFINITION_RULE_NAME;
      },
      get DOCUMENT_RULE_NAME() {
        return DOCUMENT_RULE_NAME;
      },
      get END_OF_LINE_RULE_NAME() {
        return END_OF_LINE_RULE_NAME;
      },
      get EPSILON_RULE_NAME() {
        return EPSILON_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get NAME_RULE_NAME() {
        return NAME_RULE_NAME;
      },
      get NON_TERMINAL_PART_RULE_NAME() {
        return NON_TERMINAL_PART_RULE_NAME;
      },
      get NO_WHITESPACE_PART_RULE_NAME() {
        return NO_WHITESPACE_PART_RULE_NAME;
      },
      get ONE_OR_MORE_QUANTIFIER_RULE_NAME() {
        return ONE_OR_MORE_QUANTIFIER_RULE_NAME;
      },
      get OPACITY_MODIFIER_RULE_NAME() {
        return OPACITY_MODIFIER_RULE_NAME;
      },
      get OPTIONAL_QUANTIFIER_RULE_NAME() {
        return OPTIONAL_QUANTIFIER_RULE_NAME;
      },
      get PART_CHOICE_RULE_NAME() {
        return PART_CHOICE_RULE_NAME;
      },
      get PART_RULE_NAME() {
        return PART_RULE_NAME;
      },
      get PRECEDENCE_RULE_NAME() {
        return PRECEDENCE_RULE_NAME;
      },
      get QUANTIFIER_RULE_NAME() {
        return QUANTIFIER_RULE_NAME;
      },
      get REGULAR_EXPRESSION_RULE_NAME() {
        return REGULAR_EXPRESSION_RULE_NAME;
      },
      get RULE_NAME_RULE_NAME() {
        return RULE_NAME_RULE_NAME;
      },
      get RULE_RULE_NAME() {
        return RULE_RULE_NAME;
      },
      get SEQUENCE_OF_PARTS_RULE_NAME() {
        return SEQUENCE_OF_PARTS_RULE_NAME;
      },
      get SIGNIFICANT_TOKEN_TYPE_RULE_NAME() {
        return SIGNIFICANT_TOKEN_TYPE_RULE_NAME;
      },
      get START_OF_CONTENT_PART_RULE_NAME() {
        return START_OF_CONTENT_PART_RULE_NAME;
      },
      get STRING_LITERAL_RULE_NAME() {
        return STRING_LITERAL_RULE_NAME;
      },
      get TERMINAL_PART_RULE_NAME() {
        return TERMINAL_PART_RULE_NAME;
      },
      get WILDCARD_RULE_NAME() {
        return WILDCARD_RULE_NAME;
      },
      get ZERO_OR_MORE_QUANTIFIER_RULE_NAME() {
        return ZERO_OR_MORE_QUANTIFIER_RULE_NAME;
      }
    });
    var NAME_RULE_NAME = "name";
    var PART_RULE_NAME = "part";
    var RULE_RULE_NAME = "rule";
    var ERROR_RULE_NAME = "error";
    var EPSILON_RULE_NAME = "epsilon";
    var DOCUMENT_RULE_NAME = "document";
    var WILDCARD_RULE_NAME = "wildcard";
    var RULE_NAME_RULE_NAME = "ruleName";
    var DEFINITION_RULE_NAME = "definition";
    var PRECEDENCE_RULE_NAME = "precedence";
    var QUANTIFIER_RULE_NAME = "quantifier";
    var END_OF_LINE_RULE_NAME = "endOfLine";
    var PART_CHOICE_RULE_NAME = "partChoice";
    var DEFINITIONS_RULE_NAME = "definitions";
    var TERMINAL_PART_RULE_NAME = "terminalPart";
    var STRING_LITERAL_RULE_NAME = "stringLiteral";
    var CHOICE_OF_PARTS_RULE_NAME = "choiceOfParts";
    var OPACITY_MODIFIER_RULE_NAME = "opacityModifier";
    var NON_TERMINAL_PART_RULE_NAME = "nonTerminalPart";
    var SEQUENCE_OF_PARTS_RULE_NAME = "sequenceOfParts";
    var NO_WHITESPACE_PART_RULE_NAME = "noWhitespace";
    var REGULAR_EXPRESSION_RULE_NAME = "regularExpression";
    var CALL_AHEAD_MODIFIER_RULE_NAME = "callAheadModifier";
    var OPTIONAL_QUANTIFIER_RULE_NAME = "optionalQuantifier";
    var START_OF_CONTENT_PART_RULE_NAME = "startOfContent";
    var SIGNIFICANT_TOKEN_TYPE_RULE_NAME = "significantTokenType";
    var ONE_OR_MORE_QUANTIFIER_RULE_NAME = "oneOrMoreQuantifier";
    var ZERO_OR_MORE_QUANTIFIER_RULE_NAME = "zeroOrMoreQuantifier";
  });

  // node_modules/occam-parsers/lib/utilities/bnf.js
  var require_bnf2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isNodeCallAheadModifierNode() {
        return isNodeCallAheadModifierNode;
      },
      get isNodeChoiceNode() {
        return isNodeChoiceNode;
      },
      get isNodeQuantifierNode() {
        return isNodeQuantifierNode;
      },
      get isNodeRuleNameNode() {
        return isNodeRuleNameNode;
      },
      get ruleNameFromQuantifierNode() {
        return ruleNameFromQuantifierNode;
      }
    });
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames();
    var {first: first2} = _necessary.arrayUtilities;
    function isNodeChoiceNode(node) {
      let nodeNoChoiceNode = false;
      const nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        const terminalNode = node, terminalNodeContent = terminalNode.getContent();
        nodeNoChoiceNode = terminalNodeContent === "|";
      }
      return nodeNoChoiceNode;
    }
    function isNodeRuleNameNode(node) {
      let nodeRuleNameNode = false;
      const nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
        nodeRuleNameNode = nonTerminalNodeRuleName === _ruleNames.RULE_NAME_RULE_NAME;
      }
      return nodeRuleNameNode;
    }
    function isNodeQuantifierNode(node) {
      let nodeQuantifierNode = false;
      const nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameQuantifierRuleName = ruleName === _ruleNames.QUANTIFIER_RULE_NAME;
        nodeQuantifierNode = ruleNameQuantifierRuleName;
      }
      return nodeQuantifierNode;
    }
    function isNodeCallAheadModifierNode(node) {
      let nodeCallAheadModifierNode = false;
      const nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameCallAheadModifierRuleName = ruleName === _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME;
        nodeCallAheadModifierNode = ruleNameCallAheadModifierRuleName;
      }
      return nodeCallAheadModifierNode;
    }
    function ruleNameFromQuantifierNode(quantifierNode) {
      let nonTerminalNode;
      nonTerminalNode = quantifierNode;
      const childNodes = nonTerminalNode.getChildNodes(), firstChildNode = first2(childNodes);
      nonTerminalNode = firstChildNode;
      const ruleName = nonTerminalNode.getRuleName();
      return ruleName;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/part.js
  var require_part = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _bnf = require_bnf2();
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {last} = _necessary.arrayUtilities;
    var PartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = partFromNodes(nodes);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    function partFromNodes(nodes) {
      let part;
      const nodesLength = nodes.length;
      if (nodesLength === 1) {
        const node = nodes.pop(), callAhead = false;
        part = node.generatePart(callAhead);
      } else {
        const lastNodeQuantifierNode = isLastNodeQuantifierNode(nodes);
        if (lastNodeQuantifierNode) {
          const node = nodes.pop(), quantifierNode = node;
          part = partFromNodes(nodes);
          const ruleName = (0, _bnf.ruleNameFromQuantifierNode)(quantifierNode), collectionOfPartsPart = collectionOfPartsPartFromPartAndRuleName(part, ruleName);
          part = collectionOfPartsPart;
        } else {
          nodes.shift();
          part = partFromNodes(nodes);
        }
      }
      return part;
    }
    function isLastNodeQuantifierNode(nodes) {
      const lastNode = last(nodes), lastNodeQuantifierNode = (0, _bnf.isNodeQuantifierNode)(lastNode);
      return lastNodeQuantifierNode;
    }
    function collectionOfPartsPartFromPartAndRuleName(part, ruleName) {
      let collectionOfPartsPart;
      switch (ruleName) {
        case _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME:
          const optionalPartPart = _optionalPart.default.fromPart(part);
          collectionOfPartsPart = optionalPartPart;
          break;
        case _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME:
          const oneOrMorePartsPart = _oneOrMoreParts.default.fromPart(part);
          collectionOfPartsPart = oneOrMorePartsPart;
          break;
        case _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME:
          const zeroOrMorePartsPart = _zeroOrMoreParts.default.fromPart(part);
          collectionOfPartsPart = zeroOrMorePartsPart;
          break;
      }
      return collectionOfPartsPart;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/name.js
  var require_name2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var NameBNFNode = class extends _nonTerminal.default {
      getName() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), name = terminalNodeContent;
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NameBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/node.js
  var require_node2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeFromChildNodesAndRuleName() {
        return nodeFromChildNodesAndRuleName;
      },
      get nodesFromChildNodesAndRuleName() {
        return nodesFromChildNodesAndRuleName;
      }
    });
    function nodeFromChildNodesAndRuleName(childNodes, ruleName) {
      let node = null;
      childNodes.some((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode = childNode, nonTerminalNodeRuleName = nonTerminalNode.getRuleName(), nonTerminalNodeRuleNameRuleName = nonTerminalNodeRuleName === ruleName;
          if (nonTerminalNodeRuleNameRuleName) {
            node = childNode;
            return true;
          }
        }
      });
      return node;
    }
    function nodesFromChildNodesAndRuleName(childNodes, ruleName) {
      const nodes = childNodes.filter((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode = childNode, nonTerminalNodeRuleName = nonTerminalNode.getRuleName(), nonTerminalNodeRuleNameRuleName = nonTerminalNodeRuleName === ruleName;
          if (nonTerminalNodeRuleNameRuleName) {
            return true;
          }
        }
      });
      return nodes;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/rule.js
  var require_rule3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, secondLast} = _necessary.arrayUtilities;
    var RuleBNFNode = class extends _nonTerminal.default {
      generateRule(Rule) {
        const name = this.getName(), opacity = this.getOpacity(), definitions = this.generateDefinitions(), rule = Rule.fromNameOpacityAndDefinitions(name, opacity, definitions);
        return rule;
      }
      getOpacity() {
        let opacity = null;
        const ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME, childNodes = this.getChildNodes(), opacityModifierBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        if (opacityModifierBNFNode !== null) {
          opacity = opacityModifierBNFNode.getOpacity();
        }
        return opacity;
      }
      getName() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), nameBNFNode = firstChildNode, name = nameBNFNode.getName();
        return name;
      }
      generateDefinitions() {
        const childNodes = this.getChildNodes(), secondLastChildNode = secondLast(childNodes), definitionsBNFNode = secondLastChildNode, definitions = definitionsBNFNode.generateDefinitions();
        return definitions;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RuleBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/error.js
  var require_error = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ErrorBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ErrorBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal.js
  var require_terminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPart;
      }
    });
    var TerminalPart = class {
      isCallAhead() {
        const callAhead = false;
        return callAhead;
      }
      isNonTerminalPart() {
        const nonTerminalPart = false;
        return nonTerminalPart;
      }
      isTerminalPart() {
        const terminalPart = true;
        return terminalPart;
      }
      isNoWhitespacePart() {
        const noWhitespacePart = false;
        return noWhitespacePart;
      }
      isStartOfContentPart() {
        const startOfContentPart = false;
        return startOfContentPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/terminalNode.js
  var require_terminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalNodeParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _constants = require_constants4();
    var _tokens = require_tokens();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {NEW_LINE_CHARACTER, CARRIAGE_RETURN_CHARACTER} = _necessary.characters;
    var TerminalNodeParseTree = class extends _verticalBranch.default {
      static fromTerminalNodeAndTokens(terminalNode, tokens) {
        let content;
        content = terminalNode.getContent();
        content = content.replace(/[\r\n]/g, (match) => {
          switch (match) {
            case CARRIAGE_RETURN_CHARACTER:
              return "\\r";
            case NEW_LINE_CHARACTER:
              return "\\n";
            default:
              return match;
          }
        });
        const type = terminalNode.getType(), significantTokenIndex = terminalNode.getSignificantTokenIndex(tokens), lineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(significantTokenIndex, tokens);
        let lineIndexes;
        if (lineIndex === null) {
          lineIndexes = _constants.EMPTY_STRING;
        } else {
          lineIndexes = ` [${lineIndex}]`;
        }
        const string = `"${content}"[${type}]${lineIndexes}`, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(TerminalNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        return terminalNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal.js
  var require_terminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalNode;
      }
    });
    var _terminalNode = /* @__PURE__ */ _interop_require_default(require_terminalNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalNode = class {
      constructor(parentNode, significantToken) {
        this.parentNode = parentNode;
        this.significantToken = significantToken;
      }
      getParentNode() {
        return this.parentNode;
      }
      getSignificantToken() {
        return this.significantToken;
      }
      setParentNode(parentNode) {
        this.parentNode = parentNode;
      }
      setSignificantToken(significantToken) {
        this.significantToken = significantToken;
      }
      isStartOfContentNode() {
        const startOfContentNode = false;
        return startOfContentNode;
      }
      isNoWhitespaceNode() {
        const noWhitespaceNode = false;
        return noWhitespaceNode;
      }
      isEpsilonNode() {
        const epsilonNode = false;
        return epsilonNode;
      }
      isTerminalNode() {
        const terminalNode = true;
        return terminalNode;
      }
      isNonTerminalNode() {
        const nonTerminalNode = false;
        return nonTerminalNode;
      }
      getType() {
        return this.significantToken.getType();
      }
      getContent() {
        return this.significantToken.getContent();
      }
      getPrecedence() {
        const precedence = null;
        return precedence;
      }
      isLowerPrecedence(parentRuleName, parentPrecedence) {
        const lowerPrecedence = false;
        return lowerPrecedence;
      }
      getFirstSignificantTokenIndex(tokens) {
        const significantTokenIndex = this.getSignificantTokenIndex(tokens), firstSignificantTokenIndex = significantTokenIndex;
        return firstSignificantTokenIndex;
      }
      getLastSignificantTokenIndex(tokens) {
        const significantTokenIndex = this.getSignificantTokenIndex(tokens), lastSignificantTokenIndex = significantTokenIndex;
        return lastSignificantTokenIndex;
      }
      getSignificantTokenIndex(tokens) {
        let significantTokenIndex = null;
        if (this.significantToken !== null) {
          significantTokenIndex = tokens.indexOf(this.significantToken);
        }
        return significantTokenIndex;
      }
      getSignificantTokens(significantTokens = []) {
        if (this.significantToken !== null) {
          significantTokens.push(this.significantToken);
        }
        return significantTokens;
      }
      getAncestorNodes() {
        const ancestorNodes = [];
        let ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          ancestorNodes.push(ancestorNode);
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
        }
        return ancestorNodes;
      }
      mapAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.map(callback);
      }
      someAncestorNode(callback) {
        let result = false;
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          result = !!callback(ancestorNode, index);
          if (result) {
            break;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        return result;
      }
      findAncestorNode(callback) {
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          const result = callback(ancestorNode, index);
          if (result) {
            return ancestorNode;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        ancestorNode = void 0;
        return ancestorNode;
      }
      everyAncestorNode(callback) {
        let result = true;
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          result = !!callback(ancestorNode, index);
          if (!result) {
            break;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        return result;
      }
      filterAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.filter(callback);
      }
      reduceAncestorNode(callback, initialValue) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.reduce(callback, initialValue);
      }
      forEachAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        ancestorNodes.forEach(callback);
      }
      getDescendantNodes(descendantNodes = []) {
        return descendantNodes;
      }
      someDescendantNode(callback) {
        const result = false;
        return result;
      }
      findDescendantNode(callback) {
        let descendantNode = void 0;
        return descendantNode;
      }
      everyDescendantNode(callback) {
        let result = true;
        return result;
      }
      asParseTree(tokens) {
        const terminalNode = this, terminalNodeParseTree = _terminalNode.default.fromTerminalNodeAndTokens(terminalNode, tokens), parseTree = terminalNodeParseTree;
        return parseTree;
      }
      match(node, depth = Infinity, exactly = false) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, significantToken = terminalNode.getSignificantToken();
          matches = exactly ? this.significantToken === significantToken : this.significantToken.match(significantToken);
        }
        return matches;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, parentNode = null, significantToken = this.significantToken, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
      destroy() {
        this.parentNode = null;
        this.significantToken = null;
      }
      static fromNothing(Class, ...remainingArguments) {
        if (Class === void 0) {
          Class = TerminalNode;
        }
        const parentNode = null, significantToken = null, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
      static fromSignificantToken(Class, significantToken, ...remainingArguments) {
        if (significantToken === void 0) {
          significantToken = Class;
          Class = TerminalNode;
        }
        const parentNode = null, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/epsilonNode.js
  var require_epsilonNode = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = epsilon, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EpsilonNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const epsilonNodeParseTree = terminalNodeParseTree;
        return epsilonNodeParseTree;
      }
    };
    module.exports = EpsilonNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/terminal/epsilon.js
  var require_epsilon = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonNode;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _epsilonNode = /* @__PURE__ */ _interop_require_default(require_epsilonNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = epsilon;
        return content;
      }
      isEpsilonNode() {
        const epsilonNode = true;
        return epsilonNode;
      }
      asParseTree(tokens) {
        const epsilonNodeParseTree = _epsilonNode.default.fromNothing(), parseTree = epsilonNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeEpsilonNode = terminalNode.isEpsilonNode();
          if (terminalNodeEpsilonNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(EpsilonNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/epsilon.js
  var require_epsilon2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonPart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), epsilonBNFNode = _epsilon.default.fromNothing();
        parsed = epsilonBNFNode !== null;
        if (parsed) {
          nodes.push(epsilonBNFNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = epsilon;
        return string;
      }
      static fromNothing() {
        const epsilonPart = new EpsilonPart();
        return epsilonPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/epsilon.js
  var require_epsilon3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonBNFNode;
      }
    });
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EpsilonBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const epsilonPart = _epsilon.default.fromNothing();
        return epsilonPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(EpsilonBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/document.js
  var require_document2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentBNFNode = class extends _nonTerminal.default {
      generateRules(Rule) {
        const ruleName = _ruleNames.RULE_RULE_NAME, childNodes = this.getChildNodes(), ruleBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName), rules = ruleBNFNodes.map((ruleBNFNode) => {
          const rule = ruleBNFNode.generateRule(Rule);
          return rule;
        });
        return rules;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DocumentBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/ruleName.js
  var require_ruleName2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNamePart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _constants = require_constants4();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {ellipsis} = _occamlexers.specialSymbols;
    var RuleNamePart = class extends _nonTerminal.default {
      constructor(type, callAAhead, ruleName) {
        super(type, callAAhead);
        this.ruleName = ruleName;
      }
      getRuleName() {
        return this.ruleName;
      }
      isRuleNamePart() {
        const ruleNamePart = true;
        return ruleNamePart;
      }
      findRule(state) {
        const ruleMap = state.getRuleMap(), rule = ruleMap[this.ruleName] || null;
        return rule;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const rule = this.findRule(state);
        parsed = rule !== null ? rule.parse(nodes, state, callback, callAhead) : false;
        return parsed;
      }
      asString() {
        const callAAhead = this.isCallAhead(), callAAheadString = callAAhead ? ellipsis : _constants.EMPTY_STRING, string = `${this.ruleName}${callAAheadString}`;
        return string;
      }
      static fromRuleName(ruleName) {
        const type = _partTypes.RuleNamePartType, callAAhead = false, ruleNamePart = new RuleNamePart(type, callAAhead, ruleName);
        return ruleNamePart;
      }
      static fromCallAheadAndRuleName(callAAhead, ruleName) {
        const type = _partTypes.RuleNamePartType, ruleNamePart = new RuleNamePart(type, callAAhead, ruleName);
        return ruleNamePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/ruleName.js
  var require_ruleName3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameBNFNode;
      }
    });
    var _necessary = require_browser();
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var RuleNameBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), ruleName = terminalNodeContent, ruleNamePart = _ruleName.default.fromCallAheadAndRuleName(callAhead, ruleName);
        return ruleNamePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RuleNameBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/wildcard.js
  var require_wildcard = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {wildcard} = _occamlexers.specialSymbols;
    var WildcardPart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          terminalNode = _terminal1.default.fromSignificantToken(significantToken);
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = wildcard;
        return string;
      }
      static fromNothing() {
        const wildcardPart = new WildcardPart();
        return wildcardPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/wildcard.js
  var require_wildcard2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardBNFNode;
      }
    });
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var WildcardBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const wildcardPart = _wildcard.default.fromNothing();
        return wildcardPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(WildcardBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/endOfLineNode.js
  var require_endOfLineNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLineNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = endOfLine, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EndOfLineNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const endOfLineNodeParseTree = terminalNodeParseTree;
        return endOfLineNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/endOfLine.js
  var require_endOfLine5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _endOfLineNode = /* @__PURE__ */ _interop_require_default(require_endOfLineNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfLineNode = class extends _terminal.default {
      getContent(faithful = false) {
        const content = faithful ? super.getContent() : _constants.EMPTY_STRING;
        return content;
      }
      asParseTree(tokens) {
        const endOfLineNodeParseTree = _endOfLineNode.default.fromNothing(), parseTree = endOfLineNodeParseTree;
        return parseTree;
      }
      static fromSignificantToken(significantToken) {
        return _terminal.default.fromSignificantToken(EndOfLineNode, significantToken);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/endOfLine.js
  var require_endOfLine6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLinePart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLinePart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let endOfLineNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const significantTokenEndOfLineToken = significantToken.isEndOfLineToken();
          if (significantTokenEndOfLineToken) {
            endOfLineNode = _endOfLine.default.fromSignificantToken(significantToken);
          }
        }
        parsed = endOfLineNode !== null;
        if (parsed) {
          nodes.push(endOfLineNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = endOfLine;
        return string;
      }
      static fromNothing() {
        const endOfLinePart = new EndOfLinePart();
        return endOfLinePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/endOfLine.js
  var require_endOfLine7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineBNFNode;
      }
    });
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine6());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfLineBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const endOfLinePart = _endOfLine.default.fromNothing();
        return endOfLinePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(EndOfLineBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/partChoice.js
  var require_partChoice = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoice;
      }
    });
    var _necessary = require_browser();
    var {SPACE_CHARACTER} = _necessary.characters;
    var PartChoice = class {
      constructor(part, precedence) {
        this.part = part;
        this.precedence = precedence;
      }
      getPart() {
        return this.part;
      }
      getPrecedence() {
        return this.precedence;
      }
      asString() {
        let string;
        const partString = this.part.asString();
        string = partString;
        if (this.precedence !== null) {
          const precedence = this.precedence === Infinity ? SPACE_CHARACTER : this.precedence;
          string = `${string} (${precedence})`;
        }
        return string;
      }
      static fromPart(part) {
        const precedence = null, partChoice = new PartChoice(part, precedence);
        return partChoice;
      }
      static fromPartAndPrecedence(part, precedence) {
        const partChoice = new PartChoice(part, precedence);
        return partChoice;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/partChoice.js
  var require_partChoice2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceBNFNode;
      }
    });
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _node = require_node2();
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceBNFNode = class extends _nonTerminal.default {
      generatePartChoice(callAhead) {
        let ruleName;
        const childNodes = this.getChildNodes();
        ruleName = _ruleNames.PART_RULE_NAME;
        const partBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const part = partBNFNode.generatePart(callAhead), precedence = precedenceBNFNode === null ? null : precedenceBNFNode.getPrecedence(), definition = _partChoice.default.fromPartAndPrecedence(part, precedence);
        return definition;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PartChoiceBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/precedence.js
  var require_precedence = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {second} = _necessary.arrayUtilities;
    var PrecedenceBNFNode = class extends _nonTerminal.default {
      getPrecedence() {
        let precedence = Infinity;
        const multiplicity = this.getMultiplicity();
        if (multiplicity === 3) {
          const childNodes = this.getChildNodes(), secondChildNode = second(childNodes), terminalNode = secondChildNode, content = terminalNode.getContent();
          precedence = Number(content);
        }
        return precedence;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PrecedenceBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/quantifier.js
  var require_quantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(QuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/parse.js
  var require_parse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get parsePart() {
        return parsePart;
      },
      get parseParts() {
        return parseParts;
      }
    });
    function parsePart(part, nodes, state, callback, callAhead) {
      let parsed;
      const index = 0, parts = [
        part
      ];
      parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      return parsed;
    }
    function parseParts(parts, nodes, state, callback, callAhead) {
      let parsed;
      const index = 0;
      parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      return parsed;
    }
    function parsePartOfParts(index, parts, nodes, state, callback, callAhead) {
      let parsed;
      const partsLength = parts.length;
      if (index === partsLength) {
        parsed = callback !== null ? callback() : true;
      } else {
        const part = parts[index], partCallAhead = callAhead === null ? part.isCallAhead() : true;
        index++;
        parsed = partCallAhead ? parsePartWithCallAhead(part, index, parts, nodes, state, callback, callAhead) : parsePartWithoutCallAhead(part, index, parts, nodes, state, callback, callAhead);
      }
      return parsed;
    }
    function parsePartWithCallAhead(part, index, parts, nodes, state, callback, callAhead) {
      let parsed;
      const nodesLength = nodes.length;
      callAhead = () => {
        let parsed2;
        parsed2 = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
        return parsed2;
      };
      parsed = part.parse(nodes, state, callback, callAhead);
      if (!parsed) {
        const start = nodesLength;
        nodes.splice(start);
      }
      return parsed;
    }
    function parsePartWithoutCallAhead(part, index, parts, nodes, state, callback, callAhead) {
      let parsed;
      parsed = part.parse(nodes, state, callback, callAhead);
      if (parsed) {
        parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/definition.js
  var require_definition = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Definition;
      }
    });
    var _necessary = require_browser();
    var _parse = require_parse();
    var _constants = require_constants4();
    var {SPACE_CHARACTER} = _necessary.characters;
    var Definition = class {
      constructor(parts, precedence) {
        this.parts = parts;
        this.precedence = precedence;
      }
      getParts() {
        return this.parts;
      }
      getPrecedence() {
        return this.precedence;
      }
      parse(childNodes, state, callback, callAhead) {
        let parsed;
        const nodes = childNodes, savedIndex = state.getSavedIndex();
        parsed = (0, _parse.parseParts)(this.parts, nodes, state, callback, callAhead);
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        let string;
        const partsString = this.parts.reduce((partsString2, part) => {
          const partString = part.asString();
          if (partsString2 === _constants.EMPTY_STRING) {
            partsString2 = partString;
          } else {
            partsString2 = `${partsString2} ${partString}`;
          }
          return partsString2;
        }, _constants.EMPTY_STRING);
        string = partsString;
        if (this.precedence !== null) {
          const precedence = this.precedence === Infinity ? SPACE_CHARACTER : this.precedence;
          string = `${string} (${precedence})`;
        }
        return string;
      }
      static fromParts(Class, parts) {
        if (parts === void 0) {
          parts = Class;
          Class = Definition;
        }
        const precedence = null, definition = new Class(parts, precedence);
        return definition;
      }
      static fromPartsAndPrecedence(Class, parts, precedence) {
        if (precedence === void 0) {
          precedence = parts;
          parts = Class;
          Class = Definition;
        }
        const definition = new Class(parts, precedence);
        return definition;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/definition.js
  var require_definition2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionBNFNode;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionBNFNode = class extends _nonTerminal.default {
      generateDefinition() {
        let ruleName;
        const childNodes = this.getChildNodes();
        ruleName = _ruleNames.PART_RULE_NAME;
        const partBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName), callAhead = false, parts = partBNFNodes.map((partBNFNode) => {
          const part = partBNFNode.generatePart(callAhead);
          return part;
        }), precedence = precedenceBNFNode === null ? null : precedenceBNFNode.getPrecedence(), definition = _definition.default.fromPartsAndPrecedence(parts, precedence);
        return definition;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DefinitionBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/definitions.js
  var require_definitions = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionsBNFNode = class extends _nonTerminal.default {
      generateDefinitions() {
        const ruleName = _ruleNames.DEFINITION_RULE_NAME, childNodes = this.getChildNodes(), definitionBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName), definitions = definitionBNFNodes.map((definitionBNFNode) => {
          const definition = definitionBNFNode.generateDefinition();
          return definition;
        });
        return definitions;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DefinitionsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/terminalPart.js
  var require_terminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var TerminalPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), node = firstChildNode, part = node.generatePart(callAhead);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(TerminalPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/choiceOfParts.js
  var require_choiceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsPart;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _parse = require_parse();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, partChoices) {
        super(type, callAhead);
        this.partChoices = partChoices;
      }
      getPartChoices() {
        return this.partChoices;
      }
      getParts() {
        const parts = this.partChoices.map((partChoice) => {
          const part = partChoice.getPart();
          return part;
        });
        return parts;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedPrecedence = state.getSavedPrecedence();
        parsed = this.partChoices.some((partChoice) => {
          let parsed2;
          const part = partChoice.getPart(), savedIndex = state.getSavedIndex(), precedence = partChoice.getPrecedence(), nodesLength = nodes.length;
          if (precedence !== null) {
            state.setPrecedence(precedence);
          }
          callback = callAhead === null ? null : () => {
            let parsed3;
            parsed3 = callAhead();
            return parsed3;
          };
          parsed2 = (0, _parse.parsePart)(part, nodes, state, callback, callAhead);
          if (!parsed2) {
            const start = nodesLength;
            nodes.splice(start);
            state.backtrack(savedIndex);
          }
          return parsed2;
        });
        if (!parsed) {
          state.resetPrecedence(savedPrecedence);
        }
        return parsed;
      }
      asString() {
        const partChoicesString = this.partChoices.reduce((partChoicesString2, partChoice) => {
          const partChoiceString = partChoice.asString();
          if (partChoicesString2 === null) {
            partChoicesString2 = partChoiceString;
          } else {
            partChoicesString2 = `${partChoicesString2} | ${partChoiceString}`;
          }
          return partChoicesString2;
        }, null), string = `( ${partChoicesString} )`;
        return string;
      }
      static fromPartChoices(partChoices) {
        const type = _partTypes.ChoiceOfPartsPartType, callAhead = false, choiceOfPartsPart = new ChoiceOfPartsPart(type, callAhead, partChoices);
        return choiceOfPartsPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/choiceOfParts.js
  var require_choiceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const ruleName = _ruleNames.PART_CHOICE_RULE_NAME, childNodes = this.getChildNodes(), partChoiceBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const partChoices = partChoiceBNFNodes.map((partChoiceBNFNode) => {
          const partChoice = partChoiceBNFNode.generatePartChoice(callAhead);
          return partChoice;
        }), choiceOfPartsPart = _choiceOfParts.default.fromPartChoices(partChoices), part = choiceOfPartsPart;
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ChoiceOfPartsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/stringLiteral.js
  var require_stringLiteral2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralPart;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StringLiteralPart = class extends _terminal.default {
      constructor(content) {
        super();
        this.content = content;
      }
      getContent() {
        return this.content;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const content = significantToken.getContent();
          if (content === this.content) {
            terminalNode = _terminal1.default.fromSignificantToken(significantToken);
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const content = this.content.replace(/\\/, "\\\\"), string = `"${content}"`;
        return string;
      }
      static fromContent(content) {
        const stringLiteralPart = new StringLiteralPart(content);
        return stringLiteralPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/stringLiteral.js
  var require_stringLiteral3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var StringLiteralBNFNode = class extends _nonTerminal.default {
      regularExpression = /^"((?:\\.|[^"\\])*)"$/;
      generatePart(callAhead) {
        const content = this.getContent(), stringLiteralPart = _stringLiteral.default.fromContent(content);
        return stringLiteralPart;
      }
      getContent() {
        let content;
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches);
        content = secondMatch;
        content = sanitiseContent(content);
        return content;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(StringLiteralBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    function sanitiseContent(content) {
      content = content.replace(/\\\\/g, _constants.ESCAPED_BACKSLASH).replace(/\\"/g, _constants.ESCAPED_DOUBLE_QUOTE);
      return content;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/nonTerminalPart.js
  var require_nonTerminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var NonTerminalPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes();
        if (!callAhead) {
          const ruleName = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME, callAheadModifierBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
          callAhead = callAheadModifierBNFNode !== null;
        }
        const firstChildNode = first2(childNodes), node = firstChildNode, part = node.generatePart(callAhead);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NonTerminalPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/sequenceOfParts.js
  var require_sequenceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsPart;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _parse = require_parse();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, parts) {
        super(type, callAhead);
        this.parts = parts;
      }
      getParts() {
        return this.parts;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        callback = callAhead === null ? null : () => {
          let parsed2;
          parsed2 = callAhead();
          return parsed2;
        };
        parsed = (0, _parse.parseParts)(this.parts, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partsString = this.parts.reduce((partsString2, part) => {
          const partString = part.asString();
          if (partsString2 === null) {
            partsString2 = partString;
          } else {
            partsString2 = `${partsString2} ${partString}`;
          }
          return partsString2;
        }, null), string = `( ${partsString} )`;
        return string;
      }
      static fromParts(parts) {
        const type = _partTypes.SequenceOfPartsPartType, callAhead = false, sequenceOfPartsPart = new SequenceOfPartsPart(type, callAhead, parts);
        return sequenceOfPartsPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/sequenceOfParts.js
  var require_sequenceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const ruleName = _ruleNames.PART_RULE_NAME, childNodes = this.getChildNodes(), partBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const parts = partBNFNodes.map((partBNFNode) => {
          const part2 = partBNFNode.generatePart(callAhead);
          return part2;
        }), sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), part = sequenceOfPartsPart;
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(SequenceOfPartsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/opacityModifier.js
  var require_opacityModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {second} = _necessary.arrayUtilities;
    var OpacityModifierBNFNode = class extends _nonTerminal.default {
      getOpacity() {
        const childNodes = this.getChildNodes(), secondChildNode = second(childNodes), terminalNode = secondChildNode, terminalNodeContent = terminalNode.getContent(), opacity = terminalNodeContent;
        return opacity;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OpacityModifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/noWhitespaceNode.js
  var require_noWhitespaceNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespaceNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespaceNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = noWhitespace, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(NoWhitespaceNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const noWhitespaceNodeParseTree = terminalNodeParseTree;
        return noWhitespaceNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/noWhitespace.js
  var require_noWhitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespaceNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _noWhitespaceNode = /* @__PURE__ */ _interop_require_default(require_noWhitespaceNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespaceNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = _constants.EMPTY_STRING;
        return content;
      }
      isNoWhitespaceNode() {
        const noWhitespaceNode = true;
        return noWhitespaceNode;
      }
      asParseTree(tokens) {
        const noWhitespaceNodeParseTree = _noWhitespaceNode.default.fromNothing(), parseTree = noWhitespaceNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeNoWhitespaceNode = terminalNode.isNoWhitespaceNode();
          if (terminalNodeNoWhitespaceNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(NoWhitespaceNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/noWhitespace.js
  var require_noWhitespace2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespacePart = class extends _terminal.default {
      isNoWhitespacePart() {
        const noWhitespacePart = true;
        return noWhitespacePart;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let noWhitespaceNode = null;
        const savedIndex = state.getSavedIndex(), nextTokenWhitespaceToken = state.isNextTokenWhitespaceToken();
        if (!nextTokenWhitespaceToken) {
          noWhitespaceNode = _noWhitespace.default.fromNothing();
        }
        parsed = noWhitespaceNode !== null;
        if (parsed) {
          nodes.push(noWhitespaceNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = noWhitespace;
        return string;
      }
      static fromNothing() {
        const noWhitespacePart = new NoWhitespacePart();
        return noWhitespacePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/noWhitespacePart.js
  var require_noWhitespacePart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespacePartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const noWhitespacePart = _noWhitespace.default.fromNothing();
        return noWhitespacePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NoWhitespacePartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/callAheadModifier.js
  var require_callAheadModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CallAheadModifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(CallAheadModifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/regularExpression.js
  var require_regularExpression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionPart;
      }
    });
    var _necessary = require_browser();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var RegularExpressionPart = class extends _terminal.default {
      constructor(regularExpression) {
        super();
        this.regularExpression = regularExpression;
      }
      getRegularExpression() {
        return this.regularExpression;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const content = significantToken.getContent(), matches = content.match(this.regularExpression);
          if (matches !== null) {
            const firstMatch = first2(matches);
            if (firstMatch === content) {
              terminalNode = _terminal1.default.fromSignificantToken(significantToken);
            }
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const regularExpressionString = this.regularExpression.toString(), string = regularExpressionString;
        return string;
      }
      static fromRegularExpression(regularExpression) {
        const regularExpressionPart = new RegularExpressionPart(regularExpression);
        return regularExpressionPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/regularExpression.js
  var require_regularExpression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var RegularExpressionBNFNode = class extends _nonTerminal.default {
      regularExpression = /^\/((?:\\.|[^\/])*)\/$/;
      generatePart(callAhead) {
        const regularExpression = this.getRegularExpression(), regularExpressionPart = _regularExpression.default.fromRegularExpression(regularExpression);
        return regularExpressionPart;
      }
      getRegularExpression() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches), pattern = secondMatch, regularExpression = new RegExp(pattern);
        return regularExpression;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RegularExpressionBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/startOfContentNode.js
  var require_startOfContentNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = startOfContent, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(StartOfContentNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const startOfContentNodeParseTree = terminalNodeParseTree;
        return startOfContentNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/startOfContent.js
  var require_startOfContent = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _startOfContentNode = /* @__PURE__ */ _interop_require_default(require_startOfContentNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = _constants.EMPTY_STRING;
        return content;
      }
      isStartOfContentNode() {
        const startOfContentNode = true;
        return startOfContentNode;
      }
      asParseTree(tokens) {
        const startOfContentNodeParseTree = _startOfContentNode.default.fromNothing(), parseTree = startOfContentNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeStartOfContentNode = terminalNode.isStartOfContentNode();
          if (terminalNodeStartOfContentNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(StartOfContentNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/startOfContent.js
  var require_startOfContent2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _startOfContent = /* @__PURE__ */ _interop_require_default(require_startOfContent());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentPart = class extends _terminal.default {
      isStartOfContentPart() {
        const startOfContentPart = true;
        return startOfContentPart;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let startOfContentNode = null;
        const savedIndex = state.getSavedIndex(), atStartOfContent = state.isAtStartOfContent();
        if (atStartOfContent) {
          startOfContentNode = _startOfContent.default.fromNothing();
        }
        parsed = startOfContentNode !== null;
        if (parsed) {
          nodes.push(startOfContentNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = startOfContent;
        return string;
      }
      static fromNothing() {
        const startOfContentPart = new StartOfContentPart();
        return startOfContentPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/startOfContentPart.js
  var require_startOfContentPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _startOfContent = /* @__PURE__ */ _interop_require_default(require_startOfContent2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const startOfContentPart = _startOfContent.default.fromNothing();
        return startOfContentPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(StartOfContentPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/optionalQuantifier.js
  var require_optionalQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OptionalQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OptionalQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OptionalQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/oneOneOrMoreQuantifier.js
  var require_oneOneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OneOrMoreQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OneOrMoreQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OneOrMoreQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/significantTokenType.js
  var require_significantTokenType = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypePart;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantTokenTypePart = class extends _terminal.default {
      constructor(significantTokenType) {
        super();
        this.significantTokenType = significantTokenType;
      }
      getSignificantTokenType() {
        return this.significantTokenType;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const significantTokenType = significantToken.getType();
          if (significantTokenType === this.significantTokenType) {
            terminalNode = _terminal1.default.fromSignificantToken(significantToken);
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = `[${this.significantTokenType}]`;
        return string;
      }
      static fromSignificantTokenType(significantTokenType) {
        const significantTokenTypePart = new SignificantTokenTypePart(significantTokenType);
        return significantTokenTypePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/significantTokenType.js
  var require_significantTokenType2 = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var SignificantTokenTypeBNFNode = class extends _nonTerminal.default {
      regularExpression = /^\[([^\]]+)]$/;
      generatePart(callAhead) {
        const significantTokenType = this.getSignificantTokenType(), significantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType);
        return significantTokenTypePart;
      }
      getSignificantTokenType() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches), significantTokenType = secondMatch;
        return significantTokenType;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(SignificantTokenTypeBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    module.exports = SignificantTokenTypeBNFNode;
  });

  // node_modules/occam-parsers/lib/node/bnf/zeroOneOrMoreQuantifier.js
  var require_zeroOneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZerorOrMoreQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ZerorOrMoreQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ZerorOrMoreQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _part = /* @__PURE__ */ _interop_require_default(require_part());
    var _name = /* @__PURE__ */ _interop_require_default(require_name2());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule3());
    var _error = /* @__PURE__ */ _interop_require_default(require_error());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon3());
    var _document = /* @__PURE__ */ _interop_require_default(require_document2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName3());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard2());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine7());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice2());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence());
    var _quantifier = /* @__PURE__ */ _interop_require_default(require_quantifier());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition2());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions());
    var _terminalPart = /* @__PURE__ */ _interop_require_default(require_terminalPart());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral3());
    var _nonTerminalPart = /* @__PURE__ */ _interop_require_default(require_nonTerminalPart());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts2());
    var _opacityModifier = /* @__PURE__ */ _interop_require_default(require_opacityModifier());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart());
    var _callAheadModifier = /* @__PURE__ */ _interop_require_default(require_callAheadModifier());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression3());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart());
    var _optionalQuantifier = /* @__PURE__ */ _interop_require_default(require_optionalQuantifier());
    var _oneOneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_oneOneOrMoreQuantifier());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType2());
    var _zeroOneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_zeroOneOrMoreQuantifier());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeMap = {
      [_ruleNames.NAME_RULE_NAME]: _name.default,
      [_ruleNames.PART_RULE_NAME]: _part.default,
      [_ruleNames.RULE_RULE_NAME]: _rule.default,
      [_ruleNames.ERROR_RULE_NAME]: _error.default,
      [_ruleNames.EPSILON_RULE_NAME]: _epsilon.default,
      [_ruleNames.DOCUMENT_RULE_NAME]: _document.default,
      [_ruleNames.WILDCARD_RULE_NAME]: _wildcard.default,
      [_ruleNames.RULE_NAME_RULE_NAME]: _ruleName.default,
      [_ruleNames.DEFINITION_RULE_NAME]: _definition.default,
      [_ruleNames.PRECEDENCE_RULE_NAME]: _precedence.default,
      [_ruleNames.QUANTIFIER_RULE_NAME]: _quantifier.default,
      [_ruleNames.END_OF_LINE_RULE_NAME]: _endOfLine.default,
      [_ruleNames.PART_CHOICE_RULE_NAME]: _partChoice.default,
      [_ruleNames.DEFINITIONS_RULE_NAME]: _definitions.default,
      [_ruleNames.TERMINAL_PART_RULE_NAME]: _terminalPart.default,
      [_ruleNames.STRING_LITERAL_RULE_NAME]: _stringLiteral.default,
      [_ruleNames.CHOICE_OF_PARTS_RULE_NAME]: _choiceOfParts.default,
      [_ruleNames.OPACITY_MODIFIER_RULE_NAME]: _opacityModifier.default,
      [_ruleNames.NON_TERMINAL_PART_RULE_NAME]: _nonTerminalPart.default,
      [_ruleNames.SEQUENCE_OF_PARTS_RULE_NAME]: _sequenceOfParts.default,
      [_ruleNames.NO_WHITESPACE_PART_RULE_NAME]: _noWhitespacePart.default,
      [_ruleNames.REGULAR_EXPRESSION_RULE_NAME]: _regularExpression.default,
      [_ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME]: _callAheadModifier.default,
      [_ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME]: _optionalQuantifier.default,
      [_ruleNames.START_OF_CONTENT_PART_RULE_NAME]: _startOfContentPart.default,
      [_ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME]: _significantTokenType.default,
      [_ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME]: _oneOneOrMoreQuantifier.default,
      [_ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME]: _zeroOneOrMoreQuantifier.default
    };
    var _default = NonTerminalNodeMap;
  });

  // node_modules/occam-parsers/lib/state.js
  var require_state2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return State;
      }
    });
    var State = class {
      constructor(index, tokens, ruleMap, precedence, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode) {
        this.index = index;
        this.tokens = tokens;
        this.ruleMap = ruleMap;
        this.precedence = precedence;
        this.startOfContent = startOfContent;
        this.NonTerminalNodeMap = NonTerminalNodeMap;
        this.defaultNonTerminalNode = defaultNonTerminalNode;
      }
      getIndex() {
        return this.index;
      }
      getTokens() {
        return this.tokens;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      getPrecedence() {
        return this.precedence;
      }
      getStartOfContent() {
        return this.startOfContent;
      }
      getNonTerminalNode() {
        return this.NonTerminalNodeMap;
      }
      getDefaultNonTerminalNode() {
        return this.defaultNonTerminalNode;
      }
      setIndex(index) {
        this.index = index;
      }
      setTokens(tokens) {
        this.tokens = tokens;
      }
      setRuleMap(ruleMap) {
        this.ruleMap = ruleMap;
      }
      setPrecedence(precedence) {
        this.precedence = precedence;
      }
      setStartOfContent(startOfContent) {
        this.startOfContent = startOfContent;
      }
      getSavedPrecedence() {
        const savedPrecedence = this.precedence;
        return savedPrecedence;
      }
      getSavedIndex() {
        const savedIndex = this.index;
        return savedIndex;
      }
      getNextToken() {
        let nextToken = null;
        const tokensLength = this.tokens.length;
        if (this.index < tokensLength) {
          nextToken = this.tokens[this.index++];
        }
        return nextToken;
      }
      isAtStartOfContent() {
        const atStartOfContent = this.startOfContent ? this.index === 0 : false;
        return atStartOfContent;
      }
      getNextSignificantToken() {
        let nextSignificantToken = null;
        const tokensLength = this.tokens.length;
        while (this.index < tokensLength) {
          const token = this.tokens[this.index++], tokenSignificant = token.isSignificant();
          if (tokenSignificant) {
            const significantToken = token;
            nextSignificantToken = significantToken;
            break;
          }
        }
        return nextSignificantToken;
      }
      isNextTokenWhitespaceToken() {
        let nextTokenWhitespaceToken = false;
        const tokensLength = this.tokens.length;
        if (this.index < tokensLength) {
          const nextToken = this.tokens[this.index];
          nextTokenWhitespaceToken = nextToken.isWhitespaceToken();
        }
        return nextTokenWhitespaceToken;
      }
      backtrack(savedIndex) {
        this.index = savedIndex;
      }
      resetPrecedence(savedPrecedence) {
        this.precedence = savedPrecedence;
      }
      NonTerminalNodeFromRuleName(ruleName) {
        const NonTerminalNode = Object.hasOwn(this.NonTerminalNodeMap, ruleName) ? this.NonTerminalNodeMap[ruleName] : this.defaultNonTerminalNode;
        return NonTerminalNode;
      }
      static fromTokensRuleMapStartOfContentNonTerminalNodeMapAndDefaultNonTerminalNode(tokens, ruleMap, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode) {
        const index = 0, precedence = null, state = new State(index, tokens, ruleMap, precedence, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode);
        return state;
      }
    };
  });

  // node_modules/occam-parsers/lib/mixins/parser.js
  var require_parser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _state = /* @__PURE__ */ _interop_require_default(require_state2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    function parse(tokens, rule = this.startRule, startOfContent = true) {
      let node = null;
      const nodes = [], {NonTerminalNodeMap, defaultNonTerminalNode} = this.constructor, state = _state.default.fromTokensRuleMapStartOfContentNonTerminalNodeMapAndDefaultNonTerminalNode(tokens, this.ruleMap, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode), callback = null, callAhead = null, parsed = rule.parse(nodes, state, callback, callAhead);
      if (parsed) {
        const firstNode = first2(nodes);
        node = firstNode;
      }
      return node;
    }
    var parserMixins = {
      parse
    };
    var _default = parserMixins;
  });

  // node_modules/occam-parsers/lib/definition/name.js
  var require_name3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {nameType} = _occamlexers.types;
    var NameDefinition = class extends _definition.default {
      static fromNothing() {
        const significantTokenType = nameType, nameSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), parts = [
          nameSignificantTokenTypePart
        ], precedence = null, nameDefinition = new NameDefinition(parts, precedence);
        return nameDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/name.js
  var require_name4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _name = /* @__PURE__ */ _interop_require_default(require_name3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NameBNFRule = class extends _rule.default {
      static fromNothing() {
        const nameDefinition = _name.default.fromNothing(), name = _ruleNames.NAME_RULE_NAME, opacity = null, definitions = [
          nameDefinition
        ], nameRule = new NameBNFRule(name, opacity, definitions);
        return nameRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/terminal.js
  var require_terminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.QUANTIFIER_RULE_NAME;
        const quantifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.TERMINAL_PART_RULE_NAME;
        const terminalPartRuleNamePart = _ruleName.default.fromRuleName(ruleName), zeroOrMoreQuantifierRuleNamePartsPart = _zeroOrMoreParts.default.fromPart(quantifierRuleNamePart), parts = [
          terminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ], precedence = null, terminalPartRuleDefinition = new TerminalPartRuleDefinition(parts, precedence);
        return terminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal.js
  var require_nonTerminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.QUANTIFIER_RULE_NAME;
        const quantifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NON_TERMINAL_PART_RULE_NAME;
        const nonTerminalPartRuleNamePart = _ruleName.default.fromRuleName(ruleName), zeroOrMoreQuantifierRuleNamePartsPart = _zeroOrMoreParts.default.fromPart(quantifierRuleNamePart), parts = [
          nonTerminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ], precedence = null, nonTerminalPartRuleDefinition = new NonTerminalPartRuleDefinition(parts, precedence);
        return nonTerminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/part.js
  var require_part2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal3());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PART_RULE_NAME, terminalPartRuleDefinition = _terminal.default.fromNothing(), nonTerminalPartRuleDefinition = _nonTerminal.default.fromNothing(), opacity = null, definitions = [
          nonTerminalPartRuleDefinition,
          terminalPartRuleDefinition
        ], partRule = new PartBNFRule(name, opacity, definitions);
        return partRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/rule.js
  var require_rule4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {separator, terminator} = _occamlexers.specialSymbols;
    var RuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        const separatorStringLiteralContent = separator, terminatorStringLiteralContent = terminator;
        ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME;
        const opacityModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NAME_RULE_NAME;
        const nameRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalOpacityRuleNamePartPart = _optionalPart.default.fromPart(opacityModifierRuleNamePart), separatorStringLiteralPart = _stringLiteral.default.fromContent(separatorStringLiteralContent);
        ruleName = _ruleNames.DEFINITIONS_RULE_NAME;
        const definitionsRuleNamePart = _ruleName.default.fromRuleName(ruleName), terminatorStringLiteralPart = _stringLiteral.default.fromContent(terminatorStringLiteralContent), parts = [
          nameRuleNamePart,
          optionalOpacityRuleNamePartPart,
          separatorStringLiteralPart,
          definitionsRuleNamePart,
          terminatorStringLiteralPart
        ], precedence = null, ruleDefinition = new RuleDefinition(parts, precedence);
        return ruleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/rule.js
  var require_rule5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _rule1 = /* @__PURE__ */ _interop_require_default(require_rule4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleBNFRule = class extends _rule.default {
      static fromNothing() {
        const ruleDefinition = _rule1.default.fromNothing(), name = _ruleNames.RULE_RULE_NAME, opacity = null, definitions = [
          ruleDefinition
        ], ruleRule = new RuleBNFRule(name, opacity, definitions);
        return ruleRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/error.js
  var require_error2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ErrorDefinition = class extends _definition.default {
      static fromNothing() {
        const wildcardPart = _wildcard.default.fromNothing(), parts = [
          wildcardPart
        ], precedence = null, errorDefinition = new ErrorDefinition(parts, precedence);
        return errorDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/error.js
  var require_error3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _error = /* @__PURE__ */ _interop_require_default(require_error2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque} = _occamlexers.specialSymbols;
    var ErrorBNFRule = class extends _rule.default {
      static fromNothing() {
        const errorDefinition = _error.default.fromNothing(), name = _ruleNames.ERROR_RULE_NAME, opacity = opaque, definitions = [
          errorDefinition
        ], errorRule = new ErrorBNFRule(name, opacity, definitions);
        return errorRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/stringLiteral.js
  var require_stringLiteral4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StringLiteralDefinition = class extends _definition.default {
      static fromContent(content) {
        const stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, stringLiteralDefinition = new StringLiteralDefinition(parts, precedence);
        return stringLiteralDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/epsilon.js
  var require_epsilon4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = epsilon, epsilonStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.EPSILON_RULE_NAME, opacity = null, definitions = [
          epsilonStringLiteralDefinition
        ], epsilonRule = new EpsilonBNFRule(name, opacity, definitions);
        return epsilonRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/document.js
  var require_document3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.RULE_RULE_NAME;
        const ruleRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ERROR_RULE_NAME;
        const errorRuleNamePart = _ruleName.default.fromRuleName(ruleName), ruleRuleNamePartChoice = _partChoice.default.fromPart(ruleRuleNamePart), errorRuleNamePartChoice = _partChoice.default.fromPart(errorRuleNamePart), partChoices = [
          ruleRuleNamePartChoice,
          errorRuleNamePartChoice
        ], choiceOfRuleRuleNameAndErrorRuleNamePartsPart = _choiceOfParts.default.fromPartChoices(partChoices), oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart = _oneOrMoreParts.default.fromPart(choiceOfRuleRuleNameAndErrorRuleNamePartsPart), parts = [
          oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart
        ], precedence = null, documentDefinition = new DocumentDefinition(parts, precedence);
        return documentDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/document.js
  var require_document4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _document = /* @__PURE__ */ _interop_require_default(require_document3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentBNFRule = class extends _rule.default {
      static fromNothing() {
        const documentDefinition = _document.default.fromNothing(), name = _ruleNames.DOCUMENT_RULE_NAME, opacity = null, definitions = [
          documentDefinition
        ], documentRule = new DocumentBNFRule(name, opacity, definitions);
        return documentRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/ruleName.js
  var require_ruleName4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _name = /* @__PURE__ */ _interop_require_default(require_name3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameBNFRule = class extends _rule.default {
      static fromNothing() {
        const nameDefinition = _name.default.fromNothing(), name = _ruleNames.RULE_NAME_RULE_NAME, opacity = null, definitions = [
          nameDefinition
        ], ruleNameRule = new RuleNameBNFRule(name, opacity, definitions);
        return ruleNameRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/wildcard.js
  var require_wildcard3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {wildcard} = _occamlexers.specialSymbols;
    var WildcardBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = wildcard, wildcardStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.WILDCARD_RULE_NAME, opacity = null, definitions = [
          wildcardStringLiteralDefinition
        ], wildcardRule = new WildcardBNFRule(name, opacity, definitions);
        return wildcardRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/endOfLine.js
  var require_endOfLine8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLineBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = endOfLine, endOfLineStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.END_OF_LINE_RULE_NAME, opacity = null, definitions = [
          endOfLineStringLiteralDefinition
        ], endOfLineRule = new EndOfLineBNFRule(name, opacity, definitions);
        return endOfLineRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partChoice.js
  var require_partChoice3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.PART_RULE_NAME;
        const partRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalPrecedenceRuleNamePartPart = _optionalPart.default.fromPart(precedenceRuleNamePart), parts = [
          partRuleNamePart,
          optionalPrecedenceRuleNamePartPart
        ], precedence = null, partChoiceDefinition = new PartChoiceDefinition(parts, precedence);
        return partChoiceDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/partChoice.js
  var require_partChoice4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PART_CHOICE_RULE_NAME, partChoiceDefinition = _partChoice.default.fromNothing(), opacity = null, definitions = [
          partChoiceDefinition
        ], definitionRule = new PartChoiceBNFRule(name, opacity, definitions);
        return definitionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/ruleName.js
  var require_ruleName5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameDefinition = class extends _definition.default {
      static fromRuleName(ruleName) {
        const ruleNameRuleNamePart = _ruleName.default.fromRuleName(ruleName), parts = [
          ruleNameRuleNamePart
        ], precedence = null, ruleNameDefinition = new RuleNameDefinition(parts, precedence);
        return ruleNameDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/quantifier.js
  var require_quantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.QUANTIFIER_RULE_NAME;
        ruleName = _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME;
        const optionalQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME;
        const oneOrMoreQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME;
        const zeroOrMoreQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), opacity = null, definitions = [
          optionalQuantifierRuleNameDefinition,
          oneOrMoreQuantifierRuleNameDefinition,
          zeroOrMoreQuantifierRuleNameDefinition
        ], quantifierRule = new QuantifierBNFRule(name, opacity, definitions);
        return quantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/definition.js
  var require_definition3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.PART_RULE_NAME;
        const partRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceRuleNamePart = _ruleName.default.fromRuleName(ruleName), oneOrMoreRuleNamePartsPart = _oneOrMoreParts.default.fromPart(partRuleNamePart), optionalPrecedenceRuleNamePartPart = _optionalPart.default.fromPart(precedenceRuleNamePart), parts = [
          oneOrMoreRuleNamePartsPart,
          optionalPrecedenceRuleNamePartPart
        ], precedence = null, definitionDefinition = new DefinitionDefinition(parts, precedence);
        return definitionDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/definition.js
  var require_definition4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.DEFINITION_RULE_NAME, definitionDefinition = _definition.default.fromNothing(), opacity = null, definitions = [
          definitionDefinition
        ], definitionRule = new DefinitionBNFRule(name, opacity, definitions);
        return definitionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/precedence.js
  var require_precedence2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {numberType} = _occamlexers.types;
    var {openBracket, closeBracket} = _occamlexers.specialSymbols;
    var PrecedenceDefinition = class extends _definition.default {
      static fromNothing() {
        const significantTokenType = numberType, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), numberSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), optionalNumberSignificantTokenTypePartPart = _optionalPart.default.fromPart(numberSignificantTokenTypePart), parts = [
          openBracketStringLiteralPart,
          optionalNumberSignificantTokenTypePartPart,
          closeBracketStringLiteralPart
        ], precedence = null, precedenceDefinition = new PrecedenceDefinition(parts, precedence);
        return precedenceDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/precedence.js
  var require_precedence3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrecedenceBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PRECEDENCE_RULE_NAME, precedenceDefinition = _precedence.default.fromNothing(), opacity = null, definitions = [
          precedenceDefinition
        ], precedenceRule = new PrecedenceBNFRule(name, opacity, definitions);
        return precedenceRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/definitions.js
  var require_definitions2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {verticalBar} = _occamlexers.specialSymbols;
    var DefinitionsDefinition = class extends _definition.default {
      static fromNothing() {
        let parts;
        const content = verticalBar, ruleName = _ruleNames.DEFINITION_RULE_NAME, definitionRuleNamePart = _ruleName.default.fromRuleName(ruleName), verticalBarStringLiteralPart = _stringLiteral.default.fromContent(content);
        parts = [
          verticalBarStringLiteralPart,
          definitionRuleNamePart
        ];
        const sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), zeroOrMoreSequenceOfPartsPart = _zeroOrMoreParts.default.fromPart(sequenceOfPartsPart);
        parts = [
          definitionRuleNamePart,
          zeroOrMoreSequenceOfPartsPart
        ];
        const precedence = null, definitionsDefinition = new DefinitionsDefinition(parts, precedence);
        return definitionsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/definitions.js
  var require_definitions3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionsBNFRule = class extends _rule.default {
      static fromNothing() {
        const definitionsDefinition = _definitions.default.fromNothing(), name = _ruleNames.DEFINITIONS_RULE_NAME, opacity = null, definitions = [
          definitionsDefinition
        ], definitionsRule = new DefinitionsBNFRule(name, opacity, definitions);
        return definitionsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/terminalPart.js
  var require_terminalPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalPartBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.TERMINAL_PART_RULE_NAME;
        ruleName = _ruleNames.EPSILON_RULE_NAME;
        const epsilonRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.WILDCARD_RULE_NAME;
        const wildcardRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.END_OF_LINE_RULE_NAME;
        const endOfLineRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.STRING_LITERAL_RULE_NAME;
        const stringLiteralRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NO_WHITESPACE_PART_RULE_NAME;
        const noWhitespacePartRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.REGULAR_EXPRESSION_RULE_NAME;
        const regularExpressionRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.START_OF_CONTENT_PART_RULE_NAME;
        const startOfContentPartRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME;
        const significantTokenTypeRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), opacity = null, definitions = [
          significantTokenTypeRuleNameDefinition,
          regularExpressionRuleNameDefinition,
          stringLiteralRuleNameDefinition,
          endOfLineRuleNameDefinition,
          wildcardRuleNameDefinition,
          epsilonRuleNameDefinition,
          noWhitespacePartRuleNameDefinition,
          startOfContentPartRuleNameDefinition
        ], terminalPartRule = new TerminalPartBNFRule(name, opacity, definitions);
        return terminalPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/choiceOfParts.js
  var require_choiceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {verticalBar, openBracket, closeBracket} = _occamlexers.specialSymbols;
    var ChoiceOfPartsDefinition = class extends _definition.default {
      static fromNothing() {
        let parts;
        const ruleName = _ruleNames.PART_CHOICE_RULE_NAME, verticalBarStringLiteralContent = verticalBar, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, partChoiceRuleNamePart = _ruleName.default.fromRuleName(ruleName), verticalBarStringLiteralPart = _stringLiteral.default.fromContent(verticalBarStringLiteralContent), openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent);
        parts = [
          verticalBarStringLiteralPart,
          partChoiceRuleNamePart
        ];
        const sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), oneOrMoreSequenceOfPartsPart = _oneOrMoreParts.default.fromPart(sequenceOfPartsPart);
        parts = [
          openBracketStringLiteralPart,
          partChoiceRuleNamePart,
          oneOrMoreSequenceOfPartsPart,
          closeBracketStringLiteralPart
        ];
        const precedence = null, choiceOfPartsDefinition = new ChoiceOfPartsDefinition(parts, precedence);
        return choiceOfPartsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/choiceOfParts.js
  var require_choiceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.CHOICE_OF_PARTS_RULE_NAME, choiceOfPartsDefinition = _choiceOfParts.default.fromNothing(), opacity = null, definitions = [
          choiceOfPartsDefinition
        ], choiceOfPartsRule = new ChoiceOfPartsBNFRule(name, opacity, definitions);
        return choiceOfPartsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/significantTokenType.js
  var require_significantTokenType3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantTokenTypeDefinition = class extends _definition.default {
      static fromSignificantTokenType(significantTokenType) {
        const significantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), parts = [
          significantTokenTypePart
        ], precedence = null, significantTokenTypeDefinition = new SignificantTokenTypeDefinition(parts, precedence);
        return significantTokenTypeDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/stringLiteral.js
  var require_stringLiteral5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {stringLiteralType} = _occamlexers.types;
    var StringLiteralBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = stringLiteralType, stringLiteralSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.STRING_LITERAL_RULE_NAME, opacity = null, definitions = [
          stringLiteralSignificantTokenTypeDefinition
        ], stringLiteralRule = new StringLiteralBNFRule(name, opacity, definitions);
        return stringLiteralRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal/ruleName.js
  var require_ruleName6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameNonTerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameNonTerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.RULE_NAME_RULE_NAME;
        const ruleNameRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME;
        const callAheadModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalCallAheadRuleNamePartPart = _optionalPart.default.fromPart(callAheadModifierRuleNamePart), parts = [
          ruleNameRuleNamePart,
          optionalCallAheadRuleNamePartPart
        ], precedence = null, ruleNameNonTerminalPartRuleDefinition = new RuleNameNonTerminalPartRuleDefinition(parts, precedence);
        return ruleNameNonTerminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/nonTerminalPart.js
  var require_nonTerminalPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleName1 = /* @__PURE__ */ _interop_require_default(require_ruleName6());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalPartBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.NON_TERMINAL_PART_RULE_NAME;
        ruleName = _ruleNames.CHOICE_OF_PARTS_RULE_NAME;
        const choiceOfPartsRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.SEQUENCE_OF_PARTS_RULE_NAME;
        const sequenceOfPartsRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), ruleNameNonTerminalPartRuleDefinition = _ruleName1.default.fromNothing(), opacity = null, definitions = [
          choiceOfPartsRuleNameDefinition,
          sequenceOfPartsRuleNameDefinition,
          ruleNameNonTerminalPartRuleDefinition
        ], nonTerminalPartRule = new NonTerminalPartBNFRule(name, opacity, definitions);
        return nonTerminalPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/sequenceOfParts.js
  var require_sequenceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {openBracket, closeBracket} = _occamlexers.specialSymbols;
    var SequenceOfPartsDefinition = class extends _definition.default {
      static fromNothing() {
        const ruleName = _ruleNames.PART_RULE_NAME, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, partRuleNamePart = _ruleName.default.fromRuleName(ruleName), openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), oneOrMorePartRuleNamePartsPart = _oneOrMoreParts.default.fromPart(partRuleNamePart), parts = [
          openBracketStringLiteralPart,
          partRuleNamePart,
          oneOrMorePartRuleNamePartsPart,
          closeBracketStringLiteralPart
        ], precedence = null, sequenceOfPartsDefinition = new SequenceOfPartsDefinition(parts, precedence);
        return sequenceOfPartsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/sequenceOfParts.js
  var require_sequenceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.SEQUENCE_OF_PARTS_RULE_NAME, sequenceOfPartsDefinition = _sequenceOfParts.default.fromNothing(), opacity = null, definitions = [
          sequenceOfPartsDefinition
        ], sequenceOfPartsRule = new SequenceOfPartsBNFRule(name, opacity, definitions);
        return sequenceOfPartsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/opacityModifierRule.js
  var require_opacityModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierRuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque, semiOpaque} = _occamlexers.specialSymbols;
    var OpacityModifierRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let content;
        content = opaque;
        const opaqueStringLiteralPart = _stringLiteral.default.fromContent(content);
        content = semiOpaque;
        const semiOpaqueStringLiteralPart = _stringLiteral.default.fromContent(content);
        const opaqueStringLiteralPartChoice = _partChoice.default.fromPart(opaqueStringLiteralPart), semiOpaqueStringLiteralPartChoice = _partChoice.default.fromPart(semiOpaqueStringLiteralPart), partChoices = [
          opaqueStringLiteralPartChoice,
          semiOpaqueStringLiteralPartChoice
        ], choiceOfOpaqueStringLiteralAndSemiOpaqueStringLiteralPartsPart = _choiceOfParts.default.fromPartChoices(partChoices), noWhitespacePart = _noWhitespace.default.fromNothing(), parts = [
          noWhitespacePart,
          choiceOfOpaqueStringLiteralAndSemiOpaqueStringLiteralPartsPart
        ], precedence = null, opacityModifierRuleDefinition = new OpacityModifierRuleDefinition(parts, precedence);
        return opacityModifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/opacityModifier.js
  var require_opacityModifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _opacityModifierRule = /* @__PURE__ */ _interop_require_default(require_opacityModifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OpacityModifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.OPACITY_MODIFIER_RULE_NAME, opacityModifierRuleDefinition = _opacityModifierRule.default.fromNothing(), opacity = null, definitions = [
          opacityModifierRuleDefinition
        ], opacityModifierRule = new OpacityModifierBNFRule(name, opacity, definitions);
        return opacityModifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/noWhitespacePart.js
  var require_noWhitespacePart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespacePartDefinition = class extends _definition.default {
      static fromNothing() {
        const content = noWhitespace, stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, noWhitespacePartDefinition = new NoWhitespacePartDefinition(parts, precedence);
        return noWhitespacePartDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/noWhitespacePart.js
  var require_noWhitespacePart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespacePartBNFRule = class extends _rule.default {
      static fromNothing() {
        const noWhitespacePartDefinition = _noWhitespacePart.default.fromNothing(), name = _ruleNames.NO_WHITESPACE_PART_RULE_NAME, opacity = null, definitions = [
          noWhitespacePartDefinition
        ], noWhitespacePartRule = new NoWhitespacePartBNFRule(name, opacity, definitions);
        return noWhitespacePartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/callAheadModifierRule.js
  var require_callAheadModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierRuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {ellipsis} = _occamlexers.specialSymbols;
    var CallAheadModifierRuleDefinition = class extends _definition.default {
      static fromNothing() {
        const content = ellipsis, noWhitespacePart = _noWhitespace.default.fromNothing(), stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          noWhitespacePart,
          stringLiteralPart
        ], precedence = null, callAheadModifierRuleDefinition = new CallAheadModifierRuleDefinition(parts, precedence);
        return callAheadModifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/callAheadModifier.js
  var require_callAheadModifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _callAheadModifierRule = /* @__PURE__ */ _interop_require_default(require_callAheadModifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CallAheadModifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME, callAheadModifierRuleDefinition = _callAheadModifierRule.default.fromNothing(), opacity = null, definitions = [
          callAheadModifierRuleDefinition
        ], callAheadModifierRule = new CallAheadModifierBNFRule(name, opacity, definitions);
        return callAheadModifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/regularExpression.js
  var require_regularExpression4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {regularExpressionType} = _occamlexers.types;
    var RegularExpressionBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = regularExpressionType, regularExpressionSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.REGULAR_EXPRESSION_RULE_NAME, opacity = null, definitions = [
          regularExpressionSignificantTokenTypeDefinition
        ], regularExpressionRule = new RegularExpressionBNFRule(name, opacity, definitions);
        return regularExpressionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/quantifierRule.js
  var require_quantifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierRuleDefinition = class extends _definition.default {
      static fromSpecialSymbol(specialSymbol) {
        const content = specialSymbol, noWhitespacePart = _noWhitespace.default.fromNothing(), stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          noWhitespacePart,
          stringLiteralPart
        ], precedence = null, quantifierRuleDefinition = new QuantifierRuleDefinition(parts, precedence);
        return quantifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/optionalQuantifier.js
  var require_optionalQuantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OptionalQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {questionMark} = _occamlexers.specialSymbols;
    var OptionalQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME, specialSymbol = questionMark, optionalQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          optionalQuantifierRuleDefinition
        ], optionalQuantifierRule = new OptionalQuantifierBNFRule(name, opacity, definitions);
        return optionalQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/startOfContentPart.js
  var require_startOfContentPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentPartDefinition = class extends _definition.default {
      static fromNothing() {
        const content = startOfContent, stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, startOfContentPartDefinition = new StartOfContentPartDefinition(parts, precedence);
        return startOfContentPartDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/startOfContentPart.js
  var require_startOfContentPart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentPartBNFRule = class extends _rule.default {
      static fromNothing() {
        const startOfContentPartDefinition = _startOfContentPart.default.fromNothing(), name = _ruleNames.START_OF_CONTENT_PART_RULE_NAME, opacity = null, definitions = [
          startOfContentPartDefinition
        ], startOfContentPartRule = new StartOfContentPartBNFRule(name, opacity, definitions);
        return startOfContentPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/oneOrMoreQuantifier.js
  var require_oneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OneOrMoreQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {plus} = _occamlexers.specialSymbols;
    var OneOrMoreQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME, specialSymbol = plus, oneOrMoreQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          oneOrMoreQuantifierRuleDefinition
        ], oneOrMoreQuantifierRule = new OneOrMoreQuantifierBNFRule(name, opacity, definitions);
        return oneOrMoreQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/zeroOrMoreQuantifier.js
  var require_zeroOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZeroOrMoreQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asterisk} = _occamlexers.specialSymbols;
    var ZeroOrMoreQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME, specialSymbol = asterisk, zeroOrMoreQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          zeroOrMoreQuantifierRuleDefinition
        ], zeroOrMoreQuantifierRule = new ZeroOrMoreQuantifierBNFRule(name, opacity, definitions);
        return zeroOrMoreQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/significantTokenType.js
  var require_significantTokenType4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {typeType} = _occamlexers.types;
    var SignificantTokenTypeBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = typeType, typeSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME, opacity = null, definitions = [
          typeSignificantTokenTypeDefinition
        ], significantTokenTypeRule = new SignificantTokenTypeBNFRule(name, opacity, definitions);
        return significantTokenTypeRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/rules.js
  var require_rules2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get ruleMapFromRules() {
        return ruleMapFromRules;
      },
      get rulesAsString() {
        return rulesAsString;
      },
      get rulesFromStartRuleAndRuleMap() {
        return rulesFromStartRuleAndRuleMap;
      },
      get startRuleFromRules() {
        return startRuleFromRules;
      },
      get startRuleFromRulesAndStartRuleName() {
        return startRuleFromRulesAndStartRuleName;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {first: first2, prune} = _necessary.arrayUtilities;
    function rulesAsString(rules, multiLine) {
      const maximumRuleNameLength = rules.reduce((maximumRuleNameLength2, rule) => {
        const ruleName = rule.getName(), opacity = rule.getOpacity();
        let ruleNameLength = ruleName.length;
        if (opacity !== null) {
          const opacityLength = opacity.length;
          ruleNameLength += opacityLength;
        }
        maximumRuleNameLength2 = Math.max(maximumRuleNameLength2, ruleNameLength);
        return maximumRuleNameLength2;
      }, 0), rulesString = rules.reduce((rulesString2, rule) => {
        const ruleString = rule.asString(maximumRuleNameLength, multiLine);
        rulesString2 += ruleString;
        return rulesString2;
      }, _constants.EMPTY_STRING).replace(/^\n\n/, _constants.EMPTY_STRING);
      return rulesString;
    }
    function ruleMapFromRules(rules) {
      const ruleMap = {};
      rules.forEach((rule) => {
        const ruleName = rule.getName();
        ruleMap[ruleName] = rule;
      });
      return ruleMap;
    }
    function startRuleFromRules(rules) {
      const firstRule = first2(rules), startRule = firstRule;
      return startRule;
    }
    function rulesFromStartRuleAndRuleMap(startRule, ruleMap) {
      const rules = Object.values(ruleMap), startRuleName = startRule.getName();
      startRule = prune(rules, (rule) => {
        const ruleName = rule.getName();
        if (ruleName !== startRuleName) {
          return true;
        }
      });
      rules.unshift(startRule);
      return rules;
    }
    function startRuleFromRulesAndStartRuleName(rules, startRuleName) {
      let startRule = rules.find((rule) => {
        const ruleName = rule.getName();
        if (ruleName === startRuleName) {
          return true;
        }
      }) || null;
      if (startRule === null) {
        startRule = startRuleFromRules(rules);
      }
      return startRule;
    }
    var _default = {
      rulesAsString,
      ruleMapFromRules,
      startRuleFromRules,
      rulesFromStartRuleAndRuleMap,
      startRuleFromRulesAndStartRuleName
    };
  });

  // node_modules/occam-parsers/lib/bnf/parser.js
  var require_parser2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFParser;
      }
    });
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser());
    var _name = /* @__PURE__ */ _interop_require_default(require_name4());
    var _part = /* @__PURE__ */ _interop_require_default(require_part2());
    var _rule1 = /* @__PURE__ */ _interop_require_default(require_rule5());
    var _error = /* @__PURE__ */ _interop_require_default(require_error3());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon4());
    var _document = /* @__PURE__ */ _interop_require_default(require_document4());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName4());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard3());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine8());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice4());
    var _quantifier = /* @__PURE__ */ _interop_require_default(require_quantifier2());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition4());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence3());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions3());
    var _terminalPart = /* @__PURE__ */ _interop_require_default(require_terminalPart2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts4());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral5());
    var _nonTerminalPart = /* @__PURE__ */ _interop_require_default(require_nonTerminalPart2());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts4());
    var _opacityModifier = /* @__PURE__ */ _interop_require_default(require_opacityModifier2());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart3());
    var _callAheadModifier = /* @__PURE__ */ _interop_require_default(require_callAheadModifier2());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression4());
    var _optionalQuantifier = /* @__PURE__ */ _interop_require_default(require_optionalQuantifier2());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart3());
    var _oneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_oneOrMoreQuantifier());
    var _zeroOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreQuantifier());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType4());
    var _rules = require_rules2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BNFParser = class {
      constructor(startRule, ruleMap) {
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      getStartRule() {
        return this.startRule;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      rulesFromTokens(tokens) {
        let rules;
        const node = this.parse(tokens);
        if (node === null) {
          throw new Error(`There is no node.`);
        }
        rules = node.generateRules(_rule.default);
        const rulesLength = rules.length;
        if (rulesLength === 0) {
          throw new Error(`There are no rules.`);
        }
        return rules;
      }
      static fromNothing() {
        const nameBNFRule = _name.default.fromNothing(), partBNFRule = _part.default.fromNothing(), ruleBNFRule = _rule1.default.fromNothing(), errorBNFRule = _error.default.fromNothing(), epsilonBNFRule = _epsilon.default.fromNothing(), documentBNFRule = _document.default.fromNothing(), ruleNameBNFRule = _ruleName.default.fromNothing(), wildcardBNFRule = _wildcard.default.fromNothing(), endOfLineBNFRule = _endOfLine.default.fromNothing(), partChoiceBNFRule = _partChoice.default.fromNothing(), quantifierBNFRule = _quantifier.default.fromNothing(), definitionBNFRule = _definition.default.fromNothing(), precedentsBNFRule = _precedence.default.fromNothing(), definitionsBNFRule = _definitions.default.fromNothing(), terminalPartBNFRule = _terminalPart.default.fromNothing(), choiceOfPartsBNFRule = _choiceOfParts.default.fromNothing(), stringLiteralBNFRule = _stringLiteral.default.fromNothing(), nonTerminalPartBNFRule = _nonTerminalPart.default.fromNothing(), sequenceOfPartsBNFRule = _sequenceOfParts.default.fromNothing(), opacityModifierBNFRule = _opacityModifier.default.fromNothing(), noWhitespacePartBNFRule = _noWhitespacePart.default.fromNothing(), regularExpressionBNFRule = _regularExpression.default.fromNothing(), callAheadModifierBNFRule = _callAheadModifier.default.fromNothing(), optionalQuantifierBNFRule = _optionalQuantifier.default.fromNothing(), startOfContentPartBNFRule = _startOfContentPart.default.fromNothing(), oneOrMoreQuantifierBNFRule = _oneOrMoreQuantifier.default.fromNothing(), zeroOrMoreQuantifierBNFRule = _zeroOrMoreQuantifier.default.fromNothing(), significantTokenTypeBNFRule = _significantTokenType.default.fromNothing(), rules = [
          documentBNFRule,
          ruleBNFRule,
          nameBNFRule,
          definitionsBNFRule,
          definitionBNFRule,
          partBNFRule,
          nonTerminalPartBNFRule,
          terminalPartBNFRule,
          startOfContentPartBNFRule,
          noWhitespacePartBNFRule,
          sequenceOfPartsBNFRule,
          choiceOfPartsBNFRule,
          partChoiceBNFRule,
          ruleNameBNFRule,
          significantTokenTypeBNFRule,
          regularExpressionBNFRule,
          stringLiteralBNFRule,
          precedentsBNFRule,
          endOfLineBNFRule,
          wildcardBNFRule,
          epsilonBNFRule,
          quantifierBNFRule,
          opacityModifierBNFRule,
          callAheadModifierBNFRule,
          optionalQuantifierBNFRule,
          oneOrMoreQuantifierBNFRule,
          zeroOrMoreQuantifierBNFRule,
          errorBNFRule
        ], startRule = (0, _rules.startRuleFromRules)(rules), ruleMap = (0, _rules.ruleMapFromRules)(rules), bnfParser = new _BNFParser(startRule, ruleMap);
        return bnfParser;
      }
    };
    var BNFParser = _BNFParser;
    __publicField(BNFParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
    __publicField(BNFParser, "defaultNonTerminalNode", null);
    __publicField(BNFParser, "bnf", _bnf.default);
    Object.assign(BNFParser.prototype, _parser.default);
  });

  // node_modules/occam-parsers/lib/basic/bnf.js
  var require_bnf3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    expressions  ::=  expression+ ;

    expression   ::=  term... "." ;
    
    term         ::=  term_ term~* ;
    
    operator     ::=  "+"
    
                   |  "-"
    
                   |  "*"
    
                   ;
    
    number       ::=  /\\d+/ ;
    
    term_        ::=  "(" term ")"
    
                   |  number
    
                   ;
    
    term~term    ::=  operator term ;
    
    term~        ::=  term~term ;

`;
    var _default = bnf;
  });

  // node_modules/occam-parsers/lib/utilities/parser.js
  var require_parser3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get parserFromRules() {
        return parserFromRules;
      },
      get parserFromRulesAndStartRuleName() {
        return parserFromRulesAndStartRuleName;
      },
      get rulesFromBNF() {
        return rulesFromBNF;
      }
    });
    var _occamlexers = require_lib3();
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser2());
    var _rules = require_rules2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var bnfLexer = _occamlexers.BNFLexer.fromNothing();
    var bnfParser = _parser.default.fromNothing();
    function rulesFromBNF(bnf) {
      const tokens = bnfLexer.tokensFromBNF(bnf), rules = bnfParser.rulesFromTokens(tokens);
      return rules;
    }
    function parserFromRules(Class, rules) {
      const startRule = (0, _rules.startRuleFromRules)(rules), ruleMap = (0, _rules.ruleMapFromRules)(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
    function parserFromRulesAndStartRuleName(Class, rules, startRuleName) {
      const startRule = (0, _rules.startRuleFromRulesAndStartRuleName)(rules, startRuleName), ruleMap = (0, _rules.ruleMapFromRules)(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
    var _default = {
      rulesFromBNF,
      parserFromRules,
      parserFromRulesAndStartRuleName
    };
  });

  // node_modules/occam-parsers/lib/common/parser.js
  var require_parser4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CommonParser;
      }
    });
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _parser1 = require_parser3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CommonParser = class {
      constructor(startRule, ruleMap) {
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      getStartRule() {
        return this.startRule;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      static fromNothing(Class) {
        const {bnf} = Class, rules = (0, _parser1.rulesFromBNF)(bnf), parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
      static fromBNF(Class, bnf) {
        const rules = (0, _parser1.rulesFromBNF)(bnf), parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
      static fromRules(Class, rules) {
        const parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
    };
    __publicField(CommonParser, "NonTerminalNodeMap", {});
    __publicField(CommonParser, "defaultNonTerminalNode", _nonTerminal.default);
    Object.assign(CommonParser.prototype, _parser.default);
  });

  // node_modules/occam-parsers/lib/basic/parser.js
  var require_parser5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BasicParser;
      }
    });
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf3());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BasicParser = class extends _parser.default {
      static fromNothing() {
        return _parser.default.fromNothing(_BasicParser);
      }
      static fromBNF(bnf) {
        return _parser.default.fromBNF(_BasicParser, bnf);
      }
      static fromRules(rules) {
        return _parser.default.fromRules(_BasicParser, rules);
      }
    };
    var BasicParser = _BasicParser;
    __publicField(BasicParser, "bnf", _bnf.default);
  });

  // node_modules/occam-parsers/lib/parts.js
  var require_parts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine6());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = {
      EpsilonPart: _epsilon.default,
      RuleNamePart: _ruleName.default,
      WildcardPart: _wildcard.default,
      EndOfLinePart: _endOfLine.default,
      OptionalPartPart: _optionalPart.default,
      ChoiceOfPartsPart: _choiceOfParts.default,
      StringLiteralPart: _stringLiteral.default,
      OneOrMorePartsPart: _oneOrMoreParts.default,
      SequenceOfPartsPart: _sequenceOfParts.default,
      ZeroOrMorePartsPart: _zeroOrMoreParts.default,
      RegularExpressionPart: _regularExpression.default,
      SignificantTokenTypePart: _significantTokenType.default
    };
  });

  // node_modules/occam-parsers/lib/index.js
  var require_lib4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BNFParser() {
        return _parser.default;
      },
      get BasicParser() {
        return _parser1.default;
      },
      get CommonParser() {
        return _parser2.default;
      },
      get Definition() {
        return _definition.default;
      },
      get EpsilonNode() {
        return _epsilon.default;
      },
      get NonTerminalNode() {
        return _nonTerminal.default;
      },
      get PartChoice() {
        return _partChoice.default;
      },
      get Parts() {
        return _parts.default;
      },
      get Rule() {
        return _rule.default;
      },
      get TerminalNode() {
        return _terminal.default;
      },
      get nodeMixins() {
        return _node.default;
      },
      get parserUtilities() {
        return _parser3.default;
      },
      get partTypes() {
        return _partTypes.default;
      },
      get rulesUtilities() {
        return _rules.default;
      }
    });
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser2());
    var _parser1 = /* @__PURE__ */ _interop_require_default(require_parser5());
    var _parser2 = /* @__PURE__ */ _interop_require_default(require_parser4());
    var _node = /* @__PURE__ */ _interop_require_default(require_node());
    var _rules = /* @__PURE__ */ _interop_require_default(require_rules2());
    var _parser3 = /* @__PURE__ */ _interop_require_default(require_parser3());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _parts = /* @__PURE__ */ _interop_require_default(require_parts());
    var _partTypes = /* @__PURE__ */ _interop_require_default(require_partTypes());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon());
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/bnf.js
  var require_bnf4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    stylesheet                 ::= ( media | ruleSet | keyframes | declaration | error )+ ;


    media                      ::= "@media" mediaQueries "{" ( ruleSet | declaration )* "}" ;
                                     
                                                              
    ruleSet                    ::=  selectors "{" declaration* "}" ;
    
    
    keyframes                  ::= "@keyframes" [identifier] "{" keyframe+ "}" ;
                                     
                                                              
    declaration                ::=  propertyName ":" propertyValues important? ";" ;


    error.                     ::=  . ;


    propertyValues             ::=  propertyValue ( "," propertyValue )* ;


    mediaQueries               ::=  mediaQuery ( ( "," | "or" ) mediaQuery )* ;
                                                              
                                                              
    selectors                  ::=  selector ( "," selector )* ;


    keyframe                   ::=  [percentage] "{" declaration+ "}" ;
    
    
    mediaQuery                 ::=  ( "not"? mediaType "and" )? mediaFeatures 
    
                                 |  "not"? mediaType
                                 
                                 ;


    mediaType                  ::=  "all" | "print" | "screen" | "speech" ;
                                                              
                                                              
    mediaFeatures              ::=  ( 
    
                                      mediaFeature 
                                      
                                      | 
                                      
                                      ( "(" "not" mediaFeature ")" ) 
                                      
                                    ) 
    
                                    ( 
                                    
                                      "and" 
                                    
                                      ( 
                                      
                                        mediaFeature 
                                        
                                        | 
                                        
                                        ( "(" "not" mediaFeature ")" ) 
                                        
                                      ) 
                                      
                                    )* 
                                    
                                 ;


    mediaFeature               ::=  "(" [identifier] ( ":" propertyValue )? ")" ;


    propertyValue              ::=  term ( ","? term )* ;


    propertyName               ::=  [identifier] ;


    important                  ::=  "!important" ;


    selector                   ::=  ( class | pseudoClass | pseudoElement | attribute )+ ;


    class                      ::=  "."<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    pseudoClass                ::=  ":"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    pseudoElement              ::=  "::"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    parenthesisedSelector      ::=  <NO_WHITESPACE>"(" selector <NO_WHITESPACE>")" ;


    attribute                  ::=  "["

                                       [identifier]

                                       (

                                         ( "=" | "~=" | "|=" )

                                         ( [identifier] | [string-literal] )

                                       )?

                                    "]"

                                 ;


    term                       ::=  [plus-or-minus]?
                                                       
                                    (
                                                     
                                      ( [percentage] | [frequency] | [fraction] | [length] | [angle] | [rems] | [ems] | [time] | [number] )
                                                     
                                      |
                                                     
                                      uri
                                                     
                                      |
                                                     
                                      function
                                                     
                                      |
                                                     
                                      [string-literal]+
                                                     
                                      |
                                                     
                                      [identifier]
                                                     
                                      |
                                                     
                                      [colour]
                                                     
                                    )
                                                       
                                 ;


    uri                        ::=  "url"<NO_WHITESPACE>"(" [string-literal] ")" ;


    function                   ::=  [identifier]<NO_WHITESPACE>"(" propertyValue ")" ;

`;
    var _default = bnf;
  });

  // node_modules/with-style/lib/css/parser.js
  var require_parser6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CSSParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CSSParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CSSParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CSSParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CSSParser, rules);
      }
    };
    var CSSParser = _CSSParser;
    __publicField(CSSParser, "bnf", _bnf.default);
  });

  // node_modules/occam-query/lib/ruleNames.js
  var require_ruleNames2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get END_INDEX_RULE_NAME() {
        return END_INDEX_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get INDEX_RULE_NAME() {
        return INDEX_RULE_NAME;
      },
      get INFINITE_DESCENT_RULE_NAME() {
        return INFINITE_DESCENT_RULE_NAME;
      },
      get RULE_NAME_RULE_NAME() {
        return RULE_NAME_RULE_NAME;
      },
      get SPREAD_RULE_NAME() {
        return SPREAD_RULE_NAME;
      },
      get START_INDEX_RULE_NAME() {
        return START_INDEX_RULE_NAME;
      },
      get SUB_EXPRESSION_RULE_NAME() {
        return SUB_EXPRESSION_RULE_NAME;
      },
      get TOKEN_TYPE_RULE_NAME() {
        return TOKEN_TYPE_RULE_NAME;
      },
      get UNIQUE_RULE_NAME() {
        return UNIQUE_RULE_NAME;
      }
    });
    var ERROR_RULE_NAME = "error";
    var INDEX_RULE_NAME = "index";
    var UNIQUE_RULE_NAME = "unique";
    var SPREAD_RULE_NAME = "spread";
    var END_INDEX_RULE_NAME = "endIndex";
    var RULE_NAME_RULE_NAME = "ruleName";
    var TOKEN_TYPE_RULE_NAME = "tokenType";
    var START_INDEX_RULE_NAME = "startIndex";
    var SUB_EXPRESSION_RULE_NAME = "subExpression";
    var INFINITE_DESCENT_RULE_NAME = "infiniteDescent";
  });

  // node_modules/occam-query/lib/utilities/node.js
  var require_node3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get endIndexFromSpreadNode() {
        return endIndexFromSpreadNode;
      },
      get errorNodesFromExpressionNode() {
        return errorNodesFromExpressionNode;
      },
      get indexFromIndexNode() {
        return indexFromIndexNode;
      },
      get indexFromSpreadNode() {
        return indexFromSpreadNode;
      },
      get infiniteDescentFromPathNode() {
        return infiniteDescentFromPathNode;
      },
      get pathNodeFromExpressionNode() {
        return pathNodeFromExpressionNode;
      },
      get pathNodeFromSubExpressionNode() {
        return pathNodeFromSubExpressionNode;
      },
      get ruleNamesFromPathNode() {
        return ruleNamesFromPathNode;
      },
      get selectorNodesFromPathNode() {
        return selectorNodesFromPathNode;
      },
      get spreadNodeFromExpressionNode() {
        return spreadNodeFromExpressionNode;
      },
      get spreadNodeFromSubExpressionNode() {
        return spreadNodeFromSubExpressionNode;
      },
      get startIndexFromSpreadNode() {
        return startIndexFromSpreadNode;
      },
      get subExpressionNodeFromExpressionNode() {
        return subExpressionNodeFromExpressionNode;
      },
      get subExpressionNodeFromSubExpressionNode() {
        return subExpressionNodeFromSubExpressionNode;
      },
      get tokenTypesFromPathNode() {
        return tokenTypesFromPathNode;
      },
      get uniqueFromSpreadNode() {
        return uniqueFromSpreadNode;
      }
    });
    var _ruleNames = require_ruleNames2();
    function indexFromIndexNode(indexNode) {
      const nonTerminalNode = indexNode, index = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const terminalNode = firstChildNode, content = terminalNode.getContent(), index2 = Number(content);
        return index2;
      });
      return index;
    }
    function ruleNamesFromPathNode(pathNode) {
      const selectorNodes = selectorNodesFromPathNode(pathNode), ruleNameNodes = selectorNodes.reduce((ruleNameNodes2, selectorNode) => {
        const nonTerminalNode = selectorNode, ruleNameNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          let ruleNameNode2 = null;
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameRuleNameRuleName = ruleName === _ruleNames.RULE_NAME_RULE_NAME;
          if (ruleNameRuleNameRuleName) {
            ruleNameNode2 = nonTerminalNode2;
          }
          return ruleNameNode2;
        });
        if (ruleNameNode !== null) {
          ruleNameNodes2.push(ruleNameNode);
        }
        return ruleNameNodes2;
      }, []), ruleNames = ruleNameNodes.map((ruleNameNode) => {
        const nonTerminalNode = ruleNameNode, ruleName = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          const terminalNode = firstChildNode, content = terminalNode.getContent(), ruleName2 = content;
          return ruleName2;
        });
        return ruleName;
      });
      return ruleNames;
    }
    function tokenTypesFromPathNode(pathNode) {
      const selectorNodes = selectorNodesFromPathNode(pathNode), tokenTypeNodes = selectorNodes.reduce((tokenTypeNodes2, selectorNode) => {
        const nonTerminalNode = selectorNode, tokenTypeNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          let tokenTypeNode2 = null;
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameTokenTypeRuleName = ruleName === _ruleNames.TOKEN_TYPE_RULE_NAME;
          if (ruleNameTokenTypeRuleName) {
            tokenTypeNode2 = nonTerminalNode2;
          }
          return tokenTypeNode2;
        });
        if (tokenTypeNode !== null) {
          tokenTypeNodes2.push(tokenTypeNode);
        }
        return tokenTypeNodes2;
      }, []), tokenTypes = tokenTypeNodes.map((tokenTypeNode) => {
        const nonTerminalNode = tokenTypeNode, tokenType = fromThirdChildNode(nonTerminalNode, (thirdChildNode) => {
          const terminalNode = thirdChildNode, content = terminalNode.getContent(), tokenType2 = content;
          return tokenType2;
        });
        return tokenType;
      });
      return tokenTypes;
    }
    function selectorNodesFromPathNode(pathNode) {
      let nonTerminalNode;
      nonTerminalNode = pathNode;
      const selectorsNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
        const selectorsNode2 = lastChildNode;
        return selectorsNode2;
      });
      nonTerminalNode = selectorsNode;
      const selectorNodes = nonTerminalNode.filterChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          return true;
        }
      });
      return selectorNodes;
    }
    function infiniteDescentFromPathNode(pathNode) {
      const nonTerminalNode = pathNode, infiniteDescent = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
        const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameInfiniteDescentRuleName = ruleName === _ruleNames.INFINITE_DESCENT_RULE_NAME, infiniteDescent2 = ruleNameInfiniteDescentRuleName;
        return infiniteDescent2;
      }) || false;
      return infiniteDescent;
    }
    function uniqueFromSpreadNode(spreadNode) {
      const nonTerminalNode = spreadNode, unique = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        let unique2 = false;
        const firstChildNodeNonTerminalNode = firstChildNode.isNonTerminalNode();
        if (firstChildNodeNonTerminalNode) {
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameUniqueRuleName = ruleName === _ruleNames.UNIQUE_RULE_NAME;
          if (ruleNameUniqueRuleName) {
            unique2 = true;
          }
        }
        return unique2;
      });
      return unique;
    }
    function indexFromSpreadNode(spreadNode) {
      let index = null;
      const nonTerminalNode = spreadNode, indexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameIndexRuleName = ruleName === _ruleNames.INDEX_RULE_NAME;
          if (ruleNameIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (indexNode !== null) {
        index = indexFromIndexNode(indexNode);
      }
      return index;
    }
    function endIndexFromSpreadNode(spreadNode) {
      let endIndex = Infinity;
      const nonTerminalNode = spreadNode, endIndexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameEndIndexRuleName = ruleName === _ruleNames.END_INDEX_RULE_NAME;
          if (ruleNameEndIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (endIndexNode !== null) {
        endIndex = indexFromIndexNode(endIndexNode);
      }
      return endIndex;
    }
    function startIndexFromSpreadNode(spreadNode) {
      let startIndex = 0;
      const nonTerminalNode = spreadNode, startIndexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameStartIndexRuleName = ruleName === _ruleNames.START_INDEX_RULE_NAME;
          if (ruleNameStartIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (startIndexNode !== null) {
        startIndex = indexFromIndexNode(startIndexNode);
      }
      return startIndex;
    }
    function pathNodeFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, pathNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const pathNode2 = firstChildNode;
        return pathNode2;
      });
      return pathNode;
    }
    function spreadNodeFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, spreadNode = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
        let spreadNode2 = null;
        const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSpreadRuleName = ruleName === _ruleNames.SPREAD_RULE_NAME;
        if (ruleNameSpreadRuleName) {
          spreadNode2 = secondChildNode;
        }
        return spreadNode2;
      }) || null;
      return spreadNode;
    }
    function errorNodesFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, errorNodes = nonTerminalNode.reduceChildNode((errorNodes2, childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameErrorRuleName = ruleName === _ruleNames.ERROR_RULE_NAME;
          if (ruleNameErrorRuleName) {
            const errorNode = nonTerminalNode2;
            errorNodes2.push(errorNode);
          }
        }
        return errorNodes2;
      }, []);
      return errorNodes;
    }
    function subExpressionNodeFromExpressionNode(expressionNode) {
      let subExpressionNode = null;
      const nonTerminalNode = expressionNode, multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        subExpressionNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
          let subExpressionNode2 = null;
          const nonTerminalNode2 = lastChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSubExpressionRuleName = ruleName === _ruleNames.SUB_EXPRESSION_RULE_NAME;
          if (ruleNameSubExpressionRuleName) {
            subExpressionNode2 = lastChildNode;
          }
          return subExpressionNode2;
        });
      }
      return subExpressionNode;
    }
    function pathNodeFromSubExpressionNode(subExpressionNode) {
      const nonTerminalNode = subExpressionNode, pathNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const pathNode2 = firstChildNode;
        return pathNode2;
      });
      return pathNode;
    }
    function spreadNodeFromSubExpressionNode(subExpressionNode) {
      let spreadNode = null;
      const nonTerminalNode = subExpressionNode, multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        spreadNode = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
          let spreadNode2 = null;
          const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSpreadRuleName = ruleName === _ruleNames.SPREAD_RULE_NAME;
          if (ruleNameSpreadRuleName) {
            spreadNode2 = secondChildNode;
          }
          return spreadNode2;
        }) || null;
      }
      return spreadNode;
    }
    function subExpressionNodeFromSubExpressionNode(subExpressionNode) {
      const nonTerminalNode = subExpressionNode;
      subExpressionNode = null;
      const multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        subExpressionNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
          let subExpressionNode2 = null;
          const nonTerminalNoe = lastChildNode, ruleName = nonTerminalNoe.getRuleName(), ruleNameSubExpressionRuleName = ruleName === _ruleNames.SUB_EXPRESSION_RULE_NAME;
          if (ruleNameSubExpressionRuleName) {
            subExpressionNode2 = lastChildNode;
          }
          return subExpressionNode2;
        });
      }
      return subExpressionNode;
    }
    function fromFirstChildNode(nonTerminalNode, callback) {
      let result;
      const firstIndex = 0;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === firstIndex) {
          const firstChildNode = childNode;
          result = callback(firstChildNode);
          return true;
        }
      });
      return result;
    }
    function fromSecondChildNode(nonTerminalNode, callback) {
      let result;
      const secondIndex = 1;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === secondIndex) {
          const firstChildNode = childNode;
          result = callback(firstChildNode);
          return true;
        }
      });
      return result;
    }
    function fromThirdChildNode(nonTerminalNode, callback) {
      let result;
      const thirdIndex = 2;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === thirdIndex) {
          const thirdChildNode = childNode;
          result = callback(thirdChildNode);
          return true;
        }
      });
      return result;
    }
    function fromLastChildNode(nonTerminalNode, callback) {
      let result;
      const multiplicity = nonTerminalNode.getMultiplicity(), lastIndex = multiplicity - 1;
      nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
        if (index === lastIndex) {
          const thirdChildNode = childNode;
          result = callback(thirdChildNode);
          return true;
        }
      });
      return result;
    }
  });

  // node_modules/occam-query/lib/path.js
  var require_path2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Path;
      }
    });
    var _node = require_node3();
    var Path = class {
      constructor(ruleNames, tokenTypes, infiniteDescent) {
        this.ruleNames = ruleNames;
        this.tokenTypes = tokenTypes;
        this.infiniteDescent = infiniteDescent;
      }
      getRuleNames() {
        return this.ruleNames;
      }
      getTokenTypes() {
        return this.tokenTypes;
      }
      isInfiniteDescent() {
        return this.infiniteDescent;
      }
      static fromPathNode(pathNode) {
        const ruleNames = (0, _node.ruleNamesFromPathNode)(pathNode), tokenTypes = (0, _node.tokenTypesFromPathNode)(pathNode), infiniteDescent = (0, _node.infiniteDescentFromPathNode)(pathNode), path = new Path(ruleNames, tokenTypes, infiniteDescent);
        return path;
      }
    };
  });

  // node_modules/occam-query/lib/utilities/array.js
  var require_array3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get clear() {
        return clear;
      },
      get fifth() {
        return fifth;
      },
      get first() {
        return first2;
      },
      get fourth() {
        return fourth;
      },
      get includes() {
        return includes;
      },
      get last() {
        return last;
      },
      get push() {
        return push;
      },
      get second() {
        return second;
      },
      get third() {
        return third;
      },
      get trim() {
        return trim;
      }
    });
    var _necessary = require_browser();
    var {clear, push, first: first2, second, third, fourth, fifth, last} = _necessary.arrayUtilities;
    function trim(array, startIndex, endIndex) {
      if (startIndex < 0) {
        const length = array.length;
        startIndex = length + startIndex;
        endIndex = length + endIndex;
      }
      if (endIndex !== Infinity) {
        const start2 = endIndex + 1;
        array.splice(start2);
      }
      const start = 0, deleteCount = startIndex;
      array.splice(start, deleteCount);
    }
    function includes(array, ...elements) {
      return elements.some((element) => array.includes(element));
    }
  });

  // node_modules/occam-query/lib/spread.js
  var require_spread = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Spread;
      }
    });
    var _necessary = require_browser();
    var _array = require_array3();
    var _node = require_node3();
    var {EXCLAMATION_MARK_CHARACTER} = _necessary.characters;
    var Spread = class {
      constructor(startIndex, endIndex, unique) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.unique = unique;
      }
      adjustNodes(nodes) {
        if (this.unique) {
          const nodesLength = nodes.length;
          if (nodesLength > 1) {
            (0, _array.clear)(nodes);
          }
        } else {
          (0, _array.trim)(nodes, this.startIndex, this.endIndex);
        }
      }
      static fromNothing() {
        const startIndex = 0, endIndex = Infinity, unique = false, spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
      static fromSpreadNode(spreadNode) {
        let startIndex = 0, endIndex = Infinity, unique = false;
        if (spreadNode !== null) {
          const index = (0, _node.indexFromSpreadNode)(spreadNode);
          if (index !== null) {
            startIndex = index;
            endIndex = index;
          } else {
            startIndex = (0, _node.startIndexFromSpreadNode)(spreadNode);
            endIndex = (0, _node.endIndexFromSpreadNode)(spreadNode);
          }
          unique = (0, _node.uniqueFromSpreadNode)(spreadNode);
        }
        const spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
      static fromSpreadExpression(spreadExpression) {
        let startIndex = 0, endIndex = Infinity, unique = false;
        if (spreadExpression !== null) {
          if (spreadExpression === EXCLAMATION_MARK_CHARACTER) {
            unique = true;
          } else {
            const regExp = /\[(-?\d+)?(\.\.\.)?(-?\d+)?]/, matches = spreadExpression.match(regExp), secondMatch = (0, _array.second)(matches) || null, thirdMatch = (0, _array.third)(matches) || null, fourthMatch = (0, _array.fourth)(matches) || null;
            if (secondMatch !== null) {
              startIndex = parseInt(secondMatch);
              if (thirdMatch === null) {
                endIndex = startIndex;
              }
            }
            if (fourthMatch !== null) {
              endIndex = parseInt(fourthMatch);
              if (thirdMatch === null) {
                startIndex = endIndex;
              }
            }
          }
        }
        const spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
    };
  });

  // node_modules/occam-query/lib/subExpression.js
  var require_subExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SubExpression;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path2());
    var _spread = /* @__PURE__ */ _interop_require_default(require_spread());
    var _node = require_node3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SubExpression = class {
      constructor(path, spread, subExpression) {
        this.path = path;
        this.spread = spread;
        this.subExpression = subExpression;
      }
      getPath() {
        return this.path;
      }
      getSpread() {
        return this.spread;
      }
      getSubExpression() {
        return this.subExpression;
      }
      getRuleNames() {
        return this.path.getRuleNames();
      }
      getTokenTypes() {
        return this.path.getTokenTypes();
      }
      isInfiniteDescent() {
        return this.path.isInfiniteDescent();
      }
      static fromSubExpressionNode(subExpressionNode) {
        let subExpression = null;
        if (subExpressionNode !== null) {
          const pathNode = (0, _node.pathNodeFromSubExpressionNode)(subExpressionNode), spreadNode = (0, _node.spreadNodeFromSubExpressionNode)(subExpressionNode);
          subExpressionNode = (0, _node.subExpressionNodeFromSubExpressionNode)(subExpressionNode);
          const path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode);
          subExpression = SubExpression.fromSubExpressionNode(subExpressionNode);
          subExpression = new SubExpression(path, spread, subExpression);
        }
        return subExpression;
      }
    };
  });

  // node_modules/occam-query/lib/expression/entries.js
  var require_entries4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:@|!|\\*|\\||\\/|\\[|\\]|\\.\\.\\.)"
      },
      {
        name: "^[a-zA-Z\\-]+"
      },
      {
        number: "^[0-9]+"
      },
      {
        unassigned: "^."
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-query/lib/expression/lexer.js
  var require_lexer6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _ExpressionLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_ExpressionLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_ExpressionLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_ExpressionLexer, entries);
      }
    };
    var ExpressionLexer = _ExpressionLexer;
    __publicField(ExpressionLexer, "entries", _entries.default);
    __publicField(ExpressionLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(ExpressionLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(ExpressionLexer, "EndOfLineCommentToken", null);
    __publicField(ExpressionLexer, "SingleLineCommentToken", null);
    __publicField(ExpressionLexer, "RegularExpressionToken", null);
    __publicField(ExpressionLexer, "EndOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "StartOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(ExpressionLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-query/lib/expression/bnf.js
  var require_bnf5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    expression       ::=  path spread? subExpression?   
    
                       |  error+ 
                                 
                       ;
  
    path             ::=  "/" infiniteDescent? selectors ;
    
    subExpression    ::=  path spread? subExpression?;

    infiniteDescent  ::=  "/" ;
    
    selectors        ::=  selector ( "|" selector )* ;

    spread           ::=  unique
    
                       |  "[" 

                          ( 
                            
                            ( startIndex "..." endIndex ) 
                            
                            | 
                            
                            ( startIndex "..." ) 
                            
                            | 
                            
                            ( "..." endIndex )
                             
                            | 
                            
                            index 
                            
                          )  
                          
                          "]" ;

    selector         ::=  ruleName | tokenType ;
                       
    ruleName         ::=  [name] | "*" ;
                       
    tokenType        ::=  "@"<NO_WHITESPACE>( [name] | "*" ) ;
                       
    startIndex       ::=  [number] ;
                       
    endIndex         ::=  [number] ;
                       
    index            ::=  [number] ;
                       
    unique           ::=  "!" ;
                       


    error.           ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-query/lib/expression/parser.js
  var require_parser7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _ExpressionParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_ExpressionParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_ExpressionParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_ExpressionParser, rules);
      }
    };
    var ExpressionParser = _ExpressionParser;
    __publicField(ExpressionParser, "bnf", _bnf.default);
  });

  // node_modules/occam-query/lib/expression.js
  var require_expression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Expression;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path2());
    var _spread = /* @__PURE__ */ _interop_require_default(require_spread());
    var _subExpression = /* @__PURE__ */ _interop_require_default(require_subExpression());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer6());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser7());
    var _node = require_node3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var expressionLexer = _lexer.default.fromNothing();
    var expressionParser = _parser.default.fromNothing();
    var Expression = class {
      constructor(path, spread, subExpression) {
        this.path = path;
        this.spread = spread;
        this.subExpression = subExpression;
      }
      getPath() {
        return this.path;
      }
      getSpread() {
        return this.spread;
      }
      getSubExpression() {
        return this.subExpression;
      }
      getRuleNames() {
        return this.path.getRuleNames();
      }
      getTokenTypes() {
        return this.path.getTokenTypes();
      }
      isInfiniteDescent() {
        return this.path.isInfiniteDescent();
      }
      static fromExpressionNode(expressionNode) {
        const pathNode = (0, _node.pathNodeFromExpressionNode)(expressionNode), spreadNode = (0, _node.spreadNodeFromExpressionNode)(expressionNode), subExpressionNode = (0, _node.subExpressionNodeFromExpressionNode)(expressionNode), path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode), subExpression = _subExpression.default.fromSubExpressionNode(subExpressionNode), expression = new Expression(path, spread, subExpression);
        return expression;
      }
      static fromExpressionString(expressionString) {
        let expression = null;
        const lexer = expressionLexer, parser = expressionParser, content = expressionString, tokens = lexer.tokenise(content), node = parser.parse(tokens);
        if (node !== null) {
          const expressionNode = node, errorNodes = (0, _node.errorNodesFromExpressionNode)(expressionNode), errorNodesLength = errorNodes.length;
          if (errorNodesLength === 0) {
            const pathNode = (0, _node.pathNodeFromExpressionNode)(expressionNode), spreadNode = (0, _node.spreadNodeFromExpressionNode)(expressionNode), subExpressionNode = (0, _node.subExpressionNodeFromExpressionNode)(expressionNode), path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode), subExpression = _subExpression.default.fromSubExpressionNode(subExpressionNode);
            expression = new Expression(path, spread, subExpression);
          }
        }
        return expression;
      }
    };
  });

  // node_modules/occam-query/lib/query.js
  var require_query = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Query;
      }
    });
    var _necessary = require_browser();
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    var _array = require_array3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {WILDCARD_CHARACTER} = _necessary.characters;
    var Query = class {
      constructor(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes) {
        this.spread = spread;
        this.subQuery = subQuery;
        this.ruleNames = ruleNames;
        this.tokenTypes = tokenTypes;
        this.maximumDepth = maximumDepth;
        this.infiniteDescent = infiniteDescent;
        this.intermediateNodes = intermediateNodes;
      }
      getSpread() {
        return this.sprea;
      }
      getSubQuery() {
        return this.subQuery;
      }
      getRuleNames() {
        return this.ruleNames;
      }
      getTokenTypes() {
        return this.tokenTypes;
      }
      getMaximumDepth() {
        return this.maximumDepth;
      }
      isInfiniteDescent() {
        return this.infiniteDescent;
      }
      getIntermediateNodes() {
        return this.intermediateNodes;
      }
      execute(node, depth = 0, maximumDepth = this.maximumDepth) {
        const nodes = [];
        this.clear();
        this.find(node, depth, maximumDepth);
        this.apply(nodes, depth, maximumDepth);
        return nodes;
      }
      clear() {
        (0, _array.clear)(this.intermediateNodes);
      }
      find(node, depth, maximumDepth) {
        if (depth > maximumDepth) {
          return;
        }
        const nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
        let found;
        if (nodeTerminalNode) {
          const terminalNode = node, types = this.tokenTypes, type = terminalNode.getType();
          found = (0, _array.includes)(types, type, WILDCARD_CHARACTER);
        }
        if (nodeNonTerminalNode) {
          const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName();
          found = (0, _array.includes)(this.ruleNames, ruleName, WILDCARD_CHARACTER);
        }
        if (found) {
          const intermediateNode = node;
          this.intermediateNodes.push(intermediateNode);
        }
        if (this.infiniteDescent) {
          if (nodeNonTerminalNode) {
            depth++;
            const nonTerminalNode = node;
            nonTerminalNode.forEachChildNode((childNode) => {
              this.find(childNode, depth, maximumDepth);
            });
          }
        }
      }
      apply(nodes, depth, maximumDepth) {
        this.spread.adjustNodes(this.intermediateNodes);
        if (this.subQuery === null) {
          (0, _array.push)(nodes, this.intermediateNodes);
        } else {
          this.intermediateNodes.forEach((intermediateNode) => {
            const intermediateNodeNonTerminalNode = intermediateNode.isNonTerminalNode();
            if (intermediateNodeNonTerminalNode) {
              depth++;
              const nonTerminalNode = intermediateNode;
              this.subQuery.clear();
              nonTerminalNode.forEachChildNode((childNode) => {
                this.subQuery.find(childNode, depth, maximumDepth);
              });
              this.subQuery.apply(nodes, depth, maximumDepth);
            }
          });
        }
      }
      static fromExpression(expression, maximumDepth = Infinity) {
        const spread = expression.getSpread(), subQuery = subQueryFromExpression(expression), ruleNames = expression.getRuleNames(), tokenTypes = expression.getTokenTypes(), infiniteDescent = expression.isInfiniteDescent(), intermediateNodes = [], query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        return query;
      }
      static fromSubExpression(subExpression) {
        const spread = subExpression.getSpread(), subQuery = subQueryFromSubExpression(subExpression), ruleNames = subExpression.getRuleNames(), tokenTypes = subExpression.getTokenTypes(), maximumDepth = Infinity, infiniteDescent = subExpression.isInfiniteDescent(), intermediateNodes = [], query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        return query;
      }
      static fromExpressionString(expressionString, maximumDepth = Infinity) {
        let query = null;
        const expression = _expression.default.fromExpressionString(expressionString);
        if (expression !== null) {
          const spread = expression.getSpread(), subQuery = subQueryFromExpression(expression), ruleNames = expression.getRuleNames(), tokenTypes = expression.getTokenTypes(), infiniteDescent = expression.isInfiniteDescent(), intermediateNodes = [];
          query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        }
        return query;
      }
    };
    function subQueryFromExpression(expression) {
      let subQuery = null;
      const subExpression = expression.getSubExpression();
      if (subExpression !== null) {
        const query = Query.fromSubExpression(subExpression);
        subQuery = query;
      }
      return subQuery;
    }
    function subQueryFromSubExpression(subExpression) {
      let subQuery = null;
      subExpression = subExpression.getSubExpression();
      if (subExpression !== null) {
        const query = Query.fromSubExpression(subExpression);
        subQuery = query;
      }
      return subQuery;
    }
  });

  // node_modules/occam-query/lib/utilities/query.js
  var require_query2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get queryByExpressionString() {
        return queryByExpressionString;
      }
    });
    var _query = /* @__PURE__ */ _interop_require_default(require_query());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function queryByExpressionString(node, expressionString, maximumDepth) {
      let nodes = null;
      const expression = _expression.default.fromExpressionString(expressionString);
      if (expression !== null) {
        const query = _query.default.fromExpression(expression, maximumDepth);
        nodes = query.execute(node);
      }
      return nodes;
    }
    var _default = {
      queryByExpressionString
    };
  });

  // node_modules/occam-query/lib/index.js
  var require_lib5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Expression() {
        return _expression.default;
      },
      get ExpressionLexer() {
        return _lexer.default;
      },
      get ExpressionParser() {
        return _parser.default;
      },
      get Query() {
        return _query.default;
      },
      get queryUtilities() {
        return _query1.default;
      }
    });
    var _query = /* @__PURE__ */ _interop_require_default(require_query());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    var _query1 = /* @__PURE__ */ _interop_require_default(require_query2());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer6());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/constants.js
  var require_constants5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CHARACTERS() {
        return CHARACTERS;
      },
      get CLASS_NAME_LENGTH() {
        return CLASS_NAME_LENGTH;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get HEAD() {
        return HEAD;
      },
      get STYLE() {
        return STYLE;
      },
      get TWO_SPACES() {
        return TWO_SPACES;
      }
    });
    var HEAD = "head";
    var STYLE = "style";
    var CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var TWO_SPACES = "  ";
    var EMPTY_STRING = "";
    var CLASS_NAME_LENGTH = 6;
  });

  // node_modules/with-style/lib/utilities/content.js
  var require_content2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "contentFromQueryNodeAndTokens", {
      enumerable: true,
      get: function() {
        return contentFromQueryNodeAndTokens;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants5();
    var {first: first2} = _necessary.arrayUtilities;
    function contentFromQueryNodeAndTokens(query, node, tokens) {
      let content = null;
      const nodes = query.execute(node), nodesLength = nodes.length;
      if (nodesLength > 0) {
        const firstNode = first2(nodes);
        node = firstNode;
        content = contentFromNodeAndTokens(node, tokens);
      }
      return content;
    }
    function contentFromNodeAndTokens(node, tokens) {
      const firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens), lastSignificantTokenIndex = node.getLastSignificantTokenIndex(tokens);
      let content = _constants.EMPTY_STRING;
      for (let index = firstSignificantTokenIndex; index <= lastSignificantTokenIndex; index++) {
        const token = tokens[index], tokenContent = token.getContent();
        content += tokenContent;
      }
      return content;
    }
  });

  // node_modules/with-style/lib/style/declaration.js
  var require_declaration = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Declaration;
      }
    });
    var _occamquery = require_lib5();
    var _constants = require_constants5();
    var _content = require_content2();
    var importantQuery = _occamquery.Query.fromExpressionString("/*/important");
    var propertyNameQuery = _occamquery.Query.fromExpressionString("/*/propertyName");
    var propertyValuesQuery = _occamquery.Query.fromExpressionString("/*/propertyValues");
    var Declaration = class {
      constructor(propertyValues, propertyName, important) {
        this.propertyValues = propertyValues;
        this.propertyName = propertyName;
        this.important = important;
      }
      getPropertyValues() {
        return this.propertyValues;
      }
      getPropertyName() {
        return this.propertyName;
      }
      getImportant() {
        return this.important;
      }
      matchPropertyName(propertyName) {
        const matches = this.propertyName === propertyName;
        return matches;
      }
      matchDeclaration(declaration) {
        const propertyName = declaration.getPropertyName(), matches = this.matchPropertyName(propertyName);
        return matches;
      }
      matchDeclarations(declarations) {
        const matches = declarations.someDeclaration((declaration) => {
          const matches2 = this.matchDeclaration(declaration);
          if (matches2) {
            return true;
          }
        });
        return matches;
      }
      asCSS(indent) {
        indent = indent + _constants.TWO_SPACES;
        const css = `${indent}${this.propertyName}: ${this.propertyValues}${this.important};
`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const propertyValuesContent = (0, _content.contentFromQueryNodeAndTokens)(propertyValuesQuery, node, tokens), propertyNameContent = (0, _content.contentFromQueryNodeAndTokens)(propertyNameQuery, node, tokens), importantContent = (0, _content.contentFromQueryNodeAndTokens)(importantQuery, node, tokens), propertyValues = propertyValuesContent, propertyName = propertyNameContent, important = importantContent === null ? _constants.EMPTY_STRING : ` ${importantContent}`, declaration = new Declaration(propertyValues, propertyName, important);
        return declaration;
      }
    };
  });

  // node_modules/with-style/lib/style/declarations.js
  var require_declarations = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Declarations;
      }
    });
    var _occamquery = require_lib5();
    var _necessary = require_browser();
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forwardsForEach, backwardsForEach} = _necessary.arrayUtilities;
    var declarationQuery = _occamquery.Query.fromExpressionString("/*/declaration");
    var Declarations = class {
      constructor(array) {
        this.array = array;
      }
      someDeclaration(callback) {
        return this.array.some(callback);
      }
      forwardsForEachDeclaration(callback) {
        forwardsForEach(this.array, callback);
      }
      backwardsForEachDeclaration(callback) {
        backwardsForEach(this.array, callback);
      }
      unshift(declarations) {
        declarations.backwardsForEachDeclaration((declaration) => {
          const matches = declaration.matchDeclarations(this);
          if (!matches) {
            this.array.unshift(declaration);
          }
        });
      }
      asCSS(className, indent) {
        const declarationsCSS = this.array.reduce((declarationsCSS2, declaration) => {
          const declarationCSS = declaration.asCSS(indent);
          declarationsCSS2 += declarationCSS;
          return declarationsCSS2;
        }, _constants.EMPTY_STRING), css = className === null ? declarationsCSS : `${indent}.${className} {
${declarationsCSS}${indent}}

`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarationNodes = declarationQuery.execute(node), array = declarationNodes.map((declarationNode) => {
          const node2 = declarationNode, declaration = _declaration.default.fromNodeAndTokens(node2, tokens);
          return declaration;
        }), declarations = new Declarations(array);
        return declarations;
      }
    };
  });

  // node_modules/with-style/lib/style/ruleSet.js
  var require_ruleSet = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleSet;
      }
    });
    var _occamquery = require_lib5();
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var selectorsQuery = _occamquery.Query.fromExpressionString("//selectors");
    var RuleSet = class {
      constructor(selectors, declarations) {
        this.selectors = selectors;
        this.declarations = declarations;
      }
      getSelectors() {
        return this.selectors;
      }
      getDeclarations() {
        return this.declarations;
      }
      unshift(ruleSet) {
        const declarations = ruleSet.getDeclarations();
        this.declarations.unshift(declarations);
      }
      findMatchingRuleSet(ruleSets) {
        const matchingRuleSet = ruleSets.find((ruleSet) => {
          const selectors = ruleSet.getSelectors(), selectorsMatch = selectors === this.selectors, ruleSetsMatch = selectorsMatch;
          if (ruleSetsMatch) {
            return true;
          }
        }) || null;
        return matchingRuleSet;
      }
      asCSS(className, indent) {
        let css = _constants.EMPTY_STRING;
        const declarationsCSS = this.declarations.asCSS(null, indent);
        if (declarationsCSS !== _constants.EMPTY_STRING) {
          css = `${indent}.${className}${this.selectors} {
${declarationsCSS}${indent}}

`;
        }
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const selectors = selectorsFromNodeAndTokens(node, tokens), declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSet = new RuleSet(selectors, declarations);
        return ruleSet;
      }
    };
    function selectorsFromNodeAndTokens(node, tokens) {
      const selectorsNodeContent = (0, _content.contentFromQueryNodeAndTokens)(selectorsQuery, node, tokens), selectors = `${selectorsNodeContent}`;
      return selectors;
    }
  });

  // node_modules/with-style/lib/style/ruleSets.js
  var require_ruleSets = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleSets;
      }
    });
    var _occamquery = require_lib5();
    var _ruleSet = /* @__PURE__ */ _interop_require_default(require_ruleSet());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ruleSetQuery = _occamquery.Query.fromExpressionString("/*/ruleSet");
    var RuleSets = class {
      constructor(array) {
        this.array = array;
      }
      unshift(ruleSets) {
        ruleSets.forEach((ruleSet) => {
          const matchingRuleSet = ruleSet.findMatchingRuleSet(this.array);
          matchingRuleSet === null ? this.array.unshift(ruleSet) : matchingRuleSet.unshift(ruleSet);
        });
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, ruleSet) => {
          const ruleSetCSS = ruleSet.asCSS(className, indent);
          css2 += ruleSetCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const ruleSetNodes = ruleSetQuery.execute(node), array = ruleSetNodes.map((ruleSetNode) => {
          const node2 = ruleSetNode, ruleSet = _ruleSet.default.fromNodeAndTokens(node2, tokens);
          return ruleSet;
        }), ruleSets = new RuleSets(array);
        return ruleSets;
      }
    };
  });

  // node_modules/with-style/lib/utilities/string.js
  var require_string4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "trim", {
      enumerable: true,
      get: function() {
        return trim;
      }
    });
    var _constants = require_constants5();
    function trim(string) {
      string = string.replace(/[\n\r]$/g, _constants.EMPTY_STRING);
      return string;
    }
  });

  // node_modules/with-style/lib/style/media.js
  var require_media = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Media;
      }
    });
    var _occamquery = require_lib5();
    var _ruleSets = /* @__PURE__ */ _interop_require_default(require_ruleSets());
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _string = require_string4();
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var queriesQuery = _occamquery.Query.fromExpressionString("/media/mediaQueries");
    var Media = class {
      constructor(declarations, ruleSets, queries) {
        this.declarations = declarations;
        this.ruleSets = ruleSets;
        this.queries = queries;
      }
      getDeclarations() {
        return this.declarations;
      }
      getRuleSets() {
        return this.ruleSets;
      }
      getQueries() {
        return this.queries;
      }
      asCSS(className, indent) {
        indent = indent + _constants.TWO_SPACES;
        let css = _constants.EMPTY_STRING;
        const ruleSetsCSS = this.ruleSets.asCSS(className, indent), declarationsCSS = this.declarations.asCSS(className, indent);
        let ruleSetsDeclarationsCSS = `${declarationsCSS}${ruleSetsCSS}`;
        if (ruleSetsDeclarationsCSS !== _constants.EMPTY_STRING) {
          ruleSetsDeclarationsCSS = (0, _string.trim)(ruleSetsDeclarationsCSS);
          css = `@media ${this.queries} {
${ruleSetsDeclarationsCSS}}

`;
        }
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), queries = queriesFromNodeAndTokens(node, tokens), media = new Media(declarations, ruleSets, queries);
        return media;
      }
    };
    function queriesFromNodeAndTokens(node, tokens) {
      const queriesNodeContent = (0, _content.contentFromQueryNodeAndTokens)(queriesQuery, node, tokens), queries = `${queriesNodeContent}`;
      return queries;
    }
  });

  // node_modules/with-style/lib/style/medias.js
  var require_medias = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Medias;
      }
    });
    var _occamquery = require_lib5();
    var _media = /* @__PURE__ */ _interop_require_default(require_media());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var mediaQuery = _occamquery.Query.fromExpressionString("/stylesheet/media");
    var Medias = class {
      constructor(array) {
        this.array = array;
      }
      unshift(medias) {
        medias.forEach((media) => {
          this.array.unshift(media);
        });
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, media) => {
          const mediaCSS = media.asCSS(className, indent);
          css2 += mediaCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const mediaNodes = mediaQuery.execute(node), array = mediaNodes.map((mediaNode) => {
          const node2 = mediaNode, media = _media.default.fromNodeAndTokens(node2, tokens);
          return media;
        }), medias = new Medias(array);
        return medias;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframe.js
  var require_keyframe = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframe;
      }
    });
    var _occamquery = require_lib5();
    var _necessary = require_browser();
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration());
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var percentageQuery = _occamquery.Query.fromExpressionString("/*/@percentage");
    var declarationQuery = _occamquery.Query.fromExpressionString("/*/declaration");
    var {first: first2} = _necessary.arrayUtilities;
    var Keyframe = class {
      constructor(percentage, declaration) {
        this.percentage = percentage;
        this.declaration = declaration;
      }
      getPercentage() {
        return this.percentage;
      }
      getDeclaration() {
        return this.declaration;
      }
      asCSS(indent) {
        const declarationCSS = this.declaration.asCSS(indent), css = `${indent}${this.percentage} { 
${declarationCSS}${indent}}
`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const percentageContent = (0, _content.contentFromQueryNodeAndTokens)(percentageQuery, node, tokens), percentage = percentageContent, declarationNodes = declarationQuery.execute(node), firstDeclarationNode = first2(declarationNodes), declarationNode = firstDeclarationNode;
        node = declarationNode;
        const declaration = _declaration.default.fromNodeAndTokens(node, tokens), keyframe = new Keyframe(percentage, declaration);
        return keyframe;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframes.js
  var require_keyframes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframes;
      }
    });
    var _occamquery = require_lib5();
    var _keyframe = /* @__PURE__ */ _interop_require_default(require_keyframe());
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var keyframeQuery = _occamquery.Query.fromExpressionString("/keyframes/keyframe");
    var identifierQuery = _occamquery.Query.fromExpressionString("/keyframes/@identifier");
    var Keyframes = class {
      constructor(array, identifier) {
        this.array = array;
        this.identifier = identifier;
      }
      getIdentifier() {
        return this.identifier;
      }
      asCSS(indent) {
        indent = indent + _constants.TWO_SPACES;
        const keyframesCSS = this.array.reduce((keyframesCSS2, keyframe) => {
          const keyframeCSS = keyframe.asCSS(indent);
          keyframesCSS2 += keyframeCSS;
          return keyframesCSS2;
        }, _constants.EMPTY_STRING), css = `@keyframes ${this.identifier} {
${keyframesCSS}}

`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const keyframeNodes = keyframeQuery.execute(node), array = keyframeNodes.map((keyframeNode) => {
          const node2 = keyframeNode, keyframe = _keyframe.default.fromNodeAndTokens(node2, tokens);
          return keyframe;
        }), identifierContent = (0, _content.contentFromQueryNodeAndTokens)(identifierQuery, node, tokens), identifier = identifierContent, keyframes = new Keyframes(array, identifier);
        return keyframes;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframess.js
  var require_keyframess = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframess;
      }
    });
    var _occamquery = require_lib5();
    var _keyframes = /* @__PURE__ */ _interop_require_default(require_keyframes());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var keyframesQuery = _occamquery.Query.fromExpressionString("/stylesheet/keyframes");
    var Keyframess = class {
      constructor(array) {
        this.array = array;
      }
      unshift(keyframess) {
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, keyframes) => {
          const keyframesCSS = keyframes.asCSS(indent);
          css2 += keyframesCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const keyframesNodes = keyframesQuery.execute(node), array = keyframesNodes.map((keyframesNode) => {
          const node2 = keyframesNode, keyframes = _keyframes.default.fromNodeAndTokens(node2, tokens);
          return keyframes;
        }), keyframess = new Keyframess(array);
        return keyframess;
      }
    };
  });

  // node_modules/with-style/lib/style.js
  var require_style = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Style;
      }
    });
    var _medias = /* @__PURE__ */ _interop_require_default(require_medias());
    var _ruleSets = /* @__PURE__ */ _interop_require_default(require_ruleSets());
    var _keyframess = /* @__PURE__ */ _interop_require_default(require_keyframess());
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Style = class {
      constructor(declarations, keyframess, ruleSets, medias) {
        this.declarations = declarations;
        this.keyframess = keyframess;
        this.ruleSets = ruleSets;
        this.medias = medias;
      }
      getDeclarations() {
        return this.declarations;
      }
      getKeyframess() {
        return this.keyframess;
      }
      getRuleSets() {
        return this.ruleSets;
      }
      getMedias() {
        return this.medias;
      }
      extends(superStyle) {
        const declarations = superStyle.getDeclarations(), keyframess = superStyle.getKeyframess(), ruleSets = superStyle.getRuleSets(), medias = superStyle.getMedias();
        this.unshift(declarations, keyframess, ruleSets, medias);
      }
      unshift(declarations, keyframess, ruleSets, medias) {
        this.declarations.unshift(declarations);
        this.keyframess.unshift(keyframess);
        this.ruleSets.unshift(ruleSets);
        this.medias.unshift(medias);
      }
      asCSS(className) {
        const indent = _constants.EMPTY_STRING, declarationsCSS = this.declarations.asCSS(className, indent), keyframessCSS = this.keyframess.asCSS(className, indent), ruleSetsCSS = this.ruleSets.asCSS(className, indent), mediasCSS = this.medias.asCSS(className, indent), css = `${declarationsCSS}${keyframessCSS}${ruleSetsCSS}${mediasCSS}`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarations = _declarations.default.fromNodeAndTokens(node, tokens), keyframess = _keyframess.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), medias = _medias.default.fromNodeAndTokens(node, tokens), style = new Style(declarations, keyframess, ruleSets, medias);
        return style;
      }
    };
  });

  // node_modules/with-style/lib/utilities/styles.js
  var require_styles = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _style = /* @__PURE__ */ _interop_require_default(require_style());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer5());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser6());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var cssLexer = _lexer.default.fromNothing();
    var cssParser = _parser.default.fromNothing();
    if (!globalThis.styleMap) {
      globalThis.styleMap = {};
    }
    var {styleMap} = globalThis;
    function renderStyle(style) {
      const headDOMElement = document.querySelector(_constants.HEAD), styleDOMElement = document.createElement(_constants.STYLE), innerHTML = `        
${style}
`;
      Object.assign(styleDOMElement, {
        innerHTML
      });
      headDOMElement.appendChild(styleDOMElement);
      return styleDOMElement;
    }
    function renderStyles() {
      const stylesCSS = retrieveStylesCSS(), style = stylesCSS;
      renderStyle(style);
    }
    function generateStyle(args, className, superStyle = null) {
      const strings = args.shift(), content = strings.reduce((content2, string, index) => {
        const arg = args[index] || null;
        content2 = arg === null ? `${content2}${string}` : `${content2}${string}${arg}`;
        return content2;
      }, _constants.EMPTY_STRING), tokens = cssLexer.tokenise(content), node = cssParser.parse(tokens), style = _style.default.fromNodeAndTokens(node, tokens);
      if (superStyle !== null) {
        style.extends(superStyle);
      }
      styleMap[className] = style;
    }
    function retrieveStyle(className) {
      const style = styleMap[className] || null;
      return style;
    }
    var _default = {
      renderStyle,
      renderStyles,
      generateStyle,
      retrieveStyle
    };
    function retrieveStylesCSS() {
      const classNames = Object.keys(styleMap), stylesCSS = classNames.reduce((stylesCSS2, className) => {
        const style = retrieveStyle(className), styleCSS = style.asCSS(className);
        stylesCSS2 += styleCSS;
        return stylesCSS2;
      }, _constants.EMPTY_STRING);
      return stylesCSS;
    }
  });

  // node_modules/with-style/lib/utilities/className.js
  var require_className = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get generateClassName() {
        return generateClassName;
      },
      get retrieveClassName() {
        return retrieveClassName;
      }
    });
    var _constants = require_constants5();
    var length = _constants.CLASS_NAME_LENGTH;
    var characters = _constants.CHARACTERS;
    var charactersLength = characters.length;
    var classNames = [];
    function generateClassName() {
      let className = _constants.EMPTY_STRING;
      for (let count = 0; count < length; count++) {
        const index = Math.floor(Math.random() * charactersLength), character = characters[index];
        className += character;
      }
      const classNamesIncludesClassName = classNames.includes(className);
      if (!classNamesIncludesClassName) {
        classNames.push(className);
      } else {
        className = generateClassName();
      }
      return className;
    }
    function retrieveClassName(element) {
      const {className} = element.reactFunction || element.reactComponent.constructor;
      return className;
    }
    var _default = {
      generateClassName,
      retrieveClassName
    };
  });

  // node_modules/with-style/lib/index.js
  var require_lib6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CSSLexer() {
        return _lexer.default;
      },
      get CSSParser() {
        return _parser.default;
      },
      get classNameUtilities() {
        return _className.default;
      },
      get stylesUtilities() {
        return _styles.default;
      },
      get tagNames() {
        return _tagNames.default;
      }
    });
    var _tagNames = /* @__PURE__ */ _interop_require_default(require_tagNames());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer5());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser6());
    var _styles = /* @__PURE__ */ _interop_require_default(require_styles());
    var _className = /* @__PURE__ */ _interop_require_default(require_className());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-with-style/lib/utilities/class.js
  var require_class = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isClass", {
      enumerable: true,
      get: function() {
        return isClass;
      }
    });
    var _easy = require_lib();
    function isClass(argument) {
      return isSubclassOf(argument, _easy.Element);
    }
    function isSubclassOf(argument, Class) {
      const subclassOf = argument.prototype instanceof Class;
      return subclassOf;
    }
  });

  // node_modules/easy-with-style/lib/constants.js
  var require_constants6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CLASS_NAME", {
      enumerable: true,
      get: function() {
        return CLASS_NAME;
      }
    });
    var CLASS_NAME = "className";
  });

  // node_modules/easy-with-style/lib/withStyle.js
  var require_withStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easy = require_lib();
    var _withstyle = require_lib6();
    var _class = require_class();
    var _constants = require_constants6();
    var {generateClassName} = _withstyle.classNameUtilities;
    var {renderStyle, renderStyles, generateStyle, retrieveStyle} = _withstyle.stylesUtilities;
    function withStyle(ClassOrFunction) {
      return function() {
        const args = [
          ...arguments
        ];
        let {className = null} = ClassOrFunction;
        const superStyle = retrieveStyle(className);
        className = generateClassName();
        generateStyle(args, className, superStyle);
        const ClassOrFunctionClass = (0, _class.isClass)(ClassOrFunction);
        if (ClassOrFunctionClass) {
          const Class = ClassOrFunction;
          ClassOrFunction = class extends Class {
            static fromClass(_Class, properties, ...remainingArguments) {
              properties = appendClassNameToProperties(className, properties);
              return Class.fromClass(_Class, properties, ...remainingArguments);
            }
          };
        } else {
          const Function2 = ClassOrFunction;
          ClassOrFunction = (properties) => {
            properties = appendClassNameToProperties(className, properties);
            return Function2(properties);
          };
        }
        Object.assign(ClassOrFunction, {
          className
        });
        return ClassOrFunction;
      };
    }
    Object.assign(withStyle, {
      renderStyle,
      renderStyles
    });
    var _default = withStyle;
    _withstyle.tagNames.forEach((tagName) => {
      Object.defineProperty(withStyle, tagName, {
        get: () => function() {
          const args = [
            ...arguments
          ], className = generateClassName();
          generateStyle(args, className);
          const Function2 = (properties) => {
            properties = appendClassNameToProperties(className, properties);
            return _easy.React.createElement(tagName, properties);
          };
          Object.assign(Function2, {
            className
          });
          return Function2;
        }
      });
    });
    function appendClassNameToProperties(className, properties) {
      properties = properties.hasOwnProperty(_constants.CLASS_NAME) ? properties : {
        ...properties,
        className
      };
      return properties;
    }
  });

  // node_modules/easy-with-style/lib/index.js
  var require_lib7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _withStyle = /* @__PURE__ */ _interop_require_default(require_withStyle());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = _withStyle.default;
  });

  // node_modules/easy-layout/lib/constants.js
  var require_constants7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CURSOR", {
      enumerable: true,
      get: function() {
        return CURSOR;
      }
    });
    var CURSOR = "cursor";
  });

  // node_modules/easy-layout/lib/cursors.js
  var require_cursors = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AUTO_CURSOR() {
        return AUTO_CURSOR;
      },
      get COL_RESIZE_CURSOR() {
        return COL_RESIZE_CURSOR;
      },
      get POINTER_CURSOR() {
        return POINTER_CURSOR;
      },
      get ROW_RESIZE_CURSOR() {
        return ROW_RESIZE_CURSOR;
      }
    });
    var AUTO_CURSOR = "auto";
    var POINTER_CURSOR = "pointer";
    var COL_RESIZE_CURSOR = "col-resize";
    var ROW_RESIZE_CURSOR = "row-resize";
  });

  // node_modules/easy-layout/lib/cursor.js
  var require_cursor = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get autoCursor() {
        return autoCursor;
      },
      get columnResizeCursor() {
        return columnResizeCursor;
      },
      get default() {
        return _default;
      },
      get pointerCursor() {
        return pointerCursor;
      },
      get resetCursor() {
        return resetCursor;
      },
      get rowResizeCursor() {
        return rowResizeCursor;
      }
    });
    var _easy = require_lib();
    var _constants = require_constants7();
    var _cursors = require_cursors();
    var body = new _easy.Body();
    var previousCursor;
    function autoCursor() {
      const cursor = _cursors.AUTO_CURSOR;
      updateCursor(cursor);
    }
    function resetCursor() {
      setCursor(previousCursor);
    }
    function pointerCursor() {
      const cursor = _cursors.POINTER_CURSOR;
      updateCursor(cursor);
    }
    function rowResizeCursor() {
      const cursor = _cursors.ROW_RESIZE_CURSOR;
      updateCursor(cursor);
    }
    function columnResizeCursor() {
      const cursor = _cursors.COL_RESIZE_CURSOR;
      updateCursor(cursor);
    }
    var _default = {
      autoCursor,
      resetCursor,
      pointerCursor,
      rowResizeCursor,
      columnResizeCursor
    };
    function setCursor(cursor) {
      const css = {
        cursor
      };
      body.css(css);
    }
    function updateCursor(cursor) {
      const currentCursor = getCurrentCursor();
      if (currentCursor !== cursor) {
        previousCursor = currentCursor;
        setCursor(cursor);
      }
    }
    function getCurrentCursor() {
      const currentCursor = body.css(_constants.CURSOR) || _cursors.AUTO_CURSOR;
      return currentCursor;
    }
  });

  // node_modules/easy-layout/lib/div/row.js
  var require_row = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RowDiv = class extends _easy.Element {
    };
    __publicField(RowDiv, "tagName", "div");
    __publicField(RowDiv, "defaultProperties", {
      className: "row"
    });
    var _default = (0, _easywithstyle.default)(RowDiv)`

  display: flex;
  flex-grow: 1;

`;
  });

  // node_modules/easy-layout/lib/div/rows.js
  var require_rows = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RowsDiv = class extends _easy.Element {
    };
    __publicField(RowsDiv, "tagName", "div");
    __publicField(RowsDiv, "defaultProperties", {
      className: "rows"
    });
    var _default = (0, _easywithstyle.default)(RowsDiv)`

  display: flex;
  flex-grow: 1;
  flex-direction: column;

`;
  });

  // node_modules/easy-layout/lib/div/column.js
  var require_column = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ColumnDiv = class extends _easy.Element {
    };
    __publicField(ColumnDiv, "tagName", "div");
    __publicField(ColumnDiv, "defaultProperties", {
      className: "column"
    });
    var _default = (0, _easywithstyle.default)(ColumnDiv)`

  display: flex;
  flex-grow: 1;

`;
  });

  // node_modules/easy-layout/lib/div/columns.js
  var require_columns = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ColumnsDiv = class extends _easy.Element {
    };
    __publicField(ColumnsDiv, "tagName", "div");
    __publicField(ColumnsDiv, "defaultProperties", {
      className: "columns"
    });
    var _default = (0, _easywithstyle.default)(ColumnsDiv)`

  display: flex;
  flex-grow: 1;
  flex-direction: row;

`;
  });

  // node_modules/easy-drag-and-drop/lib/constants.js
  var require_constants8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "START_DRAGGING_DELAY", {
      enumerable: true,
      get: function() {
        return START_DRAGGING_DELAY;
      }
    });
    var START_DRAGGING_DELAY = 175;
  });

  // node_modules/easy-drag-and-drop/lib/utilities/reference.js
  var require_reference = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "checkDragElementIgnoresDropElement", {
      enumerable: true,
      get: function() {
        return checkDragElementIgnoresDropElement;
      }
    });
    function checkDragElementIgnoresDropElement(dragElement, dropElement) {
      const reference = dropElement.getReference(), references = dragElement.getReferences(), referencesIncludesReference = references.includes(reference), dragElementIgnoresDropElement = !referencesIncludesReference;
      return dragElementIgnoresDropElement;
    }
  });

  // node_modules/easy-drag-and-drop/lib/utilities/event.js
  var require_event2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get mouseLeftFromEvent() {
        return mouseLeftFromEvent;
      },
      get mouseTopFromEvent() {
        return mouseTopFromEvent;
      }
    });
    function mouseTopFromEvent(event) {
      const {pageY} = event, mouseTop = pageY;
      return mouseTop;
    }
    function mouseLeftFromEvent(event) {
      const {pageX} = event, mouseLeft = pageX;
      return mouseLeft;
    }
  });

  // node_modules/easy-drag-and-drop/lib/customEventTypes.js
  var require_customEventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DRAG_CUSTOM_EVENT_TYPE() {
        return DRAG_CUSTOM_EVENT_TYPE;
      },
      get DRAG_OUT_CUSTOM_EVENT_TYPE() {
        return DRAG_OUT_CUSTOM_EVENT_TYPE;
      },
      get DRAG_OVER_CUSTOM_EVENT_TYPE() {
        return DRAG_OVER_CUSTOM_EVENT_TYPE;
      },
      get DROP_CUSTOM_EVENT_TYPE() {
        return DROP_CUSTOM_EVENT_TYPE;
      },
      get START_DRAG_CUSTOM_EVENT_TYPE() {
        return START_DRAG_CUSTOM_EVENT_TYPE;
      },
      get STOP_DRAG_CUSTOM_EVENT_TYPE() {
        return STOP_DRAG_CUSTOM_EVENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var DRAG_CUSTOM_EVENT_TYPE = "drag";
    var DROP_CUSTOM_EVENT_TYPE = "drop";
    var DRAG_OUT_CUSTOM_EVENT_TYPE = "drag-out";
    var DRAG_OVER_CUSTOM_EVENT_TYPE = "drag-over";
    var STOP_DRAG_CUSTOM_EVENT_TYPE = "stop-drag";
    var START_DRAG_CUSTOM_EVENT_TYPE = "start-drag";
    var _default = {
      DRAG_CUSTOM_EVENT_TYPE,
      DROP_CUSTOM_EVENT_TYPE,
      DRAG_OUT_CUSTOM_EVENT_TYPE,
      DRAG_OVER_CUSTOM_EVENT_TYPE,
      STOP_DRAG_CUSTOM_EVENT_TYPE,
      START_DRAG_CUSTOM_EVENT_TYPE
    };
  });

  // node_modules/easy-drag-and-drop/lib/mixins/drag.js
  var require_drag = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _easy = require_lib();
    var _constants = require_constants8();
    var _reference = require_reference();
    var _event = require_event2();
    var _customEventTypes = require_customEventTypes();
    var {ESCAPE_KEY_CODE} = _necessary.keyCodes;
    var {LEFT_MOUSE_BUTTON} = _easy.mouseButtons;
    function getDragElement2() {
      const {dragElement} = globalThis;
      return dragElement;
    }
    function setDragElement(dragElement) {
      Object.assign(globalThis, {
        dragElement
      });
    }
    function resetDragElement() {
      const dragElement = null;
      setDragElement(dragElement);
    }
    Object.assign(globalThis, {
      getDragElement: getDragElement2,
      setDragElement,
      resetDragElement
    });
    resetDragElement();
    function enableDrag() {
      const timeout = null, topOffset = null, leftOffset = null, dragEnabled = true, startMouseTop = null, startMouseLeft = null;
      this.onMouseDown(mouseDownHandler, this);
      this.updateState({
        timeout,
        topOffset,
        leftOffset,
        dragEnabled,
        startMouseTop,
        startMouseLeft
      });
    }
    function disableDrag() {
      const dragEnabled = false;
      this.updateState({
        dragEnabled
      });
      this.offMouseDown(mouseDownHandler, this);
    }
    function onCustomDrag(dragCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, customHandler = dragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDrag(dragCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, customHandler = dragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomStopDrag(stopDragCustomHandler, element) {
      const customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE, customHandler = stopDragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomStopDrag(stopDragCustomHandler, element) {
      const customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE, customHandler = stopDragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomStartDrag(startDragCustomHandler, element) {
      const customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE, customHandler = startDragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomStartDrag(startDragCustomHandler, element) {
      const customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE, customHandler = startDragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function isDragEnabled() {
      const {dragEnabled = false} = this.getState();
      return dragEnabled;
    }
    function isDragging() {
      const dragging = this.hasClass("dragging");
      return dragging;
    }
    function startDrag(event, element, mouseTop, mouseLeft) {
      const bounds = this.getBounds(), boundsTop = bounds.getTop(), boundsLeft = bounds.getLeft(), boundsRight = bounds.getRight(), boundsBottom = bounds.getBottom(), boundsWidth = boundsRight - boundsLeft, boundsHeight = boundsBottom - boundsTop, topOffset = Math.floor(boundsHeight / 2), leftOffset = Math.floor(boundsWidth / 2), dragElement = this, startMouseTop = mouseTop, startMouseLeft = mouseLeft, customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE;
      _easy.window.onKeyDown(keyDownHandler, this);
      _easy.window.onMouseMove(mouseMoveHandler, this);
      this.addClass("dragging");
      setDragElement(dragElement);
      this.setTopOffset(topOffset);
      this.setLeftOffset(leftOffset);
      this.setStartMouseTop(startMouseTop);
      this.setStartMouseLeft(startMouseLeft);
      this.callCustomHandlers(customEventType, event, element);
      this.drag(event, element, mouseTop, mouseLeft);
    }
    function stopDrag(event, element, aborted) {
      const dropElement = getDropElement(), customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE;
      this.removeClass("dragging");
      _easy.window.offKeyDown(keyDownHandler, this);
      _easy.window.offMouseMove(mouseMoveHandler, this);
      const done = () => {
        this.callCustomHandlersAsync(customEventType, event, element, dropElement, aborted, () => {
          resetDragElement();
        });
      };
      if (dropElement !== null) {
        let dragElement = this;
        const dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
          dragElement = null;
        }
        dropElement.drop(event, element, dragElement, aborted, done);
      } else {
        done();
      }
    }
    function drag(event, element, mouseTop, mouseLeft) {
      const scrollTop = _easy.window.getScrollTop(), scrollLeft = _easy.window.getScrollLeft(), topOffset = this.getTopOffset(), leftOffset = this.getLeftOffset(), startMouseTop = this.getStartMouseTop(), startMouseLeft = this.getStartMouseLeft(), customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, relativeMouseTop = mouseTop - startMouseTop, relativeMouseLeft = mouseLeft - startMouseLeft;
      let top = startMouseTop + relativeMouseTop - topOffset - scrollTop, left = startMouseLeft + relativeMouseLeft - leftOffset - scrollLeft;
      top = `${top}px`;
      left = `${left}px`;
      const css = {
        top,
        left
      };
      this.css(css);
      this.callCustomHandlers(customEventType, event, element, relativeMouseTop, relativeMouseLeft);
    }
    function startWaitingToDrag(event, element, mouseTop, mouseLeft) {
      let timeout = this.getTimeout();
      if (timeout === null) {
        timeout = setTimeout(() => {
          this.resetTimeout();
          this.startDrag(event, element, mouseTop, mouseLeft);
        }, _constants.START_DRAGGING_DELAY);
        this.updateTimeout(timeout);
      }
    }
    function stopWaitingToDrag() {
      const timeout = this.getTimeout();
      if (timeout !== null) {
        clearTimeout(timeout);
        this.resetTimeout();
      }
    }
    function getTimeout() {
      const {timeout} = this.getState();
      return timeout;
    }
    function resetTimeout() {
      const timeout = null;
      this.updateTimeout(timeout);
    }
    function updateTimeout(timeout) {
      this.updateState({
        timeout
      });
    }
    function getTopOffset() {
      const {topOffset} = this.getState();
      return topOffset;
    }
    function getLeftOffset() {
      const {leftOffset} = this.getState();
      return leftOffset;
    }
    function getStartMouseTop() {
      const {startMouseTop} = this.getState();
      return startMouseTop;
    }
    function getStartMouseLeft() {
      const {startMouseLeft} = this.getState();
      return startMouseLeft;
    }
    function setTopOffset(topOffset) {
      this.updateState({
        topOffset
      });
    }
    function setLeftOffset(leftOffset) {
      this.updateState({
        leftOffset
      });
    }
    function setStartMouseTop(startMouseTop) {
      this.updateState({
        startMouseTop
      });
    }
    function setStartMouseLeft(startMouseLeft) {
      this.updateState({
        startMouseLeft
      });
    }
    var _default = {
      enableDrag,
      disableDrag,
      onCustomDrag,
      offCustomDrag,
      onCustomStopDrag,
      offCustomStopDrag,
      onCustomStartDrag,
      offCustomStartDrag,
      isDragEnabled,
      isDragging,
      startDrag,
      stopDrag,
      drag,
      startWaitingToDrag,
      stopWaitingToDrag,
      getTimeout,
      resetTimeout,
      updateTimeout,
      getTopOffset,
      getLeftOffset,
      getStartMouseTop,
      getStartMouseLeft,
      setTopOffset,
      setLeftOffset,
      setStartMouseTop,
      setStartMouseLeft
    };
    function keyDownHandler(event, element) {
      const {keyCode} = event, escapeKey = keyCode === ESCAPE_KEY_CODE, aborted = true;
      if (escapeKey) {
        this.stopDrag(event, element, aborted);
        event.stopPropagation();
      }
    }
    function mouseUpHandler(event, element) {
      const dragging = this.isDragging(), aborted = false;
      dragging ? this.stopDrag(event, element, aborted) : this.stopWaitingToDrag();
      event.stopPropagation();
      _easy.window.offBlur(mouseUpHandler, this);
      _easy.window.offMouseUp(mouseUpHandler, this);
    }
    function mouseDownHandler(event, element) {
      const {button} = event;
      if (button === LEFT_MOUSE_BUTTON) {
        const dragging = this.isDragging();
        if (!dragging) {
          const mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
          this.startWaitingToDrag(event, element, mouseTop, mouseLeft);
        }
      }
      event.stopPropagation();
      _easy.window.onBlur(mouseUpHandler, this);
      _easy.window.onMouseUp(mouseUpHandler, this);
    }
    function mouseMoveHandler(event, element) {
      const dragging = this.isDragging();
      if (dragging) {
        const mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
        this.drag(event, element, mouseTop, mouseLeft);
      }
      event.stopPropagation();
    }
  });

  // node_modules/easy-drag-and-drop/lib/mixins/drop.js
  var require_drop = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _reference = require_reference();
    var _customEventTypes = require_customEventTypes();
    function getDropElement2() {
      const {dropElement} = globalThis;
      return dropElement;
    }
    function setDropElement(dropElement) {
      Object.assign(globalThis, {
        dropElement
      });
    }
    function resetDropElement() {
      const dropElement = null;
      setDropElement(dropElement);
    }
    Object.assign(globalThis, {
      getDropElement: getDropElement2,
      setDropElement,
      resetDropElement
    });
    resetDropElement();
    function drop(event, element, dragElement, aborted, done) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE;
      this.callCustomHandlersAsync(customEventType, event, element, dragElement, aborted, done);
    }
    function dragOut(event, element, dragElement) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE;
      this.callCustomHandlers(customEventType, event, element, dragElement);
    }
    function dragOver(event, element, dragElement) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE;
      this.callCustomHandlers(customEventType, event, element, dragElement);
    }
    function enableDrop() {
      this.onMouseOut(mouseOutHandler, this);
      this.onMouseOver(mouseOverHandler, this);
    }
    function disableDrop() {
      this.offMouseOut(mouseOutHandler, this);
      this.offMouseOver(mouseOverHandler, this);
    }
    function onCustomDrop(dropCustomHandler, element) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE, customHandler = dropCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDrop(dropCustomHandler, element) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE, customHandler = dropCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomDragOut(dragOutCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE, customHandler = dragOutCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDragOut(dragOutCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE, customHandler = dragOutCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomDragOver(dragOverCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE, customHandler = dragOverCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDragOver(dragOverCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE, customHandler = dragOverCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    var _default = {
      drop,
      dragOut,
      dragOver,
      enableDrop,
      disableDrop,
      onCustomDrop,
      offCustomDrop,
      onCustomDragOut,
      offCustomDragOut,
      onCustomDragOver,
      offCustomDragOver
    };
    function mouseOutHandler(event, element) {
      const dragElement = getDragElement();
      if (dragElement !== null) {
        resetDropElement();
        this.dragOut(event, element, dragElement);
      }
      event.stopPropagation();
    }
    function mouseOverHandler(event, element) {
      const dragElement = getDragElement();
      if (dragElement !== null) {
        const dropElement = this, dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
          return;
        }
        setDropElement(dropElement);
        this.dragOver(event, element, dragElement);
      }
      event.stopPropagation();
    }
  });

  // node_modules/easy-drag-and-drop/lib/element/drag.js
  var require_drag2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _drag = /* @__PURE__ */ _interop_require_default(require_drag());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DragElement = class extends _easy.Element {
      getReferences() {
        const {references = []} = this.properties;
        return references;
      }
      didMount() {
        this.enableDrag();
      }
      willUnmount() {
        this.disableDrag();
      }
    };
    __publicField(DragElement, "ignoredProperties", [
      "references"
    ]);
    Object.assign(DragElement.prototype, _drag.default);
    var _default = (0, _easywithstyle.default)(DragElement)`

  .dragging {
    z-index: 1;
    position: fixed;
    pointer-events: none;
  }
  
`;
  });

  // node_modules/easy-drag-and-drop/lib/element/drop.js
  var require_drop2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DropElement;
      }
    });
    var _easy = require_lib();
    var _drop = /* @__PURE__ */ _interop_require_default(require_drop());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DropElement = class extends _easy.Element {
      getReference() {
        const {reference = null} = this.properties;
        return reference;
      }
      didMount() {
        this.enableDrop();
      }
      willUnmount() {
        this.disableDrop();
      }
    };
    __publicField(DropElement, "ignoredProperties", [
      "reference"
    ]);
    Object.assign(DropElement.prototype, _drop.default);
  });

  // node_modules/easy-drag-and-drop/lib/index.js
  var require_lib8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DragElement() {
        return _drag1.default;
      },
      get DropElement() {
        return _drop1.default;
      },
      get customEventTypes() {
        return _customEventTypes.default;
      },
      get dragMixins() {
        return _drag.default;
      },
      get dropMixins() {
        return _drop.default;
      }
    });
    var _drag = /* @__PURE__ */ _interop_require_default(require_drag());
    var _drop = /* @__PURE__ */ _interop_require_default(require_drop());
    var _drag1 = /* @__PURE__ */ _interop_require_default(require_drag2());
    var _drop1 = /* @__PURE__ */ _interop_require_default(require_drop2());
    var _customEventTypes = /* @__PURE__ */ _interop_require_default(require_customEventTypes());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-layout/lib/div/sizeable.js
  var require_sizeable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SizeableDiv = class extends _easy.Element {
    };
    __publicField(SizeableDiv, "tagName", "div");
    __publicField(SizeableDiv, "defaultProperties", {
      className: "sizeable"
    });
    var _default = (0, _easywithstyle.default)(SizeableDiv)`

  display: flex;
  
`;
  });

  // node_modules/easy-layout/lib/div/splitter.js
  var require_splitter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _easydraganddrop = require_lib8();
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SplitterDiv = class extends _easy.Element {
      stopDragCustomHandler = (event, element, dropElement, aborted, done) => {
        (0, _cursor.resetCursor)();
        done();
      };
      mouseOutHandler = (event, element) => {
        (0, _cursor.resetCursor)();
      };
      getSizeableDiv() {
        let sizeableDiv;
        const nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement(), nextSiblingElementSizeableDiv = nextSiblingElement instanceof _sizeable.default, previousSiblingElementSizeableDiv = previousSiblingElement instanceof _sizeable.default;
        if (nextSiblingElementSizeableDiv) {
          sizeableDiv = nextSiblingElement;
        }
        if (previousSiblingElementSizeableDiv) {
          sizeableDiv = previousSiblingElement;
        }
        return sizeableDiv;
      }
      getDirection() {
        let direction;
        const nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement(), nextSiblingElementSizeableDiv = nextSiblingElement instanceof _sizeable.default, previousSiblingElementSizeableDiv = previousSiblingElement instanceof _sizeable.default;
        if (nextSiblingElementSizeableDiv) {
          direction = 1;
        }
        if (previousSiblingElementSizeableDiv) {
          direction = -1;
        }
        return direction;
      }
      getReferences() {
        const references = [];
        return references;
      }
      enable() {
        const dragEnabled = this.isDragEnabled();
        if (!dragEnabled) {
          this.enableDrag();
          this.onCustomDrag(this.dragCustomHandler);
          this.onCustomStopDrag(this.stopDragCustomHandler);
          this.onCustomStartDrag(this.startDragCustomHandler);
        }
      }
      disable() {
        const dragEnabled = this.isDragEnabled();
        if (dragEnabled) {
          this.offCustomStartDrag(this.startDragCustomHandler);
          this.offCustomStopDrag(this.stopDragCustomHandler);
          this.offCustomDrag(this.dragCustomHandler);
          this.disableDrag();
        }
      }
      isDisabled() {
        const dragEnabled = this.isDragEnabled(), disabled = !dragEnabled;
        return disabled;
      }
      didMount() {
        const {disabled = false} = this.properties;
        if (!disabled) {
          this.enable();
        }
        this.onMouseOver(this.mouseOverHandler);
        this.onMouseOut(this.mouseOutHandler);
      }
      willUnmount() {
        const disabled = this.isDisabled();
        this.offMouseOut(this.mouseOutHandler);
        this.offMouseOver(this.mouseOverHandler);
        if (!disabled) {
          this.disable();
        }
      }
      initialise() {
        this.setInitialState();
      }
    };
    __publicField(SplitterDiv, "tagName", "div");
    __publicField(SplitterDiv, "ignoredProperties", [
      "disabled"
    ]);
    __publicField(SplitterDiv, "defaultProperties", {
      className: "splitter"
    });
    Object.assign(SplitterDiv.prototype, _easydraganddrop.dragMixins);
    var _default = (0, _easywithstyle.default)(SplitterDiv)`

  flex-shrink: 0;

`;
  });

  // node_modules/easy-layout/lib/div/splitter/vertical.js
  var require_vertical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VerticalSplitter = class extends _splitter.default {
      startDragCustomHandler = (event, element) => {
        const sizeableDiv = this.getSizeableDiv(), sizeableDivWidth = sizeableDiv.getWidth(), previousSizeableDivWidth = sizeableDivWidth;
        this.setPreviousSizeableDivWidth(previousSizeableDivWidth);
        this.setCursor();
      };
      dragCustomHandler = (event, element, relativeMouseTop, relativeMouseLeft) => {
        const direction = this.getDirection(), sizeableDiv = this.getSizeableDiv(), previousSizeableDivWidth = this.getPreviousSizeableDivWidth(), sizeableDivWidth = previousSizeableDivWidth - direction * relativeMouseLeft, width = sizeableDivWidth;
        sizeableDiv.setWidth(width);
      };
      mouseOverHandler = (event, element) => {
        this.setCursor();
      };
      setCursor() {
        const disabled = this.isDisabled();
        if (!disabled) {
          (0, _cursor.columnResizeCursor)();
        }
      }
      getPreviousSizeableDivWidth() {
        const {previousSizeableDivWidth} = this.getState();
        return previousSizeableDivWidth;
      }
      setPreviousSizeableDivWidth(previousSizeableDivWidth) {
        this.updateState({
          previousSizeableDivWidth
        });
      }
      setInitialState() {
        const previousSizeableDivWidth = null;
        this.setState({
          previousSizeableDivWidth
        });
      }
    };
    __publicField(VerticalSplitter, "defaultProperties", {
      className: "vertical"
    });
    var _default = (0, _easywithstyle.default)(VerticalSplitter)`

  width: 1rem;

`;
  });

  // node_modules/easy-layout/lib/div/splitter/horizontal.js
  var require_horizontal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var HorizontalSplitter = class extends _splitter.default {
      startDragCustomHandler = (event, element) => {
        const sizeableDiv = this.getSizeableDiv(), sizeableDivHeight = sizeableDiv.getHeight(), previousSizeableDivHeight = sizeableDivHeight;
        this.setPreviousSizeableDivHeight(previousSizeableDivHeight);
        this.setCursor();
      };
      dragCustomHandler = (event, element, relativeMouseTop, relativeMouseLeft) => {
        const direction = this.getDirection(), sizeableDiv = this.getSizeableDiv(), previousSizeableDivHeight = this.getPreviousSizeableDivHeight(), sizeableDivHeight = previousSizeableDivHeight - direction * relativeMouseTop, height = sizeableDivHeight;
        sizeableDiv.setHeight(height);
      };
      mouseOverHandler = (event, element) => {
        this.setCursor();
      };
      setCursor() {
        const disabled = this.isDisabled();
        if (!disabled) {
          (0, _cursor.rowResizeCursor)();
        }
      }
      getPreviousSizeableDivHeight() {
        const {previousSizeableDivHeight} = this.getState();
        return previousSizeableDivHeight;
      }
      setPreviousSizeableDivHeight(previousSizeableDivHeight) {
        this.updateState({
          previousSizeableDivHeight
        });
      }
      setInitialState() {
        const previousSizeableDivHeight = null;
        this.setState({
          previousSizeableDivHeight
        });
      }
    };
    __publicField(HorizontalSplitter, "defaultProperties", {
      className: "horizontal"
    });
    var _default = (0, _easywithstyle.default)(HorizontalSplitter)`

  height: 1rem;

`;
  });

  // node_modules/easy-layout/lib/index.js
  var require_lib9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ColumnDiv() {
        return _column.default;
      },
      get ColumnsDiv() {
        return _columns.default;
      },
      get HorizontalSplitterDiv() {
        return _horizontal.default;
      },
      get RowDiv() {
        return _row.default;
      },
      get RowsDiv() {
        return _rows.default;
      },
      get SizeableDiv() {
        return _sizeable.default;
      },
      get SplitterDiv() {
        return _splitter.default;
      },
      get VerticalSplitterDiv() {
        return _vertical.default;
      },
      get cursor() {
        return _cursor.default;
      }
    });
    var _cursor = /* @__PURE__ */ _interop_require_default(require_cursor());
    var _row = /* @__PURE__ */ _interop_require_default(require_row());
    var _rows = /* @__PURE__ */ _interop_require_default(require_rows());
    var _column = /* @__PURE__ */ _interop_require_default(require_column());
    var _columns = /* @__PURE__ */ _interop_require_default(require_columns());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable());
    var _vertical = /* @__PURE__ */ _interop_require_default(require_vertical());
    var _horizontal = /* @__PURE__ */ _interop_require_default(require_horizontal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/constants.js
  var require_constants9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BREAK_MESSAGE() {
        return BREAK_MESSAGE;
      },
      get DEBUG_LEVEL() {
        return DEBUG_LEVEL;
      },
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ERROR_LEVEL() {
        return ERROR_LEVEL;
      },
      get INFO_LEVEL() {
        return INFO_LEVEL;
      },
      get LEVELS() {
        return LEVELS;
      },
      get LEVEL_MAXIMUM_LENGTH() {
        return LEVEL_MAXIMUM_LENGTH;
      },
      get SINGLE_SPACE() {
        return SINGLE_SPACE;
      },
      get TRACE_LEVEL() {
        return TRACE_LEVEL;
      },
      get WARNING_LEVEL() {
        return WARNING_LEVEL;
      }
    });
    var _necessary = require_browser();
    var {TRACE_LEVEL, DEBUG_LEVEL, INFO_LEVEL, WARNING_LEVEL, ERROR_LEVEL} = _necessary.levels;
    var LEVELS = [
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL
    ];
    var EMPTY_STRING = "";
    var SINGLE_SPACE = " ";
    var DOUBLE_SPACE = "  ";
    var BREAK_MESSAGE = ":: BREAK ::";
    var LEVEL_MAXIMUM_LENGTH = 7;
  });

  // node_modules/occam-languages/lib/log.js
  var require_log = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Log;
      }
    });
    var _constants = require_constants9();
    var [TRACE_LEVEL, DEBUG_LEVEL, INFO_LEVEL, WARNING_LEVEL, ERROR_LEVEL] = _constants.LEVELS;
    var Log = class {
      constructor(messages, logLevel, follow) {
        this.messages = messages;
        this.logLevel = logLevel;
        this.follow = follow;
      }
      getMessages() {
        return this.messages;
      }
      getLogLevel() {
        return this.logLevel;
      }
      getFollow() {
        return this.follow;
      }
      trace(message) {
        const level = TRACE_LEVEL;
        this.write(level, message);
      }
      debug(message) {
        const level = DEBUG_LEVEL;
        this.write(level, message);
      }
      info(message) {
        const level = INFO_LEVEL;
        this.write(level, message);
      }
      warning(message) {
        const level = WARNING_LEVEL;
        this.write(level, message);
      }
      error(message) {
        const level = ERROR_LEVEL;
        this.write(level, message);
      }
      write(level, message, filePath = null, lineIndex = null) {
        const levelIndex = _constants.LEVELS.indexOf(level), logLevelIndex = _constants.LEVELS.indexOf(this.logLevel);
        if (levelIndex < logLevelIndex) {
          return;
        }
        message = formatMessage(level, message, filePath, lineIndex);
        this.follow ? console.log(message) : this.messages.push(message);
      }
      static fromNothing() {
        const messages = null, logLevel = TRACE_LEVEL, follow = true, log = new Log(messages, logLevel, follow);
        return log;
      }
      static fromFollowAndLogLevel(follow, logLevel) {
        const messages = follow ? null : [], log = new Log(messages, logLevel, follow);
        return log;
      }
    };
    function formatMessage(level, message, filePath, lineIndex) {
      let formattedMessage = _constants.EMPTY_STRING;
      const leftPaddedLevel = leftPadLevel(level), upperCaseLeftPaddedLevel = leftPaddedLevel.toUpperCase();
      formattedMessage += `${upperCaseLeftPaddedLevel}: `;
      if (filePath !== null) {
        formattedMessage += `${filePath} `;
      }
      if (lineIndex !== null) {
        formattedMessage += `[${lineIndex}] `;
      }
      if (filePath !== null || lineIndex !== null) {
        formattedMessage += `- `;
      }
      formattedMessage += message;
      message = formattedMessage;
      return message;
    }
    function leftPadLevel(level) {
      const maximumLength = _constants.LEVEL_MAXIMUM_LENGTH, leftPaddedLevel = leftPad(level, maximumLength);
      return leftPaddedLevel;
    }
    function leftPad(string, maximumLength) {
      const stringLength = string.length, length = maximumLength - stringLength, indent = _constants.SINGLE_SPACE.repeat(length), leftPaddedString = `${indent}${string}`;
      return leftPaddedString;
    }
  });

  // node_modules/occam-languages/lib/element.js
  var require_element4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Element;
      }
    });
    var Element = class {
      constructor(context2, string, node) {
        this.context = context2;
        this.string = string;
        this.node = node;
      }
      getContext() {
        return this.context;
      }
      getString() {
        return this.string;
      }
      getNode() {
        return this.node;
      }
      setContext(context2) {
        this.context = context2;
      }
      setString(string) {
        this.string = string;
      }
      setNode(node) {
        this.node = node;
      }
      async break(context2) {
        await context2.break(this.node);
      }
      matchNode(node) {
        return this.node.match(node);
      }
    };
  });

  // node_modules/occam-languages/lib/context.js
  var require_context = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Context;
      }
    });
    var _constants = require_constants9();
    var Context = class {
      constructor(context2) {
        this.context = context2;
      }
      getContext() {
        return this.context;
      }
      getDepth() {
        let depth = this.context.getDepth();
        depth++;
        return depth;
      }
      getReleaseContext() {
        return this.context.getReleaseContext();
      }
      nodesAsString(node) {
        return this.context.nodesAsString(node);
      }
      nodeAsString(node) {
        return this.context.nodeAsString(node);
      }
      trace(message) {
        const level = _constants.TRACE_LEVEL;
        this.writeToLog(level, message);
      }
      debug(message) {
        const level = _constants.DEBUG_LEVEL;
        this.writeToLog(level, message);
      }
      info(message) {
        const level = _constants.INFO_LEVEL;
        this.writeToLog(level, message);
      }
      warning(message) {
        const level = _constants.WARNING_LEVEL;
        this.writeToLog(level, message);
      }
      error(message) {
        const level = _constants.ERROR_LEVEL;
        this.writeToLog(level, message);
      }
      writeToLog(level, message) {
        const depth = this.getDepth(), indent = _constants.DOUBLE_SPACE.repeat(depth);
        message = `${indent}${message}`;
        const releaseContext = this.getReleaseContext();
        releaseContext.writeToLog(level, message);
      }
      async break(node) {
        await this.context.break(node);
      }
      static fromNothing(Class, ...remainingArguments) {
        let context2 = remainingArguments.pop();
        context2 = new Class(context2, ...remainingArguments);
        return context2;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/lineIndex.js
  var require_lineIndex = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lineIndexFromNodeAndTokens", {
      enumerable: true,
      get: function() {
        return lineIndexFromNodeAndTokens;
      }
    });
    function lineIndexFromNodeAndTokens(node, tokens) {
      let lineIndex = 0;
      const firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens);
      tokens.some((token, tokenIndex) => {
        const tokenEndOfLineToken = token.isEndOfLineToken();
        if (tokenEndOfLineToken) {
          lineIndex += 1;
        }
        if (tokenIndex === firstSignificantTokenIndex) {
          return true;
        }
      });
      return lineIndex;
    }
  });

  // node_modules/occam-languages/lib/utilities/node.js
  var require_node4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get nodeAsString() {
        return nodeAsString;
      },
      get nodesAsString() {
        return nodesAsString;
      }
    });
    var _constants = require_constants9();
    function nodeAsString(node, tokens) {
      let string;
      tokens = nodeAsTokens(node, tokens);
      string = tokensAsString(tokens);
      string = trimString(string);
      return string;
    }
    function nodesAsString(nodes, tokens) {
      const string = nodes.reduce((string2, node) => {
        const nodeString = nodeAsString(node, tokens);
        string2 = string2 === null ? nodeString : `${string2}, ${nodeString}`;
        return string2;
      }, null);
      return string;
    }
    var _default = {
      nodeAsString,
      nodesAsString
    };
    function trimString(string) {
      string = string.replace(/\s+$/, _constants.EMPTY_STRING);
      return string;
    }
    function tokensAsString(tokens) {
      const string = tokens.reduce((string2, token) => {
        const content = token.getContent();
        string2 = `${string2}${content}`;
        return string2;
      }, _constants.EMPTY_STRING);
      return string;
    }
    function nodeAsTokens(node, tokens) {
      const nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        const terminalNode = node;
        tokens = terminalNodeAsTokens(terminalNode, tokens);
      } else {
        const nonTerminalNode = node;
        tokens = nonTerminalNodeAsTokens(nonTerminalNode, tokens);
      }
      return tokens;
    }
    function terminalNodeAsTokens(terminalNode, tokens) {
      const significantToken = terminalNode.getSignificantToken(), token = significantToken;
      tokens = [
        token
      ];
      return tokens;
    }
    function nonTerminalNodeAsTokens(nonTerminalNode, tokens) {
      const lastSignificantTokenIndex = nonTerminalNode.getLastSignificantTokenIndex(tokens), firstSignificantTokenIndex = nonTerminalNode.getFirstSignificantTokenIndex(tokens), start = firstSignificantTokenIndex, end = lastSignificantTokenIndex + 1;
      tokens = tokens.slice(start, end);
      return tokens;
    }
  });

  // node_modules/occam-languages/lib/context/file.js
  var require_file = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FileContext;
      }
    });
    var _context = /* @__PURE__ */ _interop_require_default(require_context());
    var _lineIndex = require_lineIndex();
    var _node = require_node4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FileContext = class extends _context.default {
      constructor(context2, filePath, tokens, node) {
        super(context2);
        this.filePath = filePath;
        this.tokens = tokens;
        this.node = node;
      }
      getFilePath() {
        return this.filePath;
      }
      getTokens() {
        return this.tokens;
      }
      getNode() {
        return this.node;
      }
      getLexer() {
        const lexer = null;
        return lexer;
      }
      getParser() {
        const parser = null;
        return parser;
      }
      getTypePrefix() {
        const context2 = this.getContext(), typePrefix = context2.getTypePrefix();
        return typePrefix;
      }
      matchFilePath(filePath) {
        const filePathMatches = this.filePath === filePath;
        return filePathMatches;
      }
      findFile() {
        const releaseContext = this.getReleaseContext(), file = releaseContext.findFile(this.filePath);
        return file;
      }
      nodeAsString(node) {
        const string = (0, _node.nodeAsString)(node, this.tokens);
        return string;
      }
      nodesAsString(nodes) {
        const string = (0, _node.nodesAsString)(nodes, this.tokens);
        return string;
      }
      prepare() {
        if (this.tokens !== null) {
          return;
        }
        const file = this.findFile(), lexer = this.getLexer(), parser = this.getParser(), content = file.getContent();
        this.tokens = lexer.tokenise(content);
        this.node = parser.parse(this.tokens);
      }
      initialise(json) {
        const {content} = json, lexer = this.getLexer(), parser = this.getParser();
        this.tokens = lexer.tokenise(content);
        this.node = parser.parse(this.tokens);
        this.clear();
        this.addProcedures();
      }
      async break(node) {
        const filePath = this.filePath, lineIndex = (0, _lineIndex.lineIndexFromNodeAndTokens)(node, this.tokens), releaseContext = this.getReleaseContext();
        await releaseContext.break(filePath, lineIndex);
      }
      async verify() {
        let verifies = false;
        this.prepare();
        if (this.node === null) {
          this.warning(`Unable to verify the '${this.filePath}' file because it cannot be parsed.`);
        } else {
          this.debug(`Verifying the '${this.filePath}' file...`);
          const fileVerifies = await this.verifyFile();
          if (fileVerifies) {
            verifies = true;
          }
          verifies ? this.complete() : this.clear();
          if (verifies) {
            this.info(`...verified the '${this.filePath}' file.`);
          }
        }
        return verifies;
      }
      static fromFile(Class, file, ...remainingArguments) {
        const filePath = file.getPath(), tokens = null, node = null, context2 = remainingArguments.pop(), fileContext = new Class(context2, filePath, tokens, node, ...remainingArguments);
        return fileContext;
      }
      static fromJSON(Class, json, ...remainingArguments) {
        const {filePath} = json, tokens = null, node = null, context2 = remainingArguments.pop(), fileContext = new Class(context2, filePath, tokens, node, ...remainingArguments);
        return fileContext;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/asynchronous.js
  var require_asynchronous2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get asyncBackwardsEvery() {
        return asyncBackwardsEvery;
      },
      get asyncEvery() {
        return asyncEvery;
      },
      get asyncForEach() {
        return asyncForEach;
      },
      get asyncForwardsEvery() {
        return asyncForwardsEvery;
      },
      get asyncReduce() {
        return asyncReduce;
      },
      get asyncResolve() {
        return asyncResolve;
      },
      get asyncSome() {
        return asyncSome;
      },
      get default() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var {filter} = _necessary.arrayUtilities;
    async function asyncSome(array, callback) {
      let result = false;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        result = await callback(element, index, array);
        if (result) {
          break;
        }
      }
      return result;
    }
    async function asyncEvery(array, callback) {
      let result = true;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        result = await callback(element, index, array);
        if (!result) {
          break;
        }
      }
      return result;
    }
    async function asyncReduce(array, callback, initialValue) {
      let value = initialValue;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        value = await callback(value, element, index, array);
      }
      return value;
    }
    async function asyncForEach(array, callback) {
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        await callback(element, index, array);
      }
    }
    async function asyncResolve(arrayA, arrayB, callback) {
      let resolved;
      arrayA = [
        ...arrayA
      ];
      for (; ; ) {
        const arrayALength2 = arrayA.length;
        if (arrayALength2 === 0) {
          break;
        }
        let resolved2 = false;
        await asyncForEach(arrayA, async (elementA, index) => {
          const passed = await callback(elementA, index, arrayA);
          if (passed) {
            const elementB = elementA;
            arrayB.push(elementB);
            resolved2 = true;
          }
        });
        if (!resolved2) {
          break;
        }
        filter(arrayA, (elementA) => {
          const arrayBIncludesElementA = arrayB.includes(elementA);
          if (!arrayBIncludesElementA) {
            return true;
          }
        });
      }
      const arrayALength = arrayA.length;
      resolved = arrayALength === 0;
      return resolved;
    }
    async function asyncForwardsEvery(array, callback) {
      const length = array.length;
      for (let index = 0; index < length; index++) {
        const element = array[index], passed = await callback(element, index, array);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    async function asyncBackwardsEvery(array, callback) {
      const length = array.length;
      for (let index = length - 1; index >= 0; index--) {
        const element = array[index], passed = await callback(element, index, array);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    var _default = {
      asyncSome,
      asyncEvery,
      asyncReduce,
      asyncForEach,
      asyncResolve,
      asyncForwardsEvery,
      asyncBackwardsEvery
    };
  });

  // node_modules/occam-languages/lib/utilities/verify.js
  var require_verify = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get verifyFileContexts() {
        return verifyFileContexts;
      },
      get verifyTypePrefixes() {
        return verifyTypePrefixes;
      }
    });
    var _necessary = require_browser();
    var _asynchronous = require_asynchronous2();
    var {first: first2, filter, compress} = _necessary.arrayUtilities;
    async function verifyFileContexts(fileContexts, verifiedFileContexts) {
      const resolved = await (0, _asynchronous.asyncResolve)(fileContexts, verifiedFileContexts, async (fileContext) => {
        const fileContextVerifies = await fileContext.verify();
        if (fileContextVerifies) {
          return true;
        }
      }), fileContextsVerify = resolved;
      return fileContextsVerify;
    }
    function verifyTypePrefixes(typePrefixes, releaseContext) {
      let typePrefixesVerify = true;
      const typePrefixesLength = typePrefixes.length, compressedTypePrefixes = [
        ...typePrefixes
      ];
      compress(compressedTypePrefixes, (typePrefixA, typePrefixB) => {
        const typePrefixAName = typePrefixA.getName(), typePrefixBName = typePrefixB.getName();
        if (typePrefixAName !== typePrefixBName) {
          return true;
        }
      });
      const compressTypePrefixesLength = compressedTypePrefixes.length;
      if (typePrefixesLength > compressTypePrefixesLength) {
        filter(compressedTypePrefixes, (typePrefix2) => {
          const typePrefixesIncludesTypePrefix = typePrefixes.includes(typePrefix2);
          if (!typePrefixesIncludesTypePrefix) {
            return true;
          }
        });
        const firstTypePrefix = first2(typePrefixes), typePrefix = firstTypePrefix, typePrefixString = typePrefix.getString();
        releaseContext.info(`The '${typePrefixString}' type prefix is duplicated.`);
        typePrefixesVerify = false;
      }
      return typePrefixesVerify;
    }
  });

  // node_modules/occam-custom-grammars/lib/grammarNames.js
  var require_grammarNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DEFAULT_CUSTOM_GRAMMAR_NAME", {
      enumerable: true,
      get: function() {
        return DEFAULT_CUSTOM_GRAMMAR_NAME;
      }
    });
    var DEFAULT_CUSTOM_GRAMMAR_NAME = "Default";
  });

  // node_modules/occam-custom-grammars/lib/ruleNames.js
  var require_ruleNames3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get STATEMENT_RULE_NAME() {
        return STATEMENT_RULE_NAME;
      },
      get TERM_RULE_NAME() {
        return TERM_RULE_NAME;
      },
      get default() {
        return _default;
      }
    });
    var TERM_RULE_NAME = "term";
    var STATEMENT_RULE_NAME = "statement";
    var _default = {
      TERM_RULE_NAME,
      STATEMENT_RULE_NAME
    };
  });

  // node_modules/occam-custom-grammars/lib/vocabularyNames.js
  var require_vocabularyNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get SYMBOL_VOCABULARY_NAME() {
        return SYMBOL_VOCABULARY_NAME;
      },
      get TYPE_VOCABULARY_NAME() {
        return TYPE_VOCABULARY_NAME;
      },
      get default() {
        return _default;
      }
    });
    var TYPE_VOCABULARY_NAME = "type";
    var SYMBOL_VOCABULARY_NAME = "symbol";
    var _default = {
      TYPE_VOCABULARY_NAME,
      SYMBOL_VOCABULARY_NAME
    };
  });

  // node_modules/occam-custom-grammars/lib/constants.js
  var require_constants10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BASE_TYPE_SYMBOL() {
        return BASE_TYPE_SYMBOL;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get NONSENSE_RULE_NAME() {
        return NONSENSE_RULE_NAME;
      },
      get STUFF_RULE_NAME() {
        return STUFF_RULE_NAME;
      },
      get UNASSIGNED_TYPE() {
        return UNASSIGNED_TYPE;
      },
      get VERTICAL_BAR() {
        return VERTICAL_BAR;
      },
      get VERTICAL_SPACE() {
        return VERTICAL_SPACE;
      }
    });
    var EMPTY_STRING = "";
    var VERTICAL_BAR = "|";
    var VERTICAL_SPACE = `

`;
    var UNASSIGNED_TYPE = "unassigned";
    var STUFF_RULE_NAME = "stuff";
    var BASE_TYPE_SYMBOL = "<>";
    var NONSENSE_RULE_NAME = "nonsense";
  });

  // node_modules/occam-custom-grammars/lib/customGrammar.js
  var require_customGrammar = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammar;
      }
    });
    var _constants = require_constants10();
    var _grammarNames = require_grammarNames();
    var _ruleNames = require_ruleNames3();
    var _vocabularyNames = require_vocabularyNames();
    var CustomGrammar = class {
      constructor(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary) {
        this.name = name;
        this.termBNF = termBNF;
        this.statementBNF = statementBNF;
        this.typeVocabulary = typeVocabulary;
        this.symbolVocabulary = symbolVocabulary;
      }
      getName() {
        return this.name;
      }
      getTermBNF() {
        return this.termBNF;
      }
      getStatementBNF() {
        return this.statementBNF;
      }
      getTypeVocabulary() {
        return this.typeVocabulary;
      }
      getSymbolVocabulary() {
        return this.symbolVocabulary;
      }
      getBNF(ruleName) {
        let bnf;
        switch (ruleName) {
          case _ruleNames.TERM_RULE_NAME:
            bnf = this.termBNF;
            break;
          case _ruleNames.STATEMENT_RULE_NAME:
            bnf = this.statementBNF;
            break;
        }
        return bnf;
      }
      getVocabulary(vocabularyName) {
        let vocabulary;
        switch (vocabularyName) {
          case _vocabularyNames.TYPE_VOCABULARY_NAME:
            vocabulary = this.typeVocabulary;
            break;
          case _vocabularyNames.SYMBOL_VOCABULARY_NAME:
            vocabulary = this.symbolVocabulary;
            break;
        }
        return vocabulary;
      }
      getVocabularies() {
        const vocabularies = [
          this.typeVocabulary,
          this.symbolVocabulary
        ];
        return vocabularies;
      }
      isDefaultCustomGrammar() {
        const defaultCustomGrammar = this.name === _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
        return defaultCustomGrammar;
      }
      setName(name) {
        this.name = name;
      }
      setBNF(ruleName, bnf) {
        switch (ruleName) {
          case _ruleNames.TERM_RULE_NAME:
            this.termBNF = bnf;
            break;
          case _ruleNames.STATEMENT_RULE_NAME:
            this.statementBNF = bnf;
            break;
        }
      }
      setVocabulary(vocabularyName, vocabulary) {
        switch (vocabularyName) {
          case _vocabularyNames.TYPE_VOCABULARY_NAME:
            this.typeVocabulary = vocabulary;
            break;
          case _vocabularyNames.SYMBOL_VOCABULARY_NAME:
            this.symbolVocabulary = vocabulary;
            break;
        }
      }
      resetBNF(ruleName) {
        const bnf = _constants.EMPTY_STRING;
        this.setBNF(ruleName, bnf);
      }
      resetVocabulary(vocabularyName) {
        const vocabulary = _constants.EMPTY_STRING;
        this.setVocabulary(vocabularyName, vocabulary);
      }
      update(ruleName, bnf, vocabularyName, vocabulary) {
        this.setBNF(ruleName, bnf);
        this.setVocabulary(vocabularyName, vocabulary);
      }
      toJSON() {
        const name = this.name, termBNF = this.termBNF, statementBNF = this.statementBNF, typeVocabulary = this.typeVocabulary, symbolVocabulary = this.symbolVocabulary, json = {
          name,
          termBNF,
          statementBNF,
          typeVocabulary,
          symbolVocabulary
        };
        return json;
      }
      static fromJSON(json) {
        const {name, termBNF, statementBNF, typeVocabulary, symbolVocabulary} = json, customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
      static fromName(name) {
        const termBNF = _constants.EMPTY_STRING, statementBNF = _constants.EMPTY_STRING, typeVocabulary = _constants.EMPTY_STRING, symbolVocabulary = _constants.EMPTY_STRING, customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
      static fromNameTermBNFStatementBNFTypeVocabularyAndSymbolVocabulary(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary) {
        const customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
    };
  });

  // node_modules/occam-custom-grammars/lib/customGrammar/default.js
  var require_default = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name2 in all)
        Object.defineProperty(target, name2, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name2).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get statementBNF() {
        return statementBNF;
      },
      get symbolVocabulary() {
        return symbolVocabulary;
      },
      get termBNF() {
        return termBNF;
      },
      get typeVocabulary() {
        return typeVocabulary;
      }
    });
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _grammarNames = require_grammarNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var termBNF = `term                                 ::=  "(" argument ")"

                                       |  variable 
                                       
                                       ;`;
    var statementBNF = `statement                            ::=  "(" metaArgument ")" 
                                                  
                                       |  equality

                                       |  judgement

                                       |  typeAssertion 
                                                  
                                       |  definedAssertion  

                                       |  containedAssertion  
                                       
                                       |  satisfiesAssertion

                                       |  subproofAssertion         

                                       |  propertyAssertion  

                                       |  metavariable ( frameSubstitution | termSubstitution )?

                                       ;

equality                             ::=  term "=" term ;

typeAssertion                        ::=  term ":" type ;

definedAssertion                     ::=  ( frame | term ) "is" ( "defined" | "undefined" );

containedAssertion                   ::=  ( frame | term ) "is" ( "present" | "missing" ) "in" statement ;

satisfiesAssertion                   ::=  signature "satisfies" metavariable ;  

subproofAssertion                    ::=  "[" statement ( "," statement )* "]" "..." statement ;

propertyAssertion                    ::=  term "is" ( "a" | "an" ) propertyRelation ;

propertyRelation                     ::=  property "of" term ;

judgement                            ::=  frame "|"<NO_WHITESPACE>"-" assumption ;

frame                                ::=  "[" ( ( assumption ( "," assumption )* ) | metavariable ) "]" ;
 
assumption                           ::=  metavariable "::" statement ;

termSubstitution                     ::=  "[" term "for" term "]";

frameSubstitution                    ::=  "[" frame "for" frame "]";

statementSubstitution                ::=  "[" statement "for" statement "]";

referenceSubstitution                ::=  "[" reference "for" reference "]";`;
    var typeVocabulary = "";
    var symbolVocabulary = "";
    var name = _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
    var json = {
      name,
      termBNF,
      statementBNF,
      typeVocabulary,
      symbolVocabulary
    };
    var defaultCustomGrammar = _customGrammar.default.fromJSON(json);
    var _default = defaultCustomGrammar;
  });

  // node_modules/occam-grammar-utilities/lib/example/lexer/example.js
  var require_example = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExampleLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _ExampleLexer = class extends _occamlexers.CommonLexer {
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_ExampleLexer, entries);
      }
    };
    var ExampleLexer = _ExampleLexer;
    __publicField(ExampleLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(ExampleLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(ExampleLexer, "RegularExpressionToken", null);
    __publicField(ExampleLexer, "EndOfLineCommentToken", null);
    __publicField(ExampleLexer, "SingleLineCommentToken", null);
    __publicField(ExampleLexer, "EndOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "StartOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(ExampleLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammar-utilities/lib/example/parser/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamparsers = require_lib4();
    var A = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(A, ruleName, childNodes, opacity, precedence);
      }
    };
    var B = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(B, ruleName, childNodes, opacity, precedence);
      }
    };
    var C = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(C, ruleName, childNodes, opacity, precedence);
      }
    };
    var D = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(D, ruleName, childNodes, opacity, precedence);
      }
    };
    var E = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(E, ruleName, childNodes, opacity, precedence);
      }
    };
    var F = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(F, ruleName, childNodes, opacity, precedence);
      }
    };
    var S = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(S, ruleName, childNodes, opacity, precedence);
      }
    };
    var T = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(T, ruleName, childNodes, opacity, precedence);
      }
    };
    var V = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(V, ruleName, childNodes, opacity, precedence);
      }
    };
    var NonTerminalNodeMap = {
      A,
      B,
      C,
      D,
      E,
      F,
      S,
      T,
      V
    };
    var _default = NonTerminalNodeMap;
  });

  // node_modules/occam-grammar-utilities/lib/example/parser/example.js
  var require_example2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExampleParser;
      }
    });
    var _occamparsers = require_lib4();
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ExampleParser = class extends _occamparsers.CommonParser {
    };
    __publicField(ExampleParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
  });

  // node_modules/occam-grammar-utilities/lib/cycle.js
  var require_cycle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Cycle;
      }
    });
    var _necessary = require_browser();
    var {COMMA_CHARACTER} = _necessary.characters;
    var Cycle = class {
      constructor(edges) {
        this.edges = edges;
      }
      getEdges() {
        return this.edges;
      }
      getLength() {
        const length = this.edges.length;
        return length;
      }
      getEdge(index) {
        const edge = this.edges[index];
        return edge;
      }
      getVertexes() {
        const vertexes = this.mapEdge((edge) => {
          const sourceVertex = edge.getSourceVertex(), vertex = sourceVertex;
          return vertex;
        });
        return vertexes;
      }
      mapEdge(callback) {
        return this.edges.map(callback);
      }
      everyEdge(callback) {
        return this.edges.every(callback);
      }
      forEachEdge(callback) {
        return this.edges.forEach(callback);
      }
      isEqualTo(cycle) {
        let equalTo = false;
        const cycleA = this, cycleB = cycle, cycleALength = cycleA.getLength(), cycleBLength = cycleB.getLength();
        if (cycleALength === cycleBLength) {
          equalTo = cycleA.everyEdge((edgeA, index) => {
            const edgeB = cycleB.getEdge(index), matches = edgeA.match(edgeB);
            if (matches) {
              return true;
            }
          });
        }
        return equalTo;
      }
      permuted() {
        const edges = this.edges.slice(), edge = edges.pop();
        edges.unshift(edge);
        const cycle = new Cycle(edges);
        return cycle;
      }
      asString() {
        const vertexes = this.getVertexes(), string = vertexes.join(COMMA_CHARACTER);
        return string;
      }
      static fromEdge(edge) {
        const edges = [
          edge
        ], cycle = new Cycle(edges);
        return cycle;
      }
      static fromEdges(edges) {
        const cycle = new Cycle(edges);
        return cycle;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/directedGraph.js
  var require_directedGraph = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return DirectedGraph;
      },
      get edgesMatchEdge() {
        return edgesMatchEdge;
      }
    });
    var _necessary = require_browser();
    var _cycle = /* @__PURE__ */ _interop_require_default(require_cycle());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {last, find, compress} = _necessary.arrayUtilities;
    var DirectedGraph = class {
      constructor(edges, startVertex) {
        this.edges = edges;
        this.startVertex = startVertex;
      }
      getEdges() {
        return this.edges;
      }
      getStartVertex() {
        return this.startVertex;
      }
      addEdge(edge) {
        const matches = edgesMatchEdge(this.edges, edge);
        if (!matches) {
          this.edges.push(edge);
        }
      }
      addEdges(edges) {
        edges.forEach((edge) => {
          this.addEdge(edge);
        });
      }
      removeEdge(edge) {
        const index = this.edges.indexOf(edge), start = index, deleteCount = 1;
        this.edges.splice(start, deleteCount);
      }
      depthFirstSearch(vertex, vertexes, callback) {
        const previousVertexes = vertexes, successorVertexes = this.findSuccessorVertexes(vertex);
        successorVertexes.forEach((successorVertex) => {
          const previousVertexesIncludesSuccessorVertex = previousVertexes.includes(successorVertex), vertexes2 = [
            ...previousVertexes,
            successorVertex
          ], vertex2 = successorVertex;
          if (previousVertexesIncludesSuccessorVertex) {
            callback(vertexes2);
          } else {
            this.depthFirstSearch(vertex2, vertexes2, callback);
          }
        });
      }
      findCycles() {
        const trivialCycles = this.findTrivialCycles(), nonTrivialCycles = this.findNonTrivialCycles(), cycles = [
          ...trivialCycles,
          ...nonTrivialCycles
        ];
        compress(cycles, (cycleA, cycleB) => {
          const cyclesCoincident = areCyclesCoincident(cycleA, cycleB);
          if (!cyclesCoincident) {
            return true;
          }
        });
        return cycles;
      }
      findTrivialCycles() {
        const triviallyCyclicEdges = this.findTriviallyCyclicEdges(), trivialCycles = triviallyCyclicEdges.map((triviallyCyclicEdge) => {
          const edge = triviallyCyclicEdge, cycle = _cycle.default.fromEdge(edge), trivialCycle = cycle;
          return trivialCycle;
        });
        return trivialCycles;
      }
      findNonTrivialCycles() {
        const nonTrivialCycles = [], directedGraph = this, vertex = this.startVertex, vertexes = [
          vertex
        ];
        this.depthFirstSearch(vertex, vertexes, (vertexes2) => {
          const nonTrivialCycle = nonTrivialCycleFromVertexes(vertexes2, directedGraph);
          nonTrivialCycles.push(nonTrivialCycle);
        });
        return nonTrivialCycles;
      }
      findSuccessorEdges(vertex) {
        const sourceVertex = vertex, edges = this.findEdgesBySourceVertex(sourceVertex), successorEdges = edges.filter((edge) => {
          const targetVertex = edge.getTargetVertex();
          if (targetVertex !== sourceVertex) {
            return true;
          }
        });
        return successorEdges;
      }
      findSuccessorVertexes(vertex) {
        const successorEdges = this.findSuccessorEdges(vertex), successorVertexes = successorEdges.map((successorEdge) => {
          const successorEdgeTargetVertex = successorEdge.getTargetVertex(), successorVertex = successorEdgeTargetVertex;
          return successorVertex;
        });
        return successorVertexes;
      }
      findEdgesBySourceVertex(sourceVertex) {
        const edges = find(this.edges, (edge) => {
          const edgeMatchesSourceVertex = edge.matchSourceVertex(sourceVertex);
          if (edgeMatchesSourceVertex) {
            return true;
          }
        });
        return edges;
      }
      findTriviallyCyclicEdges() {
        const triviallyCyclicEdges = find(this.edges, (edge) => {
          const edgeTriviallyCyclic = edge.isTriviallyCyclic();
          if (edgeTriviallyCyclic) {
            return true;
          }
        });
        return triviallyCyclicEdges;
      }
      findEdgeBySourceVertexAndTargetVertex(sourceVertex, targetVertex) {
        const edge = this.edges.find((edge2) => {
          const matches = edge2.matchSourceVertexAndTargetVertex(sourceVertex, targetVertex);
          if (matches) {
            return true;
          }
        }) || null;
        return edge;
      }
      static fromEdgesAndStartVertex(edges, startVertex) {
        const directedGraph = new DirectedGraph(edges, startVertex);
        return directedGraph;
      }
    };
    function edgesMatchEdge(edges, edge) {
      const edgeA = edge, matches = edges.some((edge2) => {
        const edgeB = edge2, edgeAMatchesEdgeB = edgeA.match(edgeB);
        if (edgeAMatchesEdgeB) {
          return true;
        }
      });
      return matches;
    }
    function nonTrivialCycleFromVertexes(vertexes, directedGraph) {
      const lastVertex = last(vertexes), index = vertexes.indexOf(lastVertex), start = index;
      vertexes = vertexes.slice(start);
      vertexes.pop();
      const length = vertexes.length, edges = vertexes.map((vertex, index2) => {
        const nextIndex = (index2 + 1) % length, nextVertex = vertexes[nextIndex], sourceVertex = vertex, targetVertex = nextVertex, edge = directedGraph.findEdgeBySourceVertexAndTargetVertex(sourceVertex, targetVertex);
        return edge;
      }), cycle = _cycle.default.fromEdges(edges);
      return cycle;
    }
    function someCyclePermutation(cycle, callback) {
      let result = false;
      const length = cycle.getLength();
      for (let offset = 0; offset < length; offset++) {
        result = callback(cycle);
        if (result) {
          break;
        }
        cycle = cycle.permuted();
      }
      return result;
    }
    function areCyclesCoincident(cycleA, cycleB) {
      let cyclesCoincident = false;
      const cycleALength = cycleA.getLength(), cycleBLength = cycleB.getLength();
      if (cycleALength === cycleBLength) {
        cyclesCoincident = someCyclePermutation(cycleA, (cycleA2) => {
          const cycleAEqualTo = cycleA2.isEqualTo(cycleB);
          if (cycleAEqualTo) {
            return true;
          }
        });
      }
      return cyclesCoincident;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/reduced.js
  var require_reduced = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReducedNode;
      }
    });
    var _occamparsers = require_lib4();
    var ReducedNode = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReducedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/constants.js
  var require_constants11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "EMPTY_STRING", {
      enumerable: true,
      get: function() {
        return EMPTY_STRING;
      }
    });
    var EMPTY_STRING = "";
  });

  // node_modules/occam-grammar-utilities/lib/utilities/ruleName.js
  var require_ruleName7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get directlyRepeatedRuleNameFromRuleName() {
        return directlyRepeatedRuleNameFromRuleName;
      },
      get indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName() {
        return indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName;
      },
      get leftRecursiveRuleNameFromIndirectlyRepeatedRuleName() {
        return leftRecursiveRuleNameFromIndirectlyRepeatedRuleName;
      },
      get reducedRuleNameFromRuleName() {
        return reducedRuleNameFromRuleName;
      },
      get ruleNameFromIndirectlyRepeatedRuleName() {
        return ruleNameFromIndirectlyRepeatedRuleName;
      },
      get ruleNameFromReducedRuleName() {
        return ruleNameFromReducedRuleName;
      }
    });
    var _constants = require_constants11();
    function reducedRuleNameFromRuleName(ruleName) {
      const reducedRuleName = `${ruleName}_`;
      return reducedRuleName;
    }
    function ruleNameFromReducedRuleName(reducedRuleName) {
      const ruleName = reducedRuleName.replace(/_$/g, _constants.EMPTY_STRING);
      return ruleName;
    }
    function directlyRepeatedRuleNameFromRuleName(ruleName) {
      const directlyRepeatedRuleName = `${ruleName}~`;
      return directlyRepeatedRuleName;
    }
    function ruleNameFromIndirectlyRepeatedRuleName(indirectlyRepeatedRuleName) {
      const ruleName = indirectlyRepeatedRuleName.replace(/~.+$/g, _constants.EMPTY_STRING);
      return ruleName;
    }
    function leftRecursiveRuleNameFromIndirectlyRepeatedRuleName(indirectlyRepeatedRuleName) {
      const leftRecursiveRuleName = indirectlyRepeatedRuleName.replace(/^[^~]+~/g, _constants.EMPTY_STRING);
      return leftRecursiveRuleName;
    }
    function indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = `${ruleName}~${leftRecursiveRuleName}`;
      return indirectlyRepeatedRuleName;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/cycle.js
  var require_cycle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isCycleIrreducible() {
        return isCycleIrreducible;
      },
      get ruleCyclesFromRuleNameAndCycles() {
        return ruleCyclesFromRuleNameAndCycles;
      },
      get ruleNamesFromCycle() {
        return ruleNamesFromCycle;
      },
      get ruleNamesFromCycles() {
        return ruleNamesFromCycles;
      }
    });
    var _necessary = require_browser();
    var _ruleName = require_ruleName7();
    var {push, compress} = _necessary.arrayUtilities;
    function isCycleIrreducible(cycle, ruleMap) {
      const ruleNames = ruleNamesFromCycle(cycle), reducedRules = ruleNames.reduce((reducedRules2, ruleName) => {
        const reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName), reducedRule = ruleMap[reducedRuleName] || null;
        if (reducedRule !== null) {
          reducedRules2.push(reducedRule);
        }
        return reducedRules2;
      }, []), reducedRulesLength = reducedRules.length, cycleIrreducible = reducedRulesLength === 0;
      return cycleIrreducible;
    }
    function ruleNamesFromCycle(cycle, ruleNames = []) {
      const cycleVertexes = cycle.getVertexes(), cycleRuleNames = cycleVertexes;
      push(ruleNames, cycleRuleNames);
      return ruleNames;
    }
    function ruleNamesFromCycles(cycles, ruleNames = []) {
      cycles.forEach((cycle) => {
        ruleNamesFromCycle(cycle, ruleNames);
      });
      compress(ruleNames, (ruleNameA, ruleNameB) => {
        if (ruleNameA !== ruleNameB) {
          return true;
        }
      });
      return ruleNames;
    }
    function ruleCyclesFromRuleNameAndCycles(ruleName, cycles) {
      const ruleCycles = cycles.reduce((ruleCycles2, cycle) => {
        const ruleNames = ruleNamesFromCycle(cycle), ruleNamesIncludeRuleName = ruleNames.includes(ruleName);
        if (ruleNamesIncludeRuleName) {
          const ruleCycle = cycle;
          ruleCycles2.push(ruleCycle);
        }
        return ruleCycles2;
      }, []);
      return ruleCycles;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/nonConsuming.js
  var require_nonConsuming = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isPartNonConsuming() {
        return isPartNonConsuming;
      },
      get isRuleNonConsuming() {
        return isRuleNonConsuming;
      }
    });
    var _occamparsers = require_lib4();
    var _occamlexers = require_lib3();
    var {epsilon, noWhitespace, startOfContent} = _occamlexers.specialSymbols;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isRuleNonConsuming(rule, ruleMap, ruleNames = []) {
      let ruleNonConsuming = false;
      const ruleName = rule.getName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
      if (!ruleNamesIncludesRuleName) {
        ruleNames = [
          ...ruleNames,
          ruleName
        ];
        const definitions = rule.getDefinitions(), definitionsNonConsuming = areDefinitionsNonConsuming(definitions, ruleMap, ruleNames);
        ruleNonConsuming = definitionsNonConsuming;
      }
      return ruleNonConsuming;
    }
    function isPartNonConsuming(part, ruleMap, ruleNames = []) {
      let partNonConsuming;
      const parTerminalPart = part.isTerminalPart();
      if (parTerminalPart) {
        const terminalPart = part, terminalPartNonConsuming = isTerminalPartNonConsuming(terminalPart);
        partNonConsuming = terminalPartNonConsuming;
      } else {
        const nonTerminalNPart = part, nonTerminalPartNonConsuming = isNonTerminalPartNonConsuming(nonTerminalNPart, ruleMap, ruleNames);
        partNonConsuming = nonTerminalPartNonConsuming;
      }
      return partNonConsuming;
    }
    function areDefinitionsNonConsuming(definitions, ruleMap, ruleNames) {
      const definitionsNonConsuming = definitions.some((definition) => {
        const definitionNonConsuming = isDefinitionNonConsuming(definition, ruleMap, ruleNames);
        if (definitionNonConsuming) {
          return true;
        }
      });
      return definitionsNonConsuming;
    }
    function isDefinitionNonConsuming(definition, ruleMap, ruleNames) {
      const parts = definition.getParts(), partsNonConsuming = arePartsNonConsuming(parts, ruleMap, ruleNames), definitionNonConsuming = partsNonConsuming;
      return definitionNonConsuming;
    }
    function arePartsNonConsuming(parts, ruleMap, ruleNames) {
      const partsNonConsuming = parts.every((part) => {
        const partNonConsuming = isPartNonConsuming(part, ruleMap, ruleNames);
        if (partNonConsuming) {
          return true;
        }
      });
      return partsNonConsuming;
    }
    function isTerminalPartNonConsuming(terminalPart) {
      let terminalPartNonConsuming;
      const terminalPartString = terminalPart.asString();
      switch (terminalPartString) {
        case epsilon:
        case noWhitespace:
        case startOfContent: {
          terminalPartNonConsuming = true;
          break;
        }
        default: {
          terminalPartNonConsuming = false;
          break;
        }
      }
      return terminalPartNonConsuming;
    }
    function isNonTerminalPartNonConsuming(nonTerminalPart, ruleMap, ruleNames) {
      let partNonConsuming = false;
      const type = nonTerminalPart.getType();
      switch (type) {
        case RuleNamePartType: {
          const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), rule = ruleMap[ruleName] || null;
          if (rule !== null) {
            const ruleNonConsuming = isRuleNonConsuming(rule, ruleMap, ruleNames);
            partNonConsuming = ruleNonConsuming;
          }
          break;
        }
        case OptionalPartPartType: {
          partNonConsuming = true;
          break;
        }
        case OneOrMorePartsPartType: {
          const oneOrMorePartsPart = nonTerminalPart, part = oneOrMorePartsPart.getPart();
          partNonConsuming = isPartNonConsuming(part, ruleMap, ruleNames);
          break;
        }
        case ZeroOrMorePartsPartType: {
          partNonConsuming = true;
          break;
        }
        case SequenceOfPartsPartType: {
          const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), partsNonConsuming = arePartsNonConsuming(parts, ruleMap, ruleNames);
          partNonConsuming = partsNonConsuming;
          break;
        }
        case ChoiceOfPartsPartType: {
          const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts(), partsNonConsuming = parts.some((part) => {
            const partNonConsuming2 = isPartNonConsuming(part, ruleMap, ruleNames);
            return partNonConsuming2;
          });
          partNonConsuming = partsNonConsuming;
          break;
        }
      }
      return partNonConsuming;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/leftRecursive.js
  var require_leftRecursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isDefinitionLeftRecursive() {
        return isDefinitionLeftRecursive;
      },
      get leftRecursiveRuleNamesFromDefinition() {
        return leftRecursiveRuleNamesFromDefinition;
      },
      get leftRecursiveRuleNamesFromRule() {
        return leftRecursiveRuleNamesFromRule;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var _nonConsuming = require_nonConsuming();
    var {first: first2} = _necessary.arrayUtilities;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isDefinitionLeftRecursive(definition, ruleMap) {
      const parts = definition.getParts(), partsLeftRecursive = arePartsLeftRecursive(parts, ruleMap), definitionLeftRecursive = partsLeftRecursive;
      return definitionLeftRecursive;
    }
    function leftRecursiveRuleNamesFromRule(rule, ruleMap, leftRecursiveRuleNames = []) {
      const definitions = rule.getDefinitions();
      definitions.forEach((definition) => {
        leftRecursiveRuleNamesFromDefinition(definition, ruleMap, leftRecursiveRuleNames);
      });
      return leftRecursiveRuleNames;
    }
    function leftRecursiveRuleNamesFromDefinition(definition, ruleMap, leftRecursiveRuleNames = []) {
      const parts = definition.getParts();
      leftRecursiveRuleNamesFromParts(parts, ruleMap, leftRecursiveRuleNames);
      return leftRecursiveRuleNames;
    }
    function arePartsLeftRecursive(parts, ruleMap) {
      const leftRecursiveRuleNames = leftRecursiveRuleNamesFromParts(parts, ruleMap), leftRecursiveRuleNamesLength = leftRecursiveRuleNames.length, partsLeftRecursive = leftRecursiveRuleNamesLength > 0;
      return partsLeftRecursive;
    }
    function leftRecursiveRuleNamesFromPart(part, ruleMap, leftRecursiveRuleNames) {
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), leftRecursiveRuleNamesIncludesRuleName = leftRecursiveRuleNames.includes(ruleName);
            if (!leftRecursiveRuleNamesIncludesRuleName) {
              const leftRecursiveRuleName = ruleName;
              leftRecursiveRuleNames.push(leftRecursiveRuleName);
            }
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case SequenceOfPartsPartType: {
            const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), firstPart = first2(parts), part2 = firstPart;
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case ChoiceOfPartsPartType: {
            const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts();
            parts.forEach((part2) => {
              leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            });
            break;
          }
        }
      }
    }
    function leftRecursiveRuleNamesFromParts(parts, ruleMap, leftRecursiveRuleNames = []) {
      parts.every((part) => {
        const partNonConsuming = (0, _nonConsuming.isPartNonConsuming)(part, ruleMap);
        if (!partNonConsuming) {
          leftRecursiveRuleNamesFromPart(part, ruleMap, leftRecursiveRuleNames);
        } else {
          return true;
        }
      });
      return leftRecursiveRuleNames;
    }
  });

  // node_modules/occam-grammar-utilities/lib/edge.js
  var require_edge = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Edge;
      }
    });
    var Edge = class {
      constructor(label, sourceVertex, targetVertex) {
        this.label = label;
        this.sourceVertex = sourceVertex;
        this.targetVertex = targetVertex;
      }
      getLabel() {
        return this.label;
      }
      getSourceVertex() {
        return this.sourceVertex;
      }
      getTargetVertex() {
        return this.targetVertex;
      }
      isTriviallyCyclic() {
        const triviallyCyclic = this.sourceVertex === this.targetVertex;
        return triviallyCyclic;
      }
      match(edge) {
        const label = this.getLabel(), sourceVertex = edge.getSourceVertex(), targetVertex = edge.getTargetVertex(), matches = this.matchLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex);
        return matches;
      }
      matchSourceVertex(sourceVertex) {
        const matchesSourceVertex = this.sourceVertex === sourceVertex;
        return matchesSourceVertex;
      }
      matchTargetVertex(targetVertex) {
        const matchesTargetVertex = this.targetVertex === targetVertex;
        return matchesTargetVertex;
      }
      matchSourceVertexAndTargetVertex(sourceVertex, targetVertex) {
        const matches = this.sourceVertex === sourceVertex && this.targetVertex === targetVertex;
        return matches;
      }
      matchLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex) {
        const matches = this.label === label && this.sourceVertex === sourceVertex && this.targetVertex === targetVertex;
        return matches;
      }
      static fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex) {
        const edge = new Edge(label, sourceVertex, targetVertex);
        return edge;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/recursive.js
  var require_recursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "recursiveRuleNamesFromRule", {
      enumerable: true,
      get: function() {
        return recursiveRuleNamesFromRule;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, SequenceOfPartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    function recursiveRuleNamesFromRule(rule, recursiveRuleNames = []) {
      const definitions = rule.getDefinitions();
      definitions.forEach((definition) => {
        recursiveRuleNamesFromDefinition(definition, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromDefinition(definition, recursiveRuleNames = []) {
      const parts = definition.getParts();
      recursiveRuleNamesFromParts(parts, recursiveRuleNames);
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromParts(parts, recursiveRuleNames = []) {
      parts.forEach((part) => {
        recursiveRuleNamesFromPart(part, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromPart(part, recursiveRuleNames) {
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), recursiveRuleNamesIncludesRuleName = recursiveRuleNames.includes(ruleName);
            if (!recursiveRuleNamesIncludesRuleName) {
              const recursiveRuleName = ruleName;
              recursiveRuleNames.push(recursiveRuleName);
            }
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case SequenceOfPartsPartType: {
            const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts();
            parts.forEach((part2) => {
              recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            });
            break;
          }
          case ChoiceOfPartsPartType: {
            const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts();
            parts.forEach((part2) => {
              recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            });
            break;
          }
        }
      }
    }
  });

  // node_modules/occam-grammar-utilities/lib/labels.js
  var require_labels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get LEFT_RECURSIVE_LABEL() {
        return LEFT_RECURSIVE_LABEL;
      },
      get RECURSIVE_LABEL() {
        return RECURSIVE_LABEL;
      }
    });
    var RECURSIVE_LABEL = "recursive";
    var LEFT_RECURSIVE_LABEL = "left-recursive";
  });

  // node_modules/occam-grammar-utilities/lib/utilities/directedGraph.js
  var require_directedGraph2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get edgeFromRuleNameAndLeftRecursiveRuleName() {
        return edgeFromRuleNameAndLeftRecursiveRuleName;
      },
      get edgesFromRuleNames() {
        return edgesFromRuleNames;
      },
      get edgesFromStartRule() {
        return edgesFromStartRule;
      }
    });
    var _edge = /* @__PURE__ */ _interop_require_default(require_edge());
    var _directedGraph = require_directedGraph();
    var _recursive = require_recursive();
    var _labels = require_labels();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function edgesFromRuleNames(ruleNames) {
      const length = ruleNames.length, edges = ruleNames.map((ruleName, index) => {
        const nextIndex = (index + 1) % length, nextRuleName = ruleNames[nextIndex], leftRecursiveRuleName = nextRuleName, edge = edgeFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName);
        return edge;
      });
      return edges;
    }
    function edgesFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const rule = startRule, edges = [], vertexes = [];
      edgesFromRule(rule, edges, vertexes, ruleMap, ruleNamesMap);
      return edges;
    }
    function edgeFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const label = _labels.LEFT_RECURSIVE_LABEL, sourceVertex = ruleName, targetVertex = leftRecursiveRuleName, edge = _edge.default.fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex);
      return edge;
    }
    function edgesFromRule(rule, edges, vertexes, ruleMap, ruleNamesMap) {
      const ruleName = rule.getName(), vertex = ruleName, vertexesIncludesVertex = vertexes.includes(vertex);
      if (vertexesIncludesVertex) {
        return;
      }
      vertexes = [
        ...vertexes,
        vertex
      ];
      const ruleNames = ruleNamesMap[ruleName], recursiveRuleNames = (0, _recursive.recursiveRuleNamesFromRule)(rule), leftRecursiveRuleNames = ruleNames;
      recursiveRuleNames.forEach((recursiveRuleName) => {
        const leftRecursiveRuleNamesIncludesRecursiveRuleName = leftRecursiveRuleNames.includes(recursiveRuleName), leftRecursiveRuleName = recursiveRuleName, label = leftRecursiveRuleNamesIncludesRecursiveRuleName ? _labels.LEFT_RECURSIVE_LABEL : _labels.RECURSIVE_LABEL, sourceVertex = ruleName, targetVertex = leftRecursiveRuleName, edge = _edge.default.fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex), matches = (0, _directedGraph.edgesMatchEdge)(edges, edge);
        if (!matches) {
          edges.push(edge);
        }
        const recursiveRule = ruleMap[recursiveRuleName] || null;
        if (recursiveRule !== null) {
          const rule2 = recursiveRule;
          edgesFromRule(rule2, edges, vertexes, ruleMap, ruleNamesMap);
        }
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/reduced.js
  var require_reduced2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReducedRule;
      }
    });
    var _occamparsers = require_lib4();
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced());
    var _directedGraph = require_directedGraph();
    var _cycle = require_cycle2();
    var _ruleName = require_ruleName7();
    var _leftRecursive = require_leftRecursive();
    var _directedGraph1 = require_directedGraph2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ReducedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _reduced.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles, ruleMap) {
        const ruleName = rule.getName();
        let reducedRule = null, definitions = rule.getDefinitions();
        definitions = definitions.filter((definition) => {
          const definitionLeftReducible = isDefinitionReducible(definition, ruleName, cycles, ruleMap);
          if (definitionLeftReducible) {
            return true;
          }
        });
        const definitionsLength = definitions.length;
        if (definitionsLength > 0) {
          const ruleName2 = rule.getName(), reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName2), name = reducedRuleName, opacity = rule.getOpacity();
          reducedRule = new ReducedRule(name, opacity, definitions);
        }
        return reducedRule;
      }
    };
    function isDefinitionReducible(definition, ruleName, cycles, ruleMap) {
      const leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromDefinition)(definition, ruleMap), definitionReducible = leftRecursiveRuleNames.every((leftRecursiveRuleName) => {
        const cyclesIncludeRuleNameAndLeftRecursiveRuleName = cycles.some((cycle) => {
          const cycleIncludesRuleNameAndLeftRecursiveRuleName = doesCycleIncludeRuleNameAndLeftRecursiveRuleName(cycle, ruleName, leftRecursiveRuleName);
          if (cycleIncludesRuleNameAndLeftRecursiveRuleName) {
            return true;
          }
        });
        if (!cyclesIncludeRuleNameAndLeftRecursiveRuleName) {
          return true;
        }
      });
      return definitionReducible;
    }
    function doesCycleIncludeRuleNameAndLeftRecursiveRuleName(cycle, ruleName, leftRecursiveRuleName) {
      const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), edge = (0, _directedGraph1.edgeFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), edges = (0, _directedGraph1.edgesFromRuleNames)(ruleNames), matches = (0, _directedGraph.edgesMatchEdge)(edges, edge), cycleIncludesRuleNameAndLeftRecursiveRuleName = matches;
      return cycleIncludesRuleNameAndLeftRecursiveRuleName;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createReducedRules.js
  var require_createReducedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createReducedRules;
      }
    });
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced2());
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createReducedRules(cycles, ruleMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], reducedRule = _reduced.default.fromRuleAndCycles(rule, cycles, ruleMap);
        if (reducedRule !== null) {
          const reducedRuleName = reducedRule.getName();
          ruleMap[reducedRuleName] = reducedRule;
        }
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/precedence.js
  var require_precedence4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isNonTerminalNodeUnprecedented", {
      enumerable: true,
      get: function() {
        return isNonTerminalNodeUnprecedented;
      }
    });
    function isNonTerminalNodeUnprecedented(nonTerminalNode) {
      let nonTerminalNodeUnprecedented;
      const childNonTerminalNodeUnprecedented = nonTerminalNode.someChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const childNonTerminalNode = childNode, childNonTerminalNodeUnprecedented2 = isNonTerminalNodeUnprecedented(childNonTerminalNode);
          if (childNonTerminalNodeUnprecedented2) {
            return true;
          }
        }
      });
      if (childNonTerminalNodeUnprecedented) {
        nonTerminalNodeUnprecedented = true;
      } else {
        const precedence = nonTerminalNode.getPrecedence();
        if (precedence !== null) {
          const ruleName = nonTerminalNode.getRuleName();
          nonTerminalNodeUnprecedented = nonTerminalNode.someChildNode((childNode) => {
            const childNodeLowerPrecedence = childNode.isLowerPrecedence(ruleName, precedence);
            if (childNodeLowerPrecedence) {
              return true;
            }
          });
        }
      }
      return nonTerminalNodeUnprecedented;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/repeated/directly.js
  var require_directly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedNode;
      }
    });
    var _occamparsers = require_lib4();
    var _rewrite = require_rewrite();
    var DirectlyRepeatedNode = class extends _occamparsers.NonTerminalNode {
      rewrite(state) {
        const nonTerminalNode = this.clone();
        (0, _rewrite.rewriteDirectlyRepeatedNodes)(nonTerminalNode, state);
        return nonTerminalNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(DirectlyRepeatedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/node/repeated/indirectly.js
  var require_indirectly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return IndirectlyRepeatedNode;
      }
    });
    var _occamparsers = require_lib4();
    var IndirectlyRepeatedNode = class extends _occamparsers.NonTerminalNode {
      isNullary() {
        let nullary = false;
        const singular = this.isSingular();
        if (singular) {
          nullary = this.everyChildNode((childNode) => {
            if (childNode instanceof _occamparsers.EpsilonNode) {
              return true;
            }
          });
        }
        return nullary;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(IndirectlyRepeatedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/rewrite.js
  var require_rewrite = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get rewriteDirectlyRepeatedNodes() {
        return rewriteDirectlyRepeatedNodes;
      },
      get rewriteIndirectlyRepeatedNodes() {
        return rewriteIndirectlyRepeatedNodes;
      },
      get rewriteReducedNodes() {
        return rewriteReducedNodes;
      }
    });
    var _necessary = require_browser();
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced());
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly());
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly());
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {push} = _necessary.arrayUtilities;
    function rewriteReducedNodes(nonTerminalNode, state) {
      let reducedChildNode;
      const firstChildNodeReducedNode = nonTerminalNode.someChildNode((childNode, index) => {
        if (index === 0) {
          if (childNode instanceof _reduced.default) {
            reducedChildNode = childNode;
            return true;
          }
        }
      });
      if (!firstChildNodeReducedNode) {
        return;
      }
      const parentNode = nonTerminalNode, replacedChildNode = reducedChildNode, replacedChildNodeOpacity = replacedChildNode.getOpacity(), replacedChildNodeRuleName = replacedChildNode.getRuleName(), replacedChildNodePrecedence = replacedChildNode.getPrecedence(), replacedChildNodeChildNodes = replacedChildNode.removeChildNodes(), parentNodeRuleName = parentNode.getRuleName(), reducedRuleName = replacedChildNodeRuleName, parentRuleName = parentNodeRuleName, precedence = replacedChildNodePrecedence, opacity = replacedChildNodeOpacity, ruleName = (0, _ruleName.ruleNameFromReducedRuleName)(reducedRuleName);
      let replacementChildNodes;
      if (ruleName === parentRuleName) {
        replacementChildNodes = replacedChildNodeChildNodes;
        parentNode.setPrecedence(precedence);
      } else {
        const childNodes = replacedChildNodeChildNodes, NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName), nonTerminalNode2 = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), replacementChildNode = nonTerminalNode2;
        replacementChildNodes = [
          replacementChildNode
        ];
      }
      parentNode.replaceChildNode(replacedChildNode, replacementChildNodes);
    }
    function rewriteDirectlyRepeatedNodes(nonTerminalNode, state) {
      let directlyRepeatedNodesReplaced;
      directlyRepeatedNodesReplaced = replaceDirectlyRepeatedNodes(nonTerminalNode);
      while (directlyRepeatedNodesReplaced) {
        directlyRepeatedNodesReplaced = replaceDirectlyRepeatedNodes(nonTerminalNode);
      }
    }
    function rewriteIndirectlyRepeatedNodes(nonTerminalNode, state) {
      let parentNode = nonTerminalNode;
      const indirectlyRepeatedNodes = findIndirectlyRepeatedNodes(nonTerminalNode);
      indirectlyRepeatedNodes.forEach((indirectlyRepeatedNode) => {
        const leftRecursiveNode = leftRecursiveNodeFromParentNodeAndIndirectlyRepeatedNode(parentNode, indirectlyRepeatedNode, state), childNodes = childNodesFromLeftRecursiveNodeNodeAndIndirectlyRepeatedNode(leftRecursiveNode, indirectlyRepeatedNode);
        adjustParentNodePrecedence(parentNode, indirectlyRepeatedNode);
        parentNode.setChildNodes(childNodes);
        parentNode = leftRecursiveNode;
      });
      return parentNode;
    }
    function findRepeatedNodes(nonTerminalNode, RepeatedNode) {
      let repeatedNodes;
      let endIndex = -1;
      nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
        const childNodeRepeatedNode = childNode instanceof RepeatedNode;
        if (childNodeRepeatedNode) {
          endIndex = index + 1;
          return true;
        }
      });
      if (endIndex === -1) {
        repeatedNodes = [];
      } else {
        let startIndex;
        nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
          const childNodeRepeatedNode = childNode instanceof RepeatedNode;
          if (!childNodeRepeatedNode) {
            if (index < endIndex) {
              return true;
            }
          }
          startIndex = index;
        });
        const childNodes = nonTerminalNode.sliceChildNodes(startIndex, endIndex);
        repeatedNodes = childNodes;
      }
      return repeatedNodes;
    }
    function removeFrontChildNodes(parentNode) {
      const multiplicity = parentNode.getMultiplicity(), deleteCount = multiplicity - 1, start = 0, removedFrontChildNodes = parentNode.spliceChildNodes(start, deleteCount);
      return removedFrontChildNodes;
    }
    function findDirectlyRepeatedNodes(nonTerminalNode) {
      const directlyRepeatedNodes = findRepeatedNodes(nonTerminalNode, _directly.default);
      return directlyRepeatedNodes;
    }
    function findIndirectlyRepeatedNodes(nonTerminalNode) {
      const indirectlyRepeatedNodes = findRepeatedNodes(nonTerminalNode, _indirectly.default);
      indirectlyRepeatedNodes.reverse();
      return indirectlyRepeatedNodes;
    }
    function replaceDirectlyRepeatedNodes(nonTerminalNode) {
      let directlyRepeatedNodesReplaced = false;
      const directlyRepeatedNodes = findDirectlyRepeatedNodes(nonTerminalNode), directlyRepeatedNodesLength = directlyRepeatedNodes.length;
      if (directlyRepeatedNodesLength > 0) {
        const parentNode = nonTerminalNode, replacedChildNodes = directlyRepeatedNodes, replacementChildNodes = [];
        directlyRepeatedNodes.forEach((directlyRepeatedNode) => {
          const directlyRepeatedNodesChildNodes = directlyRepeatedNode.removeChildNodes();
          push(replacementChildNodes, directlyRepeatedNodesChildNodes);
        });
        parentNode.replaceChildNodes(replacedChildNodes, replacementChildNodes);
        directlyRepeatedNodesReplaced = true;
      }
      return directlyRepeatedNodesReplaced;
    }
    function adjustParentNodePrecedence(parentNode, indirectlyRepeatedNode) {
      const indirectlyRepeatedNodeRuleName = indirectlyRepeatedNode.getRuleName(), indirectlyRepeatedRuleName = indirectlyRepeatedNodeRuleName, parentNodeNodeRuleName = parentNode.getRuleName(), ruleName = (0, _ruleName.ruleNameFromIndirectlyRepeatedRuleName)(indirectlyRepeatedRuleName);
      if (parentNodeNodeRuleName === ruleName) {
        const precedence = indirectlyRepeatedNode.getPrecedence();
        parentNode.setPrecedence(precedence);
      }
    }
    function leftRecursiveNodeFromParentNodeAndIndirectlyRepeatedNode(parentNode, indirectlyRepeatedNode, state) {
      const indirectlyRepeatedNodeRuleName = indirectlyRepeatedNode.getRuleName(), indirectlyRepeatedNodeOpacity = indirectlyRepeatedNode.getOpacity(), indirectlyRepeatedRuleName = indirectlyRepeatedNodeRuleName, removedFrontChildNodes = removeFrontChildNodes(parentNode), leftRecursiveRuleName = (0, _ruleName.leftRecursiveRuleNameFromIndirectlyRepeatedRuleName)(indirectlyRepeatedRuleName), ruleName = leftRecursiveRuleName, childNodes = removedFrontChildNodes, opacity = indirectlyRepeatedNodeOpacity, precedence = null, NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName), nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), leftRecursiveNode = nonTerminalNode;
      return leftRecursiveNode;
    }
    function childNodesFromLeftRecursiveNodeNodeAndIndirectlyRepeatedNode(leftRecursiveNode, indirectlyRepeatedNode) {
      const childNodes = [
        leftRecursiveNode
      ], indirectlyRepeatedNodeNullary = indirectlyRepeatedNode.isNullary();
      if (!indirectlyRepeatedNodeNullary) {
        const removedChildNodes = indirectlyRepeatedNode.removeChildNodes();
        push(childNodes, removedChildNodes);
      }
      return childNodes;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/rewritten.js
  var require_rewritten = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenNode;
      }
    });
    var _occamparsers = require_lib4();
    var _precedence = require_precedence4();
    var _rewrite = require_rewrite();
    var RewrittenNode = class extends _occamparsers.NonTerminalNode {
      rewrite(state) {
        let nonTerminalNode;
        const ruleName = this.getRuleName(), NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName);
        nonTerminalNode = this.clone();
        const opacity = nonTerminalNode.getOpacity(), childNodes = nonTerminalNode.getChildNodes(), precedence = nonTerminalNode.getPrecedence();
        nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence);
        (0, _rewrite.rewriteDirectlyRepeatedNodes)(nonTerminalNode, state);
        const parentNode = (0, _rewrite.rewriteIndirectlyRepeatedNodes)(nonTerminalNode, state);
        {
          const nonTerminalNode2 = parentNode;
          (0, _rewrite.rewriteReducedNodes)(nonTerminalNode2, state);
        }
        return nonTerminalNode;
      }
      isUnprecedented() {
        const nonTerminalNode = this, nonTerminalNodeUnprecedented = (0, _precedence.isNonTerminalNodeUnprecedented)(nonTerminalNode), unprecedented = nonTerminalNodeUnprecedented;
        return unprecedented;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(RewrittenNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/ruleNames.js
  var require_ruleNames4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get forEachRuleNameAndLeftRecursiveRuleName() {
        return forEachRuleNameAndLeftRecursiveRuleName;
      },
      get permuteRuleNames() {
        return permuteRuleNames;
      }
    });
    function permuteRuleNames(ruleNames, ruleName) {
      let start, end;
      const index = ruleNames.indexOf(ruleName);
      start = 0;
      end = index;
      const leadingRuleNames = ruleNames.slice(start, end);
      start = index;
      const trailingRuleNames = ruleNames.slice(start), permutedRuleNames = [
        ...trailingRuleNames,
        ...leadingRuleNames
      ];
      return permutedRuleNames;
    }
    function forEachRuleNameAndLeftRecursiveRuleName(ruleNames, callback) {
      const ruleNamesLength = ruleNames.length, lastIndex = ruleNamesLength - 1;
      ruleNames.forEach((ruleName, index) => {
        const nextIndex = index === lastIndex ? 0 : index + 1, leftRecursiveRuleName = ruleNames[nextIndex];
        callback(ruleName, leftRecursiveRuleName, index);
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/part.js
  var require_part3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ruleNamePartFromRuleName() {
        return ruleNamePartFromRuleName;
      },
      get zeroOrMorePartsPartFromPart() {
        return zeroOrMorePartsPartFromPart;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePart, ZeroOrMorePartsPart} = _occamparsers.Parts;
    function ruleNamePartFromRuleName(ruleName) {
      const ruleNamePart = RuleNamePart.fromRuleName(ruleName);
      return ruleNamePart;
    }
    function zeroOrMorePartsPartFromPart(part) {
      const zeroOrMorePartsPart = ZeroOrMorePartsPart.fromPart(part);
      return zeroOrMorePartsPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/path.js
  var require_path3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get arePathsEqual() {
        return arePathsEqual;
      },
      get differenceFromPaths() {
        return differenceFromPaths;
      },
      get pathsFromRuleNameAndCycles() {
        return pathsFromRuleNameAndCycles;
      },
      get reducedRuleNameFromPath() {
        return reducedRuleNameFromPath;
      },
      get reducedRuleNamePartFromPath() {
        return reducedRuleNamePartFromPath;
      }
    });
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames4();
    var _cycle = require_cycle2();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var {last, match, compress} = _necessary.arrayUtilities;
    function arePathsEqual(pathA, pathB) {
      const ruleNamesA = pathA, ruleNamesB = pathB, ruleNamesMatch = match(ruleNamesA, ruleNamesB, (ruleNameA, ruleNameB) => {
        if (ruleNameA === ruleNameB) {
          return true;
        }
      }), pathsEqual = ruleNamesMatch;
      return pathsEqual;
    }
    function differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap) {
      let difference;
      const pathALength = pathA.length, pathBLength = pathB.length;
      if (false) {
      } else if (pathALength === 1) {
        difference = -1;
      } else if (pathBLength === 1) {
        difference = 1;
      } else if (pathALength === 0 && pathBLength === 0) {
        difference = 0;
      } else if (pathALength === 0) {
        difference = 1;
      } else if (pathBLength === 0) {
        difference = -1;
      } else {
        const ruleNamesA = pathA.slice(), ruleNamesB = pathB.slice(), ruleNameA = ruleNamesA.shift(), ruleNameB = ruleNamesB.shift();
        if (ruleNameA === ruleNameB) {
          pathA = ruleNamesA;
          pathB = ruleNamesB;
          ruleName = ruleNameA;
          difference = differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap);
        } else {
          const ruleNames = ruleNamesMap[ruleName], indexA = ruleNames.indexOf(ruleNameA), indexB = ruleNames.indexOf(ruleNameB);
          difference = indexA - indexB;
        }
      }
      return difference;
    }
    function reducedRuleNameFromPath(path) {
      const ruleNames = path, lastRuleName = last(ruleNames), ruleName = lastRuleName, reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName);
      return reducedRuleName;
    }
    function pathsFromRuleNameAndCycles(ruleName, cycles, ruleMap, ruleNamesMap) {
      const paths = cycles.reduce((paths2, cycle) => {
        const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
        if (ruleNamesIncludesRuleName) {
          const permutedRuleNames = (0, _ruleNames.permuteRuleNames)(ruleNames, ruleName), path = permutedRuleNames;
          paths2.push(path);
        }
        return paths2;
      }, []);
      let length;
      paths.forEach((path) => {
        length = path.length;
        while (length > 1) {
          path = path.slice();
          path.pop();
          paths.push(path);
          length = path.length;
        }
      });
      compress(paths, (pathA, pathB) => {
        const pathsEqual = arePathsEqual(pathA, pathB);
        if (!pathsEqual) {
          return true;
        }
      });
      ruleName = null;
      paths.sort((pathA, pathB) => {
        const difference = differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap);
        return difference;
      });
      return paths;
    }
    function reducedRuleNamePartFromPath(path) {
      const reducedRuleName = reducedRuleNameFromPath(path), reducedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(reducedRuleName);
      return reducedRuleNamePart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/definition/rewritten.js
  var require_rewritten2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames4();
    var _path = require_path3();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var {first: first2} = _necessary.arrayUtilities;
    var RewrittenDefinition = class extends _occamparsers.Definition {
      static fromPath(path, ruleMap) {
        let rewrittenDefinition = null;
        const reducedRuleName = (0, _path.reducedRuleNameFromPath)(path), reducedRule = ruleMap[reducedRuleName] || null;
        if (reducedRule !== null) {
          rewrittenDefinition = rewrittenDefinitionFromPath(path);
        }
        return rewrittenDefinition;
      }
    };
    function reversePath(path) {
      const reversedPath = path.slice();
      reversedPath.reverse();
      return reversedPath;
    }
    function rewrittenDefinitionFromPath(path) {
      const reducedRuleNamePart = (0, _path.reducedRuleNamePartFromPath)(path), reversedPath = reversePath(path), ruleNames = reversedPath, ruleNamesLength = ruleNames.length, lastIndex = ruleNamesLength - 1, parts = [];
      parts.push(reducedRuleNamePart);
      (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName, index) => {
        if (index < lastIndex) {
          const directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
          parts.push(directlyRepeatedPart);
          const temporaryRuleName = leftRecursiveRuleName;
          leftRecursiveRuleName = ruleName;
          ruleName = temporaryRuleName;
          const indirectlyRepeatedPart = indirectlyRepeatedPartFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName);
          parts.push(indirectlyRepeatedPart);
        }
      });
      if (ruleNamesLength === 1) {
        const firstRuleName = first2(ruleNames), ruleName = firstRuleName, directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
        parts.push(directlyRepeatedPart);
      }
      const precedence = null, rewrittenDefinition = new RewrittenDefinition(parts, precedence);
      return rewrittenDefinition;
    }
    function directlyRepeatedPartFromRuleName(ruleName) {
      const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), directlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(directlyRepeatedRuleName), zeroOrMoreDirectlyRepeatedRuleNamePartsPart = (0, _part.zeroOrMorePartsPartFromPart)(directlyRepeatedRuleNamePart), directlyRepeatedPart = zeroOrMoreDirectlyRepeatedRuleNamePartsPart;
      return directlyRepeatedPart;
    }
    function indirectlyRepeatedPartFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), indirectlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(indirectlyRepeatedRuleName), indirectlyRepeatedPart = indirectlyRepeatedRuleNamePart;
      return indirectlyRepeatedPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/rewritten.js
  var require_rewritten3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenRule;
      }
    });
    var _occamparsers = require_lib4();
    var _rewritten = /* @__PURE__ */ _interop_require_default(require_rewritten());
    var _rewritten1 = /* @__PURE__ */ _interop_require_default(require_rewritten2());
    var _path = require_path3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RewrittenRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _rewritten.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles, ruleMap, ruleNamesMap) {
        const definitions = [], ruleName = rule.getName(), paths = (0, _path.pathsFromRuleNameAndCycles)(ruleName, cycles, ruleMap, ruleNamesMap);
        paths.forEach((path) => {
          const rewrittenDefinition = _rewritten1.default.fromPath(path, ruleMap);
          if (rewrittenDefinition !== null) {
            const definition = rewrittenDefinition;
            definitions.push(definition);
          }
        });
        const name = ruleName, opacity = rule.getOpacity(), rewrittenRule = new RewrittenRule(name, opacity, definitions);
        return rewrittenRule;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/definition/repeated/directly.js
  var require_directly2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var _cycle = require_cycle2();
    var _ruleNames = require_ruleNames4();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var DirectlyRepeatedDefinition = class extends _occamparsers.Definition {
      static fromRuleAndCycle(rule, cycle) {
        let directlyRepeatedDefinition = null;
        const ruleName = rule.getName(), ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), ruleNameIncludesRuleName = ruleNames.includes(ruleName);
        if (ruleNameIncludesRuleName) {
          const permutedRuleNames = (0, _ruleNames.permuteRuleNames)(ruleNames, ruleName), path = permutedRuleNames, parts = partsFromPath(path), precedence = null;
          directlyRepeatedDefinition = new DirectlyRepeatedDefinition(parts, precedence);
        }
        return directlyRepeatedDefinition;
      }
    };
    function permutePath(path) {
      const permutedPath = path.slice();
      permutedPath.reverse();
      const ruleName = permutedPath.pop();
      permutedPath.unshift(ruleName);
      return permutedPath;
    }
    function partsFromPath(path) {
      const permutedPath = permutePath(path), ruleNames = permutedPath, parts = [];
      (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName) => {
        const temporaryRuleName = leftRecursiveRuleName;
        leftRecursiveRuleName = ruleName;
        ruleName = temporaryRuleName;
        const indirectlyRepeatedPart = indirectlyRepeatedPartFromRuleNameAndLeftReucrsiveRuleName(ruleName, leftRecursiveRuleName), directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
        parts.push(indirectlyRepeatedPart);
        parts.push(directlyRepeatedPart);
      });
      parts.pop();
      return parts;
    }
    function directlyRepeatedPartFromRuleName(ruleName) {
      const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), directlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(directlyRepeatedRuleName), zeroOrMoreDirectlyRepeatedRuleNamePartsPart = (0, _part.zeroOrMorePartsPartFromPart)(directlyRepeatedRuleNamePart), directlyRepeatedPart = zeroOrMoreDirectlyRepeatedRuleNamePartsPart;
      return directlyRepeatedPart;
    }
    function indirectlyRepeatedPartFromRuleNameAndLeftReucrsiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), indirectlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(indirectlyRepeatedRuleName), indirectlyRepeatedPart = indirectlyRepeatedRuleNamePart;
      return indirectlyRepeatedPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/repeated/directly.js
  var require_directly3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedRule;
      }
    });
    var _occamparsers = require_lib4();
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly());
    var _directly1 = /* @__PURE__ */ _interop_require_default(require_directly2());
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DirectlyRepeatedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _directly.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles) {
        const ruleName = rule.getName(), definitions = [];
        cycles.map((cycle) => {
          const directlyRepeatedDefinition = _directly1.default.fromRuleAndCycle(rule, cycle);
          if (directlyRepeatedDefinition !== null) {
            const definition = directlyRepeatedDefinition;
            definitions.push(definition);
          }
        });
        const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), name = directlyRepeatedRuleName, opacity = rule.getOpacity(), directlyRepeatedRule = new DirectlyRepeatedRule(name, opacity, definitions);
        return directlyRepeatedRule;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/rewriteLeftRecursiveRules.js
  var require_rewriteLeftRecursiveRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return rewriteLeftRecursiveRules;
      }
    });
    var _necessary = require_browser();
    var _rewritten = /* @__PURE__ */ _interop_require_default(require_rewritten3());
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly3());
    var _nonConsuming = require_nonConsuming();
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {filter} = _necessary.arrayUtilities;
    function rewriteLeftRecursiveRules(cycles, ruleMap, ruleNamesMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        let rule = ruleMap[ruleName];
        const rewrittenRule = _rewritten.default.fromRuleAndCycles(rule, cycles, ruleMap, ruleNamesMap);
        rule = rewrittenRule;
        ruleMap[ruleName] = rule;
      });
      const directlyRepeatedRules = rulesFromRule(_directly.default, ruleMap);
      directlyRepeatedRules.forEach((directlyRepeatedRule) => {
        const directlyRepeatedRuleNonConsuming = (0, _nonConsuming.isRuleNonConsuming)(directlyRepeatedRule, ruleMap);
        if (directlyRepeatedRuleNonConsuming) {
          const directlyRepeatedRuleName = directlyRepeatedRule.getName();
          throw new Error(`The directly repeated '${directlyRepeatedRuleName}' rule is non-consuming.`);
        }
      });
      ruleNames.forEach((ruleName) => {
        const ruleCycles = (0, _cycle.ruleCyclesFromRuleNameAndCycles)(ruleName, cycles), ruleCyclesIrreducible = ruleCycles.every((ruleCycle) => {
          const ruleCycleIrreducible = (0, _cycle.isCycleIrreducible)(ruleCycle, ruleMap);
          if (ruleCycleIrreducible) {
            return true;
          }
        });
        if (ruleCyclesIrreducible) {
          throw new Error(`None of the cycles including the '${ruleName}' rule have a reduced rule.`);
        }
      });
    }
    function rulesFromRule(Rule, ruleMap) {
      const rules = Object.values(ruleMap);
      filter(rules, (rule) => {
        const ruleRule = rule instanceof Rule;
        if (ruleRule) {
          return true;
        }
      });
      return rules;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createDirectlyRepeatedRules.js
  var require_createDirectlyRepeatedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createDirectlyRepeatedRules;
      }
    });
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly3());
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createDirectlyRepeatedRules(cycles, ruleMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], directlyRepeatedRule = _directly.default.fromRuleAndCycles(rule, cycles, ruleMap), directlyRepeatedRuleName = directlyRepeatedRule.getName();
        ruleMap[directlyRepeatedRuleName] = directlyRepeatedRule;
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/definition/epsilon.js
  var require_epsilon5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var {EpsilonPart} = _occamparsers.Parts;
    var EpsilonDefinition = class extends _occamparsers.Definition {
      static fromPrecedence(precedence) {
        const epsilonPart = EpsilonPart.fromNothing(), parts = [
          epsilonPart
        ], epsilonDefinition = EpsilonDefinition.fromPartsAndPrecedence(parts, precedence);
        return epsilonDefinition;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/parts.js
  var require_parts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "arePartsEqual", {
      enumerable: true,
      get: function() {
        return arePartsEqual;
      }
    });
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    function arePartsEqual(parts) {
      const firstPart = first2(parts), firstPartString = firstPart.asString(), partsEqual = parts.every((part) => {
        const partString = part.asString(), partStringFirstPartString = partString === firstPartString;
        if (partStringFirstPartString) {
          return true;
        }
      });
      return partsEqual;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/nonProducing.js
  var require_nonProducing = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isRuleNonProducing", {
      enumerable: true,
      get: function() {
        return isRuleNonProducing;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isRuleNonProducing(rule, ruleMap, ruleNames = []) {
      let ruleNonProducing = false;
      const ruleName = rule.getName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
      if (!ruleNamesIncludesRuleName) {
        ruleNames = [
          ...ruleNames,
          ruleName
        ];
        const definitions = rule.getDefinitions(), definitionsNonProducing = areDefinitionsNonProducing(definitions, ruleMap, ruleNames);
        ruleNonProducing = definitionsNonProducing;
      }
      return ruleNonProducing;
    }
    function areDefinitionsNonProducing(definitions, ruleMap, ruleNames) {
      const definitionsNonProducing = definitions.every((definition) => {
        const definitionNonProducing = isDefinitionNonProducing(definition, ruleMap, ruleNames);
        if (definitionNonProducing) {
          return true;
        }
      });
      return definitionsNonProducing;
    }
    function isDefinitionNonProducing(definition, ruleMap, ruleNames) {
      const parts = definition.getParts(), partsNonProducing = arePartsNonProducing(parts, ruleMap, ruleNames), definitionNonProducing = partsNonProducing;
      return definitionNonProducing;
    }
    function arePartsNonProducing(parts, ruleMap, ruleNames) {
      const partsNonProducing = parts.every((part) => {
        const partNonProducing = isPartNonProducing(part, ruleMap, ruleNames);
        if (partNonProducing) {
          return true;
        }
      });
      return partsNonProducing;
    }
    function isPartNonProducing(part, ruleMap, ruleNames) {
      let partNonProducing;
      const parTerminalPart = part.isTerminalPart();
      if (parTerminalPart) {
        const terminalPart = part, terminalPartUseless = isTerminalPartNonProducing(terminalPart);
        partNonProducing = terminalPartUseless;
      } else {
        const nonTerminalNPart = part, nonTerminalPartNonProducing = isNonTerminalPartNonProducing(nonTerminalNPart, ruleMap, ruleNames);
        partNonProducing = nonTerminalPartNonProducing;
      }
      return partNonProducing;
    }
    function isTerminalPartNonProducing(terminalPart) {
      const terminalPartNonProducing = false;
      return terminalPartNonProducing;
    }
    function isNonTerminalPartNonProducing(nonTerminalPart, ruleMap, ruleNames) {
      let partNonProducing = false;
      const type = nonTerminalPart.getType();
      switch (type) {
        case RuleNamePartType: {
          const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), rule = ruleMap[ruleName] || null;
          if (rule !== null) {
            const ruleNonProducing = isRuleNonProducing(rule, ruleMap, ruleNames);
            partNonProducing = ruleNonProducing;
          }
          break;
        }
        case OptionalPartPartType: {
          partNonProducing = true;
          break;
        }
        case OneOrMorePartsPartType: {
          const oneOrMorePartsPart = nonTerminalPart, part = oneOrMorePartsPart.getPart();
          partNonProducing = isPartNonProducing(part, ruleMap, ruleNames);
          break;
        }
        case ZeroOrMorePartsPartType: {
          partNonProducing = true;
          break;
        }
        case SequenceOfPartsPartType: {
          const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), partsNonProducing = arePartsNonProducing(parts, ruleMap, ruleNames);
          partNonProducing = partsNonProducing;
          break;
        }
        case ChoiceOfPartsPartType: {
          const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts(), partsNonProducing = parts.every((part) => {
            const partNonProducing2 = isPartNonProducing(part, ruleMap, ruleNames);
            return partNonProducing2;
          });
          partNonProducing = partsNonProducing;
          break;
        }
      }
      return partNonProducing;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/complex.js
  var require_complex = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionComplex", {
      enumerable: true,
      get: function() {
        return isDefinitionComplex;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, SequenceOfPartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    function isDefinitionComplex(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartComplex = isPartComplex(firstPart), definitionComplex = firstPartComplex;
      return definitionComplex;
    }
    function isPartComplex(part) {
      let partComplex = true;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            partComplex = false;
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case SequenceOfPartsPartType:
          case ChoiceOfPartsPartType: {
            partComplex = true;
            break;
          }
        }
      }
      return partComplex;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/occluded.js
  var require_occluded = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionOccluded", {
      enumerable: true,
      get: function() {
        return isDefinitionOccluded;
      }
    });
    var _necessary = require_browser();
    var _nonConsuming = require_nonConsuming();
    var {first: first2} = _necessary.arrayUtilities;
    function isDefinitionOccluded(definition, ruleMap, ruleNames = []) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartNonConsuming = (0, _nonConsuming.isPartNonConsuming)(firstPart, ruleMap, ruleNames), definitionOccluded = firstPartNonConsuming;
      return definitionOccluded;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/callAhead.js
  var require_callAhead = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionCallAhead", {
      enumerable: true,
      get: function() {
        return isDefinitionCallAhead;
      }
    });
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    function isDefinitionCallAhead(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartCallAhead = isPartCallAhead(firstPart), definitionCallAhead = firstPartCallAhead;
      return definitionCallAhead;
    }
    function isPartCallAhead(part) {
      let partCallAhead = false;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, nonTerminalPartRuleNamePart = nonTerminalPart.isRuleNamePart();
        if (nonTerminalPartRuleNamePart) {
          const ruleNamePart = nonTerminalPart, callAhead = ruleNamePart.isCallAhead();
          partCallAhead = callAhead;
        }
      }
      return partCallAhead;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/qualified.js
  var require_qualified = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isDefinitionQualified() {
        return isDefinitionQualified;
      },
      get isPartQualified() {
        return isPartQualified;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var {OptionalPartPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    var {first: first2} = _necessary.arrayUtilities;
    function isPartQualified(part) {
      let partQualified = false;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case OptionalPartPartType:
          case OneOrMorePartsPartType:
          case ZeroOrMorePartsPartType: {
            partQualified = true;
            break;
          }
        }
      }
      return partQualified;
    }
    function isDefinitionQualified(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartQualified = isPartQualified(firstPart), definitionQualified = firstPartQualified;
      return definitionQualified;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/repeated/indirectly.js
  var require_indirectly2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return IndirectlyRepeatedRule;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon5());
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly());
    var _parts = require_parts2();
    var _nonProducing = require_nonProducing();
    var _complex = require_complex();
    var _occluded = require_occluded();
    var _callAhead = require_callAhead();
    var _qualified = require_qualified();
    var _ruleName = require_ruleName7();
    var _leftRecursive = require_leftRecursive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var IndirectlyRepeatedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _indirectly.default;
        return NonTerminalNode;
      }
      static fromRuleAndLeftRecursiveRule(rule, leftRecursiveRule, ruleMap) {
        let definitions = rule.getDefinitions();
        const leftRecursiveRuleName = leftRecursiveRule.getName();
        let leftRecursiveDefinitions = definitions.filter((definition) => {
          const definitionLeftRecursive = (0, _leftRecursive.isDefinitionLeftRecursive)(definition, ruleMap);
          if (definitionLeftRecursive) {
            const leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromDefinition)(definition, ruleMap), firstLeftRecursiveRuleName = first2(leftRecursiveRuleNames);
            if (firstLeftRecursiveRuleName === leftRecursiveRuleName) {
              const ruleName2 = rule.getName(), definitionString = definition.asString();
              const definitionComplex = (0, _complex.isDefinitionComplex)(definition);
              if (definitionComplex) {
                throw new Error(`The '${definitionString}' left recursive-definition of the '${ruleName2}' rule is complex.`);
              }
              const definitionOccluded = (0, _occluded.isDefinitionOccluded)(definition, ruleMap);
              if (definitionOccluded) {
                const definitionString2 = definition.asString();
                throw new Error(`The '${definitionString2}' left recursive definition of the '${ruleName2}' rule is occluded.`);
              }
              const definitionCallAhead = (0, _callAhead.isDefinitionCallAhead)(definition);
              if (definitionCallAhead) {
                throw new Error(`The first part of the '${definitionString}' left recursive definition of the '${ruleName2}' rule is look-ahead.`);
              }
              const definitionQualified = (0, _qualified.isDefinitionQualified)(definition);
              if (definitionQualified) {
                throw new Error(`The first part of the '${definitionString}' left recursive definition of the '${ruleName2}' rule is qualified.`);
              }
              return true;
            }
          }
        });
        const firstPartsEqual = areFirstPartsEqual(leftRecursiveDefinitions);
        if (!firstPartsEqual) {
          const ruleName2 = rule.getName();
          throw new Error(`The first parts of the '${leftRecursiveRuleName}' left recursive definitions in the '${ruleName2}' rule are not equal.`);
        }
        let precedence = null;
        leftRecursiveDefinitions = leftRecursiveDefinitions.filter((leftRecursiveDefinition) => {
          const parts = leftRecursiveDefinition.getParts(), partsLength = parts.length;
          if (partsLength === 1) {
            precedence = leftRecursiveDefinition.getPrecedence();
          } else {
            return true;
          }
        });
        const ruleName = rule.getName(), leftRecursiveRuleOpacity = leftRecursiveRule.getOpacity(), indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), name = indirectlyRepeatedRuleName, opacity = leftRecursiveRuleOpacity;
        definitions = definitionsFromLeftRecursiveDefinitions(leftRecursiveDefinitions);
        const indirectlyRepeatedRule = new IndirectlyRepeatedRule(name, opacity, definitions), indirectlyRepeatedRuleNonProducing = (0, _nonProducing.isRuleNonProducing)(indirectlyRepeatedRule, ruleMap);
        if (indirectlyRepeatedRuleNonProducing) {
          const epsilonDefinition = _epsilon.default.fromPrecedence(precedence);
          definitions.push(epsilonDefinition);
        }
        return indirectlyRepeatedRule;
      }
    };
    function areFirstPartsEqual(definitions) {
      const firstParts = definitions.map((definition) => {
        const parts = definition.getParts(), firstPart = first2(parts);
        return firstPart;
      }), firstPartsEqual = (0, _parts.arePartsEqual)(firstParts);
      return firstPartsEqual;
    }
    function definitionsFromLeftRecursiveDefinitions(leftRecursiveDefinitions) {
      const definitions = leftRecursiveDefinitions.map((leftRecursiveDefinition) => {
        let parts = leftRecursiveDefinition.getParts();
        parts = [
          ...parts
        ];
        parts.shift();
        const precedence = leftRecursiveDefinition.getPrecedence(), definition = _occamparsers.Definition.fromPartsAndPrecedence(parts, precedence);
        return definition;
      });
      return definitions;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createIndirectlyRepeatedRules.js
  var require_createIndirectlyRepeatedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createIndirectlyRepeatedRules;
      }
    });
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly2());
    var _cycle = require_cycle2();
    var _ruleNames = require_ruleNames4();
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createIndirectlyRepeatedRules(cycles, ruleMap) {
      cycles.forEach((cycle) => {
        const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle);
        (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName) => {
          const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName);
          let indirectlyRepeatedRule = ruleMap[indirectlyRepeatedRuleName] || null;
          if (indirectlyRepeatedRule === null) {
            const rule = ruleMap[ruleName], leftRecursiveRule = ruleMap[leftRecursiveRuleName];
            indirectlyRepeatedRule = _indirectly.default.fromRuleAndLeftRecursiveRule(rule, leftRecursiveRule, ruleMap);
            ruleMap[indirectlyRepeatedRuleName] = indirectlyRepeatedRule;
          }
        });
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/eliminateLeftRecursion.js
  var require_eliminateLeftRecursion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return eliminateLeftRecursion;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var _directedGraph = /* @__PURE__ */ _interop_require_default(require_directedGraph());
    var _createReducedRules = /* @__PURE__ */ _interop_require_default(require_createReducedRules());
    var _rewriteLeftRecursiveRules = /* @__PURE__ */ _interop_require_default(require_rewriteLeftRecursiveRules());
    var _createDirectlyRepeatedRules = /* @__PURE__ */ _interop_require_default(require_createDirectlyRepeatedRules());
    var _createIndirectlyRepeatedRules = /* @__PURE__ */ _interop_require_default(require_createIndirectlyRepeatedRules());
    var _directedGraph1 = require_directedGraph2();
    var _labels = require_labels();
    var _leftRecursive = require_leftRecursive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {filter} = _necessary.arrayUtilities;
    var {ruleMapFromRules, startRuleFromRules, rulesFromStartRuleAndRuleMap} = _occamparsers.rulesUtilities;
    function eliminateLeftRecursion(rules) {
      const ruleMap = ruleMapFromRules(rules), startRule = startRuleFromRules(rules), ruleNamesMap = ruleNamesMapFromNothing(ruleMap), cycles = cyclesFromStartRule(startRule, ruleMap, ruleNamesMap);
      (0, _createReducedRules.default)(cycles, ruleMap);
      (0, _createIndirectlyRepeatedRules.default)(cycles, ruleMap);
      (0, _createDirectlyRepeatedRules.default)(cycles, ruleMap);
      (0, _rewriteLeftRecursiveRules.default)(cycles, ruleMap, ruleNamesMap);
      rules = rulesFromStartRuleAndRuleMap(startRule, ruleMap);
      return rules;
    }
    function directedGraphFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const startRuleName = startRule.getName(), edges = (0, _directedGraph1.edgesFromStartRule)(startRule, ruleMap, ruleNamesMap), startVertex = startRuleName, directedGraph = _directedGraph.default.fromEdgesAndStartVertex(edges, startVertex);
      return directedGraph;
    }
    function ruleNamesMapFromNothing(ruleMap) {
      const ruleNamesMap = {}, ruleNames = Object.keys(ruleMap);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromRule)(rule, ruleMap), ruleNames2 = leftRecursiveRuleNames;
        ruleNamesMap[ruleName] = ruleNames2;
      });
      return ruleNamesMap;
    }
    function isCycleLeftRecursive(cycle) {
      const cycleLeftRecursive = cycle.everyEdge((edge) => {
        const label = edge.getLabel(), labelLeftRecursiveLabel = label === _labels.LEFT_RECURSIVE_LABEL, edgeLeftRecursive = labelLeftRecursiveLabel;
        if (edgeLeftRecursive) {
          return true;
        }
      });
      return cycleLeftRecursive;
    }
    function cyclesFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const directedGraph = directedGraphFromStartRule(startRule, ruleMap, ruleNamesMap), cycles = directedGraph.findCycles();
      filter(cycles, (cycle) => {
        const cycleLeftRecursive = isCycleLeftRecursive(cycle);
        if (cycleLeftRecursive) {
          return true;
        }
      });
      return cycles;
    }
  });

  // node_modules/occam-grammar-utilities/lib/index.js
  var require_lib10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ExampleLexer() {
        return _example.default;
      },
      get ExampleParser() {
        return _example1.default;
      },
      get eliminateLeftRecursion() {
        return _eliminateLeftRecursion.default;
      }
    });
    var _example = /* @__PURE__ */ _interop_require_default(require_example());
    var _example1 = /* @__PURE__ */ _interop_require_default(require_example2());
    var _eliminateLeftRecursion = /* @__PURE__ */ _interop_require_default(require_eliminateLeftRecursion());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/query.js
  var require_query3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
  });

  // node_modules/occam-grammars/lib/teX/entries.js
  var require_entries5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\$\\$|\\$|\\\\\\(|\\\\\\)|\\\\\\[|\\\\\\])"
      },
      {
        unassigned: "^(?:.+?(?=\\$\\$|\\$|\\\\\\(|\\\\\\)|\\\\\\[|\\\\\\])|.+)"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/teX/lexer.js
  var require_lexer7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TeXLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _TeXLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_TeXLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_TeXLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_TeXLexer, entries);
      }
    };
    var TeXLexer = _TeXLexer;
    __publicField(TeXLexer, "entries", _entries.default);
    __publicField(TeXLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(TeXLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(TeXLexer, "EndOfLineCommentToken", null);
    __publicField(TeXLexer, "SingleLineCommentToken", null);
    __publicField(TeXLexer, "RegularExpressionToken", null);
    __publicField(TeXLexer, "EndOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "StartOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(TeXLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/json/entries.js
  var require_entries6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:,|:|\\{|\\}|\\[|\\])"
      },
      {
        number: "^-?[1-9][0-9]*(\\.[0-9]+)?"
      },
      {
        boolean: "^(?:true|false)"
      },
      {
        null: "^(?:null)"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/json/lexer.js
  var require_lexer8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return JSONLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries6());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _JSONLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_JSONLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_JSONLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_JSONLexer, entries);
      }
    };
    var JSONLexer = _JSONLexer;
    __publicField(JSONLexer, "entries", _entries.default);
    __publicField(JSONLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(JSONLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(JSONLexer, "EndOfLineCommentToken", null);
    __publicField(JSONLexer, "SingleLineCommentToken", null);
    __publicField(JSONLexer, "RegularExpressionToken", null);
    __publicField(JSONLexer, "EndOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "StartOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(JSONLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/furtle/entries.js
  var require_entries7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var LATIN = "[\\p{Script=Latin}]";
    var DECIMAL = "[0-9]";
    var entries = [
      {
        type: "^(?:Nodes|Node|String|Number|Boolean)"
      },
      {
        query: "^(?:nodeQuery|nodesQuery)"
      },
      {
        "primary-keyword": "^return"
      },
      {
        "secondary-keyword": "^(?:if|else|reduce|every|some|as)"
      },
      {
        null: "^null"
      },
      {
        boolean: "^(?:true|false)"
      },
      {
        bracket: "^(?:\\{|\\})"
      },
      {
        special: "^(?:!=|==|!|=|,|;|_|&&|\\|\\||\\(|\\)|\\[|\\])"
      },
      {
        name: `^${LATIN}+${DECIMAL}*`
      },
      {
        number: `^${DECIMAL}+`
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/furtle/lexer.js
  var require_lexer9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _FurtleLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_FurtleLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_FurtleLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_FurtleLexer, entries);
      }
    };
    var FurtleLexer = _FurtleLexer;
    __publicField(FurtleLexer, "entries", _entries.default);
    __publicField(FurtleLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(FurtleLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(FurtleLexer, "RegularExpressionToken", null);
    __publicField(FurtleLexer, "EndOfLineCommentToken", _occamlexers.EndOfLineCommentNonSignificantToken);
    __publicField(FurtleLexer, "SingleLineCommentToken", _occamlexers.PythonStyleSingleLineCommentToken);
    __publicField(FurtleLexer, "EndOfMultiLineCommentToken", _occamlexers.PythonStyleEndOfMultiLineCommentToken);
    __publicField(FurtleLexer, "StartOfMultiLineCommentToken", _occamlexers.PythonStyleStartOfMultiLineCommentToken);
    __publicField(FurtleLexer, "MiddleOfMultiLineCommentToken", _occamlexers.PythonStyleMiddleOfMultiLineCommentToken);
    __publicField(FurtleLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(FurtleLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/nominal/entries.js
  var require_entries8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var GREEK = "[\\p{Script=Greek}]";
    var LATIN = "[\\p{Script=Latin}]";
    var DECIMAL = "[0-9]";
    var LATIN_LOWER_CASE = "[\\p{Script=Latin}&&\\p{Lowercase}]";
    var LATIN_UPPER_CASE = "[\\p{Script=Latin}&&\\p{Uppercase}]";
    var MATHEMATICAL_SANS_SERIF_BOLD = "[\\u{1D5D4}-\\u{1D607}]";
    var MATHEMATICAL_ITALIC_UPPER_CASE = "[\\u{1D434}-\\u{1D44D}]";
    var MATHEMATICAL_SCRIPT_UPPER_CASE = "[\\u{1D49C}\\u{212C}\\u{1D49E}\\u{1D49F}\\u{2130}\\u{2131}\\u{1D4A2}\\u{210B}\\u{2110}\\u{1D4A5}\\u{1D4A6}\\u{2112}\\u{2133}\\u{1D4A9}-\\u{1D4AC}\\u{211B}\\u{1D4AE}-\\u{1D4B5}]";
    var MATHEMATICAL_FRAKTUR_UPPER_CASE = "[\\u{1D504}\\u{1D505}\\u{212D}\\u{1D507}-\\u{1D50A}\\u{210C}\\u{2111}\\u{1D50D}-\\u{1D514}\\u{211C}\\u{1D516}-\\u{1D51C}\\u{2128}]";
    var entries = [
      {
        "primary-keyword": "^(?:Rule|Axiom|Theorem|Lemma|Conjecture|MetaLemma|Metatheorem|Premises|Premise|Conclusion|Proof|Therefore|Suppose|Hence|Then|Provisional|Type|TypePrefix|Properties|Property|Variable|Constructor|Combinator|Metavariable|Given)\\b"
      },
      {
        "secondary-keyword": "^(?:is|in|an|a|of|by|from|because|for|satisfies|provisionally|defined|undefined|missing|present)\\b"
      },
      {
        "meta-type": "^(?:Statement|Reference|Frame)\\b"
      },
      {
        name: `^(?:${LATIN_UPPER_CASE}${LATIN}*${DECIMAL}*|${LATIN_LOWER_CASE}${LATIN}+${DECIMAL}*)`
      },
      {
        identifier: `^(?:${LATIN_LOWER_CASE}${DECIMAL}*|${GREEK}+|${MATHEMATICAL_SANS_SERIF_BOLD}+|${MATHEMATICAL_ITALIC_UPPER_CASE}+|${MATHEMATICAL_SCRIPT_UPPER_CASE}+|${MATHEMATICAL_FRAKTUR_UPPER_CASE}+)`
      },
      {
        primitive: "^(?:\\||\\.\\.\\.|\\(|\\)|\\[|\\]|\\+|-|,|<|>)"
      },
      {
        special: "^(?:@|::|:|=)"
      },
      {
        unassigned: "^[^\\s\\(\\)\\[\\]:,]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/nominal/lexer.js
  var require_lexer10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NominalLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries8());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NominalLexer = class extends _occamlexers.CommonLexer {
    };
    __publicField(NominalLexer, "entries", _entries.default);
    __publicField(NominalLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(NominalLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(NominalLexer, "RegularExpressionToken", null);
    __publicField(NominalLexer, "EndOfLineCommentToken", _occamlexers.EndOfLineCommentSignificantToken);
    __publicField(NominalLexer, "SingleLineCommentToken", _occamlexers.PythonStyleSingleLineCommentToken);
    __publicField(NominalLexer, "EndOfMultiLineCommentToken", _occamlexers.PythonStyleEndOfMultiLineCommentToken);
    __publicField(NominalLexer, "StartOfMultiLineCommentToken", _occamlexers.PythonStyleStartOfMultiLineCommentToken);
    __publicField(NominalLexer, "MiddleOfMultiLineCommentToken", _occamlexers.PythonStyleMiddleOfMultiLineCommentToken);
    __publicField(NominalLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(NominalLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/plainText/entries.js
  var require_entries9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        "alpha-numeric": "^[a-zA-Z0-9]+"
      },
      {
        punctuation: "^[@,\\.\"'`]+"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/plainText/lexer.js
  var require_lexer11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PlainTextLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries9());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PlainTextLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_PlainTextLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_PlainTextLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_PlainTextLexer, entries);
      }
    };
    var PlainTextLexer = _PlainTextLexer;
    __publicField(PlainTextLexer, "entries", _entries.default);
    __publicField(PlainTextLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(PlainTextLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(PlainTextLexer, "EndOfLineCommentToken", null);
    __publicField(PlainTextLexer, "SingleLineCommentToken", null);
    __publicField(PlainTextLexer, "RegularExpressionToken", null);
    __publicField(PlainTextLexer, "EndOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "StartOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(PlainTextLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/entries.js
  var require_entries10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\||\\(|\\)|\\?|\\*|\\+|::=|;|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        number: "^(?:0|[1-9][0-9]*)"
      },
      {
        name: "^[\\w~]+"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/lexer.js
  var require_lexer12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarBNFnLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries10());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarBNFnLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CustomGrammarBNFnLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CustomGrammarBNFnLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CustomGrammarBNFnLexer, entries);
      }
    };
    var CustomGrammarBNFnLexer = _CustomGrammarBNFnLexer;
    __publicField(CustomGrammarBNFnLexer, "entries", _entries.default);
    __publicField(CustomGrammarBNFnLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(CustomGrammarBNFnLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CustomGrammarBNFnLexer, "EndOfLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "RegularExpressionToken", null);
    __publicField(CustomGrammarBNFnLexer, "SingleLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CustomGrammarBNFnLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/entries.js
  var require_entries11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/lexer.js
  var require_lexer13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarVocabularyLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries11());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarVocabularyLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CustomGrammarVocabularyLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CustomGrammarVocabularyLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CustomGrammarVocabularyLexer, entries);
      }
    };
    var CustomGrammarVocabularyLexer = _CustomGrammarVocabularyLexer;
    __publicField(CustomGrammarVocabularyLexer, "entries", _entries.default);
    __publicField(CustomGrammarVocabularyLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(CustomGrammarVocabularyLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CustomGrammarVocabularyLexer, "EndOfLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "SingleLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "RegularExpressionToken", null);
    __publicField(CustomGrammarVocabularyLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CustomGrammarVocabularyLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/teX/bnf.js
  var require_bnf6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document                        ::=   ( delimitedTeX | plainMarkup )+ ;
    
    
    
    delimitedTeX                    ::=   dollarDelimiter inlineTeX dollarDelimiter 
    
                                      |   doubleDollarDelimiter displayTeX doubleDollarDelimiter 
    
                                      |   openingBracketDelimiter inlineTeX closingBracketDelimiter 
    
                                      |   openingSquareBracketDelimiter displayTeX closingSquareBracketDelimiter 
                                      
                                      ;
    

    
    inlineTeX                       ::=   [unassigned]* ;

    displayTeX                      ::=   [unassigned]* ;



    dollarDelimiter                 ::=   "$" ;
 
    doubleDollarDelimiter           ::=   "$$" ;
    

    
    openingBracketDelimiter         ::=   "\\(" ;

    closingBracketDelimiter         ::=   "\\)" ;

    openingSquareBracketDelimiter   ::=   "\\[" ;
    
    closingSquareBracketDelimiter   ::=   "\\]" ;
    
    
    
    plainMarkup                     ::=   . ;


`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/teX/parser.js
  var require_parser8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TeXParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf6());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _TeXParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_TeXParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_TeXParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_TeXParser, rules);
      }
    };
    var TeXParser = _TeXParser;
    __publicField(TeXParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/json/bnf.js
  var require_bnf7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document     ::=  json error* 
    
                   |  error+ 
                                 
                   ;
  
  
  
    json         ::=  array 
    
                   |  object 
    
                   |  [string-literal] 
    
                   |  [boolean] 
    
                   |  [number] 
    
                   |  [null] 
    
                   ;
  
  
  
    array..      ::=  "[" ( element ( "," element )* )? nonsense? "]" ;
  
  
     
    object..     ::=  "{" ( property ( "," property )* )? nonsense? "}" ;
  
  
    
    property     ::=  [string-literal] ":" json ;
  
    

    element      ::=  json ;
  
    

    nonsense.    ::=  ( ":" | "," | [string-literal] | [number] | [boolean] | [null] | [unassigned] )+ ;
    


    error.       ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/json/parser.js
  var require_parser9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return JSONParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _JSONParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_JSONParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_JSONParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_JSONParser, rules);
      }
    };
    var JSONParser = _JSONParser;
    __publicField(JSONParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/furtle/bnf.js
  var require_bnf8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document                ::=  ( procedureDeclaration | error )+ ;
    
    
    
    procedureDeclaration    ::=  [type] label<NO_WHITESPACE>"(" parameters? ")" returnBlock ;
    
    anonymousProcedure      ::=  [type] "(" parameters? ")" returnBlock ;
    
    returnStatement         ::=  "return" term ";" ; 
    
    
    
    step                    ::=  arrayAssignment
                              
                              |  objectAssignment
                              
                              |  variableAssignments
     
                              ;  
      
      
    
    arrayAssignment         ::=  "[" parameters "]" "=" variable ";" ;
    
    objectAssignment        ::=  "{" namedParameters "}" "=" variable ";" ;
    
    variableAssignments     ::=  [type] variableAssignment ( "," variableAssignment )* ";" ;
    
    variableAssignment      ::=  variable "=" expression ;
    


    namedParameters         ::=  namedParameter ( "," namedParameter )* ;
    
    parameters              ::=  parameter ( "," parameter )* ;
    
    terms                   ::=  term ( "," term )* ;
    


    namedParameter          ::=  [type] [name] ( "as" [name] )? ;   
    
    parameter               ::=  [type] [name]
    
                              |  "_" 
    
                              ;


    
    procedureCall           ::=  reference<NO_WHITESPACE>"(" terms? ")" ;
    
    returnBlock..           ::=  "{" ( step | nonsense )* returnStatement "}" ;
                                     
    nodesQuery              ::=  "nodesQuery"<NO_WHITESPACE>"(" variable "," [string-literal] ")" ;
    
    nodeQuery               ::=  "nodeQuery"<NO_WHITESPACE>"(" variable "," [string-literal] ")" ;
    
    ternary                 ::=  "if" "(" term ")" expression "else" expression ;
    
    reduce                  ::=  "reduce"<NO_WHITESPACE>"(" variable "," anonymousProcedure "," expression ")" ;
    
    every                   ::=  "every"<NO_WHITESPACE>"(" variable "," anonymousProcedure ")" ;
    
    some                    ::=  "some"<NO_WHITESPACE>"(" variable "," anonymousProcedure ")" ;
    
    
    
    comparisonTerm          ::=  term ( "==" | "!=" ) term ; 
    
    bracketedTerm           ::=  "(" term ")" ; 
    
    negatedTerm             ::=  "!"<NO_WHITESPACE>term ; 
    
    logicalTerm             ::=  term ( "||" | "&&" ) term ; 


    
    expression              ::=  procedureCall
     
                              |  returnBlock
    
                              |  nodesQuery
                              
                              |  nodeQuery
                              
                              |  ternary
                              
                              |  reduce
    
                              |  every
    
                              |  some
                             
                              |  term
                              
                              ;
    
    
    
    term                    ::=  comparisonTerm 
    
                              |  bracketedTerm 
    
                              |  logicalTerm 
    
                              |  negatedTerm 
    
                              |  primitive 
    
                              |  variable 
                              
                              ;


    
    primitive               ::=  [string-literal]
                              
                              |  [boolean]
                              
                              |  [number] 
                              
                              |  [null]
                             
                              ;



    reference.              ::=  [name] ;
    
    variable                ::=  [name] ;
    
    label.                  ::=  [name] ;
    
    
    
    nonsense.               ::=  [secondary-keyword] | [type] | [null] | [boolean] | [string-literal] | [query] | [special] | [name] | [number] | [unassigned] ;


    
    error.                  ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/furtle/parser.js
  var require_parser10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf8());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _FurtleParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_FurtleParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_FurtleParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_FurtleParser, rules);
      }
    };
    var FurtleParser = _FurtleParser;
    __publicField(FurtleParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/nominal/bnf.js
  var require_bnf9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `document                             ::=  ( variableDeclaration 
                                           
                                          | combinatorDeclaration 
                                                          
                                          | constructorDeclaration 
                                                          
                                          | metavariableDeclaration 
                                                          
                                          | typePrefixDeclaration  
                                                                                                     
                                          | simpleTypeDeclaration 
                                                          
                                          | complexTypeDeclaration 
                                                      
                                          | rule 
               
                                          | axiom 
               
                                          | lemma 
               
                                          | theorem 
               
                                          | conjecture 
               
                                          | metaLemma 
               
                                          | metatheorem  
                                                      
                                          | section 
                                                      
                                          | verticalSpace 
                                                      
                                          | error )+ ;



section                              ::=  "Given" <END_OF_LINE>

                                          hypothesis+
                                          
                                          <END_OF_LINE>
                                          
                                          ( axiom 
                                          
                                          | lemma 
                                          
                                          | theorem 
                                          
                                          | conjecture ) ; 



verticalSpace                        ::=  <END_OF_LINE>+ ;



error.                               ::=  . ;



variableDeclaration                  ::=  "Variable" variable ( ":" type "provisionally"? )? <END_OF_LINE> ;
 
combinatorDeclaration                ::=  "Combinator" combinator... <END_OF_LINE> ;
 
constructorDeclaration               ::=  "Constructor" constructor... ( ":" type "provisionally"? )? <END_OF_LINE> ;
 
metavariableDeclaration              ::=  "Metavariable" metavariable... ":" metaType <END_OF_LINE> ;
 
typePrefixDeclaration                ::=  "TypePrefix" typePrefix <END_OF_LINE> ;

simpleTypeDeclaration                ::=  "Provisional"? "Type" type ( ":" types )? <END_OF_LINE> ;
 
complexTypeDeclaration               ::=  "Provisional"? "Type" <END_OF_LINE> 

                                          type ( ":" types )? <END_OF_LINE>
                                          
                                          (
                                          
                                            ( "Properties" <END_OF_LINE> propertyDeclaration propertyDeclaration+ ) 
                                             
                                            | 
                                             
                                            ( "Property" <END_OF_LINE> propertyDeclaration ) 
                                             
                                          );
  

  
rule                                 ::=  ruleHeader ruleBody ;                                         

metaLemma                            ::=  metaLemmaHeader metaLemmaBody ;

metatheorem                          ::=  metatheoremHeader metatheoremBody ;

axiom                                ::=  axiomHeader axiomBody ;

lemma                                ::=  lemmaHeader lemmaBody ;

theorem                              ::=  theoremHeader theoremBody ;

conjecture                           ::=  conjectureHeader conjectureBody ;



ruleHeader                          ::=  "Rule" parenthesisedLabels... <END_OF_LINE> ; 

metaLemmaHeader                     ::=  "MetaLemma" parenthesisedLabel... <END_OF_LINE> | "MetaLemma" <END_OF_LINE> ;

metatheoremHeader                   ::=  "Metatheorem" parenthesisedLabel... <END_OF_LINE> ; 

axiomHeader                         ::=  "Axiom" signature? parenthesisedLabels... <END_OF_LINE> ; 

lemmaHeader                         ::=  "Lemma" parenthesisedLabels... <END_OF_LINE> | "Lemma" <END_OF_LINE> ; 

theoremHeader                       ::=  "Theorem" parenthesisedLabels... <END_OF_LINE> ; 

conjectureHeader                    ::=  "Conjecture" parenthesisedLabels... <END_OF_LINE> ;



ruleBody                             ::=  ( 

                                            ( "Premises" <END_OF_LINE> premise premise+ ) 
                                             
                                            | 
                                             
                                            ( "Premise" <END_OF_LINE> premise ) 
                                             
                                          )?
                                             
                                          "Conclusion" <END_OF_LINE> conclusion 
                                           
                                          proof? ;                                         

metaLemmaBody                        ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+ 

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                                                                         
                                          proof ;

metatheoremBody                      ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+ 

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                           
                                          proof ;

axiomBody                            ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+
    
                                            "Then" <END_OF_LINE> 
                                                 
                                          )?
                                                 
                                          deduction ;

lemmaBody                            ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                           
                                          proof ;

theoremBody                          ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                             
                                          deduction
                                           
                                          proof ;

conjectureBody                       ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                             
                                          deduction
                                           
                                          proof? ;



proof                                ::=  "Proof" <END_OF_LINE> derivation ;

subproof                             ::=  "Suppose" <END_OF_LINE> supposition+ subDerivation ;

derivation                           ::=  ( 

                                            ( step | subproof )+ 
                                            
                                            "Therefore" <END_OF_LINE> 
                                            
                                          )? 
                                          
                                          step ;                                        

subDerivation                        ::=  (

                                            "Hence" <END_OF_LINE>
    
                                            ( step | subproof )+ 
                                                                                         
                                          )? 
                                           
                                          "Then" <END_OF_LINE> 
                                           
                                          step ;                                        



propertyDeclaration.                 ::=  property ( ":" type )? <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;



combinator                           ::=  statement ;

constructor                          ::=  term ; 

 

premise.                             ::=  procedureCall <END_OF_LINE>  

                                       |  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

supposition.                         ::=  procedureCall <END_OF_LINE>  

                                       |  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

conclusion.                          ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

deduction.                           ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

hypothesis.                          ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;



step.                                ::=  statement... qualification? <END_OF_LINE>  

                                       |  nonsense... qualification? <END_OF_LINE>
                                       
                                       ;



qualification                        ::=  "because" satisfiesAssertion

                                       |  ( "by" | "from" ) reference
                                       
                                       ; 



parenthesisedLabels                  ::=  "(" labels ")" ; 

parenthesisedLabel                   ::=  "(" label ")" ; 



procedureCall                        ::=  "@"<NO_WHITESPACE>procedureReference<NO_WHITESPACE>"(" parameter ( "," parameter )* ")" ;



signature                            ::=  "[" term ( "," term )* "]" ;



arguments                            ::=  argument ( "," argument )* ;

labels                               ::=  label ( "," label )* ;

types                                ::=  type ( "," type )* ;



argument                             ::=  term ( ) 

                                       |  type ( )
                                       
                                       ;

metaArgument                         ::=  statement ( ) 

                                       |  metaType ( ) 
                                       
                                       ;

frameArgument                        ::=  frame ( ) 

                                       |  metaType ( ) 
                                       
                                       ;


procedureReference.                  ::=  [name] ;

reference.                           ::=  metavariable ;

label.                               ::=  metavariable ;



equivalences                         ::=  equivalence ( "," equivalence )* ;

equivalence                          ::=  "[" term ( "," term )+ "]" ;



metavariable.                        ::=  [name] ( <NO_WHITESPACE>"(" ( term | type | stuff ) ")" )? ;

parameter.                           ::=  [name] | [identifier] ;

variable.                            ::=  [identifier] ;

metaType.                            ::=  [meta-type] ;

property.                            ::=  [name]+ ;

typePrefix.                          ::=  [type] ;

type.                                ::=  [type] ( <NO_WHITESPACE>[type] )? 

                                       |  "<"<NO_WHITESPACE>">"

                                       ;



stuff.                               ::=  ( [string-literal] | [symbol] | [type] | [name] | [identifier] | [primitive] | [unassigned] )+ ;

nonsense.                            ::=  ( [secondary-keyword] | [meta-type] | [special] | [symbol] | [type] | [name] | [identifier] | [primitive] | [unassigned] )+ ;`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/nominal/parser.js
  var require_parser11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NominalParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf9());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NominalParser = class extends _occamparsers.CommonParser {
    };
    __publicField(NominalParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/plainText/bnf.js
  var require_bnf10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document       ::=  ( block | verticalSpace )+ ;

    block          ::=  endedLine* lastLine 
                          
                     |  endedLine+
                          
                     ;

    lastLine       ::=  ( [alpha-numeric] | [punctuation] | [unassigned] )+ ;

    endedLine      ::=  ( [alpha-numeric] | [punctuation] | [unassigned] )+ <END_OF_LINE> ;

    verticalSpace  ::=  <END_OF_LINE>+ ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/plainText/parser.js
  var require_parser12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PlainTextParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf10());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PlainTextParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_PlainTextParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_PlainTextParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_PlainTextParser, rules);
      }
    };
    var PlainTextParser = _PlainTextParser;
    __publicField(PlainTextParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/bnf.js
  var require_bnf11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

      document                 ::=  ( rule | error )+ ;

      rule                     ::=  name "::=" definitions ";" ;

      name                     ::=  [name] ;

      definitions              ::=  definition ( "|" definition )* ;

      definition               ::=  part+ precedence? ;
 
      part                     ::=  nonTerminalPart quantifier*

                                 |  terminalPart quantifier*

                                 ;

      nonTerminalPart          ::=  choiceOfParts

                                 |  sequenceOfParts

                                 |  ruleName 

                                 ;

      terminalPart             ::=  significantTokenType
  
                                 |  stringLiteral
  
                                 |  endOfLine
  
                                 |  noWhitespace
                              
                                 ;
                              
      sequenceOfParts          ::=  "(" part part+ ")" ;

      choiceOfParts            ::=  "(" partChoice ( "|" partChoice )+ ")" ;

      partChoice               ::=  part precedence? ;

      ruleName                 ::=  [name] ;

      significantTokenType     ::=  [type] ;

      stringLiteral            ::=  [string-literal] ;

      precedence               ::=  "(" [number]? ")" ;
      
      endOfLine                ::=  "<END_OF_LINE>" ;
      
      noWhitespace             ::=  "<NO_WHITESPACE>" ;                              

      quantifier               ::=  optionalQuantifier
 
                                 |  oneOrMoreQuantifier
  
                                 |  zeroOrMoreQuantifier
  
                                 ;

      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;

      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;

      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;

      error.                   ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/parser.js
  var require_parser13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarBNFParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf11());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarBNFParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CustomGrammarBNFParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CustomGrammarBNFParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CustomGrammarBNFParser, rules);
      }
    };
    var CustomGrammarBNFParser = _CustomGrammarBNFParser;
    __publicField(CustomGrammarBNFParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/bnf.js
  var require_bnf12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document       ::=  ( expression | verticalSpace | error )+ ;

    expression     ::=  <NO_WHITESPACE>[unassigned]<NO_WHITESPACE><END_OF_LINE> ;

    verticalSpace  ::=  <END_OF_LINE>+ ;
   
    error.         ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/parser.js
  var require_parser14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarVocabularyParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf12());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarVocabularyParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CustomGrammarVocabularyParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CustomGrammarVocabularyParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CustomGrammarVocabularyParser, rules);
      }
    };
    var CustomGrammarVocabularyParser = _CustomGrammarVocabularyParser;
    __publicField(CustomGrammarVocabularyParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/index.js
  var require_lib11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CustomGrammarBNFLexer() {
        return _lexer5.default;
      },
      get CustomGrammarBNFParser() {
        return _parser5.default;
      },
      get CustomGrammarVocabularyLexer() {
        return _lexer6.default;
      },
      get CustomGrammarVocabularyParser() {
        return _parser6.default;
      },
      get FurtleLexer() {
        return _lexer2.default;
      },
      get FurtleParser() {
        return _parser2.default;
      },
      get JSONLexer() {
        return _lexer1.default;
      },
      get JSONParser() {
        return _parser1.default;
      },
      get NominalLexer() {
        return _lexer3.default;
      },
      get NominalParser() {
        return _parser3.default;
      },
      get PlainTextLexer() {
        return _lexer4.default;
      },
      get PlainTextParser() {
        return _parser4.default;
      },
      get TeXLexer() {
        return _lexer.default;
      },
      get TeXParser() {
        return _parser.default;
      }
    });
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer7());
    var _lexer1 = /* @__PURE__ */ _interop_require_default(require_lexer8());
    var _lexer2 = /* @__PURE__ */ _interop_require_default(require_lexer9());
    var _lexer3 = /* @__PURE__ */ _interop_require_default(require_lexer10());
    var _lexer4 = /* @__PURE__ */ _interop_require_default(require_lexer11());
    var _lexer5 = /* @__PURE__ */ _interop_require_default(require_lexer12());
    var _lexer6 = /* @__PURE__ */ _interop_require_default(require_lexer13());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser8());
    var _parser1 = /* @__PURE__ */ _interop_require_default(require_parser9());
    var _parser2 = /* @__PURE__ */ _interop_require_default(require_parser10());
    var _parser3 = /* @__PURE__ */ _interop_require_default(require_parser11());
    var _parser4 = /* @__PURE__ */ _interop_require_default(require_parser12());
    var _parser5 = /* @__PURE__ */ _interop_require_default(require_parser13());
    var _parser6 = /* @__PURE__ */ _interop_require_default(require_parser14());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/grammar.js
  var require_grammar = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get customGrammarBNFLexer() {
        return customGrammarBNFLexer;
      },
      get customGrammarBNFParser() {
        return customGrammarBNFParser;
      },
      get customGrammarVocabularyLexer() {
        return customGrammarVocabularyLexer;
      },
      get customGrammarVocabularyParser() {
        return customGrammarVocabularyParser;
      }
    });
    var _occamgrammars = require_lib11();
    var customGrammarBNFLexer = _occamgrammars.CustomGrammarBNFLexer.fromNothing();
    var customGrammarBNFParser = _occamgrammars.CustomGrammarBNFParser.fromNothing();
    var customGrammarVocabularyLexer = _occamgrammars.CustomGrammarVocabularyLexer.fromNothing();
    var customGrammarVocabularyParser = _occamgrammars.CustomGrammarVocabularyParser.fromNothing();
  });

  // node_modules/occam-custom-grammars/lib/utilities/vocabulary.js
  var require_vocabulary = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "expressionsFromVocabulary", {
      enumerable: true,
      get: function() {
        return expressionsFromVocabulary;
      }
    });
    var _necessary = require_browser();
    var _query = require_query3();
    var _grammar = require_grammar();
    var {second} = _necessary.arrayUtilities;
    var expressionNodesQuery = (0, _query.nodesQuery)("//expression");
    function expressionsFromVocabulary(vocabulary, expressions) {
      const content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
      if (node === null) {
        return;
      }
      const expressionNodes = expressionNodesQuery(node);
      expressionNodes.forEach((expressionNode) => {
        const content2 = contentFromExpressionNode(expressionNode), expression = escape(content2);
        expressions.push(expression);
      });
    }
    function contentFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, childNodes = nonTerminalNode.getChildNodes(), secondChildNode = second(childNodes), unassignedTerminalNode = secondChildNode, content = unassignedTerminalNode.getContent();
      return content;
    }
    function escape(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/nominal.js
  var require_nominal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nominalLexer() {
        return nominalLexer;
      },
      get nominalParser() {
        return nominalParser;
      }
    });
    var _occamlexers = require_lib3();
    var _occamparsers = require_lib4();
    var _occamgrammars = require_lib11();
    var nominalLexer = _occamlexers.CommonLexer.fromNothing(_occamgrammars.NominalLexer);
    var nominalParser = _occamparsers.CommonParser.fromNothing(_occamgrammars.NominalParser);
  });

  // node_modules/occam-custom-grammars/lib/typesMap.js
  var require_typesMap = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _nominal = require_nominal();
    var _ruleNames = require_ruleNames3();
    var _constants = require_constants10();
    var {first: first2} = _necessary.arrayUtilities;
    var ruleMap = _nominal.nominalParser.getRuleMap();
    var stuffRule = ruleMap[_constants.STUFF_RULE_NAME];
    var nonsenseRule = ruleMap[_constants.NONSENSE_RULE_NAME];
    var stuffTypes = typesFromRule(stuffRule);
    var nonsenseTypes = typesFromRule(nonsenseRule);
    var termTypes = stuffTypes;
    var statementTypes = nonsenseTypes;
    var typesMap = {
      [_ruleNames.TERM_RULE_NAME]: termTypes,
      [_ruleNames.STATEMENT_RULE_NAME]: statementTypes
    };
    var _default = typesMap;
    function typesFromRule(rule) {
      let parts;
      const definitions = rule.getDefinitions(), firstDDefinition = first2(definitions), definition = firstDDefinition;
      parts = definition.getParts();
      const firstPart = first2(parts), oneOrMorePartsPart = firstPart, part = oneOrMorePartsPart.getPart(), choiceOrPartsPart = part;
      parts = choiceOrPartsPart.getParts();
      const types = parts.map((part2) => {
        const significantTokenTypePart = part2, significantTokenType = significantTokenTypePart.getSignificantTokenType(), type = significantTokenType;
        return type;
      });
      return types;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/validate.js
  var require_validate = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get validateBNF() {
        return validateBNF;
      },
      get validateVocabulary() {
        return validateVocabulary;
      }
    });
    var _necessary = require_browser();
    var _typesMap = /* @__PURE__ */ _interop_require_default(require_typesMap());
    var _nominal = require_nominal();
    var _query = require_query3();
    var _constants = require_constants10();
    var _grammar = require_grammar();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var expressionNodesQuery = (0, _query.nodesQuery)("//expression");
    var ruleNameTerminalNodeQuery = (0, _query.nodeQuery)("/document/rule/name/@*!");
    var unassignedTerminalNodeQuery = (0, _query.nodeQuery)("/expression/@unassigned");
    var stringLiteralTerminalNodesQuery = (0, _query.nodesQuery)("//stringLiteral/@*!");
    var significantTokenTypeTerminalNodesQuery = (0, _query.nodesQuery)("//significantTokenType/@*!");
    function validateBNF(bnf, ruleName) {
      const content = bnf, tokens = _grammar.customGrammarBNFLexer.tokenise(content), node = _grammar.customGrammarBNFParser.parse(tokens);
      if (node === null) {
        return;
      }
      const ruleNameTerminalNode = ruleNameTerminalNodeQuery(node);
      if (ruleNameTerminalNode !== null) {
        const name = nameFromRuleNameTerminalNode(ruleNameTerminalNode);
        if (name !== ruleName) {
          throw new Error(`The '${name}' rule should be named '${ruleName}'.`);
        }
      }
      const types = _typesMap.default[ruleName], significantTokenTypeTerminalNodes = significantTokenTypeTerminalNodesQuery(node);
      significantTokenTypeTerminalNodes.forEach((significantTokenTypeTerminalNode) => {
        const type = typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
          throw new Error(`The '${type}' type is not included in the '${ruleName}' rule's types.`);
        }
      });
      const stringLiteralTerminalNodes = stringLiteralTerminalNodesQuery(node);
      stringLiteralTerminalNodes.forEach((stringLiteralTerminalNode) => {
        const content2 = contentFromStringLiteralTerminalNode(stringLiteralTerminalNode);
        if (content2 === _constants.BASE_TYPE_SYMBOL) {
          throw new Error(`The "${content2}" string literal cannot be the same as the base type symbol.`);
        }
        const tokens2 = _nominal.nominalLexer.tokenise(content2), tokensLength = tokens2.length;
        if (tokensLength !== 1) {
          throw new Error(`Tokenising the "${content2}" string literal does not result in a single token.`);
        }
        const firstToken = first2(tokens2), token = firstToken, type = token.getType(), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
          throw new Error(`The "${content2}" string literal's token's '${type}' type is not included in the '${ruleName}' rule's types.`);
        }
      });
    }
    function validateVocabulary(vocabulary) {
      const content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
      if (node === null) {
        return;
      }
      const expressionNodes = expressionNodesQuery(node);
      expressionNodes.forEach((expressionNode) => {
        const content2 = contentFromExpressionNode(expressionNode), tokens2 = _nominal.nominalLexer.tokenise(content2), tokensLength = tokens2.length;
        if (tokensLength > 1) {
          throw new Error(`Tokenising the '${content2}' content results in more than one token.`);
        }
        const firstToken = first2(tokens2), token = firstToken, type = token.getType();
        if (type !== _constants.UNASSIGNED_TYPE) {
          throw new Error(`The '${type}' type of the '${content2}' token is not 'unassigned'.`);
        }
        if (content2 === _constants.BASE_TYPE_SYMBOL) {
          throw new Error(`The '${content2}' token cannot be the same as the base type symbol.`);
        }
      });
    }
    function contentFromExpressionNode(expressionNode) {
      let content;
      const unassignedTerminalNode = unassignedTerminalNodeQuery(expressionNode);
      content = unassignedTerminalNode.getContent();
      return content;
      ;
    }
    function nameFromRuleNameTerminalNode(ruleNameTerminalNode) {
      let name;
      const content = ruleNameTerminalNode.getContent();
      name = content;
      return name;
    }
    function contentFromStringLiteralTerminalNode(stringLiteralTerminalNode) {
      let content;
      content = stringLiteralTerminalNode.getContent();
      const matches = content.match(/"([^"]*)"/), secondMatch = second(matches);
      content = secondMatch;
      return content;
    }
    function typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode) {
      let type;
      const content = significantTokenTypeTerminalNode.getContent(), matches = content.match(/\[([^\]]*)\]/), secondMatch = second(matches);
      type = secondMatch;
      return type;
    }
  });

  // node_modules/occam-custom-grammars/lib/customGrammar/combined.js
  var require_combined = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CombinedCustomGrammar;
      }
    });
    var _necessary = require_browser();
    var _occamlexers = require_lib3();
    var _occamparsers = require_lib4();
    var _occamgrammarutilities = require_lib10();
    var _default = /* @__PURE__ */ _interop_require_default(require_default());
    var _vocabulary = require_vocabulary();
    var _constants = require_constants10();
    var _validate = require_validate();
    var _ruleNames = require_ruleNames3();
    var _vocabularyNames = require_vocabularyNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque} = _occamlexers.specialSymbols;
    var {rulesFromBNF} = _occamparsers.parserUtilities;
    var {unshift, forwardsForEach, backwardsForEach} = _necessary.arrayUtilities;
    var CombinedCustomGrammar = class {
      constructor(rules, entries) {
        this.rules = rules;
        this.entries = entries;
      }
      getRules() {
        return this.rules;
      }
      getEntries() {
        return this.entries;
      }
      postProcess(rules) {
        rules = [
          ...rules,
          ...this.rules
        ];
        rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
        return rules;
      }
      static fromNothing(includeDefault = true) {
        let customGrammars = [];
        if (includeDefault) {
          customGrammars = [
            _default.default,
            ...customGrammars
          ];
        }
        const rules = rulesFromCustomGrammars(customGrammars), entries = entriesFromCustomGrammars(customGrammars), combinedCustomGrammar = new CombinedCustomGrammar(rules, entries);
        return combinedCustomGrammar;
      }
      static fromCustomGrammars(customGrammars, includeDefault = true) {
        if (includeDefault) {
          customGrammars = [
            _default.default,
            ...customGrammars
          ];
        }
        const rules = rulesFromCustomGrammars(customGrammars), entries = entriesFromCustomGrammars(customGrammars), combinedCustomGrammar = new CombinedCustomGrammar(rules, entries);
        return combinedCustomGrammar;
      }
    };
    function rulesFromCustomGrammars(customGrammars) {
      const ruleNames = [
        _ruleNames.TERM_RULE_NAME,
        _ruleNames.STATEMENT_RULE_NAME
      ], bnfs = ruleNames.map((ruleName) => {
        const bnf2 = bnfFromCustomGrammars(customGrammars, ruleName);
        return bnf2;
      }), bnf = bnfs.join(_constants.VERTICAL_SPACE), rules = rulesFromBNF(bnf);
      combineRules(rules);
      const opacity = opaque;
      ruleNames.forEach((ruleName) => {
        const rule = rules.find((rule2) => {
          const name = rule2.getName();
          if (name === ruleName) {
            return true;
          }
        });
        rule.setOpacity(opacity);
      });
      return rules;
    }
    function entriesFromCustomGrammars(customGrammars) {
      const vocabularyNames = [
        _vocabularyNames.TYPE_VOCABULARY_NAME,
        _vocabularyNames.SYMBOL_VOCABULARY_NAME
      ], entries = vocabularyNames.map((vocabularyName) => {
        const entry = entryFromCustomGrammars(customGrammars, vocabularyName);
        return entry;
      });
      return entries;
    }
    function entryFromCustomGrammars(customGrammars, vocabularyName) {
      const expressions = [];
      backwardsForEach(customGrammars, (customGrammar) => {
        const vocabulary = customGrammar.getVocabulary(vocabularyName), customGrammarDefaultCustomGrammar = customGrammar.isDefaultCustomGrammar();
        if (!customGrammarDefaultCustomGrammar) {
          (0, _validate.validateVocabulary)(vocabulary);
        }
        (0, _vocabulary.expressionsFromVocabulary)(vocabulary, expressions);
      });
      const pattern = expressions.join(_constants.VERTICAL_BAR), entryName = vocabularyName, entryValue = `^(?:${pattern})`, entry = {
        [entryName]: entryValue
      };
      return entry;
    }
    function bnfFromCustomGrammars(customGrammars, ruleName) {
      const bnfs = [];
      forwardsForEach(customGrammars, (customGrammar) => {
        const bnf2 = customGrammar.getBNF(ruleName), customGrammarDefaultCustomGrammar = customGrammar.isDefaultCustomGrammar();
        if (!customGrammarDefaultCustomGrammar) {
          (0, _validate.validateBNF)(bnf2, ruleName);
        }
        bnfs.push(bnf2);
      });
      const bnf = bnfs.join(_constants.VERTICAL_SPACE);
      return bnf;
    }
    function combineRules(rules) {
      let outerIndex = 0, length = rules.length;
      while (outerIndex < length) {
        const outerRule = rules[outerIndex], outerRuleName = outerRule.getName();
        let innerIndex = outerIndex + 1;
        while (innerIndex < length) {
          const innerRule = rules[innerIndex], innerRuleName = innerRule.getName();
          if (innerRuleName === outerRuleName) {
            const innerRuleDefinitions = innerRule.getDefinitions(), outerRuleDefinitions = outerRule.getDefinitions();
            unshift(outerRuleDefinitions, innerRuleDefinitions);
            const start = innerIndex, deleteCount = 1;
            rules.splice(start, deleteCount);
            length = rules.length;
          } else {
            innerIndex++;
          }
        }
        outerIndex++;
        length = rules.length;
      }
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/lexers.js
  var require_lexers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get lexerFromCombinedCustomGrammar() {
        return lexerFromCombinedCustomGrammar;
      },
      get lexerFromEntriesAndCombinedCustomGrammar() {
        return lexerFromEntriesAndCombinedCustomGrammar;
      },
      get lexerFromNothing() {
        return lexerFromNothing;
      }
    });
    var _occamlexers = require_lib3();
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {lexerFromRules, rulesFromEntries} = _occamlexers.lexerUtilities;
    function lexerFromNothing(Class) {
      const {entries} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    function lexerFromCombinedCustomGrammar(Class, combinedCustomGrammar) {
      const {entries} = Class, rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    function lexerFromEntriesAndCombinedCustomGrammar(Class, entries, combinedCustomGrammar) {
      const rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    var _default = {
      lexerFromNothing,
      lexerFromCombinedCustomGrammar,
      lexerFromEntriesAndCombinedCustomGrammar
    };
    function rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar) {
      const customGrammarEntries = combinedCustomGrammar.getEntries();
      entries = [
        ...customGrammarEntries,
        ...entries
      ];
      const rules = rulesFromEntries(entries);
      return rules;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/parsers.js
  var require_parsers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get parserFromBNFAndCombinedCustomGrammar() {
        return parserFromBNFAndCombinedCustomGrammar;
      },
      get parserFromBNFStartRuleNameAndCombinedCustomGrammar() {
        return parserFromBNFStartRuleNameAndCombinedCustomGrammar;
      },
      get parserFromCombinedCustomGrammar() {
        return parserFromCombinedCustomGrammar;
      },
      get parserFromNothing() {
        return parserFromNothing;
      },
      get parserFromStartRuleName() {
        return parserFromStartRuleName;
      },
      get parserFromStartRuleNameAndCombinedCustomGrammar() {
        return parserFromStartRuleNameAndCombinedCustomGrammar;
      }
    });
    var _occamparsers = require_lib4();
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {rulesFromBNF, parserFromRules, parserFromRulesAndStartRuleName} = _occamparsers.parserUtilities;
    function parserFromNothing(Class) {
      const {bnf} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromStartRuleName(Class, startRuleName) {
      const {bnf} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    function parserFromCombinedCustomGrammar(Class, combinedCustomGrammar) {
      const {bnf} = Class, rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromBNFAndCombinedCustomGrammar(Class, bnf, combinedCustomGrammar) {
      const rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromStartRuleNameAndCombinedCustomGrammar(Class, startRuleName, combinedCustomGrammar) {
      const {bnf} = Class, rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    function parserFromBNFStartRuleNameAndCombinedCustomGrammar(Class, bnf, startRuleName, combinedCustomGrammar) {
      const rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    var _default = {
      parserFromNothing,
      parserFromStartRuleName,
      parserFromCombinedCustomGrammar,
      parserFromBNFAndCombinedCustomGrammar,
      parserFromStartRuleNameAndCombinedCustomGrammar,
      parserFromBNFStartRuleNameAndCombinedCustomGrammar
    };
    function rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar) {
      let rules = rulesFromBNF(bnf);
      rules = combinedCustomGrammar.postProcess(rules);
      return rules;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/customGrammar.js
  var require_customGrammar2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combinedCustomGrammarFromCustomGrammars() {
        return combinedCustomGrammarFromCustomGrammars;
      },
      get combinedCustomGrammarFromJSON() {
        return combinedCustomGrammarFromJSON;
      },
      get combinedCustomGrammarFromNothing() {
        return combinedCustomGrammarFromNothing;
      },
      get default() {
        return _default;
      }
    });
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function combinedCustomGrammarFromJSON(json) {
      const customGrammarsJSON = json, customGrammars = customGrammarsJSON.map((customGrammarJSON) => {
        const json2 = customGrammarJSON, customGrammar = _customGrammar.default.fromJSON(json2);
        return customGrammar;
      });
      customGrammars.reverse();
      const combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    function combinedCustomGrammarFromNothing() {
      const customGrammars = [], combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    function combinedCustomGrammarFromCustomGrammars(customGrammars) {
      customGrammars = [
        ...customGrammars
      ];
      customGrammars.reverse();
      const combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    var _default = {
      combinedCustomGrammarFromJSON,
      combinedCustomGrammarFromNothing,
      combinedCustomGrammarFromCustomGrammars
    };
  });

  // node_modules/occam-custom-grammars/lib/index.js
  var require_lib12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CombinedCustomGrammar() {
        return _combined.default;
      },
      get CustomGrammar() {
        return _customGrammar.default;
      },
      get DEFAULT_CUSTOM_GRAMMAR_NAME() {
        return _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
      },
      get customGrammarUtilities() {
        return _customGrammar1.default;
      },
      get defaultCustomGrammar() {
        return _default.default;
      },
      get lexersUtilities() {
        return _lexers.default;
      },
      get parsersUtilities() {
        return _parsers.default;
      },
      get ruleNames() {
        return _ruleNames.default;
      },
      get vocabularyNames() {
        return _vocabularyNames.default;
      }
    });
    var _grammarNames = require_grammarNames();
    var _ruleNames = /* @__PURE__ */ _interop_require_default(require_ruleNames3());
    var _vocabularyNames = /* @__PURE__ */ _interop_require_default(require_vocabularyNames());
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _default = /* @__PURE__ */ _interop_require_default(require_default());
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    var _lexers = /* @__PURE__ */ _interop_require_default(require_lexers());
    var _parsers = /* @__PURE__ */ _interop_require_default(require_parsers());
    var _customGrammar1 = /* @__PURE__ */ _interop_require_default(require_customGrammar2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/utilities/customGrammar.js
  var require_customGrammar3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combinedCustomGrammarFromReleaseContexts() {
        return combinedCustomGrammarFromReleaseContexts;
      },
      get customGrammarFromNameAndEntries() {
        return customGrammarFromNameAndEntries;
      }
    });
    var _occamcustomgrammars = require_lib12();
    var {combinedCustomGrammarFromCustomGrammars} = _occamcustomgrammars.customGrammarUtilities;
    function customGrammarFromNameAndEntries(name, entries) {
      const termBNF = entries.getTermBNF(), statementBNF = entries.getStatementBNF(), typeVocabulary = entries.getTypeVocabulary(), symbolVocabulary = entries.getSymbolVocabulary(), customGrammar = _occamcustomgrammars.CustomGrammar.fromNameTermBNFStatementBNFTypeVocabularyAndSymbolVocabulary(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
      return customGrammar;
    }
    function combinedCustomGrammarFromReleaseContexts(releaseContexts) {
      const customGrammars = releaseContexts.map((releaseContext) => {
        const customGrammar = releaseContext.getCustomGrammar();
        return customGrammar;
      });
      const combinedCustomGrammar = combinedCustomGrammarFromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
  });

  // node_modules/occam-languages/lib/utilities/fileContext.js
  var require_fileContext = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get fileContextsFromEntries() {
        return fileContextsFromEntries;
      },
      get fileContextsFromJSON() {
        return fileContextsFromJSON;
      }
    });
    function fileContextsFromJSON(json, fileContexts, releaseContext, FileContextFromFilePath) {
      const fileContextsJSON = json;
      fileContextsJSON.forEach((fileContextJSON) => {
        const {filePath} = fileContextJSON, FileContext = FileContextFromFilePath(filePath);
        if (FileContext !== null) {
          const json2 = fileContextJSON, fileContext = FileContext.fromJSON(json2, releaseContext);
          fileContexts.push(fileContext);
        }
      });
    }
    function fileContextsFromEntries(entries, fileContexts, releaseContext, FileContextFromFilePath) {
      entries.forEachFile((file) => {
        const filePath = file.getPath(), FileContext = FileContextFromFilePath(filePath);
        if (FileContext !== null) {
          const fileContext = FileContext.fromFile(file, releaseContext);
          fileContexts.push(fileContext);
        }
      });
    }
    var _default = {
      fileContextsFromJSON,
      fileContextsFromEntries
    };
  });

  // node_modules/occam-languages/lib/context/release.js
  var require_release = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReleaseContext;
      }
    });
    var _necessary = require_browser();
    var _verify = require_verify();
    var _customGrammar = require_customGrammar3();
    var _fileContext = require_fileContext();
    var _constants = require_constants9();
    var {push, tail, first: first2} = _necessary.arrayUtilities;
    var ReleaseContext = class {
      constructor(log, name, json, entries, callback, customGrammar, verifies, initialised, fileContexts, combinedCustomGrammar, dependencyReleaseContexts) {
        this.log = log;
        this.name = name;
        this.json = json;
        this.entries = entries;
        this.callback = callback;
        this.customGrammar = customGrammar;
        this.verifies = verifies;
        this.initialised = initialised;
        this.fileContexts = fileContexts;
        this.combinedCustomGrammar = combinedCustomGrammar;
        this.dependencyReleaseContexts = dependencyReleaseContexts;
      }
      getLog() {
        return this.log;
      }
      getName() {
        return this.name;
      }
      getJSON() {
        return this.json;
      }
      getEntries() {
        return this.entries;
      }
      getCallback() {
        return this.callback;
      }
      getCustomGrammar() {
        return this.customGrammar;
      }
      getVerifies() {
        return this.verifies;
      }
      isInitialised() {
        return this.initialised;
      }
      getFileContexts() {
        return this.fileContexts;
      }
      getCombinedCustomGrammar() {
        return this.combinedCustomGrammar;
      }
      getDependencyReleaseContexts() {
        return this.dependencyReleaseContexts;
      }
      getReleaseContext() {
        const releaseContext = this;
        return releaseContext;
      }
      getDepth() {
        const depth = 0;
        return depth;
      }
      hasVerified() {
        const verified = this.verifies;
        return verified;
      }
      isReleased() {
        const released = this.json !== null;
        return released;
      }
      getTypePrefix() {
        let typePrefix = null;
        const includeDependencies = false, typePrefixes = this.getTypePrefixes(includeDependencies), typePrefixesLength = typePrefixes.length;
        if (typePrefixesLength === 1) {
          const firstTypePrefix = first2(typePrefixes);
          typePrefix = firstTypePrefix;
        }
        return typePrefix;
      }
      getLabels(includeDependencies = true) {
        const labels = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextLabels = fileContext.getLabels(includeRelease);
          push(labels, fileContextLabels);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextLabels = releaseContext.getLabels(includeDependencies2);
            push(labels, releaseContextLabels);
          });
        }
        return labels;
      }
      getTypes(includeDependencies = true) {
        const types = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTypes = fileContext.getTypes(includeRelease);
          push(types, fileContextTypes);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTypes = releaseContext.getTypes(includeDependencies2);
            push(types, releaseContextTypes);
          });
        }
        return types;
      }
      getRules(includeDependencies = true) {
        const rules = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextRules = fileContext.getRules(includeRelease);
          push(rules, fileContextRules);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextRules = releaseContext.getRules(includeDependencies2);
            push(rules, releaseContextRules);
          });
        }
        return rules;
      }
      getAxioms(includeDependencies = true) {
        const axioms = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextAxioms = fileContext.getAxioms(includeRelease);
          push(axioms, fileContextAxioms);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextAxioms = releaseContext.getAxioms(includeDependencies2);
            push(axioms, releaseContextAxioms);
          });
        }
        return axioms;
      }
      getLemmas(includeDependencies = true) {
        const lemmas = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextLemmas = fileContext.getLemmas(includeRelease);
          push(lemmas, fileContextLemmas);
        });
        return lemmas;
      }
      getTheorems(includeDependencies = true) {
        const theorems = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTheorems = fileContext.getTheorems(includeRelease);
          push(theorems, fileContextTheorems);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTheorems = releaseContext.getTheorems(includeDependencies2);
            push(theorems, releaseContextTheorems);
          });
        }
        return theorems;
      }
      getProcedures(includeDependencies = true) {
        const procedures = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextProcedures = fileContext.getProcedures(includeRelease);
          push(procedures, fileContextProcedures);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextProcedures = releaseContext.getProcedures(includeDependencies2);
            push(procedures, releaseContextProcedures);
          });
        }
        return procedures;
      }
      getMetaLemmas(includeDependencies = true) {
        const metaLemmas = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextMetaLemmas = fileContext.getMetaLemmas(includeRelease);
          push(metaLemmas, fileContextMetaLemmas);
        });
        return metaLemmas;
      }
      getConjectures(includeDependencies = true) {
        const conjectures = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextConjectures = fileContext.getConjectures(includeRelease);
          push(conjectures, fileContextConjectures);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextConjectures = releaseContext.getConjectures(includeDependencies2);
            push(conjectures, releaseContextConjectures);
          });
        }
        return conjectures;
      }
      getCombinators(includeDependencies = true) {
        const combinators = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextCombinators = fileContext.getCombinators(includeRelease);
          push(combinators, fileContextCombinators);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextCombinators = releaseContext.getCombinators(includeDependencies2);
            push(combinators, releaseContextCombinators);
          });
        }
        return combinators;
      }
      getTypePrefixes(includeDependencies = true) {
        const typePrefixes = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTypePrefixes = fileContext.getTypePrefixes(includeRelease);
          push(typePrefixes, fileContextTypePrefixes);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTypePrefixes = releaseContext.getTypePrefixes(includeDependencies2);
            push(typePrefixes, releaseContextTypePrefixes);
          });
        }
        return typePrefixes;
      }
      getConstructors(includeDependencies = true) {
        const constructors = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextConstructors = fileContext.getConstructors(includeRelease);
          push(constructors, fileContextConstructors);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextConstructors = releaseContext.getConstructors(includeDependencies2);
            push(constructors, releaseContextConstructors);
          });
        }
        return constructors;
      }
      getMetatheorems(includeDependencies = true) {
        const metatheorems = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextMetatheorems = fileContext.getMetatheorems(includeRelease);
          push(metatheorems, fileContextMetatheorems);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextMetatheorems = releaseContext.getMetatheorems(includeDependencies2);
            push(metatheorems, releaseContextMetatheorems);
          });
        }
        return metatheorems;
      }
      getDependencies() {
        return this.entries.getDependencies();
      }
      matchShortenedVersion(shortenedVersion) {
        return this.entries.matchShortenedVersion(shortenedVersion);
      }
      findFile(filePath) {
        return this.entries.findFile(filePath);
      }
      findFileContext(filePath) {
        const fileContext = this.fileContexts.find((fileContext2) => {
          const filePathMatches = fileContext2.matchFilePath(filePath);
          if (filePathMatches) {
            return true;
          }
        }) || null;
        return fileContext;
      }
      trace(message) {
        const level = _constants.TRACE_LEVEL;
        this.writeToLog(level, message);
      }
      debug(message) {
        const level = _constants.DEBUG_LEVEL;
        this.writeToLog(level, message);
      }
      info(message) {
        const level = _constants.INFO_LEVEL;
        this.writeToLog(level, message);
      }
      warning(message) {
        const level = _constants.WARNING_LEVEL;
        this.writeToLog(level, message);
      }
      error(message) {
        const level = _constants.ERROR_LEVEL;
        this.writeToLog(level, message);
      }
      writeToLog(level, message, filePath = null, lineIndex = null) {
        this.log.write(level, message, filePath, lineIndex);
      }
      initialise(releaseContexts, FileContextFromFilePath) {
        const released = this.isReleased(), releaseContext = this, releaseContextsTail = tail(releaseContexts);
        this.dependencyReleaseContexts = releaseContextsTail;
        this.combinedCustomGrammar = (0, _customGrammar.combinedCustomGrammarFromReleaseContexts)(releaseContexts);
        released ? (0, _fileContext.fileContextsFromJSON)(this.json, this.fileContexts, releaseContext, FileContextFromFilePath) : (0, _fileContext.fileContextsFromEntries)(this.entries, this.fileContexts, releaseContext, FileContextFromFilePath);
        this.initialised = true;
      }
      async break(filePath, lineIndex) {
        const level = _constants.TRACE_LEVEL, message = _constants.BREAK_MESSAGE;
        this.writeToLog(level, message, filePath, lineIndex);
        const context2 = this;
        await this.callback(context2, filePath, lineIndex);
      }
      async verify() {
        let verifies = false;
        const typePrefixes = this.getTypePrefixes(), releaseContext = this, typePrefixesVerify = (0, _verify.verifyTypePrefixes)(typePrefixes, releaseContext);
        if (typePrefixesVerify) {
          const verifiedFileContexts = [], fileContextsVerify = await (0, _verify.verifyFileContexts)(this.fileContexts, verifiedFileContexts);
          if (fileContextsVerify) {
            verifies = true;
            this.verifies = verifies;
            this.fileContexts = verifiedFileContexts;
          }
        }
        return verifies;
      }
      toJSON() {
        const fileContextsJSON = this.fileContexts.map((fileContext) => {
          const fileContextJSON = fileContext.toJSON();
          return fileContextJSON;
        }), json = fileContextsJSON;
        return json;
      }
      static fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar) {
        const verifies = false, initialised = false, fileContexts = [], combinedCustomGrammar = null, dependencyReleaseContexts = null, releaseContext = new ReleaseContext(log, name, json, entries, callback, customGrammar, verifies, initialised, fileContexts, combinedCustomGrammar, dependencyReleaseContexts);
        return releaseContext;
      }
    };
  });

  // node_modules/occam-languages/lib/nonTerminalNode.js
  var require_nonTerminalNode2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNode;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var {first: first2} = _necessary.arrayUtilities;
    var NonTerminalNode = class extends _occamparsers.NonTerminalNode {
      someTerminalNode(callback, tokenType) {
        return this.someChildNode((childNode, index) => {
          const childNodeTerminalNode = childNode.isTerminalNode();
          if (childNodeTerminalNode) {
            const terminalNode = childNode, terminalNodeType = terminalNode.getType();
            if (terminalNodeType === tokenType) {
              return callback(terminalNode, index);
            }
          }
        });
      }
      getNodeByRuleName(...ruleNames) {
        const node = this.findChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        }) || null;
        return node;
      }
      getNodesByRuleName(...ruleNames) {
        const nodes = this.filterChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        });
        return nodes;
      }
      getLastNodeByRuleName(...ruleNames) {
        let lastNode = null;
        this.backwardsSomeChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              lastNode = childNode;
              return true;
            }
          }
        });
        return lastNode;
      }
      getFirstNodeByRuleName(...ruleNames) {
        let firstNode = null;
        this.forwardsSomeChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              firstNode = childNode;
              return true;
            }
          }
        });
        return firstNode;
      }
      getSingularNodeByRuleName(...ruleNames) {
        let singularNode = null;
        const nodes = this.filterChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        }), nodesLength = nodes.length;
        if (nodesLength === 1) {
          const firstNode = first2(nodes);
          singularNode = firstNode;
        }
        return singularNode;
      }
      getDescendantNodesByRuleName(...ruleNames) {
        const nodes = this.filterDescendantNode((descendantNode) => {
          const descendantNodeNonTerminalNode = descendantNode.isNonTerminalNode();
          if (descendantNodeNonTerminalNode) {
            const nonTerminalNode = descendantNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        });
        return nodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/query.js
  var require_query4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
    var _default = {
      nodeQuery,
      nodesQuery
    };
  });

  // node_modules/occam-languages/lib/utilities/pass.js
  var require_pass = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get areTerminalNodeMapsEqual() {
        return areTerminalNodeMapsEqual;
      },
      get nonTerminalNodeQuery() {
        return nonTerminalNodeQuery;
      },
      get terminalNodeMapFromNodes() {
        return terminalNodeMapFromNodes;
      }
    });
    var _necessary = require_browser();
    var _query = require_query4();
    var {match} = _necessary.arrayUtilities;
    var nonTerminalNodeQuery = (0, _query.nodeQuery)("/*");
    function terminalNodeMapFromNodes(nodes) {
      const terminalNodeMap = {};
      nodes.forEach((node, index) => {
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          terminalNodeMap[index] = terminalNode;
        }
      });
      return terminalNodeMap;
    }
    function areTerminalNodeMapsEqual(generalTerminalNodeMap, specificTerminalNodeMap) {
      let terminalNodeMapsEqual = false;
      const generalIndexes = Object.keys(generalTerminalNodeMap), specificIndexes = Object.keys(specificTerminalNodeMap), terminalNodeMapKeysMatch = match(generalIndexes, specificIndexes, (generalIndex, specificIndex) => {
        if (generalIndex === specificIndex) {
          return true;
        }
      });
      if (terminalNodeMapKeysMatch) {
        const generalTerminalNodes = Object.values(generalTerminalNodeMap), specificTerminalNodes = Object.values(specificTerminalNodeMap), terminalNodeMapValuesMatch = match(generalTerminalNodes, specificTerminalNodes, (generalTerminalNode, specificTerminalNode) => {
          const generalTerminalNodeMatchesSpecificTerminalNode = generalTerminalNode.match(specificTerminalNode);
          if (generalTerminalNodeMatchesSpecificTerminalNode) {
            return true;
          }
        });
        terminalNodeMapsEqual = terminalNodeMapValuesMatch;
      }
      return terminalNodeMapsEqual;
    }
  });

  // node_modules/occam-languages/lib/pass/zip.js
  var require_zip = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZipPass;
      }
    });
    var _pass = require_pass();
    var ZipPass = class {
      run(generalNode, specificNode, ...remainingArguments) {
        let success;
        const visited = this.visitNode(generalNode, specificNode, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(generalChildNodes, specificChildNodes, ...remainingArguments) {
        let descended = false;
        const generalChildNodesLength = generalChildNodes.length, specificChildNodesLength = specificChildNodes.length;
        if (generalChildNodesLength === specificChildNodesLength) {
          const specificTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(specificChildNodes), generalTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(generalChildNodes), terminalNodeMapsEqual = (0, _pass.areTerminalNodeMapsEqual)(generalTerminalNodeMap, specificTerminalNodeMap);
          if (terminalNodeMapsEqual) {
            const visited = generalChildNodes.every((generalChildNode, index) => {
              const specificChildNode = specificChildNodes[index], specificNode = specificChildNode, generalNode = generalChildNode, visited2 = this.visitNode(generalNode, specificNode, ...remainingArguments);
              if (visited2) {
                return true;
              }
            });
            if (visited) {
              descended = true;
            }
          }
        }
        return descended;
      }
      visitNode(generalNode, specificNode, ...remainingArguments) {
        let visited = false;
        const generalNodeTerminalNode = generalNode.isTerminalNode(), specificNodeTerminalNode = specificNode.isTerminalNode(), generalNodeNonTerminalNode = generalNode.isNonTerminalNode(), specificNodeNonTerminalNode = specificNode.isNonTerminalNode();
        if (false) {
        } else if (generalNodeTerminalNode && specificNodeTerminalNode) {
          const generalTerminalNode = generalNode, specificTerminalNode = specificNode;
          visited = this.visitTerminalNode(generalTerminalNode, specificTerminalNode, ...remainingArguments);
        } else if (generalNodeNonTerminalNode && specificNodeNonTerminalNode) {
          const generalNonTerminalNode = generalNode, specificNonTerminalNode = specificNode;
          visited = this.visitNonTerminalNode(generalNonTerminalNode, specificNonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(generalTerminalNode, specificTerminalNode, ...remainingArguments) {
        let visited;
        visited = true;
        return visited;
      }
      visitNonTerminalNode(generalNonTerminalNode, specificNonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            generalNodeQuery: _pass.nonTerminalNodeQuery,
            specificNodeQuery: _pass.nonTerminalNodeQuery,
            run: (generalNode, specificNode, ...remainingArguments2) => {
              let visited2 = false;
              const generalNonTerminalNodeRuleName = generalNonTerminalNode.getRuleName(), specificNonTerminalNodeRuleName = specificNonTerminalNode.getRuleName();
              if (generalNonTerminalNodeRuleName === specificNonTerminalNodeRuleName) {
                const generalNonTerminalNodeChildNodes = generalNonTerminalNode.getChildNodes(), specificNonTerminalNodeChildNodes = specificNonTerminalNode.getChildNodes(), generalChildNodes = generalNonTerminalNodeChildNodes, specificChildNodes = specificNonTerminalNodeChildNodes, descended = this.descend(generalChildNodes, specificChildNodes, ...remainingArguments2);
                if (descended) {
                  visited2 = true;
                }
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {generalNodeQuery, specificNodeQuery, run} = map;
          const generalNode = generalNodeQuery(generalNonTerminalNode), specificNode = specificNodeQuery(specificNonTerminalNode);
          if (generalNode !== null && specificNode !== null) {
            const success = run(generalNode, specificNode, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/async.js
  var require_async2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AsyncPass;
      }
    });
    var _pass = require_pass();
    var _asynchronous = require_asynchronous2();
    var AsyncPass = class {
      async run(node, ...remainingArguments) {
        let success;
        const visited = await this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      async descend(childNodes, ...remainingArguments) {
        let descended = false;
        const visited = await (0, _asynchronous.asyncEvery)(childNodes, async (childNode) => {
          const node = childNode, visited2 = await this.visitNode(node, ...remainingArguments);
          if (visited2) {
            return true;
          }
        });
        if (visited) {
          descended = true;
        }
        return descended;
      }
      async visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = await this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = await this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      async visitTerminalNode(terminalNode, ...remainingArguments) {
        const visited = true;
        return visited;
      }
      async visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: async (node, ...remainingArguments2) => {
              let visited2 = false;
              const childNodes = nonTerminalNode.getChildNodes(), descended = await this.descend(childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        await (0, _asynchronous.asyncSome)(maps, async (map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = await run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/simple.js
  var require_simple = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SimplePass;
      }
    });
    var _pass = require_pass();
    var SimplePass = class {
      run(node, ...remainingArguments) {
        let success;
        const visited = this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(childNodes, ...remainingArguments) {
        let descended = false;
        const visited = childNodes.every((childNode) => {
          const node = childNode, visited2 = this.visitNode(node, ...remainingArguments);
          if (visited2) {
            return true;
          }
        });
        if (visited) {
          descended = true;
        }
        return descended;
      }
      visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(terminalNode, ...remainingArguments) {
        const visited = true;
        return visited;
      }
      visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: (node, ...remainingArguments2) => {
              let visited2 = false;
              const childNodes = nonTerminalNode.getChildNodes(), descended = this.descend(childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/forward.js
  var require_forward = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ForwardPass;
      }
    });
    var _pass = require_pass();
    var ForwardPass = class {
      run(node, ...remainingArguments) {
        let success;
        const visited = this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(index, childNodes, ...remainingArguments) {
        let descendedForward = false;
        const descendForward = remainingArguments.pop(), childNodesLength = childNodes.length;
        if (index === childNodesLength) {
          descendedForward = descendForward();
        } else {
          const childNode = childNodes[index], node = childNode, visited = this.visitNode(node, ...remainingArguments, () => {
            remainingArguments.push(descendForward);
            const aheadIndex = index + 1, descendedForward2 = this.descend(aheadIndex, childNodes, ...remainingArguments);
            return descendedForward2;
          });
          if (visited) {
            descendedForward = true;
          }
        }
        return descendedForward;
      }
      visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(terminalNode, ...remainingArguments) {
        let visited = false;
        const descendForward = remainingArguments.pop(), descendedForward = descendForward();
        if (descendedForward) {
          visited = true;
        }
        remainingArguments.push(descendForward);
        return visited;
      }
      visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: (node, ...remainingArguments2) => {
              let visited2 = false;
              const index = 0, childNodes = nonTerminalNode.getChildNodes(), descended = this.descend(index, childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/equivalence.js
  var require_equivalence = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EquivalencePass;
      }
    });
    var _pass = require_pass();
    var EquivalencePass = class {
      run(leftNode, rightNode, ...remainingArguments) {
        let success;
        const visited = this.visitNode(leftNode, rightNode, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(leftChildNodes, rightChildNodes, ...remainingArguments) {
        let descended = false;
        const leftChildNodesLength = leftChildNodes.length, rightChildNodesLength = rightChildNodes.length;
        if (leftChildNodesLength === rightChildNodesLength) {
          const leftTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(leftChildNodes), rightTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(rightChildNodes), terminalNodeMapsEqual = (0, _pass.areTerminalNodeMapsEqual)(leftTerminalNodeMap, rightTerminalNodeMap);
          if (terminalNodeMapsEqual) {
            descended = leftChildNodes.every((leftChildNode, index) => {
              const rightChildNode = rightChildNodes[index], leftNode = leftChildNode, rightNode = rightChildNode, visited = this.visitNode(leftNode, rightNode, ...remainingArguments);
              if (visited) {
                return true;
              }
            });
          }
        }
        return descended;
      }
      visitNode(leftNode, rightNode, ...remainingArguments) {
        let visited = false;
        const leftNodeTerminalNode = leftNode.isTerminalNode(), rightNodeTerminalNode = rightNode.isTerminalNode(), leftNodeNonTerminalNode = leftNode.isNonTerminalNode(), rightNodeNonTerminalNode = rightNode.isNonTerminalNode();
        if (false) {
        } else if (leftNodeTerminalNode && rightNodeTerminalNode) {
          const leftTerminalNode = leftNode, rightTerminalNode = rightNode;
          visited = this.visitTerminalNode(leftTerminalNode, rightTerminalNode, ...remainingArguments);
        } else if (leftNodeNonTerminalNode && rightNodeNonTerminalNode) {
          const leftNonTerminalNode = leftNode, rightNonTerminalNode = rightNode;
          visited = this.visitNonTerminalNode(leftNonTerminalNode, rightNonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(leftTerminalNode, rightTerminalNode, ...remainingArguments) {
        let visited;
        visited = true;
        return visited;
      }
      visitNonTerminalNode(leftNonTerminalNode, rightNonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            leftNodeQuery: _pass.nonTerminalNodeQuery,
            rightNodeQuery: _pass.nonTerminalNodeQuery,
            run: (leftNode, rightNode, ...remainingArguments2) => {
              let visited2 = false;
              const leftNonTerminalNodeRuleName = leftNonTerminalNode.getRuleName(), rightNonTerminalNodeRuleName = rightNonTerminalNode.getRuleName();
              if (leftNonTerminalNodeRuleName === rightNonTerminalNodeRuleName) {
                const leftNonTerminalNodeChildNodes = leftNonTerminalNode.getChildNodes(), rightNonTerminalNodeChildNodes = rightNonTerminalNode.getChildNodes(), leftChildNodes = leftNonTerminalNodeChildNodes, rightChildNodes = rightNonTerminalNodeChildNodes, descended = this.descend(leftChildNodes, rightChildNodes, ...remainingArguments2);
                if (descended) {
                  visited2 = true;
                }
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {leftNodeQuery, rightNodeQuery, run} = map;
          const leftNode = leftNodeQuery(leftNonTerminalNode), rightNode = rightNodeQuery(rightNonTerminalNode);
          if (leftNode !== null && rightNode !== null) {
            const success = run(leftNode, rightNode, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/dependency.js
  var require_dependency = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "asyncEveryDependency", {
      enumerable: true,
      get: function() {
        return asyncEveryDependency;
      }
    });
    var _asynchronous = require_asynchronous2();
    async function asyncEveryDependency(dependencies, callback) {
      const array = dependencies.getArray();
      return await (0, _asynchronous.asyncEvery)(array, callback);
    }
  });

  // node_modules/occam-languages/lib/utilities/verification.js
  var require_verification = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get createReleaseContext() {
        return createReleaseContext;
      },
      get default() {
        return _default;
      },
      get initialiseReleaseContext() {
        return initialiseReleaseContext;
      },
      get verifyReleaseContext() {
        return verifyReleaseContext;
      }
    });
    var _necessary = require_browser();
    var _dependency = require_dependency();
    var {last} = _necessary.arrayUtilities;
    function initialiseReleaseContext(dependency, context2) {
      const {log, releaseContextMap} = context2, dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext = releaseContextMap[releaseName] || null;
      if (releaseContext === null) {
        log.warning(`Unable to initialise the '${dependencyName}' context because it has not been created.`);
      } else {
        const releaseContextInitialised = releaseContext.isInitialised();
        if (!releaseContextInitialised) {
          initialiseDependencyReleaseContexts(dependency, releaseContext, context2);
          const releaseContexts = retrieveReleaseContexts(releaseContext, releaseContextMap);
          log.info(`Initialising the '${dependencyName}' context...`);
          const {FileContextFromFilePath} = context2;
          releaseContext.initialise(releaseContexts, FileContextFromFilePath);
          log.debug(`...initialised the '${dependencyName}' context.`);
        }
      }
    }
    async function createReleaseContext(dependency, dependentNames, context2) {
      let releaseContextCreated = false;
      const {log, releaseContextMap} = context2, dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext = releaseContextMap[releaseName] || null;
      if (releaseContext !== null) {
        const releaseMatchesDependency = checkReleaseMatchesDependency(releaseContext, dependency, dependentNames, context2);
        if (releaseMatchesDependency) {
          log.debug(`The '${releaseName}' context has already been created.`);
          releaseContextCreated = true;
        }
      } else {
        const dependencyString = dependency.asString(), dependentNamesLength = dependentNames.length;
        if (dependentNamesLength === 0) {
          log.info(`Creating the '${releaseName}' context...`);
        } else {
          const lastDependentName = last(dependentNames), dependentName = lastDependentName;
          log.info(`Creating the '${releaseName}' context given the '${dependentName}' dependant's '${dependencyString}' dependency...`);
        }
        const {releaseContextFromDependency} = context2, releaseContext2 = await releaseContextFromDependency(dependency, context2);
        if (releaseContext2 !== null) {
          const releaseMatchesDependency = checkReleaseMatchesDependency(releaseContext2, dependency, dependentNames, context2);
          if (releaseMatchesDependency) {
            releaseContextMap[releaseName] = releaseContext2;
            const dependencyReleaseContextsCreated = await createDependencyReleaseContexts(dependency, releaseContext2, dependentNames, context2);
            if (dependencyReleaseContextsCreated) {
              releaseContextCreated = true;
            }
          }
        } else {
          const dependencyName2 = dependency.getName(), releaseName2 = dependencyName2;
          log.warning(`The '${releaseName2}' context could not be created. Perhaps the 'meta.json' file is missing or invalid. Or there could be a dependency mismatch.`);
        }
        releaseContextCreated ? log.debug(`...created the '${releaseName}' context.`) : log.warning(`...unable to create the '${releaseName}' context.`);
      }
      return releaseContextCreated;
    }
    async function verifyReleaseContext(releaseName, dependentName, dependentReleased, releaseContextMap) {
      let releaseContextVerifies = false;
      const releaseContext = releaseContextMap[releaseName];
      if (releaseContext !== null) {
        const released = releaseContext.isReleased();
        if (released) {
          releaseContextVerifies = true;
        } else {
          if (dependentReleased) {
            releaseContext.warning(`The '${releaseName}' project cannot be verifies because its '${dependentName}' dependent is a package.`);
          } else {
            const dependentName2 = releaseName, dependentReleased2 = released, dependencyReleaseContextsVerify = await verifyDependencyReleaseContexts(releaseContext, dependentName2, dependentReleased2, releaseContextMap);
            if (dependencyReleaseContextsVerify) {
              const releaseContextVerified = releaseContext.hasVerified();
              if (releaseContextVerified) {
                releaseContextVerifies = true;
              } else {
                releaseContext.info(`Verifying the '${releaseName}' project...`);
                const verifies = await releaseContext.verify();
                if (verifies) {
                  releaseContext.info(`...verified the '${releaseName}' project.`);
                  releaseContextVerifies = true;
                }
              }
            }
          }
        }
      }
      return releaseContextVerifies;
    }
    var _default = {
      createReleaseContext,
      verifyReleaseContext,
      initialiseReleaseContext
    };
    async function createDependencyReleaseContexts(dependency, releaseContext, dependentNames, context2) {
      let dependencyReleaseContextsCreated;
      const dependencyName = dependency.getName(), dependencies = releaseContext.getDependencies();
      dependentNames = [
        ...dependentNames,
        dependencyName
      ];
      dependencyReleaseContextsCreated = await (0, _dependency.asyncEveryDependency)(dependencies, async (dependency2) => {
        const cyclicDependencyExists = checkCyclicDependencyExists(dependency2, dependentNames, context2);
        if (!cyclicDependencyExists) {
          const releaseContextCreated = await createReleaseContext(dependency2, dependentNames, context2);
          if (releaseContextCreated) {
            return true;
          }
        }
      });
      return dependencyReleaseContextsCreated;
    }
    async function verifyDependencyReleaseContexts(releaseContext, dependentName, dependentReleased, releaseContextMap) {
      const dependencies = releaseContext.getDependencies(), dependencyReleaseContextsVerify = await (0, _dependency.asyncEveryDependency)(dependencies, async (dependency) => {
        const name = dependency.getName(), releaseName = name, releaseContextVerifies = await verifyReleaseContext(releaseName, dependentName, dependentReleased, releaseContextMap);
        if (releaseContextVerifies) {
          return true;
        }
      });
      return dependencyReleaseContextsVerify;
    }
    function retrieveReleaseContexts(releaseContext, releaseContextMap) {
      const releaseContexts = [], remainingReleaseContext = releaseContext, remainingReleaseContexts = [
        remainingReleaseContext
      ];
      let remainingReleaseContextsLength = remainingReleaseContexts.length;
      while (remainingReleaseContextsLength > 0) {
        const remainingReleaseContext2 = remainingReleaseContexts.shift(), releaseContext2 = remainingReleaseContext2;
        releaseContexts.push(releaseContext2);
        const dependencies = releaseContext2.getDependencies();
        dependencies.forEachDependency((dependency) => {
          const dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext3 = releaseContextMap[releaseName], releaseContextsIncludesReleaseContext = releaseContexts.includes(releaseContext3), remainingReleaseContextsIncludesReleaseContext = remainingReleaseContexts.includes(releaseContext3);
          if (!releaseContextsIncludesReleaseContext && !remainingReleaseContextsIncludesReleaseContext) {
            const remainingReleaseContext3 = releaseContext3;
            remainingReleaseContexts.push(remainingReleaseContext3);
          }
        });
        remainingReleaseContextsLength = remainingReleaseContexts.length;
      }
      return releaseContexts;
    }
    function checkCyclicDependencyExists(dependency, dependentNames, context2) {
      const dependencyName = dependency.getName(), dependentNamesIncludesDependencyName = dependentNames.includes(dependencyName), cyclicDependencyExists = dependentNamesIncludesDependencyName;
      if (cyclicDependencyExists) {
        const {log} = context2, firstDependentName = first(dependentNames), dependencyNames = [
          ...dependentNames,
          firstDependentName
        ], dependencyNamesString = dependencyNames.join(`' -> '`);
        log.warning(`There is a cyclic dependency, '${dependencyNamesString}'.`);
      }
      return cyclicDependencyExists;
    }
    function checkReleaseMatchesDependency(releaseContext, dependency, dependentNames, context2) {
      let releaseMatchesDependency = true;
      const shortenedVersion = dependency.getShortedVersion();
      if (shortenedVersion !== null) {
        const entriesMatchShortenedVersion = releaseContext.matchShortenedVersion(shortenedVersion);
        if (!entriesMatchShortenedVersion) {
          const {log} = context2, version = releaseContext.getVersion(), lastDependentName = last(dependentNames), dependentName = lastDependentName, versionString = version.toString(), dependencyString = dependency.asString();
          log.warning(`The '${dependentName}' dependent requires the '${dependencyString}' dependency but a context with version '${versionString}' was provided.`);
          releaseMatchesDependency = false;
        }
      }
      return releaseMatchesDependency;
    }
    function initialiseDependencyReleaseContexts(dependency, releaseContext, context2) {
      const dependencies = releaseContext.getDependencies();
      dependencies.forEachDependency((dependency2) => {
        initialiseReleaseContext(dependency2, context2);
      });
    }
  });

  // node_modules/occam-model/lib/types.js
  var require_types2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DIRECTORY_TYPE() {
        return DIRECTORY_TYPE;
      },
      get FILE_TYPE() {
        return FILE_TYPE;
      }
    });
    var FILE_TYPE = "File";
    var DIRECTORY_TYPE = "Directory";
  });

  // node_modules/occam-model/lib/constants.js
  var require_constants12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_AMPERSAND() {
        return ESCAPED_AMPERSAND;
      },
      get ESCAPED_GREATER_THAN() {
        return ESCAPED_GREATER_THAN;
      },
      get ESCAPED_LESS_THAN() {
        return ESCAPED_LESS_THAN;
      }
    });
    var EMPTY_STRING = "";
    var DOUBLE_SPACE = "  ";
    var ESCAPED_AMPERSAND = "&amp;";
    var ESCAPED_LESS_THAN = "&lt;";
    var ESCAPED_GREATER_THAN = "&gt;";
  });

  // node_modules/occam-model/lib/utilities/content.js
  var require_content3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get convertContentTabsToWhitespace() {
        return convertContentTabsToWhitespace;
      },
      get default() {
        return _default;
      },
      get sanitiseContent() {
        return sanitiseContent;
      },
      get trimDoubleQuotes() {
        return trimDoubleQuotes;
      }
    });
    var _constants = require_constants12();
    function sanitiseContent(content) {
      const sanitisedContent = content.replace(/&/g, _constants.ESCAPED_AMPERSAND).replace(/</g, _constants.ESCAPED_LESS_THAN).replace(/>/g, _constants.ESCAPED_GREATER_THAN);
      return sanitisedContent;
    }
    function trimDoubleQuotes(content) {
      return content.replace(/(^"|"$)/g, _constants.EMPTY_STRING);
    }
    function convertContentTabsToWhitespace(content) {
      return content.replace(/\t/g, _constants.DOUBLE_SPACE);
    }
    var _default = {
      sanitiseContent,
      trimDoubleQuotes,
      convertContentTabsToWhitespace
    };
  });

  // node_modules/occam-model/lib/file.js
  var require_file2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return File;
      }
    });
    var _types = require_types2();
    var _content = require_content3();
    var _File = class {
      constructor(path, content, released) {
        this.path = path;
        this.content = content;
        this.released = released;
      }
      getPath() {
        return this.path;
      }
      getContent() {
        return this.content;
      }
      isReleased() {
        return this.released;
      }
      isFile() {
        const file = true;
        return file;
      }
      isDirectory() {
        const directory = false;
        return directory;
      }
      setPath(path) {
        this.path = path;
      }
      setContent(content) {
        this.content = content;
      }
      setReleased(released) {
        this.released = released;
      }
      matchFilePath(filePath) {
        const filePathMatches = this.path === filePath;
        return filePathMatches;
      }
      toJSON() {
        const {type} = _File, path = this.path, content = this.content, released = this.released, json = {
          type,
          path,
          content,
          released
        };
        return json;
      }
      static fromJSON(json) {
        let file = null;
        if (json !== null) {
          const {type} = json;
          if (type === _types.FILE_TYPE) {
            let {content} = json;
            const {path, released} = json;
            content = (0, _content.convertContentTabsToWhitespace)(content);
            file = new _File(path, content, released);
          }
        }
        return file;
      }
      static fromDocument(document2) {
        const filePath = document2.getFilePath(), released = document2.isReleased(), path = filePath;
        let content = document2.getContent();
        content = (0, _content.convertContentTabsToWhitespace)(content);
        const file = new _File(path, content, released);
        return file;
      }
      static fromPathContentAndReleased(path, content, released) {
        content = (0, _content.convertContentTabsToWhitespace)(content);
        const file = new _File(path, content, released);
        return file;
      }
    };
    var File = _File;
    __publicField(File, "type", _types.FILE_TYPE);
  });

  // node_modules/occam-model/lib/files.js
  var require_files = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Files;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Files = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getFilePaths() {
        const filePaths = this.mapFile((file) => {
          const filePath = file.getPath();
          return filePath;
        });
        return filePaths;
      }
      addFile(file) {
        this.array.push(file);
      }
      mapFile(callback) {
        return this.array.map(callback);
      }
      someFile(callback) {
        return this.array.some(callback);
      }
      reduceFile(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachFile(callback) {
        this.array.forEach(callback);
      }
      findFile(callback) {
        return this.array.find(callback) || null;
      }
      toJSON() {
        const filesJSON = this.array.map((file) => {
          const fileJSON = file !== null ? file.toJSON() : null;
          return fileJSON;
        }), json = filesJSON;
        return json;
      }
      static fromJSON(json) {
        const filesJSON = json, array = [], files = new Files(array);
        filesJSON.forEach((fileJSON) => {
          const json2 = fileJSON, file = _file.default.fromJSON(json2);
          files.addFile(file);
        });
        return files;
      }
      static fromNothing() {
        const array = [], files = new Files(array);
        return files;
      }
    };
  });

  // node_modules/occam-model/lib/multiplers.js
  var require_multiplers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get MAJOR_NUMBER_MULTIPLIER() {
        return MAJOR_NUMBER_MULTIPLIER;
      },
      get MINOR_NUMBER_MULTIPLIER() {
        return MINOR_NUMBER_MULTIPLIER;
      },
      get PATCH_NUMBER_MULTIPLIER() {
        return PATCH_NUMBER_MULTIPLIER;
      }
    });
    var MAJOR_NUMBER_MULTIPLIER = 1e12;
    var MINOR_NUMBER_MULTIPLIER = 1e6;
    var PATCH_NUMBER_MULTIPLIER = 1;
  });

  // node_modules/occam-model/lib/utilities/version.js
  var require_version2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get majorNumberFromNumber() {
        return majorNumberFromNumber;
      },
      get majorNumberFromString() {
        return majorNumberFromString;
      },
      get minorNumberFromNumber() {
        return minorNumberFromNumber;
      },
      get minorNumberFromString() {
        return minorNumberFromString;
      },
      get patchNumberFromNumber() {
        return patchNumberFromNumber;
      },
      get patchNumberFromString() {
        return patchNumberFromString;
      }
    });
    var _necessary = require_browser();
    var _multiplers = require_multiplers();
    var {second} = _necessary.arrayUtilities;
    function majorNumberFromNumber(number) {
      const majorNumber = number !== null ? Math.floor(number / _multiplers.MAJOR_NUMBER_MULTIPLIER) : 0;
      return majorNumber;
    }
    function minorNumberFromNumber(number) {
      const minorNumber = number !== null ? Math.floor(number % _multiplers.MAJOR_NUMBER_MULTIPLIER / _multiplers.MINOR_NUMBER_MULTIPLIER) : 0;
      return minorNumber;
    }
    function patchNumberFromNumber(number) {
      const patchNumber = number !== null ? Math.floor(number % _multiplers.MINOR_NUMBER_MULTIPLIER / _multiplers.PATCH_NUMBER_MULTIPLIER) : 0;
      return patchNumber;
    }
    function majorNumberFromString(string) {
      let majorNumber = 0;
      if (string) {
        const matches = string.match(/^(\d+)/), secondMatch = second(matches);
        majorNumber = Number(secondMatch);
      }
      return majorNumber;
    }
    function minorNumberFromString(string) {
      let minorNumber = 0;
      if (string) {
        const matches = string.match(/^\d+\.(\d+)/), secondMatch = second(matches);
        minorNumber = Number(secondMatch);
      }
      return minorNumber;
    }
    function patchNumberFromString(string) {
      let patchNumber = 0;
      if (string) {
        const matches = string.match(/^\d+\.\d+\.(\d+)/), secondMatch = second(matches);
        patchNumber = Number(secondMatch);
      }
      return patchNumber;
    }
  });

  // node_modules/occam-model/lib/version.js
  var require_version3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Version;
      }
    });
    var _multiplers = require_multiplers();
    var _version = require_version2();
    var Version = class {
      constructor(majorNumber, minorNumber, patchNumber) {
        this.majorNumber = majorNumber;
        this.minorNumber = minorNumber;
        this.patchNumber = patchNumber;
      }
      getMajorNumber() {
        return this.majorNumber;
      }
      getMinorNumber() {
        return this.minorNumber;
      }
      getPatchNumber() {
        return this.patchNumber;
      }
      bumpMajorNumber() {
        this.majorNumber += 1;
      }
      bumpMinorNumber() {
        this.minorNumber += 1;
      }
      bumpPatchNumber() {
        this.patchNumber += 1;
      }
      resetMajorNumber() {
        this.majorNumber = 0;
      }
      resetMinorNumber() {
        this.minorNumber = 0;
      }
      resetPatchNumber() {
        this.patchNumber = 0;
      }
      matchShortenedVersion(shortenedVersion) {
        let matchesShortenedVersion = false;
        if (shortenedVersion === null) {
          matchesShortenedVersion = true;
        } else {
          const majorNumber = shortenedVersion.getMajorNumber();
          if (this.majorNumber === majorNumber) {
            const minorNumber = shortenedVersion.getMinorNumber();
            if (this.minorNumber >= minorNumber) {
              matchesShortenedVersion = true;
            }
          }
        }
        return matchesShortenedVersion;
      }
      toString() {
        const string = `${this.majorNumber}.${this.minorNumber}.${this.patchNumber}`;
        return string;
      }
      toVersionNumber() {
        const versionNumber = this.majorNumber * _multiplers.MAJOR_NUMBER_MULTIPLIER + this.minorNumber * _multiplers.MINOR_NUMBER_MULTIPLIER + this.patchNumber * _multiplers.PATCH_NUMBER_MULTIPLIER;
        return versionNumber;
      }
      static fromString(string) {
        const majorNumber = (0, _version.majorNumberFromString)(string), minorNumber = (0, _version.minorNumberFromString)(string), patchNumber = (0, _version.patchNumberFromString)(string), version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromNothing() {
        const majorNumber = 0, minorNumber = 0, patchNumber = 0, version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromVersion(version) {
        const majorNumber = version.getMajorNumber(), minorNumber = version.getMinorNumber(), patchNumber = version.getPatchNumber();
        version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromVersionNumber(versionNumber) {
        const number = versionNumber, majorNumber = (0, _version.majorNumberFromNumber)(number), minorNumber = (0, _version.minorNumberFromNumber)(number), patchNumber = (0, _version.patchNumberFromNumber)(number), version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
    };
  });

  // node_modules/occam-model/lib/directory.js
  var require_directory = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Directory;
      }
    });
    var _types = require_types2();
    var _Directory = class {
      constructor(path) {
        this.path = path;
      }
      getPath() {
        return this.path;
      }
      isFile() {
        const file = false;
        return file;
      }
      isDirectory() {
        const directory = true;
        return directory;
      }
      toJSON() {
        const {type} = _Directory, path = this.path, json = {
          type,
          path
        };
        return json;
      }
      static fromPath(path) {
        const directory = new _Directory(path);
        return directory;
      }
      static fromJSON(json) {
        let directory = null;
        if (json !== null) {
          const {type} = json;
          if (type === _types.DIRECTORY_TYPE) {
            const {path} = json;
            directory = new _Directory(path);
          }
        }
        return directory;
      }
    };
    var Directory = _Directory;
    __publicField(Directory, "type", _types.DIRECTORY_TYPE);
  });

  // node_modules/occam-model/lib/utilities/name.js
  var require_name5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "fileNameFromFilePath", {
      enumerable: true,
      get: function() {
        return fileNameFromFilePath;
      }
    });
    var _necessary = require_browser();
    var {bottommostNameFromPath} = _necessary.pathUtilities;
    function fileNameFromFilePath(filePath) {
      const path = filePath, bottommostName = bottommostNameFromPath(path), fileName = bottommostName;
      return fileName;
    }
  });

  // node_modules/occam-model/lib/fileNames.js
  var require_fileNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get META_JSON_FILE_NAME() {
        return META_JSON_FILE_NAME;
      },
      get README_MD_FILE_NAME() {
        return README_MD_FILE_NAME;
      },
      get STATEMENT_BNF_FILE_NAME() {
        return STATEMENT_BNF_FILE_NAME;
      },
      get SYMBOL_VOCABULARY_FILE_NAME() {
        return SYMBOL_VOCABULARY_FILE_NAME;
      },
      get TERM_BNF_FILE_NAME() {
        return TERM_BNF_FILE_NAME;
      },
      get TYPE_VOCABULARY_FILE_NAME() {
        return TYPE_VOCABULARY_FILE_NAME;
      },
      get default() {
        return _default;
      }
    });
    var README_MD_FILE_NAME = "README.md";
    var META_JSON_FILE_NAME = "meta.json";
    var TERM_BNF_FILE_NAME = "term.bnf";
    var STATEMENT_BNF_FILE_NAME = "statement.bnf";
    var TYPE_VOCABULARY_FILE_NAME = "type.vcb";
    var SYMBOL_VOCABULARY_FILE_NAME = "symbol.vcb";
    var _default = {
      README_MD_FILE_NAME,
      META_JSON_FILE_NAME,
      TERM_BNF_FILE_NAME,
      STATEMENT_BNF_FILE_NAME,
      TYPE_VOCABULARY_FILE_NAME,
      SYMBOL_VOCABULARY_FILE_NAME
    };
  });

  // node_modules/occam-model/lib/mixins/bnf.js
  var require_bnf13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants12();
    var _name = require_name5();
    var _fileNames = require_fileNames();
    function getBNF(bnfFileName) {
      let bnf = _constants.EMPTY_STRING;
      const customGrammarBNFFiles = this.getCustomGrammarBNFFiles(), customGrammarBNFFile = customGrammarBNFFiles.find((customGrammarBNFFile2) => {
        const customGrammarBNFFilePath = customGrammarBNFFile2.getPath(), customGrammarBNFFileName = (0, _name.fileNameFromFilePath)(customGrammarBNFFilePath);
        if (customGrammarBNFFileName === bnfFileName) {
          return true;
        }
      }) || null;
      if (customGrammarBNFFile !== null) {
        const customGrammarBNFFileContent = customGrammarBNFFile.getContent();
        bnf = customGrammarBNFFileContent;
      }
      return bnf;
    }
    function getTermBNF() {
      const fileName = _fileNames.TERM_BNF_FILE_NAME, bnf = this.getBNF(fileName), termBNF = bnf;
      return termBNF;
    }
    function getStatementBNF() {
      const fileName = _fileNames.STATEMENT_BNF_FILE_NAME, bnf = this.getBNF(fileName), statementBNF = bnf;
      return statementBNF;
    }
    var bnfMixins = {
      getBNF,
      getTermBNF,
      getStatementBNF
    };
    var _default = bnfMixins;
  });

  // node_modules/occam-model/lib/utilities/filePath.js
  var require_filePath = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get isFilePathCustomGrammarBNFFilePath() {
        return isFilePathCustomGrammarBNFFilePath;
      },
      get isFilePathCustomGrammarVocabularyFilePath() {
        return isFilePathCustomGrammarVocabularyFilePath;
      },
      get isFilePathDefaultMarkdownStyleFilePath() {
        return isFilePathDefaultMarkdownStyleFilePath;
      },
      get isFilePathFurtleFilePath() {
        return isFilePathFurtleFilePath;
      },
      get isFilePathIndexJSONFilePath() {
        return isFilePathIndexJSONFilePath;
      },
      get isFilePathMarkdownFilePath() {
        return isFilePathMarkdownFilePath;
      },
      get isFilePathMarkdownStyleFilePath() {
        return isFilePathMarkdownStyleFilePath;
      },
      get isFilePathMetaJSONFilePath() {
        return isFilePathMetaJSONFilePath;
      },
      get isFilePathNominalFilePath() {
        return isFilePathNominalFilePath;
      },
      get isFilePathReadmeFilePath() {
        return isFilePathReadmeFilePath;
      },
      get isFilePathRecognisedFilePath() {
        return isFilePathRecognisedFilePath;
      },
      get isFilePathReleaseFilePath() {
        return isFilePathReleaseFilePath;
      }
    });
    var readmeFilePathPattern = "^(?:[^\\/]+\\/){1}README\\.md$";
    var furtleFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.ftl$";
    var nominalFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.nml$";
    var markdownFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.md$";
    var metaJSONFilePathPattern = "^(?:[^\\/]+\\/){1}meta\\.json$";
    var indexJSONFilePathPattern = "^(?:[^\\/]+\\/){1}index\\.json$";
    var markdownStyleFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.mds$";
    var customGrammarBNFFilePathPattern = "^(?:[^\\/]+\\/){1}(term|statement)\\.bnf$";
    var defaultMarkdownStyleFilePathPattern = "^[^\\/]+\\/default\\.mds$";
    var customGrammarVocabularyFilePathPattern = "^(?:[^\\/]+\\/){1}(type|symbol)\\.vcb$";
    var releaseFilePathPattern = `${readmeFilePathPattern}|${furtleFilePathPattern}|${nominalFilePathPattern}|${metaJSONFilePathPattern}|${customGrammarBNFFilePathPattern}|${customGrammarVocabularyFilePathPattern}`;
    var recognisedFilePathPattern = `${releaseFilePathPattern}|${indexJSONFilePathPattern}|${markdownFilePathPattern}|${markdownStyleFilePathPattern}`;
    var readmeFilePathRegularExpression = new RegExp(readmeFilePathPattern);
    var furtleFilePathRegularExpression = new RegExp(furtleFilePathPattern);
    var releaseFilePathRegularExpression = new RegExp(releaseFilePathPattern);
    var nominalFilePathRegularExpression = new RegExp(nominalFilePathPattern);
    var markdownFilePathRegularExpression = new RegExp(markdownFilePathPattern);
    var metaJSONFilePathRegularExpression = new RegExp(metaJSONFilePathPattern);
    var indexJSONFilePathRegularExpression = new RegExp(indexJSONFilePathPattern);
    var recognisedFilePathRegularExpression = new RegExp(recognisedFilePathPattern);
    var markdownStyleFilePathRegularExpression = new RegExp(markdownStyleFilePathPattern);
    var customGrammarBNFFilePathRegularExpression = new RegExp(customGrammarBNFFilePathPattern);
    var defaultMarkdownStyleFilePathRegularExpression = new RegExp(defaultMarkdownStyleFilePathPattern);
    var customGrammarVocabularyFilePathRegularExpression = new RegExp(customGrammarVocabularyFilePathPattern);
    function isFilePathReadmeFilePath(filePath) {
      return readmeFilePathRegularExpression.test(filePath);
    }
    function isFilePathFurtleFilePath(filePath) {
      return furtleFilePathRegularExpression.test(filePath);
    }
    function isFilePathReleaseFilePath(filePath) {
      return releaseFilePathRegularExpression.test(filePath);
    }
    function isFilePathNominalFilePath(filePath) {
      return nominalFilePathRegularExpression.test(filePath);
    }
    function isFilePathMarkdownFilePath(filePath) {
      return markdownFilePathRegularExpression.test(filePath);
    }
    function isFilePathMetaJSONFilePath(filePath) {
      return metaJSONFilePathRegularExpression.test(filePath);
    }
    function isFilePathIndexJSONFilePath(filePath) {
      return indexJSONFilePathRegularExpression.test(filePath);
    }
    function isFilePathRecognisedFilePath(filePath) {
      return recognisedFilePathRegularExpression.test(filePath);
    }
    function isFilePathMarkdownStyleFilePath(filePath) {
      return markdownStyleFilePathRegularExpression.test(filePath);
    }
    function isFilePathCustomGrammarBNFFilePath(filePath) {
      return customGrammarBNFFilePathRegularExpression.test(filePath);
    }
    function isFilePathDefaultMarkdownStyleFilePath(filePath) {
      return defaultMarkdownStyleFilePathRegularExpression.test(filePath);
    }
    function isFilePathCustomGrammarVocabularyFilePath(filePath) {
      return customGrammarVocabularyFilePathRegularExpression.test(filePath);
    }
    var _default = {
      isFilePathReadmeFilePath,
      isFilePathFurtleFilePath,
      isFilePathReleaseFilePath,
      isFilePathNominalFilePath,
      isFilePathMarkdownFilePath,
      isFilePathMetaJSONFilePath,
      isFilePathIndexJSONFilePath,
      isFilePathRecognisedFilePath,
      isFilePathMarkdownStyleFilePath,
      isFilePathCustomGrammarBNFFilePath,
      isFilePathDefaultMarkdownStyleFilePath,
      isFilePathCustomGrammarVocabularyFilePath
    };
  });

  // node_modules/occam-model/lib/utilities/files.js
  var require_files2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get customGrammarBNFFilesFromFiles() {
        return customGrammarBNFFilesFromFiles;
      },
      get customGrammarVocabularyFilesFromFiles() {
        return customGrammarVocabularyFilesFromFiles;
      },
      get furtleFilesFromFiles() {
        return furtleFilesFromFiles;
      },
      get metaJSONFileFromFiles() {
        return metaJSONFileFromFiles;
      },
      get nominalFilesFromFiles() {
        return nominalFilesFromFiles;
      },
      get readmeFileFromFiles() {
        return readmeFileFromFiles;
      }
    });
    var _filePath = require_filePath();
    function readmeFileFromFiles(files) {
      let readmeFile = null;
      files.someFile((file) => {
        const filePath = file.getPath(), filePathReadmeFilePath = (0, _filePath.isFilePathReadmeFilePath)(filePath);
        if (filePathReadmeFilePath) {
          readmeFile = file;
          return true;
        }
      });
      return readmeFile;
    }
    function furtleFilesFromFiles(files) {
      const furtleFiles = files.reduceFile((furtleFiles2, file) => {
        const filePath = file.getPath(), filePathFurtleFilePath = (0, _filePath.isFilePathFurtleFilePath)(filePath), fileFurtleFile = filePathFurtleFilePath;
        if (fileFurtleFile) {
          const furtleFile = file;
          furtleFiles2.push(furtleFile);
        }
        return furtleFiles2;
      }, []);
      return furtleFiles;
    }
    function nominalFilesFromFiles(files) {
      const nominalFiles = files.reduceFile((nominalFiles2, file) => {
        const filePath = file.getPath(), filePathNominalFilePath = (0, _filePath.isFilePathNominalFilePath)(filePath), fileNominalFile = filePathNominalFilePath;
        if (fileNominalFile) {
          const nominalFile = file;
          nominalFiles2.push(nominalFile);
        }
        return nominalFiles2;
      }, []);
      return nominalFiles;
    }
    function metaJSONFileFromFiles(files) {
      let metaJSONFile = null;
      files.someFile((file) => {
        const filePath = file.getPath(), filePathMetaJSONFilePath = (0, _filePath.isFilePathMetaJSONFilePath)(filePath);
        if (filePathMetaJSONFilePath) {
          metaJSONFile = file;
          return true;
        }
      });
      return metaJSONFile;
    }
    function customGrammarBNFFilesFromFiles(files) {
      const customGrammarBNFFiles = files.reduceFile((customGrammarBNFFiles2, file) => {
        const filePath = file.getPath(), filePathCustomGrammarBNFFilePath = (0, _filePath.isFilePathCustomGrammarBNFFilePath)(filePath), fileCustomGrammarBNFFile = filePathCustomGrammarBNFFilePath;
        if (fileCustomGrammarBNFFile) {
          const customGrammarBNFFile = file;
          customGrammarBNFFiles2.push(customGrammarBNFFile);
        }
        return customGrammarBNFFiles2;
      }, []);
      return customGrammarBNFFiles;
    }
    function customGrammarVocabularyFilesFromFiles(files) {
      const customGrammarVocabularyFiles = files.reduceFile((customGrammarVocabularyFiles2, file) => {
        const filePath = file.getPath(), filePathCustomGrammarVocabularyFilePath = (0, _filePath.isFilePathCustomGrammarVocabularyFilePath)(filePath), fileCustomGrammarVocabularyFile = filePathCustomGrammarVocabularyFilePath;
        if (fileCustomGrammarVocabularyFile) {
          const customGrammarVocabularyFile = file;
          customGrammarVocabularyFiles2.push(customGrammarVocabularyFile);
        }
        return customGrammarVocabularyFiles2;
      }, []);
      return customGrammarVocabularyFiles;
    }
  });

  // node_modules/occam-model/lib/mixins/files.js
  var require_files3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _files = require_files2();
    function getReadmeFile() {
      const files = this.getFiles(), readmeFile = (0, _files.readmeFileFromFiles)(files);
      return readmeFile;
    }
    function getFurtleFiles() {
      const files = this.getFiles(), furtleFiles = (0, _files.furtleFilesFromFiles)(files);
      return furtleFiles;
    }
    function getNominalFiles() {
      const files = this.getFiles(), nominalFiles = (0, _files.nominalFilesFromFiles)(files);
      return nominalFiles;
    }
    function getMetaJSONFile() {
      const files = this.getFiles(), metaJSONFile = (0, _files.metaJSONFileFromFiles)(files);
      return metaJSONFile;
    }
    function getCustomGrammarBNFFiles() {
      const files = this.getFiles(), customGrammarBNFFiles = (0, _files.customGrammarBNFFilesFromFiles)(files);
      return customGrammarBNFFiles;
    }
    function getCustomGrammarVocabularyFiles() {
      const files = this.getFiles(), customGrammarVocabularyFiles = (0, _files.customGrammarVocabularyFilesFromFiles)(files);
      return customGrammarVocabularyFiles;
    }
    var filesMixins = {
      getReadmeFile,
      getFurtleFiles,
      getNominalFiles,
      getMetaJSONFile,
      getCustomGrammarBNFFiles,
      getCustomGrammarVocabularyFiles
    };
    var _default = filesMixins;
  });

  // node_modules/occam-model/lib/dependency.js
  var require_dependency2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Dependency;
      }
    });
    var Dependency = class {
      constructor(name, shortenedVersion) {
        this.name = name;
        this.shortenedVersion = shortenedVersion;
      }
      getName() {
        return this.name;
      }
      getShortedVersion() {
        return this.shortenedVersion;
      }
      asString() {
        let string;
        if (this.shortenedVersion !== null) {
          const shortenedVersionString = this.shortenedVersion.toString();
          string = `${this.name}@${shortenedVersionString}`;
        } else {
          string = this.name;
        }
        return string;
      }
      static fromName(name) {
        const shortenedVersion = null, dependency = new Dependency(name, shortenedVersion);
        return dependency;
      }
      static fromNameAndShortenedVersion(name, shortenedVersion) {
        const dependency = new Dependency(name, shortenedVersion);
        return dependency;
      }
    };
  });

  // node_modules/occam-model/lib/shortenedVersion.js
  var require_shortenedVersion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ShortenedVersion;
      }
    });
    var _multiplers = require_multiplers();
    var _version = require_version2();
    var ShortenedVersion = class {
      constructor(majorNumber, minorNumber) {
        this.majorNumber = majorNumber;
        this.minorNumber = minorNumber;
      }
      getMajorNumber() {
        return this.majorNumber;
      }
      getMinorNumber() {
        return this.minorNumber;
      }
      toString() {
        const string = `${this.majorNumber}.${this.minorNumber}`;
        return string;
      }
      toVersionNumber() {
        const versionNumber = this.majorNumber * _multiplers.MAJOR_NUMBER_MULTIPLIER + this.minorNumber * _multiplers.MINOR_NUMBER_MULTIPLIER;
        return versionNumber;
      }
      getLeastMatchingVersionNumber() {
        const versionNumber = this.toVersionNumber(), leastMatchingVersionNumber = versionNumber;
        return leastMatchingVersionNumber;
      }
      getGreatestMatchingVersionNumber() {
        const majorNumber = this.majorNumber + 1, minorNumber = 0, shortenedVersion = ShortenedVersion.fromMajorNumberAndMinorNumber(majorNumber, minorNumber), shortenedVersionNumber = shortenedVersion.toVersionNumber(), greatestMatchingVersionNumber = shortenedVersionNumber - 1;
        return greatestMatchingVersionNumber;
      }
      static fromString(string) {
        const majorNumber = (0, _version.majorNumberFromString)(string), minorNumber = (0, _version.minorNumberFromString)(string), shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
      static fromVersionNumber(versionNumber) {
        const number = versionNumber, majorNumber = (0, _version.majorNumberFromNumber)(number), minorNumber = (0, _version.minorNumberFromNumber)(number), shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
      static fromMajorNumberAndMinorNumber(majorNumber, minorNumber) {
        const shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
    };
  });

  // node_modules/occam-model/lib/dependencies.js
  var require_dependencies = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Dependencies;
      }
    });
    var _necessary = require_browser();
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Dependencies = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      addDependency(dependency) {
        this.array.push(dependency);
      }
      mapDependency(callback) {
        return this.array.map(callback);
      }
      everyDependency(callback) {
        return this.array.every(callback);
      }
      reduceDependency(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachDependency(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachDependency(operation, done) {
        forEach(this.array, operation, done);
      }
      toJSON() {
        const dependenciesJSON = this.array.reduce((dependenciesJSON2, dependency) => {
          const name = dependency.getName(), shortenedVersion = dependency.getShortedVersion(), shortenedVersionString = shortenedVersion.toString();
          dependenciesJSON2[name] = shortenedVersionString;
          return dependenciesJSON2;
        }, {}), json = dependenciesJSON;
        return json;
      }
      static fromJSON(json) {
        const dependenciesJSON = json, dependenciesJSONKeys = Object.keys(dependenciesJSON), names = dependenciesJSONKeys, array = names.map((name) => {
          const shortenedVersionString = dependenciesJSON[name], string = shortenedVersionString, shortenedVersion = _shortenedVersion.default.fromString(string), dependency = _dependency.default.fromNameAndShortenedVersion(name, shortenedVersion);
          return dependency;
        }), dependencies = new Dependencies(array);
        return dependencies;
      }
      static fromNothing() {
        const array = [], dependencies = new Dependencies(array);
        return dependencies;
      }
    };
  });

  // node_modules/occam-model/lib/utilities/query.js
  var require_query5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
  });

  // node_modules/occam-model/lib/utilities/validate.js
  var require_validate2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isStringShortenedVersionString() {
        return isStringShortenedVersionString;
      },
      get isStringVersionString() {
        return isStringVersionString;
      }
    });
    function isStringVersionString(string) {
      return /(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))/.test(string);
    }
    function isStringShortenedVersionString(string) {
      return /(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))/.test(string);
    }
  });

  // node_modules/occam-model/lib/propertyNames.js
  var require_propertyNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DEPENDENCIES_PROPERTY_NAME() {
        return DEPENDENCIES_PROPERTY_NAME;
      },
      get REPOSITORY_PROPERTY_NAME() {
        return REPOSITORY_PROPERTY_NAME;
      },
      get VERSION_PROPERTY_NAME() {
        return VERSION_PROPERTY_NAME;
      }
    });
    var VERSION_PROPERTY_NAME = "version";
    var REPOSITORY_PROPERTY_NAME = "repository";
    var DEPENDENCIES_PROPERTY_NAME = "dependencies";
  });

  // node_modules/occam-model/lib/utilities/metaJSON.js
  var require_metaJSON = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get dependenciesFromDocumentNode() {
        return dependenciesFromDocumentNode;
      },
      get dependencyNamesFromDocumentNode() {
        return dependencyNamesFromDocumentNode;
      },
      get documentNodeFromMetaJSONFile() {
        return documentNodeFromMetaJSONFile;
      },
      get isMetaJSONFileValid() {
        return isMetaJSONFileValid;
      },
      get repositoryFromDocumentNode() {
        return repositoryFromDocumentNode;
      },
      get updateMetaJSONFileVersion() {
        return updateMetaJSONFileVersion;
      },
      get versionFromDocumentNode() {
        return versionFromDocumentNode;
      }
    });
    var _occamgrammars = require_lib11();
    var _version = /* @__PURE__ */ _interop_require_default(require_version3());
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _dependencies = /* @__PURE__ */ _interop_require_default(require_dependencies());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    var _constants = require_constants12();
    var _content = require_content3();
    var _query = require_query5();
    var _validate = require_validate2();
    var _propertyNames = require_propertyNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var jsonLexer = _occamgrammars.JSONLexer.fromNothing();
    var jsonParser = _occamgrammars.JSONParser.fromNothing();
    var errorNodesQuery = (0, _query.nodesQuery)("/*/error");
    var propertyNodesQuery = (0, _query.nodesQuery)("/property/json/object/property");
    var documentPropertyNodesQuery = (0, _query.nodesQuery)("/document/json/object/property");
    var propertyStringLiteralTerminalNodeQuery = (0, _query.nodeQuery)("/property/@string-literal");
    var propertyJSONStringLiteralTerminalNodeQuery = (0, _query.nodeQuery)("/property/json/@string-literal!");
    function isMetaJSONFileValid(metaJSONFile) {
      let metaJSONFileValid = false;
      const documentNode = documentNodeFromMetaJSONFile(metaJSONFile);
      if (documentNode !== null) {
        const errorNodes = errorNodesQuery(documentNode), errorNodesLength = errorNodes.length;
        if (errorNodesLength === 0) {
          const version = versionFromDocumentNode(documentNode), repository = repositoryFromDocumentNode(documentNode), dependencies = dependenciesFromDocumentNode(documentNode);
          metaJSONFileValid = version !== null && repository !== null && dependencies !== null;
        }
      }
      return metaJSONFileValid;
    }
    function updateMetaJSONFileVersion(metaJSONFile, version) {
      const documentNode = documentNodeFromMetaJSONFile(metaJSONFile), repository = repositoryFromDocumentNode(documentNode);
      let dependencies = dependenciesFromDocumentNode(documentNode);
      const string = version.toString(), dependenciesJSON = dependencies.toJSON();
      version = string;
      dependencies = dependenciesJSON;
      const metaJSON = {
        version,
        repository,
        dependencies
      }, metaJSONString = JSON.stringify(metaJSON, null, _constants.DOUBLE_SPACE), metaJSONFileContent = metaJSONString;
      metaJSONFile.setContent(metaJSONFileContent);
    }
    function documentNodeFromMetaJSONFile(metaJSONFile) {
      let documentNode = null;
      if (metaJSONFile !== null) {
        const content = metaJSONFile.getContent(), tokens = jsonLexer.tokenise(content), node = jsonParser.parse(tokens);
        documentNode = node;
      }
      return documentNode;
    }
    function versionFromDocumentNode(documentNode) {
      let version = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.VERSION_PROPERTY_NAME) {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringVersionString = (0, _validate.isStringVersionString)(string);
            if (stringVersionString) {
              version = _version.default.fromString(string);
            }
            return true;
          }
        }
      });
      return version;
    }
    function repositoryFromDocumentNode(documentNode) {
      let repository = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.REPOSITORY_PROPERTY_NAME) {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode);
          if (stringPropertyValue !== null) {
            repository = stringPropertyValue;
            return true;
          }
        }
      });
      return repository;
    }
    function dependenciesFromDocumentNode(documentNode) {
      let dependencies = null;
      const dependenciesPropertyNode = dependenciesPropertyNodeFromDocumentNode(documentNode);
      if (dependenciesPropertyNode !== null) {
        dependencies = _dependencies.default.fromNothing();
        const propertyNode = dependenciesPropertyNode, propertyNodes = propertyNodesQuery(propertyNode);
        propertyNodes.forEach((propertyNode2) => {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode2);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringShortenedVersionString = (0, _validate.isStringShortenedVersionString)(string);
            if (stringShortenedVersionString) {
              const propertyName = propertyNameFromPropertyNode(propertyNode2), name = propertyName, shortenedVersion = _shortenedVersion.default.fromString(string), dependency = _dependency.default.fromNameAndShortenedVersion(name, shortenedVersion);
              dependencies.addDependency(dependency);
            }
          }
        });
      }
      return dependencies;
    }
    function dependencyNamesFromDocumentNode(documentNode) {
      let dependencyNames = null;
      const dependenciesPropertyNode = dependenciesPropertyNodeFromDocumentNode(documentNode);
      if (dependenciesPropertyNode !== null) {
        dependencyNames = [];
        const propertyNode = dependenciesPropertyNode, propertyNodes = propertyNodesQuery(propertyNode);
        propertyNodes.forEach((propertyNode2) => {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode2);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringShortenedVersionString = (0, _validate.isStringShortenedVersionString)(string);
            if (stringShortenedVersionString) {
              const propertyName = propertyNameFromPropertyNode(propertyNode2), dependencyName = propertyName;
              dependencyNames.push(dependencyName);
            }
          }
        });
      }
      return dependencyNames;
    }
    var _default = {
      isMetaJSONFileValid,
      updateMetaJSONFileVersion,
      documentNodeFromMetaJSONFile,
      versionFromDocumentNode,
      repositoryFromDocumentNode,
      dependenciesFromDocumentNode,
      dependencyNamesFromDocumentNode
    };
    function propertyNameFromPropertyNode(propertyNode) {
      const propertyStringLiteralTerminalNode = propertyStringLiteralTerminalNodeQuery(propertyNode), propertyStringLiteralTerminalNodeContent = propertyStringLiteralTerminalNode.getContent(), propertyName = (0, _content.trimDoubleQuotes)(propertyStringLiteralTerminalNodeContent);
      return propertyName;
    }
    function stringPropertyValueFromPropertyNode(propertyNode) {
      let stringPropertyValue = null;
      const propertyJSONStringLiteralTerminalNode = propertyJSONStringLiteralTerminalNodeQuery(propertyNode);
      if (propertyJSONStringLiteralTerminalNode !== null) {
        const propertyJSONStringLiteralTerminalNodeContent = propertyJSONStringLiteralTerminalNode.getContent();
        stringPropertyValue = (0, _content.trimDoubleQuotes)(propertyJSONStringLiteralTerminalNodeContent);
      }
      return stringPropertyValue;
    }
    function documentPropertyNodesFromDocumentNode(documentNode) {
      const documentPropertyNodes = documentPropertyNodesQuery(documentNode);
      return documentPropertyNodes;
    }
    function dependenciesPropertyNodeFromDocumentNode(documentNode) {
      let dependenciesPropertyNode = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.DEPENDENCIES_PROPERTY_NAME) {
          dependenciesPropertyNode = propertyNode;
          return true;
        }
      });
      return dependenciesPropertyNode;
    }
  });

  // node_modules/occam-model/lib/mixins/metaJSON.js
  var require_metaJSON2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _metaJSON = require_metaJSON();
    function getVersion() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), version = (0, _metaJSON.versionFromDocumentNode)(documentNode);
      return version;
    }
    function getRepository() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), repository = (0, _metaJSON.repositoryFromDocumentNode)(documentNode);
      return repository;
    }
    function getDependencies() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), dependencies = (0, _metaJSON.dependenciesFromDocumentNode)(documentNode);
      return dependencies;
    }
    function getDependencyNames() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), dependencyNames = (0, _metaJSON.dependencyNamesFromDocumentNode)(documentNode);
      return dependencyNames;
    }
    var metaJSONMixins = {
      getVersion,
      getRepository,
      getDependencies,
      getDependencyNames
    };
    var _default = metaJSONMixins;
  });

  // node_modules/occam-model/lib/mixins/vocabulary.js
  var require_vocabulary2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants12();
    var _name = require_name5();
    var _fileNames = require_fileNames();
    function getVocabulary(vocabularyFileName) {
      let vocabulary = _constants.EMPTY_STRING;
      const customGrammarVocabularyFiles = this.getCustomGrammarVocabularyFiles(), customGrammarVocabularyFile = customGrammarVocabularyFiles.find((customGrammarVocabularyFile2) => {
        const customGrammarVocabularyFilePath = customGrammarVocabularyFile2.getPath(), customGrammarVocabularyFileName = (0, _name.fileNameFromFilePath)(customGrammarVocabularyFilePath);
        if (customGrammarVocabularyFileName === vocabularyFileName) {
          return true;
        }
      }) || null;
      if (customGrammarVocabularyFile !== null) {
        const customGrammarVocabularyFileContent = customGrammarVocabularyFile.getContent();
        vocabulary = customGrammarVocabularyFileContent;
      }
      return vocabulary;
    }
    function getTypeVocabulary() {
      const fileName = _fileNames.TYPE_VOCABULARY_FILE_NAME, vocabulary = this.getVocabulary(fileName), typeVocabulary = vocabulary;
      return typeVocabulary;
    }
    function getSymbolVocabulary() {
      const fileName = _fileNames.SYMBOL_VOCABULARY_FILE_NAME, vocabulary = this.getVocabulary(fileName), symbolVocabulary = vocabulary;
      return symbolVocabulary;
    }
    var vocabularyMixins = {
      getVocabulary,
      getTypeVocabulary,
      getSymbolVocabulary
    };
    var _default = vocabularyMixins;
  });

  // node_modules/occam-model/lib/entries.js
  var require_entries12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _files = /* @__PURE__ */ _interop_require_default(require_files());
    var _directory = /* @__PURE__ */ _interop_require_default(require_directory());
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf13());
    var _files1 = /* @__PURE__ */ _interop_require_default(require_files3());
    var _metaJSON = /* @__PURE__ */ _interop_require_default(require_metaJSON2());
    var _vocabulary = /* @__PURE__ */ _interop_require_default(require_vocabulary2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, filter} = _necessary.arrayUtilities;
    var {topmostDirectoryNameFromPath} = _necessary.pathUtilities;
    var Entries = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getTopmostDirectoryName() {
        let topmostDirectoryName = null;
        const firstEntry = first2(this.array);
        if (firstEntry) {
          const firstEntryPath = firstEntry.getPath();
          topmostDirectoryName = topmostDirectoryNameFromPath(firstEntryPath);
          if (topmostDirectoryName === null) {
            topmostDirectoryName = firstEntryPath;
          }
        }
        return topmostDirectoryName;
      }
      removeFileByPath(path) {
        filter(this.array, (entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry, filePath = file.getPath();
            if (filePath === path) {
              return false;
            }
          }
          return true;
        });
      }
      findFile(filePath) {
        const files = this.getFiles(), file = files.findFile((file2) => {
          const filePathMatches = file2.matchFilePath(filePath);
          if (filePathMatches) {
            return true;
          }
        }) || null;
        return file;
      }
      getFiles() {
        const files = _files.default.fromNothing();
        this.mapEntry((entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry;
            files.addFile(file);
          }
        });
        return files;
      }
      getFilePaths() {
        const filePaths = this.reduceEntry((filePaths2, entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry, filePath = file.getPath();
            filePaths2.push(filePath);
          }
          return filePaths2;
        }, []);
        return filePaths;
      }
      getDirectoryPaths() {
        const directoryPaths = this.reduceEntry((directoryPaths2, entry) => {
          const entryDirectory = entry.isDirectory();
          if (entryDirectory) {
            const directory = entry, directoryPath = directory.getPath();
            directoryPaths2.push(directoryPath);
          }
          return directoryPaths2;
        }, []);
        return directoryPaths;
      }
      matchShortenedVersion(shortenedVersion) {
        const version = this.getVersion(), versionMatchesShortenedVersion = version.matchShortenedVersion(shortenedVersion);
        return versionMatchesShortenedVersion;
      }
      addFile(file) {
        const entry = file;
        this.addEntry(entry);
      }
      addEntry(entry) {
        this.array.push(entry);
      }
      addDirectory(directory) {
        const entry = directory;
        this.addEntry(entry);
      }
      forEachFile(callback) {
        const files = this.getFiles();
        files.forEachFile(callback);
      }
      mapEntry(callback) {
        return this.array.map(callback);
      }
      someEntry(callback) {
        return this.array.some(callback);
      }
      everyEntry(callback) {
        return this.array.every(callback);
      }
      forEachEntry(callback) {
        this.array.forEach(callback);
      }
      reduceEntry(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      toJSON() {
        const entriesJSON = this.array.map((entry) => {
          const entryJSON = entry.toJSON();
          return entryJSON;
        }), json = entriesJSON;
        return json;
      }
      static fromJSON(json) {
        const array = [], entries = new Entries(array), entriesJSON = json;
        entriesJSON.map((entryJSON) => {
          const json2 = entryJSON, file = _file.default.fromJSON(json2), directory = _directory.default.fromJSON(json2), entry = file || directory;
          entries.addEntry(entry);
        });
        return entries;
      }
      static fromEntry(entry) {
        const array = [
          entry
        ], entries = new Entries(array);
        return entries;
      }
      static fromNothing() {
        const array = [], entries = new Entries(array);
        return entries;
      }
    };
    Object.assign(Entries.prototype, _bnf.default);
    Object.assign(Entries.prototype, _files1.default);
    Object.assign(Entries.prototype, _metaJSON.default);
    Object.assign(Entries.prototype, _vocabulary.default);
    var _default = Entries;
  });

  // node_modules/occam-model/lib/mixins/entries.js
  var require_entries13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    function forEachFile(callback) {
      return this.entries.forEachFile(callback);
    }
    function findFile(filePath) {
      return this.entries.findFile(filePath);
    }
    function getBNF() {
      return this.entries.getBNF();
    }
    function getFiles() {
      return this.entries.getFiles();
    }
    function getTermBNF() {
      return this.entries.getTermBNF();
    }
    function getVersion() {
      return this.entries.getVersion();
    }
    function getFilePaths() {
      return this.entries.getFilePaths();
    }
    function getVocabulary() {
      return this.entries.getVocabulary();
    }
    function getRepository() {
      return this.entries.getRepository();
    }
    function getReadmeFile() {
      return this.entries.getReadmeFile();
    }
    function getStatementBNF() {
      return this.entries.getStatementBNF();
    }
    function getDependencies() {
      return this.entries.getDependencies();
    }
    function getTypeVocabulary() {
      return this.entries.getTypeVocabulary();
    }
    function getSymbolVocabulary() {
      return this.entries.getSymbolVocabulary();
    }
    function getMetaJSONFile() {
      return this.entries.getMetaJSONFile();
    }
    function getFurtleFiles() {
      return this.entries.getFurtleFiles();
    }
    function getNominalFiles() {
      return this.entries.getNominalFiles();
    }
    function getDirectoryPaths() {
      return this.entries.getDirectoryPaths();
    }
    function getDependencyNames() {
      return this.entries.getDependencyNames();
    }
    function getCustomGrammarBNFFiles() {
      return this.entries.getCustomGrammarBNFFiles();
    }
    function getCustomGrammarVocabularyFiles() {
      return this.entries.getCustomGrammarVocabularyFiles();
    }
    var entriesMixins = {
      forEachFile,
      findFile,
      getBNF,
      getFiles,
      getTermBNF,
      getVersion,
      getFilePaths,
      getVocabulary,
      getRepository,
      getReadmeFile,
      getStatementBNF,
      getDependencies,
      getTypeVocabulary,
      getSymbolVocabulary,
      getMetaJSONFile,
      getFurtleFiles,
      getNominalFiles,
      getDirectoryPaths,
      getDependencyNames,
      getCustomGrammarBNFFiles,
      getCustomGrammarVocabularyFiles
    };
    var _default = entriesMixins;
  });

  // node_modules/occam-model/lib/project.js
  var require_project = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _entries1 = /* @__PURE__ */ _interop_require_default(require_entries13());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Project = class {
      constructor(name, entries) {
        this.name = name;
        this.entries = entries;
      }
      getName() {
        return this.name;
      }
      getEntries() {
        return this.entries;
      }
      toJSON() {
        const entriesJSON = this.entries.toJSON(), name = this.name, entries = entriesJSON, json = {
          name,
          entries
        };
        return json;
      }
      static fromJSON(json) {
        let {entries} = json;
        const {name} = json, entriesJSON = entries;
        json = entriesJSON;
        entries = _entries.default.fromJSON(json);
        const project = new Project(name, entries);
        return project;
      }
      static fromName(name) {
        const entries = _entries.default.fromNothing(), project = new Project(name, entries);
        return project;
      }
      static fromNameAndEntries(name, entries) {
        const project = new Project(name, entries);
        return project;
      }
    };
    Object.assign(Project.prototype, _entries1.default);
    var _default = Project;
  });

  // node_modules/occam-model/lib/release.js
  var require_release2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _entries1 = /* @__PURE__ */ _interop_require_default(require_entries13());
    var _constants = require_constants12();
    var _metaJSON = require_metaJSON();
    var _filePath = require_filePath();
    var _files = require_files2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Release = class {
      constructor(name, entries) {
        this.name = name;
        this.entries = entries;
      }
      getName() {
        return this.name;
      }
      getEntries() {
        return this.entries;
      }
      updateVersion(version) {
        let repository = this.getRepository(), dependencies = this.getDependencies();
        const versionString = version.toString(), repositoryJSON = repository, dependenciesJSON = dependencies.toJSON();
        version = versionString;
        repository = repositoryJSON;
        dependencies = dependenciesJSON;
        const metaJSONFile = this.getMetaJSONFile(), json = {
          version,
          repository,
          dependencies
        }, jsonString = JSON.stringify(json, null, _constants.DOUBLE_SPACE), file = metaJSONFile, content = jsonString;
        file.setContent(content);
      }
      toJSON() {
        const entriesJSON = this.entries.toJSON(), name = this.name, entries = entriesJSON, json = {
          name,
          entries
        };
        return json;
      }
      static fromJSON(json) {
        let {entries} = json;
        const {name} = json, entriesJSON = entries;
        json = entriesJSON;
        entries = _entries.default.fromJSON(json);
        const release = new Release(name, entries);
        return release;
      }
      static fromProject(project) {
        let release = null, entries = project.getEntries();
        const entriesReleasable = areEntriesReleasable(entries);
        if (entriesReleasable) {
          const name = project.getName(), releasedEntries = releaseEntriesFromEntries(entries);
          entries = releasedEntries;
          release = new Release(name, entries);
        }
        return release;
      }
      static fromNameAndEntries(name, entries) {
        let release = null;
        const entriesReleasable = areEntriesReleasable(entries);
        if (entriesReleasable) {
          release = new Release(name, entries);
        }
        return release;
      }
    };
    Object.assign(Release.prototype, _entries1.default);
    var _default = Release;
    function releaseEntriesFromEntries(entries) {
      const releasedEntries = _entries.default.fromNothing(), files = entries.getFiles();
      files.forEachFile((file) => {
        const filePath = file.getPath(), filePathReleaseFilePath = (0, _filePath.isFilePathReleaseFilePath)(filePath);
        if (filePathReleaseFilePath) {
          const path = filePath, content = file.getContent(), released = true;
          file = _file.default.fromPathContentAndReleased(path, content, released);
          releasedEntries.addFile(file);
        }
      });
      return releasedEntries;
    }
    function areEntriesReleasable(entries) {
      let entriesReleasable = false;
      const files = entries.getFiles(), readmeFile = (0, _files.readmeFileFromFiles)(files), metaJSONFile = (0, _files.metaJSONFileFromFiles)(files);
      if (readmeFile !== null && metaJSONFile !== null) {
        const metaJSONFileValid = (0, _metaJSON.isMetaJSONFileValid)(metaJSONFile);
        if (metaJSONFileValid) {
          entriesReleasable = true;
        }
      }
      return entriesReleasable;
    }
  });

  // node_modules/occam-model/lib/projects.js
  var require_projects = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Projects;
      }
    });
    var _necessary = require_browser();
    var _project = /* @__PURE__ */ _interop_require_default(require_project());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Projects = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        return this.array.length;
      }
      addProject(project) {
        this.array.push(project);
      }
      mapProject(callback) {
        return this.array.map(callback);
      }
      reduceProject(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachProject(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachProject(callback, done) {
        forEach(this.array, callback, done);
      }
      toJSON() {
        const json = this.array.map((project) => {
          const projectJSON = project.toJSON();
          return projectJSON;
        });
        return json;
      }
      static fromJSON(json) {
        const array = json.map((json2) => {
          const project = _project.default.fromJSON(json2);
          return project;
        }), projects = new Projects(array);
        return projects;
      }
      static fromNothing() {
        const array = [], projects = new Projects(array);
        return projects;
      }
    };
  });

  // node_modules/occam-model/lib/releases.js
  var require_releases = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Releases;
      }
    });
    var _necessary = require_browser();
    var _release = /* @__PURE__ */ _interop_require_default(require_release2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Releases = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        return this.array.length;
      }
      addRelease(release) {
        this.array.push(release);
      }
      mapRelease(callback) {
        return this.array.map(callback);
      }
      reduceRelease(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachRelease(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachRelease(callback, done) {
        forEach(this.array, callback, done);
      }
      toJSON() {
        const json = this.array.map((release) => {
          const releaseJSON = release.toJSON();
          return releaseJSON;
        });
        return json;
      }
      static fromJSON(json) {
        const array = json.map((json2) => {
          const release = _release.default.fromJSON(json2);
          return release;
        }), releases = new Releases(array);
        return releases;
      }
      static fromNothing() {
        const array = [], releases = new Releases(array);
        return releases;
      }
    };
  });

  // node_modules/occam-model/lib/index.js
  var require_lib13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Dependencies() {
        return _dependencies.default;
      },
      get Dependency() {
        return _dependency.default;
      },
      get Directory() {
        return _directory.default;
      },
      get Entries() {
        return _entries.default;
      },
      get File() {
        return _file.default;
      },
      get Files() {
        return _files.default;
      },
      get Project() {
        return _project.default;
      },
      get Projects() {
        return _projects.default;
      },
      get Release() {
        return _release.default;
      },
      get Releases() {
        return _releases.default;
      },
      get ShortenedVersion() {
        return _shortenedVersion.default;
      },
      get Version() {
        return _version.default;
      },
      get contentUtilities() {
        return _content.default;
      },
      get fileNames() {
        return _fileNames.default;
      },
      get filePathUtilities() {
        return _filePath.default;
      },
      get metaJSONUtilities() {
        return _metaJSON.default;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _files = /* @__PURE__ */ _interop_require_default(require_files());
    var _version = /* @__PURE__ */ _interop_require_default(require_version3());
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _project = /* @__PURE__ */ _interop_require_default(require_project());
    var _release = /* @__PURE__ */ _interop_require_default(require_release2());
    var _projects = /* @__PURE__ */ _interop_require_default(require_projects());
    var _releases = /* @__PURE__ */ _interop_require_default(require_releases());
    var _directory = /* @__PURE__ */ _interop_require_default(require_directory());
    var _fileNames = /* @__PURE__ */ _interop_require_default(require_fileNames());
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _dependencies = /* @__PURE__ */ _interop_require_default(require_dependencies());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    var _content = /* @__PURE__ */ _interop_require_default(require_content3());
    var _filePath = /* @__PURE__ */ _interop_require_default(require_filePath());
    var _metaJSON = /* @__PURE__ */ _interop_require_default(require_metaJSON());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/utilities/releaseContext.js
  var require_releaseContext = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get releaseContextFromJSON() {
        return releaseContextFromJSON;
      },
      get releaseContextFromProject() {
        return releaseContextFromProject;
      },
      get releaseContextFromRelease() {
        return releaseContextFromRelease;
      }
    });
    var _occammodel = require_lib13();
    var _release = /* @__PURE__ */ _interop_require_default(require_release());
    var _customGrammar = require_customGrammar3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {isMetaJSONFileValid} = _occammodel.metaJSONUtilities;
    function releaseContextFromJSON(json, context2) {
      const {log, callback} = context2, {name} = json;
      let {entries} = json;
      ({context: context2} = json);
      json = entries;
      entries = _occammodel.Entries.fromJSON(json);
      const contextJSON = context2;
      json = contextJSON;
      const customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries), releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
      return releaseContext;
    }
    function releaseContextFromProject(project, context2) {
      let releaseContext = null;
      if (project !== null) {
        const metaJSONFile = project.getMetaJSONFile();
        if (metaJSONFile !== null) {
          const metaJSONFileValid = isMetaJSONFileValid(metaJSONFile);
          if (metaJSONFileValid) {
            const {log, callback} = context2, name = project.getName(), json = null, entries = project.getEntries(), customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries);
            releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
          }
        }
      }
      return releaseContext;
    }
    function releaseContextFromRelease(release, context2) {
      let releaseContext = null;
      if (release !== null) {
        const {log, callback} = context2, name = release.getName(), json = null, entries = release.getEntries(), customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries);
        releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
      }
      return releaseContext;
    }
    var _default = {
      releaseContextFromJSON,
      releaseContextFromProject,
      releaseContextFromRelease
    };
  });

  // node_modules/occam-languages/lib/index.js
  var require_lib14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AsyncPass() {
        return _async.default;
      },
      get Context() {
        return _context.default;
      },
      get Element() {
        return _element.default;
      },
      get EquivalencePass() {
        return _equivalence.default;
      },
      get FileContext() {
        return _file.default;
      },
      get ForwardPass() {
        return _forward.default;
      },
      get Log() {
        return _log.default;
      },
      get NonTerminalNode() {
        return _nonTerminalNode.default;
      },
      get ReleaseContext() {
        return _release.default;
      },
      get SimplePass() {
        return _simple.default;
      },
      get ZipPass() {
        return _zip.default;
      },
      get asynchronousUtilities() {
        return _asynchronous.default;
      },
      get fileContextUtilities() {
        return _fileContext.default;
      },
      get nodeUtilities() {
        return _node.default;
      },
      get queryUtilities() {
        return _query.default;
      },
      get releaseContextUtilities() {
        return _releaseContext.default;
      },
      get verificationUtilities() {
        return _verification.default;
      }
    });
    var _log = /* @__PURE__ */ _interop_require_default(require_log());
    var _element = /* @__PURE__ */ _interop_require_default(require_element4());
    var _context = /* @__PURE__ */ _interop_require_default(require_context());
    var _file = /* @__PURE__ */ _interop_require_default(require_file());
    var _release = /* @__PURE__ */ _interop_require_default(require_release());
    var _nonTerminalNode = /* @__PURE__ */ _interop_require_default(require_nonTerminalNode2());
    var _zip = /* @__PURE__ */ _interop_require_default(require_zip());
    var _async = /* @__PURE__ */ _interop_require_default(require_async2());
    var _simple = /* @__PURE__ */ _interop_require_default(require_simple());
    var _forward = /* @__PURE__ */ _interop_require_default(require_forward());
    var _equivalence = /* @__PURE__ */ _interop_require_default(require_equivalence());
    var _node = /* @__PURE__ */ _interop_require_default(require_node4());
    var _query = /* @__PURE__ */ _interop_require_default(require_query4());
    var _fileContext = /* @__PURE__ */ _interop_require_default(require_fileContext());
    var _verification = /* @__PURE__ */ _interop_require_default(require_verification());
    var _asynchronous = /* @__PURE__ */ _interop_require_default(require_asynchronous2());
    var _releaseContext = /* @__PURE__ */ _interop_require_default(require_releaseContext());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/elements.js
  var require_elements2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get define() {
        return define;
      }
    });
    var elements = {};
    function define(Element) {
      const {name} = Element;
      elements[name] = Element;
      return Element;
    }
    var _default = elements;
  });

  // lib/element/step.js
  var require_step = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, arrayAssignment, objectAssigment, variablessAssignment) {
        super(context2, string, node);
        this.arrayAssignment = arrayAssignment;
        this.objectAssigment = objectAssigment;
        this.variablessAssignment = variablessAssignment;
      }
      getArrayAssignment() {
        return this.arrayAssignment;
      }
      getObjectAssigment() {
        return this.objectAssigment;
      }
      getVariablessAssignment() {
        return this.variablessAssignment;
      }
      async evaluate(context2) {
        if (false) {
        } else if (this.arrayAssignment !== null) {
          this.arrayAssignment.evaluate(context2);
        } else if (this.objectAssigment !== null) {
          this.objectAssigment.evaluate(context2);
        } else if (this.variablessAssignment !== null) {
          await this.variablessAssignment.evaluate(context2);
        }
      }
    }, __publicField(_a, "name", "Step"), _a));
  });

  // lib/exception.js
  var require_exception = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Exception;
      }
    });
    var Exception = class {
      constructor(message) {
        this.message = message;
      }
      getMessage() {
        return this.message;
      }
      static fromMessage(message) {
        const exception = new Exception(message);
        return exception;
      }
    };
  });

  // lib/types.js
  var require_types3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN_TYPE() {
        return BOOLEAN_TYPE;
      },
      get NODES_TYPE() {
        return NODES_TYPE;
      },
      get NODE_TYPE() {
        return NODE_TYPE;
      },
      get NUMBER_TYPE() {
        return NUMBER_TYPE;
      },
      get STRING_TYPE() {
        return STRING_TYPE;
      }
    });
    var NODE_TYPE = "Node";
    var NODES_TYPE = "Nodes";
    var STRING_TYPE = "String";
    var NUMBER_TYPE = "Number";
    var BOOLEAN_TYPE = "Boolean";
  });

  // lib/nullNode.js
  var require_nullNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var NullNode = class {
      static fromNothing() {
        const nullNode2 = new NullNode();
        return nullNode2;
      }
    };
    var nullNode = NullNode.fromNothing();
    var _default = nullNode;
  });

  // lib/constants.js
  var require_constants13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CONJUNCTION_OPERATOR() {
        return CONJUNCTION_OPERATOR;
      },
      get DISJUNCTION_OPERATOR() {
        return DISJUNCTION_OPERATOR;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get FALSE() {
        return FALSE;
      },
      get NOT_EQUAL_TO() {
        return NOT_EQUAL_TO;
      },
      get NULL() {
        return NULL;
      },
      get TRUE() {
        return TRUE;
      }
    });
    var NULL = "null";
    var TRUE = "true";
    var FALSE = "false";
    var EMPTY_STRING = "";
    var NOT_EQUAL_TO = "!=";
    var CONJUNCTION_OPERATOR = "&&";
    var DISJUNCTION_OPERATOR = "||";
  });

  // lib/utilities/stringLiteral.js
  var require_stringLiteral6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get stringFromStringLiteral() {
        return stringFromStringLiteral;
      },
      get stringLiteralFromString() {
        return stringLiteralFromString;
      }
    });
    var _constants = require_constants13();
    function stringFromStringLiteral(stringLiteral) {
      const string = stringLiteral.replace(/(^"|"$)/g, _constants.EMPTY_STRING);
      return string;
    }
    function stringLiteralFromString(string) {
      const stringLiteral = `"${string}"`;
      return stringLiteral;
    }
  });

  // lib/utilities/string.js
  var require_string5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get anonymousProcedureStringFromTypeParametersAndReturnBlock() {
        return anonymousProcedureStringFromTypeParametersAndReturnBlock;
      },
      get everyStringFromVariableAndAnonymousProcedure() {
        return everyStringFromVariableAndAnonymousProcedure;
      },
      get expressionStringFromProperties() {
        return expressionStringFromProperties;
      },
      get nodePropertiesStringFromNodePropertiesArray() {
        return nodePropertiesStringFromNodePropertiesArray;
      },
      get nodePropertyStringFromNameAndType() {
        return nodePropertyStringFromNameAndType;
      },
      get primtiveStringFromBoolean() {
        return primtiveStringFromBoolean;
      },
      get primtiveStringFromNode() {
        return primtiveStringFromNode;
      },
      get primtiveStringFromNodes() {
        return primtiveStringFromNodes;
      },
      get primtiveStringFromStringLiteral() {
        return primtiveStringFromStringLiteral;
      },
      get procedureDeclarationStringFromProcedure() {
        return procedureDeclarationStringFromProcedure;
      },
      get procedureStringFromTypeLabelParametersAndReturnBlock() {
        return procedureStringFromTypeLabelParametersAndReturnBlock;
      },
      get reduceStringFromVariableInitialExpressionAndAnonymousProcedure() {
        return reduceStringFromVariableInitialExpressionAndAnonymousProcedure;
      },
      get returnBlockStringFromReturnStatementNode() {
        return returnBlockStringFromReturnStatementNode;
      },
      get someStringFromVariableAndAnonymousProcedure() {
        return someStringFromVariableAndAnonymousProcedure;
      },
      get termStringFromProperties() {
        return termStringFromProperties;
      },
      get termsStringFromTermsArray() {
        return termsStringFromTermsArray;
      },
      get ternaryStringFromTerm() {
        return ternaryStringFromTerm;
      },
      get variableAssignmentStringFromTypeAndVariable() {
        return variableAssignmentStringFromTypeAndVariable;
      },
      get variableAssignmentStringFromTypeAndVariableAssignmentsArray() {
        return variableAssignmentStringFromTypeAndVariableAssignmentsArray;
      },
      get variableAssignmentStringFromVariableAssignment() {
        return variableAssignmentStringFromVariableAssignment;
      },
      get variableStringFromName() {
        return variableStringFromName;
      }
    });
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _constants = require_constants13();
    var _stringLiteral = require_stringLiteral6();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ternaryStringFromTerm(term) {
      const termString = term.getString(), ternaryString = `if (${termString}) { ... } else { ... }`;
      return ternaryString;
    }
    function variableStringFromName(name) {
      const variableString = name;
      return variableString;
    }
    function primtiveStringFromNode(node, context2) {
      const primtiveString = node === _nullNode.default ? _constants.NULL : context2.nodeAsString(node);
      return primtiveString;
    }
    function primtiveStringFromNodes(nodes, context2) {
      const string = context2.nodesAsString(nodes), primtiveString = string;
      return primtiveString;
    }
    function termStringFromProperties(properties) {
      let termString;
      properties.forEach((property) => {
        if (property !== null) {
          const propertyString = property.getString();
          termString = propertyString;
        }
      });
      return termString;
    }
    function primtiveStringFromBoolean(boolean) {
      const expresssionString = `${boolean}`;
      return expresssionString;
    }
    function termsStringFromTermsArray(termsArray) {
      const termsString = termsArray.reduce((termsString2, term) => {
        const termString = term.getString();
        termsString2 = termsString2 === null ? termString : `${termsString2}, ${termString}`;
        return termsString2;
      }, null);
      return termsString;
    }
    function expressionStringFromProperties(properties) {
      let expressionString;
      properties.forEach((property) => {
        if (property !== null) {
          const propertyString = property.getString();
          expressionString = propertyString;
        }
      });
      return expressionString;
    }
    function primtiveStringFromStringLiteral(stringLiteral) {
      const string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral), primtiveString = string;
      return primtiveString;
    }
    function nodePropertyStringFromNameAndType(name, type) {
      const typeString = type, nameString = name, nodePropertyString = `${typeString} ${nameString}`;
      return nodePropertyString;
    }
    function procedureDeclarationStringFromProcedure(procedure) {
      const type = procedure.getType(), label = procedure.getLabel(), parameters = procedure.getParameters(), returnStatement = procedure.getReturnStatement(), labelString = label.getString(), parametersString = parameters.getString(), returnStatementString = returnStatement.getString(), procedureDelcarationString = `${type} ${labelString}(${parametersString}) { ... ${returnStatementString} }`;
      return procedureDelcarationString;
    }
    function returnBlockStringFromReturnStatementNode(returnStatement) {
      const returnStatementString = returnStatement.getString(), returnBlockString = `{ ... ${returnStatementString} }`;
      return returnBlockString;
    }
    function nodePropertiesStringFromNodePropertiesArray(nodePropertiesArray) {
      const nodePropertiesString = nodePropertiesArray.reduce((nodePropertiesString2, nodeProperty) => {
        const nodePropertyString = nodeProperty.getString();
        nodePropertiesString2 = nodePropertiesString2 === null ? nodePropertyString : `${nodePropertiesString2}, ${nodePropertyString}`;
        return nodePropertiesString2;
      }, null);
      return nodePropertiesString;
    }
    function variableAssignmentStringFromTypeAndVariable(type, variable) {
      const variableString = variable.getString(), variableAssignmentString = `${type} ${variableString} = ... ;`;
      return variableAssignmentString;
    }
    function someStringFromVariableAndAnonymousProcedure(variable, anonymousProcedure) {
      const variableString = variable.getString(), anonymousProcedureString = anonymousProcedure.getString(), someString = `Some(${variableString}, ${anonymousProcedureString}) `;
      return someString;
    }
    function everyStringFromVariableAndAnonymousProcedure(variable, anonymousProcedure) {
      const variableString = variable.getString(), anonymousProcedureString = anonymousProcedure.getString(), everyString = `Every(${variableString}, ${anonymousProcedureString}) `;
      return everyString;
    }
    function variableAssignmentStringFromVariableAssignment(variableAssignment) {
      const variable = variableAssignment.getVariable(), variableString = variable.getString(), variableAssignmentString = `${variableString} = ...`;
      return variableAssignmentString;
    }
    function procedureStringFromTypeLabelParametersAndReturnBlock(type, label, parameters, returnBlock) {
      const typeString = type, labelString = label.getString(), parametersString = parameters.getString(), returnBlockString = returnBlock.getString(), procedureString = `${typeString} ${labelString}(${parametersString}) ${returnBlockString}`;
      return procedureString;
    }
    function anonymousProcedureStringFromTypeParametersAndReturnBlock(type, parameters, returnBlock) {
      const typeString = type, parametersString = parameters.getString(), returnBlockString = returnBlock.getString(), anonymousProcedureString = `${typeString} (${parametersString}) ${returnBlockString}`;
      return anonymousProcedureString;
    }
    function variableAssignmentStringFromTypeAndVariableAssignmentsArray(type, variableAssignmentsArray) {
      let variableAssignmentsString = variableAssignmentsArray.reduce((variableAssignmentsString2, variableAssignment) => {
        const variableAssignmentString = variableAssignmentStringFromVariableAssignment(variableAssignment);
        variableAssignmentsString2 = variableAssignmentsString2 === null ? variableAssignmentString : `${variableAssignmentsString2}, ${variableAssignmentString}`;
        return variableAssignmentsString2;
      }, null);
      variableAssignmentsString = `${type} ${variableAssignmentsString} ;`;
      return variableAssignmentsString;
    }
    function reduceStringFromVariableInitialExpressionAndAnonymousProcedure(variable, initialExpression, anonymousProcedure) {
      const variableString = variable.getString(), initialExpressionString = initialExpression.getString(), anonymousProcedureString = anonymousProcedure.getString(), reduceString = `Reduce(${variableString}, ${anonymousProcedureString}, ${initialExpressionString})`;
      return reduceString;
    }
  });

  // lib/utilities/primitive.js
  var require_primitive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get primitiveFromBoolean() {
        return primitiveFromBoolean;
      },
      get primitiveFromNode() {
        return primitiveFromNode;
      },
      get primitiveFromNodes() {
        return primitiveFromNodes;
      },
      get primitiveFromStringLiteral() {
        return primitiveFromStringLiteral;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _types = require_types3();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function primitiveFromNode(node, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromNode)(node, context2), string = primitiveString, type = _types.NODE_TYPE, value = node;
      node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromNodes(nodes, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromNodes)(nodes, context2), string = primitiveString, type = _types.NODES_TYPE, value = nodes, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromBoolean(boolean, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromBoolean)(boolean), string = primitiveString, type = _types.BOOLEAN_TYPE, value = boolean, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromStringLiteral(stringLiteral, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromStringLiteral)(stringLiteral), string = primitiveString, type = _types.STRING_TYPE, value = stringLiteral, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    var _default = {
      primitiveFromNode,
      primitiveFromNodes,
      primitiveFromBoolean,
      primitiveFromStringLiteral
    };
  });

  // lib/utilities/term.js
  var require_term = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get termFromBoolean() {
        return termFromBoolean;
      },
      get termFromNode() {
        return termFromNode;
      },
      get termFromNodes() {
        return termFromNodes;
      },
      get termFromPrimitive() {
        return termFromPrimitive;
      },
      get termFromStringLiteral() {
        return termFromStringLiteral;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _primitive = require_primitive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function termFromNode(node, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromNode)(node, context2), string = primitive.getString();
      node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromNodes(nodes, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromNodes)(nodes, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromBoolean(boolean, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromBoolean)(boolean, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromStringLiteral(stringLiteral, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromStringLiteral)(stringLiteral, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromPrimitive(primitive) {
      const {Term} = _elements.default, context2 = null, string = primitive.getString(), node = null, variable = null, term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    var _default = {
      termFromNode,
      termFromNodes,
      termFromBoolean,
      termFromStringLiteral,
      termFromPrimitive
    };
  });

  // lib/element/some.js
  var require_some = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncSome} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, anonymousProcedure) {
        super(context2, string, node);
        this.variable = variable;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const someString = this.getString();
        context2.trace(`Evaluating the '${someString}' some...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), nodes = primitiveValue, boolean = await asyncSome(nodes, async (node) => {
          let term2;
          term2 = (0, _term.termFromNode)(node, context2);
          const {Terms} = _elements.default, terms = Terms.fromTerm(term2, context2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          const termType2 = term2.getType();
          if (termType2 !== _types.BOOLEAN_TYPE) {
            const termString2 = term2.getString(), message = `The '${termString2}' term's type is '${termType2}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
            throw exception;
          }
          const primitiveValue2 = term2.getPrimitiveValue(), boolean2 = primitiveValue2;
          return boolean2;
        });
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.trace(`...evaluated the '${someString}' some as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Some"), _a));
  });

  // lib/element/term.js
  var require_term2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _types = require_types3();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm) {
        super(context2, string, node);
        this.variable = variable;
        this.primitive = primitive;
        this.negatedTerm = negatedTerm;
        this.logicalTerm = logicalTerm;
        this.bracketedTerm = bracketedTerm;
        this.comparisonTerm = comparisonTerm;
      }
      getVariable() {
        return this.variable;
      }
      getPrimitive() {
        return this.primitive;
      }
      getNegatedTerm() {
        return this.negatedTerm;
      }
      getLogicalTerm() {
        return this.logicalTerm;
      }
      getBreedingTerm() {
        return this.bracketedTerm;
      }
      getComparisonTerm() {
        return this.comparisonTerm;
      }
      getPrimitiveValue() {
        const primitiveValue = this.primitive.getValue();
        return primitiveValue;
      }
      getType() {
        let type;
        if (false) {
        } else if (this.variable !== null) {
          type = this.variable.getType();
        } else if (this.primitive !== null) {
          type = this.primitive.getType();
        } else if (this.negatedTerm !== null) {
          type = this.negatedTerm.getType();
        } else if (this.logicalTerm !== null) {
          type = this.logicalTerm.getType();
        } else if (this.bracketedTerm !== null) {
          type = this.bracketedTerm.getType();
        } else if (this.comparisonTerm !== null) {
          type = this.comparisonTerm.getType();
        }
        return type;
      }
      isBoolean() {
        const type = this.getType(), boolean = type === _types.BOOLEAN_TYPE;
        return boolean;
      }
      evaluate(context2) {
        let term;
        if (false) {
        } else if (this.variable !== null) {
          term = this.variable.evaluate(context2);
        } else if (this.primitive !== null) {
          term = this.primitive.evaluate(context2);
        } else if (this.negatedTerm !== null) {
          term = this.negatedTerm.evaluate(context2);
        } else if (this.logicalTerm !== null) {
          term = this.logicalTerm.evaluate(context2);
        } else if (this.bracketedTerm !== null) {
          term = this.bracketedTerm.evaluate(context2);
        } else if (this.comparisonTerm !== null) {
          term = this.comparisonTerm.evaluate(context2);
        }
        return term;
      }
      isEqualTo(term) {
        let equalTo = false;
        if (false) {
        } else if (this.variable !== null) {
          const variable = term.getVariable();
          if (variable !== null) {
            equalTo = this.variable.isEqualTo(variable);
          }
        } else if (this.primitive !== null) {
          const primitive = term.getPrimitive();
          if (primitive !== null) {
            equalTo = this.primitive.isEqualTo(primitive);
          }
        }
        return equalTo;
      }
      static fromPrimitive(primitive, context2) {
        const primitiveString = primitive.getString(), string = primitiveString, node = null, variable = null, negatedTerm = null, logicalTerm = null, bracketedTerm = null, comparisonTerm = null;
        context2 = null;
        const term = new _a(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm);
        return term;
      }
    }, __publicField(_a, "name", "Term"), _a));
  });

  // lib/element/terms.js
  var require_terms = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _string = require_string5();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getTerm(index) {
        const term = this.array[index] || null;
        return term;
      }
      addTerm(term) {
        this.array.push(term);
      }
      mapTerm(callback) {
        return this.array.map(callback);
      }
      forEachTerm(callback) {
        this.array.forEach(callback);
      }
      evaluate(context2) {
        const termsArray = this.mapTerm((term) => {
          term = term.evaluate(context2);
          return term;
        }), termsString = (0, _string.termsStringFromTermsArray)(termsArray, context2), string = termsString, array = termsArray, node = null;
        context2 = null;
        const terms = new _a(context2, string, node, array);
        return terms;
      }
      static fromTerm(term, context2) {
        const termsArray = [
          term
        ], termsString = (0, _string.termsStringFromTermsArray)(termsArray, context2), string = termsString, array = termsArray, node = null;
        context2 = null;
        const terms = new _a(context2, string, node, array);
        return terms;
      }
    }, __publicField(_a, "name", "Terms"), _a));
  });

  // lib/element/label.js
  var require_label = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, name) {
        super(context2, string, node);
        this.name = name;
      }
      getName() {
        return this.name;
      }
      compareProcedureName(procedureName) {
        const procedureNameCompares = this.name === procedureName;
        return procedureNameCompares;
      }
    }, __publicField(_a, "name", "Label"), _a));
  });

  // lib/element/error.js
  var require_error4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(conterxt, string, node) {
        super(context, string, node);
      }
      verify(context1) {
        const verifies = false, errorString = this.getString();
        context1.warning(`The '${errorString}' error cannot be verified.`);
        return verifies;
      }
    }, __publicField(_a, "name", "Error"), _a));
  });

  // lib/element/every.js
  var require_every = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncEvery} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, anonymousProcedure) {
        super(context2, string, node);
        this.string = string;
        this.variable = variable;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const everyString = this.getString();
        context2.trace(`Evaluating the '${everyString}' every...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = term.getNodes(), boolean = await asyncEvery(nodes, async (node) => {
          let term2;
          const {Terms} = _elements.default;
          term2 = (0, _term.termFromNode)(node, context2);
          const terms = Terms.fromTerm(term2, context2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          const termType2 = term2.getType();
          if (termType2 !== _types.BOOLEAN_TYPE) {
            const termString2 = term2.getString(), message = `The '${termString2}' term's type is '${termType2}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
            throw exception;
          }
          const boolean2 = term2.getBoolean();
          return boolean2;
        });
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.trace(`...evaluated the '${everyString}' every as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Every"), _a));
  });

  // lib/element/reduce.js
  var require_reduce = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncReduce} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, initialExpression, anonymousProcedure) {
        super(context2, string, node);
        this.variable = variable;
        this.initialExpression = initialExpression;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getInitialExpression() {
        return this.initialExpression;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const reduceString = this.getString();
        context2.trace(`Evaluating the '${reduceString}' reduce...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = term.getNodes(), initialExpression = await this.initialExpression.evaluate(context2);
        term = await asyncReduce(nodes, async (currentExpression, node) => {
          let term2;
          const {Terms} = _elements.default;
          term2 = currentTerm;
          const terms = Terms.fromTerm(term2, context2);
          term2 = (0, _term.termFromNode)(node, context2);
          terms.addTerm(term2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          return term2;
        }, initialExpression);
        const termString = term.getString();
        context2.trace(`...evaluated the '${reduceString}' reduce as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Reduce"), _a));
  });

  // lib/element/ternary.js
  var require_ternary = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term, ifExpression, elseExpression) {
        super(context2, string, node);
        this.term = term;
        this.ifExpression = ifExpression;
        this.elseExpression = elseExpression;
      }
      getTerm() {
        return this.term;
      }
      getIfBlock() {
        return this.ifExpression;
      }
      getElseBlock() {
        return this.elseExpression;
      }
      async evaluate(context2) {
        let term;
        const ternaryString = this.getString();
        context2.trace(`Evaluating the '${ternaryString}' ternary...`);
        term = this.term.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.BOOLEAN_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's type is '${termType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), boolean = primitiveValue;
        term = boolean ? await this.ifExpression.evaluate(context2) : await this.elseExpression.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${ternaryString}' ternary as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Ternary"), _a));
  });

  // lib/element/variable.js
  var require_variable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name, term) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
        this.term = term;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      getTerm() {
        return this.term;
      }
      compareVariableName(variableName) {
        const comparesToVariableName = this.name === variableName;
        return comparesToVariableName;
      }
      evaluate(context2) {
        const variableString = this.getString();
        context2.trace(`Evaluating the '${variableString}' variable...`);
        const nested = true, variableName = this.name, variablePresent = context2.isVariablePresentByVariableName(variableName, nested);
        if (!variablePresent) {
          const message = `The '${variableString}' variable is not present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const variable = context2.findVariableByVariableName(variableName), term = variable.getTerm(), termString = term.getString();
        context2.debug(`...evaluated the '${variableString}' variable as the '${termString}' term.`);
        return term;
      }
      assign(term, context2) {
        const nested = false, termString = term.getString(), variableName = this.name, variableString = this.getString(), variablePresent = context2.isVariablePresentByVariableName(variableName, nested);
        context2.trace(`Assigning the '${termString}' term to the '${variableString}' variable...`);
        if (variablePresent) {
          const message = `The '${variableString}' variable is already present.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const termType = term.getType(), variableType = this.type;
        if (termType !== variableType) {
          const message = `The '${variableString} variable's '${variableType}' type does not compare to the term's '${termType}' type.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.term = term;
        const variable = this;
        context2.addVariable(variable);
        context2.debug(`...assigned the '${termString}' term to the '${variableString}' variable.`);
      }
      static fromParameter(parameter, context2) {
        const type = parameter.getType(), name = parameter.getName(), term = null, variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
      static fromNamedParameter(namedParameter, context2) {
        const aliasedName = namedParameter.getAliasedName(), type = namedParameter.getType(), name = aliasedName, term = null, variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
      static fromTermAndParameter(term, parameter, context2) {
        const type = parameter.getType(), name = parameter.getName(), variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
    }, __publicField(_a, "name", "Variable"), _a));
  });

  // lib/element/primitive.js
  var require_primitive2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {match} = _necessary.arrayUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, value) {
        super(context2, string, node);
        this.type = type;
        this.value = value;
      }
      getType() {
        return this.type;
      }
      getValue() {
        return this.value;
      }
      evaluate(context2) {
        const {Term} = _elements.default, primitive = this, term = Term.fromPrimitive(primitive, context2);
        return term;
      }
      isEqualTo(primitive) {
        let equalTo = false;
        const type = primitive.getType();
        if (this.type === type) {
          const value = primitive.getValue();
          switch (type) {
            case _types.NODE_TYPE: {
              const nodeA = this.value, nodeB = value, nodeMatches = matchNode(nodeA, nodeB);
              if (nodeMatches) {
                equalTo = true;
              }
              break;
            }
            case _types.NODES_TYPE: {
              const nodesA = this.value, nodesB = value, nodesMatch = matchNodes(nodesA, nodesB);
              if (nodesMatch) {
                equalTo = true;
              }
              break;
            }
            case _types.STRING_TYPE: {
              const stringLiteralA = this.value, stringLiteralB = value;
              if (stringLiteralA === stringLiteralB) {
                equalTo = true;
              }
              break;
            }
            case _types.NUMBER_TYPE: {
              const numberA = this.value, numberB = value;
              if (numberA === numberB) {
                equalTo = true;
              }
              break;
            }
            case _types.BOOLEAN_TYPE: {
              const booleanA = this.value, booleanB = value;
              if (booleanA === booleanB) {
                equalTo = true;
              }
              break;
            }
          }
        }
        return equalTo;
      }
    }, __publicField(_a, "name", "Primitive"), _a));
    function matchNode(nodeA, nodeB) {
      let nodeMatches;
      if (nodeA === _nullNode.default || nodeB === _nullNode.default) {
        nodeMatches = nodeA === nodeB;
      } else if (nodeA === _nullNode.default) {
        nodeMatches = false;
      } else if (nodeB === _nullNode.default) {
        nodeMatches = false;
      } else {
        const nodeAMatchesNodeB = nodeA.match(nodeB);
        nodeMatches = nodeAMatchesNodeB;
      }
      return nodeMatches;
    }
    function matchNodes(nodesA, nodesB) {
      const nodesMatch = match(nodesA, nodesB, (nodeA, nodeB) => {
        const nodeMatches = matchNode(nodeA, nodeB);
        if (nodeMatches) {
          return true;
        }
      });
      return nodesMatch;
    }
  });

  // lib/element/reference.js
  var require_reference2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, name) {
        super(context2, string, node);
        this.name = name;
      }
      getName() {
        return this.name;
      }
      getProcedureName() {
        const procedureName = this.name;
        return procedureName;
      }
    }, __publicField(_a, "name", "Reference"), _a));
  });

  // lib/element/procedure.js
  var require_procedure = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get variablesFromTermsAndParameters() {
        return variablesFromTermsAndParameters;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, label, parameters, returnBlock) {
        super(context2, string, node);
        this.type = type;
        this.label = label;
        this.parameters = parameters;
        this.returnBlock = returnBlock;
      }
      getType() {
        return this.type;
      }
      getLabel() {
        return this.label;
      }
      getParameters() {
        return this.parameters;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      isBoolean() {
        const typeBooleanType = this.type === _types.BOOLEAN_TYPE, boolean = typeBooleanType;
        return boolean;
      }
      getName() {
        return this.label.getName();
      }
      getReturnStatement() {
        return this.returnBlock.getReturnStatement();
      }
      compareProcedureName(procedureName) {
        return this.label.compareProcedureName(procedureName);
      }
      async call(terms, context2) {
        await this.break(context2);
        const procedureString = this.getString();
        context2.trace(`Calling the '${procedureString}' procedure...`);
        this.parameters.compareTerms(terms, context2);
        const variables = variablesFromTermsAndParameters(terms, this.parameters, context2), term = await this.returnBlock.evaluate(variables, context2), termType = term.getType();
        if (this.type !== termType) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type is not equal to the '${procedureString}' procedure's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...called the '${procedureString}' procedure.`);
        return term;
      }
    }, __publicField(_a, "name", "Procedure"), _a));
    function variablesFromTermsAndParameters(terms, parameters, context2) {
      const variables = [];
      terms.forEachTerm((term, index) => {
        const parameter = parameters.getParameter(index);
        if (parameter !== null) {
          const {Variable} = _elements.default, variable = Variable.fromTermAndParameter(term, parameter, context2);
          variables.push(variable);
        }
      });
      return variables;
    }
  });

  // lib/element/nodeQuery.js
  var require_nodeQuery = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, query) {
        super(context2, string, node);
        this.variable = variable;
        this.query = query;
      }
      getVariable() {
        return this.variable;
      }
      getQuery() {
        return this.query;
      }
      evaluate(context2) {
        let term;
        const nodeQueryString = this.getString();
        context2.trace(`Evaluating the '${nodeQueryString}' node query...`);
        if (this.query === null) {
          const message = `Cannot evaluate the '${nodeQueryString}' node query because its expression is malformed.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let node;
        const primitiveValue = term.getPrimitiveValue();
        node = primitiveValue;
        if (node === null) {
          const termString2 = term.getString(), message = `The '${termString2}' term's node is null.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = this.query.execute(node), nodesLength = nodes.length;
        if (nodesLength !== 1) {
          const message = `The length of the returned nodes is ${nodesLength} when it should be 1.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const firstNode = first2(nodes);
        node = firstNode;
        term = (0, _term.termFromNode)(node, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${nodeQueryString}' node query as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NodeQuery"), _a));
  });

  // lib/element/parameter.js
  var require_parameter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      compareTerm(term, context2) {
        const termString = term.getString(), parameterString = this.getString();
        context2.trace(`Comparing the '${termString}' term against the '${parameterString}' parameter...`);
        const termType = term.getType();
        if (this.type !== termType) {
          const message = `The '${termString}' term's '${termType}' type is not equal to the '${parameterString}' parameter's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...comparing the '${termString}' term against the '${parameterString}' parameter.`);
      }
    }, __publicField(_a, "name", "Parameter"), _a));
  });

  // lib/element/parameters.js
  var require_parameters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getParameter(index) {
        const parameter = this.array[index] || null;
        return parameter;
      }
      forEachParameter(callback) {
        this.array.forEach(callback);
      }
      compareTerms(terms, context2) {
        const termsString = terms.getString(), parametersString = this.getString();
        context2.trace(`Comparing the '${termsString}' terms against the '${parametersString}' parameters...`);
        const termsLength = terms.getLength(), parametersLength = this.getLength();
        if (termsLength !== parametersLength) {
          const message = `The '${termsString}' expressions and '${parametersString}' parameters are not of the same length.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.forEachParameter((parameter, index) => {
          if (parameter !== null) {
            const term = terms.getTerm(index);
            parameter.compareTerm(term, context2);
          }
        });
        context2.debug(`...compared the '${termsString}' terms against the '${parametersString}' parameters.`);
      }
    }, __publicField(_a, "name", "Parameters"), _a));
  });

  // lib/element/nodesQuery.js
  var require_nodesQuery = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, query) {
        super(context2, string, node);
        this.variable = variable;
        this.query = query;
      }
      getVariable() {
        return this.variable;
      }
      getQuery() {
        return this.query;
      }
      evaluate(context2) {
        let term;
        const nodesQueryString = this.getString();
        context2.trace(`Evaluating the '${nodesQueryString}' nodes query...`);
        if (this.query === null) {
          const message = `Cannot evaluate the '${nodesQueryString}' nodes query because its expression is malformed.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let node;
        const primitiveValue = term.getPrimitiveValue();
        node = primitiveValue;
        if (node === null) {
          const termString2 = term.getString(), message = `The '${termString2}' term's node is null.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = this.query.execute(node);
        term = (0, _term.termFromNodes)(nodes, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${nodesQueryString}' nodes query as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NodesQuery"), _a));
  });

  // lib/element/expression.js
  var require_expression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term, some, every, reduce, ternary, nodeQuery, nodesQuery, returnBlock, procedureCall) {
        super(context2, string, node);
        this.term = term;
        this.some = some;
        this.every = every;
        this.reduce = reduce;
        this.ternary = ternary;
        this.nodeQuery = nodeQuery;
        this.nodesQuery = nodesQuery;
        this.returnBlock = returnBlock;
        this.procedureCall = procedureCall;
      }
      getTerm() {
        return this.term;
      }
      getSome() {
        return this.some;
      }
      getEvery() {
        return this.every;
      }
      getReduce() {
        return this.reduce;
      }
      getTernary() {
        return this.ternay;
      }
      getNodeQuery() {
        return this.nodeQuery;
      }
      getNodesQuery() {
        return this.nodesQuery;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      getProcedureCall() {
        return this.procedureCall;
      }
      getType() {
        let type;
        if (false) {
        } else if (this.term !== null) {
          type = this.term.getType();
        } else if (this.some !== null) {
          type = this.some.getType();
        } else if (this.every !== null) {
          type = this.every.getType();
        } else if (this.reduce !== null) {
          type = this.reduce.getType();
        } else if (this.ternary !== null) {
          type = this.ternary.getType();
        } else if (this.nodeQuery !== null) {
          type = this.nodeQuery.getType();
        } else if (this.nodesQuery !== null) {
          type = this.nodesQuery.getType();
        } else if (this.returnBlock !== null) {
          type = this.returnBlock.getType();
        } else if (this.procedureCall !== null) {
          type = this.procedureCall.getType();
        }
        return type;
      }
      async evaluate(context2) {
        let term;
        if (false) {
        } else if (this.term !== null) {
          term = this.term.evaluate(context2);
        } else if (this.nodeQuery !== null) {
          term = this.nodeQuery.evaluate(context2);
        } else if (this.nodesQuery !== null) {
          term = this.nodesQuery.evaluate(context2);
        } else if (this.some !== null) {
          term = await this.some.evaluate(context2);
        } else if (this.every !== null) {
          term = await this.every.evaluate(context2);
        } else if (this.reduce !== null) {
          term = await this.reduce.evaluate(context2);
        } else if (this.ternary !== null) {
          term = await this.ternary.evaluate(context2);
        } else if (this.returnBlock !== null) {
          term = await this.returnBlock.evaluate(context2);
        } else if (this.procedureCall !== null) {
          term = await this.procedureCall.evaluate(context2);
        }
        return term;
      }
    }, __publicField(_a, "name", "Expression"), _a));
  });

  // lib/context/block.js
  var require_block = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BlockContext;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {push} = _necessary.arrayUtilities;
    var BlockContext = class extends _occamlanguages.Context {
      constructor(context2, variables) {
        super(context2);
        this.variables = variables;
      }
      getVariables(nested = true) {
        const variables = [];
        push(variables, this.variables);
        if (nested) {
          const context2 = this.getContext(), contextVariables = context2.getVariables();
          push(variables, contextVariables);
        }
        return variables;
      }
      addVariable(variable) {
        const nested = false, variableName = variable.getName(), variableString = variable.getString(), variablePresent = this.isVariablePresentByVariableName(variableName, nested);
        if (variablePresent) {
          const message = `The '${variableString}' variable is already present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const context2 = this;
        context2.trace(`Added the '${variableString}' variable to the context.`);
        this.variables.push(variable);
      }
      findProcedureByProcedureName(procedureName) {
        const context2 = this.getContext(), procedure = context2.findProcedureByProcedureName(procedureName);
        return procedure;
      }
      isProcedurePresentByProcedureName(procedureName) {
        const context2 = this.getContext(), procedurePresent = context2.isProcedurePresentByProcedureName(procedureName);
        return procedurePresent;
      }
      findVariableByVariableName(variableName, nested = true) {
        const variables = this.getVariables(nested), variable = variables.find((variable2) => {
          const variableComparesToVariableName = variable2.compareVariableName(variableName);
          if (variableComparesToVariableName) {
            return true;
          }
        }) || null;
        return variable;
      }
      isVariablePresentByVariableName(variableName, nested = true) {
        const variable = this.findVariableByVariableName(variableName, nested), variablePresent = variable !== null;
        return variablePresent;
      }
      static fromVariables(variables, context2) {
        const blockContext = _occamlanguages.Context.fromNothing(BlockContext, variables, context2);
        return blockContext;
      }
    };
  });

  // lib/element/returnBlock.js
  var require_returnBlock = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _block = /* @__PURE__ */ _interop_require_default(require_block());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asyncForEach} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, steps, nonsensical, returnStatement) {
        super(context2, string, node);
        this.steps = steps;
        this.nonsensical = nonsensical;
        this.returnStatement = returnStatement;
      }
      getSteps() {
        return this.steps;
      }
      isNonsensical() {
        return this.nonsensical;
      }
      getReturnStatement() {
        return this.returnStatement;
      }
      async evaluate(variables, context2) {
        if (context2 === void 0) {
          context2 = variables;
          variables = [];
        }
        const returnBlockString = this.getString();
        context2.trace(`Evaluating the '${returnBlockString}' return block...`);
        if (this.nonsensical) {
          const message = `The return block is nonsensical.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const blockContext = _block.default.fromVariables(variables, context2);
        context2 = blockContext;
        await asyncForEach(this.steps, async (step) => {
          await step.evaluate(context2);
        });
        const term = this.returnStatement.evaluate(context2), termString = term.getString();
        context2.debug(`Evaluated... the '${returnBlockString}' return block as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ReturnBlock"), _a));
  });

  // lib/element/term/negated.js
  var require_negated = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, term) {
        super(context2, string, node);
        this.type = type;
        this.term = term;
      }
      getType() {
        return this.type;
      }
      getTerm() {
        return this.term;
      }
      evaluate(context2) {
        let term;
        const negatedTermString = this.getString();
        context2.trace(`Evaluating the '${negatedTermString}' negated term...`);
        term = this.term.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.BOOLEAN_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' left term's type is '${termType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let boolean;
        const primitiveValue = term.getPrimitiveValue();
        boolean = primitiveValue;
        boolean = !boolean;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${negatedTermString}' negated term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NegatedTerm"), _a));
  });

  // lib/element/term/logical.js
  var require_logical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, disjunction, leftTerm, rightTerm) {
        super(context2, string, node);
        this.type = type;
        this.disjunction = disjunction;
        this.leftTerm = leftTerm;
        this.rightTerm = rightTerm;
      }
      getType() {
        return this.type;
      }
      isDisjunction() {
        return this.disjunction;
      }
      getLeftTerm() {
        return this.leftTerm;
      }
      getRightTerm() {
        return this.rightTerm;
      }
      evaluate(context2) {
        let term;
        const logicalTermString = this.getString();
        context2.trace(`Evaluating the '${logicalTermString}' logical term...`);
        const leftTerm = this.leftTerm.evaluate(context2), rightTerm = this.rightTerm.evaluate(context2), leftTermType = leftTerm.getType(), rightTermType = rightTerm.getType();
        if (leftTermType !== _types.BOOLEAN_TYPE) {
          const leftTermString = leftTerm.getString(), message = `The '${leftTermString}' left term's type is '${leftTermType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        if (rightTermType !== _types.BOOLEAN_TYPE) {
          const rightTermString = rightTerm.getString(), message = `The '${rightTermString}' right term's type is '${rightTermType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const leftTermPrimitiveValue = leftTerm.getPrimitiveValue(), rightTermPrimitiveValue = rightTerm.getPrimitiveValue(), leftBoolean = leftTermPrimitiveValue, rightBoolean = rightTermPrimitiveValue, boolean = this.disjunction ? leftBoolean || rightBoolean : leftBoolean && rightBoolean;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${logicalTermString}' logical term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "LogicalTerm"), _a));
  });

  // lib/element/term/bracketed.js
  var require_bracketed = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term) {
        super(context2, string, node);
        this.term = term;
      }
      getTerm() {
        return this.term;
      }
      getType() {
        return this.term.getType();
      }
      evaluate(context2) {
        let term;
        const bracketedTermString = this.getString();
        context2.trace(`Evaluating the '${bracketedTermString}' bracketed term...`);
        term = this.term.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${bracketedTermString}' bracketed term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "BracketedTerm"), _a));
  });

  // lib/element/procedureCall.js
  var require_procedureCall = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, reference, terms) {
        super(context2, string, node);
        this.reference = reference;
        this.terms = terms;
      }
      getReference() {
        return this.reference;
      }
      getTerms() {
        return this.terms;
      }
      getProcedureName() {
        return this.reference.getProcedureName();
      }
      async evaluate(context2) {
        await this.break(context2);
        const procedureCallString = this.getString();
        context2.trace(`Evaluating the '${procedureCallString}' procedure call...`);
        const procedureName = this.getProcedureName(), procedurePresent = context2.isProcedurePresentByProcedureName(procedureName);
        if (!procedurePresent) {
          const message = `The '${procedureCallString} procedure is not present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const procedure = context2.findProcedureByProcedureName(procedureName), terms = this.terms.evaluate(context2), term = await procedure.call(terms, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${procedureCallString}' procedure call as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ProcedureCall"), _a));
  });

  // lib/element/term/comparison.js
  var require_comparison = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, negated, leftTerm, rightTerm) {
        super(context2, string, node);
        this.negated = negated;
        this.leftTerm = leftTerm;
        this.rightTerm = rightTerm;
      }
      isNegated() {
        return this.negated;
      }
      getLeftTerm() {
        return this.leftTerm;
      }
      getRightTerm() {
        return this.rightTerm;
      }
      evaluate(context2) {
        let term;
        const comparisonTermString = this.getString();
        context2.trace(`Evaluating the '${comparisonTermString}' comparison term...`);
        const leftTerm = this.leftTerm.evaluate(context2), rightTerm = this.rightTerm.evaluate(context2), leftTermType = leftTerm.getType(), rightTermType = rightTerm.getType();
        if (leftTermType !== rightTermType) {
          const leftTermString = leftTerm.getString(), rightTermString = rightTerm.getString(), message = `The '${leftTermString}' left term's type is '${leftTermType}' whereas the '${rightTermString}' right term's type is '${rightTermType}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const leftTermEqualToRightTerm = leftTerm.isEqualTo(rightTerm);
        let boolean = leftTermEqualToRightTerm;
        if (this.negated) {
          boolean = !boolean;
        }
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${comparisonTermString}' comparison term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ComparisonTerm"), _a));
  });

  // lib/element/parameter/named.js
  var require_named = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name, alias) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
        this.alias = alias;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      getAlias() {
        return this.alias;
      }
      isAliased() {
        const aliased = this.alias !== null;
        return aliased;
      }
      getAliasedName() {
        const aliased = this.isAliased(), aliasedName = aliased ? this.alias : this.name;
        return aliasedName;
      }
      compareTerm(term, context2) {
        const termString = term.getString(), namedParameterString = this.getString();
        context2.trace(`Comparing the '${termString}' term with the '${namedParameterString}' named parameter...`);
        const termType = term.getType();
        if (this.type !== termType) {
          const message = `The '${termString}' term's '${termType}' type is not equal to '${namedParameterString}' named parameter's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${termString}' term with the '${namedParameterString}' named parameter.`);
      }
      compareNamedParameter(namedParameter, context2) {
        let namedParameterCompares;
        const namedParameterA = this, namedParameterB = namedParameter;
        const namedParameterAString = namedParameterA.getString(), namedParameterBString = namedParameterB.getString();
        context2.trace(`Comparing the '${namedParameterAString}' named parameter with the '${namedParameterBString}' named parameter...`);
        const name = namedParameter.getName(), type = namedParameter.getType();
        namedParameterCompares = this.name === name && this.type === type;
        if (namedParameterCompares) {
          context2.debug(`...compared the '${namedParameterAString}' named parameter with the '${namedParameterBString}' named parameter.`);
        }
        return namedParameterCompares;
      }
    }, __publicField(_a, "name", "NamedParameter"), _a));
  });

  // lib/element/assignment/array.js
  var require_array4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _term = require_term();
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, parameters) {
        super(context2, string, node);
        this.variable = variable;
        this.parameters = parameters;
      }
      getVariable() {
        return this.variable;
      }
      getParameters() {
        return this.parameters;
      }
      evaluate(context2) {
        const arrayAssignmentString = this.getString();
        context2.trace(`Evaluating the '${arrayAssignmentString}' array assignment...`);
        const term = this.variable.evaluate(context2), termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), nodes = primitiveValue, nodesLength = nodes.length, parametersLength = this.parameters.getLength();
        if (parametersLength > nodesLength) {
          const parametersString = this.parameters.getString(), nodesString = context2.nodesAsString(nodex), message = `The length of the '${parametersString}' parameters is greater than the length of the '${nodesString}' nodes.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.parameters.forEachParameter((parameter, index) => {
          if (parameter !== null) {
            const node = nodes[index], term2 = (0, _term.termFromNode)(node, context2);
            this.evaluateParameter(parameter, term2, context2);
          }
        });
        context2.debug(`...evaluated the '${arrayAssignmentString}' array assignment.`);
      }
      evaluateParameter(parameter, expression, context2) {
        const expressionString = expression.getString(), parameterString = parameter.getString();
        context2.trace(`Evaluating the '${parameterString}' parameter against the '${expressionString}' expression...`);
        const parameterType = parameter.getType();
        if (parameterType !== _types.NODE_TYPE) {
          const message = `The type of the '${parameterString}' parameter should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const {Variable} = _elements.default, variable = Variable.fromParameter(parameter, context2);
        variable.assign(expression, context2);
        context2.debug(`...evaluated the '${parameterString}' parameter against the '${expressionString}' expression.`);
      }
    }, __publicField(_a, "name", "ArrayAssignment"), _a));
  });

  // lib/element/statement/return.js
  var require_return = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term) {
        super(context2, string, node);
        this.term = term;
      }
      getExpression() {
        return this.term;
      }
      evaluate(context2) {
        let term;
        const returnStatementString = this.getString();
        context2.trace(`Evaluating the '${returnStatementString}' return statement...`);
        term = this.term.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${returnStatementString}' return statement as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ReturnStatement"), _a));
  });

  // lib/element/parameters/named.js
  var require_named2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getNamedParameter(index) {
        const namedParameter = this.array[index] || null;
        return namedParameter;
      }
      someNamedParameter(callback) {
        return this.array.some(callback);
      }
      forEachNamedParameter(callback) {
        this.array.forEach(callback);
      }
      compareTerms(terms, context2) {
        const termsString = terms.getString(), namedParametersString = this.getString();
        context2.trace(`Comparing the '${termsString}' terms with the '${namedParametersString}' named parameters...`);
        const termsLength = terms.getLength(), namedParametersLength = this.getLength();
        if (termsLength !== namedParametersLength) {
          const message = `The '${termsString}' terms and '${namedParametersString}' named parameters are not of the same length.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.forEachNamedParameter((namedParameter, index) => {
          if (namedParameter !== null) {
            const term = terms.getTerm(index);
            namedParameter.compareTerm(term, context2);
          }
        });
        context2.debug(`...compared the '${termsString}' terms with the '${namedParametersString}' named parameters.`);
      }
      compareNamedParameter(namedParameter, context2) {
        const namedParameterString = namedParameter.getString(), namedParametersString = this.getString();
        context2.trace(`Comparing the '${namedParameterString}' namedParameter with the '${namedParametersString}' named parameters...`);
        const namedParameterA = namedParameter, namedParameterCompares = this.someNamedParameter((namedParameter2) => {
          if (namedParameter2 !== null) {
            const namedParameterB = namedParameter2, namedParameterBComparesToNamedParameterA = namedParameterA.compareNamedParameter(namedParameterB, context2);
            if (namedParameterBComparesToNamedParameterA) {
              return true;
            }
          }
        });
        if (!namedParameterCompares) {
          const message = `The '${namedParameterString}' namedParameter does not compare to any of the '${namedParametersString}' named parameters.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${namedParameterString}' namedParameter with the '${namedParametersString}' named parameters.`);
      }
      compareNamedParameters(namedParameters, context2) {
        namedParameters.forEachNamedParameter((namedParameter) => {
          if (namedParameter !== null) {
            this.compareNamedParameter(namedParameter, context2);
          }
        });
      }
    }, __publicField(_a, "name", "NamedParameters"), _a));
  });

  // lib/nodeProperty.js
  var require_nodeProperty = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodeProperty;
      }
    });
    var _string = require_string5();
    var _NodeProperty = class {
      constructor(string, type, name) {
        this.string = string;
        this.type = type;
        this.name = name;
      }
      getString() {
        return this.string;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      compareNamedParameter(namedParameter, context2) {
        let namedParameterCompares;
        const nodePropertyString = this.string, namedParameterString = namedParameter.getString();
        context2.trace(`Comparing the '${nodePropertyString}' node property with the '${namedParameterString}' named parameter...`);
        const name = namedParameter.getName(), type = namedParameter.getType();
        namedParameterCompares = this.name === name && this.type === type;
        if (namedParameterCompares) {
          context2.debug(`...compared the '${nodePropertyString}' node property with the '${namedParameterString}' named parameter.`);
        }
        return namedParameterCompares;
      }
      static fromNameAndType(name, type) {
        const nodePropertyString = (0, _string.nodePropertyStringFromNameAndType)(name, type), string = nodePropertyString, nodeProperty = new _NodeProperty(string, type, name);
        return nodeProperty;
      }
    };
    var NodeProperty = _NodeProperty;
    __publicField(NodeProperty, "name", "Parameter");
  });

  // lib/parameterNames.js
  var require_parameterNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CHILD_NODES_PARAMETER_NAME() {
        return CHILD_NODES_PARAMETER_NAME;
      },
      get CONTENT_PARAMETER_NAME() {
        return CONTENT_PARAMETER_NAME;
      },
      get TERMINAL_PARAMETER_NAME() {
        return TERMINAL_PARAMETER_NAME;
      }
    });
    var CONTENT_PARAMETER_NAME = "content";
    var TERMINAL_PARAMETER_NAME = "terminal";
    var CHILD_NODES_PARAMETER_NAME = "childNodes";
  });

  // lib/nodeProperties.js
  var require_nodeProperties = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _nodeProperty = /* @__PURE__ */ _interop_require_default(require_nodeProperty());
    var _types = require_types3();
    var _string = require_string5();
    var _parameterNames = require_parameterNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NodeProperties = class {
      constructor(string, array) {
        this.string = string;
        this.array = array;
      }
      getString() {
        return this.string;
      }
      getArray() {
        return this.array;
      }
      someNodeProperty(callback) {
        return this.array.some(callback);
      }
      compareNamedParameter(namedParameter, context2) {
        const nodePropertiesString = this.string, namedParameterString = namedParameter.getString();
        context2.trace(`Comparing the '${namedParameterString}' named parameter with the '${nodePropertiesString}' node properties...`);
        const namedParametersCompare = this.someNodeProperty((nodeProperty) => {
          const namedParameterComparesToNodeProperty = nodeProperty.compareNamedParameter(namedParameter, context2);
          if (namedParameterComparesToNodeProperty) {
            return true;
          }
        });
        if (!namedParametersCompare) {
          const message = `The '${namedParameterString}' named parameter does not compmare to any of the '${nodePropertiesString}' node properties.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${namedParameterString}' named parameter with the '${nodePropertiesString}' node properties.`);
      }
      compareNamedParameters(namedParameters, context2) {
        namedParameters.forEachNamedParameter((namedParameter) => {
          this.compareNamedParameter(namedParameter, context2);
        });
      }
      static fromNothing() {
        const nodePropertiesArray = nodePropertiesArrayFromNothing(), string = (0, _string.nodePropertiesStringFromNodePropertiesArray)(nodePropertiesArray), array = nodePropertiesArray, nodeProperties2 = new NodeProperties(string, array);
        return nodeProperties2;
      }
    };
    var nodeProperties = NodeProperties.fromNothing();
    var _default = nodeProperties;
    function nodePropertiesArrayFromNothing() {
      const types = [
        _types.STRING_TYPE,
        _types.BOOLEAN_TYPE,
        _types.NODES_TYPE
      ], names = [
        _parameterNames.CONTENT_PARAMETER_NAME,
        _parameterNames.TERMINAL_PARAMETER_NAME,
        _parameterNames.CHILD_NODES_PARAMETER_NAME
      ], nodePropertiesArray = names.map((name, index) => {
        const type = types[index], nodeProperty = _nodeProperty.default.fromNameAndType(name, type);
        return nodeProperty;
      });
      return nodePropertiesArray;
    }
  });

  // lib/element/assignment/object.js
  var require_object2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _nodeProperties = /* @__PURE__ */ _interop_require_default(require_nodeProperties());
    var _stringLiteral = require_stringLiteral6();
    var _types = require_types3();
    var _term = require_term();
    var _parameterNames = require_parameterNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, namedParameters) {
        super(context2, string, node);
        this.variable = variable;
        this.namedParameters = namedParameters;
      }
      getVariable() {
        return this.variable;
      }
      getNamedParameters() {
        return this.namedParameters;
      }
      evaluate(context2) {
        const objectAssignmentString = this.getString();
        context2.trace(`Evaluating the '${objectAssignmentString}' object assignment...`);
        const term = this.variable.evaluate(context2), termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        _nodeProperties.default.compareNamedParameters(this.namedParameters, context2);
        this.namedParameters.forEachNamedParameter((namedParameter) => {
          this.evaluateNamedParameter(namedParameter, term, context2);
        });
        context2.debug(`...evaluated the '${objectAssignmentString}' object assignment.`);
      }
      evaluateNamedParameter(namedParameter, term, context2) {
        const termString = term.getString(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the '${namedParameterString}' named parameter against the '${termString}' term...`);
        const name = namedParameter.getName();
        switch (name) {
          case _parameterNames.CONTENT_PARAMETER_NAME: {
            term = this.evaluateContentNamedParameter(namedParameter, term, context2);
            break;
          }
          case _parameterNames.TERMINAL_PARAMETER_NAME: {
            term = this.evaluateTerminalNamedParameter(namedParameter, term, context2);
            break;
          }
          case _parameterNames.CHILD_NODES_PARAMETER_NAME: {
            term = this.evaluateChildNodesNamedParameter(namedParameter, term, context2);
            break;
          }
        }
        const {Variable} = _elements.default, variable = Variable.fromNamedParameter(namedParameter, context2);
        variable.assign(term, context2);
        context2.debug(`...evaluated the '${namedParameterString}' parameter named against the '${termString}' term.`);
      }
      evaluateContentNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the content '${namedParameterString}' named parameter...`);
        if (type !== _types.STRING_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.STRING_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeTerminalNode = node.isTerminalNode();
        if (!nodeTerminalNode) {
          const termString = term.getString(), message = `The '${termString}' term's node must be terminal.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const terminalNode = node, content = terminalNode.getContent(), string = content, stringLiteral = (0, _stringLiteral.stringLiteralFromString)(string);
        term = (0, _term.termFromStringLiteral)(stringLiteral, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the content '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
      evaluateTerminalNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the terminal '${namedParameterString}' named parameter...`);
        if (type !== _types.BOOLEAN_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeTerminalNode = node.isTerminalNode(), terminal = nodeTerminalNode;
        const boolean = terminal;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the terminal '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
      evaluateChildNodesNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the child nodes '${namedParameterString}' named parameter...`);
        if (type !== _types.NODES_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeNonTerminalNode = node.isNonTerminalNode();
        if (!nodeNonTerminalNode) {
          const termString = term.getString(), message = `The '${termString}' term's node must be non-terminal.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nonTerminalNode = node, childNodes = nonTerminalNode.getChildNodes(), nodes = childNodes;
        term = (0, _term.termFromNodes)(nodes, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the childNodes '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ObjectAssigment"), _a));
  });

  // lib/element/procedure/anonymous.js
  var require_anonymous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _procedure = require_procedure();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, parameters, returnBlock) {
        super(context2, string, node);
        this.type = type;
        this.parameters = parameters;
        this.returnBlock = returnBlock;
      }
      getType() {
        return this.type;
      }
      getParameters() {
        return this.parameters;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      async call(terms, context2) {
        const anonymousProcedureString = this.getString();
        context2.trace(`Calling the '${anonymousProcedureString}' anonymous procedure...`);
        this.parameters.compareTerms(terms, context2);
        const variables = (0, _procedure.variablesFromTermsAndParameters)(terms, this.parameters, context2), term = await this.returnBlock.evaluate(variables, context2), termType = term.getType();
        if (this.type !== termType) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type is not equal to the '${anonymousProcedureString}' anonymous procedure's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...called the '${anonymousProcedureString}' anonymous procedure.`);
        return term;
      }
    }, __publicField(_a, "name", "AnonymousProcedure"), _a));
  });

  // lib/element/assignment/variable.js
  var require_variable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, expression) {
        super(context2, string, node);
        this.variable = variable;
        this.expression = expression;
      }
      getVariable() {
        return this.variable;
      }
      getExpression() {
        return this.expression;
      }
      async evaluate(context2) {
        let term;
        const variableAssignmentString = this.getString();
        context2.trace(`Evaluating the '${variableAssignmentString}' variable assignment...`);
        term = await this.expression.evaluate(context2);
        this.variable.assign(term, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${variableAssignmentString}' variable assignment as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "VariableAssignment"), _a));
  });

  // lib/element/assignments/variable.js
  var require_variable3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var {asyncForEach} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      async evaluate(context2) {
        await this.break(context2);
        const variableAssignmentsString = this.getString();
        context2.trace(`Evaluating the '${variableAssignmentsString}' variable assignments...`);
        await asyncForEach(this.array, async (variableAssignment) => {
          await variableAssignment.evaluate(context2);
        });
        context2.debug(`...evaluated the '${variableAssignmentsString}' variable assignments.`);
      }
    }, __publicField(_a, "name", "VariableAssignments"), _a));
  });

  // lib/element/declaration/procedure.js
  var require_procedure2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, procedure) {
        super(context2, string, node);
        this.string = string;
        this.procedure = procedure;
      }
      getProcedure() {
        return this.procedure;
      }
      verify(context2) {
        const verifies = true;
        const procedureDeclarationString = this.getString();
        context2.trace(`Verifying the '${procedureDeclarationString}' procedure declaration...`);
        const procedure = this.getProcedure();
        context2.addProcedure(procedure);
        if (verifies) {
          context2.debug(`...verified the '${procedureDeclarationString}' procedure declaration.`);
        }
        return verifies;
      }
    }, __publicField(_a, "name", "ProcedureDeclaration"), _a));
  });

  // lib/preamble.js
  var require_preamble = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _step = /* @__PURE__ */ _interop_require_default(require_step());
    var _some = /* @__PURE__ */ _interop_require_default(require_some());
    var _term = /* @__PURE__ */ _interop_require_default(require_term2());
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms());
    var _label = /* @__PURE__ */ _interop_require_default(require_label());
    var _error = /* @__PURE__ */ _interop_require_default(require_error4());
    var _every = /* @__PURE__ */ _interop_require_default(require_every());
    var _reduce = /* @__PURE__ */ _interop_require_default(require_reduce());
    var _ternary = /* @__PURE__ */ _interop_require_default(require_ternary());
    var _variable = /* @__PURE__ */ _interop_require_default(require_variable());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive2());
    var _reference = /* @__PURE__ */ _interop_require_default(require_reference2());
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure());
    var _nodeQuery = /* @__PURE__ */ _interop_require_default(require_nodeQuery());
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter());
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters());
    var _nodesQuery = /* @__PURE__ */ _interop_require_default(require_nodesQuery());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression2());
    var _returnBlock = /* @__PURE__ */ _interop_require_default(require_returnBlock());
    var _negated = /* @__PURE__ */ _interop_require_default(require_negated());
    var _logical = /* @__PURE__ */ _interop_require_default(require_logical());
    var _bracketed = /* @__PURE__ */ _interop_require_default(require_bracketed());
    var _procedureCall = /* @__PURE__ */ _interop_require_default(require_procedureCall());
    var _comparison = /* @__PURE__ */ _interop_require_default(require_comparison());
    var _named = /* @__PURE__ */ _interop_require_default(require_named());
    var _array = /* @__PURE__ */ _interop_require_default(require_array4());
    var _return = /* @__PURE__ */ _interop_require_default(require_return());
    var _named1 = /* @__PURE__ */ _interop_require_default(require_named2());
    var _object = /* @__PURE__ */ _interop_require_default(require_object2());
    var _anonymous = /* @__PURE__ */ _interop_require_default(require_anonymous());
    var _variable1 = /* @__PURE__ */ _interop_require_default(require_variable2());
    var _variable2 = /* @__PURE__ */ _interop_require_default(require_variable3());
    var _procedure1 = /* @__PURE__ */ _interop_require_default(require_procedure2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/furtle/lexer.js
  var require_lexer14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleLexer;
      }
    });
    var _occamgrammars = require_lib11();
    var FurtleLexer = class extends _occamgrammars.FurtleLexer {
    };
  });

  // lib/ruleNames.js
  var require_ruleNames5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ANONYMOUS_PROCEDURE_RULE_NAME() {
        return ANONYMOUS_PROCEDURE_RULE_NAME;
      },
      get ARRAY_ASSIGNMENT_RULE_NAME() {
        return ARRAY_ASSIGNMENT_RULE_NAME;
      },
      get BRACKETED_TERM_RULE_NAME() {
        return BRACKETED_TERM_RULE_NAME;
      },
      get COMPARISON_TERM_RULE_NAME() {
        return COMPARISON_TERM_RULE_NAME;
      },
      get DOCUMENT_RULE_NAME() {
        return DOCUMENT_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get EVERY_RULE_NAME() {
        return EVERY_RULE_NAME;
      },
      get EXPRESSION_RULE_NAME() {
        return EXPRESSION_RULE_NAME;
      },
      get LABEL_RULE_NAME() {
        return LABEL_RULE_NAME;
      },
      get LOGICAL_TERM_RULE_NAME() {
        return LOGICAL_TERM_RULE_NAME;
      },
      get NAMED_PARAMETERS_RULE_NAME() {
        return NAMED_PARAMETERS_RULE_NAME;
      },
      get NAMED_PARAMETER_RULE_NAME() {
        return NAMED_PARAMETER_RULE_NAME;
      },
      get NEGATED_TERM_RULE_NAME() {
        return NEGATED_TERM_RULE_NAME;
      },
      get NODES_QUERY_RULE_NAME() {
        return NODES_QUERY_RULE_NAME;
      },
      get NODE_QUERY_RULE_NAME() {
        return NODE_QUERY_RULE_NAME;
      },
      get NONSENSE_RULE_NAME() {
        return NONSENSE_RULE_NAME;
      },
      get OBJECT_ASSIGNMENT_RULE_NAME() {
        return OBJECT_ASSIGNMENT_RULE_NAME;
      },
      get PARAMETERS_RULE_NAME() {
        return PARAMETERS_RULE_NAME;
      },
      get PARAMETER_RULE_NAME() {
        return PARAMETER_RULE_NAME;
      },
      get PRIMITIVE_RULE_NAME() {
        return PRIMITIVE_RULE_NAME;
      },
      get PROCEDURE_CALL_RULE_NAME() {
        return PROCEDURE_CALL_RULE_NAME;
      },
      get PROCEDURE_DECLARATION_RULE_NAME() {
        return PROCEDURE_DECLARATION_RULE_NAME;
      },
      get REDUCE_RULE_NAME() {
        return REDUCE_RULE_NAME;
      },
      get REFERENCE_RULE_NAME() {
        return REFERENCE_RULE_NAME;
      },
      get RETURN_BLOCK_RULE_NAME() {
        return RETURN_BLOCK_RULE_NAME;
      },
      get RETURN_STATEMENT_RULE_NAME() {
        return RETURN_STATEMENT_RULE_NAME;
      },
      get SOME_RULE_NAME() {
        return SOME_RULE_NAME;
      },
      get STEP_RULE_NAME() {
        return STEP_RULE_NAME;
      },
      get TERMS_RULE_NAME() {
        return TERMS_RULE_NAME;
      },
      get TERM_RULE_NAME() {
        return TERM_RULE_NAME;
      },
      get TERNARY_RULE_NAME() {
        return TERNARY_RULE_NAME;
      },
      get VARIABLE_ASSIGNMENTS_RULE_NAME() {
        return VARIABLE_ASSIGNMENTS_RULE_NAME;
      },
      get VARIABLE_ASSIGNMENT_RULE_NAME() {
        return VARIABLE_ASSIGNMENT_RULE_NAME;
      },
      get VARIABLE_RULE_NAME() {
        return VARIABLE_RULE_NAME;
      }
    });
    var STEP_RULE_NAME = "step";
    var SOME_RULE_NAME = "some";
    var TERM_RULE_NAME = "term";
    var TERMS_RULE_NAME = "terms";
    var EVERY_RULE_NAME = "every";
    var LABEL_RULE_NAME = "label";
    var ERROR_RULE_NAME = "error";
    var REDUCE_RULE_NAME = "reduce";
    var TERNARY_RULE_NAME = "ternary";
    var VARIABLE_RULE_NAME = "variable";
    var NONSENSE_RULE_NAME = "nonsense";
    var DOCUMENT_RULE_NAME = "document";
    var PRIMITIVE_RULE_NAME = "primitive";
    var REFERENCE_RULE_NAME = "reference";
    var PARAMETER_RULE_NAME = "parameter";
    var NODE_QUERY_RULE_NAME = "nodeQuery";
    var EXPRESSION_RULE_NAME = "expression";
    var PARAMETERS_RULE_NAME = "parameters";
    var NODES_QUERY_RULE_NAME = "nodesQuery";
    var RETURN_BLOCK_RULE_NAME = "returnBlock";
    var LOGICAL_TERM_RULE_NAME = "logicalTerm";
    var NEGATED_TERM_RULE_NAME = "negatedTerm";
    var BRACKETED_TERM_RULE_NAME = "bracketedTerm";
    var PROCEDURE_CALL_RULE_NAME = "procedureCall";
    var COMPARISON_TERM_RULE_NAME = "comparisonTerm";
    var NAMED_PARAMETER_RULE_NAME = "namedParameter";
    var NAMED_PARAMETERS_RULE_NAME = "namedParameters";
    var RETURN_STATEMENT_RULE_NAME = "returnStatement";
    var ARRAY_ASSIGNMENT_RULE_NAME = "arrayAssignment";
    var OBJECT_ASSIGNMENT_RULE_NAME = "objectAssignment";
    var VARIABLE_ASSIGNMENT_RULE_NAME = "variableAssignment";
    var ANONYMOUS_PROCEDURE_RULE_NAME = "anonymousProcedure";
    var VARIABLE_ASSIGNMENTS_RULE_NAME = "variableAssignments";
    var PROCEDURE_DECLARATION_RULE_NAME = "procedureDeclaration";
  });

  // lib/node/step.js
  var require_step2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StepNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var StepNode = class extends _occamlanguages.NonTerminalNode {
      getArrayAssignmentNode() {
        const ruleName = _ruleNames.ARRAY_ASSIGNMENT_RULE_NAME, arrayAssignmentNode = this.getNodeByRuleName(ruleName);
        return arrayAssignmentNode;
      }
      getObjectAssignmentNode() {
        const ruleName = _ruleNames.OBJECT_ASSIGNMENT_RULE_NAME, objectAssignmentNode = this.getNodeByRuleName(ruleName);
        return objectAssignmentNode;
      }
      getVariableAssignmentsNode() {
        const ruleName = _ruleNames.VARIABLE_ASSIGNMENTS_RULE_NAME, variableAssignmentsNode = this.getNodeByRuleName(ruleName);
        return variableAssignmentsNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(StepNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/some.js
  var require_some2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SomeNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var SomeNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variabloeNode = this.getNodeByRuleName(ruleName);
        return variabloeNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(SomeNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term.js
  var require_term3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TermNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var TermNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getPrimitiveNode() {
        const ruleName = _ruleNames.PRIMITIVE_RULE_NAME, primitiveNode = this.getNodeByRuleName(ruleName);
        return primitiveNode;
      }
      getNegatedTermNode() {
        const ruleName = _ruleNames.NEGATED_TERM_RULE_NAME, negatedTermNode = this.getNodeByRuleName(ruleName);
        return negatedTermNode;
      }
      getLogicalTermNode() {
        const ruleName = _ruleNames.LOGICAL_TERM_RULE_NAME, logicalTermRuleName = this.getNodeByRuleName(ruleName);
        return logicalTermRuleName;
      }
      getBracketedTermNode() {
        const ruleName = _ruleNames.BRACKETED_TERM_RULE_NAME, bracketedTermRuleName = this.getNodeByRuleName(ruleName);
        return bracketedTermRuleName;
      }
      getComparisonTermNode() {
        const ruleName = _ruleNames.COMPARISON_TERM_RULE_NAME, comparisonNode = this.getNodeByRuleName(ruleName);
        return comparisonNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = TermNode;
        }
        const termNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return termNode;
      }
    };
  });

  // lib/node/terms.js
  var require_terms2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TermNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var TermNode = class extends _occamlanguages.NonTerminalNode {
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(TermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/every.js
  var require_every2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EveryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var EveryNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(EveryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/tokenTypes.js
  var require_tokenTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN_TOKEN_TYPE() {
        return BOOLEAN_TOKEN_TYPE;
      },
      get NAME_TOKEN_TYPE() {
        return NAME_TOKEN_TYPE;
      },
      get NULL_TOKEN_TYPE() {
        return NULL_TOKEN_TYPE;
      },
      get NUMBER_TOKEN_TYPE() {
        return NUMBER_TOKEN_TYPE;
      },
      get SPECIAL_TOKEN_TYPE() {
        return SPECIAL_TOKEN_TYPE;
      },
      get STRING_LITERAL_TOKEN_TYPE() {
        return STRING_LITERAL_TOKEN_TYPE;
      },
      get TYPE_TOKEN_TYPE() {
        return TYPE_TOKEN_TYPE;
      }
    });
    var TYPE_TOKEN_TYPE = "type";
    var NAME_TOKEN_TYPE = "name";
    var NULL_TOKEN_TYPE = "null";
    var NUMBER_TOKEN_TYPE = "number";
    var SPECIAL_TOKEN_TYPE = "special";
    var BOOLEAN_TOKEN_TYPE = "boolean";
    var STRING_LITERAL_TOKEN_TYPE = "string-literal";
  });

  // lib/node/label.js
  var require_label2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LabelNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var LabelNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(LabelNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/error.js
  var require_error5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorNode;
      }
    });
    var _occamlanguages = require_lib14();
    var ErrorNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ErrorNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/reduce.js
  var require_reduce2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReduceNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ReduceNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getExpressionNode() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNode = this.getNodeByRuleName(ruleName);
        return expressionNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReduceNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/ternary.js
  var require_ternary2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TernaryNode;
      }
    });
    var _necessary = require_browser();
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var {first: first2, second} = _necessary.arrayUtilities;
    var TernaryNode = class extends _occamlanguages.NonTerminalNode {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      getExpressionNodes() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNodes = this.getNodesByRuleName(ruleName);
        return expressionNodes;
      }
      getIfExpressionNode() {
        const firstExpressionNode = this.getFirstExpressionNode(), ifExpressionNode = firstExpressionNode;
        return ifExpressionNode;
      }
      getElseExpressionNode() {
        const secondExpressionNode = this.getSecondExpressionNode(), elseExpressionNode = secondExpressionNode;
        return elseExpressionNode;
      }
      getFirstExpressionNode() {
        const expressionNodes = this.getExpressionNodes(), firstExpressionNode = first2(expressionNodes);
        return firstExpressionNode;
      }
      getSecondExpressionNode() {
        const expressionNodes = this.getExpressionNodes(), secondExpressionNode = second(expressionNodes);
        return secondExpressionNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(TernaryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/document.js
  var require_document5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentNode;
      }
    });
    var _occamlanguages = require_lib14();
    var DocumentNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(DocumentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/variable.js
  var require_variable4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var VariableNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(VariableNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/nonsense.js
  var require_nonsense = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonsenseNode;
      }
    });
    var _occamlanguages = require_lib14();
    var NonsenseNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NonsenseNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/primitive.js
  var require_primitive3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrimitiveNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _constants = require_constants13();
    var _types = require_types3();
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrimitiveNode = class extends _occamlanguages.NonTerminalNode {
      getType() {
        let type;
        const node = this.getNode(), number = this.getNumber(), boolean = this.getBoolean(), stringLiteral = this.getStringLiteral();
        if (false) {
        } else if (node !== null) {
          type = _types.NODE_TYPE;
        } else if (number !== null) {
          type = _types.NUMBER_TYPE;
        } else if (boolean !== null) {
          type = _types.BOOLEAN_TYPE;
        } else if (stringLiteral !== null) {
          type = _types.STRING_TYPE;
        }
        return type;
      }
      getValue() {
        let value;
        const node = this.getNode(), number = this.getNumber(), boolean = this.getBoolean(), stringLiteral = this.getStringLiteral();
        if (false) {
        } else if (node !== null) {
          value = node;
        } else if (number !== null) {
          value = number;
        } else if (boolean !== null) {
          value = boolean;
        } else if (stringLiteral !== null) {
          value = stringLiteral;
        }
        return value;
      }
      getNode() {
        let node = null;
        const tokenType = _tokenTypes.NULL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.NULL) {
            node = _nullNode.default;
            return true;
          }
        }, tokenType);
        return node;
      }
      getNumber() {
        let number = null;
        const tokenType = _tokenTypes.NUMBER_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.TRUE) {
            number = Number(content);
            return true;
          }
        }, tokenType);
        return number;
      }
      getBoolean() {
        let boolean = null;
        const tokenType = _tokenTypes.BOOLEAN_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.TRUE) {
            boolean = true;
            return true;
          }
          if (content === _constants.FALSE) {
            boolean = false;
            return true;
          }
        }, tokenType);
        return boolean;
      }
      getStringLiteral() {
        let stringLiteral = null;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(PrimitiveNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/reference.js
  var require_reference3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReferenceNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var ReferenceNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReferenceNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameter.js
  var require_parameter2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParamterNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var ParamterNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name = null;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      getType() {
        let type = null;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
          return true;
        }, tokenType);
        return type;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = ParamterNode;
        }
        const parameterNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return parameterNode;
      }
    };
  });

  // lib/node/nodeQuery.js
  var require_nodeQuery2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodeQueryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var _stringLiteral = require_stringLiteral6();
    var _tokenTypes = require_tokenTypes();
    var NodeQueryNode = class extends _occamlanguages.NonTerminalNode {
      getString() {
        const stringLiteral = this.getStringLiteral(), string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral);
        return string;
      }
      getStringLiteral() {
        let stringLiteral;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NodeQueryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/expression.js
  var require_expression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ExpressionNode = class extends _occamlanguages.NonTerminalNode {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      getSomeNode() {
        const ruleName = _ruleNames.SOME_RULE_NAME, someNode = this.getNodeByRuleName(ruleName);
        return someNode;
      }
      getEveryNode() {
        const ruleName = _ruleNames.EVERY_RULE_NAME, everyNode = this.getNodeByRuleName(ruleName);
        return everyNode;
      }
      getReduceNode() {
        const ruleName = _ruleNames.REDUCE_RULE_NAME, reduceNode = this.getNodeByRuleName(ruleName);
        return reduceNode;
      }
      getTernaryNode() {
        const ruleName = _ruleNames.TERNARY_RULE_NAME, ternaryNode = this.getNodeByRuleName(ruleName);
        return ternaryNode;
      }
      getNodeQueryNode() {
        const ruleName = _ruleNames.NODE_QUERY_RULE_NAME, nodeQueryNode = this.getNodeByRuleName(ruleName);
        return nodeQueryNode;
      }
      getNodesQueryNode() {
        const ruleName = _ruleNames.NODES_QUERY_RULE_NAME, nodeSQueryNode = this.getNodeByRuleName(ruleName);
        return nodeSQueryNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      getProcedureCallNode() {
        const ruleName = _ruleNames.PROCEDURE_CALL_RULE_NAME, procedureCallNode = this.getNodeByRuleName(ruleName);
        return procedureCallNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ExpressionNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameters.js
  var require_parameters2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParamtersNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ParamtersNode = class extends _occamlanguages.NonTerminalNode {
      getParameterNodes() {
        const ruleName = _ruleNames.PARAMETER_RULE_NAME, parameterNodes = this.getNodesByRuleName(ruleName);
        return parameterNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = ParamtersNode;
        }
        const parametersNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return parametersNode;
      }
    };
  });

  // lib/node/nodesQuery.js
  var require_nodesQuery2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodesQueryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var _stringLiteral = require_stringLiteral6();
    var _tokenTypes = require_tokenTypes();
    var NodesQueryNode = class extends _occamlanguages.NonTerminalNode {
      getString() {
        const stringLiteral = this.getStringLiteral(), string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral);
        return string;
      }
      getStringLiteral() {
        let stringLiteral = null;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NodesQueryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/returnBlock.js
  var require_returnBlock2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReturnBlockNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ReturnBlockNode = class extends _occamlanguages.NonTerminalNode {
      isNonsensical() {
        const nonsenseNodes = this.getNonsenseNodes(), nonsenseNodesLength = nonsenseNodes.length, nonsensical = nonsenseNodesLength > 0;
        return nonsensical;
      }
      getStepNodes() {
        const ruleName = _ruleNames.STEP_RULE_NAME, stepNodes = this.getNodesByRuleName(ruleName);
        return stepNodes;
      }
      getNonsenseNodes() {
        const ruleName = _ruleNames.NONSENSE_RULE_NAME, nonsenseNodes = this.getNodesByRuleName(ruleName);
        return nonsenseNodes;
      }
      getReturnStatementNode() {
        const ruleName = _ruleNames.RETURN_STATEMENT_RULE_NAME, returnStatement = this.getNodeByRuleName(ruleName);
        return returnStatement;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReturnBlockNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/logical.js
  var require_logical2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LogicalTermNode;
      }
    });
    var _necessary = require_browser();
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    var _tokenTypes = require_tokenTypes();
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, last} = _necessary.arrayUtilities;
    var LogicalTermNode = class extends _term.default {
      getOperator() {
        let operator = null;
        const tokenType = _tokenTypes.SPECIAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          operator = content;
          return true;
        }, tokenType);
        return operator;
      }
      isConjection() {
        const operator = this.getOperator(), conjection = operator === _constants.CONJUNCTION_OPERATOR;
        return conjection;
      }
      isDisjunction() {
        const operator = this.getOperator(), disjunction = operator === _constants.DISJUNCTION_OPERATOR;
        return disjunction;
      }
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      getLeftTermNode() {
        const firstExpresionNode = this.getFirstTermNode(), leftTermNode = firstExpresionNode;
        return leftTermNode;
      }
      getRightTermNode() {
        const lastTermNode = this.getLastTermNode(), rightTermNode = lastTermNode;
        return rightTermNode;
      }
      getLastTermNode() {
        const termNodes = this.getTermNodes(), lastTermNode = last(termNodes);
        return lastTermNode;
      }
      getFirstTermNode() {
        const termNodes = this.getTermNodes(), firstTermNode = first2(termNodes);
        return firstTermNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(LogicalTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/negated.js
  var require_negated2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NegatedTermNode;
      }
    });
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NegatedTermNode = class extends _term.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(NegatedTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedureCall.js
  var require_procedureCall2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureCallNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ProcedureCallNode = class extends _occamlanguages.NonTerminalNode {
      getTermsNode() {
        const ruleName = _ruleNames.TERMS_RULE_NAME, termsNode = this.getNodeByRuleName(ruleName);
        return termsNode;
      }
      getReferenceNode() {
        const ruleName = _ruleNames.REFERENCE_RULE_NAME, referenceNode = this.getNodeByRuleName(ruleName);
        return referenceNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ProcedureCallNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/bracketed.js
  var require_bracketed2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BracketedTermNode;
      }
    });
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BracketedTermNode = class extends _term.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(BracketedTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/comparison.js
  var require_comparison2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ComparisonTermNode;
      }
    });
    var _necessary = require_browser();
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _constants = require_constants13();
    var _ruleNames = require_ruleNames5();
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var ComparisonTermNode = class extends _term.default {
      isNegated() {
        let negated = false;
        const tokenType = _tokenTypes.SPECIAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.NOT_EQUAL_TO) {
            negated = true;
          }
          return true;
        }, tokenType);
        return negated;
      }
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      getLeftTermNode() {
        const firstTermNode = this.getFirstTermNode(), leftTermNode = firstTermNode;
        return leftTermNode;
      }
      getRightTermNode() {
        const secondTermNode = this.getSecondTermNode(), rightTermNode = secondTermNode;
        return rightTermNode;
      }
      getFirstTermNode() {
        const termNodes = this.getTermNodes(), firstTermNode = first2(termNodes);
        return firstTermNode;
      }
      getSecondTermNode() {
        const termNodes = this.getTermNodes(), secondTermNode = second(termNodes);
        return secondTermNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(ComparisonTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameter/named.js
  var require_named3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NamedParamterNode;
      }
    });
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter2());
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NamedParamterNode = class extends _parameter.default {
      getAlias() {
        let alias = null;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode, index) => {
          if (index === 3) {
            const content = terminalNode.getContent();
            alias = content;
            return true;
          }
        }, tokenType);
        return alias;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _parameter.default.fromRuleNameChildNodesOpacityAndPrecedence(NamedParamterNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameters/named.js
  var require_named4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NamedParamtersNode;
      }
    });
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters2());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NamedParamtersNode = class extends _parameters.default {
      getNamedParameterNodes() {
        const ruleName = _ruleNames.NAMED_PARAMETER_RULE_NAME, namedParamterNodes = this.getNodesByRuleName(ruleName);
        return namedParamterNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _parameters.default.fromRuleNameChildNodesOpacityAndPrecedence(NamedParamtersNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/statement.js
  var require_statement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StatementNode;
      }
    });
    var _occamlanguages = require_lib14();
    var StatementNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/statement/return.js
  var require_return2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReturnStatementNode;
      }
    });
    var _statement = /* @__PURE__ */ _interop_require_default(require_statement());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ReturnStatementNode = class extends _statement.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _statement.default.fromRuleNameChildNodesOpacityAndPrecedence(ReturnStatementNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment.js
  var require_assignment = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AssignmentrNode;
      }
    });
    var _occamlanguages = require_lib14();
    var AssignmentrNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/array.js
  var require_array5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ArrayAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ArrayAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(ArrayAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/object.js
  var require_object3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ObjectAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ObjectAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getNamedParametersNode() {
        const ruleName = _ruleNames.NAMED_PARAMETERS_RULE_NAME, namedParametersNode = this.getNodeByRuleName(ruleName);
        return namedParametersNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(ObjectAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedure.js
  var require_procedure3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureNode;
      }
    });
    var _occamlanguages = require_lib14();
    var ProcedureNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedure/anoymous.js
  var require_anoymous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AnonymousProcedureNode;
      }
    });
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure3());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AnonymousProcedureNode = class extends _procedure.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _procedure.default.fromRuleNameChildNodesOpacityAndPrecedence(AnonymousProcedureNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/variable.js
  var require_variable5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VariableAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getExpressionNode() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNode = this.getNodeByRuleName(ruleName);
        return expressionNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(VariableAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignments/variable.js
  var require_variable6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableAssignmentsNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VariableAssignmentsNode = class extends _assignment.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getVariableAssignmentNodes() {
        const ruleName = _ruleNames.VARIABLE_ASSIGNMENT_RULE_NAME, variableAssingnmentNodss = this.getNodesByRuleName(ruleName);
        return variableAssingnmentNodss;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(VariableAssignmentsNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/declaration.js
  var require_declaration2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DeclarationNode;
      }
    });
    var _occamlanguages = require_lib14();
    var DeclarationNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/declaration/procedure.js
  var require_procedure4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureDeclarationNode;
      }
    });
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration2());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ProcedureDeclarationNode = class extends _declaration.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getLabelNode() {
        const ruleName = _ruleNames.LABEL_RULE_NAME, labelNode = this.getNodeByRuleName(ruleName);
        return labelNode;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _declaration.default.fromRuleNameChildNodesOpacityAndPrecedence(ProcedureDeclarationNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _step = /* @__PURE__ */ _interop_require_default(require_step2());
    var _some = /* @__PURE__ */ _interop_require_default(require_some2());
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms2());
    var _every = /* @__PURE__ */ _interop_require_default(require_every2());
    var _label = /* @__PURE__ */ _interop_require_default(require_label2());
    var _error = /* @__PURE__ */ _interop_require_default(require_error5());
    var _reduce = /* @__PURE__ */ _interop_require_default(require_reduce2());
    var _ternary = /* @__PURE__ */ _interop_require_default(require_ternary2());
    var _document = /* @__PURE__ */ _interop_require_default(require_document5());
    var _variable = /* @__PURE__ */ _interop_require_default(require_variable4());
    var _nonsense = /* @__PURE__ */ _interop_require_default(require_nonsense());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive3());
    var _reference = /* @__PURE__ */ _interop_require_default(require_reference3());
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter2());
    var _nodeQuery = /* @__PURE__ */ _interop_require_default(require_nodeQuery2());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression3());
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters2());
    var _nodesQuery = /* @__PURE__ */ _interop_require_default(require_nodesQuery2());
    var _returnBlock = /* @__PURE__ */ _interop_require_default(require_returnBlock2());
    var _logical = /* @__PURE__ */ _interop_require_default(require_logical2());
    var _negated = /* @__PURE__ */ _interop_require_default(require_negated2());
    var _procedureCall = /* @__PURE__ */ _interop_require_default(require_procedureCall2());
    var _bracketed = /* @__PURE__ */ _interop_require_default(require_bracketed2());
    var _comparison = /* @__PURE__ */ _interop_require_default(require_comparison2());
    var _named = /* @__PURE__ */ _interop_require_default(require_named3());
    var _named1 = /* @__PURE__ */ _interop_require_default(require_named4());
    var _return = /* @__PURE__ */ _interop_require_default(require_return2());
    var _array = /* @__PURE__ */ _interop_require_default(require_array5());
    var _object = /* @__PURE__ */ _interop_require_default(require_object3());
    var _anoymous = /* @__PURE__ */ _interop_require_default(require_anoymous());
    var _variable1 = /* @__PURE__ */ _interop_require_default(require_variable5());
    var _variable2 = /* @__PURE__ */ _interop_require_default(require_variable6());
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure4());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeMap = {
      [_ruleNames.STEP_RULE_NAME]: _step.default,
      [_ruleNames.SOME_RULE_NAME]: _some.default,
      [_ruleNames.TERM_RULE_NAME]: _term.default,
      [_ruleNames.TERMS_RULE_NAME]: _terms.default,
      [_ruleNames.EVERY_RULE_NAME]: _every.default,
      [_ruleNames.LABEL_RULE_NAME]: _label.default,
      [_ruleNames.ERROR_RULE_NAME]: _error.default,
      [_ruleNames.REDUCE_RULE_NAME]: _reduce.default,
      [_ruleNames.TERNARY_RULE_NAME]: _ternary.default,
      [_ruleNames.VARIABLE_RULE_NAME]: _variable.default,
      [_ruleNames.NONSENSE_RULE_NAME]: _nonsense.default,
      [_ruleNames.DOCUMENT_RULE_NAME]: _document.default,
      [_ruleNames.PRIMITIVE_RULE_NAME]: _primitive.default,
      [_ruleNames.REFERENCE_RULE_NAME]: _reference.default,
      [_ruleNames.PARAMETER_RULE_NAME]: _parameter.default,
      [_ruleNames.NODE_QUERY_RULE_NAME]: _nodeQuery.default,
      [_ruleNames.EXPRESSION_RULE_NAME]: _expression.default,
      [_ruleNames.PARAMETERS_RULE_NAME]: _parameters.default,
      [_ruleNames.NODES_QUERY_RULE_NAME]: _nodesQuery.default,
      [_ruleNames.RETURN_BLOCK_RULE_NAME]: _returnBlock.default,
      [_ruleNames.LOGICAL_TERM_RULE_NAME]: _logical.default,
      [_ruleNames.NEGATED_TERM_RULE_NAME]: _negated.default,
      [_ruleNames.PROCEDURE_CALL_RULE_NAME]: _procedureCall.default,
      [_ruleNames.BRACKETED_TERM_RULE_NAME]: _bracketed.default,
      [_ruleNames.COMPARISON_TERM_RULE_NAME]: _comparison.default,
      [_ruleNames.NAMED_PARAMETER_RULE_NAME]: _named.default,
      [_ruleNames.NAMED_PARAMETERS_RULE_NAME]: _named1.default,
      [_ruleNames.RETURN_STATEMENT_RULE_NAME]: _return.default,
      [_ruleNames.ARRAY_ASSIGNMENT_RULE_NAME]: _array.default,
      [_ruleNames.OBJECT_ASSIGNMENT_RULE_NAME]: _object.default,
      [_ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME]: _anoymous.default,
      [_ruleNames.VARIABLE_ASSIGNMENT_RULE_NAME]: _variable1.default,
      [_ruleNames.VARIABLE_ASSIGNMENTS_RULE_NAME]: _variable2.default,
      [_ruleNames.PROCEDURE_DECLARATION_RULE_NAME]: _procedure.default
    };
    var _default = NonTerminalNodeMap;
  });

  // lib/furtle/parser.js
  var require_parser15 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleParser;
      }
    });
    var _occamlanguages = require_lib14();
    var _occamgrammars = require_lib11();
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap3());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FurtleParser = class extends _occamgrammars.FurtleParser {
    };
    __publicField(FurtleParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
    __publicField(FurtleParser, "defaultNonTerminalNode", _occamlanguages.NonTerminalNode);
  });

  // lib/utilities/element.js
  var require_element5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get aliasFromNamedParameterNode() {
        return aliasFromNamedParameterNode;
      },
      get anonymousProcedureFromAnonymousProcedureNode() {
        return anonymousProcedureFromAnonymousProcedureNode;
      },
      get anonymousProcedureFromEveryNode() {
        return anonymousProcedureFromEveryNode;
      },
      get anonymousProcedureFromReduceNode() {
        return anonymousProcedureFromReduceNode;
      },
      get anonymousProcedureFromSomeNode() {
        return anonymousProcedureFromSomeNode;
      },
      get arrayAssignmentFromArrayAssignmentNode() {
        return arrayAssignmentFromArrayAssignmentNode;
      },
      get arrayAssignmentFromStepNode() {
        return arrayAssignmentFromStepNode;
      },
      get bracketedTermFromBracketedTermNode() {
        return bracketedTermFromBracketedTermNode;
      },
      get bracketedTermFromTermNode() {
        return bracketedTermFromTermNode;
      },
      get comparisonTermFromComparisonTermNode() {
        return comparisonTermFromComparisonTermNode;
      },
      get comparisonTermFromTermNode() {
        return comparisonTermFromTermNode;
      },
      get disjunctionFromLogicalTermNode() {
        return disjunctionFromLogicalTermNode;
      },
      get elseExpressionFromTernaryNode() {
        return elseExpressionFromTernaryNode;
      },
      get errorFromErrorNode() {
        return errorFromErrorNode;
      },
      get everyFromEveryNode() {
        return everyFromEveryNode;
      },
      get everyFromExpressionNode() {
        return everyFromExpressionNode;
      },
      get expressionFromExpressionNode() {
        return expressionFromExpressionNode;
      },
      get expressionFromReduceNode() {
        return expressionFromReduceNode;
      },
      get expressionFromTypeAndVariableNode() {
        return expressionFromTypeAndVariableNode;
      },
      get expressionFromVariableAssignmentNode() {
        return expressionFromVariableAssignmentNode;
      },
      get expressionFromVariableNode() {
        return expressionFromVariableNode;
      },
      get ifExpressionFromTernaryNode() {
        return ifExpressionFromTernaryNode;
      },
      get initialExpressionFromReduceNode() {
        return initialExpressionFromReduceNode;
      },
      get labelFromLabelNode() {
        return labelFromLabelNode;
      },
      get labelFromProcedureDeclarationNode() {
        return labelFromProcedureDeclarationNode;
      },
      get leftTermFromCompzrisonTermNode() {
        return leftTermFromCompzrisonTermNode;
      },
      get leftTermFromLogicalTermNode() {
        return leftTermFromLogicalTermNode;
      },
      get logicalTermFromLogicalTermNode() {
        return logicalTermFromLogicalTermNode;
      },
      get logicalTermFromTermNode() {
        return logicalTermFromTermNode;
      },
      get nameFromLabelNode() {
        return nameFromLabelNode;
      },
      get nameFromNamedParameterNode() {
        return nameFromNamedParameterNode;
      },
      get nameFromParaneterNode() {
        return nameFromParaneterNode;
      },
      get nameFromReferenceNode() {
        return nameFromReferenceNode;
      },
      get nameFromVariableNode() {
        return nameFromVariableNode;
      },
      get namedParameterFromNamedParameterNode() {
        return namedParameterFromNamedParameterNode;
      },
      get namedParametersFromNamedParametersNode() {
        return namedParametersFromNamedParametersNode;
      },
      get namedParametersFromObjectAssignmentNode() {
        return namedParametersFromObjectAssignmentNode;
      },
      get namedParamtersArrayFromNamedParameterNodes() {
        return namedParamtersArrayFromNamedParameterNodes;
      },
      get negatedFromComparisonTermNode() {
        return negatedFromComparisonTermNode;
      },
      get negatedTermFromNegatedTermNode() {
        return negatedTermFromNegatedTermNode;
      },
      get negatedTermFromTermNode() {
        return negatedTermFromTermNode;
      },
      get nodeQueryFromExpressionNode() {
        return nodeQueryFromExpressionNode;
      },
      get nodeQueryFromNodeQueryNode() {
        return nodeQueryFromNodeQueryNode;
      },
      get nodesQueryFromExpressionNode() {
        return nodesQueryFromExpressionNode;
      },
      get nodesQueryFromNodesQueryNode() {
        return nodesQueryFromNodesQueryNode;
      },
      get nonsensicalFromReturnBlockNode() {
        return nonsensicalFromReturnBlockNode;
      },
      get objectAssignmentFromObjectAssignmentNode() {
        return objectAssignmentFromObjectAssignmentNode;
      },
      get objectAssignmentFromStepNode() {
        return objectAssignmentFromStepNode;
      },
      get parameterFromParameterNode() {
        return parameterFromParameterNode;
      },
      get parametersFromAnonymousProcedureNode() {
        return parametersFromAnonymousProcedureNode;
      },
      get parametersFromArrayAssignmentNode() {
        return parametersFromArrayAssignmentNode;
      },
      get parametersFromParametersNode() {
        return parametersFromParametersNode;
      },
      get parametersFromProcedureDeclarationNode() {
        return parametersFromProcedureDeclarationNode;
      },
      get paramtersArrayFromParametersNode() {
        return paramtersArrayFromParametersNode;
      },
      get primitiveFromPrimitiveNode() {
        return primitiveFromPrimitiveNode;
      },
      get primitiveFromTermNode() {
        return primitiveFromTermNode;
      },
      get procedureCallFromExpressionNode() {
        return procedureCallFromExpressionNode;
      },
      get procedureCallFromProcedureCallNode() {
        return procedureCallFromProcedureCallNode;
      },
      get procedureDeclarationFromProcedureDeclarationNode() {
        return procedureDeclarationFromProcedureDeclarationNode;
      },
      get procedureFromProcedureDeclarationNode() {
        return procedureFromProcedureDeclarationNode;
      },
      get queryFromNodeQueryNode() {
        return queryFromNodeQueryNode;
      },
      get queryFromNodesQueryNode() {
        return queryFromNodesQueryNode;
      },
      get reduceFromExpressionNode() {
        return reduceFromExpressionNode;
      },
      get reduceFromReduceNode() {
        return reduceFromReduceNode;
      },
      get referenceFromProcedureCallNode() {
        return referenceFromProcedureCallNode;
      },
      get referenceFromReferenceNode() {
        return referenceFromReferenceNode;
      },
      get returnBlockFromAnonymousProcedureNode() {
        return returnBlockFromAnonymousProcedureNode;
      },
      get returnBlockFromExpressionNode() {
        return returnBlockFromExpressionNode;
      },
      get returnBlockFromProcedureDeclarationNode() {
        return returnBlockFromProcedureDeclarationNode;
      },
      get returnBlockFromReturnBlockNode() {
        return returnBlockFromReturnBlockNode;
      },
      get returnStatementFromReturnBlockNode() {
        return returnStatementFromReturnBlockNode;
      },
      get returnStatementFromReturnStatementNode() {
        return returnStatementFromReturnStatementNode;
      },
      get rightTermFromCompzrisonTermNode() {
        return rightTermFromCompzrisonTermNode;
      },
      get rightTermFromLogicalTermNode() {
        return rightTermFromLogicalTermNode;
      },
      get someFromExpressionNode() {
        return someFromExpressionNode;
      },
      get someFromSomeNode() {
        return someFromSomeNode;
      },
      get stepFromStepNode() {
        return stepFromStepNode;
      },
      get stepsFromReturnBlockNode() {
        return stepsFromReturnBlockNode;
      },
      get termFromBracketedTermNode() {
        return termFromBracketedTermNode;
      },
      get termFromExpressionNode() {
        return termFromExpressionNode;
      },
      get termFromNegatedTermNode() {
        return termFromNegatedTermNode;
      },
      get termFromReturnStatementNode() {
        return termFromReturnStatementNode;
      },
      get termFromTermNode() {
        return termFromTermNode;
      },
      get termFromTernaryNode() {
        return termFromTernaryNode;
      },
      get termsArrayFromTermNodes() {
        return termsArrayFromTermNodes;
      },
      get termsFromProcedureCallNode() {
        return termsFromProcedureCallNode;
      },
      get termsFromTermsNode() {
        return termsFromTermsNode;
      },
      get ternaryFromExpressionNode() {
        return ternaryFromExpressionNode;
      },
      get ternaryFromTernaryNode() {
        return ternaryFromTernaryNode;
      },
      get typeFromLogicalTermNode() {
        return typeFromLogicalTermNode;
      },
      get typeFromNamedParameterNode() {
        return typeFromNamedParameterNode;
      },
      get typeFromNegatedTermNode() {
        return typeFromNegatedTermNode;
      },
      get typeFromParaneterNode() {
        return typeFromParaneterNode;
      },
      get typeFromPrimitiveNode() {
        return typeFromPrimitiveNode;
      },
      get typeFromProcedureAnonymousProcedureNode() {
        return typeFromProcedureAnonymousProcedureNode;
      },
      get typeFromProcedureDeclarationNode() {
        return typeFromProcedureDeclarationNode;
      },
      get typeFromVariableAssignmentsNode() {
        return typeFromVariableAssignmentsNode;
      },
      get typeFromVariableNode() {
        return typeFromVariableNode;
      },
      get valueFromPrimitiveNode() {
        return valueFromPrimitiveNode;
      },
      get variableAssignmentFromTypeAndVariableAssignmentNode() {
        return variableAssignmentFromTypeAndVariableAssignmentNode;
      },
      get variableAssignmentsArrayFromTypeAndVariableAssignmentsNode() {
        return variableAssignmentsArrayFromTypeAndVariableAssignmentsNode;
      },
      get variableAssignmentsFromStepNode() {
        return variableAssignmentsFromStepNode;
      },
      get variableAssignmentsFromVariableAssignmentsNode() {
        return variableAssignmentsFromVariableAssignmentsNode;
      },
      get variableFromArrayAssignmentNode() {
        return variableFromArrayAssignmentNode;
      },
      get variableFromEveryNode() {
        return variableFromEveryNode;
      },
      get variableFromNodeQueryNode() {
        return variableFromNodeQueryNode;
      },
      get variableFromNodesQueryNode() {
        return variableFromNodesQueryNode;
      },
      get variableFromObjectAssignmentNode() {
        return variableFromObjectAssignmentNode;
      },
      get variableFromReduceNode() {
        return variableFromReduceNode;
      },
      get variableFromSomeNode() {
        return variableFromSomeNode;
      },
      get variableFromTermNode() {
        return variableFromTermNode;
      },
      get variableFromTypeAndVariableAssignmentNode() {
        return variableFromTypeAndVariableAssignmentNode;
      },
      get variableFromTypeAndVariableNode() {
        return variableFromTypeAndVariableNode;
      },
      get variableFromVariableNode() {
        return variableFromVariableNode;
      }
    });
    var _occamquery = require_lib5();
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _types = require_types3();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function stepFromStepNode(stepNode, context2) {
      const {Step} = _elements.default, node = stepNode, string = context2.nodeAsString(node), arrayAssignment = arrayAssignmentFromStepNode(stepNode, context2), objectAssigment = objectAssignmentFromStepNode(stepNode, context2), variablesDeclaration = variableAssignmentsFromStepNode(stepNode, context2);
      context2 = null;
      const step = new Step(context2, string, node, arrayAssignment, objectAssigment, variablesDeclaration);
      return step;
    }
    function someFromSomeNode(someNode, context2) {
      const {Some} = _elements.default, node = someNode, variable = variableFromSomeNode(someNode, context2), anonymousProcedure = anonymousProcedureFromSomeNode(someNode, context2), someString = (0, _string.someStringFromVariableAndAnonymousProcedure)(variable, anonymousProcedure), string = someString;
      context2 = null;
      const some = new Some(context2, string, node, variable, anonymousProcedure);
      return some;
    }
    function termFromTermNode(termNode, context2) {
      const {Term} = _elements.default, node = termNode, variable = variableFromTermNode(termNode, context2), primitive = primitiveFromTermNode(termNode, context2), negatedTerm = negatedTermFromTermNode(termNode, context2), logicalTerm = logicalTermFromTermNode(termNode, context2), bracketedTerm = bracketedTermFromTermNode(termNode, context2), comparisonTerm = comparisonTermFromTermNode(termNode, context2), properties = [
        variable,
        primitive,
        negatedTerm,
        logicalTerm,
        bracketedTerm,
        comparisonTerm
      ], termString = (0, _string.termStringFromProperties)(properties, context2), string = termString;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm);
      return term;
    }
    function termsFromTermsNode(termsNode, context2) {
      const {Terms} = _elements.default, node = termsNode, string = context2.nodeAsString(node), termNodes = termsNode.getTermNodes(), termsArray = termsArrayFromTermNodes(termNodes, context2), array = termsArray;
      context2 = null;
      const terms = new Terms(context2, string, node, array);
      return terms;
    }
    function errorFromErrorNode(errorNode, context2) {
      const {Error: Error2} = _elements.default, node = errorNode, string = context2.nodeAsString(node);
      context2 = null;
      const error = new Error2(context2, string, node);
      return error;
    }
    function everyFromEveryNode(everyNode, context2) {
      const {Every} = _elements.default, node = everyNode, variable = variableFromEveryNode(everyNode, context2), anonymousProcedure = anonymousProcedureFromEveryNode(everyNode, context2), everyString = (0, _string.everyStringFromVariableAndAnonymousProcedure)(variable, anonymousProcedure), string = everyString;
      context2 = null;
      const every = new Every(context2, string, node, variable, anonymousProcedure);
      return every;
    }
    function labelFromLabelNode(labelNode, context2) {
      const {Label} = _elements.default, node = labelNode, string = context2.nodeAsString(node), name = nameFromLabelNode(labelNode, context2);
      context2 = null;
      const label = new Label(context2, string, node, name);
      return label;
    }
    function reduceFromReduceNode(reduceNode, context2) {
      const {Reduce} = _elements.default, node = reduceNode, variable = variableFromReduceNode(reduceNode, context2), initialExpression = initialExpressionFromReduceNode(reduceNode, context2), anonymousProcedure = anonymousProcedureFromReduceNode(reduceNode, context2), reduceString = (0, _string.reduceStringFromVariableInitialExpressionAndAnonymousProcedure)(variable, initialExpression, anonymousProcedure), string = reduceString;
      context2 = null;
      const reduce = new Reduce(context2, string, node, variable, initialExpression, anonymousProcedure);
      return reduce;
    }
    function ternaryFromTernaryNode(ternaryNode, context2) {
      const {Ternary} = _elements.default, node = ternaryNode, term = termFromTernaryNode(ternaryNode, context2), ifExpression = ifExpressionFromTernaryNode(ternaryNode, context2), elseExpression = elseExpressionFromTernaryNode(ternaryNode, context2), ternaryString = (0, _string.ternaryStringFromTerm)(term), string = ternaryString;
      context2 = null;
      const ternary = new Ternary(context2, string, node, term, ifExpression, elseExpression);
      return ternary;
    }
    function variableFromVariableNode(variableNode, context2) {
      const {Variable} = _elements.default, node = variableNode, string = context2.nodeAsString(node), type = typeFromVariableNode(variableNode, context2), name = nameFromVariableNode(variableNode, context2), expression = expressionFromVariableNode(variableNode, context2);
      context2 = null;
      const variable = new Variable(context2, string, node, type, name, expression);
      return variable;
    }
    function referenceFromReferenceNode(referenceNode, context2) {
      const {Reference} = _elements.default, node = referenceNode, string = context2.nodeAsString(node), name = nameFromReferenceNode(referenceNode, context2);
      context2 = null;
      const reference = new Reference(context2, string, node, name);
      return reference;
    }
    function parameterFromParameterNode(parameterNode, context2) {
      let parameter = null;
      const type = typeFromParaneterNode(parameterNode, context2);
      if (type !== null) {
        const {Parameter} = _elements.default, node = parameterNode, string = context2.nodeAsString(node), name = nameFromParaneterNode(parameterNode, context2);
        context2 = null;
        parameter = new Parameter(context2, string, node, type, name);
      }
      return parameter;
    }
    function nodeQueryFromNodeQueryNode(nodeQueryNode, context2) {
      const {NodeQuery} = _elements.default, node = nodeQueryNode, string = context2.nodeAsString(node), variable = variableFromNodeQueryNode(nodeQueryNode, context2), query = queryFromNodeQueryNode(nodeQueryNode, context2);
      context2 = null;
      const nodeQuery = new NodeQuery(context2, string, node, variable, query);
      return nodeQuery;
    }
    function primitiveFromPrimitiveNode(primitiveNode, context2) {
      const {Primitive} = _elements.default, node = primitiveNode, string = context2.nodeAsString(node), type = typeFromPrimitiveNode(primitiveNode, context2), value = valueFromPrimitiveNode(primitiveNode, context2);
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function nodesQueryFromNodesQueryNode(nodesQueryNode, context2) {
      const {NodesQuery} = _elements.default, node = nodesQueryNode, string = context2.nodeAsString(node), variable = variableFromNodesQueryNode(nodesQueryNode, context2), query = queryFromNodesQueryNode(nodesQueryNode, context2);
      context2 = null;
      const nodesQuery = new NodesQuery(context2, string, node, variable, query);
      return nodesQuery;
    }
    function parametersFromParametersNode(parametersNode, context2) {
      const {Parameters} = _elements.default, node = parametersNode, string = context2.nodeAsString(node), paramtersArray = paramtersArrayFromParametersNode(parametersNode, context2), array = paramtersArray;
      context2 = null;
      const parameters = new Parameters(context2, string, node, array);
      return parameters;
    }
    function expressionFromExpressionNode(expressionNode, context2) {
      const {Expression} = _elements.default, node = expressionNode, term = termFromExpressionNode(expressionNode, context2), some = someFromExpressionNode(expressionNode, context2), every = everyFromExpressionNode(expressionNode, context2), reduce = reduceFromExpressionNode(expressionNode, context2), ternary = ternaryFromExpressionNode(expressionNode, context2), nodeQuery = nodeQueryFromExpressionNode(expressionNode, context2), nodesQuery = nodesQueryFromExpressionNode(expressionNode, context2), returnBlock = returnBlockFromExpressionNode(expressionNode, context2), procedureCall = procedureCallFromExpressionNode(expressionNode, context2), properties = [
        term,
        some,
        every,
        reduce,
        ternary,
        nodeQuery,
        nodesQuery,
        returnBlock,
        procedureCall
      ], expressionString = (0, _string.expressionStringFromProperties)(properties, context2), string = expressionString;
      context2 = null;
      const expression = new Expression(context2, string, node, term, some, every, reduce, ternary, nodeQuery, nodesQuery, returnBlock, procedureCall);
      return expression;
    }
    function returnBlockFromReturnBlockNode(returnBlockNode, context2) {
      const {ReturnBlock} = _elements.default, node = returnBlockNode, steps = stepsFromReturnBlockNode(returnBlockNode, context2), nonsensical = nonsensicalFromReturnBlockNode(returnBlockNode, context2), returnStatement = returnStatementFromReturnBlockNode(returnBlockNode, context2), returnBlockString = (0, _string.returnBlockStringFromReturnStatementNode)(returnStatement), string = returnBlockString;
      context2 = null;
      const returnBlock = new ReturnBlock(context2, string, node, steps, nonsensical, returnStatement);
      return returnBlock;
    }
    function procedureCallFromProcedureCallNode(procedureCallNode, context2) {
      const {ProcedureCall} = _elements.default, node = procedureCallNode, string = context2.nodeAsString(node), reference = referenceFromProcedureCallNode(procedureCallNode, context2), terms = termsFromProcedureCallNode(procedureCallNode, context2);
      context2 = null;
      const procedureCall = new ProcedureCall(context2, string, node, reference, terms);
      return procedureCall;
    }
    function namedParameterFromNamedParameterNode(namedParameterNode, context2) {
      const {NamedParameter} = _elements.default, node = namedParameterNode, string = context2.nodeAsString(node), type = typeFromNamedParameterNode(namedParameterNode, context2), name = nameFromNamedParameterNode(namedParameterNode, context2), alias = aliasFromNamedParameterNode(namedParameterNode, context2);
      context2 = null;
      const namedParameter = new NamedParameter(context2, string, node, type, name, alias);
      return namedParameter;
    }
    function namedParametersFromNamedParametersNode(namedParametersNode, context2) {
      const {NamedParameters} = _elements.default, node = namedParametersNode, string = context2.nodeAsString(node), namedParameterNodes = namedParametersNode.getNamedParameterNodes(), namedParametersArray = namedParamtersArrayFromNamedParameterNodes(namedParameterNodes, context2), array = namedParametersArray;
      context2 = null;
      const namedParameters = new NamedParameters(context2, string, node, array);
      return namedParameters;
    }
    function arrayAssignmentFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const {ArrayAssignment} = _elements.default, node = arrayAssignmentNode, string = context2.nodeAsString(node), variable = variableFromArrayAssignmentNode(arrayAssignmentNode, context2), parameters = parametersFromArrayAssignmentNode(arrayAssignmentNode, context2);
      context2 = null;
      const arrayAssignment = new ArrayAssignment(context2, string, node, variable, parameters);
      return arrayAssignment;
    }
    function returnStatementFromReturnStatementNode(returnStatementNode, context2) {
      const {ReturnStatement} = _elements.default, node = returnStatementNode, string = context2.nodeAsString(node), term = termFromReturnStatementNode(returnStatementNode, context2);
      context2 = null;
      const returnStatement = new ReturnStatement(context2, string, node, term);
      return returnStatement;
    }
    function namedParametersFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const namedParametersNode = objectAssignmentNode.getNamedParametersNode(), namedParameters = namedParametersFromNamedParametersNode(namedParametersNode, context2);
      return namedParameters;
    }
    function objectAssignmentFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const {ObjectAssigment} = _elements.default, node = objectAssignmentNode, string = context2.nodeAsString(node), variable = variableFromObjectAssignmentNode(objectAssignmentNode, context2), namedParameters = namedParametersFromObjectAssignmentNode(objectAssignmentNode, context2);
      context2 = null;
      const objectAssignment = new ObjectAssigment(context2, string, node, variable, namedParameters);
      return objectAssignment;
    }
    function anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const {AnonymousProcedure} = _elements.default, node = anonymousProcedureNode, type = typeFromProcedureAnonymousProcedureNode(anonymousProcedureNode, context2), parameters = parametersFromAnonymousProcedureNode(anonymousProcedureNode, context2), returnBlock = returnBlockFromAnonymousProcedureNode(anonymousProcedureNode, context2), nonymousProcedureString = (0, _string.anonymousProcedureStringFromTypeParametersAndReturnBlock)(type, parameters, returnBlock), string = nonymousProcedureString;
      context2 = null;
      const anonymousProcedure = new AnonymousProcedure(context2, string, node, type, parameters, returnBlock);
      return anonymousProcedure;
    }
    function variableAssignmentsFromVariableAssignmentsNode(variableAssignmentsNode, context2) {
      const {VariableAssignments} = _elements.default, node = variableAssignmentsNode, type = typeFromVariableAssignmentsNode(variableAssignmentsNode, context2), variableAssignmentsArray = variableAssignmentsArrayFromTypeAndVariableAssignmentsNode(type, variableAssignmentsNode, context2), variableAssignmentString = (0, _string.variableAssignmentStringFromTypeAndVariableAssignmentsArray)(type, variableAssignmentsArray), array = variableAssignmentsArray, string = variableAssignmentString;
      context2 = null;
      const variableAssignments = new VariableAssignments(context2, string, node, array);
      return variableAssignments;
    }
    function procedureDeclarationFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const {ProcedureDeclaration} = _elements.default, node = procedureDeclarationNode, procedure = procedureFromProcedureDeclarationNode(procedureDeclarationNode, context2), procedureDeclarationString = (0, _string.procedureDeclarationStringFromProcedure)(procedure), string = procedureDeclarationString;
      context2 = null;
      const procedureDeclaration = new ProcedureDeclaration(context2, string, node, procedure);
      return procedureDeclaration;
    }
    function nameFromLabelNode(labelNode, context2) {
      const name = labelNode.getName();
      return name;
    }
    function termFromTernaryNode(ternaryNode, context2) {
      const termNode = ternaryNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function variableFromSomeNode(someNode, context2) {
      const variableNode = someNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function variableFromTermNode(termNode, context2) {
      let variable = null;
      const variableNode = termNode.getVariableNode();
      if (variableNode !== null) {
        variable = variableFromVariableNode(variableNode, context2);
      }
      return variable;
    }
    function nameFromVariableNode(variableNode) {
      const name = variableNode.getName();
      return name;
    }
    function typeFromVariableNode(variableNode, context2) {
      const type = null;
      return type;
    }
    function primitiveFromTermNode(termNode, context2) {
      let primitive = null;
      const primitiveNode = termNode.getPrimitiveNode();
      if (primitiveNode !== null) {
        primitive = primitiveFromPrimitiveNode(primitiveNode, context2);
      }
      return primitive;
    }
    function variableFromEveryNode(everyNode, context2) {
      const variableNode = everyNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromParaneterNode(parameterNode, context2) {
      const type = parameterNode.getType();
      return type;
    }
    function nameFromParaneterNode(parameterNode, context2) {
      const name = parameterNode.getName();
      return name;
    }
    function nameFromReferenceNode(referenceNode, context2) {
      const name = referenceNode.getName();
      return name;
    }
    function typeFromPrimitiveNode(primitiveNode, context2) {
      const type = primitiveNode.getType();
      return type;
    }
    function variableFromReduceNode(reduceNode, context2) {
      const variableNode = reduceNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function termFromExpressionNode(expressionNode, context2) {
      let term = null;
      const termNode = expressionNode.getTermNode();
      if (termNode !== null) {
        term = termFromTermNode(termNode, context2);
      }
      return term;
    }
    function someFromExpressionNode(expressionNode, context2) {
      let some = null;
      const someNode = expressionNode.getSomeNode();
      if (someNode !== null) {
        some = someFromSomeNode(someNode, context2);
      }
      return some;
    }
    function queryFromNodeQueryNode(nodeQueryNode, context2) {
      const string = nodeQueryNode.getString(), expressionString = string, query = _occamquery.Query.fromExpressionString(expressionString);
      return query;
    }
    function valueFromPrimitiveNode(primitiveNode, context2) {
      const value = primitiveNode.getValue();
      return value;
    }
    function queryFromNodesQueryNode(nodesQueryNode, context2) {
      const string = nodesQueryNode.getString(), expressionString = string, query = _occamquery.Query.fromExpressionString(expressionString);
      return query;
    }
    function everyFromExpressionNode(expressionNode, context2) {
      let every = null;
      const everyNode = expressionNode.getEveryNode();
      if (everyNode !== null) {
        every = everyFromEveryNode(everyNode, context2);
      }
      return every;
    }
    function negatedTermFromTermNode(termNode, context2) {
      let negatedTerm = null;
      const negatedTermNode = termNode.getNegatedTermNode();
      if (negatedTermNode !== null) {
        negatedTerm = negatedTermFromNegatedTermNode(negatedTermNode, context2);
      }
      return negatedTerm;
    }
    function logicalTermFromTermNode(termNode, context2) {
      let logicalTerm = null;
      const logicalTermNode = termNode.getLogicalTermNode();
      if (logicalTermNode !== null) {
        logicalTerm = logicalTermFromLogicalTermNode(logicalTermNode, context2);
      }
      return logicalTerm;
    }
    function typeFromLogicalTermNode(logicalTermNode, context2) {
      const type = _types.BOOLEAN_TYPE;
      return type;
    }
    function typeFromNegatedTermNode(logicalTermNode, context2) {
      const type = _types.BOOLEAN_TYPE;
      return type;
    }
    function termFromNegatedTermNode(negatedTermNode, context2) {
      const termNode = negatedTermNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function expressionFromReduceNode(reduceNode, context2) {
      const expressionNode = reduceNode.getExpressionNode(), expression = expressionFromExpressionNode(expressionNode, context2);
      return expression;
    }
    function reduceFromExpressionNode(expressionNode, context2) {
      let reduce = null;
      const reduceNode = expressionNode.getReduceNode();
      if (reduceNode !== null) {
        reduce = reduceFromReduceNode(reduceNode, context2);
      }
      return reduce;
    }
    function stepsFromReturnBlockNode(returnBlockNode, context2) {
      const stepNodes = returnBlockNode.getStepNodes(), steps = stepNodes.map((stepNode) => {
        const step = stepFromStepNode(stepNode, context2);
        return step;
      });
      return steps;
    }
    function variableFromNodeQueryNode(nodeQueryNode, context2) {
      const variableNode = nodeQueryNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function ternaryFromExpressionNode(expressionNode, context2) {
      let ternary = null;
      const ternaryNode = expressionNode.getTernaryNode();
      if (ternaryNode !== null) {
        ternary = ternaryFromTernaryNode(ternaryNode, context2);
      }
      return ternary;
    }
    function bracketedTermFromTermNode(termNode, context2) {
      let bracketedTerm = null;
      const bracketedTermNode = termNode.getBracketedTermNode();
      if (bracketedTermNode !== null) {
        bracketedTerm = bracketedTermFromBracketedTermNode(bracketedTermNode, context2);
      }
      return bracketedTerm;
    }
    function termFromBracketedTermNode(bracketedTermNode, context2) {
      const termNode = bracketedTermNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function comparisonTermFromTermNode(termNOde, context2) {
      let comparisonTerm = null;
      const comparisonTermNode = termNOde.getComparisonTermNode();
      if (comparisonTermNode !== null) {
        comparisonTerm = comparisonTermFromComparisonTermNode(comparisonTermNode, context2);
      }
      return comparisonTerm;
    }
    function expressionFromVariableNode(variableNode, context2) {
      const expression = null;
      return expression;
    }
    function variableFromNodesQueryNode(nodesQueryNode, context2) {
      const variableNode = nodesQueryNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function termsFromProcedureCallNode(procedureCallNode, context2) {
      const termsNode = procedureCallNode.getTermsNode(), terms = termsFromTermsNode(termsNode, context2);
      return terms;
    }
    function typeFromNamedParameterNode(namedParameterNode, context2) {
      const type = namedParameterNode.getType();
      return type;
    }
    function nameFromNamedParameterNode(namedParameterNode, context2) {
      const name = namedParameterNode.getName();
      return name;
    }
    function leftTermFromLogicalTermNode(logicalTermNode, context2) {
      const leftTermNode = logicalTermNode.getLeftTermNode(), leftTerm = termFromTermNode(leftTermNode, context2);
      return leftTerm;
    }
    function arrayAssignmentFromStepNode(stepNode, context2) {
      let arrayAssignment = null;
      const arrayAssignmentNode = stepNode.getArrayAssignmentNode();
      if (arrayAssignmentNode !== null) {
        arrayAssignment = arrayAssignmentFromArrayAssignmentNode(arrayAssignmentNode, context2);
      }
      return arrayAssignment;
    }
    function ifExpressionFromTernaryNode(ternaryNode, context2) {
      const ifExpressionNode = ternaryNode.getIfExpressionNode(), ifExpression = expressionFromExpressionNode(ifExpressionNode, context2);
      return ifExpression;
    }
    function nodeQueryFromExpressionNode(expressionNode, context2) {
      let nodeQuery = null;
      const nodeQueryNode = expressionNode.getNodeQueryNode();
      if (nodeQueryNode !== null) {
        nodeQuery = nodeQueryFromNodeQueryNode(nodeQueryNode, context2);
      }
      return nodeQuery;
    }
    function aliasFromNamedParameterNode(namedParameterNode, context2) {
      const alias = namedParameterNode.getAlias();
      return alias;
    }
    function termFromReturnStatementNode(returnStatementNode, context2) {
      const termNode = returnStatementNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function objectAssignmentFromStepNode(stepNode, context2) {
      let objectAssignment = null;
      const objectAssignmentNode = stepNode.getObjectAssignmentNode();
      if (objectAssignmentNode !== null) {
        objectAssignment = objectAssignmentFromObjectAssignmentNode(objectAssignmentNode, context2);
      }
      return objectAssignment;
    }
    function nodesQueryFromExpressionNode(expressionNode, context2) {
      let nodesQuery = null;
      const nodesQueryNode = expressionNode.getNodesQueryNode();
      if (nodesQueryNode !== null) {
        nodesQuery = nodesQueryFromNodesQueryNode(nodesQueryNode, context2);
      }
      return nodesQuery;
    }
    function rightTermFromLogicalTermNode(logicalTermNode, context2) {
      const rightTermNode = logicalTermNode.getRightTermNode(), rightTerm = termFromTermNode(rightTermNode, context2);
      return rightTerm;
    }
    function negatedFromComparisonTermNode(comparisonTermNode, context2) {
      const negated = comparisonTermNode.isNegated();
      return negated;
    }
    function elseExpressionFromTernaryNode(ternaryNode, context2) {
      const elseExpressionNode = ternaryNode.getElseExpressionNode(), elseExpression = expressionFromExpressionNode(elseExpressionNode, context2);
      return elseExpression;
    }
    function returnBlockFromExpressionNode(expressionNode, context2) {
      let returnBlock = null;
      const returnBlockNode = expressionNode.getReturnBlockNode();
      if (returnBlockNode !== null) {
        returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      }
      return returnBlock;
    }
    function anonymousProcedureFromSomeNode(someNode, context2) {
      const anonymousProcedureNode = someNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function nonsensicalFromReturnBlockNode(returnBlockNode, context2) {
      const nonsensical = returnBlockNode.isNonsensical();
      return nonsensical;
    }
    function referenceFromProcedureCallNode(procedureCallNode, context2) {
      const referenceNode = procedureCallNode.getReferenceNode(), reference = referenceFromReferenceNode(referenceNode, context2);
      return reference;
    }
    function leftTermFromCompzrisonTermNode(comparisonTermNode, context2) {
      const leftTermNode = comparisonTermNode.getLeftTermNode(), leftTerm = termFromTermNode(leftTermNode, context2);
      return leftTerm;
    }
    function disjunctionFromLogicalTermNode(logicalTermNode, context2) {
      const disjunction = logicalTermNode.isDisjunction();
      return disjunction;
    }
    function negatedTermFromNegatedTermNode(negatedTermNode, context2) {
      const {NegatedTerm} = _elements.default, node = negatedTermNode, string = context2.nodeAsString(node), termNode = negatedTermNode.getTermNode(), type = typeFromNegatedTermNode(termNode, context2), term = termFromNegatedTermNode(negatedTermNode, context2), negatedTerm = new NegatedTerm(context2, string, node, type, term);
      return negatedTerm;
    }
    function logicalTermFromLogicalTermNode(logicalTermNode, context2) {
      const {LogicalTerm} = _elements.default, node = logicalTermNode, string = context2.nodeAsString(node), type = typeFromLogicalTermNode(logicalTermNode, context2), disjunction = disjunctionFromLogicalTermNode(logicalTermNode, context2), leftTerm = leftTermFromLogicalTermNode(logicalTermNode, context2), rightTerm = rightTermFromLogicalTermNode(logicalTermNode, context2), logicalTerm = new LogicalTerm(context2, string, node, type, disjunction, leftTerm, rightTerm);
      return logicalTerm;
    }
    function variableFromTypeAndVariableNode(type, variableNode, context2) {
      const {Variable} = _elements.default, node = variableNode, name = nameFromVariableNode(variableNode), expression = expressionFromTypeAndVariableNode(type, variableNode, context2), variableString = (0, _string.variableStringFromName)(name), string = variableString, variable = new Variable(context2, string, node, type, name, expression);
      return variable;
    }
    function variableAssignmentsFromStepNode(stepNode, context2) {
      let variableAssignments = null;
      const variableAssignmentsNode = stepNode.getVariableAssignmentsNode();
      if (variableAssignmentsNode !== null) {
        variableAssignments = variableAssignmentsFromVariableAssignmentsNode(variableAssignmentsNode, context2);
      }
      return variableAssignments;
    }
    function anonymousProcedureFromEveryNode(everyNode, context2) {
      const anonymousProcedureNode = everyNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function initialExpressionFromReduceNode(reduceNode, context2) {
      const expression = expressionFromReduceNode(reduceNode, context2), initialExpression = expression;
      return initialExpression;
    }
    function procedureCallFromExpressionNode(expressionNode, context2) {
      let procedureCall = null;
      const procedureCallNode = expressionNode.getProcedureCallNode();
      if (procedureCallNode !== null) {
        procedureCall = procedureCallFromProcedureCallNode(procedureCallNode, context2);
      }
      return procedureCall;
    }
    function rightTermFromCompzrisonTermNode(comparisonTermNode, context2) {
      const rightTermNode = comparisonTermNode.getRightTermNode(), rightTerm = termFromTermNode(rightTermNode, context2);
      return rightTerm;
    }
    function variableFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const variableNode = arrayAssignmentNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromVariableAssignmentsNode(variableAssignmentsNode, context2) {
      const type = variableAssignmentsNode.getType();
      return type;
    }
    function anonymousProcedureFromReduceNode(reduceNode, context2) {
      const anonymousProcedureNode = reduceNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function variableFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const variableNode = objectAssignmentNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const type = procedureDeclarationNode.getType();
      return type;
    }
    function expressionFromTypeAndVariableNode(type, variableNode, context2) {
      const expression = null;
      return expression;
    }
    function parametersFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const parametersNode = arrayAssignmentNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function labelFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const labelNode = procedureDeclarationNode.getLabelNode(), label = labelFromLabelNode(labelNode, context2);
      return label;
    }
    function returnStatementFromReturnBlockNode(returnBlockNode, context2) {
      const returnStatementNode = returnBlockNode.getReturnStatementNode(), returnStatement = returnStatementFromReturnStatementNode(returnStatementNode, context2);
      return returnStatement;
    }
    function bracketedTermFromBracketedTermNode(bracketedTermNode, context2) {
      const {BracketedTerm} = _elements.default, node = bracketedTermNode, string = context2.nodeAsString(node), term = termFromBracketedTermNode(bracketedTermNode, context2), bracketedTerm = new BracketedTerm(context2, string, node, term);
      return bracketedTerm;
    }
    function expressionFromVariableAssignmentNode(variableAssigmentNode, context2) {
      const expressionNode = variableAssigmentNode.getExpressionNode(), expression = expressionFromExpressionNode(expressionNode, context2);
      return expression;
    }
    function parametersFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const parametersNode = anonymousProcedureNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function comparisonTermFromComparisonTermNode(comparisonTermNode, context2) {
      const {ComparisonTerm} = _elements.default, node = comparisonTermNode, string = context2.nodeAsString(node), negated = negatedFromComparisonTermNode(comparisonTermNode, context2), leftTerm = leftTermFromCompzrisonTermNode(comparisonTermNode, context2), rightTerm = rightTermFromCompzrisonTermNode(comparisonTermNode, context2), comparisonTerm = new ComparisonTerm(context2, string, node, negated, leftTerm, rightTerm);
      return comparisonTerm;
    }
    function returnBlockFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const returnBlockNode = anonymousProcedureNode.getReturnBlockNode(), returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      return returnBlock;
    }
    function procedureFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const {Procedure} = _elements.default, node = procedureDeclarationNode, type = typeFromProcedureDeclarationNode(procedureDeclarationNode, context2), label = labelFromProcedureDeclarationNode(procedureDeclarationNode, context2), parameters = parametersFromProcedureDeclarationNode(procedureDeclarationNode, context2), returnBlock = returnBlockFromProcedureDeclarationNode(procedureDeclarationNode, context2), procedureString = (0, _string.procedureStringFromTypeLabelParametersAndReturnBlock)(type, label, parameters, returnBlock), string = procedureString, procedure = new Procedure(context2, string, node, type, label, parameters, returnBlock);
      return procedure;
    }
    function parametersFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const parametersNode = procedureDeclarationNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function typeFromProcedureAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const type = anonymousProcedureNode.getType();
      return type;
    }
    function returnBlockFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const returnBlockNode = procedureDeclarationNode.getReturnBlockNode(), returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      return returnBlock;
    }
    function variableFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2) {
      const variableNode = variableAssignmentNode.getVariableNode(), variable = variableFromTypeAndVariableNode(type, variableNode, context2);
      return variable;
    }
    function variableAssignmentFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2) {
      const {VariableAssignment} = _elements.default, node = variableAssignmentNode, variable = variableFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2), expression = expressionFromVariableAssignmentNode(variableAssignmentNode, context2), variableAssignmentString = (0, _string.variableAssignmentStringFromTypeAndVariable)(type, variable, context2), string = variableAssignmentString, assignment = new VariableAssignment(context2, string, node, variable, expression);
      return assignment;
    }
    function termsArrayFromTermNodes(termNodes, context2) {
      const termsArray = termNodes.map((termNode) => {
        const term = termFromTermNode(termNode, context2);
        return term;
      });
      return termsArray;
    }
    function paramtersArrayFromParametersNode(parametersNode, context2) {
      const parameterNodes = parametersNode.getParameterNodes(), paramtersArray = parameterNodes.map((parameterNode) => {
        const parameter = parameterFromParameterNode(parameterNode, context2);
        return parameter;
      });
      return paramtersArray;
    }
    function namedParamtersArrayFromNamedParameterNodes(namedParameterNodes, context2) {
      const namedParamtersArray = namedParameterNodes.map((namedParameterNode) => {
        const namedParameter = namedParameterFromNamedParameterNode(namedParameterNode, context2);
        return namedParameter;
      });
      return namedParamtersArray;
    }
    function variableAssignmentsArrayFromTypeAndVariableAssignmentsNode(type, variableAssignmentsNode, context2) {
      const variableAssignmentNodes = variableAssignmentsNode.getVariableAssignmentNodes(), variableAssignmentsArray = variableAssignmentNodes.map((variableAssignmentNode) => {
        const variableAssignment = variableAssignmentFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2);
        return variableAssignment;
      });
      return variableAssignmentsArray;
    }
  });

  // lib/process/verify.js
  var require_verify2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "verifyFile", {
      enumerable: true,
      get: function() {
        return verifyFile;
      }
    });
    var _occamlanguages = require_lib14();
    var _element = require_element5();
    var {nodeQuery} = _occamlanguages.queryUtilities;
    var errorNodeQuery = nodeQuery("/error");
    var procedureDeclarationNodeQuery = nodeQuery("/procedureDeclaration");
    var TopLevelPass = class extends _occamlanguages.SimplePass {
    };
    __publicField(TopLevelPass, "maps", [
      {
        nodeQuery: errorNodeQuery,
        run: (errorNode, context2) => {
          let success = false;
          const error = (0, _element.errorFromErrorNode)(errorNode, context2), errorVerifies = error.verify(context2);
          if (errorVerifies) {
            success = true;
          }
          return success;
        }
      },
      {
        nodeQuery: procedureDeclarationNodeQuery,
        run: (procedureDeclarationNode, context2) => {
          let success = false;
          const procedureDeclaration = (0, _element.procedureDeclarationFromProcedureDeclarationNode)(procedureDeclarationNode, context2), procedureDeclarationVerifies = procedureDeclaration.verify(context2);
          if (procedureDeclarationVerifies) {
            success = true;
          }
          return success;
        }
      }
    ]);
    var topLevelPass = new TopLevelPass();
    function verifyFile(fileNode, context2) {
      let fileVerifies = false;
      const node = fileNode, sucess = topLevelPass.run(node, context2);
      if (sucess) {
        fileVerifies = true;
      }
      return fileVerifies;
    }
  });

  // lib/utilities/lexers.js
  var require_lexers2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get furtleLexerFromEntries() {
        return furtleLexerFromEntries;
      },
      get furtleLexerFromNothing() {
        return furtleLexerFromNothing;
      }
    });
    var _occamlexers = require_lib3();
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {lexerFromRules, rulesFromEntries} = _occamlexers.lexerUtilities;
    function furtleLexerFromNothing(Class) {
      if (Class === void 0) {
        Class = _lexer.default;
      }
      const {entries} = _lexer.default;
      let rules;
      rules = rulesFromEntries(entries);
      const furtleLexer = lexerFromRules(Class, rules);
      return furtleLexer;
    }
    function furtleLexerFromEntries(Class, entries) {
      if (entries === void 0) {
        entries = Class;
        Class = _lexer.default;
      }
      let rules;
      rules = rulesFromEntries(entries);
      const furtleLexer = lexerFromRules(Class, rules);
      return furtleLexer;
    }
    var _default = {
      furtleLexerFromEntries,
      furtleLexerFromNothing
    };
  });

  // lib/utilities/parsers.js
  var require_parsers2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get furtleParserFromBNF() {
        return furtleParserFromBNF;
      },
      get furtleParserFromBNFAndStartRuleName() {
        return furtleParserFromBNFAndStartRuleName;
      },
      get furtleParserFromNothing() {
        return furtleParserFromNothing;
      }
    });
    var _occamparsers = require_lib4();
    var _occamgrammarutilities = require_lib10();
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {rulesFromBNF, parserFromRules, parserFromRulesAndStartRuleName} = _occamparsers.parserUtilities;
    function furtleParserFromBNF(Class, bnf) {
      if (bnf === void 0) {
        bnf = Class;
        Class = _parser.default;
      }
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRules(Class, rules);
      return furtleParser;
    }
    function furtleParserFromNothing(Class) {
      if (Class === void 0) {
        Class = _parser.default;
      }
      const {bnf} = _parser.default;
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRules(Class, rules);
      return furtleParser;
    }
    function furtleParserFromBNFAndStartRuleName(Class, bnf, startRuleName) {
      if (startRuleName === void 0) {
        startRuleName = bnf;
        bnf = Class;
        Class = _parser.default;
      }
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return furtleParser;
    }
    var _default = {
      furtleParserFromBNF,
      furtleParserFromNothing,
      furtleParserFromBNFAndStartRuleName
    };
  });

  // lib/utilities/furtle.js
  var require_furtle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get furtleLexer() {
        return furtleLexer;
      },
      get furtleParser() {
        return furtleParser;
      }
    });
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    var _lexers = require_lexers2();
    var _parsers = require_parsers2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var furtleLexer = (0, _lexers.furtleLexerFromNothing)(_lexer.default);
    var furtleParser = (0, _parsers.furtleParserFromNothing)(_parser.default);
  });

  // lib/context/file/furtle.js
  var require_furtle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleFileContext;
      }
    });
    var _occamlanguages = require_lib14();
    var _verify = require_verify2();
    var _furtle = require_furtle();
    var FurtleFileContext = class extends _occamlanguages.FileContext {
      constructor(context2, filePath, tokens, node, procedures) {
        super(context2, filePath, tokens, node);
        this.procedures = procedures;
      }
      getProcedures(includeRelease = true) {
        const procedures = includeRelease ? this.context.getProcedures() : this.procedures;
        return procedures;
      }
      getLexer() {
        const lexer = _furtle.furtleLexer;
        return lexer;
      }
      getParser() {
        const parser = _furtle.furtleParser;
        return parser;
      }
      getLabels(includeRelease = true) {
        const labels = [];
        return labels;
      }
      getTypes(includeRelease = true) {
        const types = [];
        return types;
      }
      getRules(includeRelease = true) {
        const rules = [];
        return rules;
      }
      getAxioms(includeRelease = true) {
        const axioms = [];
        return axioms;
      }
      getLemmas(includeRelease = true) {
        const lemmas = [];
        return lemmas;
      }
      getTheorems(includeRelease = true) {
        const theorems = [];
        return theorems;
      }
      getVariables(includeRelease = true) {
        const variables = [];
        return variables;
      }
      getMetaLemmas(includeRelease = true) {
        const metaLemmas = [];
        return metaLemmas;
      }
      getConjectures(includeRelease = true) {
        const conjectures = [];
        return conjectures;
      }
      getCombinators(includeRelease = true) {
        const combinators = [];
        return combinators;
      }
      getTypePrefixes(includeRelease = true) {
        const typePrefixes = [];
        return typePrefixes;
      }
      getConstructors(includeRelease = true) {
        const constructors = [];
        return constructors;
      }
      getMetatheorems(includeRelease = true) {
        const metatheorems = [];
        return metatheorems;
      }
      getMetavariables(includeRelease = true) {
        const metavariables = [];
        return metavariables;
      }
      addProcedure(procedure) {
        const procedureString = procedure.getString();
        this.procedures.push(procedure);
        const filePath = this.getFilePath();
        this.debug(`Added the '${procedureString}' procedure to the '${filePath}' file context.`);
      }
      findProcedureByProcedureName(procedureName) {
        const procedures = this.getProcedures(), procedure = procedures.find((procedure2) => {
          const procedureComparesToProcedureName = procedure2.compareProcedureName(procedureName);
          if (procedureComparesToProcedureName) {
            return true;
          }
        }) || null;
        return procedure;
      }
      isProcedurePresentByProcedureName(procedureName) {
        const procedure = this.findProcedureByProcedureName(procedureName), procedurePresent = procedure !== null;
        return procedurePresent;
      }
      clear() {
        this.procedures = [];
      }
      complete() {
      }
      async verifyFile() {
        const node = this.getNode(), context2 = this, fileNode = node, fileVerifies = (0, _verify.verifyFile)(fileNode, context2);
        return fileVerifies;
      }
      static fromFile(file, context2) {
        const procedures = [], furtleFileContext = _occamlanguages.FileContext.fromFile(FurtleFileContext, file, procedures, context2);
        return furtleFileContext;
      }
      static fromFilePath(filePath, context2) {
        const procedures = null, furtleFileContext = ileContext.fromFilePath(FurtleFileContext, filePath, procedures, context2);
        return furtleFileContext;
      }
    };
  });

  // lib/utilities/terms.js
  var require_terms3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get termsFromNodes() {
        return termsFromNodes;
      },
      get termsFromPrimitives() {
        return termsFromPrimitives;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _string = require_string5();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function termsFromNodes(nodes, context2) {
      const {Terms} = _elements.default, termsArray = termsArrayFromNodes(nodes, context2), termsString = (0, _string.termsStringFromTermsArray)(termsArray), string = termsString, array = termsArray, node = null;
      context2 = null;
      const terms = new Terms(context2, string, node, array);
      return terms;
    }
    function termsFromPrimitives(primitives) {
      const {Terms} = _elements.default, termsArray = termsArrayFromPrimitives(primitives), termsString = (0, _string.termsStringFromTermsArray)(termsArray), context2 = null, string = termsString, array = termsArray, node = null, terms = new Terms(context2, string, node, array);
      return terms;
    }
    var _default = {
      termsFromNodes,
      termsFromPrimitives
    };
    function termsArrayFromNodes(nodes, context2) {
      const termsArray = nodes.map((node) => {
        const term = (0, _term.termFromNode)(node, context2);
        return term;
      });
      return termsArray;
    }
    function termsArrayFromPrimitives(primitives) {
      const termsArray = primitives.map((primitive) => {
        const term = (0, _term.termFromPrimitive)(primitive);
        return term;
      });
      return termsArray;
    }
  });

  // lib/index.js
  var require_lib15 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get FurtleFileContext() {
        return _furtle.default;
      },
      get FurtleLexer() {
        return _lexer.default;
      },
      get FurtleParser() {
        return _parser.default;
      },
      get Terms() {
        return _terms.default;
      },
      get lexersUtilities() {
        return _lexers.default;
      },
      get parsersUtilities() {
        return _parsers.default;
      },
      get primitiveUtilities() {
        return _primitive.default;
      },
      get termUtilities() {
        return _term.default;
      },
      get termsUtilities() {
        return _terms1.default;
      }
    });
    require_preamble();
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    var _furtle = /* @__PURE__ */ _interop_require_default(require_furtle2());
    var _term = /* @__PURE__ */ _interop_require_default(require_term());
    var _terms1 = /* @__PURE__ */ _interop_require_default(require_terms3());
    var _lexers = /* @__PURE__ */ _interop_require_default(require_lexers2());
    var _parsers = /* @__PURE__ */ _interop_require_default(require_parsers2());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/example/view/subHeading.js
  var require_subHeading = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SubHeading = _easywithstyle.default.h2`

  margin: 1rem 0 0.5rem 0;
  font-size: 2rem;
  
  :first-of-type {
    margin-top: 0;
  }

`;
    var _default = SubHeading;
  });

  // lib/example/view/div/sizeable.js
  var require_sizeable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easylayout = require_lib9();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = (0, _easywithstyle.default)(_easylayout.SizeableDiv)`

  width: 80rem;
  min-width: 48rem;
  
`;
  });

  // lib/example/view/textarea.js
  var require_textarea2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = (0, _easywithstyle.default)(_easy.Textarea)`

  border: 1px solid darkgrey;
  height: 36rem;
  resize: vertical;
  padding: 0.25rem;
  font-size: 1.2rem;
  line-height: 1.5rem;
  white-space: pre;
  font-family: monospace;

`;
  });

  // lib/example/view/textarea/bnf.js
  var require_bnf14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BNFTextarea = class extends _textarea.default {
      getBNF() {
        const value = this.getValue(), bnf = value;
        return bnf;
      }
      setBNF(bnf) {
        const value = bnf;
        this.setValue(value);
      }
      parentContext() {
        const getBNF = this.getBNF.bind(this), setBNF = this.setBNF.bind(this);
        return {
          getBNF,
          setBNF
        };
      }
    };
    __publicField(BNFTextarea, "defaultProperties", {
      className: "bnf",
      spellCheck: "false"
    });
  });

  // lib/example/view/input/ruleName.js
  var require_ruleName8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameInput = class extends _easy.Input {
      getRuleName() {
        const value = this.getValue(), ruleName = value;
        return ruleName;
      }
      setRuleName(ruleName) {
        const value = ruleName;
        this.setValue(value);
      }
      parentContext() {
        const getRuleName = this.getRuleName.bind(this), setRuleName = this.setRuleName.bind(this);
        return {
          getRuleName,
          setRuleName
        };
      }
    };
    __publicField(RuleNameInput, "defaultProperties", {
      className: "rule-name",
      spellCheck: "false"
    });
    var _default = (0, _easywithstyle.default)(RuleNameInput)`

  border: 1px solid darkgrey;
  padding: 0.25rem;
  font-size: 1.2rem;
  font-family: monospace;
  
`;
  });

  // lib/example/view/textarea/tokens.js
  var require_tokens2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TokensTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TokensTextarea = class extends _textarea.default {
      setTokens(tokens) {
        let lineNumber = 1, previousToken = null;
        const html = tokens.reduce((html2, token) => {
          const tokenHTML = token.asHTML();
          if (previousToken === null) {
            html2 += `${lineNumber++}: `;
          } else {
            const previousTokenEndOfLineToken = previousToken.isEndOfLineToken();
            if (previousTokenEndOfLineToken) {
              html2 += `${lineNumber++}: `;
            }
          }
          html2 += tokenHTML;
          previousToken = token;
          return html2;
        }, _constants.EMPTY_STRING);
        this.html(html);
      }
      clearTokens() {
        const html = _constants.EMPTY_STRING;
        this.html(html);
      }
      parentContext() {
        const setTokens = this.setTokens.bind(this), clearTokens = this.clearTokens.bind(this);
        return {
          setTokens,
          clearTokens
        };
      }
    };
    __publicField(TokensTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/view/textarea/content.js
  var require_content4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ContentTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ContentTextarea = class extends _textarea.default {
      getContent() {
        const value = this.getValue(), content = value;
        return content;
      }
      setContent(content) {
        const value = content;
        this.setValue(value);
      }
      parentContext() {
        const getContent = this.getContent.bind(this), setContent = this.setContent.bind(this);
        return {
          getContent,
          setContent
        };
      }
    };
    __publicField(ContentTextarea, "defaultProperties", {
      className: "content",
      spellCheck: "false"
    });
  });

  // lib/example/view/textarea/parseTree.js
  var require_parseTree2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParseTreeTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ParseTreeTextarea = class extends _textarea.default {
      setParseTree(parseTree) {
        if (parseTree !== null) {
          parseTree.shiftLine();
          const parseTreeString = parseTree.asString(), value = parseTreeString;
          this.setValue(value);
        } else {
          this.clearParseTree();
        }
      }
      clearParseTree() {
        const value = _constants.EMPTY_STRING;
        this.setValue(value);
      }
      parentContext() {
        const setParseTree = this.setParseTree.bind(this), clearParseTree = this.clearParseTree.bind(this);
        return {
          setParseTree,
          clearParseTree
        };
      }
    };
    __publicField(ParseTreeTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/view/textarea/lexicalEntries.js
  var require_lexicalEntries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LexicalEntriesTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var LexicalEntriesTextarea = class extends _textarea.default {
      getLexicalEntries() {
        const value = this.getValue(), lexicalEntries = JSON.parse(value);
        return lexicalEntries;
      }
      setLexicalEntries(lexicalEntries) {
        const value = JSON.stringify(lexicalEntries, null, "  ");
        this.setValue(value);
      }
      parentContext() {
        const getLexicalEntries = this.getLexicalEntries.bind(this), setLexicalEntries = this.setLexicalEntries.bind(this);
        return {
          getLexicalEntries,
          setLexicalEntries
        };
      }
    };
    __publicField(LexicalEntriesTextarea, "defaultProperties", {
      className: "lexical-entries",
      spellCheck: "false"
    });
  });

  // lib/example/view.js
  var require_view = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _easylayout = require_lib9();
    var _index = require_lib15();
    var _subHeading = /* @__PURE__ */ _interop_require_default(require_subHeading());
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable2());
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf14());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName8());
    var _tokens = /* @__PURE__ */ _interop_require_default(require_tokens2());
    var _content = /* @__PURE__ */ _interop_require_default(require_content4());
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree2());
    var _lexicalEntries = /* @__PURE__ */ _interop_require_default(require_lexicalEntries());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {furtleParserFromBNF} = _index.parsersUtilities;
    var {furtleLexerFromEntries} = _index.lexersUtilities;
    var {bnf} = _index.FurtleParser;
    var {entries} = _index.FurtleLexer;
    var View = class extends _easy.Element {
      keyUpHandler = (event, element) => {
        const tokens = this.getTokens(), parseTree = this.getParseTree(tokens);
        this.setTokens(tokens);
        this.setParseTree(parseTree);
      };
      getTokens() {
        const lexicalEntries = this.getLexicalEntries(), entries2 = lexicalEntries, furtleLexer = furtleLexerFromEntries(entries2), lexer = furtleLexer, content = this.getContent(), tokens = lexer.tokenise(content);
        return tokens;
      }
      getParseTree(tokens) {
        let parseTree = null;
        const bnf2 = this.getBNF(), furtleParser = furtleParserFromBNF(bnf2), parser = furtleParser, ruleName = this.getRuleName(), ruleMap = parser.getRuleMap(), rule = ruleMap[ruleName], node = parser.parse(tokens, rule);
        if (node !== null) {
          parseTree = node.asParseTree(tokens);
        }
        return parseTree;
      }
      childElements() {
        return /* @__PURE__ */ React.createElement(_easylayout.ColumnsDiv, null, /* @__PURE__ */ React.createElement(_sizeable.default, null, /* @__PURE__ */ React.createElement(_easylayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Lexical entries"), /* @__PURE__ */ React.createElement(_lexicalEntries.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "BNF"), /* @__PURE__ */ React.createElement(_bnf.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Rule name"), /* @__PURE__ */ React.createElement(_ruleName.default, {
          onKeyUp: this.keyUpHandler
        }))), /* @__PURE__ */ React.createElement(_easylayout.VerticalSplitterDiv, null), /* @__PURE__ */ React.createElement(_easylayout.ColumnDiv, null, /* @__PURE__ */ React.createElement(_easylayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Content"), /* @__PURE__ */ React.createElement(_content.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Tokens"), /* @__PURE__ */ React.createElement(_tokens.default, null), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Parse tree"), /* @__PURE__ */ React.createElement(_parseTree.default, null))));
      }
      initialise() {
        this.assignContext();
        const {initialContent, initialRuleName} = this.constructor, content = initialContent, ruleName = initialRuleName, lexicalEntries = entries;
        this.setBNF(bnf);
        this.setContent(content);
        this.setRuleName(ruleName);
        this.setLexicalEntries(lexicalEntries);
        this.keyUpHandler();
      }
    };
    __publicField(View, "initialRuleName", "variableAssignment");
    __publicField(View, "initialContent", `Boolean variableBound = isVariableBound(termNode, statementNode);`);
    __publicField(View, "tagName", "div");
    __publicField(View, "defaultProperties", {
      className: "view"
    });
    var _default = (0, _easywithstyle.default)(View)`

  padding: 1rem;
 
`;
  });

  // lib/example.js
  var require_example3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_lib2();
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _view = /* @__PURE__ */ _interop_require_default(require_view());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {renderStyles} = _easywithstyle.default;
    renderStyles();
    var body = new _easy.Body();
    body.mount(/* @__PURE__ */ React.createElement(_view.default, null));
  });
  require_example3();
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL29mZnNldC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvYm91bmRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL29iamVjdC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9lbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdGV4dEVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9lbGVtZW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZXZlbnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2pzeC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2tleS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9tb3VzZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2NsaWNrLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvdG91Y2guanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9yZXNpemUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9mdWxsU2NyZWVuLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvYXN5bmMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9jdXN0b21FdmVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvcmVhY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21vdXNlQnV0dG9ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2lucHV0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZm9jdXMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zZWxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2RvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy93aW5kb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvYm9keS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9saW5rLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2lucHV0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2J1dHRvbi5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9zZWxlY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvY2hlY2tib3guanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvdGV4dGFyZWEuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9qdXh0YXBvc2Uvc3JjL2p1eHRhcG9zZS5qcyIsICJub2RlX21vZHVsZXMvanV4dGFwb3NlL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdGFnTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvbGV2ZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL21ldGhvZHMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvaGVhZGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9rZXlDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9lbmNvZGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY2hhcmFjdGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9zdGF0dXNDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9jb250ZW50VHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvc3RhdHVzTWVzc2FnZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvaHR0cC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy9hc3luY2hyb25vdXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvdXRpbGl0aWVzL2FqYXguanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2NvbnRlbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9zcGVjaWFsU3ltYm9scy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy91dGlsaXRpZXMvcnVsZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL2JuZi9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3V0aWxpdGllcy90b2tlbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9jb21tb24vbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvd2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9ibmYvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvYmFzaWMvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9weXRob25TdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9weXRob25TdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9iYXNpYy9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lL2NTdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvbWlkZGxlT2YvY1N0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jc3MvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ibmYvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL21peGlucy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnNlVHJlZS92ZXJ0aWNhbEJyYW5jaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvdXRpbGl0aWVzL3Rva2Vucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUvaG9yaXpvbnRhbEJyYW5jaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2NoaWxkTm9kZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnNlVHJlZS9ub25UZXJtaW5hbE5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9ydWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL3Rlcm1pbmFsTm9kZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS90ZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2Vwc2lsb25Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL3Rlcm1pbmFsL2Vwc2lsb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvdGVybWluYWwvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL3dpbGRjYXJkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2VuZE9mTGluZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvdGVybWluYWwvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0Q2hvaWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9wYXJ0Q2hvaWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9xdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvcGFyc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL2RlZmluaXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi90ZXJtaW5hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9ub25UZXJtaW5hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvc2VxdWVuY2VPZlBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL29wYWNpdHlNb2RpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL25vV2hpdGVzcGFjZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvdGVybWluYWwvbm9XaGl0ZXNwYWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL25vV2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvY2FsbEFoZWFkTW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvdGVybWluYWwvcmVndWxhckV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUvc3RhcnRPZkNvbnRlbnROb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zdGFydE9mQ29udGVudFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL29wdGlvbmFsUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvb25lT25lT3JNb3JlUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3plcm9PbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub25UZXJtaW5hbE5vZGVNYXAuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9taXhpbnMvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZXJyb3IuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vc3RyaW5nTGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9kb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL3BhcnRDaG9pY2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3BhcnRDaG9pY2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3F1YW50aWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL2RlZmluaXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9kZWZpbml0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvdGVybWluYWxQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3N0cmluZ0xpdGVyYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL25vblRlcm1pbmFsUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3NlcXVlbmNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9vcGFjaXR5TW9kaWZpZXJSdWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9vcGFjaXR5TW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9jYWxsQWhlYWRNb2RpZmllclJ1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL2NhbGxBaGVhZE1vZGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9yZWd1bGFyRXhwcmVzc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9xdWFudGlmaWVyUnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvb3B0aW9uYWxRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL3N0YXJ0T2ZDb250ZW50UGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvc3RhcnRPZkNvbnRlbnRQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9vbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi96ZXJvT3JNb3JlUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ydWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvYm5mL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvYmFzaWMvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9jb21tb24vcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9iYXNpYy9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL2JuZi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1xdWVyeS9zcmMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3NwcmVhZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3N1YkV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL2VudHJpZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1xdWVyeS9zcmMvZXhwcmVzc2lvbi9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL2V4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9kZWNsYXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvZGVjbGFyYXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0cy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvbWVkaWEuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL21lZGlhcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUva2V5ZnJhbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL2tleWZyYW1lcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUva2V5ZnJhbWVzcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9zdHlsZXMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzc05hbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS13aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktd2l0aC1zdHlsZS9zcmMvd2l0aFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvY3Vyc29ycy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2N1cnNvci5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9yb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvcm93cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9jb2x1bW4uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvY29sdW1ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvdXRpbGl0aWVzL3JlZmVyZW5jZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy91dGlsaXRpZXMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvY3VzdG9tRXZlbnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9taXhpbnMvZHJhZy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9taXhpbnMvZHJvcC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9lbGVtZW50L2RyYWcuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvZWxlbWVudC9kcm9wLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWRyYWctYW5kLWRyb3Avc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NpemVhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyL3ZlcnRpY2FsLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyL2hvcml6b250YWwuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2VsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvY29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvbGluZUluZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2NvbnRleHQvZmlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvYXN5bmNocm9ub3VzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy92ZXJpZnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvZ3JhbW1hck5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy92b2NhYnVsYXJ5TmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hci9kZWZhdWx0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9sZXhlci9leGFtcGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9wYXJzZXIvbm9uVGVybWluYWxOb2RlTWFwLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9wYXJzZXIvZXhhbXBsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2N5Y2xlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGlyZWN0ZWRHcmFwaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmVkdWNlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9ydWxlTmFtZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9jeWNsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9ub25Db25zdW1pbmcuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2VkZ2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcmVjdXJzaXZlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvbGFiZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL2RpcmVjdGVkR3JhcGguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ydWxlL3JlZHVjZWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9jcmVhdGVSZWR1Y2VkUnVsZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcHJlY2VkZW5jZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmVwZWF0ZWQvZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ub2RlL3JlcGVhdGVkL2luZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcmV3cml0ZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmV3cml0dGVuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9wYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3BhdGguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9kZWZpbml0aW9uL3Jld3JpdHRlbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3J1bGUvcmV3cml0dGVuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGVmaW5pdGlvbi9yZXBlYXRlZC9kaXJlY3RseS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9yZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvY3JlYXRlRGlyZWN0bHlSZXBlYXRlZFJ1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGVmaW5pdGlvbi9lcHNpbG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3BhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL25vblByb2R1Y2luZy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9jb21wbGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL29jY2x1ZGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL2NhbGxBaGVhZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9xdWFsaWZpZWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ydWxlL3JlcGVhdGVkL2luZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9jcmVhdGVJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2VsaW1pbmF0ZUxlZnRSZWN1cnNpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvcXVlcnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy90ZVgvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL3RlWC9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9mdXJ0bGUvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2Z1cnRsZS9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9wbGFpblRleHQvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL3BsYWluVGV4dC9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hclZvY2FidWxhcnkvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy90ZVgvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvdGVYL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvanNvbi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9mdXJ0bGUvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvZnVydGxlL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvbm9taW5hbC9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9wbGFpblRleHQvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvcGxhaW5UZXh0L3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hckJORi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvZ3JhbW1hci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvdm9jYWJ1bGFyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvbm9taW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy90eXBlc01hcC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvdmFsaWRhdGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hci9jb21iaW5lZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvbGV4ZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3V0aWxpdGllcy9wYXJzZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9maWxlQ29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9jb250ZXh0L3JlbGVhc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvbm9uVGVybWluYWxOb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvcGFzcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL3ppcC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL2FzeW5jLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3Bhc3Mvc2ltcGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3Bhc3MvZm9yd2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL2VxdWl2YWxlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9kZXBlbmRlbmN5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy92ZXJpZmljYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy90eXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZmlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2ZpbGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvbXVsdGlwbGVycy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdmVyc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2RpcmVjdG9yeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9uYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZmlsZU5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvbWl4aW5zL2JuZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9maWxlUGF0aC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9maWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9maWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2RlcGVuZGVuY3kuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy9zaG9ydGVuZWRWZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZGVwZW5kZW5jaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdXRpbGl0aWVzL3F1ZXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdXRpbGl0aWVzL3ZhbGlkYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvcHJvcGVydHlOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9tZXRhSlNPTi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9tZXRhSlNPTi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy92b2NhYnVsYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvcHJvamVjdC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3JlbGVhc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy9wcm9qZWN0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3JlbGVhc2VzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvdXRpbGl0aWVzL3JlbGVhc2VDb250ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2luZGV4LmpzIiwgInNyYy9lbGVtZW50cy5qcyIsICJzcmMvZWxlbWVudC9zdGVwLmpzIiwgInNyYy9leGNlcHRpb24uanMiLCAic3JjL3R5cGVzLmpzIiwgInNyYy9udWxsTm9kZS5qcyIsICJzcmMvY29uc3RhbnRzLmpzIiwgInNyYy91dGlsaXRpZXMvc3RyaW5nTGl0ZXJhbC5qcyIsICJzcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJzcmMvdXRpbGl0aWVzL3ByaW1pdGl2ZS5qcyIsICJzcmMvdXRpbGl0aWVzL3Rlcm0uanMiLCAic3JjL2VsZW1lbnQvc29tZS5qcyIsICJzcmMvZWxlbWVudC90ZXJtLmpzIiwgInNyYy9lbGVtZW50L3Rlcm1zLmpzIiwgInNyYy9lbGVtZW50L2xhYmVsLmpzIiwgInNyYy9lbGVtZW50L2Vycm9yLmpzIiwgInNyYy9lbGVtZW50L2V2ZXJ5LmpzIiwgInNyYy9lbGVtZW50L3JlZHVjZS5qcyIsICJzcmMvZWxlbWVudC90ZXJuYXJ5LmpzIiwgInNyYy9lbGVtZW50L3ZhcmlhYmxlLmpzIiwgInNyYy9lbGVtZW50L3ByaW1pdGl2ZS5qcyIsICJzcmMvZWxlbWVudC9yZWZlcmVuY2UuanMiLCAic3JjL2VsZW1lbnQvcHJvY2VkdXJlLmpzIiwgInNyYy9lbGVtZW50L25vZGVRdWVyeS5qcyIsICJzcmMvZWxlbWVudC9wYXJhbWV0ZXIuanMiLCAic3JjL2VsZW1lbnQvcGFyYW1ldGVycy5qcyIsICJzcmMvZWxlbWVudC9ub2Rlc1F1ZXJ5LmpzIiwgInNyYy9lbGVtZW50L2V4cHJlc3Npb24uanMiLCAic3JjL2NvbnRleHQvYmxvY2suanMiLCAic3JjL2VsZW1lbnQvcmV0dXJuQmxvY2suanMiLCAic3JjL2VsZW1lbnQvdGVybS9uZWdhdGVkLmpzIiwgInNyYy9lbGVtZW50L3Rlcm0vbG9naWNhbC5qcyIsICJzcmMvZWxlbWVudC90ZXJtL2JyYWNrZXRlZC5qcyIsICJzcmMvZWxlbWVudC9wcm9jZWR1cmVDYWxsLmpzIiwgInNyYy9lbGVtZW50L3Rlcm0vY29tcGFyaXNvbi5qcyIsICJzcmMvZWxlbWVudC9wYXJhbWV0ZXIvbmFtZWQuanMiLCAic3JjL2VsZW1lbnQvYXNzaWdubWVudC9hcnJheS5qcyIsICJzcmMvZWxlbWVudC9zdGF0ZW1lbnQvcmV0dXJuLmpzIiwgInNyYy9lbGVtZW50L3BhcmFtZXRlcnMvbmFtZWQuanMiLCAic3JjL25vZGVQcm9wZXJ0eS5qcyIsICJzcmMvcGFyYW1ldGVyTmFtZXMuanMiLCAic3JjL25vZGVQcm9wZXJ0aWVzLmpzIiwgInNyYy9lbGVtZW50L2Fzc2lnbm1lbnQvb2JqZWN0LmpzIiwgInNyYy9lbGVtZW50L3Byb2NlZHVyZS9hbm9ueW1vdXMuanMiLCAic3JjL2VsZW1lbnQvYXNzaWdubWVudC92YXJpYWJsZS5qcyIsICJzcmMvZWxlbWVudC9hc3NpZ25tZW50cy92YXJpYWJsZS5qcyIsICJzcmMvZWxlbWVudC9kZWNsYXJhdGlvbi9wcm9jZWR1cmUuanMiLCAic3JjL3ByZWFtYmxlLmpzIiwgInNyYy9mdXJ0bGUvbGV4ZXIuanMiLCAic3JjL3J1bGVOYW1lcy5qcyIsICJzcmMvbm9kZS9zdGVwLmpzIiwgInNyYy9ub2RlL3NvbWUuanMiLCAic3JjL25vZGUvdGVybS5qcyIsICJzcmMvbm9kZS90ZXJtcy5qcyIsICJzcmMvbm9kZS9ldmVyeS5qcyIsICJzcmMvdG9rZW5UeXBlcy5qcyIsICJzcmMvbm9kZS9sYWJlbC5qcyIsICJzcmMvbm9kZS9lcnJvci5qcyIsICJzcmMvbm9kZS9yZWR1Y2UuanMiLCAic3JjL25vZGUvdGVybmFyeS5qcyIsICJzcmMvbm9kZS9kb2N1bWVudC5qcyIsICJzcmMvbm9kZS92YXJpYWJsZS5qcyIsICJzcmMvbm9kZS9ub25zZW5zZS5qcyIsICJzcmMvbm9kZS9wcmltaXRpdmUuanMiLCAic3JjL25vZGUvcmVmZXJlbmNlLmpzIiwgInNyYy9ub2RlL3BhcmFtZXRlci5qcyIsICJzcmMvbm9kZS9ub2RlUXVlcnkuanMiLCAic3JjL25vZGUvZXhwcmVzc2lvbi5qcyIsICJzcmMvbm9kZS9wYXJhbWV0ZXJzLmpzIiwgInNyYy9ub2RlL25vZGVzUXVlcnkuanMiLCAic3JjL25vZGUvcmV0dXJuQmxvY2suanMiLCAic3JjL25vZGUvdGVybS9sb2dpY2FsLmpzIiwgInNyYy9ub2RlL3Rlcm0vbmVnYXRlZC5qcyIsICJzcmMvbm9kZS9wcm9jZWR1cmVDYWxsLmpzIiwgInNyYy9ub2RlL3Rlcm0vYnJhY2tldGVkLmpzIiwgInNyYy9ub2RlL3Rlcm0vY29tcGFyaXNvbi5qcyIsICJzcmMvbm9kZS9wYXJhbWV0ZXIvbmFtZWQuanMiLCAic3JjL25vZGUvcGFyYW1ldGVycy9uYW1lZC5qcyIsICJzcmMvbm9kZS9zdGF0ZW1lbnQuanMiLCAic3JjL25vZGUvc3RhdGVtZW50L3JldHVybi5qcyIsICJzcmMvbm9kZS9hc3NpZ25tZW50LmpzIiwgInNyYy9ub2RlL2Fzc2lnbm1lbnQvYXJyYXkuanMiLCAic3JjL25vZGUvYXNzaWdubWVudC9vYmplY3QuanMiLCAic3JjL25vZGUvcHJvY2VkdXJlLmpzIiwgInNyYy9ub2RlL3Byb2NlZHVyZS9hbm95bW91cy5qcyIsICJzcmMvbm9kZS9hc3NpZ25tZW50L3ZhcmlhYmxlLmpzIiwgInNyYy9ub2RlL2Fzc2lnbm1lbnRzL3ZhcmlhYmxlLmpzIiwgInNyYy9ub2RlL2RlY2xhcmF0aW9uLmpzIiwgInNyYy9ub2RlL2RlY2xhcmF0aW9uL3Byb2NlZHVyZS5qcyIsICJzcmMvbm9uVGVybWluYWxOb2RlTWFwLmpzIiwgInNyYy9mdXJ0bGUvcGFyc2VyLmpzIiwgInNyYy91dGlsaXRpZXMvZWxlbWVudC5qcyIsICJzcmMvcHJvY2Vzcy92ZXJpZnkuanMiLCAic3JjL3V0aWxpdGllcy9sZXhlcnMuanMiLCAic3JjL3V0aWxpdGllcy9wYXJzZXJzLmpzIiwgInNyYy91dGlsaXRpZXMvZnVydGxlLmpzIiwgInNyYy9jb250ZXh0L2ZpbGUvZnVydGxlLmpzIiwgInNyYy91dGlsaXRpZXMvdGVybXMuanMiLCAic3JjL2luZGV4LmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvc3ViSGVhZGluZy5qcyIsICJzcmMvZXhhbXBsZS92aWV3L2Rpdi9zaXplYWJsZS5qcyIsICJzcmMvZXhhbXBsZS92aWV3L3RleHRhcmVhLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvYm5mLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvaW5wdXQvcnVsZU5hbWUuanMiLCAic3JjL2V4YW1wbGUvdmlldy90ZXh0YXJlYS90b2tlbnMuanMiLCAic3JjL2V4YW1wbGUvdmlldy90ZXh0YXJlYS9jb250ZW50LmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvcGFyc2VUcmVlLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvbGV4aWNhbEVudHJpZXMuanMiLCAic3JjL2V4YW1wbGUvdmlldy5qcyIsICJzcmMvZXhhbXBsZS5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9mZnNldCB7XG4gIGNvbnN0cnVjdG9yKHRvcCwgbGVmdCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21ET01FbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCB9ID0gZG9tRWxlbWVudCxcbiAgICAgICAgICB0b3AgPSBvZmZzZXRUb3AsICAvLy9cbiAgICAgICAgICBsZWZ0ID0gb2Zmc2V0TGVmdCwgIC8vL1xuICAgICAgICAgIG9mZnNldCA9IG5ldyBPZmZzZXQodG9wLCBsZWZ0KTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm91bmRzIHtcbiAgY29uc3RydWN0b3IodG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKSB7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG5cbiAgZ2V0UmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHQ7XG4gIH1cblxuICBnZXRCb3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgY29uc3Qgd2lkdGggPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCk7XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBnZXRIZWlnaHQoKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdGhpcy50b3ApO1xuXG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuICBcbiAgc2V0VG9wKHRvcCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICB9XG5cbiAgc2V0TGVmdChsZWZ0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgfVxuXG4gIHNldFJpZ2h0KHJpZ2h0KSB7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB9XG5cbiAgc2V0Qm90dG9tKGJvdHRvbSkge1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG5cbiAgYXJlT3ZlcmxhcHBpbmcoYm91bmRzKSB7XG4gICAgY29uc3QgYm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICAgIHJpZ2h0ID0gYm91bmRzLmdldFJpZ2h0KCksXG4gICAgICAgICAgbGVmdCA9IGJvdW5kcy5nZXRMZWZ0KCksXG4gICAgICAgICAgdG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICAgIG92ZXJsYXBwaW5nID0gKCh0aGlzLnRvcCA8IGJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDwgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IHRvcCkpO1xuXG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nO1xuICB9XG5cbiAgYXJlT3ZlcmxhcHBpbmdCeVRvcEFuZExlZnQodG9wLCBsZWZ0KSB7XG4gICAgY29uc3Qgb3ZlcmxhcHBpbmcgPSAoKHRoaXMudG9wIDw9IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDw9IGxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IHRvcCkpO1xuXG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21ET01FbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHBhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCB9ID0gd2luZG93LFxuICAgICAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgd2luZG93U2Nyb2xsVG9wID0gcGFnZVlPZmZzZXQsIC8vL1xuICAgICAgICAgIHdpbmRvd1Njcm9sbExlZnQgPSBwYWdlWE9mZnNldCwgIC8vL1xuICAgICAgICAgIHRvcCA9IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyB3aW5kb3dTY3JvbGxUb3AsXG4gICAgICAgICAgbGVmdCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgd2luZG93U2Nyb2xsTGVmdCxcbiAgICAgICAgICByaWdodCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5yaWdodCArIHdpbmRvd1Njcm9sbExlZnQsXG4gICAgICAgICAgYm90dG9tID0gYm91bmRpbmdDbGllbnRSZWN0LmJvdHRvbSArIHdpbmRvd1Njcm9sbFRvcCxcbiAgICAgICAgICBib3VuZHMgPSBuZXcgQm91bmRzKHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSk7XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ub3BMZWZ0V2lkdGhBbmRIZWlnaHQodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0LFxuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoLFxuICAgICAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHModG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKTtcblxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7IHJldHVybiBhcnJheVswXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheTEsIGFycmF5MikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheTEsIGFycmF5Mik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnQoYXJyYXkxLCBhcnJheTIsIHRlc3QpIHtcbiAgYXJyYXkxID0gWyAuLi5hcnJheTEgXTsgLy8vXG5cbiAgYXJyYXkyLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheTEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGFycmF5LCBlbGVtZW50KSA9PiB7XG4gICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZWxlbWVudCk7ICAvLy9cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSwgW10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3VhcmFudGVlKGFycmF5T3JFbGVtZW50KSB7XG4gIGFycmF5T3JFbGVtZW50ID0gYXJyYXlPckVsZW1lbnQgfHwgW107XG5cbiAgcmV0dXJuIChhcnJheU9yRWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICBhcnJheU9yRWxlbWVudCA6XG4gICAgICAgICAgICAgIFthcnJheU9yRWxlbWVudF07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBGT1IgPSBcImZvclwiO1xuZXhwb3J0IGNvbnN0IEJPRFkgPSBcImJvZHlcIjtcbmV4cG9ydCBjb25zdCBOT05FID0gXCJub25lXCI7XG5leHBvcnQgY29uc3QgU1BBQ0UgPSBcIiBcIjtcbmV4cG9ydCBjb25zdCBDTEFTUyA9IFwiY2xhc3NcIjtcbmV4cG9ydCBjb25zdCBXSURUSCA9IFwid2lkdGhcIjtcbmV4cG9ydCBjb25zdCBCTE9DSyA9IFwiYmxvY2tcIjtcbmV4cG9ydCBjb25zdCBIRUlHSFQgPSBcImhlaWdodFwiO1xuZXhwb3J0IGNvbnN0IE9CSkVDVCA9IFwib2JqZWN0XCI7XG5leHBvcnQgY29uc3QgU1RSSU5HID0gXCJzdHJpbmdcIjtcbmV4cG9ydCBjb25zdCBESVNQTEFZID0gXCJkaXNwbGF5XCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuZXhwb3J0IGNvbnN0IERJU0FCTEVEID0gXCJkaXNhYmxlZFwiO1xuZXhwb3J0IGNvbnN0IEZVTkNUSU9OID0gXCJmdW5jdGlvblwiO1xuZXhwb3J0IGNvbnN0IFdJTERDQVJEID0gXCIqXCI7XG5leHBvcnQgY29uc3QgSFRNTF9GT1IgPSBcImh0bWxGb3JcIjtcbmV4cG9ydCBjb25zdCBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FID0gXCJjbGFzc05hbWVcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IFNWR19OQU1FU1BBQ0VfVVJJID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPUEVSVElFUyA9IFwiZGVmYXVsdFByb3BlcnRpZXNcIjtcbmV4cG9ydCBjb25zdCBJR05PUkVEX1BST1BFUlRJRVMgPSBcImlnbm9yZWRQcm9wZXJ0aWVzXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJPT0xFQU4gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKHRhcmdldCwgc291cmNlID0ge30pIHtcbiAgdGFyZ2V0ID0geyAgLy8vXG4gICAgLi4udGFyZ2V0XG4gIH07XG5cbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyAgLy8vXG5cbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W25hbWVdLFxuICAgICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW25hbWVdLFxuICAgICAgICAgIHRhcmdldEhhc093blByb3BlcnR5ID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpO1xuXG4gICAgdGFyZ2V0W25hbWVdID0gdGFyZ2V0SGFzT3duUHJvcGVydHkgP1xuICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZhbHVlcyh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU7IC8vL1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmUodGFyZ2V0LCBuYW1lcyA9IFtdKSB7XG4gIHRhcmdldCA9IHsgIC8vL1xuICAgIC4uLnRhcmdldFxuICB9O1xuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB0YXJnZXRIYXNPd25Qcm9wZXJ0eSA9IHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcblxuICAgIGlmICh0YXJnZXRIYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgZGVsZXRlIHRhcmdldFtuYW1lXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVWYWx1ZXModGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gIGNvbnN0IHRhcmdldFZhbHVlQm9vbGVhbiA9IGlzVmFsdWVCb29sZWFuKHRhcmdldFZhbHVlKSxcbiAgICAgICAgc291cmNlVmFsdWVCb29sZWFuID0gaXNWYWx1ZUJvb2xlYW4oc291cmNlVmFsdWUpLFxuICAgICAgICBjb21iaW5lZFZhbHVlID0gKHRhcmdldFZhbHVlQm9vbGVhbiAmJiBzb3VyY2VWYWx1ZUJvb2xlYW4pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgOiAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0YXJnZXRWYWx1ZX0gJHtzb3VyY2VWYWx1ZX1gO1xuXG4gIHJldHVybiBjb21iaW5lZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbHVlQm9vbGVhbih2YWx1ZSkge1xuICBjb25zdCB2YWx1ZUJvb2xlYW4gPSAodHlwZW9mIHZhbHVlID09PSBCT09MRUFOKTtcblxuICByZXR1cm4gdmFsdWVCb29sZWFuO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxDYXNlVG9TbmFrZUNhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKykvZywgKG1hdGNoLCBjaGFyYWN0ZXJzKSA9PiB7XG4gICAgY29uc3QgdXBwZXJDYXNlQ2hhcmFjdGVycyA9IGNoYXJhY3RlcnMudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBzbmFrZUNhc2VDaGFyYWN0ZXJzID0gYC0ke3VwcGVyQ2FzZUNoYXJhY3RlcnN9YDtcblxuICAgIHJldHVybiBzbmFrZUNhc2VDaGFyYWN0ZXJzO1xuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZHVGFnTmFtZSh0YWdOYW1lKSB7XG4gIHJldHVybiBzdmdUYWdOYW1lcy5pbmNsdWRlcyh0YWdOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZHQXR0cmlidXRlTmFtZShhdHRyaWJ1dGVOYW1lKSB7XG4gIHJldHVybiBzdmdBdHRyaWJ1dGVOYW1lcy5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICByZXR1cm4gaHRtbEF0dHJpYnV0ZU5hbWVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpO1xufVxuXG5jb25zdCBzdmdUYWdOYW1lcyA9IFtcbiAgICAgICAgXCJhbHRHbHlwaFwiLCBcImFuaW1hdGVcIiwgXCJhbmltYXRlQ29sb3JcIiwgXCJhbmltYXRlTW90aW9uXCIsIFwiYW5pbWF0ZVRyYW5zZm9ybVwiLCBcImFuaW1hdGlvblwiLCBcImF1ZGlvXCIsXG4gICAgICAgIFwiY2lyY2xlXCIsIFwiY2xpcFBhdGhcIiwgXCJjb2xvci1wcm9maWxlXCIsIFwiY3Vyc29yXCIsXG4gICAgICAgIFwiZGVmc1wiLCBcImRlc2NcIiwgXCJkaXNjYXJkXCIsXG4gICAgICAgIFwiZWxsaXBzZVwiLFxuICAgICAgICBcImZlQmxlbmRcIiwgXCJmZUNvbG9yTWF0cml4XCIsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLCBcImZlQ29tcG9zaXRlXCIsIFwiZmVDb252b2x2ZU1hdHJpeFwiLCBcImZlRGlmZnVzZUxpZ2h0aW5nXCIsIFwiZmVEaXNwbGFjZW1lbnRNYXBcIiwgXCJmZURpc3RhbnRMaWdodFwiLCBcImZlRHJvcFNoYWRvd1wiLCBcImZlRmxvb2RcIiwgXCJmZUZ1bmNBXCIsIFwiZmVGdW5jQlwiLCBcImZlRnVuY0dcIiwgXCJmZUZ1bmNSXCIsIFwiZmVHYXVzc2lhbkJsdXJcIiwgXCJmZUltYWdlXCIsIFwiZmVNZXJnZVwiLCBcImZlTWVyZ2VOb2RlXCIsIFwiZmVNb3JwaG9sb2d5XCIsIFwiZmVPZmZzZXRcIiwgXCJmZVBvaW50TGlnaHRcIiwgXCJmZVNwZWN1bGFyTGlnaHRpbmdcIiwgXCJmZVNwb3RMaWdodFwiLCBcImZlVGlsZVwiLCBcImZlVHVyYnVsZW5jZVwiLCBcImZpbHRlclwiLCBcImZvbnRcIiwgXCJmb250LWZhY2VcIiwgXCJmb250LWZhY2UtZm9ybWF0XCIsIFwiZm9udC1mYWNlLW5hbWVcIiwgXCJmb250LWZhY2UtdXJpXCIsIFwiZm9yZWlnbk9iamVjdFwiLFxuICAgICAgICBcImdcIiwgXCJnbHlwaFwiLCBcImdseXBoUmVmXCIsXG4gICAgICAgIFwiaGFuZGxlclwiLCBcImhhdGNoXCIsIFwiaGF0Y2hwYXRoXCIsIFwiaGtlcm5cIixcbiAgICAgICAgXCJpbWFnZVwiLCBcImxpbmVcIiwgXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgICAgICBcImxpc3RlbmVyXCIsXG4gICAgICAgIFwibWFya2VyXCIsIFwibWFza1wiLCBcIm1lc2hcIiwgXCJtZXNoZ3JhZGllbnRcIiwgXCJtZXNocGF0Y2hcIiwgXCJtZXNocm93XCIsIFwibWV0YWRhdGFcIiwgXCJtaXNzaW5nLWdseXBoXCIsIFwibXBhdGhcIixcbiAgICAgICAgXCJwYXRoXCIsIFwicGF0dGVyblwiLCBcInBvbHlnb25cIiwgXCJwb2x5bGluZVwiLCBcInByZWZldGNoXCIsXG4gICAgICAgIFwicmFkaWFsR3JhZGllbnRcIiwgXCJyZWN0XCIsXG4gICAgICAgIFwic2NyaXB0XCIsIFwic2V0XCIsIFwic29saWRjb2xvclwiLCBcInN0b3BcIiwgXCJzdHlsZVwiLCBcInN2Z1wiLCBcInN3aXRjaFwiLCBcInN5bWJvbFwiLFxuICAgICAgICBcInRicmVha1wiLCBcInRleHRcIiwgXCJ0ZXh0QXJlYVwiLCBcInRleHRQYXRoXCIsIFwidGl0bGVcIiwgXCJ0cmVmXCIsIFwidHNwYW5cIixcbiAgICAgICAgXCJ1bmtub3duXCIsIFwidXNlXCIsXG4gICAgICAgIFwidmlkZW9cIiwgXCJ2aWV3XCIsIFwidmtlcm5cIlxuICAgICAgXSxcbiAgICAgIHN2Z0F0dHJpYnV0ZU5hbWVzID0gW1xuICAgICAgICBcImFjY2VudC1oZWlnaHRcIiwgXCJhY2N1bXVsYXRlXCIsIFwiYWRkaXRpdmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJhbHBoYWJldGljXCIsIFwiYW1wbGl0dWRlXCIsIFwiYXJhYmljLWZvcm1cIiwgXCJhc2NlbnRcIiwgXCJhdHRyaWJ1dGVOYW1lXCIsIFwiYXR0cmlidXRlVHlwZVwiLCBcImF6aW11dGhcIixcbiAgICAgICAgXCJiYW5kd2lkdGhcIiwgXCJiYXNlRnJlcXVlbmN5XCIsIFwiYmFzZVByb2ZpbGVcIiwgXCJiYXNlbGluZS1zaGlmdFwiLCBcImJib3hcIiwgXCJiZWdpblwiLCBcImJpYXNcIiwgXCJieVwiLFxuICAgICAgICBcImNhbGNNb2RlXCIsIFwiY2FwLWhlaWdodFwiLCBcImNsaXBcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGlwLXBhdGhcIiwgXCJjbGlwLXJ1bGVcIiwgXCJjbGlwUGF0aFVuaXRzXCIsIFwiY29sb3JcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwiY29sb3ItcHJvZmlsZVwiLCBcImNvbG9yLXJlbmRlcmluZ1wiLCBcImNvbnRlbnRTY3JpcHRUeXBlXCIsIFwiY29udGVudFN0eWxlVHlwZVwiLCBcImNyb3Nzb3JpZ2luXCIsIFwiY3Vyc29yXCIsIFwiY3hcIiwgXCJjeVwiLFxuICAgICAgICBcImRcIiwgXCJkZWZhdWx0QWN0aW9uXCIsIFwiZGVzY2VudFwiLCBcImRpZmZ1c2VDb25zdGFudFwiLCBcImRpcmVjdGlvblwiLCBcImRpc3BsYXlcIiwgXCJkaXZpc29yXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJkb3dubG9hZFwiLCBcImR1clwiLCBcImR4XCIsIFwiZHlcIixcbiAgICAgICAgXCJlZGdlTW9kZVwiLCBcImVkaXRhYmxlXCIsIFwiZWxldmF0aW9uXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIiwgXCJlbmRcIiwgXCJldmVudFwiLCBcImV4cG9uZW50XCIsIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxuICAgICAgICBcImZpbGxcIiwgXCJmaWxsLW9wYWNpdHlcIiwgXCJmaWxsLXJ1bGVcIiwgXCJmaWx0ZXJcIiwgXCJmaWx0ZXJSZXNcIiwgXCJmaWx0ZXJVbml0c1wiLCBcImZsb29kLWNvbG9yXCIsIFwiZmxvb2Qtb3BhY2l0eVwiLCBcImZvY3VzSGlnaGxpZ2h0XCIsIFwiZm9jdXNhYmxlXCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXNpemUtYWRqdXN0XCIsIFwiZm9udC1zdHJldGNoXCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9ybWF0XCIsIFwiZnJcIiwgXCJmcm9tXCIsIFwiZnhcIiwgXCJmeVwiLFxuICAgICAgICBcImcxXCIsIFwiZzJcIiwgXCJnbHlwaC1uYW1lXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCIsIFwiZ2x5cGhSZWZcIiwgXCJncmFkaWVudFRyYW5zZm9ybVwiLCBcImdyYWRpZW50VW5pdHNcIixcbiAgICAgICAgXCJoYW5kbGVyXCIsIFwiaGFuZ2luZ1wiLCBcImhhdGNoQ29udGVudFVuaXRzXCIsIFwiaGF0Y2hVbml0c1wiLCBcImhlaWdodFwiLCBcImhvcml6LWFkdi14XCIsIFwiaG9yaXotb3JpZ2luLXhcIiwgXCJob3Jpei1vcmlnaW4teVwiLCBcImhyZWZcIiwgXCJocmVmbGFuZ1wiLFxuICAgICAgICBcImlkXCIsIFwiaWRlb2dyYXBoaWNcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIiwgXCJpblwiLCBcImluMlwiLCBcImluaXRpYWxWaXNpYmlsaXR5XCIsIFwiaW50ZXJjZXB0XCIsXG4gICAgICAgIFwia1wiLCBcImsxXCIsIFwiazJcIiwgXCJrM1wiLCBcIms0XCIsIFwia2VybmVsTWF0cml4XCIsIFwia2VybmVsVW5pdExlbmd0aFwiLCBcImtlcm5pbmdcIiwgXCJrZXlQb2ludHNcIiwgXCJrZXlTcGxpbmVzXCIsIFwia2V5VGltZXNcIixcbiAgICAgICAgXCJsZW5ndGhBZGp1c3RcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLCBcImxpZ2h0aW5nLWNvbG9yXCIsIFwibGltaXRpbmdDb25lQW5nbGVcIiwgXCJsb2NhbFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIiwgXCJtYXJrZXItbWlkXCIsIFwibWFya2VyLXN0YXJ0XCIsIFwibWFya2VySGVpZ2h0XCIsIFwibWFya2VyVW5pdHNcIiwgXCJtYXJrZXJXaWR0aFwiLCBcIm1hc2tcIiwgXCJtYXNrQ29udGVudFVuaXRzXCIsIFwibWFza1VuaXRzXCIsIFwibWF0aGVtYXRpY2FsXCIsIFwibWF4XCIsIFwibWVkaWFcIiwgXCJtZWRpYUNoYXJhY3RlckVuY29kaW5nXCIsIFwibWVkaWFDb250ZW50RW5jb2RpbmdzXCIsIFwibWVkaWFTaXplXCIsIFwibWVkaWFUaW1lXCIsIFwibWV0aG9kXCIsIFwibWluXCIsIFwibW9kZVwiLFxuICAgICAgICBcIm5hbWVcIiwgXCJuYXYtZG93blwiLCBcIm5hdi1kb3duLWxlZnRcIiwgXCJuYXYtZG93bi1yaWdodFwiLCBcIm5hdi1sZWZ0XCIsIFwibmF2LW5leHRcIiwgXCJuYXYtcHJldlwiLCBcIm5hdi1yaWdodFwiLCBcIm5hdi11cFwiLCBcIm5hdi11cC1sZWZ0XCIsIFwibmF2LXVwLXJpZ2h0XCIsIFwibnVtT2N0YXZlc1wiLFxuICAgICAgICBcIm9ic2VydmVyXCIsIFwib2Zmc2V0XCIsIFwib3BhY2l0eVwiLCBcIm9wZXJhdG9yXCIsIFwib3JkZXJcIiwgXCJvcmllbnRcIiwgXCJvcmllbnRhdGlvblwiLCBcIm9yaWdpblwiLCBcIm92ZXJmbG93XCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCIsXG4gICAgICAgIFwicGFub3NlLTFcIiwgXCJwYXRoXCIsIFwicGF0aExlbmd0aFwiLCBcInBhdHRlcm5Db250ZW50VW5pdHNcIiwgXCJwYXR0ZXJuVHJhbnNmb3JtXCIsIFwicGF0dGVyblVuaXRzXCIsIFwicGhhc2VcIiwgXCJwaXRjaFwiLCBcInBsYXliYWNrT3JkZXJcIiwgXCJwbGF5YmFja29yZGVyXCIsIFwicG9pbnRlci1ldmVudHNcIiwgXCJwb2ludHNcIiwgXCJwb2ludHNBdFhcIiwgXCJwb2ludHNBdFlcIiwgXCJwb2ludHNBdFpcIiwgXCJwcmVzZXJ2ZUFscGhhXCIsIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcInByaW1pdGl2ZVVuaXRzXCIsIFwicHJvcGFnYXRlXCIsXG4gICAgICAgIFwiclwiLCBcInJhZGl1c1wiLCBcInJlZlhcIiwgXCJyZWZZXCIsIFwicmVuZGVyaW5nLWludGVudFwiLCBcInJlcGVhdENvdW50XCIsIFwicmVwZWF0RHVyXCIsIFwicmVxdWlyZWRFeHRlbnNpb25zXCIsIFwicmVxdWlyZWRGZWF0dXJlc1wiLCBcInJlcXVpcmVkRm9udHNcIiwgXCJyZXF1aXJlZEZvcm1hdHNcIiwgXCJyZXN0YXJ0XCIsIFwicmVzdWx0XCIsIFwicm90YXRlXCIsIFwicnhcIiwgXCJyeVwiLFxuICAgICAgICBcInNjYWxlXCIsIFwic2VlZFwiLCBcInNoYXBlLXJlbmRlcmluZ1wiLCBcInNpZGVcIiwgXCJzbG9wZVwiLCBcInNuYXBzaG90VGltZVwiLCBcInNwYWNpbmdcIiwgXCJzcGVjdWxhckNvbnN0YW50XCIsIFwic3BlY3VsYXJFeHBvbmVudFwiLCBcInNwcmVhZE1ldGhvZFwiLCBcInNyY1wiLCBcInN0YXJ0T2Zmc2V0XCIsIFwic3RkRGV2aWF0aW9uXCIsIFwic3RlbWhcIiwgXCJzdGVtdlwiLCBcInN0aXRjaFRpbGVzXCIsIFwic3RvcC1jb2xvclwiLCBcInN0b3Atb3BhY2l0eVwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiLCBcInN0cmluZ1wiLCBcInN0cm9rZVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBcInN0cm9rZS1saW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVqb2luXCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiLCBcInN0eWxlXCIsIFwic3VyZmFjZVNjYWxlXCIsIFwic3luY0JlaGF2aW9yXCIsIFwic3luY0JlaGF2aW9yRGVmYXVsdFwiLCBcInN5bmNNYXN0ZXJcIiwgXCJzeW5jVG9sZXJhbmNlXCIsIFwic3luY1RvbGVyYW5jZURlZmF1bHRcIiwgXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICBcInRhYmxlVmFsdWVzXCIsIFwidGFyZ2V0XCIsIFwidGFyZ2V0WFwiLCBcInRhcmdldFlcIiwgXCJ0ZXh0LWFuY2hvclwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtcmVuZGVyaW5nXCIsIFwidGV4dExlbmd0aFwiLCBcInRpbWVsaW5lQmVnaW5cIiwgXCJ0aW1lbGluZWJlZ2luXCIsIFwidGl0bGVcIiwgXCJ0b1wiLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybUJlaGF2aW9yXCIsIFwidHlwZVwiLFxuICAgICAgICBcInUxXCIsIFwidTJcIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCIsIFwidW5pY29kZVwiLCBcInVuaWNvZGUtYmlkaVwiLCBcInVuaWNvZGUtcmFuZ2VcIiwgXCJ1bml0cy1wZXItZW1cIixcbiAgICAgICAgXCJ2LWFscGhhYmV0aWNcIiwgXCJ2LWhhbmdpbmdcIiwgXCJ2LWlkZW9ncmFwaGljXCIsIFwidi1tYXRoZW1hdGljYWxcIiwgXCJ2YWx1ZXNcIiwgXCJ2ZXJzaW9uXCIsIFwidmVydC1hZHYteVwiLCBcInZlcnQtb3JpZ2luLXhcIiwgXCJ2ZXJ0LW9yaWdpbi15XCIsIFwidmlld0JveFwiLCBcInZpZXdUYXJnZXRcIiwgXCJ2aXNpYmlsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIiwgXCJ3aWR0aHNcIiwgXCJ3b3JkLXNwYWNpbmdcIiwgXCJ3cml0aW5nLW1vZGVcIixcbiAgICAgICAgXCJ4XCIsIFwieC1oZWlnaHRcIiwgXCJ4MVwiLCBcIngyXCIsIFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICBcInlcIiwgXCJ5MVwiLCBcInkyXCIsIFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICBcInpcIiwgXCJ6b29tQW5kUGFuXCJcbiAgICAgIF0sXG4gICAgICBodG1sQXR0cmlidXRlTmFtZXMgPSBbXG4gICAgICAgIFwiYWNjZXB0XCIsIFwiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2Vzc0tleVwiLCBcImFjdGlvblwiLCBcImFsbG93XCIsIFwiYWxsb3dGdWxsU2NyZWVuXCIsIFwiYWxsb3dUcmFuc3BhcmVuY3lcIiwgXCJhbHRcIiwgXCJhc3luY1wiLCBcImF1dG9Db21wbGV0ZVwiLCBcImF1dG9Gb2N1c1wiLCBcImF1dG9QbGF5XCIsXG4gICAgICAgIFwiY2FwdHVyZVwiLCBcImNlbGxQYWRkaW5nXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjaGFsbGVuZ2VcIiwgXCJjaGFyU2V0XCIsIFwiY2hlY2tlZFwiLCBcImNpdGVcIiwgXCJjbGFzc0lEXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sU3BhblwiLCBcImNvbHNcIiwgXCJjb250ZW50XCIsIFwiY29udGVudEVkaXRhYmxlXCIsIFwiY29udGV4dE1lbnVcIiwgXCJjb250cm9sc1wiLCBcImNvb3Jkc1wiLCBcImNyb3NzT3JpZ2luXCIsXG4gICAgICAgIFwiZGF0YVwiLCBcImRhdGVUaW1lXCIsIFwiZGVmYXVsdFwiLCBcImRlZmVyXCIsIFwiZGlyXCIsIFwiZGlzYWJsZWRcIiwgXCJkb3dubG9hZFwiLCBcImRyYWdnYWJsZVwiLFxuICAgICAgICBcImVuY1R5cGVcIixcbiAgICAgICAgXCJmb3JtXCIsIFwiZm9ybUFjdGlvblwiLCBcImZvcm1FbmNUeXBlXCIsIFwiZm9ybU1ldGhvZFwiLCBcImZvcm1Ob1ZhbGlkYXRlXCIsIFwiZm9ybVRhcmdldFwiLCBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgIFwiaGVhZGVyc1wiLCBcImhlaWdodFwiLCBcImhpZGRlblwiLCBcImhpZ2hcIiwgXCJocmVmXCIsIFwiaHJlZkxhbmdcIiwgXCJodG1sRm9yXCIsIFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIFwiaWNvblwiLCBcImlkXCIsIFwiaW5wdXRNb2RlXCIsIFwiaW50ZWdyaXR5XCIsIFwiaXNcIixcbiAgICAgICAgXCJrZXlQYXJhbXNcIiwgXCJrZXlUeXBlXCIsIFwia2luZFwiLFxuICAgICAgICBcImxhYmVsXCIsIFwibGFuZ1wiLCBcImxpc3RcIiwgXCJsb29wXCIsIFwibG93XCIsXG4gICAgICAgIFwibWFuaWZlc3RcIiwgXCJtYXJnaW5IZWlnaHRcIiwgXCJtYXJnaW5XaWR0aFwiLCBcIm1heFwiLCBcIm1heExlbmd0aFwiLCBcIm1lZGlhXCIsIFwibWVkaWFHcm91cFwiLCBcIm1ldGhvZFwiLCBcIm1pblwiLCBcIm1pbkxlbmd0aFwiLCBcIm11bHRpcGxlXCIsIFwibXV0ZWRcIixcbiAgICAgICAgXCJuYW1lXCIsIFwibm9WYWxpZGF0ZVwiLCBcIm5vbmNlXCIsXG4gICAgICAgIFwib3BlblwiLCBcIm9wdGltdW1cIixcbiAgICAgICAgXCJwYXR0ZXJuXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJwb3N0ZXJcIiwgXCJwcmVsb2FkXCIsIFwicHJvZmlsZVwiLFxuICAgICAgICBcInJhZGlvR3JvdXBcIiwgXCJyZWFkT25seVwiLCBcInJlbFwiLCBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJyb2xlXCIsIFwicm93U3BhblwiLCBcInJvd3NcIixcbiAgICAgICAgXCJzYW5kYm94XCIsIFwic2NvcGVcIiwgXCJzY29wZWRcIiwgXCJzY3JvbGxpbmdcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCIsIFwic2hhcGVcIiwgXCJzaXplXCIsIFwic2l6ZXNcIiwgXCJzcGFuXCIsIFwic3BlbGxDaGVja1wiLCBcInNyY1wiLCBcInNyY0RvY1wiLCBcInNyY0xhbmdcIiwgXCJzcmNTZXRcIiwgXCJzdGFydFwiLCBcInN0ZXBcIiwgXCJzdHlsZVwiLCBcInN1bW1hcnlcIixcbiAgICAgICAgXCJ0YWJJbmRleFwiLCBcInRhcmdldFwiLCBcInRpdGxlXCIsIFwidHlwZVwiLFxuICAgICAgICBcInVzZU1hcFwiLFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJ3bW9kZVwiLFxuICAgICAgICBcIndyYXBcIlxuICAgICAgXTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEVsZW1lbnQoZWxlbWVudCwgZG9tRWxlbWVudCkge1xuICBlbGVtZW50LmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG4gIGRvbUVsZW1lbnQuX19lbGVtZW50X18gPSBlbGVtZW50OyAvLy9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgZGVzY2VuZGFudEVsZW1lbnRzID0gZWxlbWVudC5nZXREZXNjZW5kYW50RWxlbWVudHMoKSxcbiAgICAgICAgZWxlbWVudHMgPSBbXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAuLi5kZXNjZW5kYW50RWxlbWVudHNcbiAgICAgICAgXTtcblxuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZ2V0RE9NRWxlbWVudCgpO1xuXG4gICAgZGVsZXRlIGVsZW1lbnQuZG9tRWxlbWVudDtcblxuICAgIGRlbGV0ZSBkb21FbGVtZW50Ll9fZWxlbWVudF9fO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IGRlc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnQuZ2V0RGVzY2VuZGFudEVsZW1lbnRzKCksXG4gICAgICAgIGVsZW1lbnRzID0gW1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgLi4uZGVzY2VuZGFudEVsZW1lbnRzXG4gICAgICAgIF07XG5cbiAgZWxlbWVudHMucmV2ZXJzZSgpOyAvLy9cblxuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgZWxlbWVudC5kaWRNb3VudCAmJiBlbGVtZW50LmRpZE1vdW50KCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudEVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50LmdldERlc2NlbmRhbnRFbGVtZW50cygpLFxuICAgICAgICBlbGVtZW50cyA9IFtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIC4uLmRlc2NlbmRhbnRFbGVtZW50c1xuICAgICAgICBdO1xuXG4gIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICBlbGVtZW50LndpbGxVbm1vdW50ICYmIGVsZW1lbnQud2lsbFVubW91bnQoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29uc3RydWN0RWxlbWVudCxcbiAgZGVzdHJveUVsZW1lbnQsXG4gIG1vdW50RWxlbWVudCxcbiAgdW5tb3VudEVsZW1lbnRcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHB1c2ggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBXSUxEQ0FSRCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGRvbUVsZW1lbnRzKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnRzV2l0aEVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXMoZG9tRWxlbWVudHMsIChkb21FbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKChkb21FbGVtZW50Ll9fZWxlbWVudF9fKSkgeyAvLy9cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGVsZW1lbnRzID0gZG9tRWxlbWVudHNXaXRoRWxlbWVudHMubWFwKChkb21FbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvbUVsZW1lbnQuX19lbGVtZW50X187IC8vL1xuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUoZG9tTm9kZSwgaGVpZ2h0LCBhc2NlbmRhbnRET01Ob2RlcyA9IFtdKSB7XG4gIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IGRvbU5vZGUucGFyZW50RWxlbWVudDsgIC8vL1xuXG4gICAgaWYgKHBhcmVudERPTU5vZGUgIT09IG51bGwpIHtcbiAgICAgIGFzY2VuZGFudERPTU5vZGVzLnB1c2gocGFyZW50RE9NTm9kZSk7XG5cbiAgICAgIGhlaWdodC0tO1xuXG4gICAgICBhc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKHBhcmVudERPTU5vZGUsIGhlaWdodCwgYXNjZW5kYW50RE9NTm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhc2NlbmRhbnRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoLCBkZXNjZW5kYW50RE9NTm9kZXMgPSBbXSkge1xuICBpZiAoZGVwdGggPiAwKSB7XG4gICAgY29uc3QgY2hpbGRET01Ob2RlcyA9IGRvbU5vZGUuY2hpbGROb2RlczsgIC8vL1xuXG4gICAgcHVzaChkZXNjZW5kYW50RE9NTm9kZXMsIGNoaWxkRE9NTm9kZXMpO1xuXG4gICAgZGVwdGgtLTtcblxuICAgIGNoaWxkRE9NTm9kZXMuZm9yRWFjaCgoY2hpbGRET01Ob2RlKSA9PiB7XG4gICAgICBkZXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShjaGlsZERPTU5vZGUsIGRlcHRoLCBkZXNjZW5kYW50RE9NTm9kZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzQnlTZWxlY3Rvcihkb21Ob2Rlcywgc2VsZWN0b3IpIHtcbiAgY29uc3QgZmlsdGVyZWRET01Ob2RlcyA9IGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCAoZG9tTm9kZSkgPT4ge1xuICAgIGlmIChkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKGRvbU5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvbU5vZGVNYXRjaGVzU2VsZWN0b3IoZG9tTm9kZSwgc2VsZWN0b3IpIHtcbiAgY29uc3QgZG9tTm9kZVR5cGUgPSBkb21Ob2RlLm5vZGVUeXBlOyAvLy9cblxuICBzd2l0Y2ggKGRvbU5vZGVUeXBlKSB7XG4gICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvbU5vZGU7IC8vL1xuXG4gICAgICByZXR1cm4gZG9tRWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCB0ZXN0KSB7XG4gIGNvbnN0IGZpbHRlcmVkRE9NTm9kZXMgPSBbXSxcbiAgICAgICAgZG9tTm9kZXNMZW5ndGggPSBkb21Ob2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRvbU5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZG9tTm9kZSA9IGRvbU5vZGVzW2luZGV4XSxcbiAgICAgICAgICByZXN1bHQgPSB0ZXN0KGRvbU5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgZmlsdGVyZWRET01Ob2Rlcy5wdXNoKGRvbU5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZERPTU5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFdJTERDQVJEIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG9tTm9kZU1hdGNoZXNTZWxlY3RvciwgZWxlbWVudHNGcm9tRE9NRWxlbWVudHMsIGZpbHRlckRPTU5vZGVzQnlTZWxlY3RvciwgYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZSwgZGVzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2RvbVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwYXJlbnRFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwYXJlbnRET01FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7IC8vL1xuXG4gIGlmIChwYXJlbnRET01FbGVtZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKHBhcmVudERPTUVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgIGNvbnN0IHBhcmVudERPTUVsZW1lbnRzID0gW1xuICAgICAgICAgICAgICBwYXJlbnRET01FbGVtZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGFyZW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhwYXJlbnRET01FbGVtZW50cyksXG4gICAgICAgICAgICBmaXJzdFBhcmVudEVsZW1lbnQgPSBmaXJzdChwYXJlbnRFbGVtZW50cyk7XG5cbiAgICAgIHBhcmVudEVsZW1lbnQgPSBmaXJzdFBhcmVudEVsZW1lbnQgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50RWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkRWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBjb25zdCBjaGlsZERPTU5vZGVzID0gdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXMsIC8vL1xuICAgICAgICBjaGlsZERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGNoaWxkRE9NTm9kZXMsIHNlbGVjdG9yKSxcbiAgICAgICAgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGNoaWxkRE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBjaGlsZEVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bUhlaWdodCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IGhlaWdodCA9IG1heGltdW1IZWlnaHQsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGFzY2VuZGFudERPTU5vZGVzID0gYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShkb21Ob2RlLCBoZWlnaHQpLFxuICAgICAgICBhc2NlbmRhbnRET01FbGVtZW50cyA9IGZpbHRlckRPTU5vZGVzQnlTZWxlY3Rvcihhc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBhc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGFzY2VuZGFudERPTUVsZW1lbnRzKTtcblxuICByZXR1cm4gYXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bURlcHRoID0gSW5maW5pdHkpIHtcbiAgY29uc3QgZGVwdGggPSBtYXhpbXVtRGVwdGgsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGRlc2NlbmRhbnRET01Ob2RlcyA9IGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoKSxcbiAgICAgICAgZGVzY2VuZGFudERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGRlc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhkZXNjZW5kYW50RE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBkZXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0U2libGluZ0VsZW1lbnQoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBsZXQgbmV4dFNpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBuZXh0U2libGluZ0RPTU5vZGUgPSB0aGlzLmRvbUVsZW1lbnQubmV4dFNpYmxpbmc7IC8vL1xuXG4gIGlmICgobmV4dFNpYmxpbmdET01Ob2RlICE9PSBudWxsKSAmJiBkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKG5leHRTaWJsaW5nRE9NTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgbmV4dFNpYmxpbmdFbGVtZW50ID0gbmV4dFNpYmxpbmdET01Ob2RlLl9fZWxlbWVudF9fIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gbmV4dFNpYmxpbmdFbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwcmV2aW91c1NpYmxpbmdET01Ob2RlID0gdGhpcy5kb21FbGVtZW50LnByZXZpb3VzU2libGluZzsgIC8vL1xuXG4gIGlmICgocHJldmlvdXNTaWJsaW5nRE9NTm9kZSAhPT0gbnVsbCkgJiYgZG9tTm9kZU1hdGNoZXNTZWxlY3RvcihwcmV2aW91c1NpYmxpbmdET01Ob2RlLCBzZWxlY3RvcikpIHtcbiAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gcHJldmlvdXNTaWJsaW5nRE9NTm9kZS5fX2VsZW1lbnRfXyB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzU2libGluZ0VsZW1lbnQ7XG59XG5cbmNvbnN0IGVsZW1lbnRNaXhpbnMgPSB7XG4gIGdldFBhcmVudEVsZW1lbnQsXG4gIGdldENoaWxkRWxlbWVudHMsXG4gIGdldEFzY2VuZGFudEVsZW1lbnRzLFxuICBnZXREZXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudE1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE9mZnNldCBmcm9tIFwiLi9vZmZzZXRcIjtcbmltcG9ydCBCb3VuZHMgZnJvbSBcIi4vYm91bmRzXCI7XG5cbmltcG9ydCB7IGNvbnN0cnVjdEVsZW1lbnQsIGRlc3Ryb3lFbGVtZW50IH0gZnJvbSBcIi4vdXRpbGl0aWVzL2VsZW1lbnRcIjtcbmltcG9ydCB7IGdldFBhcmVudEVsZW1lbnQsIGdldEFzY2VuZGFudEVsZW1lbnRzLCBnZXROZXh0U2libGluZ0VsZW1lbnQsIGdldFByZXZpb3VzU2libGluZ0VsZW1lbnQgfSBmcm9tIFwiLi9taXhpbnMvZWxlbWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcywgLy8vXG4gICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpOyAvLy9cblxuICAgIGNvbnN0cnVjdEVsZW1lbnQoZWxlbWVudCwgZG9tRWxlbWVudCk7XG4gIH1cblxuICBnZXRET01FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gT2Zmc2V0LmZyb21ET01FbGVtZW50KHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IEJvdW5kcy5mcm9tRE9NRWxlbWVudCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50Lm9mZnNldFdpZHRoOyB9ICAvLy9cblxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyB9ICAvLy9cblxuICBnZXRUZXh0KCkge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuZG9tRWxlbWVudC5ub2RlVmFsdWUsXG4gICAgICAgICAgdGV4dCA9IG5vZGVWYWx1ZTsgLy8vXG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHNldFRleHQodGV4dCkge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRleHQ7IC8vL1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lm5vZGVWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIGFwcGVuZFRvKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5hcHBlbmQodGhpcyk7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgcmVtb3ZlRnJvbShwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucmVtb3ZlKHRoaXMpOyB9XG5cbiAgaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSwgLy8vXG4gICAgICAgICAgc2libGluZ0RPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSwgLy8vXG4gICAgICAgICAgc2libGluZ0RPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50Lm5leHRTaWJsaW5nKTsgIC8vL1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgZGVzdHJveUVsZW1lbnQoZWxlbWVudCk7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0RWxlbWVudC5wcm90b3R5cGUsIHtcbiAgZ2V0UGFyZW50RWxlbWVudCxcbiAgZ2V0QXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0RWxlbWVudCBmcm9tIFwiLi4vdGV4dEVsZW1lbnRcIjtcblxuaW1wb3J0IHsgU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmFsc2V5RWxlbWVudHMoZWxlbWVudHMpIHtcbiAgZWxlbWVudHMgPSBlbGVtZW50cy5yZWR1Y2UoKGVsZW1lbnRzLCBlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gIGVsZW1lbnRzID0gZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiB7ICAvLy9cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFNUUklORykge1xuICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQsICAvLy9cbiAgICAgICAgICAgIHRleHRFbGVtZW50ID0gbmV3IFRleHRFbGVtZW50KHRleHQpO1xuXG4gICAgICBlbGVtZW50ID0gdGV4dEVsZW1lbnQ7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcblxuICByZXR1cm4gZWxlbWVudHM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDVVRfRVZFTlRfVFlQRSA9IFwiY3V0XCI7XG5leHBvcnQgY29uc3QgQ09QWV9FVkVOVF9UWVBFID0gXCJjb3B5XCI7XG5leHBvcnQgY29uc3QgQkxVUl9FVkVOVF9UWVBFID0gXCJibHVyXCI7XG5leHBvcnQgY29uc3QgRVJST1JfRVZFTlRfVFlQRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBQQVNURV9FVkVOVF9UWVBFID0gXCJwYXN0ZVwiO1xuZXhwb3J0IGNvbnN0IFdIRUVMX0VWRU5UX1RZUEUgPSBcIndoZWVsXCI7XG5leHBvcnQgY29uc3QgSU5QVVRfRVZFTlRfVFlQRSA9IFwiaW5wdXRcIjtcbmV4cG9ydCBjb25zdCBGT0NVU19FVkVOVF9UWVBFID0gXCJmb2N1c1wiO1xuZXhwb3J0IGNvbnN0IENMSUNLX0VWRU5UX1RZUEUgPSBcImNsaWNrXCI7XG5leHBvcnQgY29uc3QgS0VZVVBfRVZFTlRfVFlQRSA9IFwia2V5dXBcIjtcbmV4cG9ydCBjb25zdCBTRUxFQ1RfRVZFTlRfVFlQRSA9IFwic2VsZWN0XCI7XG5leHBvcnQgY29uc3QgQ0hBTkdFX0VWRU5UX1RZUEUgPSBcImNoYW5nZVwiO1xuZXhwb3J0IGNvbnN0IFJFU0laRV9FVkVOVF9UWVBFID0gXCJyZXNpemVcIjtcbmV4cG9ydCBjb25zdCBTQ1JPTExfRVZFTlRfVFlQRSA9IFwic2Nyb2xsXCI7XG5leHBvcnQgY29uc3QgS0VZRE9XTl9FVkVOVF9UWVBFID0gXCJrZXlkb3duXCI7XG5leHBvcnQgY29uc3QgTU9VU0VVUF9FVkVOVF9UWVBFID0gXCJtb3VzZXVwXCI7XG5leHBvcnQgY29uc3QgQVVYQ0xJQ0tfRVZFTlRfVFlQRSA9IFwiYXV4Y2xpY2tcIjtcbmV4cG9ydCBjb25zdCBNT1VTRU9VVF9FVkVOVF9UWVBFID0gXCJtb3VzZW91dFwiO1xuZXhwb3J0IGNvbnN0IERCTENMSUNLX0VWRU5UX1RZUEUgPSBcImRibGNsaWNrXCI7XG5leHBvcnQgY29uc3QgVE9VQ0hFTkRfRVZFTlRfVFlQRSA9IFwidG91Y2hlbmRcIjtcbmV4cG9ydCBjb25zdCBUT1VDSE1PVkVfRVZFTlRfVFlQRSA9IFwidG91Y2htb3ZlXCI7XG5leHBvcnQgY29uc3QgTU9VU0VPVkVSX0VWRU5UX1RZUEUgPSBcIm1vdXNlb3ZlclwiO1xuZXhwb3J0IGNvbnN0IE1PVVNFRE9XTl9FVkVOVF9UWVBFID0gXCJtb3VzZWRvd25cIjtcbmV4cG9ydCBjb25zdCBNT1VTRU1PVkVfRVZFTlRfVFlQRSA9IFwibW91c2Vtb3ZlXCI7XG5leHBvcnQgY29uc3QgVE9VQ0hTVEFSVF9FVkVOVF9UWVBFID0gXCJ0b3VjaHN0YXJ0XCI7XG5leHBvcnQgY29uc3QgQ09OVEVYVE1FTlVfRVZFTlRfVFlQRSA9IFwiY29udGV4dG1lbnVcIjtcbmV4cG9ydCBjb25zdCBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRSA9IFwic2VsZWN0aW9uY2hhbmdlXCI7XG5leHBvcnQgY29uc3QgRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFID0gXCJmdWxsc2NyZWVuY2hhbmdlXCI7XG5leHBvcnQgY29uc3QgVU5IQU5ETEVEUkVKRUNUSU9OX0VWRU5UX1RZUEUgPSBcInVuaGFuZGxlZHJlamVjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIENVVF9FVkVOVF9UWVBFLFxuICBDT1BZX0VWRU5UX1RZUEUsXG4gIEJMVVJfRVZFTlRfVFlQRSxcbiAgRVJST1JfRVZFTlRfVFlQRSxcbiAgUEFTVEVfRVZFTlRfVFlQRSxcbiAgV0hFRUxfRVZFTlRfVFlQRSxcbiAgSU5QVVRfRVZFTlRfVFlQRSxcbiAgRk9DVVNfRVZFTlRfVFlQRSxcbiAgQ0xJQ0tfRVZFTlRfVFlQRSxcbiAgS0VZVVBfRVZFTlRfVFlQRSxcbiAgU0VMRUNUX0VWRU5UX1RZUEUsXG4gIENIQU5HRV9FVkVOVF9UWVBFLFxuICBSRVNJWkVfRVZFTlRfVFlQRSxcbiAgU0NST0xMX0VWRU5UX1RZUEUsXG4gIEtFWURPV05fRVZFTlRfVFlQRSxcbiAgTU9VU0VVUF9FVkVOVF9UWVBFLFxuICBBVVhDTElDS19FVkVOVF9UWVBFLFxuICBNT1VTRU9VVF9FVkVOVF9UWVBFLFxuICBEQkxDTElDS19FVkVOVF9UWVBFLFxuICBUT1VDSEVORF9FVkVOVF9UWVBFLFxuICBUT1VDSE1PVkVfRVZFTlRfVFlQRSxcbiAgTU9VU0VPVkVSX0VWRU5UX1RZUEUsXG4gIE1PVVNFRE9XTl9FVkVOVF9UWVBFLFxuICBNT1VTRU1PVkVfRVZFTlRfVFlQRSxcbiAgVE9VQ0hTVEFSVF9FVkVOVF9UWVBFLFxuICBDT05URVhUTUVOVV9FVkVOVF9UWVBFLFxuICBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRSxcbiAgRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFLFxuICBVTkhBTkRMRURSRUpFQ1RJT05fRVZFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VhcmFudGVlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgY29tYmluZSwgcHJ1bmUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL29iamVjdFwiO1xuaW1wb3J0IHsgY2FtZWxDYXNlVG9TbmFrZUNhc2UgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgaXNIVE1MQXR0cmlidXRlTmFtZSwgaXNTVkdBdHRyaWJ1dGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9uYW1lXCI7XG5pbXBvcnQgeyByZW1vdmVGYWxzZXlFbGVtZW50cywgcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9lbGVtZW50c1wiO1xuaW1wb3J0IHsgREJMQ0xJQ0tfRVZFTlRfVFlQRSwgU0VMRUNUSU9OQ0hBTkdFX0VWRU5UX1RZUEUsIEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5pbXBvcnQgeyBGT1IsIENMQVNTLCBPQkpFQ1QsIEhUTUxfRk9SLCBDTEFTU19OQU1FLCBCT09MRUFOLCBGVU5DVElPTiwgU1ZHX05BTUVTUEFDRV9VUkkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IERPVUJMRV9DTElDS19FVkVOVF9UWVBFID0gXCJkb3VibGVjbGlja1wiLFxuICAgICAgU0VMRUNUSU9OX0NIQU5HRV9FVkVOVF9UWVBFID0gXCJzZWxlY3Rpb25DaGFuZ2VcIixcbiAgICAgIEZVTExfU0NSRUVOX0NIQU5HRV9FVkVOVF9UWVBFID0gXCJmdWxsU2NyZWVuQ2hhbmdlXCI7XG5cbmZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gY29tYmluZShwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcyk7XG5cbiAgcHJvcGVydGllcyA9IHBydW5lKHRoaXMucHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpOyAvLy9cblxuICBjb25zdCBuYW1lc3BhY2VVUkkgPSB0aGlzLmRvbUVsZW1lbnQubmFtZXNwYWNlVVJJLFxuICAgICAgICBzdmcgPSAobmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFX1VSSSksIC8vL1xuICAgICAgICBwcm9wZXJ0aWVzS2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLFxuICAgICAgICBuYW1lcyA9IHByb3BlcnRpZXNLZXlzOyAgLy8vPVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbbmFtZV0sXG4gICAgICAgICAgbmFtZUhhbmRsZXJOYW1lID0gaXNOYW1lSGFuZGxlck5hbWUobmFtZSksXG4gICAgICAgICAgbmFtZUN1c3RvbUhhbmRsZXJOYW1lID0gaXNOYW1lQ3VzdG9tSGFuZGxlck5hbWUobmFtZSk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobmFtZUhhbmRsZXJOYW1lKSB7XG4gICAgICBhZGRIYW5kbGVyKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWVDdXN0b21IYW5kbGVyTmFtZSkge1xuICAgICAgYWRkQ3VzdG9tSGFuZGxlcih0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVBdHRyaWJ1dGVOYW1lID0gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpO1xuXG4gICAgICBpZiAobmFtZUF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgYWRkQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGNoaWxkRWxlbWVudHMgPSBjaGlsZEVsZW1lbnRzRnJvbUVsZW1lbnQodGhpcykgfHwgcHJvcGVydGllcy5jaGlsZEVsZW1lbnRzLCAgLy8vXG4gICAgICAgIGNvbnRleHQgPSB7fTtcblxuICBjaGlsZEVsZW1lbnRzLmZvckVhY2goKGNoaWxkRWxlbWVudCkgPT4ge1xuICAgIHVwZGF0ZUNvbnRleHQoY2hpbGRFbGVtZW50LCBjb250ZXh0KTtcblxuICAgIHRoaXMuYWRkKGNoaWxkRWxlbWVudCk7XG4gIH0pO1xuXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXMoKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNvbnRleHQobmFtZXMpIHtcbiAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29udGV4dClcbiAgfVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29udGV4dFtuYW1lXSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBuYW1lLCAgLy8vXG4gICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRbbmFtZV07XG4gIH0pO1xufVxuXG5jb25zdCBqc3hNaXhpbnMgPSB7XG4gIGFwcGx5UHJvcGVydGllcyxcbiAgZ2V0UHJvcGVydGllcyxcbiAgZ2V0Q29udGV4dCxcbiAgYXNzaWduQ29udGV4dFxufTtcblxuZXhwb3J0IGRlZmF1bHQganN4TWl4aW5zO1xuXG5mdW5jdGlvbiBjaGlsZEVsZW1lbnRzRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICBsZXQgY2hpbGRFbGVtZW50cyA9IG51bGw7XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50LmNoaWxkRWxlbWVudHMgPT09IEZVTkNUSU9OKSB7XG4gICAgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnQuY2hpbGRFbGVtZW50cy5jYWxsKGVsZW1lbnQpO1xuXG4gICAgY2hpbGRFbGVtZW50cyA9IGd1YXJhbnRlZShjaGlsZEVsZW1lbnRzKTtcblxuICAgIGNoaWxkRWxlbWVudHMgPSByZW1vdmVGYWxzZXlFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTtcblxuICAgIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRFbGVtZW50cztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChjaGlsZEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9ICh0eXBlb2YgY2hpbGRFbGVtZW50LnBhcmVudENvbnRleHQgPT09IEZVTkNUSU9OKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudC5wYXJlbnRDb250ZXh0KCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudC5jb250ZXh0OyAvLy9cblxuICBPYmplY3QuYXNzaWduKGNvbnRleHQsIHBhcmVudENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGxldCBldmVudFR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpOyAvLy9cblxuICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgIGNhc2UgRE9VQkxFX0NMSUNLX0VWRU5UX1RZUEU6IHtcbiAgICAgIGV2ZW50VHlwZSA9IERCTENMSUNLX0VWRU5UX1RZUEU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgU0VMRUNUSU9OX0NIQU5HRV9FVkVOVF9UWVBFOiB7XG4gICAgICBldmVudFR5cGUgPSBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBGVUxMX1NDUkVFTl9DSEFOR0VfRVZFTlRfVFlQRToge1xuICAgICAgZXZlbnRUeXBlID0gRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZXIgPSB2YWx1ZTsgIC8vL1xuXG4gIGVsZW1lbnQub25FdmVudChldmVudFR5cGUsIGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRDdXN0b21IYW5kbGVyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IGNhbWVsQ2FzZVRvU25ha2VDYXNlKG5hbWUpLnJlcGxhY2UoL29uLWN1c3RvbS0vLCBcIlwiKSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHZhbHVlOyAgLy8vXG5cbiAgZWxlbWVudC5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBpZiAobmFtZSA9PT0gQ0xBU1NfTkFNRSkge1xuICAgIG5hbWUgPSBDTEFTUztcbiAgfVxuXG4gIGlmIChuYW1lID09PSBIVE1MX0ZPUikge1xuICAgIG5hbWUgPSBGT1I7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBPQkpFQ1QpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtuYW1lXVtrZXldID0gdmFsdWVba2V5XTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IEJPT0xFQU4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmFtZTsgLy8vXG5cbiAgICAgIGVsZW1lbnQuYWRkQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5hZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTmFtZUhhbmRsZXJOYW1lKG5hbWUpIHtcbiAgY29uc3QgbmFtZUhhbmRsZXJOYW1lID0gIC9eb24oPyFDdXN0b20pLy50ZXN0KG5hbWUpOyAgLy8vXG5cbiAgcmV0dXJuIG5hbWVIYW5kbGVyTmFtZTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpIHtcbiAgY29uc3QgbmFtZUF0dHJpYnV0ZU5hbWUgPSBzdmcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NWR0F0dHJpYnV0ZU5hbWUobmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSFRNTEF0dHJpYnV0ZU5hbWUobmFtZSk7XG5cbiAgcmV0dXJuIG5hbWVBdHRyaWJ1dGVOYW1lO1xufVxuXG5mdW5jdGlvbiBpc05hbWVDdXN0b21IYW5kbGVyTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVDdXN0b21IYW5kbGVyTmFtZSA9IC9eb25DdXN0b20vLnRlc3QobmFtZSk7XG5cbiAgcmV0dXJuIG5hbWVDdXN0b21IYW5kbGVyTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgS0VZVVBfRVZFTlRfVFlQRSwgS0VZRE9XTl9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25LZXlVcChrZXlVcEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEtFWVVQX0VWRU5UX1RZUEUsIGtleVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmS2V5VXAoa2V5VXBIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoS0VZVVBfRVZFTlRfVFlQRSwga2V5VXBIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEtFWURPV05fRVZFTlRfVFlQRSwga2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChLRVlET1dOX0VWRU5UX1RZUEUsIGtleURvd25IYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5jb25zdCBrZXlNaXhpbnMgPSB7XG4gIG9uS2V5VXAsXG4gIG9mZktleVVwLFxuICBvbktleURvd24sXG4gIG9mZktleURvd25cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtleU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlO1xufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICh0aGlzLnN0YXRlID09PSB1bmRlZmluZWQpID9cbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgOlxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCBzdGF0ZSk7XG59XG5cbmNvbnN0IHN0YXRlTWl4aW5zID0ge1xuICBnZXRTdGF0ZSxcbiAgc2V0U3RhdGUsXG4gIHVwZGF0ZVN0YXRlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdGF0ZU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgU1BBQ0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBSRVNJWkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uRXZlbnQoZXZlbnRUeXBlcywgaGFuZGxlciwgZWxlbWVudCA9IHRoaXMpIHtcbiAgZXZlbnRUeXBlcyA9IGV2ZW50VHlwZXMuc3BsaXQoU1BBQ0UpOyAvLy9cblxuICBldmVudFR5cGVzLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgIGlmIChldmVudFR5cGUgPT09IFJFU0laRV9FVkVOVF9UWVBFKSB7XG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc2l6ZUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kRXZlbnRMaXN0ZW5lcnMoUkVTSVpFX0VWRU5UX1RZUEUpO1xuXG4gICAgICAgICAgcmVzaXplRXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgocmVzaXplRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICByZXNpemVFdmVudExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tRWxlbWVudClcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZFdmVudChldmVudFR5cGVzLCBoYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBldmVudFR5cGVzID0gZXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGV2ZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gUkVTSVpFX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICBkZWxldGUgdGhpcy5yZXNpemVPYnNlcnZlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gIH1cblxuICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmZpbmRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCksXG4gICAgICAgIGluZGV4ID0gdGhpcy5ldmVudExpc3RlbmVycy5pbmRleE9mKGV2ZW50TGlzdGVuZXIpLFxuICAgICAgICBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gMTtcblxuICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB0aGlzLmV2ZW50TGlzdGVuZXJzO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGZpbmRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVycy5maW5kKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgaWYgKChldmVudExpc3RlbmVyLmVsZW1lbnQgPT09IGVsZW1lbnQpICYmIChldmVudExpc3RlbmVyLmhhbmRsZXIgPT09IGhhbmRsZXIpICYmIChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmluZEV2ZW50TGlzdGVuZXJzKGV2ZW50VHlwZSkge1xuICBjb25zdCBldmVudExpc3RlbmVycyA9IFtdO1xuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgICBjb25zdCBmb3VuZCA9IChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKTtcblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGxldCBldmVudExpc3RlbmVyO1xuXG4gIGNvbnN0IGhhbmRsZXJFbGVtZW50ID0gZWxlbWVudDsgLy8vXG5cbiAgZXZlbnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oZXZlbnRMaXN0ZW5lciwge1xuICAgIGVsZW1lbnQsXG4gICAgaGFuZGxlcixcbiAgICBldmVudFR5cGVcbiAgfSk7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmNvbnN0IGV2ZW50TWl4aW5zID0ge1xuICBvbkV2ZW50LFxuICBvZmZFdmVudCxcbiAgYWRkRXZlbnRMaXN0ZW5lcixcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcixcbiAgZmluZEV2ZW50TGlzdGVuZXIsXG4gIGZpbmRFdmVudExpc3RlbmVycyxcbiAgY3JlYXRlRXZlbnRMaXN0ZW5lclxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXZlbnRNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE1PVVNFVVBfRVZFTlRfVFlQRSwgTU9VU0VPVVRfRVZFTlRfVFlQRSwgTU9VU0VET1dOX0VWRU5UX1RZUEUsIE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBNT1VTRU1PVkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoTU9VU0VVUF9FVkVOVF9UWVBFLCBtb3VzZVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFVVBfRVZFTlRfVFlQRSwgbW91c2VVcEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdXQobW91c2VPdXRIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChNT1VTRU9VVF9FVkVOVF9UWVBFLCBtb3VzZU91dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFT1VUX0VWRU5UX1RZUEUsIG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBtb3VzZU92ZXJIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZNb3VzZU92ZXIobW91c2VPdmVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBtb3VzZU92ZXJIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbk1vdXNlTW92ZShtb3VzZU1vdmVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuY29uc3QgbW91c2VNaXhpbnMgPSB7XG4gIG9uTW91c2VVcCxcbiAgb2ZmTW91c2VVcCxcbiAgb25Nb3VzZU91dCxcbiAgb2ZmTW91c2VPdXQsXG4gIG9uTW91c2VEb3duLFxuICBvZmZNb3VzZURvd24sXG4gIG9uTW91c2VPdmVyLFxuICBvZmZNb3VzZU92ZXIsXG4gIG9uTW91c2VNb3ZlLFxuICBvZmZNb3VzZU1vdmVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdXNlTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDTElDS19FVkVOVF9UWVBFLCBEQkxDTElDS19FVkVOVF9UWVBFLCBBVVhDTElDS19FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25DbGljayhjbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KENMSUNLX0VWRU5UX1RZUEUsIGNsaWNrSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ2xpY2soY2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoQ0xJQ0tfRVZFTlRfVFlQRSwgY2xpY2tIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbkF1eENsaWNrKGF1eENsaWNrSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQVVYQ0xJQ0tfRVZFTlRfVFlQRSwgYXV4Q2xpY2tIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZBdXhDbGljayhhdXhDbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChBVVhDTElDS19FVkVOVF9UWVBFLCBhdXhDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZG91YmxlQ2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChEQkxDTElDS19FVkVOVF9UWVBFLCBkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9IC8vL1xuXG5mdW5jdGlvbiBvZmZEb3VibGVDbGljayhkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChEQkxDTElDS19FVkVOVF9UWVBFLCBkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9IC8vL1xuXG5jb25zdCBjbGlja01peGlucyA9IHtcbiAgb25DbGljayxcbiAgb2ZmQ2xpY2ssXG4gIG9uQXV4Q2xpY2ssXG4gIG9mZkF1eENsaWNrLFxuICBvbkRvdWJsZUNsaWNrLFxuICBvZmZEb3VibGVDbGlja1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpY2tNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFRPVUNIU1RBUlRfRVZFTlRfVFlQRSwgVE9VQ0hNT1ZFX0VWRU5UX1RZUEUsIFRPVUNIRU5EX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vbkV2ZW50KFRPVUNIU1RBUlRfRVZFTlRfVFlQRSwgdG91Y2hTdGFydEhhbmRsZXIpOyB9XG5cbmZ1bmN0aW9uIG9mZlRvdWNoU3RhcnQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vZmZFdmVudChUT1VDSFNUQVJUX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvblRvdWNoTW92ZSh0b3VjaFN0YXJ0SGFuZGxlcikgeyB0aGlzLm9uRXZlbnQoVE9VQ0hNT1ZFX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvZmZUb3VjaE1vdmUodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vZmZFdmVudChUT1VDSE1PVkVfRVZFTlRfVFlQRSwgdG91Y2hTdGFydEhhbmRsZXIpOyB9XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vbkV2ZW50KFRPVUNIRU5EX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvZmZUb3VjaEVuZCh0b3VjaFN0YXJ0SGFuZGxlcikgeyB0aGlzLm9mZkV2ZW50KFRPVUNIRU5EX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5jb25zdCBjbGlja01peGlucyA9IHtcbiAgb25Ub3VjaFN0YXJ0LFxuICBvZmZUb3VjaFN0YXJ0LFxuICBvblRvdWNoTW92ZSxcbiAgb2ZmVG91Y2hNb3ZlLFxuICBvblRvdWNoRW5kLFxuICBvZmZUb3VjaEVuZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpY2tNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNDUk9MTF9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9uU2Nyb2xsKHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KFNDUk9MTF9FVkVOVF9UWVBFLCBzY3JvbGxIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZmU2Nyb2xsKHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChTQ1JPTExfRVZFTlRfVFlQRSwgc2Nyb2xsSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0KSB7IHRoaXMuZG9tRWxlbWVudC5zY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApOyB9IC8vL1xuXG5mdW5jdGlvbiBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsVG9wOyB9XG5cbmZ1bmN0aW9uIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsTGVmdDsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxXaWR0aCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5zY3JvbGxXaWR0aDsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsSGVpZ2h0OyB9XG5cbmZ1bmN0aW9uIHNldFNjcm9sbFRvcChzY3JvbGxUb3ApIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDsgfVxuXG5mdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KHNjcm9sbExlZnQpIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0OyB9XG5cbmNvbnN0IHNjcm9sbE1peGlucyA9IHtcbiAgb25TY3JvbGwsXG4gIG9mZlNjcm9sbCxcbiAgc2Nyb2xsVG8sXG4gIGdldFNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsTGVmdCxcbiAgZ2V0U2Nyb2xsV2lkdGgsXG4gIGdldFNjcm9sbEhlaWdodCxcbiAgc2V0U2Nyb2xsVG9wLFxuICBzZXRTY3JvbGxMZWZ0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzY3JvbGxNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJFU0laRV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25SZXNpemUocmVzaXplSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmNvbnN0IHJlc2l6ZU1peGlucyA9IHtcbiAgb25SZXNpemUsXG4gIG9mZlJlc2l6ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVzaXplTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBGVUxMU0NSRUVOQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbkZ1bGxTY3JlZW5DaGFuZ2UoZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSwgZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9ICAvLy9cblxuZnVuY3Rpb24gb2ZmRnVsbFNjcmVlbkNoYW5nZShmdWxsU2NyZWVuQ2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSwgZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9ICAvLy9cblxuZnVuY3Rpb24gcmVxdWVzdEZ1bGxTY3JlZW4oZXJyb3JIYW5kbGVyKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB0aGlzLmdldERPTUVsZW1lbnQoKTtcblxuICBkb21FbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gZXhpdEZ1bGxTY3JlZW4oKSB7XG4gIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVsbFNjcmVlbigpIHtcbiAgY29uc3QgeyBmdWxsc2NyZWVuRWxlbWVudCB9ID0gZG9jdW1lbnQsXG4gICAgICAgIGZ1bGxTY3JlZW4gPSAoZnVsbHNjcmVlbkVsZW1lbnQgIT09IG51bGwpO1xuXG4gIHJldHVybiBmdWxsU2NyZWVuO1xufVxuXG5jb25zdCBmdWxsc2NyZWVuTWl4aW5zID0ge1xuICBvbkZ1bGxTY3JlZW5DaGFuZ2UsXG4gIG9mZkZ1bGxTY3JlZW5DaGFuZ2UsXG4gIHJlcXVlc3RGdWxsU2NyZWVuLFxuICBleGl0RnVsbFNjcmVlbixcbiAgaXNGdWxsU2NyZWVuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdWxsc2NyZWVuTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChhcnJheSwgb3BlcmF0aW9uLCBkb25lLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xuXG4gIGxldCBjb3VudCA9IC0xO1xuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgY291bnQrKztcblxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xuICAgICAgICAgICAgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNQQUNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNcIjtcblxuZnVuY3Rpb24gb25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGVzLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBjdXN0b21FdmVudFR5cGVzID0gY3VzdG9tRXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGN1c3RvbUV2ZW50VHlwZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnRUeXBlKSA9PiB7XG4gICAgdGhpcy5hZGRDdXN0b21FdmVudExpc3RlbmVyKGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGVzLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBjdXN0b21FdmVudFR5cGVzID0gY3VzdG9tRXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGN1c3RvbUV2ZW50VHlwZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnRUeXBlKSA9PiB7XG4gICAgdGhpcy5yZW1vdmVDdXN0b21FdmVudExpc3RlbmVyKGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQ3VzdG9tSGFuZGxlcnMoY3VzdG9tRXZlbnRUeXBlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmZpbmRDdXN0b21FdmVudExpc3RlbmVycyhjdXN0b21FdmVudFR5cGUpO1xuXG4gIGN1c3RvbUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQ6IGN1c3RvbUhhbmRsZXJFbGVtZW50IH0gPSBjdXN0b21FdmVudExpc3RlbmVyOyAvLy9cblxuICAgIGN1c3RvbUhhbmRsZXIuY2FsbChjdXN0b21IYW5kbGVyRWxlbWVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxDdXN0b21IYW5kbGVyc0FzeW5jKGN1c3RvbUV2ZW50VHlwZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMoY3VzdG9tRXZlbnRUeXBlKSxcbiAgICAgICAgZG9uZSA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKTsgIC8vL1xuXG4gIGZvckVhY2goY3VzdG9tRXZlbnRMaXN0ZW5lcnMsIChjdXN0b21FdmVudExpc3RlbmVyLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b21IYW5kbGVyLCBlbGVtZW50OiBjdXN0b21IYW5kbGVyRWxlbWVudCB9ID0gY3VzdG9tRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgICBkb25lID0gbmV4dDsgIC8vL1xuXG4gICAgY3VzdG9tSGFuZGxlci5jYWxsKGN1c3RvbUhhbmRsZXJFbGVtZW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMsIGRvbmUpO1xuICB9LCBkb25lKTtcbn1cblxuZnVuY3Rpb24gYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lciA9IHRoaXMuY3JlYXRlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gIGlmICghdGhpcy5jdXN0b21FdmVudExpc3RlbmVycykge1xuICAgIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMucHVzaChjdXN0b21FdmVudExpc3RlbmVyKTtcblxuICByZXR1cm4gY3VzdG9tRXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lciA9IHRoaXMuZmluZEN1c3RvbUV2ZW50TGlzdGVuZXIoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY3VzdG9tRXZlbnRMaXN0ZW5lciksXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG5cbiAgaWYgKHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnM7XG4gIH1cblxuICByZXR1cm4gY3VzdG9tRXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmluZEN1c3RvbUV2ZW50TGlzdGVuZXIoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXIgPSB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmZpbmQoKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBpZiAoKGN1c3RvbUV2ZW50TGlzdGVuZXIuZWxlbWVudCA9PT0gZWxlbWVudCkgJiYgKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tSGFuZGxlciA9PT0gY3VzdG9tSGFuZGxlcikgJiYgKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tRXZlbnRUeXBlID09PSBjdXN0b21FdmVudFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMoY3VzdG9tRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgaWYgKHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgIGNvbnN0IGZvdW5kID0gKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tRXZlbnRUeXBlID09PSBjdXN0b21FdmVudFR5cGUpO1xuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY3VzdG9tRXZlbnRMaXN0ZW5lcnMucHVzaChjdXN0b21FdmVudExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgbGV0IGN1c3RvbUV2ZW50TGlzdGVuZXI7XG5cbiAgY3VzdG9tRXZlbnRMaXN0ZW5lciA9ICgpID0+IHt9OyAvLy9cblxuICBPYmplY3QuYXNzaWduKGN1c3RvbUV2ZW50TGlzdGVuZXIsIHtcbiAgICBlbGVtZW50LFxuICAgIGN1c3RvbUhhbmRsZXIsXG4gICAgY3VzdG9tRXZlbnRUeXBlXG4gIH0pO1xuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVyO1xufVxuXG5jb25zdCBjdXN0b21FdmVudE1peGlucyA9IHtcbiAgb25DdXN0b21FdmVudCxcbiAgb2ZmQ3VzdG9tRXZlbnQsXG4gIGNhbGxDdXN0b21IYW5kbGVycyxcbiAgY2FsbEN1c3RvbUhhbmRsZXJzQXN5bmMsXG4gIGFkZEN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIHJlbW92ZUN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIGZpbmRDdXN0b21FdmVudExpc3RlbmVyLFxuICBmaW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMsXG4gIGNyZWF0ZUN1c3RvbUV2ZW50TGlzdGVuZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbUV2ZW50TWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgT2Zmc2V0IGZyb20gXCIuL29mZnNldFwiO1xuaW1wb3J0IEJvdW5kcyBmcm9tIFwiLi9ib3VuZHNcIjtcbmltcG9ydCBqc3hNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2pzeFwiO1xuaW1wb3J0IGtleU1peGlucyBmcm9tIFwiLi9taXhpbnMva2V5XCI7XG5pbXBvcnQgc3RhdGVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3N0YXRlXCI7XG5pbXBvcnQgZXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2V2ZW50XCI7XG5pbXBvcnQgbW91c2VNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL21vdXNlXCI7XG5pbXBvcnQgY2xpY2tNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2NsaWNrXCI7XG5pbXBvcnQgdG91Y2hNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3RvdWNoXCI7XG5pbXBvcnQgc2Nyb2xsTWl4aW5zIGZyb20gXCIuL21peGlucy9zY3JvbGxcIjtcbmltcG9ydCByZXNpemVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3Jlc2l6ZVwiO1xuaW1wb3J0IGVsZW1lbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2VsZW1lbnRcIjtcbmltcG9ydCBmdWxsU2NyZWVuTWl4aW5zIGZyb20gXCIuL21peGlucy9mdWxsU2NyZWVuXCI7XG5pbXBvcnQgY3VzdG9tRXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2N1c3RvbUV2ZW50XCI7XG5cbmltcG9ydCB7IGF1Z21lbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tIFwiLi91dGlsaXRpZXMvb2JqZWN0XCI7XG5pbXBvcnQgeyBpc1NWR1RhZ05hbWUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbmFtZVwiO1xuaW1wb3J0IHsgY29uc3RydWN0RWxlbWVudCwgZGVzdHJveUVsZW1lbnQsIG1vdW50RWxlbWVudCwgdW5tb3VudEVsZW1lbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudFwiO1xuaW1wb3J0IHsgTk9ORSxcbiAgICAgICAgIEJMT0NLLFxuICAgICAgICAgV0lEVEgsXG4gICAgICAgICBTVFJJTkcsXG4gICAgICAgICBIRUlHSFQsXG4gICAgICAgICBESVNQTEFZLFxuICAgICAgICAgRElTQUJMRUQsXG4gICAgICAgICBFTVBUWV9TVFJJTkcsXG4gICAgICAgICBTVkdfTkFNRVNQQUNFX1VSSSxcbiAgICAgICAgIERFRkFVTFRfUFJPUEVSVElFUyxcbiAgICAgICAgIElHTk9SRURfUFJPUEVSVElFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPXRoaXMsICAvLy9cbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgICAgY29uc3RydWN0RWxlbWVudChlbGVtZW50LCBkb21FbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBnZXRET01FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gT2Zmc2V0LmZyb21ET01FbGVtZW50KHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IEJvdW5kcy5mcm9tRE9NRWxlbWVudCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50Lm9mZnNldFdpZHRoOyB9ICAvLy9cblxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyB9ICAvLy9cblxuICBnZXRJbm5lcldpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmNsaWVudFdpZHRoOyB9IC8vL1xuXG4gIGdldElubmVySGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmNsaWVudEhlaWdodDsgfSAvLy9cblxuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIHdpZHRoID0gYCR7d2lkdGh9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoV0lEVEgsIHdpZHRoKTtcbiAgfVxuXG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBgJHtoZWlnaHR9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoSEVJR0hULCBoZWlnaHQpO1xuICB9XG5cbiAgaGFzQXR0cmlidXRlKG5hbWUpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZSk7IH1cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfVxuXG4gIGNsZWFyQXR0cmlidXRlKG5hbWUpIHsgdGhpcy5kb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIGFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7IH1cblxuICByZW1vdmVBdHRyaWJ1dGUobmFtZSkgeyB0aGlzLmNsZWFyQXR0cmlidXRlKG5hbWUpOyB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7IH1cblxuICBzZXRDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkgeyB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpOyB9XG5cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH1cblxuICB0b2dnbGVDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTsgfVxuXG4gIHJlbW92ZUFsbENsYXNzZXMoKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc05hbWUgPSBFTVBUWV9TVFJJTkc7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgYXBwZW5kVG8ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LmFwcGVuZCh0aGlzKTsgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIHJlbW92ZUZyb20ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LnJlbW92ZSh0aGlzKTsgfVxuXG4gIGluc2VydChlbGVtZW50KSB7IHRoaXMuYXBwZW5kKGVsZW1lbnQpOyB9XG5cbiAgYWRkKGVsZW1lbnQpIHsgdGhpcy5hcHBlbmQoZWxlbWVudCk7IH1cblxuICByZW1vdmUoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZSgpO1xuICB9XG5cbiAgcHJlcGVuZChlbGVtZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZG9tRWxlbWVudCxcbiAgICAgICAgICByZWZlcmVuY2VET01FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50LmZpcnN0Q2hpbGQ7ICAvLy9cblxuICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZG9tRWxlbWVudCwgcmVmZXJlbmNlRE9NRWxlbWVudCk7XG4gIH1cblxuICBhcHBlbmQoZWxlbWVudCkge1xuICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBlbGVtZW50LmRvbUVsZW1lbnQsXG4gICAgICAgICAgcmVmZXJlbmNlRE9NRWxlbWVudCA9IG51bGw7IC8vL1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZShkb21FbGVtZW50LCByZWZlcmVuY2VET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEJlZm9yZShzaWJsaW5nRWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGUgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50LnBhcmVudE5vZGUsIC8vL1xuICAgICAgICAgIHJlZmVyZW5jZURPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHJlZmVyZW5jZURPTUVsZW1lbnQpO1xuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnRET01Ob2RlID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5wYXJlbnROb2RlLCAvLy9cbiAgICAgICAgICByZWZlcmVuY2VET01FbGVtZW50ID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5uZXh0U2libGluZzsgIC8vL1xuXG4gICAgcGFyZW50RE9NTm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21FbGVtZW50LCByZWZlcmVuY2VET01FbGVtZW50KTtcbiAgfVxuXG4gIG1vdW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLmFkZChlbGVtZW50KTtcblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHVubW91bnQoZWxlbWVudCkge1xuICAgIHVubW91bnRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gIH1cblxuICBtb3VudEJlZm9yZShzaWJsaW5nRWxlbWVudCkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIG1vdW50QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICB0aGlzLmluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHNob3coZGlzcGxheVN0eWxlID0gQkxPQ0spIHsgdGhpcy5kaXNwbGF5KGRpc3BsYXlTdHlsZSk7IH1cblxuICBoaWRlKCkgeyB0aGlzLnN0eWxlKERJU1BMQVksIE5PTkUpOyB9XG5cbiAgZGlzcGxheShkaXNwbGF5KSB7IHRoaXMuc3R5bGUoRElTUExBWSwgZGlzcGxheSk7IH1cblxuICBlbmFibGUoKSB7IHRoaXMuY2xlYXJBdHRyaWJ1dGUoRElTQUJMRUQpOyB9XG5cbiAgZGlzYWJsZSgpIHsgdGhpcy5zZXRBdHRyaWJ1dGUoRElTQUJMRUQsIERJU0FCTEVEKTsgfVxuXG4gIGlzRW5hYmxlZCgpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpLFxuICAgICAgICAgIGVuYWJsZWQgPSAhZGlzYWJsZWQ7XG5cbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZShESVNBQkxFRCk7XG5cbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cbiAgXG4gIGlzRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLmNzcyhESVNQTEFZKSxcbiAgICAgICAgICBkaXNwbGF5ZWQgPSAoZGlzcGxheSAhPT0gTk9ORSk7XG4gICAgXG4gICAgcmV0dXJuIGRpc3BsYXllZDtcbiAgfVxuXG4gIGlzU2hvd2luZygpIHtcbiAgICBjb25zdCBkaXNwbGF5ZWQgPSB0aGlzLmlzRGlzcGxheWVkKCksXG4gICAgICAgICAgc2hvd2luZyA9IGRpc3BsYXllZDsgIC8vL1xuXG4gICAgcmV0dXJuIHNob3dpbmc7XG4gIH1cblxuICBpc0hpZGRlbigpIHtcbiAgICBjb25zdCBkaXNwbGF5ZWQgPSB0aGlzLmlzRGlzcGxheWVkKCksXG4gICAgICAgICAgaGlkZGVuID0gIWRpc3BsYXllZDtcblxuICAgIHJldHVybiBoaWRkZW47XG4gIH1cblxuICBzdHlsZShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGVbbmFtZV07XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBodG1sKGh0bWwgPSBudWxsKSB7XG4gICAgaWYgKGh0bWwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGlubmVySFRNTCA9IGh0bWw7IC8vL1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gaW5uZXJIVE1MXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbm5lckhUTUwgPSB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuXG4gICAgaHRtbCA9IGlubmVySFRNTDsgLy8vXG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGNzcyhjc3MgPSBudWxsKSB7XG4gICAgaWYgKGNzcyA9PT0gbnVsbCkge1xuICAgICAgY3NzID0ge307XG5cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpOyAvLy9cblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbXB1dGVkU3R5bGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZXNbaW5kZXhdLFxuICAgICAgICAgICAgICBuYW1lID0gY29tcHV0ZWRTdHlsZSwgIC8vL1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUobmFtZSk7IC8vL1xuXG4gICAgICAgIGNzc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNzcyA9PT0gU1RSSU5HKSB7XG4gICAgICBsZXQgbmFtZSA9IGNzczsgLy8vXG5cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpLCAvLy9cbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTsgLy8vXG5cbiAgICAgIGNzcyA9IHZhbHVlOyAgLy8vXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoY3NzKTsgLy8vXG5cbiAgICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgdGhpcy5zdHlsZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICBkZXN0cm95RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ2xhc3MoQ2xhc3MsIHByb3BlcnRpZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGNvbnN0IHsgdGFnTmFtZSB9ID0gQ2xhc3MsXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSxcbiAgICAgICAgICBkZWZhdWx0UHJvcGVydGllcyA9IGRlZmF1bHRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzKSxcbiAgICAgICAgICBpZ25vcmVkUHJvcGVydGllcyA9IGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzKTtcblxuICAgIGVsZW1lbnQuYXBwbHlQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGRlZmF1bHRQcm9wZXJ0aWVzLCBpZ25vcmVkUHJvcGVydGllcyk7XG5cbiAgICBlbGVtZW50LmluaXRpYWxpc2UgJiYgZWxlbWVudC5pbml0aWFsaXNlKCk7IC8vL1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRhZ05hbWUodGFnTmFtZSwgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSBFbGVtZW50LCAgLy8vXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSxcbiAgICAgICAgICBkZWZhdWx0UHJvcGVydGllcyA9IHt9LCAvLy9cbiAgICAgICAgICBpZ25vcmVkUHJvcGVydGllcyA9IFtdOyAvLy9cblxuICAgIGVsZW1lbnQuYXBwbHlQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGRlZmF1bHRQcm9wZXJ0aWVzLCBpZ25vcmVkUHJvcGVydGllcyk7XG5cbiAgICBlbGVtZW50LmluaXRpYWxpc2UgJiYgZWxlbWVudC5pbml0aWFsaXNlKCk7IC8vL1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwganN4TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBtb3VzZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzdGF0ZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBldmVudE1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCB0b3VjaE1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzY3JvbGxNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgcmVzaXplTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGVsZW1lbnRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgZnVsbFNjcmVlbk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBjdXN0b21FdmVudE1peGlucyk7XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gbnVsbCxcbiAgICAgICAgZWxlbWVudCA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChDbGFzcywgbnVsbCwgc2VsZWN0b3IsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykpLFxuICAgICAgICBkb21FbGVtZW50ID0gaXNTVkdUYWdOYW1lKHRhZ05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0VfVVJJLCB0YWdOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBjb25zdHJ1Y3RFbGVtZW50KGVsZW1lbnQsIGRvbUVsZW1lbnQpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhDbGFzcywgZGVmYXVsdFByb3BlcnRpZXMgPSB7fSkge1xuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoREVGQVVMVF9QUk9QRVJUSUVTKSkge1xuICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0gY29tYmluZShkZWZhdWx0UHJvcGVydGllcywgQ2xhc3NbREVGQVVMVF9QUk9QRVJUSUVTXSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTsgIC8vL1xuXG4gIGlmIChzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgZGVmYXVsdFByb3BlcnRpZXMgPSBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhzdXBlckNsYXNzLCBkZWZhdWx0UHJvcGVydGllcyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzLCBpZ25vcmVkUHJvcGVydGllcyA9IFtdKSB7XG4gIGlmIChDbGFzcy5oYXNPd25Qcm9wZXJ0eShJR05PUkVEX1BST1BFUlRJRVMpKSB7XG4gICAgaWdub3JlZFByb3BlcnRpZXMgPSBhdWdtZW50KGlnbm9yZWRQcm9wZXJ0aWVzLCBDbGFzc1tJR05PUkVEX1BST1BFUlRJRVNdLCAoaWdub3JlZFByb3BlcnR5KSA9PiB7XG4gICAgICBpZiAoIWlnbm9yZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKGlnbm9yZWRQcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTtcblxuICBpZiAoc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIGlnbm9yZWRQcm9wZXJ0aWVzID0gaWdub3JlZFByb3BlcnRpZXNGcm9tQ2xhc3Moc3VwZXJDbGFzcywgaWdub3JlZFByb3BlcnRpZXMpO1xuICB9XG5cbiAgcmV0dXJuIGlnbm9yZWRQcm9wZXJ0aWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi9lbGVtZW50XCI7XG5cbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFNUUklORywgRlVOQ1RJT04gfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHJlbW92ZUZhbHNleUVsZW1lbnRzLCByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudHNcIjtcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChmaXJzdEFyZ3VtZW50LCBwcm9wZXJ0aWVzLCAuLi5jaGlsZEVsZW1lbnRzKSB7XG4gIGxldCBlbGVtZW50ID0gbnVsbDtcblxuICBpZiAoZmlyc3RBcmd1bWVudCkge1xuICAgIGNoaWxkRWxlbWVudHMgPSBzYW5pdGlzZUNoaWxkRWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG5cbiAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjaGlsZEVsZW1lbnRzXG4gICAgfSwgcHJvcGVydGllcyk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAoaXNTdWJjbGFzc09mKGZpcnN0QXJndW1lbnQsIEVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBDbGFzcyA9IGZpcnN0QXJndW1lbnQ7ICAvLy9cblxuICAgICAgZWxlbWVudCA9IENsYXNzLmZyb21DbGFzcyhDbGFzcywgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmd1bWVudCA9PT0gU1RSSU5HKSB7XG4gICAgICBjb25zdCB0YWdOYW1lID0gZmlyc3RBcmd1bWVudDsgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBFbGVtZW50LmZyb21UYWdOYW1lKHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJndW1lbnQgPT09IEZVTkNUSU9OKSB7XG4gICAgICBjb25zdCBlbGVtZW50RnVuY3Rpb24gPSBmaXJzdEFyZ3VtZW50OyAgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50RnVuY3Rpb24ocHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmNvbnN0IFJlYWN0ID0ge1xuICBjcmVhdGVFbGVtZW50XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWFjdDtcblxuZnVuY3Rpb24gc2FuaXRpc2VDaGlsZEVsZW1lbnRzKGNoaWxkRWxlbWVudHMpIHtcbiAgY2hpbGRFbGVtZW50cyA9IGZsYXR0ZW4oY2hpbGRFbGVtZW50cyk7IC8vL1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZW1vdmVGYWxzZXlFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTsgIC8vL1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7ICAvLy9cblxuICByZXR1cm4gY2hpbGRFbGVtZW50cztcbn1cblxuXG5mdW5jdGlvbiBpc1N1YmNsYXNzT2YoYXJndW1lbnQsIENsYXNzKSB7XG4gIGNvbnN0IHN1YmNsYXNzT2YgPSAoYXJndW1lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQ2xhc3MpO1xuXG4gIHJldHVybiBzdWJjbGFzc09mO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgTEVGVF9NT1VTRV9CVVRUT04gPSAwO1xuZXhwb3J0IGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7XG5leHBvcnQgY29uc3QgTUlERExFX01PVVNFX0JVVFRPTiA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEVGVF9NT1VTRV9CVVRUT04sXG4gIFJJR0hUX01PVVNFX0JVVFRPTixcbiAgTUlERExFX01PVVNFX0JVVFRPTlxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgSU5QVVRfRVZFTlRfVFlQRSwgQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbklucHV0KGlucHV0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoSU5QVVRfRVZFTlRfVFlQRSwgaW5wdXRIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZJbnB1dChpbnB1dEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChJTlBVVF9FVkVOVF9UWVBFLCBpbnB1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlKGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KENIQU5HRV9FVkVOVF9UWVBFLCBjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZDaGFuZ2UoY2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KENIQU5HRV9FVkVOVF9UWVBFLCBjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC52YWx1ZTsgfVxuXG5mdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQudmFsdWUgPSB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBpc1JlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnJlYWRPbmx5OyB9XG5cbmZ1bmN0aW9uIHNldFJlYWRPbmx5KHJlYWRPbmx5KSB7IHRoaXMuZG9tRWxlbWVudC5yZWFkT25seSA9IHJlYWRPbmx5OyB9XG5cbmNvbnN0IGlucHV0TWl4aW5zID0ge1xuICBvbklucHV0LFxuICBvZmZJbnB1dCxcbiAgb25DaGFuZ2UsXG4gIG9mZkNoYW5nZSxcbiAgZ2V0VmFsdWUsXG4gIHNldFZhbHVlLFxuICBpc1JlYWRPbmx5LFxuICBzZXRSZWFkT25seVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5wdXRNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJMVVJfRVZFTlRfVFlQRSwgRk9DVVNfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uQmx1cihibHVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQkxVUl9FVkVOVF9UWVBFLCBibHVySGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQmx1cihibHVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEJMVVJfRVZFTlRfVFlQRSwgYmx1ckhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uRm9jdXMoZm9jdXNIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChGT0NVU19FVkVOVF9UWVBFLCBmb2N1c0hhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZkZvY3VzKGZvY3VzSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEZPQ1VTX0VWRU5UX1RZUEUsIGZvY3VzSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gYmx1cigpIHsgdGhpcy5kb21FbGVtZW50LmJsdXIoKTsgfVxuXG5mdW5jdGlvbiBmb2N1cygpIHsgdGhpcy5kb21FbGVtZW50LmZvY3VzKCk7IH1cblxuZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gIGNvbnN0IGZvY3VzID0gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZG9tRWxlbWVudCk7ICAvLy9cblxuICByZXR1cm4gZm9jdXM7XG59XG5cbmNvbnN0IGZvY3VzTWl4aW5zID0ge1xuICBvbkJsdXIsXG4gIG9mZkJsdXIsXG4gIG9uRm9jdXMsXG4gIG9mZkZvY3VzLFxuICBibHVyLFxuICBmb2N1cyxcbiAgaGFzRm9jdXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvY3VzTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDVVRfRVZFTlRfVFlQRSwgQ09QWV9FVkVOVF9UWVBFLCBQQVNURV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25DdXQoY3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQ1VUX0VWRU5UX1RZUEUsIGN1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZkN1dChjdXRIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoQ1VUX0VWRU5UX1RZUEUsIGN1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uQ29weShjb3B5SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQ09QWV9FVkVOVF9UWVBFLCBjb3B5SGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ29weShjb3B5SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KENPUFlfRVZFTlRfVFlQRSwgY29weUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uUGFzdGUocGFzdGVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChQQVNURV9FVkVOVF9UWVBFLCBwYXN0ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlBhc3RlKHBhc3RlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KFBBU1RFX0VWRU5UX1RZUEUsIHBhc3RlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uU3RhcnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7IH1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRW5kKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNlbGVjdGlvbkVuZDsgfVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25TdGFydChzZWxlY3Rpb25TdGFydCkgeyB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDsgfVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25FbmQoc2VsZWN0aW9uRW5kKSB7IHRoaXMuZG9tRWxlbWVudC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7IH1cblxuZnVuY3Rpb24gc2VsZWN0KCkgeyB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0KCk7IH1cblxuY29uc3Qgc2VsZWN0aW9uTWl4aW5zID0ge1xuICBvbkN1dCxcbiAgb2ZmQ3V0LFxuICBvbkNvcHksXG4gIG9mZkNvcHksXG4gIG9uUGFzdGUsXG4gIG9mZlBhc3RlLFxuICBnZXRTZWxlY3Rpb25TdGFydCxcbiAgZ2V0U2VsZWN0aW9uRW5kLFxuICBzZXRTZWxlY3Rpb25TdGFydCxcbiAgc2V0U2VsZWN0aW9uRW5kLFxuICBzZWxlY3Rcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdGlvbk1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGtleU1peGlucyBmcm9tIFwiLi9taXhpbnMva2V5XCI7XG5pbXBvcnQgZXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2V2ZW50XCI7XG5pbXBvcnQgbW91c2VNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL21vdXNlXCI7XG5pbXBvcnQgY2xpY2tNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2NsaWNrXCI7XG5cbmltcG9ydCB7IFVOREVGSU5FRCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgU0VMRUNUSU9OQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi9ldmVudFR5cGVzXCI7XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQ7IC8vL1xuICB9XG5cbiAgZ2V0RE9NRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50O1xuICB9XG5cbiAgZ2V0U2VsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldFNlbGVjdGlvbigpOyB9XG5cbiAgY3JlYXRlUmFuZ2UoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuY3JlYXRlUmFuZ2UoKTsgfVxuXG4gIGNyZWF0ZVRleHROb2RlKGRhdGEpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTsgfVxuXG4gIG9uU2VsZWN0aW9uQ2hhbmdlKHNlbGVjdGlvbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfSAvLy9cblxuICBvZmZTZWxlY3Rpb25DaGFuZ2Uoc2VsZWN0aW9uQ2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfSAvLy9cblxuICBjcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICAgIGxldCBldmVudExpc3RlbmVyO1xuXG4gICAgY29uc3QgaGFuZGxlckVsZW1lbnQgPSBlbGVtZW50OyAvLy9cblxuICAgIGV2ZW50TGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFKSB7XG4gICAgICAgIGNvbnN0IHsgZG9tRWxlbWVudCB9ID0gaGFuZGxlckVsZW1lbnQsXG4gICAgICAgICAgICAgIHsgY3VycmVudFRhcmdldCB9ID0gZXZlbnQsXG4gICAgICAgICAgICAgIHsgYWN0aXZlRWxlbWVudCB9ID0gY3VycmVudFRhcmdldDtcblxuICAgICAgICBpZiAoZG9tRWxlbWVudCAhPT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKGV2ZW50TGlzdGVuZXIsIHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBoYW5kbGVyLFxuICAgICAgZXZlbnRUeXBlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwga2V5TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRG9jdW1lbnQucHJvdG90eXBlLCBldmVudE1peGlucyk7XG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihEb2N1bWVudC5wcm90b3R5cGUsIGNsaWNrTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiBkb2N1bWVudCA9PT0gVU5ERUZJTkVEKSA/IHVuZGVmaW5lZCA6IG5ldyBEb2N1bWVudCgpOyAgLy8vXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBrZXlNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2tleVwiO1xuaW1wb3J0IGV2ZW50TWl4aW5zIGZyb20gXCIuL21peGlucy9ldmVudFwiO1xuaW1wb3J0IG1vdXNlTWl4aW5zIGZyb20gXCIuL21peGlucy9tb3VzZVwiO1xuaW1wb3J0IGNsaWNrTWl4aW5zIGZyb20gXCIuL21peGlucy9jbGlja1wiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuL21peGlucy9mb2N1c1wiO1xuXG5pbXBvcnQgeyBVTkRFRklORUQgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJFU0laRV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4vZXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgb25TY3JvbGwsIG9mZlNjcm9sbCB9IGZyb20gXCIuL21peGlucy9zY3JvbGxcIjtcblxuY2xhc3MgV2luZG93IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gd2luZG93OyAvLy9cbiAgfVxuXG4gIGdldERPTUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudDtcbiAgfVxuXG4gIGFzc2lnbiguLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kb21FbGVtZW50OyAvLy9cblxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKTtcbiAgfVxuXG4gIHJlbG9hZCgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7IC8vL1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuaW5uZXJXaWR0aDsgfSAvLy9cbiAgXG4gIGdldEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5pbm5lckhlaWdodDsgfSAvLy9cblxuICBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQucGFnZVlPZmZzZXQ7IH0gIC8vL1xuXG4gIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQucGFnZVhPZmZzZXQ7IH0gLy8vXG5cbiAgZ2V0U2VsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldFNlbGVjdGlvbigpOyB9XG5cbiAgZ2V0U2NyZWVuV2lkdGgoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2NyZWVuLndpZHRoOyB9XG5cbiAgZ2V0U2NyZWVuSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNjcmVlbi5oZWlnaHQ7IH1cblxuICBzY3JvbGxUbyhzY3JvbGxUb3AsIHNjcm9sbExlZnQpIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7IH1cblxuICBvblJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gUkVTSVpFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gUkVTSVpFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGV2ZW50TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihXaW5kb3cucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwge1xuICBvblNjcm9sbCxcbiAgb2ZmU2Nyb2xsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiB3aW5kb3cgPT09IFVOREVGSU5FRCkgPyB1bmRlZmluZWQgOiBuZXcgV2luZG93KCk7ICAvLy9cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcblxuaW1wb3J0IHsgQk9EWSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm9keSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihzZWxlY3RvciA9IEJPRFkpIHtcbiAgICBzdXBlcihzZWxlY3Rvcik7XG4gIH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYm9keVwiO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vZWxlbWVudFwiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZm9jdXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluayBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRIUmVmKCkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpOyB9XG5cbiAgc2V0SFJlZihocmVmKSB7IHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgaHJlZik7IH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYVwiO1xufVxuXG5PYmplY3QuYXNzaWduKExpbmsucHJvdG90eXBlLCBmb2N1c01peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgaW5wdXRNaXhpbnMgZnJvbSBcIi4uL21peGlucy9pbnB1dFwiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZm9jdXNcIjtcbmltcG9ydCBzZWxlY3Rpb25NaXhpbnMgZnJvbSBcIi4uL21peGlucy9zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG59XG5cbk9iamVjdC5hc3NpZ24oSW5wdXQucHJvdG90eXBlLCBpbnB1dE1peGlucyk7XG5PYmplY3QuYXNzaWduKElucHV0LnByb3RvdHlwZSwgZm9jdXNNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihJbnB1dC5wcm90b3R5cGUsIHNlbGVjdGlvbk1peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImJ1dHRvblwiO1xufVxuXG5PYmplY3QuYXNzaWduKEJ1dHRvbi5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBpbnB1dE1peGlucyBmcm9tIFwiLi4vbWl4aW5zL2lucHV0XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcInNlbGVjdFwiO1xufVxuXG5PYmplY3QuYXNzaWduKFNlbGVjdC5wcm90b3R5cGUsIGlucHV0TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oU2VsZWN0LnByb3RvdHlwZSwgZm9jdXNNaXhpbnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vZWxlbWVudFwiO1xuaW1wb3J0IGlucHV0TWl4aW5zIGZyb20gXCIuLi9taXhpbnMvaW5wdXRcIjtcbmltcG9ydCBmb2N1c01peGlucyBmcm9tIFwiLi4vbWl4aW5zL2ZvY3VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgRWxlbWVudCB7XG4gIGlzQ2hlY2tlZCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jaGVja2VkOyB9XG5cbiAgY2hlY2soY2hlY2tlZCA9IHRydWUpIHsgdGhpcy5kb21FbGVtZW50LmNoZWNrZWQgPSBjaGVja2VkOyB9XG5cbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIHR5cGU6IFwiY2hlY2tib3hcIlxuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKENoZWNrYm94LnByb3RvdHlwZSwgaW5wdXRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihDaGVja2JveC5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBpbnB1dE1peGlucyBmcm9tIFwiLi4vbWl4aW5zL2lucHV0XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuaW1wb3J0IHNlbGVjdGlvbk1peGlucyBmcm9tIFwiLi4vbWl4aW5zL3NlbGVjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0YXJlYSBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwidGV4dGFyZWFcIjtcbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0YXJlYS5wcm90b3R5cGUsIGlucHV0TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oVGV4dGFyZWEucHJvdG90eXBlLCBmb2N1c01peGlucyk7XG5PYmplY3QuYXNzaWduKFRleHRhcmVhLnByb3RvdHlwZSwgc2VsZWN0aW9uTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFjdCB9IGZyb20gXCIuL3JlYWN0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJvdW5kcyB9IGZyb20gXCIuL2JvdW5kc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRUeXBlcyB9IGZyb20gXCIuL2V2ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbW91c2VCdXR0b25zIH0gZnJvbSBcIi4vbW91c2VCdXR0b25zXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVsZW1lbnRVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnB1dE1peGlucyB9IGZyb20gXCIuL21peGlucy9pbnB1dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmb2N1c01peGlucyB9IGZyb20gXCIuL21peGlucy9mb2N1c1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZWxlY3Rpb25NaXhpbnMgfSBmcm9tIFwiLi9taXhpbnMvc2VsZWN0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGN1c3RvbUV2ZW50TWl4aW5zIH0gZnJvbSBcIi4vbWl4aW5zL2N1c3RvbUV2ZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZW1lbnQgfSBmcm9tIFwiLi9lbGVtZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRFbGVtZW50IH0gZnJvbSBcIi4vdGV4dEVsZW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZG9jdW1lbnQgfSBmcm9tIFwiLi9kb2N1bWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aW5kb3cgfSBmcm9tIFwiLi93aW5kb3dcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm9keSB9IGZyb20gXCIuL2VsZW1lbnQvYm9keVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5rIH0gZnJvbSBcIi4vZWxlbWVudC9saW5rXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0IH0gZnJvbSBcIi4vZWxlbWVudC9pbnB1dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b24gfSBmcm9tIFwiLi9lbGVtZW50L2J1dHRvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QgfSBmcm9tIFwiLi9lbGVtZW50L3NlbGVjdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVja2JveCB9IGZyb20gXCIuL2VsZW1lbnQvY2hlY2tib3hcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dGFyZWEgfSBmcm9tIFwiLi9lbGVtZW50L3RleHRhcmVhXCI7XG5cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSZWFjdCB9IGZyb20gXCJlYXN5XCI7XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywge1xuICBSZWFjdFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcIi4vanV4dGFwb3NlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHRhZ05hbWVzID0gW1xuICBcImFcIiwgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFzaWRlXCIsIFwiYXVkaW9cIixcbiAgXCJiXCIsIFwiYmFzZVwiLCBcImJkaVwiLCBcImJkb1wiLCBcImJsb2NrcXVvdGVcIiwgXCJib2R5XCIsIFwiYnJcIiwgXCJidXR0b25cIixcbiAgXCJjYW52YXNcIiwgXCJjYXB0aW9uXCIsIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJjb2xcIiwgXCJjb2xncm91cFwiLFxuICBcImRhdGFcIiwgXCJkYXRhbGlzdFwiLCBcImRkXCIsIFwiZGVsXCIsIFwiZGV0YWlsc1wiLCBcImRmblwiLCBcImRpYWxvZ1wiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImVtYmVkXCIsIFwiZmllbGRzZXRcIiwgXCJmaWdjYXB0aW9uXCIsIFwiZmlndXJlXCIsIFwiZm9vdGVyXCIsIFwiZm9ybVwiLFxuICBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcImhlYWRcIiwgXCJoZWFkZXJcIiwgXCJoclwiLCBcImh0bWxcIixcbiAgXCJpXCIsIFwiaWZyYW1lXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibGlua1wiLFxuICBcIm1haW5cIiwgXCJtYXBcIiwgXCJtYXJrXCIsIFwibWV0YVwiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwibm9zY3JpcHRcIixcbiAgXCJvYmplY3RcIiwgXCJvbFwiLCBcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwib3V0cHV0XCIsXG4gIFwicFwiLCBcInBhcmFtXCIsIFwicGljdHVyZVwiLCBcInByZVwiLCBcInByb2dyZXNzXCIsXG4gIFwicVwiLCBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsXG4gIFwic1wiLCBcInNhbXBcIiwgXCJzY3JpcHRcIiwgXCJzZWN0aW9uXCIsIFwic2VsZWN0XCIsIFwic21hbGxcIiwgXCJzb3VyY2VcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3R5bGVcIiwgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsIFwic3VwXCIsIFwic3ZnXCIsXG4gIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGVtcGxhdGVcIiwgXCJ0ZXh0YXJlYVwiLCBcInRmb290XCIsIFwidGhcIiwgXCJ0aGVhZFwiLCBcInRpbWVcIiwgXCJ0aXRsZVwiLCBcInRyXCIsIFwidHJhY2tcIixcbiAgXCJ1XCIsIFwidWxcIixcbiAgXCJ2YXJcIiwgXCJ2aWRlb1wiLFxuICBcIndiclwiXG5dO1xuXG5leHBvcnQgZGVmYXVsdCB0YWdOYW1lcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRSQUNFX0xFVkVMID0gXCJ0cmFjZVwiO1xuZXhwb3J0IGNvbnN0IERFQlVHX0xFVkVMID0gXCJkZWJ1Z1wiO1xuZXhwb3J0IGNvbnN0IElORk9fTEVWRUwgPSBcImluZm9cIjtcbmV4cG9ydCBjb25zdCBXQVJOSU5HX0xFVkVMID0gXCJ3YXJuaW5nXCI7XG5leHBvcnQgY29uc3QgRVJST1JfTEVWRUwgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgRkFUQUxfTEVWRUwgPSBcImZhdGFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTCxcbiAgRkFUQUxfTEVWRUxcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBHRVRfTUVUSE9EID0gXCJHRVRcIjtcbmV4cG9ydCBjb25zdCBQT1NUX01FVEhPRCA9IFwiUE9TVFwiO1xuZXhwb3J0IGNvbnN0IFBBVENIX01FVEhPRCA9IFwiUEFUQ0hcIjtcbmV4cG9ydCBjb25zdCBERUxFVEVfTUVUSE9EID0gXCJERUxFVEVcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05TX01FVEhPRCA9IFwiT1BUSU9OU1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEdFVF9NRVRIT0QsXG4gIFBPU1RfTUVUSE9ELFxuICBQQVRDSF9NRVRIT0QsXG4gIERFTEVURV9NRVRIT0QsXG4gIE9QVElPTlNfTUVUSE9EXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgUFJBR01BX0hFQURFUiA9IFwicHJhZ21hXCI7XG5leHBvcnQgY29uc3QgQUNDRVBUX0hFQURFUiA9IFwiYWNjZXB0XCI7XG5leHBvcnQgY29uc3QgTE9DQVRJT05fSEVBREVSID0gXCJsb2NhdGlvblwiO1xuZXhwb3J0IGNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gXCJ1c2VyLWFnZW50XCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9IFwiY29udGVudC10eXBlXCI7XG5leHBvcnQgY29uc3QgQVVUSE9SSVpBVElPTl9IRUFERVIgPSBcImF1dGhvcml6YXRpb25cIjtcbmV4cG9ydCBjb25zdCBDQUNIRV9DT05UUk9MX0hFQURFUiA9IFwiY2FjaGUtY29udHJvbFwiO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfTEVOR1RIX0hFQURFUiA9IFwiY29udGVudC1sZW5ndGhcIjtcbmV4cG9ydCBjb25zdCBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIgPSBcInRyYW5zZmVyLWVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9ESVNQT1NJVElPTl9IRUFERVIgPSBcImNvbnRlbnQtZGlzcG9zaXRpb25cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1vcmlnaW5cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUiA9IFwiYWNjZXNzLWNvbnRyb2wtYWxsb3ctbWV0aG9kc1wiO1xuZXhwb3J0IGNvbnN0IEFDQ0VTU19DT05UUk9MX0FMTE9XX0hFQURFUlNfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzXCI7XG5leHBvcnQgY29uc3QgQUNDRVNTX0NPTlRST0xfUkVRVUVTVF9NRVRIT0RfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSQUdNQV9IRUFERVIsXG4gIEFDQ0VQVF9IRUFERVIsXG4gIExPQ0FUSU9OX0hFQURFUixcbiAgVVNFUl9BR0VOVF9IRUFERVIsXG4gIENPTlRFTlRfVFlQRV9IRUFERVIsXG4gIEFVVEhPUklaQVRJT05fSEVBREVSLFxuICBDQUNIRV9DT05UUk9MX0hFQURFUixcbiAgQ09OVEVOVF9MRU5HVEhfSEVBREVSLFxuICBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIsXG4gIENPTlRFTlRfRElTUE9TSVRJT05fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUixcbiAgQUNDRVNTX0NPTlRST0xfQUxMT1dfSEVBREVSU19IRUFERVIsXG4gIEFDQ0VTU19DT05UUk9MX1JFUVVFU1RfTUVUSE9EX0hFQURFUlxufTsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUQUJfS0VZX0NPREUgPSA5O1xuZXhwb3J0IGNvbnN0IFNISUZUX0tFWV9DT0RFID0gMTY7XG5leHBvcnQgY29uc3QgRU5URVJfS0VZX0NPREUgPSAxMztcbmV4cG9ydCBjb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcbmV4cG9ydCBjb25zdCBERUxFVEVfS0VZX0NPREUgPSA0NjtcbmV4cG9ydCBjb25zdCBCQUNLU1BBQ0VfS0VZX0NPREUgPSA4O1xuZXhwb3J0IGNvbnN0IEFSUk9XX1VQX0tFWV9DT0RFID0gMzg7XG5leHBvcnQgY29uc3QgQVJST1dfRE9XTl9LRVlfQ09ERSA9IDQwO1xuZXhwb3J0IGNvbnN0IEFSUk9XX0xFRlRfS0VZX0NPREUgPSAzNztcbmV4cG9ydCBjb25zdCBBUlJPV19SSUdIVF9LRVlfQ09ERSA9IDM5O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRBQl9LRVlfQ09ERSxcbiAgU0hJRlRfS0VZX0NPREUsXG4gIEVOVEVSX0tFWV9DT0RFLFxuICBFU0NBUEVfS0VZX0NPREUsXG4gIERFTEVURV9LRVlfQ09ERSxcbiAgQkFDS1NQQUNFX0tFWV9DT0RFLFxuICBBUlJPV19VUF9LRVlfQ09ERSxcbiAgQVJST1dfRE9XTl9LRVlfQ09ERSxcbiAgQVJST1dfTEVGVF9LRVlfQ09ERSxcbiAgQVJST1dfUklHSFRfS0VZX0NPREVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVVEY4X0VOQ09ESU5HID0gXCJ1dGY4XCI7XG5leHBvcnQgY29uc3QgVVRGXzhfRU5DT0RJTkcgPSBcInV0Zi04XCI7XG5leHBvcnQgY29uc3QgQkFTRTY0X0VOQ09ESU5HID0gXCJiYXNlNjRcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBVVEY4X0VOQ09ESU5HLFxuICBVVEZfOF9FTkNPRElORyxcbiAgQkFTRTY0X0VOQ09ESU5HXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgVVBfQ0hBUkFDVEVSID0gXCJcdTAwMWJbQVwiO1xuZXhwb3J0IGNvbnN0IEVUWF9DSEFSQUNURVIgPSBcIlxcdTAwMDNcIjtcbmV4cG9ydCBjb25zdCBCQVJfQ0hBUkFDVEVSID0gXCJ8XCI7XG5leHBvcnQgY29uc3QgSEFUX0NIQVJBQ1RFUiA9IFwiXlwiO1xuZXhwb3J0IGNvbnN0IFBMVVNfQ0hBUkFDVEVSID0gXCIrXCI7XG5leHBvcnQgY29uc3QgREFTSF9DSEFSQUNURVIgPSBcIi1cIjtcbmV4cG9ydCBjb25zdCBET1dOX0NIQVJBQ1RFUiA9IFwiXHUwMDFiW0JcIjtcbmV4cG9ydCBjb25zdCBMRUZUX0NIQVJBQ1RFUiA9IFwiXHUwMDFiW0RcIjtcbmV4cG9ydCBjb25zdCBSSUdIVF9DSEFSQUNURVIgPSBcIlx1MDAxYltDXCI7XG5leHBvcnQgY29uc3QgU1BBQ0VfQ0hBUkFDVEVSID0gXCIgXCI7XG5leHBvcnQgY29uc3QgQ09NTUFfQ0hBUkFDVEVSID0gXCIsXCI7XG5leHBvcnQgY29uc3QgQ09MT05fQ0hBUkFDVEVSID0gXCI6XCI7XG5leHBvcnQgY29uc3QgUEVSSU9EX0NIQVJBQ1RFUiA9IFwiLlwiO1xuZXhwb3J0IGNvbnN0IERPTExBUl9DSEFSQUNURVIgPSBcIiRcIjtcbmV4cG9ydCBjb25zdCBDVFJMX0NfQ0hBUkFDVEVSID0gXCJeQ1wiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRV9DSEFSQUNURVIgPSBcIlxcdTAwMWJcIjtcbmV4cG9ydCBjb25zdCBBU1RFUklTS19DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBCQUNLVElDS19ERUxJTUlURVIgPSBcImBcIjtcbmV4cG9ydCBjb25zdCBORVdfTElORV9DSEFSQUNURVIgPSBcIlxcblwiO1xuZXhwb3J0IGNvbnN0IEFNUEVSU0FORF9DSEFSQUNURVIgPSBcIiZcIjtcbmV4cG9ydCBjb25zdCBCQUNLU0xBU0hfQ0hBUkFDVEVSID0gXCJcXFxcXCI7XG5leHBvcnQgY29uc3QgQkFDS1NQQUNFX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbmV4cG9ydCBjb25zdCBRVUVTVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiP1wiO1xuZXhwb3J0IGNvbnN0IEZPUldBUkRfU0xBU0hfQ0hBUkFDVEVSID0gXCIvXCI7XG5leHBvcnQgY29uc3QgT1BFTklOR19CUkFDS0VUX0NIQVJBQ1RFUiA9IFwiKFwiO1xuZXhwb3J0IGNvbnN0IENMT1NJTkdfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIilcIjtcbmV4cG9ydCBjb25zdCBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSID0gXCJcXHJcIjtcbmV4cG9ydCBjb25zdCBFWENMQU1BVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiIVwiO1xuZXhwb3J0IGNvbnN0IE9QRU5JTkdfQ1VSTFlfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIntcIjtcbmV4cG9ydCBjb25zdCBDTE9TSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSID0gXCJ9XCI7XG5leHBvcnQgY29uc3QgT1BFTklOR19TUVVBUkVfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIltcIjtcbmV4cG9ydCBjb25zdCBDTE9TSU5HX1NRVUFSRV9CUkFDS0VUX0NIQVJBQ1RFUiA9IFwiXVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVQX0NIQVJBQ1RFUixcbiAgRVRYX0NIQVJBQ1RFUixcbiAgQkFSX0NIQVJBQ1RFUixcbiAgSEFUX0NIQVJBQ1RFUixcbiAgUExVU19DSEFSQUNURVIsXG4gIERBU0hfQ0hBUkFDVEVSLFxuICBET1dOX0NIQVJBQ1RFUixcbiAgTEVGVF9DSEFSQUNURVIsXG4gIFJJR0hUX0NIQVJBQ1RFUixcbiAgU1BBQ0VfQ0hBUkFDVEVSLFxuICBDT01NQV9DSEFSQUNURVIsXG4gIENPTE9OX0NIQVJBQ1RFUixcbiAgUEVSSU9EX0NIQVJBQ1RFUixcbiAgRE9MTEFSX0NIQVJBQ1RFUixcbiAgQ1RSTF9DX0NIQVJBQ1RFUixcbiAgRVNDQVBFX0NIQVJBQ1RFUixcbiAgQVNURVJJU0tfQ0hBUkFDVEVSLFxuICBXSUxEQ0FSRF9DSEFSQUNURVIsXG4gIEJBQ0tUSUNLX0RFTElNSVRFUixcbiAgTkVXX0xJTkVfQ0hBUkFDVEVSLFxuICBBTVBFUlNBTkRfQ0hBUkFDVEVSLFxuICBCQUNLU0xBU0hfQ0hBUkFDVEVSLFxuICBCQUNLU1BBQ0VfQ0hBUkFDVEVSLFxuICBRVUVTVElPTl9NQVJLX0NIQVJBQ1RFUixcbiAgRk9SV0FSRF9TTEFTSF9DSEFSQUNURVIsXG4gIE9QRU5JTkdfQlJBQ0tFVF9DSEFSQUNURVIsXG4gIENMT1NJTkdfQlJBQ0tFVF9DSEFSQUNURVIsXG4gIENBUlJJQUdFX1JFVFVSTl9DSEFSQUNURVIsXG4gIEVYQ0xBTUFUSU9OX01BUktfQ0hBUkFDVEVSLFxuICBPUEVOSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSLFxuICBDTE9TSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSLFxuICBPUEVOSU5HX1NRVUFSRV9CUkFDS0VUX0NIQVJBQ1RFUixcbiAgQ0xPU0lOR19TUVVBUkVfQlJBQ0tFVF9DSEFSQUNURVJcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBaRVJPXzBfU1RBVFVTX0NPREUgPSAwO1xuZXhwb3J0IGNvbnN0IE9LXzIwMF9TVEFUVVNfQ09ERSA9IDIwMDtcbmV4cG9ydCBjb25zdCBGT1VORF8zMDJfU1RBVFVTX0NPREUgPSAzMDI7XG5leHBvcnQgY29uc3QgQ1JFQVRFRF8yMDFfU1RBVFVTX0NPREUgPSAyMDE7XG5leHBvcnQgY29uc3QgQ09ORkxJQ1RfNDA5X1NUQVRVU19DT0RFID0gNDA5O1xuZXhwb3J0IGNvbnN0IFNFRV9PVEhFUl8zMDNfU1RBVFVTX0NPREUgPSAzMDM7XG5leHBvcnQgY29uc3QgRk9SQklEREVOXzQwM19TVEFUVVNfQ09ERSA9IDQwMztcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkRfNDA0X1NUQVRVU19DT0RFID0gNDA0O1xuZXhwb3J0IGNvbnN0IE5PX0NPTlRFTlRfMjA0X1NUQVRVU19DT0RFID0gMjA0O1xuZXhwb3J0IGNvbnN0IEJBRF9HQVRFV0FZXzUwMl9TVEFUVVNfQ09ERSA9IDUwMjtcbmV4cG9ydCBjb25zdCBCQURfUkVRVUVTVF80MDBfU1RBVFVTX0NPREUgPSA0MDA7XG5leHBvcnQgY29uc3QgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfQ09ERSA9IDQwMTtcbmV4cG9ydCBjb25zdCBOT1RfQUNDRVBUQUJMRV80MDZfU1RBVFVTX0NPREUgPSA0MDY7XG5leHBvcnQgY29uc3QgUkVRVUVTVF9USU1FT1VUXzQwOF9TVEFUVVNfQ09ERSA9IDQwODtcbmV4cG9ydCBjb25zdCBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX0NPREUgPSA0Mjk7XG5leHBvcnQgY29uc3QgTUVUSE9EX05PVF9BTExPV0VEXzQwNV9TVEFUVVNfQ09ERSA9IDQwNTtcbmV4cG9ydCBjb25zdCBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfQ09ERSA9IDUwMztcbmV4cG9ydCBjb25zdCBVTlBST0NFU1NBQkxFX0VOVElUWV80MjJfU1RBVFVTX0NPREUgPSA0MjI7XG5leHBvcnQgY29uc3QgSU5URVJOQUxfU0VSVkVSX0VSUk9SXzUwMF9TVEFUVVNfQ09ERSA9IDUwMDtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFpFUk9fMF9TVEFUVVNfQ09ERSxcbiAgT0tfMjAwX1NUQVRVU19DT0RFLFxuICBGT1VORF8zMDJfU1RBVFVTX0NPREUsXG4gIENSRUFURURfMjAxX1NUQVRVU19DT0RFLFxuICBDT05GTElDVF80MDlfU1RBVFVTX0NPREUsXG4gIFNFRV9PVEhFUl8zMDNfU1RBVFVTX0NPREUsXG4gIEZPUkJJRERFTl80MDNfU1RBVFVTX0NPREUsXG4gIE5PVF9GT1VORF80MDRfU1RBVFVTX0NPREUsXG4gIE5PX0NPTlRFTlRfMjA0X1NUQVRVU19DT0RFLFxuICBCQURfR0FURVdBWV81MDJfU1RBVFVTX0NPREUsXG4gIEJBRF9SRVFVRVNUXzQwMF9TVEFUVVNfQ09ERSxcbiAgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfQ09ERSxcbiAgTk9UX0FDQ0VQVEFCTEVfNDA2X1NUQVRVU19DT0RFLFxuICBSRVFVRVNUX1RJTUVPVVRfNDA4X1NUQVRVU19DT0RFLFxuICBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX0NPREUsXG4gIE1FVEhPRF9OT1RfQUxMT1dFRF80MDVfU1RBVFVTX0NPREUsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEVfNTAzX1NUQVRVU19DT0RFLFxuICBVTlBST0NFU1NBQkxFX0VOVElUWV80MjJfU1RBVFVTX0NPREUsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUl81MDBfU1RBVFVTX0NPREVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBURVhUX0hUTUxfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWxcIjtcbmV4cG9ydCBjb25zdCBURVhUX1BMQUlOX0NPTlRFTlRfVFlQRSA9IFwidGV4dC9wbGFpblwiO1xuZXhwb3J0IGNvbnN0IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5leHBvcnQgY29uc3QgVEVYVF9IVE1MX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLThcIjtcbmV4cG9ydCBjb25zdCBURVhUX1BMQUlOX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fT0NURVRfU1RSRUFNX0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fWF9XV1dfRk9STV9FTkNPREVEX0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fSlNPTl9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuZXhwb3J0IGNvbnN0IEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVEVYVF9IVE1MX0NPTlRFTlRfVFlQRSxcbiAgVEVYVF9QTEFJTl9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFLFxuICBURVhUX0hUTUxfQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIFRFWFRfUExBSU5fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX09DVEVUX1NUUkVBTV9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFpFUk9fMF9TVEFUVVNfTUVTU0FHRSA9IFwiXCI7XG5leHBvcnQgY29uc3QgT0tfMjAwX1NUQVRVU19NRVNTQUdFID0gXCJPS1wiO1xuZXhwb3J0IGNvbnN0IEZPVU5EXzMwMl9TVEFUVVNfTUVTU0FHRSA9IFwiRm91bmRcIjtcbmV4cG9ydCBjb25zdCBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSA9IFwiQ3JlYXRlZFwiO1xuZXhwb3J0IGNvbnN0IENPTkZMSUNUXzQwOV9TVEFUVVNfTUVTU0FHRSA9IFwiQ29uZmxpY3RcIjtcbmV4cG9ydCBjb25zdCBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFID0gXCJTZWUgb3RoZXJcIjtcbmV4cG9ydCBjb25zdCBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFID0gXCJGb3JiaWRkZW5cIjtcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFID0gXCJOb3QgZm91bmRcIjtcbmV4cG9ydCBjb25zdCBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSA9IFwiTm8gY29udGVudFwiO1xuZXhwb3J0IGNvbnN0IEJBRF9HQVRFV0FZXzUwMl9TVEFUVVNfTUVTU0FHRSA9IFwiQmFkIGdhdGV3YXlcIjtcbmV4cG9ydCBjb25zdCBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UgPSBcIkJhZCByZXF1ZXN0XCI7XG5leHBvcnQgY29uc3QgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfTUVTU0FHRSA9IFwiVW5hdXRob3JpemVkXCI7XG5leHBvcnQgY29uc3QgTk9UX0FDQ0VQVEFCTEVfNDA2X1NUQVRVU19NRVNTQUdFID0gXCJOb3QgQWNjZXB0YWJsZVwiO1xuZXhwb3J0IGNvbnN0IFJFUVVFU1RfVElNRU9VVF80MDhfU1RBVFVTX01FU1NBR0UgPSBcIlJlcXVlc3QgdGltZW91dFwiO1xuZXhwb3J0IGNvbnN0IFRPT19NQU5ZX1JFUVVFU1RTXzQyOV9TVEFUVVNfTUVTU0FHRSA9IFwiVG9vIG1hbnkgcmVxdWVzdHNcIjtcbmV4cG9ydCBjb25zdCBNRVRIT0RfTk9UX0FMTE9XRURfNDA1X1NUQVRVU19NRVNTQUdFID0gXCJNZXRob2Qgbm90IGFsbG93ZWRcIjtcbmV4cG9ydCBjb25zdCBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfTUVTU0FHRSA9IFwiU2VydmljZSB1bmF2YWlsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IFVOUFJPQ0VTU0FCTEVfRU5USVRZXzQyMl9TVEFUVVNfTUVTU0FHRSA9IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIjtcbmV4cG9ydCBjb25zdCBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19NRVNTQUdFID0gXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBaRVJPXzBfU1RBVFVTX01FU1NBR0UsXG4gIE9LXzIwMF9TVEFUVVNfTUVTU0FHRSxcbiAgRk9VTkRfMzAyX1NUQVRVU19NRVNTQUdFLFxuICBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSxcbiAgQ09ORkxJQ1RfNDA5X1NUQVRVU19NRVNTQUdFLFxuICBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFLFxuICBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFLFxuICBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFLFxuICBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSxcbiAgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19NRVNTQUdFLFxuICBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UsXG4gIFVOQVVUSE9SSVpFRF80MDFfU1RBVFVTX01FU1NBR0UsXG4gIE5PVF9BQ0NFUFRBQkxFXzQwNl9TVEFUVVNfTUVTU0FHRSxcbiAgUkVRVUVTVF9USU1FT1VUXzQwOF9TVEFUVVNfTUVTU0FHRSxcbiAgVE9PX01BTllfUkVRVUVTVFNfNDI5X1NUQVRVU19NRVNTQUdFLFxuICBNRVRIT0RfTk9UX0FMTE9XRURfNDA1X1NUQVRVU19NRVNTQUdFLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfTUVTU0FHRSxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFlfNDIyX1NUQVRVU19NRVNTQUdFLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19NRVNTQUdFXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgWkVSTyA9IFwiMFwiO1xuZXhwb3J0IGNvbnN0IERBVEEgPSBcImRhdGFcIjtcbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBTVFJJTkcgPSBcInN0cmluZ1wiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUiA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFQgPSBcImRlZmF1bHRcIjtcbmV4cG9ydCBjb25zdCBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVCA9IFwiRU5WSVJPTk1FTlRcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IERPVUJMRV9TUEFDRSA9IFwiICBcIjtcbmV4cG9ydCBjb25zdCBQQUNLQUdFX0pTT04gPSBcInBhY2thZ2UuanNvblwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzBdO31cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZChhcnJheSkgeyByZXR1cm4gYXJyYXlbMV07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkKGFycmF5KSB7IHJldHVybiBhcnJheVsyXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZm91cnRoKGFycmF5KSB7IHJldHVybiBhcnJheVszXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlmdGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzRdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXh0aChhcnJheSkgeyByZXR1cm4gYXJyYXlbNV07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldmVudGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzZdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBlaWdodGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzddOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBuaW50aChhcnJheSkgeyByZXR1cm4gYXJyYXlbOF07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbnRoKGFycmF5KSB7IHJldHVybiBhcnJheVs5XTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RMYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vjb25kTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMl07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gM107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvdXJ0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDRdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWZ0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDVdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXh0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDZdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXZlbnRoTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gN107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGVpZ2h0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDhdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBuaW50aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDldOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCwgMSk7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDEpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZShhcnJheS5sZW5ndGggLSAxKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbnQoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDAsIE1hdGgubWF4KDEsIGFycmF5Lmxlbmd0aCAtIDEpKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheUEsIGFycmF5QikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheUEsIGFycmF5Qik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2hpZnQoYXJyYXlBLCBhcnJheUIpIHsgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYXJyYXlBLCBhcnJheUIpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoYXJyYXlBLCBlbGVtZW50T3JBcnJheTIpIHtcbiAgY29uc3QgYXJyYXlCID0gKGVsZW1lbnRPckFycmF5MiBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRPckFycmF5MiA6XG4gICAgICAgICAgICAgICAgICAgICBbIGVsZW1lbnRPckFycmF5MiBdO1xuICBcbiAgcHVzaChhcnJheUEsIGFycmF5Qik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihhcnJheSkge1xuICBjb25zdCBzdGFydCA9IDA7XG4gIFxuICByZXR1cm4gYXJyYXkuc3BsaWNlKHN0YXJ0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoYXJyYXlBLCBhcnJheUIpIHtcbiAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICBkZWxldGVDb3VudCA9IGFycmF5Qi5sZW5ndGg7ICAvLy9cbiAgXG4gIHNwbGljZShhcnJheUEsIHN0YXJ0LCBkZWxldGVDb3VudCwgYXJyYXlCKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKGFycmF5QSwgYXJyYXlCKSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFycmF5QSwgYXJyYXlCKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2goYXJyYXlBLCBhcnJheUIsIGNhbGxiYWNrKSB7XG4gIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aCxcbiAgICAgICAgYXJyYXlCTGVuZ3RoID0gYXJyYXlCLmxlbmd0aDtcblxuICBpZiAoYXJyYXlBTGVuZ3RoID09PSBhcnJheUJMZW5ndGgpIHtcbiAgICBtYXRjaGVzID0gYXJyYXlBLmV2ZXJ5KChlbGVtZW50QSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRCID0gYXJyYXlCW2luZGV4XSxcbiAgICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBLCBlbGVtZW50QiwgaW5kZXgpO1xuXG4gICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBsZXQgY291cGxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGFycmF5QUxlbmd0aCA9IGFycmF5QS5sZW5ndGgsXG4gICAgICAgIGFycmF5Qkxlbmd0aCA9IGFycmF5Qi5sZW5ndGg7XG5cbiAgaWYgKGFycmF5QUxlbmd0aCA9PT0gYXJyYXlCTGVuZ3RoKSB7XG4gICAgYXJyYXlCID0gWyAgLy8vXG4gICAgICAuLi5hcnJheUJcbiAgICBdO1xuXG4gICAgY291cGxlZCA9IGFycmF5QS5ldmVyeSgoZWxlbWVudEEsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50QiA9IGV4dHJhY3QoYXJyYXlCLCAoZWxlbWVudEIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudEEsIGVsZW1lbnRCKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pIHx8IG51bGw7XG5cbiAgICAgIGlmIChlbGVtZW50QiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3VwbGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29ycmVsYXRlKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheUIgPSBbICAvLy9cbiAgICAuLi5hcnJheUJcbiAgXTtcblxuICBjb25zdCBjb3JyZWxhdGVzID0gYXJyYXlBLmV2ZXJ5KChlbGVtZW50QSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRCID0gZXh0cmFjdChhcnJheUIsIChlbGVtZW50QikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudEEsIGVsZW1lbnRCKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsO1xuXG4gICAgaWYgKGVsZW1lbnRCICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb3JyZWxhdGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShhcnJheUEsIGFycmF5QiwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc29sdmVkO1xuXG4gIGFycmF5QSA9IFsgIC8vL1xuICAgIC4uLmFycmF5QVxuICBdO1xuXG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBhcnJheUFMZW5ndGggPSBhcnJheUEubGVuZ3RoO1xuXG4gICAgaWYgKGFycmF5QUxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICBhcnJheUEuZm9yRWFjaCgoZWxlbWVudEEpID0+IHtcbiAgICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBKTtcblxuICAgICAgaWYgKHBhc3NlZCkge1xuICAgICAgICBjb25zdCBlbGVtZW50QiA9IGVsZW1lbnRBOyAgLy8vXG5cbiAgICAgICAgYXJyYXlCLnB1c2goZWxlbWVudEIpO1xuXG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZpbHRlcihhcnJheUEsIChlbGVtZW50QSkgPT4ge1xuICAgICAgY29uc3QgYXJyYXlCSW5jbHVkZXNFbGVtZW50QSA9IGFycmF5Qi5pbmNsdWRlcyhlbGVtZW50QSk7XG5cbiAgICAgIGlmICghYXJyYXlCSW5jbHVkZXNFbGVtZW50QSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGFycmF5QUxlbmd0aCA9IGFycmF5QS5sZW5ndGg7XG5cbiAgcmVzb2x2ZWQgPSAoYXJyYXlBTGVuZ3RoID09PSAwKTtcblxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gIGZvcndhcmRzRm9yRWFjaChhcnJheSwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2UoYXJyYXksIGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIGxldCBzdGFydDtcbiAgXG4gIGNvbnN0IGZvdW5kID0gYXJyYXkuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBzdGFydCA9IGluZGV4OyAgLy8vXG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIFxuICBpZiAoZm91bmQpIHtcbiAgICBjb25zdCBkZWxldGVDb3VudCA9IDE7XG5cbiAgICBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGljZShhcnJheUEsIHN0YXJ0LCBkZWxldGVDb3VudCA9IEluZmluaXR5LCBhcnJheUIgPSBbXSkge1xuICBjb25zdCBhcmdzID0gWyBzdGFydCwgZGVsZXRlQ291bnQsIC4uLmFycmF5QiBdLFxuICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGFycmF5QSwgYXJncyk7XG5cbiAgcmV0dXJuIGRlbGV0ZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgZGVsZXRlZEVsZW1lbnRzID0gW107XG4gIFxuICBiYWNrd2FyZHNGb3JFYWNoKGFycmF5LCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpbmRleCwgIC8vL1xuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxLFxuICAgICAgICAgICAgZGVsZXRlZEVsZW1lbnRzID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCksXG4gICAgICAgICAgICBmaXJzdERlbGV0ZWRFbGVtZW50ID0gZmlyc3QoZGVsZXRlZEVsZW1lbnRzKTtcbiAgICAgIFxuICAgICAgZGVsZXRlZEVsZW1lbnRzLnVuc2hpZnQoZmlyc3REZWxldGVkRWxlbWVudCk7ICAvLy9cbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGRlbGV0ZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lKGFycmF5LCBjYWxsYmFjaykge1xuICBsZXQgZGVsZXRlZEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gIFxuICBhcnJheS5zb21lKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgICAgICBkZWxldGVDb3VudCA9IDEsXG4gICAgICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSxcbiAgICAgICAgICAgIGZpcnN0RGVsZXRlZEVsZW1lbnQgPSBmaXJzdChkZWxldGVkRWxlbWVudHMpO1xuICAgICAgXG4gICAgICBkZWxldGVkRWxlbWVudCA9IGZpcnN0RGVsZXRlZEVsZW1lbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBkZWxldGVkRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGxldCBkZWxldGVkRWxlbWVudCA9IHVuZGVmaW5lZDtcblxuICBhcnJheS5zb21lKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMSxcbiAgICAgICAgICAgIGRlbGV0ZWRFbGVtZW50cyA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpLFxuICAgICAgICAgICAgZmlyc3REZWxldGVkRWxlbWVudCA9IGZpcnN0KGRlbGV0ZWRFbGVtZW50cyk7XG5cbiAgICAgIGRlbGV0ZWRFbGVtZW50ID0gZmlyc3REZWxldGVkRWxlbWVudDsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWxldGVkRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoKGFycmF5LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICBjb25zdCBmb3VuZCA9IGFycmF5LnNvbWUoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuXG4gIGlmIChmb3VuZCkge1xuICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZm91bmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzcyhhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IGluZGV4MSA9IDAsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4MSA8IGxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnRCID0gYXJyYXlbaW5kZXgxXTtcblxuICAgIGZvciAobGV0IGluZGV4MiA9IGxlbmd0aCAtIDE7IGluZGV4MiA+IGluZGV4MTsgaW5kZXgyLS0pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRBID0gYXJyYXlbaW5kZXgyXSxcbiAgICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBLCBlbGVtZW50Qik7XG5cbiAgICAgIGlmICghcGFzc2VkKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgyLCAvLy9cbiAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgICAgIGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4MSsrO1xuXG4gICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheSA9IFtcbiAgICAuLi5hcnJheUEsXG4gICAgLi4uYXJyYXlCXG4gIF07XG5cbiAgY29tcHJlc3MoYXJyYXksIGNhbGxiYWNrKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gIGFycmF5ID0gWyAvLy9cbiAgICAuLi5hcnJheVxuICBdLnJldmVyc2UoKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdWdtZW50KGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheUIuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheUEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGUoYXJyYXksIGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIHBhc3NlZCA/XG4gICAgICBhcnJheUEucHVzaChlbGVtZW50KSA6XG4gICAgICAgIGFycmF5Qi5wdXNoKGVsZW1lbnQpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRmluZChhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcbiAgICBcbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzRXZlcnkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNSZWR1Y2UoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlOyAvLy9cblxuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzUmVkdWNlKGFycmF5LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTsgLy8vXG5cbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSBhcnJheUxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpcnN0LFxuICBzZWNvbmQsXG4gIHRoaXJkLFxuICBmb3VydGgsXG4gIGZpZnRoLFxuICBzaXh0aCxcbiAgc2V2ZW50aCxcbiAgZWlnaHRoLFxuICBuaW50aCxcbiAgZmlyc3RMYXN0LFxuICBzZWNvbmRMYXN0LFxuICB0aGlyZExhc3QsXG4gIGZvdXJ0aExhc3QsXG4gIGZpZnRoTGFzdCxcbiAgc2l4dGhMYXN0LFxuICBzZXZlbnRoTGFzdCxcbiAgZWlnaHRoTGFzdCxcbiAgbmludGhMYXN0LFxuICBsYXN0LFxuICBoZWFkLFxuICB0YWlsLFxuICBiYWNrLFxuICBmcm9udCxcbiAgcHVzaCxcbiAgdW5zaGlmdCxcbiAgY29uY2F0LFxuICBjbGVhcixcbiAgY29weSxcbiAgbWVyZ2UsXG4gIG1hdGNoLFxuICBjb21wYXJlLFxuICBjb3JyZWxhdGUsXG4gIHJlc29sdmUsXG4gIGZpbmQsXG4gIHJlcGxhY2UsXG4gIHNwbGljZSxcbiAgZmlsdGVyLFxuICBwcnVuZSxcbiAgZXh0cmFjdCxcbiAgcGF0Y2gsXG4gIGNvbXByZXNzLFxuICBjb21iaW5lLFxuICByZXZlcnNlLFxuICBhdWdtZW50LFxuICBzZXBhcmF0ZSxcbiAgZm9yd2FyZHNGaW5kLFxuICBiYWNrd2FyZHNGaW5kLFxuICBmb3J3YXJkc1NvbWUsXG4gIGJhY2t3YXJkc1NvbWUsXG4gIGZvcndhcmRzRXZlcnksXG4gIGJhY2t3YXJkc0V2ZXJ5LFxuICBmb3J3YXJkc1JlZHVjZSxcbiAgYmFja3dhcmRzUmVkdWNlLFxuICBmb3J3YXJkc0ZvckVhY2gsXG4gIGJhY2t3YXJkc0ZvckVhY2gsXG4gIGZvcndhcmRzRmluZEluZGV4LFxuICBiYWNrd2FyZHNGaW5kSW5kZXhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQsIGxhc3QgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhOYW1lKHBhdGgpIHtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIEVNUFRZX1NUUklORykucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7IC8vL1xuXG4gIGNvbnN0IHBhdGhOYW1lID0gKC9cXC8vLnRlc3QocGF0aCkgPT09IGZhbHNlKTtcblxuICByZXR1cm4gcGF0aE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhUb3Btb3N0TmFtZShwYXRoKSB7XG4gIGNvbnN0IHBhdGhOYW1lID0gaXNQYXRoTmFtZShwYXRoKSxcbiAgICAgICAgcGF0aEFic29sdXRlUGF0aCA9IGlzUGF0aEFic29sdXRlUGF0aChwYXRoKSxcbiAgICAgICAgcGF0aFRvcG1vc3ROYW1lID0gKHBhdGhOYW1lICYmIHBhdGhBYnNvbHV0ZVBhdGgpO1xuXG4gIHJldHVybiBwYXRoVG9wbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhSZWxhdGl2ZVBhdGgocGF0aCkge1xuICBjb25zdCBwYXRoUmVsYXRpdmVQYXRoID0gIS9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoUmVsYXRpdmVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXRoQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgY29uc3QgcGF0aEFic29sdXRlUGF0aCA9IC9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoQWJzb2x1dGVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoKHRvcG1vc3ROYW1lLCBhYnNvbHV0ZVBhdGgpIHtcbiAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXiR7dG9wbW9zdE5hbWV9KD86XFxcXC8uKyk/JGApLFxuICAgICAgICB0b3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoID0gcmVnRXhwLnRlc3QoYWJzb2x1dGVQYXRoKTtcblxuICByZXR1cm4gdG9wbW9zdE5hbWVJbkFic29sdXRlUGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVBhdGhzKHBhdGgsIHJlbGF0aXZlUGF0aCkge1xuICBsZXQgY29tYmluZWRQYXRoID0gbnVsbDtcblxuICBjb25zdCBwYXRoTmFtZXMgPSBwYXRoLnNwbGl0KC9cXC8vKSxcbiAgICAgICAgcmVsYXRpdmVQYXRoTmFtZXMgPSByZWxhdGl2ZVBhdGguc3BsaXQoL1xcLy8pO1xuXG4gIGxldCBsYXN0UGF0aE5hbWUsXG4gICAgICBmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPSBmaXJzdChyZWxhdGl2ZVBhdGhOYW1lcyk7XG5cbiAgaWYgKGZpcnN0UmVsYXRpdmVQYXRoTmFtZSA9PT0gXCIuXCIpIHtcbiAgICByZWxhdGl2ZVBhdGhOYW1lcy5zaGlmdCgpO1xuICB9XG5cbiAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICBsYXN0UGF0aE5hbWUgPSBsYXN0KHBhdGhOYW1lcyk7XG5cbiAgd2hpbGUgKChmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPT09IFwiLi5cIikgJiYgKGxhc3RQYXRoTmFtZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHJlbGF0aXZlUGF0aE5hbWVzLnNoaWZ0KCk7XG4gICAgcGF0aE5hbWVzLnBvcCgpO1xuXG4gICAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICAgIGxhc3RQYXRoTmFtZSA9IGxhc3QocGF0aE5hbWVzKTtcbiAgfVxuXG4gIGlmIChsYXN0UGF0aE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbWJpbmVkUGF0aE5hbWVzID0gW10uY29uY2F0KHBhdGhOYW1lcykuY29uY2F0KHJlbGF0aXZlUGF0aE5hbWVzKTtcblxuICAgIGNvbWJpbmVkUGF0aCA9IGNvbWJpbmVkUGF0aE5hbWVzLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkUGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgbGV0IGNvbmNhdGVuYXRlZFBhdGg7XG5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7ICAvLy9cblxuICBjb25jYXRlbmF0ZWRQYXRoID0gYCR7cGF0aH0vJHtyZWxhdGl2ZVBhdGh9YDtcblxuICBjb25zdCByZW1haW5pbmdBQXJndW1lbnRzTGVuZ3RoID0gcmVtYWluaW5nQXJndW1lbnRzLmxlbmd0aDtcblxuICBpZiAocmVtYWluaW5nQUFyZ3VtZW50c0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXRoID0gY29uY2F0ZW5hdGVkUGF0aCwgIC8vL1xuICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5zaGlmdCgpO1xuXG4gICAgY29uY2F0ZW5hdGVkUGF0aCA9IGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZFBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IGJvdHRvbW1vc3ROYW1lID0gbnVsbDtcblxuICBjb25zdCBtYXRjaGVzID0gcGF0aC5tYXRjaCgvXi4qXFwvKFteXFwvXStcXC8/KSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgYm90dG9tbW9zdE5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGJvdHRvbW1vc3ROYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4rKVxcL1teXFwvXStcXC8/JC8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgdG9wbW9zdERpcmVjdG9yeVBhdGggPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aChwYXRoKSB7XG4gIGxldCB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL14oW15cXC9dKylcXC8uKyQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWUgPSBudWxsO1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4qKVxcL1teXFwvXStcXC8/JC8pO1xuXG4gIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBwYXRoV2l0aG91dEJvdHRvbW1vc3ROYW1lID0gc2Vjb25kTWF0Y2g7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL15bXlxcL10rXFwvKC4rKSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IHNlY29uZE1hdGNoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0VG9wbW9zdERpcmVjdG9yeU5hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNQYXRoTmFtZSxcbiAgaXNQYXRoVG9wbW9zdE5hbWUsXG4gIGlzUGF0aFJlbGF0aXZlUGF0aCxcbiAgaXNQYXRoQWJzb2x1dGVQYXRoLFxuICBpc1RvcG1vc3ROYW1lSW5BYnNvbHV0ZVBhdGgsXG4gIGNvbWJpbmVQYXRocyxcbiAgY29uY2F0ZW5hdGVQYXRocyxcbiAgYm90dG9tbW9zdE5hbWVGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aCxcbiAgcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoLFxuICBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNlY29uZCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IENPTE9OX0NIQVJBQ1RFUiwgQU1QRVJTQU5EX0NIQVJBQ1RFUiB9IGZyb20gXCIuLi9jaGFyYWN0ZXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVyd3JpdGUoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgZXhpc3RpbmdOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLCAgLy8vXG4gICAgICAgIGV4aXN0aW5nTmFtZSA9IGV4aXN0aW5nTmFtZXMuZmluZCgoZXhpc3RpbmdOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdMb3dlckNhc2VOYW1lID0gZXhpc3RpbmdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAoZXhpc3RpbmdMb3dlckNhc2VOYW1lID09PSBsb3dlckNhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IG51bGw7XG5cbiAgaWYgKGV4aXN0aW5nTmFtZSAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbZXhpc3RpbmdOYW1lXSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmRlcndyaXRlKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGxvd2VyQ2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGV4aXN0aW5nTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKSwgIC8vL1xuICAgICAgICBleGlzdGluZ05hbWUgPSBleGlzdGluZ05hbWVzLmZpbmQoKGV4aXN0aW5nTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTG93ZXJDYXNlTmFtZSA9IGV4aXN0aW5nTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKGV4aXN0aW5nTG93ZXJDYXNlTmFtZSA9PT0gbG93ZXJDYXNlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChleGlzdGluZ05hbWUgPT09IG51bGwpIHtcbiAgICBoZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcnRGcm9tSG9zdChob3N0KSB7XG4gIGxldCBwb3J0O1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKC9eaHR0cHM/OlxcL1xcLyhbXlxcL10rKS8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgaW5kZXggPSBzZWNvbmRNYXRjaC5pbmRleE9mKENPTE9OX0NIQVJBQ1RFUik7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIGNvbnN0IHNlY3VyZSA9IHNlY3VyZUZyb21Ib3N0KGhvc3QpO1xuXG4gICAgcG9ydCA9IHNlY3VyZSA/IDQ0MyA6IDgwOyAvLy9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGFydCA9IGluZGV4ICsgMSxcbiAgICAgICAgICBwb3J0U3RyaW5nID0gc2Vjb25kTWF0Y2guc3Vic3RyaW5nKHN0YXJ0KTtcblxuICAgIHBvcnQgPSBOdW1iZXIocG9ydFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gcG9ydDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY3VyZUZyb21Ib3N0KGhvc3QpIHtcbiAgY29uc3Qgc2VjdXJlID0gL15odHRwczpcXC9cXC8vLnRlc3QoaG9zdCk7XG5cbiAgcmV0dXJuIHNlY3VyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvc3RuYW1lRnJvbUhvc3QoaG9zdCkge1xuICBjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146XFwvXSspLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpLFxuICAgICAgICBob3N0bmFtZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICByZXR1cm4gaG9zdG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVN0cmluZ0Zyb21RdWVyeShxdWVyeSkge1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHF1ZXJ5KSxcbiAgICAgICAgbmFtZXNMZW5ndGggPSBuYW1lcy5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IG5hbWVzTGVuZ3RoIC0gMSxcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBuYW1lcy5yZWR1Y2UoKHF1ZXJ5U3RyaW5nLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlbbmFtZV0sXG4gICAgICAgICAgICAgICAgZW5jb2RlZE5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSksXG4gICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhbXBlcnNhbmRPck5vdGhpbmcgPSAoaW5kZXggIT09IGxhc3RJbmRleCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQU1QRVJTQU5EX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORztcbiAgXG4gICAgICAgICAgcXVlcnlTdHJpbmcgKz0gYCR7ZW5jb2RlZE5hbWV9PSR7ZW5jb2RlZFZhbHVlfSR7YW1wZXJzYW5kT3JOb3RoaW5nfWA7XG4gIFxuICAgICAgICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcXVlcnlTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxGcm9tSG9zdFVSSUFuZFF1ZXJ5KGhvc3QsIHVyaSwgcXVlcnkpIHtcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZ0Zyb21RdWVyeShxdWVyeSksXG4gICAgICAgIHVybCA9IChxdWVyeVN0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSA/XG4gICAgICAgICAgICAgICAgYCR7aG9zdH0ke3VyaX1gIDpcbiAgICAgICAgICAgICAgICAgIGAke2hvc3R9JHt1cml9PyR7cXVlcnlTdHJpbmd9YDtcblxuICByZXR1cm4gdXJsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG92ZXJ3cml0ZSxcbiAgdW5kZXJ3cml0ZSxcbiAgcG9ydEZyb21Ib3N0LFxuICBzZWN1cmVGcm9tSG9zdCxcbiAgaG9zdG5hbWVGcm9tSG9zdCxcbiAgcXVlcnlTdHJpbmdGcm9tUXVlcnksXG4gIHVybEZyb21Ib3N0VVJJQW5kUXVlcnlcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmxlbihzdHJpbmcpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXG4gIGxldCBjaGFyYWN0ZXIgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFjaGFyYWN0ZXIuZG9uZSkge1xuICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgIGxlbmd0aCsrXG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyY21wKHN0cmluZ0EsIHN0cmluZ0IpIHtcbiAgbGV0IGRpZmZlcmVuY2U7XG5cbiAgY29uc3QgaXRlcmF0b3JBID0gc3RyaW5nQVtTeW1ib2wuaXRlcmF0b3JdKCksIC8vL1xuICAgICAgICBpdGVyYXRvckIgPSBzdHJpbmdCW1N5bWJvbC5pdGVyYXRvcl0oKTsgLy8vXG5cbiAgbGV0IGNoYXJhY3RlckEgPSBpdGVyYXRvckEubmV4dCgpLFxuICAgICAgY2hhcmFjdGVyQiA9IGl0ZXJhdG9yQi5uZXh0KCksXG4gICAgICBjb2RlUG9pbnRBLFxuICAgICAgY29kZVBvaW50QjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvZGVQb2ludEEgPSBjaGFyYWN0ZXJBLnZhbHVlID8gLy8vXG4gICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQS52YWx1ZS5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAwO1xuICAgIGNvZGVQb2ludEIgPSBjaGFyYWN0ZXJCLnZhbHVlID8gLy8vXG4gICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQi52YWx1ZS5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgZGlmZmVyZW5jZSA9IGNvZGVQb2ludEIgLSBjb2RlUG9pbnRBO1xuXG4gICAgaWYgKGRpZmZlcmVuY2UgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjaGFyYWN0ZXJBLmRvbmUgfHwgY2hhcmFjdGVyQi5kb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGFyYWN0ZXJBID0gaXRlcmF0b3JBLm5leHQoKTtcbiAgICBjaGFyYWN0ZXJCID0gaXRlcmF0b3JCLm5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICBsZXQgaW5kZXggPSAtMSxcbiAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgY29uc3Qgc2VhcmNoU3RyaW5nTGVuZ3RoID0gc3RybGVuKHNlYXJjaFN0cmluZyk7XG5cbiAgaWYgKHNlYXJjaFN0cmluZ0xlbmd0aCA+IDApIHtcbiAgICBsZXQgY2hhcmFjdGVyO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICAgIHNlYXJjaEl0ZXJhdG9yID0gc2VhcmNoU3RyaW5nW1N5bWJvbC5pdGVyYXRvcl0oKSxcbiAgICAgICAgICBzZWFyY2hDaGFyYWN0ZXIgPSBzZWFyY2hJdGVyYXRvci5uZXh0KCk7XG5cbiAgICBjaGFyYWN0ZXIgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICBpbmRleCsrO1xuXG4gICAgd2hpbGUgKCFjaGFyYWN0ZXIuZG9uZSkge1xuICAgICAgaWYgKGNoYXJhY3Rlci52YWx1ZSA9PT0gc2VhcmNoQ2hhcmFjdGVyLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBzZWFyY2hTdHJpbmdMZW5ndGgsXG4gICAgICAgICAgICAgIHN1YlN0cmluZyA9IHN1YnN0cmluZyhzdHJpbmcsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICBkaWZmZXJlbmNlID0gc3RyY21wKHN1YlN0cmluZywgc2VhcmNoU3RyaW5nKTtcblxuICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaW5kZXgrK1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQpIHtcbiAgICBpbmRleCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic3RyaW5nKHN0cmluZywgc3RhcnQsIGVuZCA9IEluZmluaXR5KSB7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICBjaGFyYWN0ZXJzID0gW107XG5cbiAgbGV0IGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICB3aGlsZSAoIWNoYXJhY3Rlci5kb25lKSB7XG4gICAgaWYgKGluZGV4ID09PSBlbmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBzdGFydCkge1xuICAgICAgY2hhcmFjdGVycy5wdXNoKGNoYXJhY3Rlci52YWx1ZSk7IC8vL1xuICAgIH1cblxuICAgIGluZGV4KytcblxuICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfVxuXG4gIGNvbnN0IHN1YnN0cmluZyA9IGNoYXJhY3RlcnMuam9pbihFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdWJzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RyY21wLFxuICBzdHJsZW4sXG4gIGluZGV4T2YsXG4gIHN1YnN0cmluZ1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGUoanNvbiwgbWlncmF0aW9uTWFwLCBsYXRlc3RWZXJzaW9uKSB7XG4gIGxldCB7IHZlcnNpb24gfSA9IGpzb247XG5cbiAgd2hpbGUgKHZlcnNpb24gIT09IGxhdGVzdFZlcnNpb24pIHtcbiAgICBjb25zdCBtaWdyYXRlRnVuY3Rpb24gPSBtaWdyYXRpb25NYXBbdmVyc2lvbl07XG5cbiAgICBqc29uID0gbWlncmF0ZUZ1bmN0aW9uKGpzb24pO1xuXG4gICAgKHsgdmVyc2lvbiB9ID0ganNvbik7XG4gIH1cblxuICByZXR1cm4ganNvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtaWdyYXRlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdoaWxzdChvcGVyYXRpb24sIGRvbmUsIGNvbnRleHQpIHtcclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSBjb3VudDsgIC8vL1xyXG5cclxuICAgIG9wZXJhdGlvbihuZXh0LCBkb25lLCBjb250ZXh0LCBpbmRleCk7XHJcbiAgfVxyXG5cclxuICBuZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBvcGVyYXRpb24sIGRvbmUsIGNvbnRleHQpIHtcclxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7ICAvLy9cclxuXHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY291bnQsICAvLy9cclxuICAgICAgICAgICAgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcclxuXHJcbiAgICAgIG9wZXJhdGlvbihlbGVtZW50LCBuZXh0LCBkb25lLCBjb250ZXh0LCBpbmRleCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW5jZShvcGVyYXRpb25zLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9ucy5sZW5ndGg7ICAvLy9cclxuXHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY291bnQsICAvLy9cclxuICAgICAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpbmRleF07XHJcblxyXG4gICAgICBvcGVyYXRpb24obmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXZlbnR1YWxseShvcGVyYXRpb25zLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9ucy5sZW5ndGg7ICAvLy9cclxuXHJcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgZG9uZSgpO1xyXG5cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGxldCBjb3VudCA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9wZXJhdGlvbnMuZm9yRWFjaCgob3BlcmF0aW9uLCBpbmRleCkgPT4ge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdGVkbHkob3BlcmF0aW9uLCBsZW5ndGgsIGRvbmUsIGNvbnRleHQpIHtcclxuICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICBkb25lKCk7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSBsZW5ndGgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc0ZvckVhY2goYXJyYXksIG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xyXG5cclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSBsZW5ndGgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkc0ZvckVhY2goYXJyYXksIG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xyXG5cclxuICBsZXQgY291bnQgPSBsZW5ndGg7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudC0tO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gLTEpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHdoaWxzdCxcclxuICBmb3JFYWNoLFxyXG4gIHNlcXVlbmNlLFxyXG4gIGV2ZW50dWFsbHksXHJcbiAgcmVwZWF0ZWRseSxcclxuICBmb3J3YXJkc0ZvckVhY2gsXHJcbiAgYmFja3dhcmRzRm9yRWFjaFxyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNUUklORywgRlVOQ1RJT04gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBHRVRfTUVUSE9ELCBQT1NUX01FVEhPRCB9IGZyb20gXCIuLi9tZXRob2RzXCI7XG5pbXBvcnQgeyBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSB9IGZyb20gXCIuLi9jb250ZW50VHlwZXNcIjtcbmltcG9ydCB7IEFDQ0VQVF9IRUFERVIsIENPTlRFTlRfVFlQRV9IRUFERVIgfSBmcm9tIFwiLi4vaGVhZGVyc1wiO1xuaW1wb3J0IHsgdW5kZXJ3cml0ZSwgdXJsRnJvbUhvc3RVUklBbmRRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvaHR0cFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGhvc3QsIHVyaSwgcXVlcnksIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSBGVU5DVElPTikge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG5cbiAgICByZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZVR5cGUgPT09IEZVTkNUSU9OKSB7XG4gICAgY2FsbGJhY2sgPSByZXNwb25zZVR5cGU7ICAvLy9cblxuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gU1RSSU5HKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBoZWFkZXJzOyAvLy9cblxuICAgICAgaGVhZGVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gR0VUX01FVEhPRCxcbiAgICAgICAgYWNjZXB0ID0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUsXG4gICAgICAgIGNvbnRlbnQgPSBudWxsO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICByZXF1ZXN0KGhvc3QsIHVyaSwgcXVlcnksIG1ldGhvZCwgY29udGVudCwgaGVhZGVycywgcmVzcG9uc2VUeXBlLCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0KGhvc3QsIHVyaSwgcXVlcnksIGNvbnRlbnQsIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSBGVU5DVElPTikge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG5cbiAgICByZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZVR5cGUgPT09IEZVTkNUSU9OKSB7XG4gICAgY2FsbGJhY2sgPSByZXNwb25zZVR5cGU7ICAvLy9cblxuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gU1RSSU5HKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBoZWFkZXJzOyAvLy9cblxuICAgICAgaGVhZGVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gUE9TVF9NRVRIT0QsXG4gICAgICAgIGFjY2VwdCA9IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFLFxuICAgICAgICBjb250ZW50VHlwZSA9IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICB1bmRlcndyaXRlQ29udGVudFR5cGVIZWFkZXIoaGVhZGVycywgY29udGVudFR5cGUpO1xuXG4gIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBjb250ZW50LCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBjb250ZW50LCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHVybCA9IHVybEZyb21Ib3N0VVJJQW5kUXVlcnkoaG9zdCwgdXJpLCBxdWVyeSksXG4gICAgICAgIGFjY2VwdCA9IGhlYWRlcnNbQUNDRVBUX0hFQURFUl0gfHwgbnVsbCxcbiAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdIHx8IG51bGwsXG4gICAgICAgIHhtbEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgaWYgKGNvbnRlbnRUeXBlID09PSBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSkge1xuICAgIGNvbnN0IGpzb24gPSBjb250ZW50LCAgLy8vXG4gICAgICAgICAganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXG4gICAgY29udGVudCA9IGpzb25TdHJpbmc7ICAvLy9cbiAgfVxuXG4gIGlmIChyZXNwb25zZVR5cGUgIT09IG51bGwpIHtcbiAgICBPYmplY3QuYXNzaWduKHhtbEh0dHBSZXF1ZXN0LCB7XG4gICAgICByZXNwb25zZVR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIHhtbEh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHJlYWR5U3RhdGUsIHN0YXR1cywgcmVzcG9uc2UgfSA9IHhtbEh0dHBSZXF1ZXN0LFxuICAgICAgICAgIHN0YXR1c0NvZGUgPSBzdGF0dXM7XG5cbiAgICBpZiAocmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICBsZXQgY29udGVudCA9IHJlc3BvbnNlO1xuXG4gICAgICBpZiAoYWNjZXB0ID09PSBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBjb250ZW50LCAgLy8vXG4gICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG5cbiAgICAgICAgICBjb250ZW50ID0ganNvbjsgIC8vL1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGNvbnRlbnQsIHN0YXR1c0NvZGUpO1xuICAgIH1cbiAgfTtcblxuICB4bWxIdHRwUmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsKTtcblxuICBpZiAoYWNjZXB0ICE9PSBudWxsKSB7XG4gICAgeG1sSHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihBQ0NFUFRfSEVBREVSLCBhY2NlcHQpO1xuICB9XG5cbiAgaWYgKGNvbnRlbnRUeXBlICE9PSBudWxsKSB7XG4gICAgeG1sSHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihDT05URU5UX1RZUEVfSEVBREVSLCBjb250ZW50VHlwZSk7XG4gIH1cblxuICAoY29udGVudCAhPT0gbnVsbCkgP1xuICAgIHhtbEh0dHBSZXF1ZXN0LnNlbmQoY29udGVudCkgOlxuICAgICAgeG1sSHR0cFJlcXVlc3Quc2VuZCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCxcbiAgcG9zdCxcbiAgcmVxdWVzdFxufVxuXG5mdW5jdGlvbiB1bmRlcndyaXRlQWNjZXB0SGVhZGVyKGhlYWRlcnMsIGFjY2VwdCkge1xuICBjb25zdCBuYW1lID0gQUNDRVBUX0hFQURFUiwgIC8vL1xuICAgICAgICB2YWx1ZSA9IGFjY2VwdDsgLy8vXG5cbiAgdW5kZXJ3cml0ZShoZWFkZXJzLCBuYW1lLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVyd3JpdGVDb250ZW50VHlwZUhlYWRlcihoZWFkZXJzLCBjb250ZW50VFlwZSkge1xuICBjb25zdCBuYW1lID0gQ09OVEVOVF9UWVBFX0hFQURFUiwgIC8vL1xuICAgICAgICB2YWx1ZSA9IGNvbnRlbnRUWXBlOyAvLy9cblxuICB1bmRlcndyaXRlKGhlYWRlcnMsIG5hbWUsIHZhbHVlKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXZlbHMgfSBmcm9tIFwiLi9sZXZlbHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWV0aG9kcyB9IGZyb20gXCIuL21ldGhvZHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaGVhZGVycyB9IGZyb20gXCIuL2hlYWRlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMga2V5Q29kZXMgfSBmcm9tIFwiLi9rZXlDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbmNvZGluZ3MgfSBmcm9tIFwiLi9lbmNvZGluZ3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2hhcmFjdGVycyB9IGZyb20gXCIuL2NoYXJhY3RlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzQ29kZXMgfSBmcm9tIFwiLi9zdGF0dXNDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb250ZW50VHlwZXMgfSBmcm9tIFwiLi9jb250ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzTWVzc2FnZXMgfSBmcm9tIFwiLi9zdGF0dXNNZXNzYWdlc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcGF0aFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBodHRwVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2h0dHBcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3ZlcnNpb25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGFqYXhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYWpheFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgViA9IFwidlwiO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9BTVBFUlNBTkQgPSBcIiZhbXA7XCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9MRVNTX1RIQU4gPSBcIiZsdDtcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0dSRUFURVJfVEhBTiA9IFwiJmd0O1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFU0NBUEVEX0FNUEVSU0FORCwgRVNDQVBFRF9MRVNTX1RIQU4sIEVTQ0FQRURfR1JFQVRFUl9USEFOIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3Qgc2FuaXRpc2VkQ29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgRVNDQVBFRF9BTVBFUlNBTkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIEVTQ0FQRURfTEVTU19USEFOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBFU0NBUEVEX0dSRUFURVJfVEhBTik7XG5cbiAgcmV0dXJuIHNhbml0aXNlZENvbnRlbnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCB0eXBlVHlwZSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IG5hbWVUeXBlID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgbnVtYmVyVHlwZSA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgY29tbWVudFR5cGUgPSBcImNvbW1lbnRcIjtcbmV4cG9ydCBjb25zdCBlbmRPZkxpbmVUeXBlID0gXCJlbmQtb2YtbGluZVwiO1xuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2VUeXBlID0gXCJ3aGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3Qgc3RyaW5nTGl0ZXJhbFR5cGUgPSBcInN0cmluZy1saXRlcmFsXCI7XG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lQ29tbWVudFR5cGUgPSBgJHtlbmRPZkxpbmVUeXBlfSAke2NvbW1lbnRUeXBlfWA7XG5leHBvcnQgY29uc3Qgc2luZ2xlTGluZUNvbW1lbnRUeXBlID0gYHNpbmdsZS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCByZWd1bGFyRXhwcmVzc2lvblR5cGUgPSBcInJlZ3VsYXItZXhwcmVzc2lvblwiO1xuZXhwb3J0IGNvbnN0IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgPSBgZW5kLW9mLW11bHRpLWxpbmUgJHtjb21tZW50VHlwZX1gO1xuZXhwb3J0IGNvbnN0IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZSA9IGBzdGFydC1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlID0gYG1pZGRsZS1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB0eXBlVHlwZSxcbiAgbmFtZVR5cGUsXG4gIG51bWJlclR5cGUsXG4gIGNvbW1lbnRUeXBlLFxuICBlbmRPZkxpbmVUeXBlLFxuICB3aGl0ZXNwYWNlVHlwZSxcbiAgc3RyaW5nTGl0ZXJhbFR5cGUsXG4gIGVuZE9mTGluZUNvbW1lbnRUeXBlLFxuICBzaW5nbGVMaW5lQ29tbWVudFR5cGUsXG4gIHJlZ3VsYXJFeHByZXNzaW9uVHlwZSxcbiAgZW5kT2ZNdWx0aUxpbmVDb21tZW50VHlwZSxcbiAgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlLFxuICBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcywgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBzYW5pdGlzZUNvbnRlbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvY29udGVudFwiO1xuaW1wb3J0IHsgY29tbWVudFR5cGUsIGVuZE9mTGluZVR5cGUsIHdoaXRlc3BhY2VUeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHN0cmxlbiB9ID0gc3RyaW5nVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNvbnRlbnQsIHNpZ25pZmljYW50KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMuc2lnbmlmaWNhbnQgPSBzaWduaWZpY2FudDtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBcbiAgZ2V0Q29udGVudExlbmd0aChuYWl2ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IG5haXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmxlbih0aGlzLmNvbnRlbnQpOyAvLy9cblxuICAgIHJldHVybiBjb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgaXNTaWduaWZpY2FudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudDtcbiAgfVxuICBcbiAgaXNDb21tZW50VG9rZW4oKSB7XG4gICAgY29uc3QgdHlwZUluY2x1ZGVzQ29tbWVudFR5cGUgPSB0aGlzLnR5cGUuaW5jbHVkZXMoY29tbWVudFR5cGUpLFxuICAgICAgICAgIGNvbW1lbnRUb2tlbiA9IHR5cGVJbmNsdWRlc0NvbW1lbnRUeXBlOyAvLy9cblxuICAgIHJldHVybiBjb21tZW50VG9rZW47XG4gIH1cblxuICBpc0VuZE9mTGluZVRva2VuKCkge1xuICAgIGNvbnN0IHR5cGVFbmRPZkxpbmVUeXBlID0gKHRoaXMudHlwZS5pbmNsdWRlcyhlbmRPZkxpbmVUeXBlKSksXG4gICAgICAgICAgZW5kT2ZMaW5lVG9rZW4gPSB0eXBlRW5kT2ZMaW5lVHlwZTsgLy8vXG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lVG9rZW47XG4gIH1cblxuICBpc1doaXRlc3BhY2VUb2tlbigpIHtcbiAgICBjb25zdCB0eXBlV2hpdGVzcGFjZVR5cGUgPSAodGhpcy50eXBlID09PSB3aGl0ZXNwYWNlVHlwZSksXG4gICAgICAgICAgd2hpdGVzcGFjZVRva2VuID0gdHlwZVdoaXRlc3BhY2VUeXBlOyAvLy9cblxuICAgIHJldHVybiB3aGl0ZXNwYWNlVG9rZW47XG4gIH1cblxuICBtYXRjaCh0b2tlbikge1xuICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICBpZiAodG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0b2tlbi5nZXRUeXBlKCksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgc2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgICAgIG1hdGNoZXMgPSAoKHRoaXMudHlwZSA9PT0gdHlwZSkgJiYgKHRoaXMuY29udGVudCA9PT0gY29udGVudCkgJiYgKHRoaXMuc2lnbmlmaWNhbnQgPT09IHNpZ25pZmljYW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBhc0hUTUwoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy50eXBlLCAvLy9cbiAgICAgICAgICBzYW5pdGlzZWRDb250ZW50ID0gc2FuaXRpc2VDb250ZW50KHRoaXMuY29udGVudCksXG4gICAgICAgICAgaHRtbCA9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPiR7c2FuaXRpc2VkQ29udGVudH08L3NwYW4+YDtcblxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgICAgICBzaWduaWZpY2FudCA9IHRoaXMuc2lnbmlmaWNhbnQsXG4gICAgICAgICAgdG9rZW4gPSBuZXcgQ2xhc3ModHlwZSwgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdG9rZW4gPSBudWxsO1xuXG4gICAgY29uc3QgeyByZWd1bGFyRXhwcmVzc2lvbiB9ID0gQ2xhc3MsXG4gICAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2gocmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoZXM7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE1hdGNoID0gZmlyc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgLy8vXG5cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBDbGFzcztcblxuICAgICAgICAgIHRva2VuID0gbmV3IENsYXNzKHR5cGUsIGNvbnRlbnQsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBDbGFzcyxcbiAgICAgICAgICB0b2tlbiA9IG5ldyBDbGFzcyh0eXBlLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgcmV0dXJuIG5ldyBDbGFzcyh0eXBlLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL3Rva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChDbGFzcywgY29udGVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHR5cGUgPSBjb250ZW50OyAvLy9cblxuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW47XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBTaWduaWZpY2FudFRva2VuIGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IFYgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCByZWd1bGFyRXhwcmVzc2lvbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWd1bGFyRXhwcmVzc2lvbiA9IHJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG4gIFxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbiAgXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG5cbiAgbWF0Y2goY29udGVudCkge1xuICAgIGxldCBzaWduaWZpY2FudFRva2VuID0gbnVsbDtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKHRoaXMucmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoZXM7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE1hdGNoID0gZmlyc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgLy8vXG5cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IFNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnRBbmRUeXBlKGNvbnRlbnQsIHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuICBcbiAgc3RhdGljIGZyb21Ub2tlbihUb2tlbikge1xuICAgIGNvbnN0IHsgdHlwZSwgcmVndWxhckV4cHJlc3Npb24gfSA9IFRva2VuLFxuICAgICAgICAgIHJ1bGUgPSBuZXcgUnVsZSh0eXBlLCByZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRW50cnkoZW50cnkpIHtcbiAgICBjb25zdCBlbnRyeUtleXMgPSBPYmplY3Qua2V5cyhlbnRyeSksXG4gICAgICAgICAgZmlyc3RFbnRyeUtleSA9IGZpcnN0KGVudHJ5S2V5cyksXG4gICAgICAgICAgdHlwZSA9IGZpcnN0RW50cnlLZXksIC8vL1xuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiA9IGVudHJ5W3R5cGVdLFxuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb25Gcm9tUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksXG4gICAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgXG4gICAgcmV0dXJuIHJ1bGU7IFxuICB9XG5cbiAgc3RhdGljIGZyb21UeXBlQW5kUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybikge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb25Gcm9tUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksXG4gICAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcblxuICAgIHJldHVybiBydWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ3VsYXJFeHByZXNzaW9uRnJvbVJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybihyZWd1bGFyRXhwcmVzc2lvblBhdHRlcm4pIHtcbiAgY29uc3QgZmxhZ3MgPSBWLCAgLy8vXG4gICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAocmVndWxhckV4cHJlc3Npb25QYXR0ZXJuLCBmbGFncyksXG4gICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uID0gcmVnRXhwOyAvLy9cblxuICByZXR1cm4gcmVndWxhckV4cHJlc3Npb247XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnQgY29uc3QgcGx1cyA9IFwiK1wiO1xyXG5leHBvcnQgY29uc3Qgb3BhcXVlID0gXCIuXCI7XHJcbmV4cG9ydCBjb25zdCBlcHNpbG9uID0gJ1x1MDNCNSc7XHJcbmV4cG9ydCBjb25zdCB3aWxkY2FyZCA9IFwiLlwiO1xyXG5leHBvcnQgY29uc3QgYXN0ZXJpc2sgPSBcIipcIjtcclxuZXhwb3J0IGNvbnN0IGVsbGlwc2lzID0gXCIuLi5cIjtcclxuZXhwb3J0IGNvbnN0IHNlcGFyYXRvciA9IFwiOjo9XCI7XHJcbmV4cG9ydCBjb25zdCBzZW1pT3BhcXVlID0gXCIuLlwiO1xyXG5leHBvcnQgY29uc3QgdGVybWluYXRvciA9IFwiO1wiO1xyXG5leHBvcnQgY29uc3QgdmVydGljYWxCYXIgPSBcInxcIjtcclxuZXhwb3J0IGNvbnN0IG9wZW5CcmFja2V0ID0gXCIoXCI7XHJcbmV4cG9ydCBjb25zdCBjbG9zZUJyYWNrZXQgPSBcIilcIjtcclxuZXhwb3J0IGNvbnN0IHF1ZXN0aW9uTWFyayA9IFwiP1wiO1xyXG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lID0gXCI8RU5EX09GX0xJTkU+XCI7XHJcbmV4cG9ydCBjb25zdCBub1doaXRlc3BhY2UgPSBcIjxOT19XSElURVNQQUNFPlwiO1xyXG5leHBvcnQgY29uc3Qgc3RhcnRPZkNvbnRlbnQgPSBcIjxTVEFSVF9PRl9DT05URU5UPlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHBsdXMsXHJcbiAgb3BhcXVlLFxyXG4gIGVwc2lsb24sXHJcbiAgd2lsZGNhcmQsXHJcbiAgYXN0ZXJpc2ssXHJcbiAgZWxsaXBzaXMsXHJcbiAgc2VwYXJhdG9yLFxyXG4gIHNlbWlPcGFxdWUsXHJcbiAgdGVybWluYXRvcixcclxuICB2ZXJ0aWNhbEJhcixcclxuICBvcGVuQnJhY2tldCxcclxuICBjbG9zZUJyYWNrZXQsXHJcbiAgcXVlc3Rpb25NYXJrLFxyXG4gIGVuZE9mTGluZSxcclxuICBub1doaXRlc3BhY2UsXHJcbiAgc3RhcnRPZkNvbnRlbnRcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNBc0VudHJpZXMocnVsZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHJ1bGVzLm1hcCgocnVsZSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gcnVsZUFzRW50cnkocnVsZSk7XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH0pO1xuXG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJ1bGVzQXNFbnRyaWVzXG59O1xuXG5mdW5jdGlvbiBydWxlQXNFbnRyeShydWxlKSB7XG4gIGNvbnN0IHR5cGUgPSBydWxlLmdldFR5cGUoKSxcbiAgICAgICAgcmVndWxhckV4cHJlc3Npb24gPSBydWxlLmdldFJlZ3VsYXJFeHByZXNzaW9uKCksXG4gICAgICAgIHsgc291cmNlIH0gPSByZWd1bGFyRXhwcmVzc2lvbixcbiAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgW3R5cGVdOiBzb3VyY2VcbiAgICAgICAgfTtcblxuICByZXR1cm4gZW50cnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi9ydWxlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0Zyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgY29uc3QgcnVsZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICBjb25zdCBydWxlID0gUnVsZS5mcm9tRW50cnkoZW50cnkpO1xuXG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0pO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcykge1xuICBjb25zdCBJbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcyksXG4gICAgICAgIE5vdEluQ29tbWVudENsYXNzZXMgPSBOb3RJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSxcbiAgICAgICAgbGV4ZXIgPSBuZXcgQ2xhc3MocnVsZXMsIEluQ29tbWVudENsYXNzZXMsIE5vdEluQ29tbWVudENsYXNzZXMpO1xuXG4gIHJldHVybiBsZXhlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0Zyb21FbnRyaWVzLFxuICBsZXhlckZyb21SdWxlc1xufTtcblxuZnVuY3Rpb24gSW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcykge1xuICBjb25zdCB7IEVuZE9mTGluZUNvbW1lbnRUb2tlbiwgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gPSBDbGFzcztcblxuICBjb25zdCBJbkNvbW1lbnRDbGFzc2VzID0gW1xuICAgIEVuZE9mTGluZUNvbW1lbnRUb2tlbixcbiAgICBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcbiAgICBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlblxuICBdO1xuXG4gIHJldHVybiBJbkNvbW1lbnRDbGFzc2VzO1xufVxuXG5mdW5jdGlvbiBOb3RJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSB7XG4gIGNvbnN0IHsgRW5kT2ZMaW5lVG9rZW4sXG4gICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxuICAgICAgICAgIFNpbmdsZUxpbmVDb21tZW50VG9rZW4sXG4gICAgICAgICAgUmVndWxhckV4cHJlc3Npb25Ub2tlbixcbiAgICAgICAgICBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxuICAgICAgICAgIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSA9IENsYXNzO1xuXG4gIGNvbnN0IE5vdEluQ29tbWVudENsYXNzZXMgPSBbXG4gICAgRW5kT2ZMaW5lVG9rZW4sXG4gICAgV2hpdGVzcGFjZVRva2VuLFxuICAgIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXG4gICAgU2luZ2xlTGluZUNvbW1lbnRUb2tlbixcbiAgICBSZWd1bGFyRXhwcmVzc2lvblRva2VuLFxuICAgIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW5cbiAgXTtcblxuICByZXR1cm4gTm90SW5Db21tZW50Q2xhc3Nlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OlxcXFx8fFxcXFwofFxcXFwpfFxcXFw/fFxcXFwqfFxcXFwrfFxcXFwuXFxcXC5cXFxcLnxcXFxcLlxcXFwufFxcXFwufDo6PXw7fFx1MDNCNXw8U1RBUlRfT0ZfQ09OVEVOVD58PE5PX1dISVRFU1BBQ0U+fDxFTkRfT0ZfTElORT4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibnVtYmVyXCI6IFwiXig/OjB8WzEtOV1bMC05XSopXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIl5bXFxcXHd+XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ0eXBlXCI6IFwiXlxcXFxbW15cXFxcXV0rXFxcXF1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5Db21tZW50RnJvbVRva2VuQW5kSW5Db21tZW50KHRva2VuLCBpbkNvbW1lbnQpIHtcbiAgY29uc3QgdG9rZW5Db21tZW50VG9rZW4gPSB0b2tlbi5pc0NvbW1lbnRUb2tlbigpO1xuXG4gIGlmICh0b2tlbkNvbW1lbnRUb2tlbikge1xuICAgIGNvbnN0IGNvbW1lbnRUb2tlbiA9IHRva2VuLCAvLy9cbiAgICAgICAgICBjb21tZW50VG9rZW5JbkNvbW1lbnRQcmVzZXJ2aW5nID0gY29tbWVudFRva2VuLmlzSW5Db21tZW50UHJlc2VydmluZygpO1xuXG4gICAgaW5Db21tZW50ID0gY29tbWVudFRva2VuSW5Db21tZW50UHJlc2VydmluZzsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGluQ29tbWVudDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgaW5Db21tZW50RnJvbVRva2VuQW5kSW5Db21tZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy90b2tlblwiO1xyXG5pbXBvcnQgeyBydWxlc0Zyb21FbnRyaWVzLCBsZXhlckZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvbGV4ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbW1vbkxleGVyIHtcclxuICBjb25zdHJ1Y3RvcihydWxlcywgSW5Db21tZW50Q2xhc3NlcywgTm90SW5Db21tZW50Q2xhc3Nlcykge1xyXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG4gICAgdGhpcy5JbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3NlcztcclxuICAgIHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcyA9IE5vdEluQ29tbWVudENsYXNzZXM7XHJcbiAgfVxyXG4gIFxyXG4gIGdldFJ1bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucnVsZXM7XHJcbiAgfVxyXG5cclxuICBnZXRJbkNvbW1lbnRDbGFzc2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuSW5Db21tZW50Q2xhc3NlcztcclxuICB9XHJcblxyXG4gIGdldE5vdEluQ29tbWVudENsYXNzZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5Ob3RJbkNvbW1lbnRDbGFzc2VzO1xyXG4gIH1cclxuXHJcbiAgdG9rZW5pc2UoY29udGVudCwgaW5Db21tZW50ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChjb250ZW50ICE9PSBFTVBUWV9TVFJJTkcpIHtcclxuICAgICAgbGV0IHRva2VuID0gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IENsYXNzZXMgPSBpbkNvbW1lbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkluQ29tbWVudENsYXNzZXMgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcztcclxuXHJcbiAgICAgIENsYXNzZXMuc29tZSgoQ2xhc3MpID0+IHtcclxuICAgICAgICBpZiAoQ2xhc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgIHRva2VuID0gQ2xhc3MubWF0Y2goY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHRva2VuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcclxuICAgICAgICBsZXQgc2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMucnVsZXMuc29tZSgocnVsZSkgPT4ge1xyXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IHJ1bGUubWF0Y2goY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBzaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjb250ZW50ICcke2NvbnRlbnR9JyBjYW5ub3QgYmUgdG9rZW5pc2VkLmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICBpbkNvbW1lbnQgPSBpbkNvbW1lbnRGcm9tVG9rZW5BbmRJbkNvbW1lbnQodG9rZW4sIGluQ29tbWVudCk7XHJcblxyXG4gICAgICBjb25zdCBuYWl2ZSA9IHRydWUsXHJcbiAgICAgICAgICAgIHRva2VuQ29udGVudExlbmd0aCA9IHRva2VuLmdldENvbnRlbnRMZW5ndGgobmFpdmUpLFxyXG4gICAgICAgICAgICBzdGFydCA9IHRva2VuQ29udGVudExlbmd0aDsgLy8vXHJcblxyXG4gICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b2tlbnM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MpIHtcclxuICAgIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXHJcbiAgICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyksXHJcbiAgICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XHJcblxyXG4gICAgcmV0dXJuIGxleGVyO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcclxuICAgIGNvbnN0IGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcclxuXHJcbiAgICByZXR1cm4gbGV4ZXI7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoQ2xhc3MsIGVudHJpZXMpIHtcclxuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tRW50cmllcyhlbnRyaWVzKSxcclxuICAgICAgICAgIGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcclxuXHJcbiAgICByZXR1cm4gbGV4ZXI7XHJcbiAgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRva2VuIGZyb20gXCIuLi90b2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25TaWduaWZpY2FudFRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudCA9IGZhbHNlLFxuICAgICAgICAgIG5vblNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQpO1xuXG4gICAgcmV0dXJuIG5vblNpZ25pZmljYW50VG9rZW47XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudCA9IGZhbHNlLFxuICAgICAgICAgIG5vblNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQpO1xuXG4gICAgcmV0dXJuIG5vblNpZ25pZmljYW50VG9rZW47XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSBmYWxzZSxcbiAgICAgICAgICBub25TaWduaWZpY2FudFRva2VuID0gVG9rZW4uZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlLCBzaWduaWZpY2FudCk7XG5cbiAgICByZXR1cm4gbm9uU2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgd2hpdGVzcGFjZVR5cGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hpdGVzcGFjZVRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIHN0YXRpYyB0eXBlID0gd2hpdGVzcGFjZVR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL15bXFx0XFx2IF0rLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChXaGl0ZXNwYWNlVG9rZW4sIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoV2hpdGVzcGFjZVRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgcmVndWxhckV4cHJlc3Npb25UeXBlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gZXh0ZW5kcyBTaWduaWZpY2FudFRva2VuIHtcbiAgc3RhdGljIHR5cGUgPSByZWd1bGFyRXhwcmVzc2lvblR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL15cXC8oPzpcXFxcW15cXHNdfFteXFwvXFxyXFxuXFxmXSkqXFwvLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChSZWd1bGFyRXhwcmVzc2lvblRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVUeXBlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgYXNIVE1MKCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBodG1sID0gY29udGVudDsgLy8vXG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lVHlwZTtcblxuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXig/OlxcclxcbnxcXHJ8XFxufFxcZikvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBOb25TaWduaWZpY2FudFRva2VuLm1hdGNoKEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgc3RyaW5nTGl0ZXJhbFR5cGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuY29uc3QgeyBzdWJzdHJpbmcgfSA9IHN0cmluZ1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nTGl0ZXJhbFRva2VuIGV4dGVuZHMgU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGdldFN0cmluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksXG4gICAgICAgICAgY29udGVudExlbmd0aCA9IHRoaXMuZ2V0Q29udGVudExlbmd0aCgpLFxuICAgICAgICAgIHN0YXJ0ID0gMSxcbiAgICAgICAgICBlbmQgPSBjb250ZW50TGVuZ3RoIC0gMSxcbiAgICAgICAgICBzdHJpbmcgPSBzdWJzdHJpbmcoY29udGVudCwgc3RhcnQsIGVuZCk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBzdHJpbmdMaXRlcmFsVHlwZTtcblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIFNpZ25pZmljYW50VG9rZW4ubWF0Y2goQ2xhc3MsIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFRva2VuIGZyb20gXCIuLi8uLi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiBleHRlbmRzIFN0cmluZ0xpdGVyYWxUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eXCIoPzpcXFxcW15cXHNdfFteXCJcXFxcXFxyXFxuXSkqXCIvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTdHJpbmdMaXRlcmFsVG9rZW4ubWF0Y2goRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTdHJpbmdMaXRlcmFsVG9rZW4uZnJvbUNvbnRlbnQoRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5pbXBvcnQgQ29tbW9uTGV4ZXIgZnJvbSBcIi4uL2NvbW1vbi9sZXhlclwiO1xyXG5pbXBvcnQgV2hpdGVzcGFjZVRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCI7XHJcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblRva2VuIGZyb20gXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCTkZMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICB0b2tlbnNGcm9tQk5GKGJuZikge1xyXG4gICAgY29uc3QgY29udGVudCA9IGJuZiwgIC8vL1xyXG4gICAgICAgICAgdG9rZW5zID0gc3VwZXIudG9rZW5pc2UoY29udGVudCk7XHJcblxyXG4gICAgcmV0dXJuIHRva2VucztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoQk5GTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhCTkZMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhCTkZMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwiZGlnaXRcIjogXCJeXFxcXGQrXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYnJhY2tldFwiOiBcIl4oPzpcXFxcKHxcXFxcKSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJvcGVyYXRvclwiOiBcIl4oPzpcXFxcK3wtfFxcXFwqfFxcXFwvKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc11cIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0cmluZ0xpdGVyYWxUb2tlbiBmcm9tIFwiLi4vLi4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZXh0ZW5kcyBTdHJpbmdMaXRlcmFsVG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXicoPzpcXFxcW15cXHNdfFteJ1xcXFxcXHJcXG5dKSonLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU3RyaW5nTGl0ZXJhbFRva2VuLm1hdGNoKFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RyaW5nTGl0ZXJhbFRva2VuLmZyb21Db250ZW50KFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IHNpbmdsZUxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICBjb25zdCBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gZmFsc2U7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gc2luZ2xlTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTaW5nbGVMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eI1teXFxyXFxuXFxmXSovO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTaW5nbGVMaW5lQ29tbWVudFRva2VuLm1hdGNoKFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2luZ2xlTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiBleHRlbmRzIE5vblNpZ25pZmljYW50VG9rZW4ge1xuICBpc0luQ29tbWVudFByZXNlcnZpbmcoKSB7XG4gICAgY29uc3QgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lQ29tbWVudFR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5mcm9tQ29udGVudChFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgIGNvbnN0IGluQ29tbWVudFByZXNlcnZpbmcgPSBmYWxzZTtcblxuICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBlbmRPZk11bHRpTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14jIyMvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5tYXRjaChQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgIGNvbnN0IGluQ29tbWVudFByZXNlcnZpbmcgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZTtcblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4ubWF0Y2goQ2xhc3MsIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7IHJldHVybiBOb25TaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14jIyMvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICBjb25zdCBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gdHJ1ZTtcblxuICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvbWlkZGxlT2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpbXlxcclxcblxcZl0rPyg/PSMjIyl8W15cXHJcXG5cXGZdKykvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5tYXRjaChQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5pbXBvcnQgQ29tbW9uTGV4ZXIgZnJvbSBcIi4uL2NvbW1vbi9sZXhlclwiO1xyXG5pbXBvcnQgV2hpdGVzcGFjZVRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCI7XHJcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblRva2VuIGZyb20gXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvc2luZ2x5UXVvdGVkXCI7XHJcbmltcG9ydCBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZS9weXRob25TdHlsZVwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZi9weXRob25TdHlsZVwiO1xyXG5pbXBvcnQgUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL3B5dGhvblN0eWxlXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9weXRob25TdHlsZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKEJhc2ljTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhCYXNpY0xleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEJhc2ljTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgZW5kT2ZMaW5lVHlwZSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuIGV4dGVuZHMgU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGFzSFRNTCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksXG4gICAgICAgICAgaHRtbCA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IGVuZE9mTGluZVR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi90b2tlbi9zaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiBleHRlbmRzIFNpZ25pZmljYW50VG9rZW4ge1xuICBpc0luQ29tbWVudFByZXNlcnZpbmcoKSB7XG4gICAgY29uc3QgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lQ29tbWVudFR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5mcm9tQ29udGVudChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFNpbmdsZUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eXFwvXFwvW15cXHJcXG5cXGZdKi87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIFNpbmdsZUxpbmVDb21tZW50VG9rZW4ubWF0Y2goQ1N0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2luZ2xlTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcKlxcLy87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcL1xcKi87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ubWF0Y2goQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXig/OlteXFxyXFxuXFxmXSs/KD89XFwqXFwvKXxbXlxcclxcblxcZl0rKS87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSdWxlIH0gZnJvbSBcIi4vcnVsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0eXBlcyB9IGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIi4vc3BlY2lhbFN5bWJvbHNcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBydWxlc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9ydWxlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXhlclV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJORkxleGVyIH0gZnJvbSBcIi4vYm5mL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2ljTGV4ZXIgfSBmcm9tIFwiLi9iYXNpYy9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25MZXhlciB9IGZyb20gXCIuL2NvbW1vbi9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50L2VuZE9mTGluZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L2VuZE9mTGluZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFdoaXRlc3BhY2VUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L3doaXRlc3BhY2VcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2YvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL3B5dGhvblN0eWxlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwibWVkaWFcIjogXCJeQG1lZGlhXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwia2V5ZnJhbWVzXCI6IFwiXkBrZXlmcmFtZXNcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJjb2xvdXJcIjogXCJeIyg/OlswLTlhLWZBLUZdezZ9fFswLTlhLWZBLUZdezN9KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImltcG9ydGFudFwiOiBcIl4haW1wb3J0YW50XCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicGVyY2VudGFnZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspJVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImZyZXF1ZW5jeVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86aHp8a2h6KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImZyYWN0aW9uXCI6IFwiXlsxLTldWzAtOV0qP2ZyXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibGVuZ3RoXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKykoPzpweHxjbXxtbXxpbnxwdHxwYylcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJhbmdsZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86ZGVnfHJhZHxncmFkKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInRpbWVcIjogXCJeKD86WzAtOV0rfFswLTldKlxcXFwuWzAtOV0rKSg/OnN8bXMpXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicmVtc1wiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspcmVtXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiZW1zXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKyllbVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl5bMC05XSt8WzAtOV0qXFxcXC5bMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXjt8Ojp8OnxcXFxcLnwsfFxcXFx8PXx+PXw9fD58XFxcXHt8XFxcXH18XFxcXCh8XFxcXCl8XFxcXFt8XFxcXF1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZGVudGlmaWVyXCI6IFwiXltfYS16QS1aMC05XFxcXC1dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImxvZ2ljYWwtb3BlcmF0b3JcIjogXCJeKD86YW5kfG5vdCkkXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicGx1cy1vci1taW51c1wiOiBcIl5bXFxcXCtcXFxcLV1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDsgLy8vXHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsOyAvLy9cclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKENTU0xleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoQ1NTTGV4ZXIsIHJ1bGVzKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoQ1NTTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICAgIGRvY3VtZW50ICAgICAgICAgICAgICAgICA6Oj0gICggcnVsZSB8IGVycm9yICkrIDtcblxuICAgICAgcnVsZSAgICAgICAgICAgICAgICAgICAgIDo6PSAgbmFtZSBvcGFjaXR5TW9kaWZpZXI/IFwiOjo9XCIgZGVmaW5pdGlvbnMgXCI7XCIgO1xuXG4gICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBkZWZpbml0aW9ucyAgICAgICAgICAgICAgOjo9ICBkZWZpbml0aW9uICggXCJ8XCIgZGVmaW5pdGlvbiApKiA7XG5cbiAgICAgIGRlZmluaXRpb24gICAgICAgICAgICAgICA6Oj0gIHBhcnQrIHByZWNlZGVuY2U/IDtcbiBcbiAgICAgIHBhcnQgICAgICAgICAgICAgICAgICAgICA6Oj0gIG5vblRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtaW5hbFBhcnQgcXVhbnRpZmllcipcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBub25UZXJtaW5hbFBhcnQgICAgICAgICAgOjo9ICBjaG9pY2VPZlBhcnRzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNlcXVlbmNlT2ZQYXJ0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBydWxlTmFtZSBjYWxsQWhlYWRNb2RpZmllcj9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICB0ZXJtaW5hbFBhcnQgICAgICAgICAgICAgOjo9ICBzaWduaWZpY2FudFRva2VuVHlwZVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJlZ3VsYXJFeHByZXNzaW9uXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdHJpbmdMaXRlcmFsXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgZW5kT2ZMaW5lXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgd2lsZGNhcmRcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlcHNpbG9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vV2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGFydE9mQ29udGVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgIHNlcXVlbmNlT2ZQYXJ0cyAgICAgICAgICA6Oj0gIFwiKFwiIHBhcnQgcGFydCsgXCIpXCIgO1xuXG4gICAgICBjaG9pY2VPZlBhcnRzICAgICAgICAgICAgOjo9ICBcIihcIiBwYXJ0Q2hvaWNlICggXCJ8XCIgcGFydENob2ljZSApKyBcIilcIiA7XG5cbiAgICAgIHBhcnRDaG9pY2UgICAgICAgICAgICAgICA6Oj0gIHBhcnQgcHJlY2VkZW5jZT8gO1xuXG4gICAgICBydWxlTmFtZSAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBzaWduaWZpY2FudFRva2VuVHlwZSAgICAgOjo9ICBbdHlwZV0gO1xuXG4gICAgICByZWd1bGFyRXhwcmVzc2lvbiAgICAgICAgOjo9ICBbcmVndWxhci1leHByZXNzaW9uXSA7XG5cbiAgICAgIHN0cmluZ0xpdGVyYWwgICAgICAgICAgICA6Oj0gIFtzdHJpbmctbGl0ZXJhbF0gO1xuXG4gICAgICBwcmVjZWRlbmNlICAgICAgICAgICAgICAgOjo9ICBcIihcIiBbbnVtYmVyXT8gXCIpXCIgO1xuICAgICAgXG4gICAgICBlbmRPZkxpbmUgICAgICAgICAgICAgICAgOjo9ICBcIjxFTkRfT0ZfTElORT5cIiA7XG4gICAgICBcbiAgICAgIHdpbGRjYXJkICAgICAgICAgICAgICAgICA6Oj0gIFwiLlwiIDtcblxuICAgICAgZXBzaWxvbiAgICAgICAgICAgICAgICAgIDo6PSAgXCJcdTAzQjVcIiA7XG5cbiAgICAgIG5vV2hpdGVzcGFjZSAgICAgICAgICAgICA6Oj0gIFwiPE5PX1dISVRFU1BBQ0U+XCIgOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICBzdGFydE9mQ29udGVudCAgICAgICAgICAgOjorICBcIjxTVEFSVF9PRl9DT05URU5UPlwiOyBcbiAgICAgIFxuICAgICAgcXVhbnRpZmllciAgICAgICAgICAgICAgIDo6PSAgb3B0aW9uYWxRdWFudGlmaWVyXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvbmVPck1vcmVRdWFudGlmaWVyXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgemVyb09yTW9yZVF1YW50aWZpZXJcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgIG9wYWNpdHlNb2RpZmllciAgICAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPiggXCIuXCIgfCBcIi4uXCIgKTtcbiAgICAgIFxuICAgICAgY2FsbEFoZWFkTW9kaWZpZXIgICAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIuLi5cIiA7XG5cbiAgICAgIG9wdGlvbmFsUXVhbnRpZmllciAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiP1wiIDtcblxuICAgICAgb25lT3JNb3JlUXVhbnRpZmllciAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIrXCIgO1xuXG4gICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllciAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIipcIiA7XG5cbiAgICAgIGVycm9yLiAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRURfQkFDS1NMQVNIID1cIlxcXFxcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0RPVUJMRV9RVU9URSA9IFwiXFxcIlwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFkZGluZ0Zyb21QYWRkaW5nTGVuZ3RoKHBhZGRpbmdMZW5ndGgpIHtcbiAgbGV0IHBhZGRpbmcgPSBFTVBUWV9TVFJJTkc7XG5cbiAgZm9yIChsZXQgcG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IHBhZGRpbmdMZW5ndGg7IHBvc2l0aW9uKyspIHtcbiAgICBwYWRkaW5nICs9IFNQQUNFX0NIQVJBQ1RFUjtcbiAgfVxuXG4gIHJldHVybiBwYWRkaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcbmltcG9ydCB7IHBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aCB9IGZyb20gXCIuL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuY29uc3QgeyBjbGVhciB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IG9wYXF1ZTogb3BhcXVlU3BlY2lhbFN5bWJvbCwgc2VtaU9wYXF1ZTogc2VtaU9wYXF1ZVNwZWNpYWxTeW1ib2wgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZ2V0RGVmaW5pdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbnM7XG4gIH1cblxuICBzZXROYW1lKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgfVxuXG4gIHNldERlZmluaXRpb25zKGRlZmluaXRpb25zKSB7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICB9XG5cbiAgaXNPcGFxdWUoKSB7XG4gICAgY29uc3Qgb3BhcXVlID0gKHRoaXMub3BhY2l0eSA9PT0gb3BhcXVlU3BlY2lhbFN5bWJvbCk7XG5cbiAgICByZXR1cm4gb3BhcXVlO1xuICB9XG5cbiAgaXNTZW1pT3BhcXVlKCkge1xuICAgIGNvbnN0IHNlbWlPcGFxdWUgPSAodGhpcy5vcGFjaXR5ID09PSBzZW1pT3BhcXVlU3BlY2lhbFN5bWJvbCk7XG5cbiAgICByZXR1cm4gc2VtaU9wYXF1ZTtcbiAgfVxuXG4gIGlzVHJhbnNwYXJlbnQoKSB7XG4gICAgY29uc3Qgc2VtaU9wYXF1ZSA9ICh0aGlzLm9wYWNpdHkgPT09IG51bGwpO1xuXG4gICAgcmV0dXJuIHNlbWlPcGFxdWU7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRoaXMubmFtZSwgLy8vXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IFtdLFxuICAgICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHRoaXMuTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lLCBzdGF0ZSksXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSksXG4gICAgICAgICAgc2F2ZWRQcmVjZWRlbmNlID0gc3RhdGUuZ2V0U2F2ZWRQcmVjZWRlbmNlKCk7XG5cbiAgICBsZXQgbm9kZSA9IG5vblRlcm1pbmFsTm9kZTsgLy8vXG5cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuXG4gICAgcGFyc2VkID0gdGhpcy5kZWZpbml0aW9ucy5zb21lKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICBjbGVhcihjaGlsZE5vZGVzKTtcblxuICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IGRlZmluaXRpb24uZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgICBzdGF0ZS5zZXRQcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuXG4gICAgICBjYWxsYmFjayA9ICgpID0+IHsgIC8vL1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5nZXRQcmVjZWRlbmNlKCk7XG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG5cbiAgICAgICAgcGFyc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgbm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV3cml0dGVuTm9uVGVybWluYWxOb2RlID0gbm9uVGVybWluYWxOb2RlLnJld3JpdGUoc3RhdGUpO1xuXG4gICAgICAgIGlmIChyZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcblxuICAgICAgICAgICAgbm9kZSA9IHJld3JpdHRlbk5vblRlcm1pbmFsTm9kZTsgLy8vXG5cbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIGNvbnN0IGVtcHR5ID0gbm9kZS5pc0VtcHR5KCk7XG5cbiAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICBjb25zdCB1bnByZWNlZGVudGVkID0gbm9kZS5pc1VucHJlY2VkZW50ZWQoKTtcblxuICAgICAgICAgIGlmICh1bnByZWNlZGVudGVkKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgaWYgKGNhbGxBaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSk7XG5cbiAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuXG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgbm9kZS5yZXNldENoaWxkTm9kZXNQYXJlbnROb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfTtcblxuICAgICAgcGFyc2VkID0gZGVmaW5pdGlvbi5wYXJzZShjaGlsZE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHN0YXRlLnJlc2V0UHJlY2VkZW5jZShzYXZlZFByZWNlZGVuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIG5vZGVzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmIChjYWxsQWhlYWQgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLnJlc2V0UHJlY2VkZW5jZShzYXZlZFByZWNlZGVuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5Ob25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUpOyB9XG5cbiAgYXNTdHJpbmcobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBtdWx0aUxpbmUgPSB0cnVlKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbnNMZW5ndGggPSB0aGlzLmRlZmluaXRpb25zLmxlbmd0aDtcblxuICAgIG11bHRpTGluZSA9IG11bHRpTGluZSAmJiAoZGVmaW5pdGlvbnNMZW5ndGggPiAxKTsgIC8vL1xuXG4gICAgY29uc3QgbWF4aW11bVBhZGRpbmcgPSBwYWRkaW5nRnJvbVBhZGRpbmdMZW5ndGgobWF4aW11bVJ1bGVOYW1lTGVuZ3RoKSxcbiAgICAgICAgICBkZWZpbml0aW9uc1N0cmluZyA9IHRoaXMuZGVmaW5pdGlvbnMucmVkdWNlKChkZWZpbml0aW9uc1N0cmluZywgZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zU3RyaW5nID09PSBFTVBUWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbnNTdHJpbmcgPSBkZWZpbml0aW9uU3RyaW5nOyAvLy9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZmluaXRpb25zU3RyaW5nID0gbXVsdGlMaW5lID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZGVmaW5pdGlvbnNTdHJpbmd9XG5cbiR7bWF4aW11bVBhZGRpbmd9ICAgfCAke2RlZmluaXRpb25TdHJpbmd9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZGVmaW5pdGlvbnNTdHJpbmd9IHwgJHtkZWZpbml0aW9uU3RyaW5nfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uc1N0cmluZztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5uYW1lLCAvLy9cbiAgICAgICAgICBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aCxcbiAgICAgICAgICBvcGFjaXR5U3RyaW5nID0gKHRoaXMub3BhY2l0eSA9PT0gbnVsbCk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSwgLy8vXG4gICAgICAgICAgb3BhY2l0eVN0cmluZ0xlbmd0aCA9IG9wYWNpdHlTdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmdMZW5ndGggPSBtYXhpbXVtUnVsZU5hbWVMZW5ndGggLSBydWxlTmFtZUxlbmd0aCAtIG9wYWNpdHlTdHJpbmdMZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IHBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aChwYWRkaW5nTGVuZ3RoKTtcblxuICAgIGNvbnN0IHNlbWljb2xvblN0cmluZyA9IG11bHRpTGluZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcblxuJHttYXhpbXVtUGFkZGluZ30gICA7YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgO1wiLFxuICAgICAgICAgIHN0cmluZyA9IGBcblxuJHt0aGlzLm5hbWV9JHtvcGFjaXR5U3RyaW5nfSR7cGFkZGluZ30gOjo9ICR7ZGVmaW5pdGlvbnNTdHJpbmd9JHtzZW1pY29sb25TdHJpbmd9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWVPcGFjaXR5QW5kRGVmaW5pdGlvbnMoQ2xhc3MsIG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKSB7XG4gICAgaWYgKGRlZmluaXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmluaXRpb25zID0gb3BhY2l0eTsgIC8vL1xuXG4gICAgICBvcGFjaXR5ID0gbmFtZTsgLy8vXG5cbiAgICAgIG5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gUnVsZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcnVsZSA9IG5ldyBDbGFzcyhuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBwdXNoLCBmaXJzdCwgZm9yd2FyZHNTb21lLCBiYWNrd2FyZHNTb21lIH0gPSBhcnJheVV0aWxpdGllcztcblxuZnVuY3Rpb24gZ2V0TXVsdGlwbGljaXR5KCkge1xuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgbXVsdGlwbGljaXR5ID0gY2hpbGROb2Rlc0xlbmd0aDsgIC8vL1xuXG4gIHJldHVybiBtdWx0aXBsaWNpdHk7XG59XG5cbmZ1bmN0aW9uIG1hcENoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcChjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gc29tZUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLnNvbWUoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maW5kKGNhbGxiYWNrKTsgfVxuXG5mdW5jdGlvbiBldmVyeUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLmV2ZXJ5KGNhbGxiYWNrKTsgfVxuXG5mdW5jdGlvbiBmaWx0ZXJDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maWx0ZXIoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIHJlZHVjZUNoaWxkTm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXMucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZE5vZGUoY2FsbGJhY2spIHsgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZvcndhcmRzU29tZUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gZm9yd2FyZHNTb21lKHRoaXMuY2hpbGROb2RlcywgY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIGJhY2t3YXJkc1NvbWUodGhpcy5jaGlsZE5vZGVzLCBjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gaW5kZXhPZkNoaWxkTm9kZShjaGlsZE5vZGUpIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkTm9kZSk7IH1cblxuZnVuY3Rpb24gc2V0Q2hpbGROb2Rlc1BhcmVudE5vZGUoY2hpbGROb2Rlcykge1xuICBpZiAoY2hpbGROb2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2hpbGROb2RlcyA9IFtcbiAgICAgIC4uLnRoaXMuY2hpbGROb2Rlc1xuICAgIF07XG4gIH1cblxuICBjb25zdCBwYXJlbnROb2RlID0gdGhpcztcblxuICBjaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNoaWxkTm9kZS5zZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZShjaGlsZE5vZGVzKSB7XG4gIGlmIChjaGlsZE5vZGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZE5vZGVzID0gW1xuICAgICAgLi4udGhpcy5jaGlsZE5vZGVzXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgY2hpbGROb2RlLnNldFBhcmVudE5vZGUocGFyZW50Tm9kZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZE5vZGUoYWRkZWRDaGlsZE5vZGUsIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgYWRkZWRDaGlsZE5vZGVzID0gW1xuICAgIGFkZGVkQ2hpbGROb2RlXG4gIF07XG5cbiAgdGhpcy5hZGRDaGlsZE5vZGVzKGFkZGVkQ2hpbGROb2Rlcywgc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkTm9kZXMoYWRkZWRDaGlsZE5vZGVzLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IGRlbGV0ZUNvdW50ID0gMDtcblxuICB0aGlzLnNwbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIGFkZGVkQ2hpbGROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkTm9kZShyZW1vdmVkQ2hpbGROb2RlKSB7XG4gIGxldCByZW1vdmVkQ2hpbGROb2RlcztcblxuICByZW1vdmVkQ2hpbGROb2RlcyA9IFtcbiAgICByZW1vdmVkQ2hpbGROb2RlXG4gIF07XG5cbiAgcmVtb3ZlZENoaWxkTm9kZXMgPSB0aGlzLnJlbW92ZUNoaWxkTm9kZXMocmVtb3ZlZENoaWxkTm9kZXMpO1xuXG4gIHJldHVybiByZW1vdmVkQ2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGROb2RlcyhyZW1vdmVkQ2hpbGROb2Rlcykge1xuICBpZiAocmVtb3ZlZENoaWxkTm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlbW92ZWRDaGlsZE5vZGVzID0gW1xuICAgICAgLi4udGhpcy5jaGlsZE5vZGVzXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IHJlbW92ZWRDaGlsZE5vZGVzTGVuZ3RoID0gcmVtb3ZlZENoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGlmIChyZW1vdmVkQ2hpbGROb2Rlc0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdFJlcGxhY2VkQ2hpbGROb2RlID0gZmlyc3QocmVtb3ZlZENoaWxkTm9kZXMpLFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihmaXJzdFJlcGxhY2VkQ2hpbGROb2RlKSwgLy8vXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSByZW1vdmVkQ2hpbGROb2Rlc0xlbmd0aCwgLy8vXG4gICAgICAgICAgYWRkZWRDaGlsZE5vZGVzID0gW107XG5cbiAgICByZW1vdmVkQ2hpbGROb2RlcyA9IHRoaXMuc3BsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBkZWxldGVDb3VudCwgYWRkZWRDaGlsZE5vZGVzKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkQ2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkTm9kZShyZXBsYWNlZENoaWxkTm9kZSwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKSB7XG4gIGNvbnN0IHJlcGxhY2VkQ2hpbGROb2RlcyA9IFtcbiAgICByZXBsYWNlZENoaWxkTm9kZVxuICBdO1xuXG4gIHRoaXMucmVwbGFjZUNoaWxkTm9kZXMocmVwbGFjZWRDaGlsZE5vZGVzLCByZXBsYWNlbWVudENoaWxkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGROb2RlcyhyZXBsYWNlZENoaWxkTm9kZXMsIHJlcGxhY2VtZW50Q2hpbGROb2Rlcykge1xuICBjb25zdCByZXBsYWNlZENoaWxkTm9kZXNMZW5ndGggPSByZXBsYWNlZENoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICBmaXJzdFJlcGxhY2VkQ2hpbGROb2RlID0gZmlyc3QocmVwbGFjZWRDaGlsZE5vZGVzKSxcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGZpcnN0UmVwbGFjZWRDaGlsZE5vZGUpLCAvLy9cbiAgICAgICAgZGVsZXRlQ291bnQgPSByZXBsYWNlZENoaWxkTm9kZXNMZW5ndGg7IC8vL1xuXG4gIHRoaXMuc3BsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBkZWxldGVDb3VudCwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGROb2RlKGFwcGVuZGVkQ2hpbGROb2RlKSB7XG4gIGNvbnN0IGFwcGVuZGVkQ2hpbGROb2RlcyA9IFtcbiAgICBhcHBlbmRlZENoaWxkTm9kZVxuICBdO1xuXG4gIHRoaXMuYXBwZW5kQ2hpbGROb2RlcyhhcHBlbmRlZENoaWxkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZE5vZGVzKGFwcGVuZGVkQ2hpbGROb2Rlcykge1xuICBjb25zdCBhZGRlZENoaWxkTm9kZXMgPSBhcHBlbmRlZENoaWxkTm9kZXMsIC8vL1xuICAgICAgICBtdWx0aXBsaWNpdHkgPSB0aGlzLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICBzdGFydEluZGV4ID0gbXVsdGlwbGljaXR5OyAgLy8vXG5cbiAgdGhpcy5hZGRDaGlsZE5vZGVzKGFkZGVkQ2hpbGROb2Rlcywgc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZE5vZGUocHJlcGVuZGVkQ2hpbGROb2RlKSB7XG4gIGNvbnN0IHByZXBlbmRlZENoaWxkTm9kZXMgPSBbXG4gICAgcHJlcGVuZGVkQ2hpbGROb2RlXG4gIF07XG5cbiAgdGhpcy5wcmVwZW5kQ2hpbGROb2RlcyhwcmVwZW5kZWRDaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZENoaWxkTm9kZXMocHJlcGVuZGVkQ2hpbGROb2Rlcykge1xuICBjb25zdCBhZGRlZENoaWxkTm9kZXMgPSBwcmVwZW5kZWRDaGlsZE5vZGVzLCAgLy8vXG4gICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuXG4gIHRoaXMuYWRkQ2hpbGROb2RlcyhhZGRlZENoaWxkTm9kZXMsIHN0YXJ0SW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzcGxpY2VDaGlsZE5vZGVzKHN0YXJ0SW5kZXgsIGRlbGV0ZUNvdW50LCBhZGRlZENoaWxkTm9kZXMgPSBbXSkge1xuICBjb25zdCByZW1vdmVkQ2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2Rlcy5zcGxpY2Uoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIC4uLmFkZGVkQ2hpbGROb2Rlcyk7XG5cbiAgdGhpcy5yZXNldENoaWxkTm9kZXNQYXJlbnROb2RlKHJlbW92ZWRDaGlsZE5vZGVzKTtcblxuICB0aGlzLnNldENoaWxkTm9kZXNQYXJlbnROb2RlKGFkZGVkQ2hpbGROb2Rlcyk7XG5cbiAgcmV0dXJuIHJlbW92ZWRDaGlsZE5vZGVzO1xufVxuXG5mdW5jdGlvbiBzbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZW5kSW5kZXggPSBJbmZpbml0eSkge1xuICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblxuICByZXR1cm4gY2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JOb2RlcygpIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IFtdO1xuXG4gIGxldCBhbmNlc3Rvck5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vL1xuXG4gIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICBhbmNlc3Rvck5vZGVzLnB1c2goYW5jZXN0b3JOb2RlKTtcblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGFuY2VzdG9yTm9kZXM7XG59XG5cbmZ1bmN0aW9uIG1hcEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgcmV0dXJuIGFuY2VzdG9yTm9kZXMubWFwKGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gc29tZUFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgbGV0IGluZGV4ID0gMCxcbiAgICAgIGFuY2VzdG9yTm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8vXG5cbiAgd2hpbGUgKGFuY2VzdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7IC8vL1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yTm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBhbmNlc3Rvck5vZGUgPSBwYXJlbnROb2RlOyAgLy8vXG5cbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgaW5kZXggPSAwLFxuICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3JOb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIGFuY2VzdG9yTm9kZSA9IHVuZGVmaW5lZDtcblxuICByZXR1cm4gYW5jZXN0b3JOb2RlO1xufVxuXG5mdW5jdGlvbiBldmVyeUFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBsZXQgaW5kZXggPSAwLFxuICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gISFjYWxsYmFjayhhbmNlc3Rvck5vZGUsIGluZGV4KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGFuY2VzdG9yTm9kZSA9IHBhcmVudE5vZGU7ICAvLy9cblxuICAgIGluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gIHJldHVybiBhbmNlc3Rvck5vZGVzLmZpbHRlcihjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUFuY2VzdG9yTm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGFuY2VzdG9yTm9kZXMgPSB0aGlzLmdldEFuY2VzdG9yTm9kZXMoKTtcblxuICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gIGFuY2VzdG9yTm9kZXMuZm9yRWFjaChjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldERlc2NlbmRhbnROb2RlcyhkZXNjZW5kYW50Tm9kZXMgPSBbXSkge1xuICBwdXNoKGRlc2NlbmRhbnROb2RlcywgdGhpcy5jaGlsZE5vZGVzKTtcblxuICB0aGlzLmZvckVhY2hDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNoaWxkTm9kZS5nZXREZXNjZW5kYW50Tm9kZXMoZGVzY2VuZGFudE5vZGVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcztcbn1cblxuZnVuY3Rpb24gbWFwRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgZGVzY2VuZGFudE5vZGVzID0gdGhpcy5nZXREZXNjZW5kYW50Tm9kZXMoKTtcblxuICByZXR1cm4gZGVzY2VuZGFudE5vZGVzLm1hcChjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHNvbWVEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNoaWxkTm9kZXNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgIGRlc2NlbmRhbnROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soZGVzY2VuZGFudE5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hpbGROb2RlLnNvbWVEZXNjZW5kYW50Tm9kZShjYWxsYmFjayk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgbGV0IGRlc2NlbmRhbnROb2RlID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjaGlsZE5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpbmRleF07XG5cbiAgICBkZXNjZW5kYW50Tm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICByZXN1bHQgPSBjYWxsYmFjayhkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXNjZW5kYW50Tm9kZSA9IGNoaWxkTm9kZS5maW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjZW5kYW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXZlcnlEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2hpbGROb2Rlc0xlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgcmVzdWx0ID0gISFjYWxsYmFjayhkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hpbGROb2RlLmV2ZXJ5RGVzY2VuZGFudE5vZGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckRlc2NlbmRhbnROb2RlKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGRlc2NlbmRhbnROb2RlcyA9IHRoaXMuZ2V0RGVzY2VuZGFudE5vZGVzKCk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEZXNjZW5kYW50Tm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGRlc2NlbmRhbnROb2RlcyA9IHRoaXMuZ2V0RGVzY2VuZGFudE5vZGVzKCk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBjb25zdCBkZXNjZW5kYW50Tm9kZXMgPSB0aGlzLmdldERlc2NlbmRhbnROb2RlcygpO1xuXG4gIGRlc2NlbmRhbnROb2Rlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbn1cblxuY29uc3Qgbm9kZU1peGlucyA9IHtcbiAgZ2V0TXVsdGlwbGljaXR5LFxuICBtYXBDaGlsZE5vZGUsXG4gIHNvbWVDaGlsZE5vZGUsXG4gIGZpbmRDaGlsZE5vZGUsXG4gIGV2ZXJ5Q2hpbGROb2RlLFxuICBmaWx0ZXJDaGlsZE5vZGUsXG4gIHJlZHVjZUNoaWxkTm9kZSxcbiAgZm9yRWFjaENoaWxkTm9kZSxcbiAgZm9yd2FyZHNTb21lQ2hpbGROb2RlLFxuICBiYWNrd2FyZHNTb21lQ2hpbGROb2RlLFxuICBpbmRleE9mQ2hpbGROb2RlLFxuICBzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSxcbiAgcmVzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSxcbiAgYWRkQ2hpbGROb2RlLFxuICBhZGRDaGlsZE5vZGVzLFxuICByZW1vdmVDaGlsZE5vZGUsXG4gIHJlbW92ZUNoaWxkTm9kZXMsXG4gIHJlcGxhY2VDaGlsZE5vZGUsXG4gIHJlcGxhY2VDaGlsZE5vZGVzLFxuICBhcHBlbmRDaGlsZE5vZGUsXG4gIGFwcGVuZENoaWxkTm9kZXMsXG4gIHByZXBlbmRDaGlsZE5vZGUsXG4gIHByZXBlbmRDaGlsZE5vZGVzLFxuICBzcGxpY2VDaGlsZE5vZGVzLFxuICBzbGljZUNoaWxkTm9kZXMsXG4gIGdldEFuY2VzdG9yTm9kZXMsXG4gIG1hcEFuY2VzdG9yTm9kZSxcbiAgc29tZUFuY2VzdG9yTm9kZSxcbiAgZmluZEFuY2VzdG9yTm9kZSxcbiAgZXZlcnlBbmNlc3Rvck5vZGUsXG4gIGZpbHRlckFuY2VzdG9yTm9kZSxcbiAgcmVkdWNlQW5jZXN0b3JOb2RlLFxuICBmb3JFYWNoQW5jZXN0b3JOb2RlLFxuICBnZXREZXNjZW5kYW50Tm9kZXMsXG4gIG1hcERlc2NlbmRhbnROb2RlLFxuICBzb21lRGVzY2VuZGFudE5vZGUsXG4gIGZpbmREZXNjZW5kYW50Tm9kZSxcbiAgZXZlcnlEZXNjZW5kYW50Tm9kZSxcbiAgZmlsdGVyRGVzY2VuZGFudE5vZGUsXG4gIHJlZHVjZURlc2NlbmRhbnROb2RlLFxuICBmb3JFYWNoRGVzY2VuZGFudE5vZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMsIGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBsYXN0IH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgTkVXX0xJTkVfQ0hBUkFDVEVSLCBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlVHJlZSB7XG4gIGNvbnN0cnVjdG9yKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKCksICAvLy9cbiAgICAgICAgICBwYXJzZVRyZWUgPSBuZXcgUGFyc2VUcmVlKGxpbmVzKTtcblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBnZXRXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGg7XG5cbiAgICBsZXQgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aDtcblxuICAgIGlmIChsaW5lc0xlbmd0aCA9PT0gMCkge1xuICAgICAgd2lkdGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0TGluZSA9IGxhc3QodGhpcy5saW5lcyksXG4gICAgICAgICAgICBsYXN0TGluZUxlbmd0aCA9IGxhc3RMaW5lLmxlbmd0aDtcblxuICAgICAgd2lkdGggPSBsYXN0TGluZUxlbmd0aDsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0RGVwdGgoKSB7XG4gICAgY29uc3QgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aCxcbiAgICAgICAgICBkZXB0aCA9IGxpbmVzTGVuZ3RoOyAgLy8vXG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBmb3JFYWNoTGluZShjYWxsYmFjaykge1xuICAgIHRoaXMubGluZXMuZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cblxuICBhcHBlbmRUb1RvcChwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUpID0+IHtcbiAgICAgIHRoaXMubGluZXMudW5zaGlmdChsaW5lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZFRvTGVmdChwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLmxpbmVzW2luZGV4XSA9IGxpbmUgKyB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZFRvUmlnaHQocGFyc2VUcmVlKSB7XG4gICAgcGFyc2VUcmVlLmZvckVhY2hMaW5lKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIGxpbmU7XG4gICAgfSk7XG4gIH1cblxuICBhcHBlbmRUb0JvdHRvbShwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUpID0+IHtcbiAgICAgIHRoaXMubGluZXMucHVzaChsaW5lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZFRvcE1hcmdpbih0b3BNYXJnaW5EZXB0aCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIHRvcE1hcmdpbldpZHRoID0gd2lkdGgsICAvLy9cbiAgICAgICAgICB0b3BNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgodG9wTWFyZ2luV2lkdGgpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRvcE1hcmdpbkRlcHRoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzLnVuc2hpZnQodG9wTWFyZ2luU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBhZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCkge1xuICAgIGNvbnN0IGxlZnRNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgobGVmdE1hcmdpbldpZHRoKSxcbiAgICAgICAgICBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpbmVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzW2luZGV4XSA9IGxlZnRNYXJnaW5TdHJpbmcgKyB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICB9XG4gIH1cblxuICBhZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKSB7XG4gICAgY29uc3QgcmlnaHRNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgocmlnaHRNYXJnaW5XaWR0aCksXG4gICAgICAgICAgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsaW5lc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIHJpZ2h0TWFyZ2luU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGFkZEJvdHRvbU1hcmdpbihib3R0b21NYXJnaW5EZXB0aCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIGJvdHRvbU1hcmdpbldpZHRoID0gd2lkdGgsICAvLy9cbiAgICAgICAgICBib3R0b21NYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgoYm90dG9tTWFyZ2luV2lkdGgpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGJvdHRvbU1hcmdpbkRlcHRoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzLnB1c2goYm90dG9tTWFyZ2luU3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgXG4gIHBvcExpbmUoKSB7IHJldHVybiB0aGlzLmxpbmVzLnBvcCgpOyB9XG4gIFxuICBzaGlmdExpbmUoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNoaWZ0KCk7IH1cbiAgXG4gIHB1c2hMaW5lKGxpbmUpIHsgdGhpcy5saW5lcy5wdXNoKGxpbmUpOyB9XG4gIFxuICB1bnNoaWZ0TGluZShsaW5lKSB7IHRoaXMubGluZXMudW5zaGlmdChsaW5lKTsgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMubGluZXMucmVkdWNlKChzdHJpbmcsIGxpbmUpID0+IHtcbiAgICAgIHN0cmluZyArPSBsaW5lICsgTkVXX0xJTkVfQ0hBUkFDVEVSO1xuXG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmdpblN0cmluZ0Zyb21NYXJnaW5XaWR0aChtYXJnaW5XaWR0aCwgc3BhY2VDaGFyYWN0ZXIpIHtcbiAgc3BhY2VDaGFyYWN0ZXIgPSBzcGFjZUNoYXJhY3RlciB8fCBTUEFDRV9DSEFSQUNURVI7XG5cbiAgbGV0IG1hcmdpblN0cmluZyA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWFyZ2luV2lkdGg7IGluZGV4KyspIHtcbiAgICBtYXJnaW5TdHJpbmcgKz0gc3BhY2VDaGFyYWN0ZXI7XG4gIH1cblxuICByZXR1cm4gbWFyZ2luU3RyaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUGFyc2VUcmVlIGZyb20gXCIuLi9wYXJzZVRyZWVcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IEJBUl9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGV4dGVuZHMgUGFyc2VUcmVlIHtcbiAgY29uc3RydWN0b3IobGluZXMsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICBzdXBlcihsaW5lcyk7XG4gICAgXG4gICAgdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgfVxuICBcbiAgZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICB9XG5cbiAgYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpIHtcbiAgICBzdXBlci5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG5cbiAgICB0aGlzLnZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gbGVmdE1hcmdpbldpZHRoOyAvLy9cbiAgfVxuXG4gIHN0YXRpYyBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBCQVJfQ0hBUkFDVEVSLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSAwLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oVmVydGljYWxCcmFuY2hQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbiksXG4gICAgICAgICAgbGVmdE1hcmdpbldpZHRoID0gTWF0aC5mbG9vcih3aWR0aC8yKSxcbiAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGggLSAxO1xuXG4gICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuXG4gICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICB9XG5cbiAgc3RhdGljIGZyb21EZXB0aEFuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oQ2xhc3MsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGluZXMgPSBsaW5lc0Zyb21EZXB0aChkZXB0aCksXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBuZXcgQ2xhc3MobGluZXMsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICB9XG5cbiAgc3RhdGljIGZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENsYXNzLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gc3RyaW5nOyAgLy8vXG5cbiAgICAgIHN0cmluZyA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJzZVRyZWU7ICAvLy9cbiAgICB9XG4gICAgXG4gICAgY29uc3QgbGluZSA9IHN0cmluZywgLy8vXG4gICAgICAgICAgbGluZXMgPSBbXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgXSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IG5ldyBDbGFzcyhsaW5lcywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gdmVydGljYWxCcmFuY2hQYXJzZVRyZWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluZXNGcm9tRGVwdGgoZGVwdGgpIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcblxuICBsZXQgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IGRlcHRoKSB7XG4gICAgbGluZXNbaW5kZXgrK10gPSBFTVBUWV9TVFJJTkc7XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2Vucyh0b2tlbkluZGV4LCB0b2tlbnMpIHtcbiAgbGV0IGxpbmVJbmRleCA9IG51bGw7XG5cbiAgaWYgKHRva2VuSW5kZXggIT09IG51bGwpIHtcbiAgICBsaW5lSW5kZXggPSAwO1xuXG4gICAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICAgIGVuZCA9IHRva2VuSW5kZXg7XG5cbiAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgY29uc3QgdG9rZW5FbmRPZkxpbmVUb2tlbiA9IHRva2VuLmlzRW5kT2ZMaW5lVG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgbGluZUluZGV4Kys7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGluZUluZGV4O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdG9rZW5zXCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZVBhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21Ob25UZXJtaW5hbE5vZGVBbmRUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIG9wYWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgZmlyc3RMaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyhmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgdG9rZW5zKSxcbiAgICAgICAgICBsYXN0TGluZUluZGV4ID0gbGluZUluZGV4RnJvbVRva2VuSW5kZXhBbmRUb2tlbnMobGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgdG9rZW5zKTtcblxuICAgIGxldCBsaW5lSW5kZXhlcztcblxuICAgIGlmIChmaXJzdExpbmVJbmRleCA9PT0gbGFzdExpbmVJbmRleCkge1xuICAgICAgY29uc3QgbGluZUluZGV4ID0gZmlyc3RMaW5lSW5kZXg7IC8vL1xuXG4gICAgICBpZiAobGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIGxpbmVJbmRleGVzID0gRU1QVFlfU1RSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZUluZGV4ZXMgPSBgIFske2xpbmVJbmRleH1dYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vL1xuICAgICAgfSBlbHNlIGlmIChmaXJzdExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7bGFzdExpbmVJbmRleH1dYDtcbiAgICAgIH0gZWxzZSBpZiAobGFzdExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7Zmlyc3RMaW5lSW5kZXh9XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7Zmlyc3RMaW5lSW5kZXh9LSR7bGFzdExpbmVJbmRleH1dYFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdHJpbmcgPSBgJHtydWxlTmFtZX1gO1xuXG4gICAgaWYgKG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgIHN0cmluZyA9IGAke3N0cmluZ30ke29wYWNpdHl9YDtcbiAgICB9XG5cbiAgICBzdHJpbmcgPSBgJHtzdHJpbmd9JHtsaW5lSW5kZXhlc31gO1xuXG4gICAgbGV0IHByZWNlZGVuY2UgPSBub25UZXJtaW5hbE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgaWYgKHByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmVjZWRlbmNlID09PSBJbmZpbml0eSkge1xuICAgICAgICBwcmVjZWRlbmNlID0gU1BBQ0VfQ0hBUkFDVEVSO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBgJHtzdHJpbmd9ICgke3ByZWNlZGVuY2V9KWA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oUnVsZU5hbWVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICBydWxlTmFtZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJzZVRyZWU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFBhcnNlVHJlZSBmcm9tIFwiLi4vcGFyc2VUcmVlXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBEQVNIX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSBleHRlbmRzIFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdGcm9tQ2hhcmFjdGVyc1dpZHRoKHdpZHRoLCBEQVNIX0NIQVJBQ1RFUiksXG4gICAgICAgICAgbGluZSA9IHN0cmluZywgLy8vXG4gICAgICAgICAgbGluZXMgPSBbXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgXSxcbiAgICAgICAgICBob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlID0gbmV3IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUobGluZXMpO1xuXG4gICAgcmV0dXJuIGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nRnJvbUNoYXJhY3RlcnNXaWR0aChjaGFyYWN0ZXJzV2lkdGgsIGNoYXJhY3Rlcikge1xuICBsZXQgc3RyaW5nID0gRU1QVFlfU1RSSU5HO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjaGFyYWN0ZXJzV2lkdGg7IGluZGV4KyspIHtcbiAgICBzdHJpbmcgKz0gY2hhcmFjdGVyO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuaW1wb3J0IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUgZnJvbSBcIi4vaG9yaXpvbnRhbEJyYW5jaFwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hpbGROb2Rlc1BhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21DaGlsZE5vZGVzQW5kVG9rZW5zKGNoaWxkTm9kZXMsIHRva2Vucykge1xuICAgIGxldCBjaGlsZE5vZGVzUGFyc2VUcmVlID0gbnVsbDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlcyA9IGNoaWxkTm9kZXMucmVkdWNlKChjaGlsZE5vZGVQYXJzZVRyZWVzLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlID0gY2hpbGROb2RlLmFzUGFyc2VUcmVlKHRva2Vucyk7XG5cbiAgICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlcy5wdXNoKGNoaWxkTm9kZVBhcnNlVHJlZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVBhcnNlVHJlZXM7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID0gY2hpbGROb2RlUGFyc2VUcmVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlID0gZmlyc3QoY2hpbGROb2RlUGFyc2VUcmVlcyk7XG5cbiAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlOyAgLy8vXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uLFxuICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSAwLFxuICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoID0gMCxcbiAgICAgICAgICAgIGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCA9IDA7XG5cbiAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlcy5mb3JFYWNoKChjaGlsZE5vZGVQYXJzZVRyZWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlV2lkdGggPSBjaGlsZE5vZGVQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZVBhcnNlVHJlZSxcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gZmlyc3RDaGlsZE5vZGVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gY2hpbGROb2RlUGFyc2VUcmVlc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUgPSBjaGlsZE5vZGVQYXJzZVRyZWUsXG4gICAgICAgICAgICAgICAgICBsYXN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArPSBsYXN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG4gICAgICAgICAgICBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArPSAxO1xuXG4gICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG5cbiAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGggPSBNYXRoLm1heChjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGgsIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiAtIGZpcnN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArIDEsXG4gICAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSA9IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgICAgbGVmdE1hcmdpbldpZHRoID0gZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uLFxuICAgICAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoIC0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGg7XG5cbiAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5hZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKTtcbiAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZS5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG4gICAgICAgIGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG5cbiAgICAgICAgY29uc3QgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICAgICAgZGVwdGggPSBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGg7IC8vL1xuXG4gICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tRGVwdGhBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENoaWxkTm9kZXNQYXJzZVRyZWUsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzLmZvckVhY2goKGNoaWxkTm9kZVBhcnNlVHJlZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpLFxuICAgICAgICAgICAgICAgIGNsb25lZENoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZVBhcnNlVHJlZS5jbG9uZSgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgY2hpbGROb2RlUGFyc2VUcmVlc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TWFyZ2luV2lkdGggPSAxO1xuXG4gICAgICAgICAgICBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoIDwgY2hpbGROb2RlUGFyc2VUcmVlc0RlcHRoKSB7XG4gICAgICAgICAgICBjb25zdCBib3R0b21NYXJnaW5EZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCAtIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoO1xuXG4gICAgICAgICAgICBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUuYWRkQm90dG9tTWFyZ2luKGJvdHRvbU1hcmdpbkRlcHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQoY2xvbmVkQ2hpbGROb2RlUGFyc2VUcmVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZS5hcHBlbmRUb1RvcChob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlKTtcblxuICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGROb2Rlc1BhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZU5hbWVQYXJzZVRyZWUgZnJvbSBcIi4vcnVsZU5hbWVcIjtcbmltcG9ydCBDaGlsZE5vZGVzUGFyc2VUcmVlIGZyb20gXCIuL2NoaWxkTm9kZXNcIjtcbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gICAgbGV0IG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZTtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlID0gUnVsZU5hbWVQYXJzZVRyZWUuZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2VucyksXG4gICAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IENoaWxkTm9kZXNQYXJzZVRyZWUuZnJvbUNoaWxkTm9kZXNBbmRUb2tlbnMoY2hpbGROb2RlcywgdG9rZW5zKTtcblxuICAgIGlmIChjaGlsZE5vZGVzUGFyc2VUcmVlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnNlVHJlZURlcHRoID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0RGVwdGgoKSxcbiAgICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHJ1bGVOYW1lUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24sIC8vL1xuICAgICAgICAgICAgZGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZURlcHRoOyAvLy9cblxuICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbURlcHRoQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQocnVsZU5hbWVQYXJzZVRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuXG4gICAgICBjb25zdCBjaGlsZE5vZGVzUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlID0gcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uIC0gY2hpbGROb2Rlc1BhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb247XG5cbiAgICAgIGxldCBsZWZ0TWFyZ2luV2lkdGg7XG5cbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAvLy9cbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSAtdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuXG4gICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlLmFkZExlZnRNYXJnaW4obGVmdE1hcmdpbldpZHRoKTtcbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlID4gMCkge1xuICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSArdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuXG4gICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBydWxlTmFtZVBhcnNlVHJlZVdpZHRoID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWVXaWR0aCA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHdpZHRoc0RpZmZlcmVuY2UgPSBydWxlTmFtZVBhcnNlVHJlZVdpZHRoIC0gY2hpbGROb2Rlc1BhcnNlVHJlZVdpZHRoO1xuXG4gICAgICBsZXQgcmlnaHRNYXJnaW5XaWR0aDtcblxuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vL1xuICAgICAgfSBlbHNlIGlmICh3aWR0aHNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICByaWdodE1hcmdpbldpZHRoID0gLXdpZHRoc0RpZmZlcmVuY2U7XG5cbiAgICAgICAgcnVsZU5hbWVQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoc0RpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgIHJpZ2h0TWFyZ2luV2lkdGggPSArd2lkdGhzRGlmZmVyZW5jZTtcblxuICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZS5nZXREZXB0aCgpLFxuICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHJ1bGVOYW1lUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiwgLy8vXG4gICAgICAgICAgICBkZXB0aCA9IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGg7IC8vL1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tRGVwdGhBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgZGVwdGgsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9SaWdodChydWxlTmFtZVBhcnNlVHJlZSk7XG5cbiAgICAgIG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb0JvdHRvbShjaGlsZE5vZGVzUGFyc2VUcmVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBub2RlTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvbm9kZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vcGFyc2VUcmVlL25vblRlcm1pbmFsTm9kZVwiO1xuXG5jb25zdCB7IGZpcnN0LCBtYXRjaCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IG9wYXF1ZTogb3BhcXVlU3BlY2lhbFN5bWJvbCAsIHNlbWlPcGFxdWU6IHNlbWlPcGFxdWVTcGVjaWFsU3ltYm9sIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uVGVybWluYWxOb2RlIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWUsIHBhcmVudE5vZGUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFJ1bGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICB9XG5cbiAgZ2V0UGFyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICB9XG5cbiAgZ2V0Q2hpbGROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZ2V0UHJlY2VkZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVjZWRlbmNlO1xuICB9XG5cbiAgc2V0UnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cblxuICBzZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuICB9XG5cbiAgc2V0Q2hpbGROb2RlcyhjaGlsZE5vZGVzKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IDAsXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSBJbmZpbml0eSxcbiAgICAgICAgICBhZGRlZENoaWxkTm9kZXMgPSBjaGlsZE5vZGVzOyAgLy8vXG5cbiAgICB0aGlzLnNwbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIGFkZGVkQ2hpbGROb2Rlcyk7XG4gIH1cblxuICBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICB9XG5cbiAgc2V0UHJlY2VkZW5jZShwcmVjZWRlbmNlKSB7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGlzT3BhcXVlKCkge1xuICAgIGNvbnN0IG9wYXF1ZSA9ICh0aGlzLm9wYWNpdHkgPT09IG9wYXF1ZVNwZWNpYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIG9wYXF1ZTtcbiAgfVxuXG4gIGlzU2VtaU9wYXF1ZSgpIHtcbiAgICBjb25zdCBzZW1pT3BhcXVlID0gKHRoaXMub3BhY2l0eSA9PT0gc2VtaU9wYXF1ZVNwZWNpYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIHNlbWlPcGFxdWU7XG4gIH1cblxuICBpc1RyYW5zcGFyZW50KCkge1xuICAgIGNvbnN0IHNlbWlPcGFxdWUgPSAodGhpcy5vcGFjaXR5ID09PSBudWxsKTtcblxuICAgIHJldHVybiBzZW1pT3BhcXVlO1xuICB9XG5cbiAgaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdHJ1ZTtcblxuICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBnZXREZXNjZW5kYW50Tm9kZXMoZGVzY2VuZGFudE5vZGVzKSB7XG4gICAgcmV0dXJuIGRlc2NlbmRhbnROb2RlcztcbiAgfVxuXG4gIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2Vucykge1xuICAgIGxldCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleDtcblxuICAgIHRoaXMuZm9yd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKTtcblxuICAgICAgaWYgKGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleDtcblxuICAgIHRoaXMuYmFja3dhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gICAgICBpZiAobGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0U2lnbmlmaWNhbnRUb2tlbnMoc2lnbmlmaWNhbnRUb2tlbnMgPSBbXSkge1xuICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNoaWxkTm9kZS5nZXRTaWduaWZpY2FudFRva2VucyhzaWduaWZpY2FudFRva2Vucyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbnM7XG4gIH1cblxuICBnZXRNdWx0aXBsaWNpdHkoKSB7XG4gICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgbXVsdGlwbGljaXR5ID0gY2hpbGROb2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgcmV0dXJuIG11bHRpcGxpY2l0eTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgY29uc3QgbXVsdGlwbGljaXR5ID0gdGhpcy5nZXRNdWx0aXBsaWNpdHkoKSxcbiAgICAgICAgICBlbXB0eSA9IChtdWx0aXBsaWNpdHkgPT09IDApO1xuXG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgaXNTaW5ndWxhcigpIHtcbiAgICBjb25zdCBtdWx0aXBsaWNpdHkgPSB0aGlzLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICAgIHNpbmd1bGFyID0gKG11bHRpcGxpY2l0eSA9PT0gMSk7XG5cbiAgICByZXR1cm4gc2luZ3VsYXI7XG4gIH1cblxuICBpc0xvd2VyUHJlY2VkZW5jZShydWxlTmFtZSwgcHJlY2VkZW5jZSkge1xuICAgIGxldCBsb3dlclByZWNlZGVuY2U7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjZWRlbmNlID09PSBudWxsKSB7XG4gICAgICBsb3dlclByZWNlZGVuY2UgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGROb2RlID0gZmlyc3QodGhpcy5jaGlsZE5vZGVzKTtcblxuICAgICAgbG93ZXJQcmVjZWRlbmNlID0gZmlyc3RDaGlsZE5vZGUuaXNMb3dlclByZWNlZGVuY2UocnVsZU5hbWUsIHByZWNlZGVuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3dlclByZWNlZGVuY2UgPSAoKHRoaXMucnVsZU5hbWUgPT09IHJ1bGVOYW1lKSAmJiAodGhpcy5wcmVjZWRlbmNlIDwgcHJlY2VkZW5jZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsb3dlclByZWNlZGVuY2U7XG4gIH1cblxuICBpc1VucHJlY2VkZW50ZWQoKSB7XG4gICAgbGV0IHVucHJlY2VkZW50ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIHVucHJlY2VkZW50ZWQgPSB0aGlzLmNoaWxkTm9kZXMuc29tZSgoY2hpbGROb2RlKSA9PiB7ICAvLy9cbiAgICAgICAgY29uc3QgY2hpbGROb2RlTG93ZXJQcmVjZWRlbmNlID0gY2hpbGROb2RlLmlzTG93ZXJQcmVjZWRlbmNlKHRoaXMucnVsZU5hbWUsIHRoaXMucHJlY2VkZW5jZSk7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5wcmVjZWRlbnRlZDtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHRoaXMsICAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUuZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2VucyksXG4gICAgICAgICAgcGFyc2VUcmVlID0gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlOyAgLy8vXG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgbWF0Y2gobm9kZSwgZGVwdGggPSBJbmZpbml0eSwgZXhhY3RseSA9IGZhbHNlKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgICBpZiAodGhpcy5ydWxlTmFtZSA9PT0gbm9uVGVybWluYWxOb2RlUnVsZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlT3BhY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRPcGFjaXR5KCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3BhY2l0eSA9PT0gbm9uVGVybWluYWxOb2RlT3BhY2l0eSkge1xuICAgICAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSB0aGlzLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICAgICAgICBub25UZXJtaW5hbE5vZGVQcmVjZWRlbmNlID0gbm9uVGVybWluYWxOb2RlLmdldFByZWNlZGVuY2UoKTtcblxuICAgICAgICAgIGlmIChwcmVjZWRlbmNlID09PSBub25UZXJtaW5hbE5vZGVQcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBkZXB0aC0tO1xuXG4gICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKTtcblxuICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2godGhpcy5jaGlsZE5vZGVzLCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzLCAoY2hpbGROb2RlLCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVNYXRjaGVzTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlID0gY2hpbGROb2RlLm1hdGNoKG5vblRlcm1pbmFsTm9kZUNoaWxkTm9kZSwgZGVwdGgsIGV4YWN0bHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZU1hdGNoZXNOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICByZXdyaXRlKHN0YXRlKSB7XG4gICAgY29uc3QgcmV3cml0dGVuTm9uVGVybWluYWxOb2RlID0gbnVsbDtcblxuICAgIHJldHVybiByZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZm9yRWFjaENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjaGlsZE5vZGUuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5ydWxlTmFtZSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gY2xvbmVDaGlsZE5vZGVzKHRoaXMuY2hpbGROb2RlcyksXG4gICAgICAgICAgb3BhY2l0eSA9IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gdGhpcy5wcmVjZWRlbmNlLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhydWxlTmFtZSwgcGFyZW50Tm9kZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBpZiAocHJlY2VkZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmVjZWRlbmNlID0gb3BhY2l0eTsgLy8vXG5cbiAgICAgIG9wYWNpdHkgPSBjaGlsZE5vZGVzOyAvLy9cblxuICAgICAgY2hpbGROb2RlcyA9IHJ1bGVOYW1lOyAgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IE5vblRlcm1pbmFsTm9kZTsgIC8vL1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhydWxlTmFtZSwgcGFyZW50Tm9kZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKE5vblRlcm1pbmFsTm9kZS5wcm90b3R5cGUsIG5vZGVNaXhpbnMpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkTm9kZXMoY2hpbGROb2Rlcykge1xuICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5tYXAoKGNoaWxkTm9kZSkgPT4geyAgLy8vXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNsb25lKCk7ICAvLy9cblxuICAgIHJldHVybiBjaGlsZE5vZGU7XG4gIH0pO1xuXG4gIHJldHVybiBjaGlsZE5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQWhlYWQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY2FsbEFoZWFkID0gY2FsbEFoZWFkO1xuICB9XG4gIFxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBpc0NhbGxBaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsQWhlYWQ7XG4gIH1cblxuICBpc05vblRlcm1pbmFsUGFydCgpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbFBhcnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IGZhbHNlO1xuICAgIFxuICAgIHJldHVybiB0ZXJtaW5hbFBhcnQ7XG4gIH1cblxuICBpc1J1bGVOYW1lUGFydCgpIHtcbiAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBmYWxzZTtcblxuICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFJ1bGVOYW1lUGFydFR5cGUgPSBcInJ1bGVOYW1lUGFydFwiO1xuZXhwb3J0IGNvbnN0IE9wdGlvbmFsUGFydFBhcnRUeXBlID0gXCJvcHRpb25hbFBhcnRcIjtcbmV4cG9ydCBjb25zdCBDaG9pY2VPZlBhcnRzUGFydFR5cGUgPSBcImNob2ljZU9mUGFydHNcIjtcbmV4cG9ydCBjb25zdCBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlID0gXCJvbmVPck1vcmVQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlID0gXCJ6ZXJvT3JNb3JlUGFydHNcIjtcbmV4cG9ydCBjb25zdCBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSA9IFwic2VxdWVuY2VPZlBhcnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBPcHRpb25hbFBhcnRQYXJ0VHlwZSB9IGZyb20gXCIuLi8uLi9wYXJ0VHlwZXNcIjtcblxuXG5jb25zdCB7IHF1ZXN0aW9uTWFyayB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbmFsUGFydFBhcnQgZXh0ZW5kcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQWhlYWQsIHBhcnQpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuXG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgfVxuXG4gIGdldFBhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydDtcbiAgfVxuXG4gIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgcGFyc2VkID0gcGFyc2VPcHRpb25hbFBhcnQodGhpcy5wYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm9kZXNMZW5ndGg7ICAvLy9cblxuICAgICAgbm9kZXMuc3BsaWNlKHN0YXJ0KTtcblxuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgICAgc3RyaW5nID0gYCR7cGFydFN0cmluZ30ke3F1ZXN0aW9uTWFya31gO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydChwYXJ0KSB7XG4gICAgY29uc3QgdHlwZSA9IE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbmFsUGFydFBhcnQgPSBuZXcgT3B0aW9uYWxQYXJ0UGFydCh0eXBlLCBjYWxsQWhlYWQsIHBhcnQpO1xuXG4gICAgcmV0dXJuIG9wdGlvbmFsUGFydFBhcnQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlT3B0aW9uYWxQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIGlmIChjYWxsQWhlYWQgPT09IG51bGwpIHtcbiAgICBwYXJzZWQgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cblxuXG5cblxuICAgIHBhcnNlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG5cblxuXG5cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIH0gZnJvbSBcIi4uLy4uL3BhcnRUeXBlc1wiO1xuXG5cbmNvbnN0IHsgYXN0ZXJpc2sgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaZXJvT3JNb3JlUGFydHNQYXJ0IGV4dGVuZHMgTm9uVGVybWluYWxQYXJ0IHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KSB7XG4gICAgc3VwZXIodHlwZSwgY2FsbEFoZWFkKTtcblxuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gIH1cblxuICBnZXRQYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHBhcnNlZCA9IHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydCh0aGlzLnBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuXG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRTdHJpbmcgPSB0aGlzLnBhcnQuYXNTdHJpbmcoKSxcbiAgICAgICAgICBzdHJpbmcgPSBgJHtwYXJ0U3RyaW5nfSR7YXN0ZXJpc2t9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnQocGFydCkge1xuICAgIGNvbnN0IHR5cGUgPSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gbmV3IFplcm9Pck1vcmVQYXJ0c1BhcnQodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KTtcblxuICAgIHJldHVybiB6ZXJvT3JNb3JlUGFydHNQYXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVplcm9Pck1vcmVQYXJ0c1BhcnQocGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgaWYgKGNhbGxBaGVhZCA9PT0gbnVsbCkge1xuICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgcGFyc2VkID0gcGFyc2VaZXJvT3JNb3JlUGFydHNQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IE9uZU9yTW9yZVBhcnRzUGFydFR5cGUgfSBmcm9tIFwiLi4vLi4vcGFydFR5cGVzXCI7XG5pbXBvcnQgeyBwYXJzZVplcm9Pck1vcmVQYXJ0c1BhcnQgfSBmcm9tIFwiLi96ZXJvT3JNb3JlUGFydHNcIjtcblxuY29uc3QgeyBwbHVzIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT25lT3JNb3JlUGFydHNQYXJ0IGV4dGVuZHMgTm9uVGVybWluYWxQYXJ0IHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KSB7XG4gICAgc3VwZXIodHlwZSwgY2FsbEFoZWFkKTtcblxuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gIH1cblxuICBnZXRQYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHBhcnNlZCA9IHBhcnNlT25lT3JNb3JlUGFydHNQYXJ0KHRoaXMucGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICAgIG5vZGVzLnNwbGljZShzdGFydCk7XG5cbiAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3QgcGFydFN0cmluZyA9IHRoaXMucGFydC5hc1N0cmluZygpLFxuICAgICAgICAgIHN0cmluZyA9IGAke3BhcnRTdHJpbmd9JHtwbHVzfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXJ0KHBhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICBvbmVPck1vcmVQYXJ0c1BhcnQgPSBuZXcgT25lT3JNb3JlUGFydHNQYXJ0KHR5cGUsIGNhbGxBaGVhZCwgcGFydCk7XG5cbiAgICByZXR1cm4gb25lT3JNb3JlUGFydHNQYXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9uZU9yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBpZiAoY2FsbEFoZWFkID09PSBudWxsKSB7XG4gICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcGFyc2VaZXJvT3JNb3JlUGFydHNQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG4gICAgfVxuXG5cbiAgfSBlbHNlIHtcblxuXG5cbiAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgKCkgPT4ge1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE5BTUVfUlVMRV9OQU1FID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgUEFSVF9SVUxFX05BTUUgPSBcInBhcnRcIjtcbmV4cG9ydCBjb25zdCBSVUxFX1JVTEVfTkFNRSA9IFwicnVsZVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SX1JVTEVfTkFNRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBFUFNJTE9OX1JVTEVfTkFNRSA9IFwiZXBzaWxvblwiO1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1JVTEVfTkFNRSA9IFwiZG9jdW1lbnRcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9SVUxFX05BTUUgPSBcIndpbGRjYXJkXCI7XG5leHBvcnQgY29uc3QgUlVMRV9OQU1FX1JVTEVfTkFNRSA9IFwicnVsZU5hbWVcIjtcbmV4cG9ydCBjb25zdCBERUZJTklUSU9OX1JVTEVfTkFNRSA9IFwiZGVmaW5pdGlvblwiO1xuZXhwb3J0IGNvbnN0IFBSRUNFREVOQ0VfUlVMRV9OQU1FID0gXCJwcmVjZWRlbmNlXCI7XG5leHBvcnQgY29uc3QgUVVBTlRJRklFUl9SVUxFX05BTUUgPSBcInF1YW50aWZpZXJcIjtcbmV4cG9ydCBjb25zdCBFTkRfT0ZfTElORV9SVUxFX05BTUUgPSBcImVuZE9mTGluZVwiO1xuZXhwb3J0IGNvbnN0IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSA9IFwicGFydENob2ljZVwiO1xuZXhwb3J0IGNvbnN0IERFRklOSVRJT05TX1JVTEVfTkFNRSA9IFwiZGVmaW5pdGlvbnNcIjtcbmV4cG9ydCBjb25zdCBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSA9IFwidGVybWluYWxQYXJ0XCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FID0gXCJzdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgY29uc3QgQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRSA9IFwiY2hvaWNlT2ZQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FID0gXCJvcGFjaXR5TW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUgPSBcIm5vblRlcm1pbmFsUGFydFwiO1xuZXhwb3J0IGNvbnN0IFNFUVVFTkNFX09GX1BBUlRTX1JVTEVfTkFNRSA9IFwic2VxdWVuY2VPZlBhcnRzXCI7XG5leHBvcnQgY29uc3QgTk9fV0hJVEVTUEFDRV9QQVJUX1JVTEVfTkFNRSA9IFwibm9XaGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3QgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSA9IFwicmVndWxhckV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSA9IFwiY2FsbEFoZWFkTW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwib3B0aW9uYWxRdWFudGlmaWVyXCI7XG5leHBvcnQgY29uc3QgU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRSA9IFwic3RhcnRPZkNvbnRlbnRcIjtcbmV4cG9ydCBjb25zdCBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRSA9IFwic2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcbmV4cG9ydCBjb25zdCBPTkVfT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwib25lT3JNb3JlUXVhbnRpZmllclwiO1xuZXhwb3J0IGNvbnN0IFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwiemVyb09yTW9yZVF1YW50aWZpZXJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IFJVTEVfTkFNRV9SVUxFX05BTUUsIFFVQU5USUZJRVJfUlVMRV9OQU1FLCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDaG9pY2VOb2RlKG5vZGUpIHtcbiAgbGV0IG5vZGVOb0Nob2ljZU5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgbm9kZU5vQ2hvaWNlTm9kZSA9ICh0ZXJtaW5hbE5vZGVDb250ZW50ID09PSBcInxcIik7XG4gIH1cblxuICByZXR1cm4gbm9kZU5vQ2hvaWNlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVJ1bGVOYW1lTm9kZShub2RlKSB7XG4gIGxldCBub2RlUnVsZU5hbWVOb2RlID0gZmFsc2U7XG5cbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgbm9kZU5vblRlcm1pbmFsTm9kZSA9ICFub2RlVGVybWluYWxOb2RlO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgIG5vZGVSdWxlTmFtZU5vZGUgPSAobm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPT09IFJVTEVfTkFNRV9SVUxFX05BTUUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVSdWxlTmFtZU5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVRdWFudGlmaWVyTm9kZShub2RlKSB7XG4gIGxldCBub2RlUXVhbnRpZmllck5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZVF1YW50aWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gUVVBTlRJRklFUl9SVUxFX05BTUUpO1xuXG4gICAgbm9kZVF1YW50aWZpZXJOb2RlID0gcnVsZU5hbWVRdWFudGlmaWVyUnVsZU5hbWU7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlUXVhbnRpZmllck5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDYWxsQWhlYWRNb2RpZmllck5vZGUobm9kZSkge1xuICBsZXQgbm9kZUNhbGxBaGVhZE1vZGlmaWVyTm9kZSA9IGZhbHNlO1xuXG4gIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lQ2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUUpO1xuXG4gICAgbm9kZUNhbGxBaGVhZE1vZGlmaWVyTm9kZSA9IHJ1bGVOYW1lQ2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG5vZGVDYWxsQWhlYWRNb2RpZmllck5vZGU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbVF1YW50aWZpZXJOb2RlKHF1YW50aWZpZXJOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcXVhbnRpZmllck5vZGU7IC8vL1xuXG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpO1xuXG4gIG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgY29uc3QgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBPbmVPck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIjtcbmltcG9ydCBaZXJvT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiO1xuXG5pbXBvcnQgeyBpc05vZGVRdWFudGlmaWVyTm9kZSwgcnVsZU5hbWVGcm9tUXVhbnRpZmllck5vZGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2JuZlwiO1xuaW1wb3J0IHsgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgbGFzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBub2RlcyA9IGNoaWxkTm9kZXMuc2xpY2UoKSxcbiAgICAgICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5mdW5jdGlvbiBwYXJ0RnJvbU5vZGVzKG5vZGVzKSB7XG4gIGxldCBwYXJ0O1xuXG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGlmIChub2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZTtcblxuICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3ROb2RlUXVhbnRpZmllck5vZGUgPSBpc0xhc3ROb2RlUXVhbnRpZmllck5vZGUobm9kZXMpO1xuXG4gICAgaWYgKGxhc3ROb2RlUXVhbnRpZmllck5vZGUpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKSxcbiAgICAgICAgICAgIHF1YW50aWZpZXJOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG5cbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZU5hbWVGcm9tUXVhbnRpZmllck5vZGUocXVhbnRpZmllck5vZGUpLFxuICAgICAgICAgICAgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gY29sbGVjdGlvbk9mUGFydHNQYXJ0RnJvbVBhcnRBbmRSdWxlTmFtZShwYXJ0LCBydWxlTmFtZSk7XG5cbiAgICAgIHBhcnQgPSBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7IC8vL1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5zaGlmdCgpO1xuXG4gICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnQ7XG59XG5cbmZ1bmN0aW9uIGlzTGFzdE5vZGVRdWFudGlmaWVyTm9kZShub2Rlcykge1xuICBjb25zdCBsYXN0Tm9kZSA9IGxhc3Qobm9kZXMpLFxuICAgICAgICBsYXN0Tm9kZVF1YW50aWZpZXJOb2RlID0gaXNOb2RlUXVhbnRpZmllck5vZGUobGFzdE5vZGUpO1xuXG4gIHJldHVybiBsYXN0Tm9kZVF1YW50aWZpZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnRGcm9tUGFydEFuZFJ1bGVOYW1lKHBhcnQsIHJ1bGVOYW1lKSB7XG4gIGxldCBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7XG5cbiAgc3dpdGNoIChydWxlTmFtZSkge1xuICAgIGNhc2UgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUgOlxuICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQocGFydCk7XG5cbiAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IG9wdGlvbmFsUGFydFBhcnQ7IC8vL1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FIDpcbiAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IE9uZU9yTW9yZVBhcnRzUGFydC5mcm9tUGFydChwYXJ0KTtcblxuICAgICAgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0OyAvLy9cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgOlxuICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocGFydCk7XG5cbiAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQ7ICAvLy9cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb25PZlBhcnRzUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hbWVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgZmlyc3RDaGlsZE5vZGUgPSBmaXJzdChjaGlsZE5vZGVzKSxcbiAgICAgICAgICB0ZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIG5hbWUgPSB0ZXJtaW5hbE5vZGVDb250ZW50OyAvLy9cbiAgICBcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGNoaWxkTm9kZXMuc29tZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lID0gKG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBydWxlTmFtZSk7XG5cbiAgICAgIGlmIChub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpIHtcbiAgY29uc3Qgbm9kZXMgPSBjaGlsZE5vZGVzLmZpbHRlcigoY2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lID0gKG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBydWxlTmFtZSk7XG5cbiAgICAgIGlmIChub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBPUEFDSVRZX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZExhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlUnVsZShSdWxlKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpLFxuICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IHRoaXMuZ2VuZXJhdGVEZWZpbml0aW9ucygpLFxuICAgICAgICAgIHJ1bGUgPSBSdWxlLmZyb21OYW1lT3BhY2l0eUFuZERlZmluaXRpb25zKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBydWxlO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBsZXQgb3BhY2l0eSA9IG51bGw7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgaWYgKG9wYWNpdHlNb2RpZmllckJORk5vZGUgIT09IG51bGwpIHtcbiAgICAgIG9wYWNpdHkgPSBvcGFjaXR5TW9kaWZpZXJCTkZOb2RlLmdldE9wYWNpdHkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgbmFtZUJORk5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIG5hbWUgPSBuYW1lQk5GTm9kZS5nZXROYW1lKCk7XG4gICAgXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgXG4gIGdlbmVyYXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHNlY29uZExhc3RDaGlsZE5vZGUgPSBzZWNvbmRMYXN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIGRlZmluaXRpb25zQk5GTm9kZSA9IHNlY29uZExhc3RDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnNCTkZOb2RlLmdlbmVyYXRlRGVmaW5pdGlvbnMoKTtcbiAgICBcbiAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJ1bGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEVycm9yQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsUGFydCB7XG4gIGlzQ2FsbEFoZWFkKCkge1xuICAgIGNvbnN0IGNhbGxBaGVhZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGNhbGxBaGVhZDtcbiAgfVxuXG4gIGlzTm9uVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIHRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzTm9XaGl0ZXNwYWNlUGFydCgpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VQYXJ0ID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgfVxuXG4gIGlzU3RhcnRPZkNvbnRlbnRQYXJ0KCkge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50UGFydDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUgZnJvbSBcIi4vdmVydGljYWxCcmFuY2hcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgbGluZUluZGV4RnJvbVRva2VuSW5kZXhBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rva2Vuc1wiO1xuXG5jb25zdCB7IE5FV19MSU5FX0NIQVJBQ1RFUiwgQ0FSUklBR0VfUkVUVVJOX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxOb2RlUGFyc2VUcmVlIGV4dGVuZHMgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUge1xuICBzdGF0aWMgZnJvbVRlcm1pbmFsTm9kZUFuZFRva2Vucyh0ZXJtaW5hbE5vZGUsIHRva2Vucykge1xuICAgIGxldCBjb250ZW50O1xuXG4gICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9bXFxyXFxuXS9nLCAobWF0Y2gpID0+IHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG5cbiAgICAgICAgY2FzZSBORVdfTElORV9DSEFSQUNURVI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGUgPSB0ZXJtaW5hbE5vZGUuZ2V0VHlwZSgpLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRlcm1pbmFsTm9kZS5nZXRTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyhzaWduaWZpY2FudFRva2VuSW5kZXgsIHRva2Vucyk7XG5cbiAgICBsZXQgbGluZUluZGV4ZXM7XG5cbiAgICBpZiAobGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICBsaW5lSW5kZXhlcyA9IEVNUFRZX1NUUklORztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZUluZGV4ZXMgPSBgIFske2xpbmVJbmRleH1dYDtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpbmcgPSBgXCIke2NvbnRlbnR9XCJbJHt0eXBlfV0ke2xpbmVJbmRleGVzfWAsXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKFRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXJtaW5hbE5vZGVQYXJzZVRyZWUgZnJvbSBcIi4uL3BhcnNlVHJlZS90ZXJtaW5hbE5vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxOb2RlIHtcbiAgY29uc3RydWN0b3IocGFyZW50Tm9kZSwgc2lnbmlmaWNhbnRUb2tlbikge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgdGhpcy5zaWduaWZpY2FudFRva2VuID0gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIGdldFBhcmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGdldFNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHNldFBhcmVudE5vZGUocGFyZW50Tm9kZSkge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cblxuICBzZXRTaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pIHtcbiAgICB0aGlzLnNpZ25pZmljYW50VG9rZW4gPSBzaWduaWZpY2FudFRva2VuO1xuICB9XG5cbiAgaXNTdGFydE9mQ29udGVudE5vZGUoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnROb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnROb2RlO1xuICB9XG5cbiAgaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGUgPSBmYWxzZTtcblxuICAgIHJldHVybiBub1doaXRlc3BhY2VOb2RlO1xuICB9XG5cbiAgaXNFcHNpbG9uTm9kZSgpIHtcbiAgICBjb25zdCBlcHNpbG9uTm9kZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlO1xuICB9XG5cbiAgaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gdHJ1ZTtcbiAgICBcbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHsgcmV0dXJuIHRoaXMuc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7IH1cblxuICBnZXRDb250ZW50KCkgeyByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuLmdldENvbnRlbnQoKTsgfVxuXG4gIGdldFByZWNlZGVuY2UoKSAge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsO1xuXG4gICAgcmV0dXJuIHByZWNlZGVuY2U7XG4gIH1cblxuICBpc0xvd2VyUHJlY2VkZW5jZShwYXJlbnRSdWxlTmFtZSwgcGFyZW50UHJlY2VkZW5jZSkge1xuICAgIGNvbnN0IGxvd2VyUHJlY2VkZW5jZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGxvd2VyUHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2Vucykge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRoaXMuZ2V0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSBzaWduaWZpY2FudFRva2VuSW5kZXg7IC8vL1xuXG4gICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuSW5kZXggPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpLFxuICAgICAgICAgIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSBzaWduaWZpY2FudFRva2VuSW5kZXg7IC8vL1xuXG4gICAgcmV0dXJuIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXg7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSB7XG4gICAgbGV0IHNpZ25pZmljYW50VG9rZW5JbmRleCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICBzaWduaWZpY2FudFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZih0aGlzLnNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuSW5kZXg7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VucyhzaWduaWZpY2FudFRva2VucyA9IFtdKSB7XG4gICAgaWYgKHRoaXMuc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgc2lnbmlmaWNhbnRUb2tlbnMucHVzaCh0aGlzLnNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VucztcbiAgfVxuXG4gIGdldEFuY2VzdG9yTm9kZXMoKSB7XG4gICAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IFtdO1xuXG4gICAgbGV0IGFuY2VzdG9yTm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8vXG5cbiAgICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgICBhbmNlc3Rvck5vZGVzLnB1c2goYW5jZXN0b3JOb2RlKTtcblxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yTm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgIGFuY2VzdG9yTm9kZSA9IHBhcmVudE5vZGU7ICAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2RlcztcbiAgfVxuXG4gIG1hcEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGFuY2VzdG9yTm9kZXMgPSB0aGlzLmdldEFuY2VzdG9yTm9kZXMoKTtcblxuICAgIHJldHVybiBhbmNlc3Rvck5vZGVzLm1hcChjYWxsYmFjayk7XG4gIH1cblxuICBzb21lQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgbGV0IGluZGV4ID0gMCxcbiAgICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICAgIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7IC8vL1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaW5kQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IGluZGV4ID0gMCxcbiAgICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICAgIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKGFuY2VzdG9yTm9kZSwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBhbmNlc3Rvck5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICBhbmNlc3Rvck5vZGUgPSBwYXJlbnROb2RlOyAgLy8vXG5cbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JOb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGFuY2VzdG9yTm9kZTtcbiAgfVxuXG4gIGV2ZXJ5QW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICBsZXQgaW5kZXggPSAwLFxuICAgICAgICBhbmNlc3Rvck5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vL1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gISFjYWxsYmFjayhhbmNlc3Rvck5vZGUsIGluZGV4KTsgLy8vXG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaWx0ZXJBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xuICB9XG5cbiAgcmVkdWNlQW5jZXN0b3JOb2RlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBmb3JFYWNoQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gICAgYW5jZXN0b3JOb2Rlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGdldERlc2NlbmRhbnROb2RlcyhkZXNjZW5kYW50Tm9kZXMgPSBbXSkge1xuICAgIHJldHVybiBkZXNjZW5kYW50Tm9kZXM7XG4gIH1cblxuICBzb21lRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgICBsZXQgZGVzY2VuZGFudE5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVzY2VuZGFudE5vZGU7XG4gIH1cblxuICBldmVyeURlc2NlbmRhbnROb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gdGhpcywgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFRlcm1pbmFsTm9kZVBhcnNlVHJlZS5mcm9tVGVybWluYWxOb2RlQW5kVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBtYXRjaChub2RlLCBkZXB0aCA9IEluZmluaXR5LCBleGFjdGx5ID0gZmFsc2UpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICBzaWduaWZpY2FudFRva2VuID0gdGVybWluYWxOb2RlLmdldFNpZ25pZmljYW50VG9rZW4oKTtcblxuICAgICAgbWF0Y2hlcyA9IGV4YWN0bHkgP1xuICAgICAgICAgICAgICAgICAgKHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9PT0gc2lnbmlmaWNhbnRUb2tlbikgOlxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduaWZpY2FudFRva2VuLm1hdGNoKHNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSB0aGlzLnNpZ25pZmljYW50VG9rZW4sXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGlmIChDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBDbGFzcyA9IFRlcm1pbmFsTm9kZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG51bGwsXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IG51bGwsXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21TaWduaWZpY2FudFRva2VuKENsYXNzLCBzaWduaWZpY2FudFRva2VuLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduaWZpY2FudFRva2VuID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IFRlcm1pbmFsTm9kZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG51bGwsXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgXG4gICAgcmV0dXJuIHRlcm1pbmFsTm9kZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuLi9wYXJzZVRyZWUvdmVydGljYWxCcmFuY2hcIjtcblxuY29uc3QgeyBlcHNpbG9uIH0gPSBzcGVjaWFsU3ltYm9scztcblxuY2xhc3MgRXBzaWxvbk5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBlcHNpbG9uLCAvLy9cbiAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGggPSBzdHJpbmdMZW5ndGgsIC8vL1xuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGgpLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCksXG4gICAgICAgICAgdGVybWluYWxOb2RlUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oRXBzaWxvbk5vZGVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9Ub3AodmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuXG4gICAgY29uc3QgZXBzaWxvbk5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlUGFyc2VUcmVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXBzaWxvbk5vZGVQYXJzZVRyZWU7IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vdGVybWluYWxcIjtcbmltcG9ydCBFcHNpbG9uTm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vLi4vcGFyc2VUcmVlL2Vwc2lsb25Ob2RlXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25Ob2RlIGV4dGVuZHMgVGVybWluYWxOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBjb25zdCB0eXBlID0gbnVsbDsgIC8vL1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBlcHNpbG9uOyAgLy8vXG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlzRXBzaWxvbk5vZGUoKSB7XG4gICAgY29uc3QgZXBzaWxvbk5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlO1xuICB9XG5cbiAgYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgY29uc3QgZXBzaWxvbk5vZGVQYXJzZVRyZWUgPSBFcHNpbG9uTm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IGVwc2lsb25Ob2RlUGFyc2VUcmVlOyAgLy8vXG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgbWF0Y2gobm9kZSwgZGVwdGgpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICB0ZXJtaW5hbE5vZGVFcHNpbG9uTm9kZSA9IHRlcm1pbmFsTm9kZS5pc0Vwc2lsb25Ob2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVFcHNpbG9uTm9kZSkge1xuICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIFRlcm1pbmFsTm9kZS5mcm9tTm90aGluZyhFcHNpbG9uTm9kZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBFcHNpbG9uQk5GTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9lcHNpbG9uXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25QYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgZXBzaWxvbkJORk5vZGUgPSBFcHNpbG9uQk5GTm9kZS5mcm9tTm90aGluZygpO1xuXG4gICAgcGFyc2VkID0gKGVwc2lsb25CTkZOb2RlICE9PSBudWxsKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIG5vZGVzLnB1c2goZXBzaWxvbkJORk5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGVwc2lsb247IC8vL1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlcHNpbG9uUGFydCA9IG5ldyBFcHNpbG9uUGFydCgpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25QYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFcHNpbG9uUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbC9lcHNpbG9uXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25CTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGVwc2lsb25QYXJ0ID0gRXBzaWxvblBhcnQuZnJvbU5vdGhpbmcoKTtcblxuICAgIHJldHVybiBlcHNpbG9uUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXBzaWxvbkJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb21cIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgUlVMRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVSdWxlcyhSdWxlKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSVUxFX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcnVsZUJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICBydWxlcyA9IHJ1bGVCTkZOb2Rlcy5tYXAoKHJ1bGVCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZUJORk5vZGUuZ2VuZXJhdGVSdWxlKFJ1bGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKERvY3VtZW50Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJ1bGVOYW1lUGFydFR5cGUgfSBmcm9tIFwiLi4vLi4vcGFydFR5cGVzXCI7XG5cbmNvbnN0IHsgZWxsaXBzaXMgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZVBhcnQgZXh0ZW5kcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQUFoZWFkLCBydWxlTmFtZSkge1xuICAgIHN1cGVyKHR5cGUsIGNhbGxBQWhlYWQpO1xuXG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICB9XG4gIFxuICBnZXRSdWxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZTtcbiAgfVxuXG4gIGlzUnVsZU5hbWVQYXJ0KCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IHRydWU7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG5cbiAgZmluZFJ1bGUoc3RhdGUpIHtcbiAgICBjb25zdCBydWxlTWFwID0gc3RhdGUuZ2V0UnVsZU1hcCgpLFxuICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3RoaXMucnVsZU5hbWVdIHx8IG51bGw7ICAvLy9cblxuICAgIHJldHVybiBydWxlO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmZpbmRSdWxlKHN0YXRlKTtcblxuICAgIHBhcnNlZCA9IChydWxlICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICBydWxlLnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkgOlxuICAgICAgICAgICAgICAgICBmYWxzZTtcblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBjYWxsQUFoZWFkID0gdGhpcy5pc0NhbGxBaGVhZCgpLFxuICAgICAgICAgIGNhbGxBQWhlYWRTdHJpbmcgPSBjYWxsQUFoZWFkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbGlwc2lzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HLFxuICAgICAgICAgIHN0cmluZyA9IGAke3RoaXMucnVsZU5hbWV9JHtjYWxsQUFoZWFkU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZShydWxlTmFtZSkge1xuICAgIGNvbnN0IHR5cGUgPSBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICBydWxlTmFtZVBhcnQgPSBuZXcgUnVsZU5hbWVQYXJ0KHR5cGUsIGNhbGxBQWhlYWQsIHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUNhbGxBaGVhZEFuZFJ1bGVOYW1lKGNhbGxBQWhlYWQsIHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IFJ1bGVOYW1lUGFydFR5cGUsXG4gICAgICAgICAgcnVsZU5hbWVQYXJ0ID0gbmV3IFJ1bGVOYW1lUGFydCh0eXBlLCBjYWxsQUFoZWFkLCBydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZUJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVDb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQsIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tQ2FsbEFoZWFkQW5kUnVsZU5hbWUoY2FsbEFoZWFkLCBydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSdWxlTmFtZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiO1xuXG5jb25zdCB7IHdpbGRjYXJkIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lsZGNhcmRQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGxldCB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuXHRcdFx0XHRcdHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgdGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlLmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHdpbGRjYXJkOyAgLy8vXG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHdpbGRjYXJkUGFydCA9IG5ldyBXaWxkY2FyZFBhcnQoKTtcblxuICAgIHJldHVybiB3aWxkY2FyZFBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFdpbGRjYXJkUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbC93aWxkY2FyZFwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWxkY2FyZEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgd2lsZGNhcmRQYXJ0ID0gV2lsZGNhcmRQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gd2lsZGNhcmRQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShXaWxkY2FyZEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuL3ZlcnRpY2FsQnJhbmNoXCI7XG5cbmNvbnN0IHsgZW5kT2ZMaW5lIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGVuZE9mTGluZSwgLy8vXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKEVuZE9mTGluZU5vZGVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9Ub3AodmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuXG4gICAgY29uc3QgZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSA9IHRlcm1pbmFsTm9kZVBhcnNlVHJlZTsgLy8vXG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi90ZXJtaW5hbFwiO1xuaW1wb3J0IEVuZE9mTGluZU5vZGVQYXJzZVRyZWUgZnJvbSBcIi4uLy4uL3BhcnNlVHJlZS9lbmRPZkxpbmVOb2RlXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lTm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XG4gIGdldENvbnRlbnQoZmFpdGhmdWwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmYWl0aGZ1bCA/XG4gICAgICAgICAgICAgICAgICAgICAgc3VwZXIuZ2V0Q29udGVudCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORzsgLy8vXG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IGVuZE9mTGluZU5vZGVQYXJzZVRyZWUgPSBFbmRPZkxpbmVOb2RlUGFyc2VUcmVlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFyc2VUcmVlID0gZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZTsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKSB7IHJldHVybiBUZXJtaW5hbE5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oRW5kT2ZMaW5lTm9kZSwgc2lnbmlmaWNhbnRUb2tlbik7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBFbmRPZkxpbmVOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1pbmFsL2VuZE9mTGluZVwiO1xuXG5jb25zdCB7IGVuZE9mTGluZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZE9mTGluZVBhcnQgZXh0ZW5kcyBUZXJtaW5hbFBhcnQge1xuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IGVuZE9mTGluZU5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlbkVuZE9mTGluZVRva2VuID0gc2lnbmlmaWNhbnRUb2tlbi5pc0VuZE9mTGluZVRva2VuKCk7XG5cbiAgICAgIGlmIChzaWduaWZpY2FudFRva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgZW5kT2ZMaW5lTm9kZSA9IEVuZE9mTGluZU5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKGVuZE9mTGluZU5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaChlbmRPZkxpbmVOb2RlKTtcblxuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBpZiAoY2FsbEFoZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBlbmRPZkxpbmU7IC8vL1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlbmRPZkxpbmVQYXJ0ID0gbmV3IEVuZE9mTGluZVBhcnQoKTtcblxuICAgIHJldHVybiBlbmRPZkxpbmVQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbmRPZkxpbmVQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGVuZE9mTGluZVBhcnQgPSBFbmRPZkxpbmVQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRW5kT2ZMaW5lQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0Q2hvaWNlIHtcbiAgY29uc3RydWN0b3IocGFydCwgcHJlY2VkZW5jZSkge1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFBhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydDtcbiAgfVxuXG4gIGdldFByZWNlZGVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZTtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmc7XG5cbiAgICBjb25zdCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCk7XG5cbiAgICBzdHJpbmcgPSBwYXJ0U3RyaW5nOyAgLy8vXG5cbiAgICBpZiAodGhpcy5wcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQQUNFX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZTtcblxuICAgICAgc3RyaW5nID0gYCR7c3RyaW5nfSAoJHtwcmVjZWRlbmNlfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnQocGFydCkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHBhcnRDaG9pY2UgPSBuZXcgUGFydENob2ljZShwYXJ0LCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJ0Q2hvaWNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXJ0QW5kUHJlY2VkZW5jZShwYXJ0LCBwcmVjZWRlbmNlKSB7XG4gICAgY29uc3QgcGFydENob2ljZSA9IG5ldyBQYXJ0Q2hvaWNlKHBhcnQsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHBhcnRDaG9pY2U7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFBhcnRDaG9pY2UgZnJvbSBcIi4uLy4uL3BhcnRDaG9pY2VcIjtcbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydENob2ljZUJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnRDaG9pY2UoY2FsbEFoZWFkKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgcnVsZU5hbWUgPSBQQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHBhcnRCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBQUkVDRURFTkNFX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHByZWNlZGVuY2VCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgY2FsbEFoZWFkID0gZmFsc2U7ICAvLy9cblxuICAgIGNvbnN0IHBhcnQgPSBwYXJ0Qk5GTm9kZS5nZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gKHByZWNlZGVuY2VCTkZOb2RlID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VCTkZOb2RlLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICBkZWZpbml0aW9uID0gUGFydENob2ljZS5mcm9tUGFydEFuZFByZWNlZGVuY2UocGFydCwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUGFydENob2ljZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZWNlZGVuY2VCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0UHJlY2VkZW5jZSgpIHtcbiAgICBsZXQgcHJlY2VkZW5jZSA9IEluZmluaXR5O1xuXG4gICAgY29uc3QgbXVsdGlwbGljaXR5ID0gdGhpcy5nZXRNdWx0aXBsaWNpdHkoKTtcblxuICAgIGlmIChtdWx0aXBsaWNpdHkgPT09IDMpIHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICAgIHNlY29uZENoaWxkTm9kZSA9IHNlY29uZChjaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHByZWNlZGVuY2UgPSBOdW1iZXIoY29udGVudCk7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBwcmVjZWRlbmNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcmVjZWRlbmNlQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhbnRpZmllckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFF1YW50aWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBjb25zdCBpbmRleCA9IDAsXG4gICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgIHBhcnRcbiAgICAgICAgXTtcblxuICBwYXJzZWQgPSBwYXJzZVBhcnRPZlBhcnRzKGluZGV4LCBwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJ0cyhwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgY29uc3QgaW5kZXggPSAwO1xuXG4gIHBhcnNlZCA9IHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBjb25zdCBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICBpZiAoaW5kZXggPT09IHBhcnRzTGVuZ3RoKSB7XG4gICAgcGFyc2VkID0gKGNhbGxiYWNrICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICBjYWxsYmFjaygpIDpcbiAgICAgICAgICAgICAgICAgdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbaW5kZXhdLFxuICAgICAgICAgIHBhcnRDYWxsQWhlYWQgPSAoY2FsbEFoZWFkID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pc0NhbGxBaGVhZCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWU7XG5cbiAgICBpbmRleCsrO1xuXG4gICAgcGFyc2VkID0gcGFydENhbGxBaGVhZCA/XG4gICAgICAgICAgICAgICBwYXJzZVBhcnRXaXRoQ2FsbEFoZWFkKHBhcnQsIGluZGV4LCBwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSA6XG4gICAgICAgICAgICAgICAgIHBhcnNlUGFydFdpdGhvdXRDYWxsQWhlYWQocGFydCwgaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0V2l0aENhbGxBaGVhZChwYXJ0LCBpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGNhbGxBaGVhZCA9ICgpID0+IHsgLy8vXG4gICAgbGV0IHBhcnNlZDtcblxuICAgIHBhcnNlZCA9IHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfTtcblxuICBwYXJzZWQgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgaWYgKCFwYXJzZWQpIHtcbiAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0V2l0aG91dENhbGxBaGVhZChwYXJ0LCBpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICBpZiAocGFyc2VkKSB7XG4gICAgcGFyc2VkID0gcGFyc2VQYXJ0T2ZQYXJ0cyhpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBwYXJzZVBhcnRzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlXCI7XG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJ0cywgcHJlY2VkZW5jZSkge1xuICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICB9XG5cbiAgZ2V0UGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cblxuICBnZXRQcmVjZWRlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2U7XG4gIH1cblxuICBwYXJzZShjaGlsZE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBjb25zdCBub2RlcyA9IGNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCk7XG5cbiAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBsZXQgc3RyaW5nO1xuXG4gICAgY29uc3QgcGFydHNTdHJpbmcgPSB0aGlzLnBhcnRzLnJlZHVjZSgocGFydHNTdHJpbmcsIHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRTdHJpbmcgPSBwYXJ0LmFzU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1N0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gcGFydFN0cmluZzsgLy8vXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJ0c1N0cmluZyA9IGAke3BhcnRzU3RyaW5nfSAke3BhcnRTdHJpbmd9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzU3RyaW5nO1xuICAgICAgICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICBzdHJpbmcgPSBwYXJ0c1N0cmluZzsgLy8vXG5cbiAgICBpZiAodGhpcy5wcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQQUNFX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZTtcblxuICAgICAgc3RyaW5nID0gYCR7c3RyaW5nfSAoJHtwcmVjZWRlbmNlfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnRzKENsYXNzLCBwYXJ0cykge1xuICAgIGlmIChwYXJ0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cyA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gRGVmaW5pdGlvbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IG5ldyBDbGFzcyhwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydHNBbmRQcmVjZWRlbmNlKENsYXNzLCBwYXJ0cywgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBwYXJ0czsgLy8vXG5cbiAgICAgIHBhcnRzID0gQ2xhc3M7ICAvLy9cblxuICAgICAgQ2xhc3MgPSBEZWZpbml0aW9uOyAvLy9cbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gbmV3IENsYXNzKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lLCBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZURlZmluaXRpb24oKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgcnVsZU5hbWUgPSBQQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHBhcnRCTkZOb2RlcyA9IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZUJORk5vZGUgPSBub2RlRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSksXG4gICAgICAgICAgY2FsbEFoZWFkID0gZmFsc2UsICAvLy9cbiAgICAgICAgICBwYXJ0cyA9IHBhcnRCTkZOb2Rlcy5tYXAoKHBhcnRCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydEJORk5vZGUuZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCk7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IChwcmVjZWRlbmNlQk5GTm9kZSA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlQk5GTm9kZS5nZXRQcmVjZWRlbmNlKCksXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IERlZmluaXRpb24uZnJvbVBhcnRzQW5kUHJlY2VkZW5jZShwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGVmaW5pdGlvbkJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IERFRklOSVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25zQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBERUZJTklUSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgZGVmaW5pdGlvbkJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IGRlZmluaXRpb25CTkZOb2Rlcy5tYXAoKGRlZmluaXRpb25CTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmaW5pdGlvbkJORk5vZGUuZ2VuZXJhdGVEZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGVmaW5pdGlvbnNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsUGFydEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgbm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCk7XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVGVybWluYWxQYXJ0Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgcGFyc2VQYXJ0IH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wYXJzZVwiO1xuaW1wb3J0IHsgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlIH0gZnJvbSBcIi4uLy4uL3BhcnRUeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzUGFydCBleHRlbmRzIE5vblRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNhbGxBaGVhZCwgcGFydENob2ljZXMpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuICAgIFxuICAgIHRoaXMucGFydENob2ljZXMgPSBwYXJ0Q2hvaWNlcztcbiAgfVxuICBcbiAgZ2V0UGFydENob2ljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydENob2ljZXM7XG4gIH1cblxuICBnZXRQYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFydENob2ljZXMubWFwKChwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydENob2ljZS5nZXRQYXJ0KCk7XG5cbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHNhdmVkUHJlY2VkZW5jZSA9IHN0YXRlLmdldFNhdmVkUHJlY2VkZW5jZSgpO1xuXG4gICAgcGFyc2VkID0gdGhpcy5wYXJ0Q2hvaWNlcy5zb21lKChwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICBjb25zdCBwYXJ0ID0gcGFydENob2ljZS5nZXRQYXJ0KCksXG4gICAgICAgICAgICBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHBhcnRDaG9pY2UuZ2V0UHJlY2VkZW5jZSgpLFxuICAgICAgICAgICAgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChwcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrID0gKGNhbGxBaGVhZCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgIHBhcnNlZCA9IHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICAgICAgbm9kZXMuc3BsaWNlKHN0YXJ0KTtcblxuICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUucmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRDaG9pY2VzU3RyaW5nID0gdGhpcy5wYXJ0Q2hvaWNlcy5yZWR1Y2UoKHBhcnRDaG9pY2VzU3RyaW5nLCBwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q2hvaWNlU3RyaW5nID0gcGFydENob2ljZS5hc1N0cmluZygpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHBhcnRDaG9pY2VzU3RyaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnRDaG9pY2VzU3RyaW5nID0gcGFydENob2ljZVN0cmluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnRDaG9pY2VzU3RyaW5nID0gYCR7cGFydENob2ljZXNTdHJpbmd9IHwgJHtwYXJ0Q2hvaWNlU3RyaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcGFydENob2ljZXNTdHJpbmc7XG4gICAgICAgICAgfSwgbnVsbCksXG4gICAgICAgICAgc3RyaW5nID0gYCggJHtwYXJ0Q2hvaWNlc1N0cmluZ30gKWA7XG4gICAgXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydENob2ljZXMocGFydENob2ljZXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIGNob2ljZU9mUGFydHNQYXJ0ID0gbmV3IENob2ljZU9mUGFydHNQYXJ0KHR5cGUsIGNhbGxBaGVhZCwgcGFydENob2ljZXMpO1xuXG4gICAgcmV0dXJuIGNob2ljZU9mUGFydHNQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBDaG9pY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9jaG9pY2VPZlBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlUGFydChjYWxsQWhlYWQpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcGFydENob2ljZUJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKTtcblxuICAgIGNhbGxBaGVhZCA9IGZhbHNlOyAgLy8vXG5cbiAgICBjb25zdCBwYXJ0Q2hvaWNlcyA9IHBhcnRDaG9pY2VCTkZOb2Rlcy5tYXAoKHBhcnRDaG9pY2VCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q2hvaWNlID0gcGFydENob2ljZUJORk5vZGUuZ2VuZXJhdGVQYXJ0Q2hvaWNlKGNhbGxBaGVhZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q2hvaWNlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNob2ljZU9mUGFydHNQYXJ0ID0gQ2hvaWNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRDaG9pY2VzKHBhcnRDaG9pY2VzKSxcbiAgICAgICAgICBwYXJ0ID0gY2hvaWNlT2ZQYXJ0c1BhcnQ7IC8vL1xuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENob2ljZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IHRlcm1pbmFsTm9kZSA9IG51bGw7XG4gICAgXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBuZXh0U2lnbmlmaWNhbnRUb2tlbiA9IHN0YXRlLmdldE5leHRTaWduaWZpY2FudFRva2VuKCksXG5cdFx0XHRcdFx0c2lnbmlmaWNhbnRUb2tlbiA9IG5leHRTaWduaWZpY2FudFRva2VuOyAvLy9cblxuICAgIGlmIChzaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlLmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBcbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC5yZXBsYWNlKC9cXFxcLywgXCJcXFxcXFxcXFwiKSxcbiAgICAgICAgICBzdHJpbmcgPSBgXCIke2NvbnRlbnR9XCJgO1xuICAgIFxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWxQYXJ0ID0gbmV3IFN0cmluZ0xpdGVyYWxQYXJ0KGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBFU0NBUEVEX0JBQ0tTTEFTSCwgRVNDQVBFRF9ET1VCTEVfUVVPVEUgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmluZ0xpdGVyYWxCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmVndWxhckV4cHJlc3Npb24gPSAvXlwiKCg/OlxcXFwufFteXCJcXFxcXSkqKVwiJC87XG5cbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxQYXJ0O1xuICB9XG5cbiAgZ2V0Q29udGVudCgpIHtcbiAgICBsZXQgY29udGVudDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZUNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbiksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBjb250ZW50ID0gc2Vjb25kTWF0Y2g7ICAvLy9cblxuICAgIGNvbnRlbnQgPSBzYW5pdGlzZUNvbnRlbnQoY29udGVudCk7XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU3RyaW5nTGl0ZXJhbEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGlzZUNvbnRlbnQoY29udGVudCkge1xuICBjb250ZW50ID0gY29udGVudFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgRVNDQVBFRF9CQUNLU0xBU0gpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgRVNDQVBFRF9ET1VCTEVfUVVPVEUpO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKTtcblxuICAgIGlmICghY2FsbEFoZWFkKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgICBjYWxsQWhlYWQgPSAoY2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIG5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKE5vblRlcm1pbmFsUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IHBhcnNlUGFydHMgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3BhcnNlXCI7XG5pbXBvcnQgeyBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSB9IGZyb20gXCIuLi8uLi9wYXJ0VHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VxdWVuY2VPZlBhcnRzUGFydCBleHRlbmRzIE5vblRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNhbGxBaGVhZCwgcGFydHMpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuXG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgZ2V0UGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGNhbGxiYWNrID0gKGNhbGxBaGVhZCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICgpID0+IHsgIC8vL1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuXG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRzU3RyaW5nID0gdGhpcy5wYXJ0cy5yZWR1Y2UoKHBhcnRzU3RyaW5nLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0U3RyaW5nID0gcGFydC5hc1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAocGFydHNTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFydHNTdHJpbmcgPSBwYXJ0U3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFydHNTdHJpbmcgPSBgJHtwYXJ0c1N0cmluZ30gJHtwYXJ0U3RyaW5nfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0c1N0cmluZztcbiAgICAgICAgICB9LCBudWxsKSxcbiAgICAgICAgICBzdHJpbmcgPSBgKCAke3BhcnRzU3RyaW5nfSApYDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgY29uc3QgdHlwZSA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBuZXcgU2VxdWVuY2VPZlBhcnRzUGFydCh0eXBlLCBjYWxsQWhlYWQsIHBhcnRzKTtcblxuICAgIHJldHVybiBzZXF1ZW5jZU9mUGFydHNQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBTZXF1ZW5jZU9mUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBQQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHBhcnRCTkZOb2RlcyA9IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSk7XG5cbiAgICBjYWxsQWhlYWQgPSBmYWxzZTsgIC8vL1xuXG4gICAgY29uc3QgcGFydHMgPSBwYXJ0Qk5GTm9kZXMubWFwKChwYXJ0Qk5GTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRCTkZOb2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gU2VxdWVuY2VPZlBhcnRzUGFydC5mcm9tUGFydHMocGFydHMpLFxuICAgICAgICAgIHBhcnQgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0OyAvLy9cblxuICAgIHJldHVybiBwYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTZXF1ZW5jZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgc2Vjb25kQ2hpbGROb2RlID0gc2Vjb25kKGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgb3BhY2l0eSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQ7ICAvLy9cblxuICAgIHJldHVybiBvcGFjaXR5O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPcGFjaXR5TW9kaWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5jb25zdCB7IG5vV2hpdGVzcGFjZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBub1doaXRlc3BhY2UsIC8vL1xuICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWVXaWR0aCA9IHN0cmluZ0xlbmd0aCwgLy8vXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tV2lkdGgodmVydGljYWxCcmFuY2hQYXJzZVRyZWVXaWR0aCksXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgdGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcblxuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vdGVybWluYWxcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlIGZyb20gXCIuLi8uLi9wYXJzZVRyZWUvbm9XaGl0ZXNwYWNlTm9kZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZU5vZGUgZXh0ZW5kcyBUZXJtaW5hbE5vZGUge1xuICBnZXRUeXBlKCkge1xuICAgIGNvbnN0IHR5cGUgPSBudWxsOyAgLy8vXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgY29uc3QgY29udGVudCA9IEVNUFRZX1NUUklORztcblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZU5vZGU7XG4gIH1cblxuICBhc1BhcnNlVHJlZSh0b2tlbnMpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlID0gTm9XaGl0ZXNwYWNlTm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBtYXRjaChub2RlLCBkZXB0aCkge1xuICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGUsICAvLy9cbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZU5vV2hpdGVzcGFjZU5vZGUgPSB0ZXJtaW5hbE5vZGUuaXNOb1doaXRlc3BhY2VOb2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVOb1doaXRlc3BhY2VOb2RlKSB7XG4gICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gVGVybWluYWxOb2RlLmZyb21Ob3RoaW5nKE5vV2hpdGVzcGFjZU5vZGUpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcblxuY29uc3QgeyBub1doaXRlc3BhY2UgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb1doaXRlc3BhY2VQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgaXNOb1doaXRlc3BhY2VQYXJ0KCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IG5vV2hpdGVzcGFjZU5vZGUgPSBudWxsO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBzdGF0ZS5pc05leHRUb2tlbldoaXRlc3BhY2VUb2tlbigpO1xuXG4gICAgaWYgKCFuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4pIHtcbiAgICAgIG5vV2hpdGVzcGFjZU5vZGUgPSBOb1doaXRlc3BhY2VOb2RlLmZyb21Ob3RoaW5nKCk7XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKG5vV2hpdGVzcGFjZU5vZGUgIT09IG51bGwpXG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBub2Rlcy5wdXNoKG5vV2hpdGVzcGFjZU5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IG5vV2hpdGVzcGFjZTsgLy8vXG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSBuZXcgTm9XaGl0ZXNwYWNlUGFydCgpO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSBOb1doaXRlc3BhY2VQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbGxBaGVhZE1vZGlmaWVyQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBUZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvdGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVndWxhckV4cHJlc3Npb24gPSByZWd1bGFyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGxldCB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuXHRcdFx0XHRcdHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHNpZ25pZmljYW50VG9rZW4uZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBmaXJzdChtYXRjaGVzKTtcblxuICAgICAgICBpZiAoZmlyc3RNYXRjaCA9PT0gY29udGVudCkge1xuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IFRlcm1pbmFsTm9kZS5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nID0gdGhpcy5yZWd1bGFyRXhwcmVzc2lvbi50b1N0cmluZygpLFxuXHRcdCAgICAgIHN0cmluZyA9IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nOyAvLy9cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlZ3VsYXJFeHByZXNzaW9uKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgY29uc3QgcmVndWxhckV4cHJlc3Npb25QYXJ0ID0gbmV3IFJlZ3VsYXJFeHByZXNzaW9uUGFydChyZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25QYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgUmVndWxhckV4cHJlc3Npb25QYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3JlZ3VsYXJFeHByZXNzaW9uXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJlZ3VsYXJFeHByZXNzaW9uID0gL15cXC8oKD86XFxcXC58W15cXC9dKSopXFwvJC87XG5cbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uID0gdGhpcy5nZXRSZWd1bGFyRXhwcmVzc2lvbigpLFxuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUGFydCA9IFJlZ3VsYXJFeHByZXNzaW9uUGFydC5mcm9tUmVndWxhckV4cHJlc3Npb24ocmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgcmV0dXJuIHJlZ3VsYXJFeHByZXNzaW9uUGFydDtcbiAgfVxuXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZUNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbiksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyksXG4gICAgICAgICAgcGF0dGVybiA9IHNlY29uZE1hdGNoLCAvLy9cbiAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocGF0dGVybik7ICAvLy9cblxuICAgIHJldHVybiByZWd1bGFyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuL3ZlcnRpY2FsQnJhbmNoXCI7XG5cbmNvbnN0IHsgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFydE9mQ29udGVudE5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBzdGFydE9mQ29udGVudCwgLy8vXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICBjb25zdCBzdGFydE9mQ29udGVudE5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi90ZXJtaW5hbFwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vLi4vcGFyc2VUcmVlL3N0YXJ0T2ZDb250ZW50Tm9kZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50Tm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgY29uc3QgdHlwZSA9IG51bGw7ICAvLy9cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0Q29udGVudCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpc1N0YXJ0T2ZDb250ZW50Tm9kZSgpIHtcbiAgICBjb25zdCBzdGFydE9mQ29udGVudE5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50Tm9kZTtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSA9IFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZTsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIG1hdGNoKG5vZGUsIGRlcHRoKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgICAgdGVybWluYWxOb2RlU3RhcnRPZkNvbnRlbnROb2RlID0gdGVybWluYWxOb2RlLmlzU3RhcnRPZkNvbnRlbnROb2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVTdGFydE9mQ29udGVudE5vZGUpIHtcbiAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBUZXJtaW5hbE5vZGUuZnJvbU5vdGhpbmcoU3RhcnRPZkNvbnRlbnROb2RlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50Tm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9zdGFydE9mQ29udGVudFwiO1xuXG5jb25zdCB7IHN0YXJ0T2ZDb250ZW50IH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhcnRPZkNvbnRlbnRQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgaXNTdGFydE9mQ29udGVudFBhcnQoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gdHJ1ZTtcblxuICAgIHJldHVybiBzdGFydE9mQ29udGVudFBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IHN0YXJ0T2ZDb250ZW50Tm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIGF0U3RhcnRPZkNvbnRlbnQgPSBzdGF0ZS5pc0F0U3RhcnRPZkNvbnRlbnQoKTtcblxuICAgIGlmIChhdFN0YXJ0T2ZDb250ZW50KSB7XG4gICAgICBzdGFydE9mQ29udGVudE5vZGUgPSBTdGFydE9mQ29udGVudE5vZGUuZnJvbU5vdGhpbmcoKTtcbiAgICB9XG5cbiAgICBwYXJzZWQgPSAoc3RhcnRPZkNvbnRlbnROb2RlICE9PSBudWxsKVxuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaChzdGFydE9mQ29udGVudE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHN0YXJ0T2ZDb250ZW50OyAvLy9cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gbmV3IFN0YXJ0T2ZDb250ZW50UGFydCgpO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50UGFydDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgU3RhcnRPZkNvbnRlbnRQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50UGFydEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gU3RhcnRPZkNvbnRlbnRQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTdGFydE9mQ29udGVudFBhcnRCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPbmVPck1vcmVRdWFudGlmaWVyQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoT25lT3JNb3JlUXVhbnRpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCI7XG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHNpZ25pZmljYW50VG9rZW5UeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlblR5cGU7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VuVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZTtcbiAgfVxuXG4gIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBsZXQgdGVybWluYWxOb2RlID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIG5leHRTaWduaWZpY2FudFRva2VuID0gc3RhdGUuZ2V0TmV4dFNpZ25pZmljYW50VG9rZW4oKSxcblx0XHRcdFx0XHRzaWduaWZpY2FudFRva2VuID0gbmV4dFNpZ25pZmljYW50VG9rZW47IC8vL1xuXG4gICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7XG5cbiAgICAgIGlmIChzaWduaWZpY2FudFRva2VuVHlwZSA9PT0gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZSkge1xuICAgICAgICB0ZXJtaW5hbE5vZGUgPSBUZXJtaW5hbE5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKHRlcm1pbmFsTm9kZSAhPT0gbnVsbCk7XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBub2Rlcy5wdXNoKHRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgaWYgKGNhbGxBaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gYFske3RoaXMuc2lnbmlmaWNhbnRUb2tlblR5cGV9XWA7XG4gICAgXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBuZXcgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KHNpZ25pZmljYW50VG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuY29uc3QgeyBmaXJzdCwgc2Vjb25kIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcWyhbXlxcXV0rKV0kLztcblxuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5UeXBlKCksXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0O1xuICB9XG5cbiAgZ2V0U2lnbmlmaWNhbnRUb2tlblR5cGUoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVDb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBtYXRjaGVzID0gdGVybWluYWxOb2RlQ29udGVudC5tYXRjaCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKSxcbiAgICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGU7XG5cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFplcm9yT3JNb3JlUXVhbnRpZmllckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFplcm9yT3JNb3JlUXVhbnRpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFydEJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvcGFydFwiO1xuaW1wb3J0IE5hbWVCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL25hbWVcIjtcbmltcG9ydCBSdWxlQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ydWxlXCI7XG5pbXBvcnQgRXJyb3JCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL2Vycm9yXCI7XG5pbXBvcnQgRXBzaWxvbkJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZXBzaWxvblwiO1xuaW1wb3J0IERvY3VtZW50Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9kb2N1bWVudFwiO1xuaW1wb3J0IFJ1bGVOYW1lQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ydWxlTmFtZVwiO1xuaW1wb3J0IFdpbGRjYXJkQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi93aWxkY2FyZFwiO1xuaW1wb3J0IEVuZE9mTGluZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgUGFydENob2ljZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvcGFydENob2ljZVwiO1xuaW1wb3J0IFByZWNlZGVuY2VCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3ByZWNlZGVuY2VcIjtcbmltcG9ydCBRdWFudGlmaWVyQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9xdWFudGlmaWVyXCI7XG5pbXBvcnQgRGVmaW5pdGlvbkJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZGVmaW5pdGlvblwiO1xuaW1wb3J0IERlZmluaXRpb25zQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9kZWZpbml0aW9uc1wiO1xuaW1wb3J0IFRlcm1pbmFsUGFydEJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvdGVybWluYWxQYXJ0XCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0JORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCBCb25UZXJtaW5hbFBhcnRCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL25vblRlcm1pbmFsUGFydFwiO1xuaW1wb3J0IFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvc2VxdWVuY2VPZlBhcnRzXCI7XG5pbXBvcnQgT3BhY2l0eU1vZGlmaWVyQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9vcGFjaXR5TW9kaWZpZXJcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VQYXJ0Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5pbXBvcnQgQ2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL2NhbGxBaGVhZE1vZGlmaWVyXCI7XG5pbXBvcnQgUmVndWxhckV4cHJlc3Npb25CTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uXCI7XG5pbXBvcnQgU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9zdGFydE9mQ29udGVudFBhcnRcIjtcbmltcG9ydCBPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL29wdGlvbmFsUXVhbnRpZmllclwiO1xuaW1wb3J0IE9uZU9yTW9yZVF1YW50aWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL29uZU9uZU9yTW9yZVF1YW50aWZpZXJcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcbmltcG9ydCBaZXJvT3JNb3JlUXVhbnRpZmllckJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvemVyb09uZU9yTW9yZVF1YW50aWZpZXJcIjtcblxuaW1wb3J0IHsgTkFNRV9SVUxFX05BTUUsXG4gICAgICAgICBQQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFJVTEVfUlVMRV9OQU1FLFxuICAgICAgICAgRVJST1JfUlVMRV9OQU1FLFxuICAgICAgICAgRVBTSUxPTl9SVUxFX05BTUUsXG4gICAgICAgICBET0NVTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBXSUxEQ0FSRF9SVUxFX05BTUUsXG4gICAgICAgICBSVUxFX05BTUVfUlVMRV9OQU1FLFxuICAgICAgICAgREVGSU5JVElPTl9SVUxFX05BTUUsXG4gICAgICAgICBQUkVDRURFTkNFX1JVTEVfTkFNRSxcbiAgICAgICAgIFFVQU5USUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgRU5EX09GX0xJTkVfUlVMRV9OQU1FLFxuICAgICAgICAgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgREVGSU5JVElPTlNfUlVMRV9OQU1FLFxuICAgICAgICAgVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBTVFJJTkdfTElURVJBTF9SVUxFX05BTUUsXG4gICAgICAgICBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FLFxuICAgICAgICAgT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUUsXG4gICAgICAgICBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUsXG4gICAgICAgICBOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FLFxuICAgICAgICAgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsXG4gICAgICAgICBTVEFSVF9PRl9DT05URU5UX1BBUlRfUlVMRV9OQU1FLFxuICAgICAgICAgU0lHTklGSUNBTlRfVE9LRU5fVFlQRV9SVUxFX05BTUUsXG4gICAgICAgICBPTkVfT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSxcbiAgICAgICAgIFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuXG5jb25zdCBOb25UZXJtaW5hbE5vZGVNYXAgPSB7XG4gIFtOQU1FX1JVTEVfTkFNRV06IE5hbWVCTkZOb2RlLFxuICBbUEFSVF9SVUxFX05BTUVdOiBQYXJ0Qk5GTm9kZSxcbiAgW1JVTEVfUlVMRV9OQU1FXTogUnVsZUJORk5vZGUsXG4gIFtFUlJPUl9SVUxFX05BTUVdOiBFcnJvckJORk5vZGUsXG4gIFtFUFNJTE9OX1JVTEVfTkFNRV06IEVwc2lsb25CTkZOb2RlLFxuICBbRE9DVU1FTlRfUlVMRV9OQU1FXTogRG9jdW1lbnRCTkZOb2RlLFxuICBbV0lMRENBUkRfUlVMRV9OQU1FXTogV2lsZGNhcmRCTkZOb2RlLFxuICBbUlVMRV9OQU1FX1JVTEVfTkFNRV06IFJ1bGVOYW1lQk5GTm9kZSxcbiAgW0RFRklOSVRJT05fUlVMRV9OQU1FXTogRGVmaW5pdGlvbkJORk5vZGUsXG4gIFtQUkVDRURFTkNFX1JVTEVfTkFNRV06IFByZWNlZGVuY2VCTkZOb2RlLFxuICBbUVVBTlRJRklFUl9SVUxFX05BTUVdOiBRdWFudGlmaWVyQk5GTm9kZSxcbiAgW0VORF9PRl9MSU5FX1JVTEVfTkFNRV06IEVuZE9mTGluZUJORk5vZGUsXG4gIFtQQVJUX0NIT0lDRV9SVUxFX05BTUVdOiBQYXJ0Q2hvaWNlQk5GTm9kZSxcbiAgW0RFRklOSVRJT05TX1JVTEVfTkFNRV06IERlZmluaXRpb25zQk5GTm9kZSxcbiAgW1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FXTogVGVybWluYWxQYXJ0Qk5GTm9kZSxcbiAgW1NUUklOR19MSVRFUkFMX1JVTEVfTkFNRV06IFN0cmluZ0xpdGVyYWxCTkZOb2RlLFxuICBbQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRV06IENob2ljZU9mUGFydHNCTkZOb2RlLFxuICBbT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUVdOiBPcGFjaXR5TW9kaWZpZXJCTkZOb2RlLFxuICBbTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FXTogQm9uVGVybWluYWxQYXJ0Qk5GTm9kZSxcbiAgW1NFUVVFTkNFX09GX1BBUlRTX1JVTEVfTkFNRV06IFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUsXG4gIFtOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FXTogTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsXG4gIFtSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FXTogUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLFxuICBbQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUVdOiBDYWxsQWhlYWRNb2RpZmllckJORk5vZGUsXG4gIFtPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRV06IE9wdGlvbmFsUXVhbnRpZmllckJORk5vZGUsXG4gIFtTVEFSVF9PRl9DT05URU5UX1BBUlRfUlVMRV9OQU1FXTogU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GTm9kZSxcbiAgW1NJR05JRklDQU5UX1RPS0VOX1RZUEVfUlVMRV9OQU1FXTogU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLFxuICBbT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUVdOiBPbmVPck1vcmVRdWFudGlmaWVyQk5GTm9kZSxcbiAgW1pFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRV06IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GTm9kZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9uVGVybWluYWxOb2RlTWFwOyIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcihpbmRleCwgdG9rZW5zLCBydWxlTWFwLCBwcmVjZWRlbmNlLCBzdGFydE9mQ29udGVudCwgTm9uVGVybWluYWxOb2RlTWFwLCBkZWZhdWx0Tm9uVGVybWluYWxOb2RlKSB7XG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIHRoaXMucnVsZU1hcCA9IHJ1bGVNYXA7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgICB0aGlzLnN0YXJ0T2ZDb250ZW50ID0gc3RhcnRPZkNvbnRlbnQ7XG4gICAgdGhpcy5Ob25UZXJtaW5hbE5vZGVNYXAgPSBOb25UZXJtaW5hbE5vZGVNYXA7XG4gICAgdGhpcy5kZWZhdWx0Tm9uVGVybWluYWxOb2RlID0gZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4O1xuICB9XG5cbiAgZ2V0VG9rZW5zKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIGdldFJ1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU1hcDtcbiAgfVxuXG4gIGdldFByZWNlZGVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFN0YXJ0T2ZDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZDb250ZW50O1xuICB9XG5cbiAgZ2V0Tm9uVGVybWluYWxOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLk5vblRlcm1pbmFsTm9kZU1hcDtcbiAgfVxuXG4gIGdldERlZmF1bHROb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHNldEluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgc2V0VG9rZW5zKHRva2Vucykge1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgc2V0UnVsZU1hcChydWxlTWFwKSB7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIHNldFByZWNlZGVuY2UocHJlY2VkZW5jZSkge1xuICAgIHRoaXMucHJlY2VkZW5jZSA9IHByZWNlZGVuY2U7XG4gIH1cblxuICBzZXRTdGFydE9mQ29udGVudChzdGFydE9mQ29udGVudCkge1xuICAgIHRoaXMuc3RhcnRPZkNvbnRlbnQgPSBzdGFydE9mQ29udGVudDtcbiAgfVxuXG4gIGdldFNhdmVkUHJlY2VkZW5jZSgpIHtcbiAgICBjb25zdCBzYXZlZFByZWNlZGVuY2UgPSB0aGlzLnByZWNlZGVuY2U7XG5cbiAgICByZXR1cm4gc2F2ZWRQcmVjZWRlbmNlO1xuICB9XG5cbiAgZ2V0U2F2ZWRJbmRleCgpIHtcbiAgICBjb25zdCBzYXZlZEluZGV4ID0gdGhpcy5pbmRleDsgLy8vXG4gIFxuICAgIHJldHVybiBzYXZlZEluZGV4O1xuICB9XG5cbiAgZ2V0TmV4dFRva2VuKCkge1xuICAgIGxldCBuZXh0VG9rZW4gPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgICAgIG5leHRUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXgrK107XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRUb2tlbjtcbiAgfVxuXG4gIGlzQXRTdGFydE9mQ29udGVudCgpIHtcbiAgICBjb25zdCBhdFN0YXJ0T2ZDb250ZW50ID0gdGhpcy5zdGFydE9mQ29udGVudCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pbmRleCA9PT0gMCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuXG4gICAgcmV0dXJuIGF0U3RhcnRPZkNvbnRlbnQ7XG4gIH1cblxuICBnZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpIHtcblx0XHRsZXQgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBudWxsO1xuXG4gIFx0Y29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgXHRcdGNvbnN0IHRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5pbmRleCsrXSxcblx0XHRcdFx0XHRcdHRva2VuU2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgXHRcdGlmICh0b2tlblNpZ25pZmljYW50KSB7XG4gIFx0XHQgIGNvbnN0IHNpZ25pZmljYW50VG9rZW4gPSB0b2tlbjsgLy8vXG5cblx0XHRcdFx0bmV4dFNpZ25pZmljYW50VG9rZW4gPSBzaWduaWZpY2FudFRva2VuO1x0Ly8vXG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG4gIFx0fVxuXG5cdFx0cmV0dXJuIG5leHRTaWduaWZpY2FudFRva2VuO1xuICB9XG5cbiAgaXNOZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4oKSB7XG4gICAgbGV0IG5leHRUb2tlbldoaXRlc3BhY2VUb2tlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXhdO1xuXG4gICAgICBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBuZXh0VG9rZW4uaXNXaGl0ZXNwYWNlVG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRva2VuV2hpdGVzcGFjZVRva2VuO1xuICB9XG5cblx0YmFja3RyYWNrKHNhdmVkSW5kZXgpIHtcblx0XHR0aGlzLmluZGV4ID0gc2F2ZWRJbmRleDsgIC8vL1xuXHR9XG5cbiAgcmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSkge1xuICAgIHRoaXMucHJlY2VkZW5jZSA9IHNhdmVkUHJlY2VkZW5jZTsgIC8vL1xuICB9XG5cbiAgTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gT2JqZWN0Lmhhc093bih0aGlzLk5vblRlcm1pbmFsTm9kZU1hcCwgcnVsZU5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTm9uVGVybWluYWxOb2RlTWFwW3J1bGVOYW1lXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRva2Vuc1J1bGVNYXBTdGFydE9mQ29udGVudE5vblRlcm1pbmFsTm9kZU1hcEFuZERlZmF1bHROb25UZXJtaW5hbE5vZGUodG9rZW5zLCBydWxlTWFwLCBzdGFydE9mQ29udGVudCwgTm9uVGVybWluYWxOb2RlTWFwLCBkZWZhdWx0Tm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgaW5kZXggPSAwLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuXHRcdFx0XHRcdHN0YXRlID0gbmV3IFN0YXRlKGluZGV4LCB0b2tlbnMsIHJ1bGVNYXAsIHByZWNlZGVuY2UsIHN0YXJ0T2ZDb250ZW50LCBOb25UZXJtaW5hbE5vZGVNYXAsIGRlZmF1bHROb25UZXJtaW5hbE5vZGUpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5mdW5jdGlvbiBwYXJzZSh0b2tlbnMsIHJ1bGUgPSB0aGlzLnN0YXJ0UnVsZSwgc3RhcnRPZkNvbnRlbnQgPSB0cnVlKSB7XG4gIGxldCBub2RlID0gbnVsbDtcblxuICBjb25zdCBub2RlcyA9IFtdLFxuICAgICAgICB7IE5vblRlcm1pbmFsTm9kZU1hcCwgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgc3RhdGUgPSBTdGF0ZS5mcm9tVG9rZW5zUnVsZU1hcFN0YXJ0T2ZDb250ZW50Tm9uVGVybWluYWxOb2RlTWFwQW5kRGVmYXVsdE5vblRlcm1pbmFsTm9kZSh0b2tlbnMsIHRoaXMucnVsZU1hcCwgc3RhcnRPZkNvbnRlbnQsIE5vblRlcm1pbmFsTm9kZU1hcCwgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSksXG4gICAgICAgIGNhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY2FsbEFoZWFkID0gbnVsbCxcbiAgICAgICAgcGFyc2VkID0gcnVsZS5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gIGlmIChwYXJzZWQpIHtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBmaXJzdChub2Rlcyk7XG5cbiAgICBub2RlID0gZmlyc3ROb2RlOyAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5jb25zdCBwYXJzZXJNaXhpbnMgPSB7XG4gIHBhcnNlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZXJNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5jb25zdCB7IG5hbWVUeXBlIH0gPSB0eXBlcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmFtZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gbmFtZVR5cGUsICAvLy9cbiAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBuYW1lRGVmaW5pdGlvbiA9IG5ldyBOYW1lRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gbmFtZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9uYW1lXCI7XG5cbmltcG9ydCB7IE5BTUVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZURlZmluaXRpb24gPSBOYW1lRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBOQU1FX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG5hbWVSdWxlID0gbmV3IE5hbWVCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBuYW1lUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFFVQU5USUZJRVJfUlVMRV9OQU1FLCBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUVVBTlRJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBxdWFudGlmaWVyUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFRFUk1JTkFMX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgdGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocXVhbnRpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IG5ldyBUZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gdGVybWluYWxQYXJ0UnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBaZXJvT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiO1xuXG5pbXBvcnQgeyBRVUFOVElGSUVSX1JVTEVfTkFNRSwgTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgcnVsZU5hbWUgPSBRVUFOVElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHF1YW50aWZpZXJSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocXVhbnRpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IG5ldyBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG4gICAgXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWxcIjtcbmltcG9ydCBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9wYXJ0UnVsZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBQQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBQQVJUX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uID0gVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IE5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBwYXJ0UnVsZSA9IG5ldyBQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcGFydFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmltcG9ydCB7IE5BTUVfUlVMRV9OQU1FLCBERUZJTklUSU9OU19SVUxFX05BTUUsIE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHNlcGFyYXRvciwgdGVybWluYXRvciB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBjb25zdCBzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCA9IHNlcGFyYXRvciwgLy8vXG4gICAgICAgICAgdGVybWluYXRvclN0cmluZ0xpdGVyYWxDb250ZW50ID0gdGVybWluYXRvcjsgLy8vXG5cbiAgICBydWxlTmFtZSA9IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgb3BhY2l0eU1vZGlmaWVyUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IE5BTUVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgbmFtZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsT3BhY2l0eVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KG9wYWNpdHlNb2RpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCk7XG5cbiAgICBydWxlTmFtZSA9IERFRklOSVRJT05TX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IGRlZmluaXRpb25zUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgdGVybWluYXRvclN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQodGVybWluYXRvclN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbE9wYWNpdHlSdWxlTmFtZVBhcnRQYXJ0LFxuICAgICAgICAgICAgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICAgICAgICBkZWZpbml0aW9uc1J1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIHRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgcnVsZURlZmluaXRpb24gPSBuZXcgUnVsZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHJ1bGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcnVsZVwiO1xuXG5pbXBvcnQgeyBSVUxFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHJ1bGVEZWZpbml0aW9uID0gUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gUlVMRV9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlUnVsZSA9IG5ldyBSdWxlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZVJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBXaWxkY2FyZFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCB3aWxkY2FyZFBhcnQgPSBXaWxkY2FyZFBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHdpbGRjYXJkUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgZXJyb3JEZWZpbml0aW9uID0gbmV3IEVycm9yRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZXJyb3JEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IEVycm9yRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9lcnJvclwiO1xuXG5pbXBvcnQgeyBFUlJPUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgb3BhcXVlIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlcnJvckRlZmluaXRpb24gPSBFcnJvckRlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gRVJST1JfUlVMRV9OQU1FLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gb3BhcXVlLCAvLy9cbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVycm9yRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXJyb3JSdWxlID0gbmV3IEVycm9yQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZXJyb3JSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbERlZmluaXRpb24gPSBuZXcgU3RyaW5nTGl0ZXJhbERlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3N0cmluZ0xpdGVyYWxcIjtcblxuaW1wb3J0IHsgRVBTSUxPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25CTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZXBzaWxvbiwgLy8vXG4gICAgICAgICAgZXBzaWxvblN0cmluZ0xpdGVyYWxEZWZpbml0aW9uID0gU3RyaW5nTGl0ZXJhbERlZmluaXRpb24uZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgbmFtZSA9IEVQU0lMT05fUlVMRV9OQU1FLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVwc2lsb25TdHJpbmdMaXRlcmFsRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXBzaWxvblJ1bGUgPSBuZXcgRXBzaWxvbkJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUGFydENob2ljZSBmcm9tIFwiLi4vcGFydENob2ljZVwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IENob2ljZU9mUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL2Nob2ljZU9mUGFydHNcIjtcbmltcG9ydCBPbmVPck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIjtcblxuaW1wb3J0IHsgUlVMRV9SVUxFX05BTUUsIEVSUk9SX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBydWxlTmFtZSA9IFJVTEVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcnVsZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBFUlJPUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBlcnJvclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHJ1bGVSdWxlTmFtZVBhcnRDaG9pY2UgPSBQYXJ0Q2hvaWNlLmZyb21QYXJ0KHJ1bGVSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIGVycm9yUnVsZU5hbWVQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChlcnJvclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydENob2ljZXMgPSBbXG4gICAgICAgICAgICBydWxlUnVsZU5hbWVQYXJ0Q2hvaWNlLFxuICAgICAgICAgICAgZXJyb3JSdWxlTmFtZVBhcnRDaG9pY2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZU9mUnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzUGFydCA9IENob2ljZU9mUGFydHNQYXJ0LmZyb21QYXJ0Q2hvaWNlcyhwYXJ0Q2hvaWNlcyksXG4gICAgICAgICAgb25lT3JNb3JlQ2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0c1BhcnQgPSBPbmVPck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQoY2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9uZU9yTW9yZUNob2ljZU9mUnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkb2N1bWVudERlZmluaXRpb24gPSBuZXcgRG9jdW1lbnREZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkb2N1bWVudERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEb2N1bWVudERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZG9jdW1lbnRcIjtcblxuaW1wb3J0IHsgRE9DVU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGRvY3VtZW50RGVmaW5pdGlvbiA9IERvY3VtZW50RGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBET0NVTUVOVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGRvY3VtZW50RGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZG9jdW1lbnRSdWxlID0gbmV3IERvY3VtZW50Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZG9jdW1lbnRSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgTmFtZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vbmFtZVwiO1xuXG5pbXBvcnQgeyBSVUxFX05BTUVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWVEZWZpbml0aW9uID0gTmFtZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gUlVMRV9OQU1FX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb24gIC8vL1xuICAgICAgICAgIF0sXG4gICAgICAgICAgcnVsZU5hbWVSdWxlID0gbmV3IFJ1bGVOYW1lQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3N0cmluZ0xpdGVyYWxcIjtcblxuaW1wb3J0IHsgV0lMRENBUkRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHdpbGRjYXJkIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lsZGNhcmRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gd2lsZGNhcmQsIC8vL1xuICAgICAgICAgIHdpbGRjYXJkU3RyaW5nTGl0ZXJhbERlZmluaXRpb24gPSBTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbi5mcm9tQ29udGVudChjb250ZW50KSxcbiAgICAgICAgICBuYW1lID0gV0lMRENBUkRfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICB3aWxkY2FyZFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICB3aWxkY2FyZFJ1bGUgPSBuZXcgV2lsZGNhcmRCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiB3aWxkY2FyZFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBFTkRfT0ZfTElORV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZW5kT2ZMaW5lIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgY29udGVudCA9IGVuZE9mTGluZSxcbiAgICAgICAgICBlbmRPZkxpbmVTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbiA9IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uLmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIG5hbWUgPSBFTkRfT0ZfTElORV9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZW5kT2ZMaW5lU3RyaW5nTGl0ZXJhbERlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGVuZE9mTGluZVJ1bGUgPSBuZXcgRW5kT2ZMaW5lQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydENob2ljZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KHByZWNlZGVuY2VSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uID0gbmV3IFBhcnRDaG9pY2VEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJ0Q2hvaWNlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFBhcnRDaG9pY2VEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3BhcnRDaG9pY2VcIjtcblxuaW1wb3J0IHsgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0Q2hvaWNlQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uID0gUGFydENob2ljZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZpbml0aW9uUnVsZSA9IG5ldyBQYXJ0Q2hvaWNlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvblJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICBjb25zdCBydWxlTmFtZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBSdWxlTmFtZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHJ1bGVOYW1lRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFJ1bGVOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ydWxlTmFtZVwiO1xuXG5pbXBvcnQgeyBRVUFOVElGSUVSX1JVTEVfTkFNRSwgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG4gICAgY29uc3QgbmFtZSA9IFFVQU5USUZJRVJfUlVMRV9OQU1FOyAgLy8vXG5cbiAgICBydWxlTmFtZSA9IE9QVElPTkFMX1FVQU5USUZJRVJfUlVMRV9OQU1FXG5cbiAgICBjb25zdCBvcHRpb25hbFF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBvcHRpb25hbFF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHF1YW50aWZpZXJSdWxlID0gbmV3IFF1YW50aWZpZXJCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBxdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkRlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9uZU9yTW9yZVJ1bGVOYW1lUGFydHNQYXJ0ID0gT25lT3JNb3JlUGFydHNQYXJ0LmZyb21QYXJ0KHBhcnRSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KHByZWNlZGVuY2VSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgb25lT3JNb3JlUnVsZU5hbWVQYXJ0c1BhcnQsXG4gICAgICAgICAgICBvcHRpb25hbFByZWNlZGVuY2VSdWxlTmFtZVBhcnRQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9uRGVmaW5pdGlvbiA9IG5ldyBEZWZpbml0aW9uRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbkRlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEZWZpbml0aW9uRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9kZWZpbml0aW9uXCI7XG5cbmltcG9ydCB7IERFRklOSVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IERFRklOSVRJT05fUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgZGVmaW5pdGlvbkRlZmluaXRpb24gPSBEZWZpbml0aW9uRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvbkRlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlZmluaXRpb25SdWxlID0gbmV3IERlZmluaXRpb25CTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB0eXBlcywgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmNvbnN0IHsgbnVtYmVyVHlwZSB9ID0gdHlwZXMsXG4gICAgICB7IG9wZW5CcmFja2V0LCBjbG9zZUJyYWNrZXQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVjZWRlbmNlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBudW1iZXJUeXBlLCAgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQpLFxuICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQpLFxuICAgICAgICAgIG51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydCA9IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydC5mcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpLFxuICAgICAgICAgIG9wdGlvbmFsTnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQobnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbE51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydFBhcnQsXG4gICAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgcHJlY2VkZW5jZURlZmluaXRpb24gPSBuZXcgUHJlY2VkZW5jZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHByZWNlZGVuY2VEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUHJlY2VkZW5jZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcHJlY2VkZW5jZVwiO1xuXG5pbXBvcnQgeyBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlY2VkZW5jZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBQUkVDRURFTkNFX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHByZWNlZGVuY2VEZWZpbml0aW9uID0gUHJlY2VkZW5jZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHByZWNlZGVuY2VEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlUnVsZSA9IG5ldyBQcmVjZWRlbmNlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcHJlY2VkZW5jZVJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIjtcblxuaW1wb3J0IHsgREVGSU5JVElPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgdmVydGljYWxCYXIgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uc0RlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBwYXJ0cztcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lID0gREVGSU5JVElPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZGVmaW5pdGlvblJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KTtcblxuICAgIHBhcnRzID0gW1xuICAgICAgdmVydGljYWxCYXJTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgIGRlZmluaXRpb25SdWxlTmFtZVBhcnRcbiAgICBdO1xuXG4gICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRzKHBhcnRzKSxcbiAgICAgICAgICB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQoc2VxdWVuY2VPZlBhcnRzUGFydCk7XG5cbiAgICBwYXJ0cyA9IFtcbiAgICAgIGRlZmluaXRpb25SdWxlTmFtZVBhcnQsXG4gICAgICB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydFxuICAgIF07XG5cbiAgICBjb25zdCBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9uc0RlZmluaXRpb24gPSBuZXcgRGVmaW5pdGlvbnNEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uc0RlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEZWZpbml0aW9uc0RlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZGVmaW5pdGlvbnNcIjtcblxuaW1wb3J0IHsgREVGSU5JVElPTlNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uc0JORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGRlZmluaXRpb25zRGVmaW5pdGlvbiA9IERlZmluaXRpb25zRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBERUZJTklUSU9OU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvbnNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZpbml0aW9uc1J1bGUgPSBuZXcgRGVmaW5pdGlvbnNCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uc1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBSdWxlTmFtZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcnVsZU5hbWVcIjtcblxuaW1wb3J0IHsgRVBTSUxPTl9SVUxFX05BTUUsXG4gICAgICAgICBXSUxEQ0FSRF9SVUxFX05BTUUsXG4gICAgICAgICBFTkRfT0ZfTElORV9SVUxFX05BTUUsXG4gICAgICAgICBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFNUUklOR19MSVRFUkFMX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFNJR05JRklDQU5UX1RPS0VOX1RZUEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtaW5hbFBhcnRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBjb25zdCBuYW1lID0gVEVSTUlOQUxfUEFSVF9SVUxFX05BTUU7XG5cbiAgICBydWxlTmFtZSA9IEVQU0lMT05fUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgZXBzaWxvblJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBXSUxEQ0FSRF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCB3aWxkY2FyZFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBFTkRfT0ZfTElORV9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBlbmRPZkxpbmVSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgc3RyaW5nTGl0ZXJhbFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgbm9XaGl0ZXNwYWNlUGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcmVndWxhckV4cHJlc3Npb25SdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGVuZE9mTGluZVJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHdpbGRjYXJkUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgZXBzaWxvblJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnRSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGUgPSBuZXcgVGVybWluYWxQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIjtcblxuaW1wb3J0IHsgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHZlcnRpY2FsQmFyLCBvcGVuQnJhY2tldCwgY2xvc2VCcmFja2V0IH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBwYXJ0cztcblxuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSVF9DSE9JQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbENvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgcGFydENob2ljZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudCh2ZXJ0aWNhbEJhclN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQob3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCksXG4gICAgICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCk7XG5cbiAgICBwYXJ0cyA9IFtcbiAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICBwYXJ0Q2hvaWNlUnVsZU5hbWVQYXJ0XG4gICAgXTtcblxuICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBTZXF1ZW5jZU9mUGFydHNQYXJ0LmZyb21QYXJ0cyhwYXJ0cyksXG4gICAgICAgICAgb25lT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IE9uZU9yTW9yZVBhcnRzUGFydC5mcm9tUGFydChzZXF1ZW5jZU9mUGFydHNQYXJ0KTtcblxuICAgIHBhcnRzID0gW1xuICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgIHBhcnRDaG9pY2VSdWxlTmFtZVBhcnQsXG4gICAgICBvbmVPck1vcmVTZXF1ZW5jZU9mUGFydHNQYXJ0LFxuICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnRcbiAgICBdO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgY2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gPSBuZXcgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIGNob2ljZU9mUGFydHNEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vY2hvaWNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IENIT0lDRV9PRl9QQVJUU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIGNob2ljZU9mUGFydHNEZWZpbml0aW9uID0gQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNob2ljZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjaG9pY2VPZlBhcnRzUnVsZSA9IG5ldyBDaG9pY2VPZlBhcnRzQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gY2hvaWNlT2ZQYXJ0c1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQuZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uID0gbmV3IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5pbXBvcnQgeyBTVFJJTkdfTElURVJBTF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgc3RyaW5nTGl0ZXJhbFR5cGUgfSA9IHR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBzdHJpbmdMaXRlcmFsVHlwZSwgIC8vL1xuICAgICAgICAgIHN0cmluZ0xpdGVyYWxTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzdHJpbmdMaXRlcmFsU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUnVsZSA9IG5ldyBTdHJpbmdMaXRlcmFsQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uLy4uLy4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uLy4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBPcHRpb25hbFBhcnRQYXJ0IGZyb20gXCIuLi8uLi8uLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuXG5pbXBvcnQgeyBSVUxFX05BTUVfUlVMRV9OQU1FLCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgcnVsZU5hbWUgPSBSVUxFX05BTUVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcnVsZU5hbWVSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBjYWxsQWhlYWRNb2RpZmllclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsQ2FsbEFoZWFkUnVsZU5hbWVQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQoY2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbENhbGxBaGVhZFJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSBuZXcgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFJ1bGVOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ydWxlTmFtZVwiO1xuaW1wb3J0IFJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcblxuaW1wb3J0IHsgQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRSwgU0VRVUVOQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FLCBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vblRlcm1pbmFsUGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIGNvbnN0IG5hbWUgPSBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUU7IC8vL1xuXG4gICAgcnVsZU5hbWUgPSBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUU7XG5cbiAgICBjb25zdCBzZXF1ZW5jZU9mUGFydHNSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICBydWxlTmFtZU5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uID0gUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG5vblRlcm1pbmFsUGFydFJ1bGUgPSBuZXcgTm9uVGVybWluYWxQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IG9wZW5CcmFja2V0LCBjbG9zZUJyYWNrZXQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUlRfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBvbmVPck1vcmVQYXJ0UnVsZU5hbWVQYXJ0c1BhcnQgPSBPbmVPck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocGFydFJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0LFxuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIG9uZU9yTW9yZVBhcnRSdWxlTmFtZVBhcnRzUGFydCxcbiAgICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24gPSBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNSdWxlID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNlcXVlbmNlT2ZQYXJ0c1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUGFydENob2ljZSBmcm9tIFwiLi4vcGFydENob2ljZVwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3N0cmluZ0xpdGVyYWxcIjtcblxuY29uc3QgeyBvcGFxdWUsIHNlbWlPcGFxdWUgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG5cbiAgICBjb250ZW50ID0gb3BhcXVlOyAvLy9cblxuICAgIGNvbnN0IG9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCk7XG5cbiAgICBjb250ZW50ID0gc2VtaU9wYXF1ZTsgLy8vXG5cbiAgICBjb25zdCBzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KTtcblxuICAgIGNvbnN0IG9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChvcGFxdWVTdHJpbmdMaXRlcmFsUGFydCksXG4gICAgICAgICAgc2VtaU9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnQpLFxuICAgICAgICAgIHBhcnRDaG9pY2VzID0gW1xuICAgICAgICAgICAgb3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnRDaG9pY2UsXG4gICAgICAgICAgICBzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnRDaG9pY2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZU9mT3BhcXVlU3RyaW5nTGl0ZXJhbEFuZFNlbWlPcGFxdWVTdHJpbmdMaXRlcmFsUGFydHNQYXJ0ID0gQ2hvaWNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRDaG9pY2VzKHBhcnRDaG9pY2VzKSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0ID0gTm9XaGl0ZXNwYWNlUGFydC5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCxcbiAgICAgICAgICAgIGNob2ljZU9mT3BhcXVlU3RyaW5nTGl0ZXJhbEFuZFNlbWlPcGFxdWVTdHJpbmdMaXRlcmFsUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gb3BhY2l0eU1vZGlmaWVyUnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9vcGFjaXR5TW9kaWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHlNb2RpZmllclJ1bGVEZWZpbml0aW9uID0gT3BhY2l0eU1vZGlmaWVyUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG9wYWNpdHlNb2RpZmllclJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJSdWxlID0gbmV3IE9wYWNpdHlNb2RpZmllckJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIG9wYWNpdHlNb2RpZmllclJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5jb25zdCB7IG5vV2hpdGVzcGFjZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gbm9XaGl0ZXNwYWNlLCAgLy8vXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiA9IG5ldyBOb1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5cbmltcG9ydCB7IE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiA9IE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgbmFtZSA9IE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0UnVsZSA9IG5ldyBOb1doaXRlc3BhY2VQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmNvbnN0IHsgZWxsaXBzaXMgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsQWhlYWRNb2RpZmllclJ1bGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZWxsaXBzaXMsICAvLy9cbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0ID0gTm9XaGl0ZXNwYWNlUGFydC5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0LFxuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gPSBuZXcgQ2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gY2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IENhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vY2FsbEFoZWFkTW9kaWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsQWhlYWRNb2RpZmllckJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSwgLy8vXG4gICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IENhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZSA9IG5ldyBDYWxsQWhlYWRNb2RpZmllckJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGNhbGxBaGVhZE1vZGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuaW1wb3J0IHsgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyByZWd1bGFyRXhwcmVzc2lvblR5cGUgfSA9IHR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWd1bGFyRXhwcmVzc2lvbkJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gcmVndWxhckV4cHJlc3Npb25UeXBlLCAgLy8vXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25TaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSwgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvblNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25SdWxlID0gbmV3IFJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVNwZWNpYWxTeW1ib2woc3BlY2lhbFN5bWJvbCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzcGVjaWFsU3ltYm9sLCAgLy8vXG4gICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCA9IE5vV2hpdGVzcGFjZVBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCxcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBxdWFudGlmaWVyUnVsZURlZmluaXRpb24gPSBuZXcgUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBxdWFudGlmaWVyUnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3F1YW50aWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IE9QVElPTkFMX1FVQU5USUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHF1ZXN0aW9uTWFyayB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbmFsUXVhbnRpZmllckJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHNwZWNpYWxTeW1ib2wgPSBxdWVzdGlvbk1hcmssIC8vL1xuICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uLmZyb21TcGVjaWFsU3ltYm9sKHNwZWNpYWxTeW1ib2wpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGUgPSBuZXcgT3B0aW9uYWxRdWFudGlmaWVyQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gb3B0aW9uYWxRdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmNvbnN0IHsgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFydE9mQ29udGVudFBhcnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gc3RhcnRPZkNvbnRlbnQsICAvLy9cbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gPSBuZXcgU3RhcnRPZkNvbnRlbnRQYXJ0RGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0RGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc3RhcnRPZkNvbnRlbnRQYXJ0XCI7XG5cbmltcG9ydCB7IFNUQVJUX09GX0NPTlRFTlRfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50UGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gPSBTdGFydE9mQ29udGVudFBhcnREZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgbmFtZSA9IFNUQVJUX09GX0NPTlRFTlRfUEFSVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydFJ1bGUgPSBuZXcgU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIjtcblxuaW1wb3J0IHsgT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgcGx1cyB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIHNwZWNpYWxTeW1ib2wgPSBwbHVzLCAvLy9cbiAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb24gPSBRdWFudGlmaWVyUnVsZURlZmluaXRpb24uZnJvbVNwZWNpYWxTeW1ib2woc3BlY2lhbFN5bWJvbCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IE9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBvbmVPck1vcmVRdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIjtcblxuaW1wb3J0IHsgWkVST19PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IGFzdGVyaXNrIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWmVyb09yTW9yZVF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gWkVST19PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgc3BlY2lhbFN5bWJvbCA9IGFzdGVyaXNrLCAvLy9cbiAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uLmZyb21TcGVjaWFsU3ltYm9sKHNwZWNpYWxTeW1ib2wpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gemVyb09yTW9yZVF1YW50aWZpZXJSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5pbXBvcnQgeyBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyB0eXBlVHlwZSB9ID0gdHlwZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW5UeXBlQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0eXBlVHlwZSwgIC8vL1xuICAgICAgICAgIHR5cGVTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gU0lHTklGSUNBTlRfVE9LRU5fVFlQRV9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHR5cGVTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSA9IG5ldyBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCwgcHJ1bmUgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0FzU3RyaW5nKHJ1bGVzLCBtdWx0aUxpbmUpIHtcbiAgY29uc3QgbWF4aW11bVJ1bGVOYW1lTGVuZ3RoID0gcnVsZXMucmVkdWNlKChtYXhpbXVtUnVsZU5hbWVMZW5ndGgsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpO1xuXG4gICAgICAgIGxldCBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aDtcblxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG9wYWNpdHlMZW5ndGggPSBvcGFjaXR5Lmxlbmd0aDtcblxuICAgICAgICAgIHJ1bGVOYW1lTGVuZ3RoICs9IG9wYWNpdHlMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBtYXhpbXVtUnVsZU5hbWVMZW5ndGggPSBNYXRoLm1heChtYXhpbXVtUnVsZU5hbWVMZW5ndGgsIHJ1bGVOYW1lTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gbWF4aW11bVJ1bGVOYW1lTGVuZ3RoO1xuICAgICAgfSwgMCksXG4gICAgICBydWxlc1N0cmluZyA9IHJ1bGVzLnJlZHVjZSgocnVsZXNTdHJpbmcsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcnVsZVN0cmluZyA9IHJ1bGUuYXNTdHJpbmcobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBtdWx0aUxpbmUpO1xuXG4gICAgICAgIHJ1bGVzU3RyaW5nICs9IHJ1bGVTdHJpbmc7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzU3RyaW5nO1xuICAgICAgfSwgRU1QVFlfU1RSSU5HKS5yZXBsYWNlKC9eXFxuXFxuLywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcnVsZXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSB7XG4gIGNvbnN0IHJ1bGVNYXAgPSB7fTtcblxuICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKTtcblxuICAgIHJ1bGVNYXBbcnVsZU5hbWVdID0gcnVsZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVNYXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpIHtcbiAgY29uc3QgZmlyc3RSdWxlID0gZmlyc3QocnVsZXMpLFxuICAgICAgICBzdGFydFJ1bGUgPSBmaXJzdFJ1bGU7ICAvLy9cblxuICByZXR1cm4gc3RhcnRSdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcChzdGFydFJ1bGUsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZXMgPSBPYmplY3QudmFsdWVzKHJ1bGVNYXApLFxuICAgICAgICBzdGFydFJ1bGVOYW1lID0gc3RhcnRSdWxlLmdldE5hbWUoKTtcblxuICBzdGFydFJ1bGUgPSBwcnVuZShydWxlcywgKHJ1bGUpID0+IHsgIC8vL1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBpZiAocnVsZU5hbWUgIT09IHN0YXJ0UnVsZU5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZXMudW5zaGlmdChzdGFydFJ1bGUpO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUocnVsZXMsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgbGV0IHN0YXJ0UnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHtcbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgaWYgKHJ1bGVOYW1lID09PSBzdGFydFJ1bGVOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIHx8IG51bGw7IC8vL1xuXG4gIGlmIChzdGFydFJ1bGUgPT09IG51bGwpIHtcbiAgICBzdGFydFJ1bGUgPSBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0UnVsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0FzU3RyaW5nLFxuICBydWxlTWFwRnJvbVJ1bGVzLFxuICBzdGFydFJ1bGVGcm9tUnVsZXMsXG4gIHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAsXG4gIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vcnVsZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZU1hcCBmcm9tIFwiLi4vbm9uVGVybWluYWxOb2RlTWFwXCI7XG5pbXBvcnQgcGFyc2VyTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvcGFyc2VyXCI7XG5pbXBvcnQgTmFtZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL25hbWVcIjtcbmltcG9ydCBQYXJ0Qk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcGFydFwiO1xuaW1wb3J0IFJ1bGVCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9ydWxlXCI7XG5pbXBvcnQgRXJyb3JCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9lcnJvclwiO1xuaW1wb3J0IEVwc2lsb25CTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9lcHNpbG9uXCI7XG5pbXBvcnQgRG9jdW1lbnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9kb2N1bWVudFwiO1xuaW1wb3J0IFJ1bGVOYW1lQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcnVsZU5hbWVcIjtcbmltcG9ydCBXaWxkY2FyZEJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3dpbGRjYXJkXCI7XG5pbXBvcnQgRW5kT2ZMaW5lQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgUGFydENob2ljZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3BhcnRDaG9pY2VcIjtcbmltcG9ydCBRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcXVhbnRpZmllclwiO1xuaW1wb3J0IERlZmluaXRpb25CTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUHJlY2VkZW50c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3ByZWNlZGVuY2VcIjtcbmltcG9ydCBEZWZpbml0aW9uc0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL2RlZmluaXRpb25zXCI7XG5pbXBvcnQgVGVybWluYWxQYXJ0Qk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvdGVybWluYWxQYXJ0XCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL2Nob2ljZU9mUGFydHNcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IE5vblRlcm1pbmFsUGFydEJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL25vblRlcm1pbmFsUGFydFwiO1xuaW1wb3J0IFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuaW1wb3J0IE9wYWNpdHlNb2RpZmllckJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL29wYWNpdHlNb2RpZmllclwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5pbXBvcnQgQ2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9jYWxsQWhlYWRNb2RpZmllclwiO1xuaW1wb3J0IFJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcmVndWxhckV4cHJlc3Npb25cIjtcbmltcG9ydCBPcHRpb25hbFF1YW50aWZpZXJCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9vcHRpb25hbFF1YW50aWZpZXJcIjtcbmltcG9ydCBTdGFydE9mQ29udGVudFBhcnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9zdGFydE9mQ29udGVudFBhcnRcIjtcbmltcG9ydCBPbmVPck1vcmVRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvb25lT3JNb3JlUXVhbnRpZmllclwiO1xuaW1wb3J0IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvemVyb09yTW9yZVF1YW50aWZpZXJcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmltcG9ydCB7IHJ1bGVNYXBGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQk5GUGFyc2VyIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIGdldFN0YXJ0UnVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gIH1cblxuICBnZXRSdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gIH1cblxuXHRydWxlc0Zyb21Ub2tlbnModG9rZW5zKSB7XG5cdCAgbGV0IHJ1bGVzO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2UodG9rZW5zKTtcblxuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUuYCk7XG4gICAgfVxuXG4gICAgcnVsZXMgPSBub2RlLmdlbmVyYXRlUnVsZXMoUnVsZSk7XG5cbiAgICBjb25zdCBydWxlc0xlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcblxuICAgIGlmIChydWxlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBhcmUgbm8gcnVsZXMuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgc3RhdGljIE5vblRlcm1pbmFsTm9kZU1hcCA9IE5vblRlcm1pbmFsTm9kZU1hcDtcblxuICBzdGF0aWMgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSA9IG51bGw7XG5cbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZUJORlJ1bGUgPSBOYW1lQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnRCTkZSdWxlID0gUGFydEJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBydWxlQk5GUnVsZSA9IFJ1bGVCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgZXJyb3JCTkZSdWxlID0gRXJyb3JCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgZXBzaWxvbkJORlJ1bGUgPSBFcHNpbG9uQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGRvY3VtZW50Qk5GUnVsZSA9IERvY3VtZW50Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHJ1bGVOYW1lQk5GUnVsZSA9IFJ1bGVOYW1lQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHdpbGRjYXJkQk5GUnVsZSA9IFdpbGRjYXJkQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGVuZE9mTGluZUJORlJ1bGUgPSBFbmRPZkxpbmVCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFydENob2ljZUJORlJ1bGUgPSBQYXJ0Q2hvaWNlQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHF1YW50aWZpZXJCTkZSdWxlID0gUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBkZWZpbml0aW9uQk5GUnVsZSA9IERlZmluaXRpb25CTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcHJlY2VkZW50c0JORlJ1bGUgPSBQcmVjZWRlbnRzQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGRlZmluaXRpb25zQk5GUnVsZSA9IERlZmluaXRpb25zQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHRlcm1pbmFsUGFydEJORlJ1bGUgPSBUZXJtaW5hbFBhcnRCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgY2hvaWNlT2ZQYXJ0c0JORlJ1bGUgPSBDaG9pY2VPZlBhcnRzQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZ0xpdGVyYWxCTkZSdWxlID0gU3RyaW5nTGl0ZXJhbEJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRCTkZSdWxlID0gTm9uVGVybWluYWxQYXJ0Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgPSBTZXF1ZW5jZU9mUGFydHNCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eU1vZGlmaWVyQk5GUnVsZSA9IE9wYWNpdHlNb2RpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0Qk5GUnVsZSA9IE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25CTkZSdWxlID0gUmVndWxhckV4cHJlc3Npb25CTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlID0gQ2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyQk5GUnVsZSA9IE9wdGlvbmFsUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRCTkZSdWxlID0gU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlID0gT25lT3JNb3JlUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUgPSBaZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBydWxlcyA9IFtcbiAgICAgICAgICAgIGRvY3VtZW50Qk5GUnVsZSxcbiAgICAgICAgICAgIHJ1bGVCTkZSdWxlLFxuICAgICAgICAgICAgbmFtZUJORlJ1bGUsXG4gICAgICAgICAgICBkZWZpbml0aW9uc0JORlJ1bGUsXG4gICAgICAgICAgICBkZWZpbml0aW9uQk5GUnVsZSxcbiAgICAgICAgICAgIHBhcnRCTkZSdWxlLFxuICAgICAgICAgICAgbm9uVGVybWluYWxQYXJ0Qk5GUnVsZSxcbiAgICAgICAgICAgIHRlcm1pbmFsUGFydEJORlJ1bGUsXG4gICAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRCTkZSdWxlLFxuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydEJORlJ1bGUsXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNCTkZSdWxlLFxuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c0JORlJ1bGUsXG4gICAgICAgICAgICBwYXJ0Q2hvaWNlQk5GUnVsZSxcbiAgICAgICAgICAgIHJ1bGVOYW1lQk5GUnVsZSxcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlQk5GUnVsZSxcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZSxcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxCTkZSdWxlLFxuICAgICAgICAgICAgcHJlY2VkZW50c0JORlJ1bGUsXG4gICAgICAgICAgICBlbmRPZkxpbmVCTkZSdWxlLFxuICAgICAgICAgICAgd2lsZGNhcmRCTkZSdWxlLFxuICAgICAgICAgICAgZXBzaWxvbkJORlJ1bGUsXG4gICAgICAgICAgICBxdWFudGlmaWVyQk5GUnVsZSxcbiAgICAgICAgICAgIG9wYWNpdHlNb2RpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBjYWxsQWhlYWRNb2RpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBvcHRpb25hbFF1YW50aWZpZXJCTkZSdWxlLFxuICAgICAgICAgICAgb25lT3JNb3JlUXVhbnRpZmllckJORlJ1bGUsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBlcnJvckJORlJ1bGVcbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXJ0UnVsZSA9IHN0YXJ0UnVsZUZyb21SdWxlcyhydWxlcyksXG4gICAgICAgICAgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICAgIGJuZlBhcnNlciA9IG5ldyBCTkZQYXJzZXIoc3RhcnRSdWxlLCBydWxlTWFwKTtcbiAgICBcbiAgICByZXR1cm4gYm5mUGFyc2VyO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oQk5GUGFyc2VyLnByb3RvdHlwZSwgcGFyc2VyTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYFxuXG4gICAgZXhwcmVzc2lvbnMgIDo6PSAgZXhwcmVzc2lvbisgO1xuXG4gICAgZXhwcmVzc2lvbiAgIDo6PSAgdGVybS4uLiBcIi5cIiA7XG4gICAgXG4gICAgdGVybSAgICAgICAgIDo6PSAgdGVybV8gdGVybX4qIDtcbiAgICBcbiAgICBvcGVyYXRvciAgICAgOjo9ICBcIitcIlxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFwiLVwiXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgXCIqXCJcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gICAgXG4gICAgbnVtYmVyICAgICAgIDo6PSAgL1xcXFxkKy8gO1xuICAgIFxuICAgIHRlcm1fICAgICAgICA6Oj0gIFwiKFwiIHRlcm0gXCIpXCJcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBudW1iZXJcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gICAgXG4gICAgdGVybX50ZXJtICAgIDo6PSAgb3BlcmF0b3IgdGVybSA7XG4gICAgXG4gICAgdGVybX4gICAgICAgIDo6PSAgdGVybX50ZXJtIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBCTkZMZXhlciB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IEJORlBhcnNlciBmcm9tIFwiLi4vYm5mL3BhcnNlclwiO1xuXG5pbXBvcnQgeyBydWxlTWFwRnJvbVJ1bGVzLCBzdGFydFJ1bGVGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVzXCI7XG5cbmNvbnN0IGJuZkxleGVyID0gQk5GTGV4ZXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgIGJuZlBhcnNlciA9IEJORlBhcnNlci5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGcm9tQk5GKGJuZikge1xuICBjb25zdCB0b2tlbnMgPSBibmZMZXhlci50b2tlbnNGcm9tQk5GKGJuZiksXG4gICAgICAgIHJ1bGVzID0gYm5mUGFyc2VyLnJ1bGVzRnJvbVRva2Vucyh0b2tlbnMpO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcbiAgY29uc3Qgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzKHJ1bGVzKSxcbiAgICAgICAgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBwYXJzZXIgPSBuZXcgQ2xhc3Moc3RhcnRSdWxlLCBydWxlTWFwKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgY29uc3Qgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShydWxlcywgc3RhcnRSdWxlTmFtZSksXG4gICAgICAgIHJ1bGVNYXAgPSBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSxcbiAgICAgICAgcGFyc2VyID0gbmV3IENsYXNzKHN0YXJ0UnVsZSwgcnVsZU1hcCk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0Zyb21CTkYsXG4gIHBhcnNlckZyb21SdWxlcyxcbiAgcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHBhcnNlck1peGlucyBmcm9tIFwiLi4vbWl4aW5zL3BhcnNlclwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IHJ1bGVzRnJvbUJORiwgcGFyc2VyRnJvbVJ1bGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJzZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tbW9uUGFyc2VyIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIGdldFN0YXJ0UnVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gIH1cblxuICBnZXRSdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gIH1cblxuICBzdGF0aWMgTm9uVGVybWluYWxOb2RlTWFwID0ge307XG5cbiAgc3RhdGljIGRlZmF1bHROb25UZXJtaW5hbE5vZGUgPSBOb25UZXJtaW5hbE5vZGU7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKENsYXNzKSB7XG4gICAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZiksXG4gICAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgc3RhdGljIGZyb21CTkYoQ2xhc3MsIGJuZikge1xuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZiksXG4gICAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICAgIHJldHVybiBwYXJzZXI7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihDb21tb25QYXJzZXIucHJvdG90eXBlLCBwYXJzZXJNaXhpbnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuaW1wb3J0IENvbW1vblBhcnNlciBmcm9tIFwiLi4vY29tbW9uL3BhcnNlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEJhc2ljUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoQmFzaWNQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKEJhc2ljUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVwc2lsb25QYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvZXBzaWxvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgV2lsZGNhcmRQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIjtcbmltcG9ydCBFbmRPZkxpbmVQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IENob2ljZU9mUGFydHNQYXJ0IGZyb20gXCIuL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IE9uZU9yTW9yZVBhcnRzUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4vcGFydC9ub25UZXJtaW5hbC96ZXJvT3JNb3JlUGFydHNcIjtcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblBhcnQgZnJvbSBcIi4vcGFydC90ZXJtaW5hbC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBmcm9tIFwiLi9wYXJ0L3Rlcm1pbmFsL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRXBzaWxvblBhcnQsXG4gIFJ1bGVOYW1lUGFydCxcbiAgV2lsZGNhcmRQYXJ0LFxuICBFbmRPZkxpbmVQYXJ0LFxuICBPcHRpb25hbFBhcnRQYXJ0LFxuICBDaG9pY2VPZlBhcnRzUGFydCxcbiAgU3RyaW5nTGl0ZXJhbFBhcnQsXG4gIE9uZU9yTW9yZVBhcnRzUGFydCxcbiAgU2VxdWVuY2VPZlBhcnRzUGFydCxcbiAgWmVyb09yTW9yZVBhcnRzUGFydCxcbiAgUmVndWxhckV4cHJlc3Npb25QYXJ0LFxuICBTaWduaWZpY2FudFRva2VuVHlwZVBhcnRcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQk5GUGFyc2VyIH0gZnJvbSBcIi4vYm5mL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNpY1BhcnNlciB9IGZyb20gXCIuL2Jhc2ljL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25QYXJzZXIgfSBmcm9tIFwiLi9jb21tb24vcGFyc2VyXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9kZU1peGlucyB9IGZyb20gXCIuL21peGlucy9ub2RlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgcnVsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcnVsZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2VyVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bGUgfSBmcm9tIFwiLi9ydWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRzIH0gZnJvbSBcIi4vcGFydHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydFR5cGVzIH0gZnJvbSBcIi4vcGFydFR5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRDaG9pY2UgfSBmcm9tIFwiLi9wYXJ0Q2hvaWNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlZmluaXRpb24gfSBmcm9tIFwiLi9kZWZpbml0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVwc2lsb25Ob2RlIH0gZnJvbSBcIi4vbm9kZS90ZXJtaW5hbC9lcHNpbG9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL25vZGUvdGVybWluYWxcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBzdHlsZXNoZWV0ICAgICAgICAgICAgICAgICA6Oj0gKCBtZWRpYSB8IHJ1bGVTZXQgfCBrZXlmcmFtZXMgfCBkZWNsYXJhdGlvbiB8IGVycm9yICkrIDtcblxuXG4gICAgbWVkaWEgICAgICAgICAgICAgICAgICAgICAgOjo9IFwiQG1lZGlhXCIgbWVkaWFRdWVyaWVzIFwie1wiICggcnVsZVNldCB8IGRlY2xhcmF0aW9uICkqIFwifVwiIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgcnVsZVNldCAgICAgICAgICAgICAgICAgICAgOjo9ICBzZWxlY3RvcnMgXCJ7XCIgZGVjbGFyYXRpb24qIFwifVwiIDtcbiAgICBcbiAgICBcbiAgICBrZXlmcmFtZXMgICAgICAgICAgICAgICAgICA6Oj0gXCJAa2V5ZnJhbWVzXCIgW2lkZW50aWZpZXJdIFwie1wiIGtleWZyYW1lKyBcIn1cIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlY2xhcmF0aW9uICAgICAgICAgICAgICAgIDo6PSAgcHJvcGVydHlOYW1lIFwiOlwiIHByb3BlcnR5VmFsdWVzIGltcG9ydGFudD8gXCI7XCIgO1xuXG5cbiAgICBlcnJvci4gICAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5cbiAgICBwcm9wZXJ0eVZhbHVlcyAgICAgICAgICAgICA6Oj0gIHByb3BlcnR5VmFsdWUgKCBcIixcIiBwcm9wZXJ0eVZhbHVlICkqIDtcblxuXG4gICAgbWVkaWFRdWVyaWVzICAgICAgICAgICAgICAgOjo9ICBtZWRpYVF1ZXJ5ICggKCBcIixcIiB8IFwib3JcIiApIG1lZGlhUXVlcnkgKSogO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgc2VsZWN0b3JzICAgICAgICAgICAgICAgICAgOjo9ICBzZWxlY3RvciAoIFwiLFwiIHNlbGVjdG9yICkqIDtcblxuXG4gICAga2V5ZnJhbWUgICAgICAgICAgICAgICAgICAgOjo9ICBbcGVyY2VudGFnZV0gXCJ7XCIgZGVjbGFyYXRpb24rIFwifVwiIDtcbiAgICBcbiAgICBcbiAgICBtZWRpYVF1ZXJ5ICAgICAgICAgICAgICAgICA6Oj0gICggXCJub3RcIj8gbWVkaWFUeXBlIFwiYW5kXCIgKT8gbWVkaWFGZWF0dXJlcyBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFwibm90XCI/IG1lZGlhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIG1lZGlhVHlwZSAgICAgICAgICAgICAgICAgIDo6PSAgXCJhbGxcIiB8IFwicHJpbnRcIiB8IFwic2NyZWVuXCIgfCBcInNwZWVjaFwiIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIG1lZGlhRmVhdHVyZXMgICAgICAgICAgICAgIDo6PSAgKCBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGZWF0dXJlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCIoXCIgXCJub3RcIiBtZWRpYUZlYXR1cmUgXCIpXCIgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmVhdHVyZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCIoXCIgXCJub3RcIiBtZWRpYUZlYXR1cmUgXCIpXCIgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBtZWRpYUZlYXR1cmUgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIFtpZGVudGlmaWVyXSAoIFwiOlwiIHByb3BlcnR5VmFsdWUgKT8gXCIpXCIgO1xuXG5cbiAgICBwcm9wZXJ0eVZhbHVlICAgICAgICAgICAgICA6Oj0gIHRlcm0gKCBcIixcIj8gdGVybSApKiA7XG5cblxuICAgIHByb3BlcnR5TmFtZSAgICAgICAgICAgICAgIDo6PSAgW2lkZW50aWZpZXJdIDtcblxuXG4gICAgaW1wb3J0YW50ICAgICAgICAgICAgICAgICAgOjo9ICBcIiFpbXBvcnRhbnRcIiA7XG5cblxuICAgIHNlbGVjdG9yICAgICAgICAgICAgICAgICAgIDo6PSAgKCBjbGFzcyB8IHBzZXVkb0NsYXNzIHwgcHNldWRvRWxlbWVudCB8IGF0dHJpYnV0ZSApKyA7XG5cblxuICAgIGNsYXNzICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCIuXCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBzZXVkb0NsYXNzICAgICAgICAgICAgICAgIDo6PSAgXCI6XCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBzZXVkb0VsZW1lbnQgICAgICAgICAgICAgIDo6PSAgXCI6OlwiPE5PX1dISVRFU1BBQ0U+W2lkZW50aWZpZXJdIHBhcmVudGhlc2lzZWRTZWxlY3Rvcj8gO1xuXG5cbiAgICBwYXJlbnRoZXNpc2VkU2VsZWN0b3IgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiKFwiIHNlbGVjdG9yIDxOT19XSElURVNQQUNFPlwiKVwiIDtcblxuXG4gICAgYXR0cmlidXRlICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCI9XCIgfCBcIn49XCIgfCBcInw9XCIgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW2lkZW50aWZpZXJdIHwgW3N0cmluZy1saXRlcmFsXSApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG4gICAgdGVybSAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBbcGx1cy1vci1taW51c10/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFtwZXJjZW50YWdlXSB8IFtmcmVxdWVuY3ldIHwgW2ZyYWN0aW9uXSB8IFtsZW5ndGhdIHwgW2FuZ2xlXSB8IFtyZW1zXSB8IFtlbXNdIHwgW3RpbWVdIHwgW251bWJlcl0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0cmluZy1saXRlcmFsXStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbG91cl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIHVyaSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJ1cmxcIjxOT19XSElURVNQQUNFPlwiKFwiIFtzdHJpbmctbGl0ZXJhbF0gXCIpXCIgO1xuXG5cbiAgICBmdW5jdGlvbiAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXTxOT19XSElURVNQQUNFPlwiKFwiIHByb3BlcnR5VmFsdWUgXCIpXCIgO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTU1BhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKENTU1BhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKENTU1BhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoQ1NTUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEVSUk9SX1JVTEVfTkFNRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBJTkRFWF9SVUxFX05BTUUgPSBcImluZGV4XCI7XG5leHBvcnQgY29uc3QgVU5JUVVFX1JVTEVfTkFNRSA9IFwidW5pcXVlXCI7XG5leHBvcnQgY29uc3QgU1BSRUFEX1JVTEVfTkFNRSA9IFwic3ByZWFkXCI7XG5leHBvcnQgY29uc3QgRU5EX0lOREVYX1JVTEVfTkFNRSA9IFwiZW5kSW5kZXhcIjtcbmV4cG9ydCBjb25zdCBSVUxFX05BTUVfUlVMRV9OQU1FID0gXCJydWxlTmFtZVwiO1xuZXhwb3J0IGNvbnN0IFRPS0VOX1RZUEVfUlVMRV9OQU1FID0gXCJ0b2tlblR5cGVcIjtcbmV4cG9ydCBjb25zdCBTVEFSVF9JTkRFWF9SVUxFX05BTUUgPSBcInN0YXJ0SW5kZXhcIjtcbmV4cG9ydCBjb25zdCBTVUJfRVhQUkVTU0lPTl9SVUxFX05BTUUgPSBcInN1YkV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBJTkZJTklURV9ERVNDRU5UX1JVTEVfTkFNRSA9IFwiaW5maW5pdGVEZXNjZW50XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVSUk9SX1JVTEVfTkFNRSxcbiAgICAgICAgIElOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFVOSVFVRV9SVUxFX05BTUUsXG4gICAgICAgICBTUFJFQURfUlVMRV9OQU1FLFxuICAgICAgICAgRU5EX0lOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFJVTEVfTkFNRV9SVUxFX05BTUUsXG4gICAgICAgICBUT0tFTl9UWVBFX1JVTEVfTkFNRSxcbiAgICAgICAgIFNUQVJUX0lOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFNVQl9FWFBSRVNTSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIElORklOSVRFX0RFU0NFTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhGcm9tSW5kZXhOb2RlKGluZGV4Tm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbmRleE5vZGUsIC8vL1xuICAgICAgICBpbmRleCA9IGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChmaXJzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgICAgICAgaW5kZXggPSBOdW1iZXIoY29udGVudCk7XG5cbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lc0Zyb21QYXRoTm9kZShwYXRoTm9kZSkge1xuICBjb25zdCBzZWxlY3Rvck5vZGVzID0gc2VsZWN0b3JOb2Rlc0Zyb21QYXRoTm9kZShwYXRoTm9kZSksXG4gICAgICAgIHJ1bGVOYW1lTm9kZXMgPSBzZWxlY3Rvck5vZGVzLnJlZHVjZSgocnVsZU5hbWVOb2Rlcywgc2VsZWN0b3JOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2VsZWN0b3JOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICBydWxlTmFtZU5vZGUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBydWxlTmFtZU5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBSVUxFX05BTUVfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVOYW1lUnVsZU5hbWVSdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZU5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZU5hbWVOb2RlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJ1bGVOYW1lTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVsZU5hbWVOb2Rlcy5wdXNoKHJ1bGVOYW1lTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lTm9kZXM7XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgcnVsZU5hbWVzID0gcnVsZU5hbWVOb2Rlcy5tYXAoKHJ1bGVOYW1lTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHJ1bGVOYW1lTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gY29udGVudDsgLy8vXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuVHlwZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0b3JOb2RlcyA9IHNlbGVjdG9yTm9kZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICB0b2tlblR5cGVOb2RlcyA9IHNlbGVjdG9yTm9kZXMucmVkdWNlKCh0b2tlblR5cGVOb2Rlcywgc2VsZWN0b3JOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2VsZWN0b3JOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICB0b2tlblR5cGVOb2RlID0gZnJvbUZpcnN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGZpcnN0Q2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgdG9rZW5UeXBlTm9kZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZVRva2VuVHlwZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBUT0tFTl9UWVBFX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChydWxlTmFtZVRva2VuVHlwZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZU5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5UeXBlTm9kZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0b2tlblR5cGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlblR5cGVOb2Rlcy5wdXNoKHRva2VuVHlwZU5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b2tlblR5cGVOb2RlcztcbiAgICAgICAgfSwgW10pLFxuICAgICAgICB0b2tlblR5cGVzID0gdG9rZW5UeXBlTm9kZXMubWFwKCh0b2tlblR5cGVOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdG9rZW5UeXBlTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgIHRva2VuVHlwZSA9IGZyb21UaGlyZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsICh0aGlyZENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gdGhpcmRDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlID0gY29udGVudDsgIC8vL1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRva2VuVHlwZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHRva2VuVHlwZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rvck5vZGVzRnJvbVBhdGhOb2RlKHBhdGhOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcGF0aE5vZGU7IC8vL1xuXG4gIGNvbnN0IHNlbGVjdG9yc05vZGUgPSBmcm9tTGFzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChsYXN0Q2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3JzTm9kZSA9IGxhc3RDaGlsZE5vZGU7ICAvLy9cblxuICAgIHJldHVybiBzZWxlY3RvcnNOb2RlO1xuICB9KTtcblxuICBub25UZXJtaW5hbE5vZGUgPSBzZWxlY3RvcnNOb2RlOyAgLy8vXG5cbiAgY29uc3Qgc2VsZWN0b3JOb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5maWx0ZXJDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VsZWN0b3JOb2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZmluaXRlRGVzY2VudEZyb21QYXRoTm9kZShwYXRoTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBwYXRoTm9kZSwgLy8vXG4gICAgICAgIGluZmluaXRlRGVzY2VudCA9IGZyb21TZWNvbmRDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoc2Vjb25kQ2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZUluZmluaXRlRGVzY2VudFJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBJTkZJTklURV9ERVNDRU5UX1JVTEVfTkFNRSksXG4gICAgICAgICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gcnVsZU5hbWVJbmZpbml0ZURlc2NlbnRSdWxlTmFtZTsgIC8vL1xuXG4gICAgICAgICAgcmV0dXJuIGluZmluaXRlRGVzY2VudDtcbiAgICAgICAgfSkgfHwgZmFsc2U7XG5cbiAgcmV0dXJuIGluZmluaXRlRGVzY2VudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ByZWFkTm9kZSxcbiAgICAgICAgdW5pcXVlID0gZnJvbUZpcnN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGZpcnN0Q2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgbGV0IHVuaXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgaWYgKGZpcnN0Q2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgcnVsZU5hbWVVbmlxdWVSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gVU5JUVVFX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGlmIChydWxlTmFtZVVuaXF1ZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHVuaXF1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuaXF1ZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHVuaXF1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4RnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSkge1xuICBsZXQgaW5kZXggPSBudWxsO1xuXG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNwcmVhZE5vZGUsIC8vL1xuICAgICAgICBpbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZUluZGV4UnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IElOREVYX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGlmIChydWxlTmFtZUluZGV4UnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChpbmRleE5vZGUgIT09IG51bGwpIHtcbiAgICBpbmRleCA9IGluZGV4RnJvbUluZGV4Tm9kZShpbmRleE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kSW5kZXhGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKSB7XG4gIGxldCBlbmRJbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNwcmVhZE5vZGUsIC8vL1xuICAgICAgICBlbmRJbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZUVuZEluZGV4UnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IEVORF9JTkRFWF9SVUxFX05BTUUpO1xuXG4gICAgICAgICAgICBpZiAocnVsZU5hbWVFbmRJbmRleFJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoZW5kSW5kZXhOb2RlICE9PSBudWxsKSB7XG4gICAgZW5kSW5kZXggPSBpbmRleEZyb21JbmRleE5vZGUoZW5kSW5kZXhOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBlbmRJbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SW5kZXhGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKSB7XG4gIGxldCBzdGFydEluZGV4ID0gMDtcblxuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBzcHJlYWROb2RlLCAvLy9cbiAgICAgICAgc3RhcnRJbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZVN0YXJ0SW5kZXhSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1RBUlRfSU5ERVhfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVOYW1lU3RhcnRJbmRleFJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoc3RhcnRJbmRleE5vZGUgIT09IG51bGwpIHtcbiAgICBzdGFydEluZGV4ID0gaW5kZXhGcm9tSW5kZXhOb2RlKHN0YXJ0SW5kZXhOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGFydEluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBwYXRoTm9kZSA9IGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChmaXJzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGhOb2RlID0gZmlyc3RDaGlsZE5vZGU7ICAvLy9cblxuICAgICAgICAgIHJldHVybiBwYXRoTm9kZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHBhdGhOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkTm9kZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIHNwcmVhZE5vZGUgPSBmcm9tU2Vjb25kQ2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKHNlY29uZENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGxldCBzcHJlYWROb2RlID0gbnVsbDtcblxuICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgcnVsZU5hbWVTcHJlYWRSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1BSRUFEX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICBpZiAocnVsZU5hbWVTcHJlYWRSdWxlTmFtZSkge1xuICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNlY29uZENoaWxkTm9kZTsgIC8vL1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzcHJlYWROb2RlO1xuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIHJldHVybiBzcHJlYWROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JOb2Rlc0Zyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIGVycm9yTm9kZXMgPSBub25UZXJtaW5hbE5vZGUucmVkdWNlQ2hpbGROb2RlKChlcnJvck5vZGVzLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lRXJyb3JSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gRVJST1JfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVOYW1lRXJyb3JSdWxlTmFtZSkge1xuICAgICAgICAgICAgICBjb25zdCBlcnJvck5vZGUgPSBub25UZXJtaW5hbE5vZGU7ICAvLy9cblxuICAgICAgICAgICAgICBlcnJvck5vZGVzLnB1c2goZXJyb3JOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXJyb3JOb2RlcztcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBlcnJvck5vZGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbk5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgbGV0IHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIG11bHRpcGxpY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRNdWx0aXBsaWNpdHkoKTtcblxuICBpZiAobXVsdGlwbGljaXR5ID4gMSkge1xuICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gZnJvbUxhc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAobGFzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgbGV0IHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbGFzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJ1bGVOYW1lU3ViRXhwcmVzc2lvblJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBTVUJfRVhQUkVTU0lPTl9SVUxFX05BTUUpO1xuXG4gICAgICBpZiAocnVsZU5hbWVTdWJFeHByZXNzaW9uUnVsZU5hbWUpIHtcbiAgICAgICAgc3ViRXhwcmVzc2lvbk5vZGUgPSBsYXN0Q2hpbGROb2RlOyAgLy8vXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJFeHByZXNzaW9uTm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdWJFeHByZXNzaW9uTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhOb2RlRnJvbVN1YkV4cHJlc3Npb25Ob2RlKHN1YkV4cHJlc3Npb25Ob2RlKSB7XG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlLCAvLy9cbiAgICAgICAgcGF0aE5vZGUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXRoTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgICAgICAgICByZXR1cm4gcGF0aE5vZGU7XG4gICAgICAgIH0pXG5cbiAgcmV0dXJuIHBhdGhOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZShzdWJFeHByZXNzaW9uTm9kZSkge1xuICBsZXQgc3ByZWFkTm9kZSA9IG51bGw7XG5cbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ViRXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCk7XG5cbiAgaWYgKG11bHRpcGxpY2l0eSA+IDEpIHtcbiAgICBzcHJlYWROb2RlID0gZnJvbVNlY29uZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChzZWNvbmRDaGlsZE5vZGUpID0+IHtcbiAgICAgIGxldCBzcHJlYWROb2RlID0gbnVsbDtcblxuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgcnVsZU5hbWVTcHJlYWRSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1BSRUFEX1JVTEVfTkFNRSk7XG5cbiAgICAgIGlmIChydWxlTmFtZVNwcmVhZFJ1bGVOYW1lKSB7XG4gICAgICAgIHNwcmVhZE5vZGUgPSBzZWNvbmRDaGlsZE5vZGU7ICAvLy9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwcmVhZE5vZGU7XG4gICAgfSkgfHwgbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzcHJlYWROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbk5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ViRXhwcmVzc2lvbk5vZGU7IC8vL1xuXG4gIHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCk7XG5cbiAgaWYgKG11bHRpcGxpY2l0eSA+IDEpIHtcbiAgICBzdWJFeHByZXNzaW9uTm9kZSA9IGZyb21MYXN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGxhc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgIGxldCBzdWJFeHByZXNzaW9uTm9kZSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9lID0gbGFzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9lLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBydWxlTmFtZVN1YkV4cHJlc3Npb25SdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1VCX0VYUFJFU1NJT05fUlVMRV9OQU1FKTtcblxuICAgICAgaWYgKHJ1bGVOYW1lU3ViRXhwcmVzc2lvblJ1bGVOYW1lKSB7XG4gICAgICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gbGFzdENoaWxkTm9kZTsgIC8vL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ViRXhwcmVzc2lvbk5vZGU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3ViRXhwcmVzc2lvbk5vZGU7XG59XG5cbmZ1bmN0aW9uIGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3QgZmlyc3RJbmRleCA9IDA7XG5cbiAgbm9uVGVybWluYWxOb2RlLmZvcndhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gZmlyc3RJbmRleCkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayhmaXJzdENoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZnJvbVNlY29uZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3Qgc2Vjb25kSW5kZXggPSAxO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5mb3J3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IHNlY29uZEluZGV4KSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkTm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGZpcnN0Q2hpbGROb2RlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmcm9tVGhpcmRDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0O1xuXG4gIGNvbnN0IHRoaXJkSW5kZXggPSAyO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5mb3J3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXJkSW5kZXgpIHtcbiAgICAgIGNvbnN0IHRoaXJkQ2hpbGROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodGhpcmRDaGlsZE5vZGUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZyb21MYXN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdDtcblxuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCksXG4gICAgICAgIGxhc3RJbmRleCA9IG11bHRpcGxpY2l0eSAtIDE7XG5cbiAgbm9uVGVybWluYWxOb2RlLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgY29uc3QgdGhpcmRDaGlsZE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh0aGlyZENoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbVBhdGhOb2RlLCB0b2tlblR5cGVzRnJvbVBhdGhOb2RlLCBpbmZpbml0ZURlc2NlbnRGcm9tUGF0aE5vZGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWVzLCB0b2tlblR5cGVzLCBpbmZpbml0ZURlc2NlbnQpIHtcbiAgICB0aGlzLnJ1bGVOYW1lcyA9IHJ1bGVOYW1lcztcbiAgICB0aGlzLnRva2VuVHlwZXMgPSB0b2tlblR5cGVzO1xuICAgIHRoaXMuaW5maW5pdGVEZXNjZW50ID0gaW5maW5pdGVEZXNjZW50O1xuICB9XG5cbiAgZ2V0UnVsZU5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lcztcbiAgfVxuXG4gIGdldFRva2VuVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5UeXBlcztcbiAgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXRlRGVzY2VudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGF0aE5vZGUocGF0aE5vZGUpIHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgIHRva2VuVHlwZXMgPSB0b2tlblR5cGVzRnJvbVBhdGhOb2RlKHBhdGhOb2RlKSxcbiAgICAgICAgICBpbmZpbml0ZURlc2NlbnQgPSBpbmZpbml0ZURlc2NlbnRGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChydWxlTmFtZXMsIHRva2VuVHlwZXMsIGluZmluaXRlRGVzY2VudCk7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuZXhwb3J0IGNvbnN0IHsgY2xlYXIsIHB1c2gsIGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBmb3VydGgsIGZpZnRoLCBsYXN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oYXJyYXksIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgLy8vXG5cbiAgICBzdGFydEluZGV4ID0gbGVuZ3RoICsgc3RhcnRJbmRleDsgLy8vXG5cbiAgICBlbmRJbmRleCA9IGxlbmd0aCArIGVuZEluZGV4OyAvLy9cbiAgfVxuXG4gIGlmIChlbmRJbmRleCAhPT0gSW5maW5pdHkpIHtcbiAgICBjb25zdCBzdGFydCA9IGVuZEluZGV4ICsgMTtcblxuICAgIGFycmF5LnNwbGljZShzdGFydCk7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IDAsXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gc3RhcnRJbmRleDsgLy8vXG5cbiAgYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgLi4uZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IGFycmF5LmluY2x1ZGVzKGVsZW1lbnQpKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgY2xlYXIsIHRyaW0sIHNlY29uZCwgdGhpcmQsIGZvdXJ0aCB9IGZyb20gXCIuL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgaW5kZXhGcm9tU3ByZWFkTm9kZSxcbiAgICAgICAgIHVuaXF1ZUZyb21TcHJlYWROb2RlLFxuICAgICAgICAgZW5kSW5kZXhGcm9tU3ByZWFkTm9kZSxcbiAgICAgICAgIHN0YXJ0SW5kZXhGcm9tU3ByZWFkTm9kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcmVhZCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpIHtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICB0aGlzLnVuaXF1ZSA9IHVuaXF1ZTtcbiAgfVxuXG4gIGFkanVzdE5vZGVzKG5vZGVzKSB7XG4gICAgaWYgKHRoaXMudW5pcXVlKSB7XG4gICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVzTGVuZ3RoID4gMSkge1xuICAgICAgICBjbGVhcihub2Rlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaW0obm9kZXMsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5lbmRJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgIGVuZEluZGV4ID0gSW5maW5pdHksXG4gICAgICAgICAgdW5pcXVlID0gZmFsc2UsXG4gICAgICAgICAgc3ByZWFkID0gbmV3IFNwcmVhZChzdGFydEluZGV4LCBlbmRJbmRleCwgdW5pcXVlKTtcblxuICAgIHJldHVybiBzcHJlYWQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSkge1xuICAgIGxldCBzdGFydEluZGV4ID0gMCxcbiAgICAgICAgZW5kSW5kZXggPSBJbmZpbml0eSxcbiAgICAgICAgdW5pcXVlID0gZmFsc2U7XG5cbiAgICBpZiAoc3ByZWFkTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleEZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4OyAvLy9cblxuICAgICAgICBlbmRJbmRleCA9IGluZGV4OyAvLy9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4RnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSk7XG5cbiAgICAgICAgZW5kSW5kZXggPSBlbmRJbmRleEZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuICAgICAgfVxuXG4gICAgICB1bmlxdWUgPSB1bmlxdWVGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcHJlYWQgPSBuZXcgU3ByZWFkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpO1xuXG4gICAgcmV0dXJuIHNwcmVhZDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3ByZWFkRXhwcmVzc2lvbihzcHJlYWRFeHByZXNzaW9uKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICBlbmRJbmRleCA9IEluZmluaXR5LFxuICAgICAgICB1bmlxdWUgPSBmYWxzZTtcblxuICAgIGlmIChzcHJlYWRFeHByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoc3ByZWFkRXhwcmVzc2lvbiA9PT0gRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVIpIHtcbiAgICAgICAgdW5pcXVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9IC9cXFsoLT9cXGQrKT8oXFwuXFwuXFwuKT8oLT9cXGQrKT9dLyxcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHNwcmVhZEV4cHJlc3Npb24ubWF0Y2gocmVnRXhwKSxcbiAgICAgICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcykgfHwgbnVsbCxcbiAgICAgICAgICAgICAgdGhpcmRNYXRjaCA9IHRoaXJkKG1hdGNoZXMpIHx8IG51bGwsXG4gICAgICAgICAgICAgIGZvdXJ0aE1hdGNoID0gZm91cnRoKG1hdGNoZXMpIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKHNlY29uZE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHBhcnNlSW50KHNlY29uZE1hdGNoKTtcblxuICAgICAgICAgIGlmICh0aGlyZE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7ICAvLy9cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91cnRoTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICBlbmRJbmRleCA9IHBhcnNlSW50KGZvdXJ0aE1hdGNoKTtcblxuICAgICAgICAgIGlmICh0aGlyZE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gZW5kSW5kZXg7ICAvLy9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcHJlYWQgPSBuZXcgU3ByZWFkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpO1xuXG4gICAgcmV0dXJuIHNwcmVhZDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGF0aCBmcm9tIFwiLi9wYXRoXCI7XG5pbXBvcnQgU3ByZWFkIGZyb20gXCIuL3NwcmVhZFwiO1xuXG5pbXBvcnQgeyBwYXRoTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZSwgc3ByZWFkTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZSwgc3ViRXhwcmVzc2lvbk5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGF0aCwgc3ByZWFkLCBzdWJFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnNwcmVhZCA9IHNwcmVhZDtcbiAgICB0aGlzLnN1YkV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG5cbiAgZ2V0U3ByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnNwcmVhZDtcbiAgfVxuXG4gIGdldFN1YkV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFJ1bGVOYW1lcygpIHsgcmV0dXJuIHRoaXMucGF0aC5nZXRSdWxlTmFtZXMoKTsgfVxuXG4gIGdldFRva2VuVHlwZXMoKSB7IHJldHVybiB0aGlzLnBhdGguZ2V0VG9rZW5UeXBlcygpOyB9XG5cbiAgaXNJbmZpbml0ZURlc2NlbnQoKSB7IHJldHVybiB0aGlzLnBhdGguaXNJbmZpbml0ZURlc2NlbnQoKTsgfVxuXG4gIHN0YXRpYyBmcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpIHtcbiAgICBsZXQgc3ViRXhwcmVzc2lvbiA9IG51bGw7XG5cbiAgICBpZiAoc3ViRXhwcmVzc2lvbk5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhdGhOb2RlID0gcGF0aE5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlRnJvbVN1YkV4cHJlc3Npb25Ob2RlKHN1YkV4cHJlc3Npb25Ob2RlKTsgIC8vL1xuXG4gICAgICBjb25zdCBwYXRoID0gUGF0aC5mcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbi5mcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uID0gbmV3IFN1YkV4cHJlc3Npb24ocGF0aCwgc3ByZWFkLCBzdWJFeHByZXNzaW9uKTsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YkV4cHJlc3Npb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OkB8IXxcXFxcKnxcXFxcfHxcXFxcL3xcXFxcW3xcXFxcXXxcXFxcLlxcXFwuXFxcXC4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIl5bYS16QS1aXFxcXC1dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl5bMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXi5cIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHByZXNzaW9uTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoRXhwcmVzc2lvbkxleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoRXhwcmVzc2lvbkxleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEV4cHJlc3Npb25MZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGV4cHJlc3Npb24gICAgICAgOjo9ICBwYXRoIHNwcmVhZD8gc3ViRXhwcmVzc2lvbj8gICBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgfCAgZXJyb3IrIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIDtcbiAgXG4gICAgcGF0aCAgICAgICAgICAgICA6Oj0gIFwiL1wiIGluZmluaXRlRGVzY2VudD8gc2VsZWN0b3JzIDtcbiAgICBcbiAgICBzdWJFeHByZXNzaW9uICAgIDo6PSAgcGF0aCBzcHJlYWQ/IHN1YkV4cHJlc3Npb24/O1xuXG4gICAgaW5maW5pdGVEZXNjZW50ICA6Oj0gIFwiL1wiIDtcbiAgICBcbiAgICBzZWxlY3RvcnMgICAgICAgIDo6PSAgc2VsZWN0b3IgKCBcInxcIiBzZWxlY3RvciApKiA7XG5cbiAgICBzcHJlYWQgICAgICAgICAgIDo6PSAgdW5pcXVlXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgIHwgIFwiW1wiIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzdGFydEluZGV4IFwiLi4uXCIgZW5kSW5kZXggKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggc3RhcnRJbmRleCBcIi4uLlwiICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFwiLi4uXCIgZW5kSW5kZXggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICApICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiIDtcblxuICAgIHNlbGVjdG9yICAgICAgICAgOjo9ICBydWxlTmFtZSB8IHRva2VuVHlwZSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHJ1bGVOYW1lICAgICAgICAgOjo9ICBbbmFtZV0gfCBcIipcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHRva2VuVHlwZSAgICAgICAgOjo9ICBcIkBcIjxOT19XSElURVNQQUNFPiggW25hbWVdIHwgXCIqXCIgKSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHN0YXJ0SW5kZXggICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGVuZEluZGV4ICAgICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGluZGV4ICAgICAgICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHVuaXF1ZSAgICAgICAgICAgOjo9ICBcIiFcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuXG5cbiAgICBlcnJvci4gICAgICAgICAgIDo6PSAgLiA7XG4gICAgXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhFeHByZXNzaW9uUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoRXhwcmVzc2lvblBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoRXhwcmVzc2lvblBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQYXRoIGZyb20gXCIuL3BhdGhcIjtcbmltcG9ydCBTcHJlYWQgZnJvbSBcIi4vc3ByZWFkXCI7XG5pbXBvcnQgU3ViRXhwcmVzc2lvbiBmcm9tIFwiLi9zdWJFeHByZXNzaW9uXCI7XG5pbXBvcnQgRXhwcmVzc2lvbkxleGVyIGZyb20gXCIuL2V4cHJlc3Npb24vbGV4ZXJcIjtcbmltcG9ydCBFeHByZXNzaW9uUGFyc2VyIGZyb20gXCIuL2V4cHJlc3Npb24vcGFyc2VyXCI7XG5cbmltcG9ydCB7IHBhdGhOb2RlRnJvbUV4cHJlc3Npb25Ob2RlLFxuICAgICAgICAgc3ByZWFkTm9kZUZyb21FeHByZXNzaW9uTm9kZSxcbiAgICAgICAgIGVycm9yTm9kZXNGcm9tRXhwcmVzc2lvbk5vZGUsXG4gICAgICAgICBzdWJFeHByZXNzaW9uTm9kZUZyb21FeHByZXNzaW9uTm9kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IGV4cHJlc3Npb25MZXhlciA9IEV4cHJlc3Npb25MZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgZXhwcmVzc2lvblBhcnNlciA9IEV4cHJlc3Npb25QYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIHNwcmVhZCwgc3ViRXhwcmVzc2lvbikge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJFeHByZXNzaW9uID0gc3ViRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGdldFNwcmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcHJlYWQ7XG4gIH1cblxuICBnZXRTdWJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN1YkV4cHJlc3Npb247XG4gIH1cblxuICBnZXRSdWxlTmFtZXMoKSB7IHJldHVybiB0aGlzLnBhdGguZ2V0UnVsZU5hbWVzKCk7IH1cblxuICBnZXRUb2tlblR5cGVzKCkgeyByZXR1cm4gdGhpcy5wYXRoLmdldFRva2VuVHlwZXMoKTsgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkgeyByZXR1cm4gdGhpcy5wYXRoLmlzSW5maW5pdGVEZXNjZW50KCk7IH1cblxuICBzdGF0aWMgZnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSB7XG4gICAgY29uc3QgcGF0aE5vZGUgPSBwYXRoTm9kZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gc3ViRXhwcmVzc2lvbk5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHBhdGggPSBQYXRoLmZyb21QYXRoTm9kZShwYXRoTm9kZSksXG4gICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpLFxuICAgICAgICAgIHN1YkV4cHJlc3Npb24gPSBTdWJFeHByZXNzaW9uLmZyb21TdWJFeHByZXNzaW9uTm9kZShzdWJFeHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKHBhdGgsIHNwcmVhZCwgc3ViRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gICAgY29uc3QgbGV4ZXIgPSBleHByZXNzaW9uTGV4ZXIsICAvLy9cbiAgICAgICAgICBwYXJzZXIgPSBleHByZXNzaW9uUGFyc2VyLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IGV4cHJlc3Npb25TdHJpbmcsIC8vL1xuICAgICAgICAgIHRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIG5vZGUgPSBwYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgZXJyb3JOb2RlcyA9IGVycm9yTm9kZXNGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgZXJyb3JOb2Rlc0xlbmd0aCA9IGVycm9yTm9kZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZXJyb3JOb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBwYXRoTm9kZSA9IHBhdGhOb2RlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgICBzdWJFeHByZXNzaW9uTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICAgICAgcGF0aCA9IFBhdGguZnJvbVBhdGhOb2RlKHBhdGhOb2RlKSxcbiAgICAgICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpLFxuICAgICAgICAgICAgICBzdWJFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbi5mcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICAgIGV4cHJlc3Npb24gPSBuZXcgRXhwcmVzc2lvbihwYXRoLCBzcHJlYWQsIHN1YkV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuL2V4cHJlc3Npb25cIjtcblxuaW1wb3J0IHsgcHVzaCwgY2xlYXIsIGluY2x1ZGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmNvbnN0IHsgV0lMRENBUkRfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKHNwcmVhZCwgc3ViUXVlcnksIHJ1bGVOYW1lcywgdG9rZW5UeXBlcywgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKSB7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJRdWVyeSA9IHN1YlF1ZXJ5O1xuICAgIHRoaXMucnVsZU5hbWVzID0gcnVsZU5hbWVzO1xuICAgIHRoaXMudG9rZW5UeXBlcyA9IHRva2VuVHlwZXM7XG4gICAgdGhpcy5tYXhpbXVtRGVwdGggPSBtYXhpbXVtRGVwdGg7XG4gICAgdGhpcy5pbmZpbml0ZURlc2NlbnQgPSBpbmZpbml0ZURlc2NlbnQ7XG4gICAgdGhpcy5pbnRlcm1lZGlhdGVOb2RlcyA9IGludGVybWVkaWF0ZU5vZGVzO1xuICB9XG5cbiAgZ2V0U3ByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnNwcmVhO1xuICB9XG5cbiAgZ2V0U3ViUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViUXVlcnk7XG4gIH1cblxuICBnZXRSdWxlTmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWVzO1xuICB9XG5cbiAgZ2V0VG9rZW5UeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlblR5cGVzO1xuICB9XG5cbiAgZ2V0TWF4aW11bURlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLm1heGltdW1EZXB0aDtcbiAgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXRlRGVzY2VudDtcbiAgfVxuXG4gIGdldEludGVybWVkaWF0ZU5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybWVkaWF0ZU5vZGVzO1xuICB9XG5cbiAgZXhlY3V0ZShub2RlLCBkZXB0aCA9IDAsIG1heGltdW1EZXB0aCA9IHRoaXMubWF4aW11bURlcHRoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuZmluZChub2RlLCBkZXB0aCwgbWF4aW11bURlcHRoKTtcblxuICAgIHRoaXMuYXBwbHkobm9kZXMsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXIodGhpcy5pbnRlcm1lZGlhdGVOb2Rlcyk7XG4gIH1cblxuICBmaW5kKG5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBtYXhpbXVtRGVwdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIG5vZGVOb25UZXJtaW5hbE5vZGUgPSAhbm9kZVRlcm1pbmFsTm9kZTtcblxuICAgIGxldCBmb3VuZDtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICB0eXBlcyA9IHRoaXMudG9rZW5UeXBlcywgIC8vL1xuICAgICAgICAgICAgdHlwZSA9IHRlcm1pbmFsTm9kZS5nZXRUeXBlKCk7XG5cbiAgICAgIGZvdW5kID0gaW5jbHVkZXModHlwZXMsIHR5cGUsIFdJTERDQVJEX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgICAgZm91bmQgPSBpbmNsdWRlcyh0aGlzLnJ1bGVOYW1lcywgcnVsZU5hbWUsIFdJTERDQVJEX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGVOb2RlID0gbm9kZTsgLy8vXG5cbiAgICAgIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMucHVzaChpbnRlcm1lZGlhdGVOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmZpbml0ZURlc2NlbnQpIHtcbiAgICAgIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgLy8vXG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlLmZvckVhY2hDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCkge1xuICAgIHRoaXMuc3ByZWFkLmFkanVzdE5vZGVzKHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgaWYgKHRoaXMuc3ViUXVlcnkgPT09IG51bGwpIHtcbiAgICAgIHB1c2gobm9kZXMsIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVybWVkaWF0ZU5vZGVzLmZvckVhY2goKGludGVybWVkaWF0ZU5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSA9IGludGVybWVkaWF0ZU5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbnRlcm1lZGlhdGVOb2RlOyAvLy9cblxuICAgICAgICAgIHRoaXMuc3ViUXVlcnkuY2xlYXIoKTtcblxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZS5mb3JFYWNoQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViUXVlcnkuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5zdWJRdWVyeS5hcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvbihleHByZXNzaW9uLCBtYXhpbXVtRGVwdGggPSBJbmZpbml0eSkge1xuICAgIGNvbnN0IHNwcmVhZCA9IGV4cHJlc3Npb24uZ2V0U3ByZWFkKCksXG4gICAgICAgICAgc3ViUXVlcnkgPSBzdWJRdWVyeUZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pLFxuICAgICAgICAgIHJ1bGVOYW1lcyA9IGV4cHJlc3Npb24uZ2V0UnVsZU5hbWVzKCksXG4gICAgICAgICAgdG9rZW5UeXBlcyA9IGV4cHJlc3Npb24uZ2V0VG9rZW5UeXBlcygpLFxuICAgICAgICAgIGluZmluaXRlRGVzY2VudCA9IGV4cHJlc3Npb24uaXNJbmZpbml0ZURlc2NlbnQoKSxcbiAgICAgICAgICBpbnRlcm1lZGlhdGVOb2RlcyA9IFtdLFxuICAgICAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHNwcmVhZCwgc3ViUXVlcnksIHJ1bGVOYW1lcywgdG9rZW5UeXBlcywgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3ViRXhwcmVzc2lvbihzdWJFeHByZXNzaW9uKSB7XG4gICAgY29uc3Qgc3ByZWFkID0gc3ViRXhwcmVzc2lvbi5nZXRTcHJlYWQoKSxcbiAgICAgICAgICBzdWJRdWVyeSA9IHN1YlF1ZXJ5RnJvbVN1YkV4cHJlc3Npb24oc3ViRXhwcmVzc2lvbiksXG4gICAgICAgICAgcnVsZU5hbWVzID0gc3ViRXhwcmVzc2lvbi5nZXRSdWxlTmFtZXMoKSxcbiAgICAgICAgICB0b2tlblR5cGVzID0gc3ViRXhwcmVzc2lvbi5nZXRUb2tlblR5cGVzKCksXG4gICAgICAgICAgbWF4aW11bURlcHRoID0gSW5maW5pdHksXG4gICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gc3ViRXhwcmVzc2lvbi5pc0luZmluaXRlRGVzY2VudCgpLFxuICAgICAgICAgIGludGVybWVkaWF0ZU5vZGVzID0gW10sXG4gICAgICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoc3ByZWFkLCBzdWJRdWVyeSwgcnVsZU5hbWVzLCB0b2tlblR5cGVzLCBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgc3RhdGljIGZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcsIG1heGltdW1EZXB0aCA9IEluZmluaXR5KSB7XG4gICAgbGV0IHF1ZXJ5ID0gbnVsbDtcblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBFeHByZXNzaW9uLmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gICAgaWYgKGV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNwcmVhZCA9IGV4cHJlc3Npb24uZ2V0U3ByZWFkKCksXG4gICAgICAgICAgICBzdWJRdWVyeSA9IHN1YlF1ZXJ5RnJvbUV4cHJlc3Npb24oZXhwcmVzc2lvbiksXG4gICAgICAgICAgICBydWxlTmFtZXMgPSBleHByZXNzaW9uLmdldFJ1bGVOYW1lcygpLFxuICAgICAgICAgICAgdG9rZW5UeXBlcyA9IGV4cHJlc3Npb24uZ2V0VG9rZW5UeXBlcygpLFxuICAgICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gZXhwcmVzc2lvbi5pc0luZmluaXRlRGVzY2VudCgpLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlTm9kZXMgPSBbXTtcblxuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoc3ByZWFkLCBzdWJRdWVyeSwgcnVsZU5hbWVzLCB0b2tlblR5cGVzLCBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJRdWVyeUZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgbGV0IHN1YlF1ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBzdWJFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5nZXRTdWJFeHByZXNzaW9uKCk7XG5cbiAgaWYgKHN1YkV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21TdWJFeHByZXNzaW9uKHN1YkV4cHJlc3Npb24pO1xuXG4gICAgc3ViUXVlcnkgPSBxdWVyeTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3ViUXVlcnk7XG59XG5cbmZ1bmN0aW9uIHN1YlF1ZXJ5RnJvbVN1YkV4cHJlc3Npb24oc3ViRXhwcmVzc2lvbikge1xuICBsZXQgc3ViUXVlcnkgPSBudWxsO1xuXG4gIHN1YkV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uLmdldFN1YkV4cHJlc3Npb24oKTsgLy8vXG5cbiAgaWYgKHN1YkV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21TdWJFeHByZXNzaW9uKHN1YkV4cHJlc3Npb24pO1xuXG4gICAgc3ViUXVlcnkgPSBxdWVyeTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3ViUXVlcnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBRdWVyeSBmcm9tIFwiLi4vcXVlcnlcIjtcbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuLi9leHByZXNzaW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUJ5RXhwcmVzc2lvblN0cmluZyhub2RlLCBleHByZXNzaW9uU3RyaW5nLCBtYXhpbXVtRGVwdGgpIHtcbiAgbGV0IG5vZGVzID0gbnVsbDtcblxuICBjb25zdCBleHByZXNzaW9uID0gRXhwcmVzc2lvbi5mcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKTtcblxuICBpZiAoZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbWF4aW11bURlcHRoKTtcblxuICAgIG5vZGVzID0gcXVlcnkuZXhlY3V0ZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBxdWVyeUJ5RXhwcmVzc2lvblN0cmluZ1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBRdWVyeSB9IGZyb20gXCIuL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cHJlc3Npb24gfSBmcm9tIFwiLi9leHByZXNzaW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHF1ZXJ5VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cHJlc3Npb25MZXhlciB9IGZyb20gXCIuL2V4cHJlc3Npb24vbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gXCIuL2V4cHJlc3Npb24vcGFyc2VyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBIRUFEID0gXCJoZWFkXCI7XG5leHBvcnQgY29uc3QgU1RZTEUgPSBcInN0eWxlXCI7XG5leHBvcnQgY29uc3QgQ0hBUkFDVEVSUyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuZXhwb3J0IGNvbnN0IFRXT19TUEFDRVMgPSBcIiAgXCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FX0xFTkdUSCA9IDY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMocXVlcnksIG5vZGUsIHRva2Vucykge1xuICBsZXQgY29udGVudCA9IG51bGw7XG5cbiAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICBpZiAobm9kZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3Qobm9kZXMpO1xuXG4gICAgbm9kZSA9IGZpcnN0Tm9kZTsgLy8vXG5cbiAgICBjb250ZW50ID0gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICBjb25zdCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSxcbiAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gIGxldCBjb250ZW50ID0gRU1QVFlfU1RSSU5HO1xuXG4gIGZvciAobGV0IGluZGV4ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXg7IGluZGV4IDw9IGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXg7IGluZGV4KyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpbmRleF0sXG4gICAgICAgICAgdG9rZW5Db250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpO1xuXG4gICAgY29udGVudCArPSB0b2tlbkNvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HLCBUV09fU1BBQ0VTIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcblxuY29uc3QgaW1wb3J0YW50UXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi8qL2ltcG9ydGFudFwiKSxcbiAgICAgIHByb3BlcnR5TmFtZVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9wcm9wZXJ0eU5hbWVcIiksXG4gICAgICBwcm9wZXJ0eVZhbHVlc1F1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9wcm9wZXJ0eVZhbHVlc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eVZhbHVlcywgcHJvcGVydHlOYW1lLCBpbXBvcnRhbnQpIHtcbiAgICB0aGlzLnByb3BlcnR5VmFsdWVzID0gcHJvcGVydHlWYWx1ZXM7XG4gICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQ7XG4gIH1cblxuICBnZXRQcm9wZXJ0eVZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eVZhbHVlcztcbiAgfVxuXG4gIGdldFByb3BlcnR5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eU5hbWU7XG4gIH1cblxuICBnZXRJbXBvcnRhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wb3J0YW50O1xuICB9XG5cbiAgbWF0Y2hQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9ICh0aGlzLnByb3BlcnR5TmFtZSA9PT0gcHJvcGVydHlOYW1lKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgbWF0Y2hEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGRlY2xhcmF0aW9uLmdldFByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLm1hdGNoUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSk7IC8vL1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBtYXRjaERlY2xhcmF0aW9ucyhkZWNsYXJhdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gZGVjbGFyYXRpb25zLnNvbWVEZWNsYXJhdGlvbigoZGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm1hdGNoRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50ICsgVFdPX1NQQUNFUztcblxuICAgIGNvbnN0IGNzcyA9IGAke2luZGVudH0ke3RoaXMucHJvcGVydHlOYW1lfTogJHt0aGlzLnByb3BlcnR5VmFsdWVzfSR7dGhpcy5pbXBvcnRhbnR9O1xcbmA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHByb3BlcnR5VmFsdWVzQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKHByb3BlcnR5VmFsdWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcHJvcGVydHlOYW1lQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKHByb3BlcnR5TmFtZVF1ZXJ5LCBub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGltcG9ydGFudENvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhpbXBvcnRhbnRRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwcm9wZXJ0eVZhbHVlcyA9IHByb3BlcnR5VmFsdWVzQ29udGVudCwgLy8vXG4gICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lQ29udGVudCwgLy8vXG4gICAgICAgICAgaW1wb3J0YW50ID0gKGltcG9ydGFudENvbnRlbnQgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgYCAke2ltcG9ydGFudENvbnRlbnR9YCxcbiAgICAgICAgICBkZWNsYXJhdGlvbiA9IG5ldyBEZWNsYXJhdGlvbihwcm9wZXJ0eVZhbHVlcywgcHJvcGVydHlOYW1lLCBpbXBvcnRhbnQpO1xuXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmb3J3YXJkc0ZvckVhY2gsIGJhY2t3YXJkc0ZvckVhY2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5jb25zdCBkZWNsYXJhdGlvblF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9kZWNsYXJhdGlvblwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb25zIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBzb21lRGVjbGFyYXRpb24oY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICBmb3J3YXJkc0ZvckVhY2hEZWNsYXJhdGlvbihjYWxsYmFjaykgeyBmb3J3YXJkc0ZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2spOyB9XG5cbiAgYmFja3dhcmRzRm9yRWFjaERlY2xhcmF0aW9uKGNhbGxiYWNrKSB7IGJhY2t3YXJkc0ZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2spOyB9XG5cbiAgdW5zaGlmdChkZWNsYXJhdGlvbnMpIHtcbiAgICBkZWNsYXJhdGlvbnMuYmFja3dhcmRzRm9yRWFjaERlY2xhcmF0aW9uKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGRlY2xhcmF0aW9uLm1hdGNoRGVjbGFyYXRpb25zKHRoaXMpOyAvLy9cblxuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChkZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uc0NTUyA9IHRoaXMuYXJyYXkucmVkdWNlKChkZWNsYXJhdGlvbnNDU1MsIGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbkNTUyA9IGRlY2xhcmF0aW9uLmFzQ1NTKGluZGVudCk7XG5cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyArPSBkZWNsYXJhdGlvbkNTUztcblxuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uc0NTUztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIGNzcyA9IChjbGFzc05hbWUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyA6ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ge1xuJHtkZWNsYXJhdGlvbnNDU1N9JHtpbmRlbnR9fVxuXG5gO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGVzID0gZGVjbGFyYXRpb25RdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGFycmF5ID0gZGVjbGFyYXRpb25Ob2Rlcy5tYXAoKGRlY2xhcmF0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGRlY2xhcmF0aW9uTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBuZXcgRGVjbGFyYXRpb25zKGFycmF5KTtcblxuICAgIHJldHVybiBkZWNsYXJhdGlvbnM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9ucyBmcm9tIFwiLi9kZWNsYXJhdGlvbnNcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcblxuY29uc3Qgc2VsZWN0b3JzUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi8vc2VsZWN0b3JzXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2V0IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3JzLCBkZWNsYXJhdGlvbnMpIHtcbiAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RvcnM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zO1xuICB9XG5cbiAgdW5zaGlmdChydWxlU2V0KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gcnVsZVNldC5nZXREZWNsYXJhdGlvbnMoKTtcblxuICAgIHRoaXMuZGVjbGFyYXRpb25zLnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgfVxuXG4gIGZpbmRNYXRjaGluZ1J1bGVTZXQocnVsZVNldHMpIHtcbiAgICBjb25zdCBtYXRjaGluZ1J1bGVTZXQgPSBydWxlU2V0cy5maW5kKChydWxlU2V0KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSBydWxlU2V0LmdldFNlbGVjdG9ycygpLFxuICAgICAgICAgICAgc2VsZWN0b3JzTWF0Y2ggPSAoc2VsZWN0b3JzID09PSB0aGlzLnNlbGVjdG9ycyksXG4gICAgICAgICAgICBydWxlU2V0c01hdGNoID0gc2VsZWN0b3JzTWF0Y2g7IC8vL1xuXG4gICAgICBpZiAocnVsZVNldHNNYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBtYXRjaGluZ1J1bGVTZXQ7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGxldCBjc3MgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhudWxsLCBpbmRlbnQpO1xuXG4gICAgaWYgKGRlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgY3NzID0gYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ke3RoaXMuc2VsZWN0b3JzfSB7XG4ke2RlY2xhcmF0aW9uc0NTU30ke2luZGVudH19XG5cbmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWxlY3RvcnNGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHJ1bGVTZXQgPSBuZXcgUnVsZVNldChzZWxlY3RvcnMsIGRlY2xhcmF0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZVNldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RvcnNGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3Qgc2VsZWN0b3JzTm9kZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhzZWxlY3RvcnNRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgc2VsZWN0b3JzID0gYCR7c2VsZWN0b3JzTm9kZUNvbnRlbnR9YDtcblxuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1xdWVyeVwiO1xuXG5pbXBvcnQgUnVsZVNldCBmcm9tIFwiLi9ydWxlU2V0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgcnVsZVNldFF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9ydWxlU2V0XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2V0cyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChydWxlU2V0cykge1xuICAgIHJ1bGVTZXRzLmZvckVhY2goKHJ1bGVTZXQpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nUnVsZVNldCA9IHJ1bGVTZXQuZmluZE1hdGNoaW5nUnVsZVNldCh0aGlzLmFycmF5KTsgLy8vXG5cbiAgICAgIChtYXRjaGluZ1J1bGVTZXQgPT09IG51bGwpID9cbiAgICAgICAgdGhpcy5hcnJheS51bnNoaWZ0KHJ1bGVTZXQpIDpcbiAgICAgICAgICBtYXRjaGluZ1J1bGVTZXQudW5zaGlmdChydWxlU2V0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spO1xuICB9XG5cbiAgYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpIHtcbiAgICBjb25zdCBjc3MgPSB0aGlzLmFycmF5LnJlZHVjZSgoY3NzLCBydWxlU2V0KSA9PiB7XG4gICAgICBjb25zdCBydWxlU2V0Q1NTID0gcnVsZVNldC5hc0NTUyhjbGFzc05hbWUsIGluZGVudCk7XG5cbiAgICAgIGNzcyArPSBydWxlU2V0Q1NTO1xuXG4gICAgICByZXR1cm4gY3NzO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHJ1bGVTZXROb2RlcyA9IHJ1bGVTZXRRdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGFycmF5ID0gcnVsZVNldE5vZGVzLm1hcCgocnVsZVNldE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBydWxlU2V0Tm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBydWxlU2V0ID0gUnVsZVNldC5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcnVsZVNldDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBydWxlU2V0cyA9IG5ldyBSdWxlU2V0cyhhcnJheSk7XG5cbiAgICByZXR1cm4gcnVsZVNldHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcbiAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1tcXG5cXHJdJC9nLCBFTVBUWV9TVFJJTkcpOyAgLy8vXG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3J1bGVTZXRzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyB0cmltIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcbmltcG9ydCB7IFRXT19TUEFDRVMsIEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IHF1ZXJpZXNRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiL21lZGlhL21lZGlhUXVlcmllc1wiKTsgLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhIHtcbiAgY29uc3RydWN0b3IoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgcXVlcmllcykge1xuICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgICB0aGlzLnF1ZXJpZXMgPSBxdWVyaWVzO1xuICB9XG5cbiAgZ2V0RGVjbGFyYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFJ1bGVTZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVTZXRzO1xuICB9XG5cbiAgZ2V0UXVlcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyaWVzO1xuICB9XG5cbiAgYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpIHtcbiAgICBpbmRlbnQgPSBpbmRlbnQgKyBUV09fU1BBQ0VTO1xuXG4gICAgbGV0IGNzcyA9IEVNUFRZX1NUUklORztcblxuICAgIGNvbnN0IHJ1bGVTZXRzQ1NTID0gdGhpcy5ydWxlU2V0cy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgZGVjbGFyYXRpb25zQ1NTID0gdGhpcy5kZWNsYXJhdGlvbnMuYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpO1xuXG4gICAgbGV0IHJ1bGVTZXRzRGVjbGFyYXRpb25zQ1NTID0gYCR7ZGVjbGFyYXRpb25zQ1NTfSR7cnVsZVNldHNDU1N9YDtcblxuICAgIGlmIChydWxlU2V0c0RlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICBydWxlU2V0c0RlY2xhcmF0aW9uc0NTUyA9IHRyaW0ocnVsZVNldHNEZWNsYXJhdGlvbnNDU1MpO1xuXG4gICAgICBjc3MgPSBgQG1lZGlhICR7dGhpcy5xdWVyaWVzfSB7XG4ke3J1bGVTZXRzRGVjbGFyYXRpb25zQ1NTfX1cblxuYDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHJ1bGVTZXRzID0gUnVsZVNldHMuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBxdWVyaWVzID0gcXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgbWVkaWEgPSBuZXcgTWVkaWEoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgcXVlcmllcyk7XG5cbiAgICByZXR1cm4gbWVkaWE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICBjb25zdCBxdWVyaWVzTm9kZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhxdWVyaWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgIHF1ZXJpZXMgPSBgJHtxdWVyaWVzTm9kZUNvbnRlbnR9YDtcblxuICByZXR1cm4gcXVlcmllcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IE1lZGlhIGZyb20gXCIuL21lZGlhXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgbWVkaWFRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiL3N0eWxlc2hlZXQvbWVkaWFcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChtZWRpYXMpIHtcbiAgICBtZWRpYXMuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChtZWRpYSk7XG4gICAgfSk7XG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgY29uc3QgY3NzID0gdGhpcy5hcnJheS5yZWR1Y2UoKGNzcywgbWVkaWEpID0+IHtcbiAgICAgIGNvbnN0IG1lZGlhQ1NTID0gbWVkaWEuYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpO1xuXG4gICAgICBjc3MgKz0gbWVkaWFDU1M7XG5cbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgbWVkaWFOb2RlcyA9IG1lZGlhUXVlcnkuZXhlY3V0ZShub2RlKSxcbiAgICAgICAgICBhcnJheSA9IG1lZGlhTm9kZXMubWFwKChtZWRpYU5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBtZWRpYU5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgbWVkaWEgPSBNZWRpYS5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWVkaWE7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFzID0gbmV3IE1lZGlhcyhhcnJheSk7XG5cbiAgICByZXR1cm4gbWVkaWFzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IHBlcmNlbnRhZ2VRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiLyovQHBlcmNlbnRhZ2VcIiksXG4gICAgICBkZWNsYXJhdGlvblF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9kZWNsYXJhdGlvblwiKTtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleWZyYW1lIHtcbiAgY29uc3RydWN0b3IocGVyY2VudGFnZSwgZGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgfVxuXG4gIGdldFBlcmNlbnRhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyY2VudGFnZTtcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25DU1MgPSB0aGlzLmRlY2xhcmF0aW9uLmFzQ1NTKGluZGVudCksXG4gICAgICAgICAgY3NzID0gYCR7aW5kZW50fSR7dGhpcy5wZXJjZW50YWdlfSB7IFxuJHtkZWNsYXJhdGlvbkNTU30ke2luZGVudH19XFxuYDtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgcGVyY2VudGFnZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhwZXJjZW50YWdlUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcGVyY2VudGFnZSA9IHBlcmNlbnRhZ2VDb250ZW50LCAvLy9cbiAgICAgICAgICBkZWNsYXJhdGlvbk5vZGVzID0gZGVjbGFyYXRpb25RdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGZpcnN0RGVjbGFyYXRpb25Ob2RlID0gZmlyc3QoZGVjbGFyYXRpb25Ob2RlcyksXG4gICAgICAgICAgZGVjbGFyYXRpb25Ob2RlID0gZmlyc3REZWNsYXJhdGlvbk5vZGU7IC8vL1xuXG4gICAgbm9kZSA9IGRlY2xhcmF0aW9uTm9kZTsgLy8vXG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAga2V5ZnJhbWUgPSBuZXcgS2V5ZnJhbWUocGVyY2VudGFnZSwgZGVjbGFyYXRpb24pO1xuXG4gICAgcmV0dXJuIGtleWZyYW1lO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmltcG9ydCBLZXlmcmFtZSBmcm9tIFwiLi9rZXlmcmFtZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcsIFRXT19TUEFDRVMgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29udGVudFwiO1xuXG5jb25zdCBrZXlmcmFtZVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIva2V5ZnJhbWVzL2tleWZyYW1lXCIpLFxuICAgICAgaWRlbnRpZmllclF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIva2V5ZnJhbWVzL0BpZGVudGlmaWVyXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlmcmFtZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSwgaWRlbnRpZmllcikge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICB9XG5cbiAgZ2V0SWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50ICsgVFdPX1NQQUNFUztcblxuICAgIGNvbnN0IGtleWZyYW1lc0NTUyA9IHRoaXMuYXJyYXkucmVkdWNlKChrZXlmcmFtZXNDU1MsIGtleWZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZUNTUyA9IGtleWZyYW1lLmFzQ1NTKGluZGVudCk7XG5cbiAgICAgICAgICAgIGtleWZyYW1lc0NTUyArPSBrZXlmcmFtZUNTUztcblxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lc0NTUztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIGNzcyA9IGBAa2V5ZnJhbWVzICR7dGhpcy5pZGVudGlmaWVyfSB7XG4ke2tleWZyYW1lc0NTU319XG5cbmA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGtleWZyYW1lTm9kZXMgPSBrZXlmcmFtZVF1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBrZXlmcmFtZU5vZGVzLm1hcCgoa2V5ZnJhbWVOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0ga2V5ZnJhbWVOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lID0gS2V5ZnJhbWUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGlkZW50aWZpZXJDb250ZW50ID0gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMoaWRlbnRpZmllclF1ZXJ5LCBub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyQ29udGVudCwgLy8vXG4gICAgICAgICAga2V5ZnJhbWVzID0gbmV3IEtleWZyYW1lcyhhcnJheSwgaWRlbnRpZmllcik7XG5cbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmltcG9ydCBLZXlmcmFtZXMgZnJvbSBcIi4va2V5ZnJhbWVzXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3Qga2V5ZnJhbWVzUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi9zdHlsZXNoZWV0L2tleWZyYW1lc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5ZnJhbWVzcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChrZXlmcmFtZXNzKSB7XG4gICAgLy8vXG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgY29uc3QgY3NzID0gdGhpcy5hcnJheS5yZWR1Y2UoKGNzcywga2V5ZnJhbWVzKSA9PiB7XG4gICAgICBjb25zdCBrZXlmcmFtZXNDU1MgPSBrZXlmcmFtZXMuYXNDU1MoaW5kZW50KTtcblxuICAgICAgY3NzICs9IGtleWZyYW1lc0NTUztcblxuICAgICAgcmV0dXJuIGNzcztcbiAgICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBrZXlmcmFtZXNOb2RlcyA9IGtleWZyYW1lc1F1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBrZXlmcmFtZXNOb2Rlcy5tYXAoKGtleWZyYW1lc05vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBrZXlmcmFtZXNOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcyA9IEtleWZyYW1lcy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBuZXcgS2V5ZnJhbWVzcyhhcnJheSk7XG5cbiAgICByZXR1cm4ga2V5ZnJhbWVzcztcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWVkaWFzIGZyb20gXCIuL3N0eWxlL21lZGlhc1wiO1xuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3N0eWxlL3J1bGVTZXRzXCI7XG5pbXBvcnQgS2V5ZnJhbWVzcyBmcm9tIFwiLi9zdHlsZS9rZXlmcmFtZXNzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL3N0eWxlL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3R5bGUge1xuICBjb25zdHJ1Y3RvcihkZWNsYXJhdGlvbnMsIGtleWZyYW1lc3MsIHJ1bGVTZXRzLCBtZWRpYXMpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgICB0aGlzLmtleWZyYW1lc3MgPSBrZXlmcmFtZXNzO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgICB0aGlzLm1lZGlhcyA9IG1lZGlhcztcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnM7XG4gIH1cblxuICBnZXRLZXlmcmFtZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmtleWZyYW1lc3M7XG4gIH1cblxuICBnZXRSdWxlU2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlU2V0cztcbiAgfVxuXG4gIGdldE1lZGlhcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZWRpYXM7XG4gIH1cblxuICBleHRlbmRzKHN1cGVyU3R5bGUpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBzdXBlclN0eWxlLmdldERlY2xhcmF0aW9ucygpLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBzdXBlclN0eWxlLmdldEtleWZyYW1lc3MoKSxcbiAgICAgICAgICBydWxlU2V0cyA9IHN1cGVyU3R5bGUuZ2V0UnVsZVNldHMoKSxcbiAgICAgICAgICBtZWRpYXMgPSBzdXBlclN0eWxlLmdldE1lZGlhcygpO1xuXG4gICAgdGhpcy51bnNoaWZ0KGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcyk7XG4gIH1cblxuICB1bnNoaWZ0KGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcykge1xuICAgIHRoaXMuZGVjbGFyYXRpb25zLnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgICB0aGlzLmtleWZyYW1lc3MudW5zaGlmdChrZXlmcmFtZXNzKTtcbiAgICB0aGlzLnJ1bGVTZXRzLnVuc2hpZnQocnVsZVNldHMpO1xuICAgIHRoaXMubWVkaWFzLnVuc2hpZnQobWVkaWFzKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IGluZGVudCA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAga2V5ZnJhbWVzc0NTUyA9IHRoaXMua2V5ZnJhbWVzcy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgcnVsZVNldHNDU1MgPSB0aGlzLnJ1bGVTZXRzLmFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSxcbiAgICAgICAgICBtZWRpYXNDU1MgPSB0aGlzLm1lZGlhcy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgY3NzID0gYCR7ZGVjbGFyYXRpb25zQ1NTfSR7a2V5ZnJhbWVzc0NTU30ke3J1bGVTZXRzQ1NTfSR7bWVkaWFzQ1NTfWA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBLZXlmcmFtZXNzLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcnVsZVNldHMgPSBSdWxlU2V0cy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIG1lZGlhcyA9IE1lZGlhcy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHN0eWxlID0gbmV3IFN0eWxlKGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcyk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0eWxlIGZyb20gXCIuLi9zdHlsZVwiO1xuaW1wb3J0IENTU0xleGVyIGZyb20gXCIuLi9jc3MvbGV4ZXJcIjtcbmltcG9ydCBDU1NQYXJzZXIgZnJvbSBcIi4uL2Nzcy9wYXJzZXJcIjtcblxuaW1wb3J0IHsgSEVBRCwgU1RZTEUsIEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgY3NzTGV4ZXIgPSBDU1NMZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgY3NzUGFyc2VyID0gQ1NTUGFyc2VyLmZyb21Ob3RoaW5nKCk7XG5cbmlmICghZ2xvYmFsVGhpcy5zdHlsZU1hcCkge1xuICBnbG9iYWxUaGlzLnN0eWxlTWFwID0ge307XG59XG5cbmNvbnN0IHsgc3R5bGVNYXAgfSA9IGdsb2JhbFRoaXM7XG5cbmZ1bmN0aW9uIHJlbmRlclN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IGhlYWRET01FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihIRUFEKSxcbiAgICAgICAgc3R5bGVET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChTVFlMRSksXG4gICAgICAgIGlubmVySFRNTCA9IGAgICAgICAgIFxuJHtzdHlsZX1cbmA7XG5cbiAgT2JqZWN0LmFzc2lnbihzdHlsZURPTUVsZW1lbnQsIHtcbiAgICBpbm5lckhUTUxcbiAgfSk7XG5cbiAgaGVhZERPTUVsZW1lbnQuYXBwZW5kQ2hpbGQoc3R5bGVET01FbGVtZW50KTtcblxuICByZXR1cm4gc3R5bGVET01FbGVtZW50O1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdHlsZXMoKSB7XG4gIGNvbnN0IHN0eWxlc0NTUyA9IHJldHJpZXZlU3R5bGVzQ1NTKCksXG4gICAgICAgIHN0eWxlID0gc3R5bGVzQ1NTOyAgLy8vXG5cbiAgcmVuZGVyU3R5bGUoc3R5bGUpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSwgc3VwZXJTdHlsZSA9IG51bGwpIHtcbiAgY29uc3Qgc3RyaW5ncyA9IGFyZ3Muc2hpZnQoKSxcdC8vL1xuICAgICAgICBjb250ZW50ID0gc3RyaW5ncy5yZWR1Y2UoKGNvbnRlbnQsIHN0cmluZywgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XSB8fCBudWxsO1xuXG4gICAgICAgICAgY29udGVudCA9IChhcmcgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICBgJHtjb250ZW50fSR7c3RyaW5nfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7Y29udGVudH0ke3N0cmluZ30ke2FyZ31gO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0sIEVNUFRZX1NUUklORyksXG4gICAgICAgIHRva2VucyA9IGNzc0xleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3NzUGFyc2VyLnBhcnNlKHRva2VucyksXG4gICAgICAgIHN0eWxlID0gU3R5bGUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICBpZiAoc3VwZXJTdHlsZSAhPT0gbnVsbCkge1xuICAgIHN0eWxlLmV4dGVuZHMoc3VwZXJTdHlsZSk7XG4gIH1cblxuICBzdHlsZU1hcFtjbGFzc05hbWVdID0gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlU3R5bGUoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVNYXBbY2xhc3NOYW1lXSB8fCBudWxsO1xuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzLFxuICBnZW5lcmF0ZVN0eWxlLFxuICByZXRyaWV2ZVN0eWxlXG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZVN0eWxlc0NTUygpIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlTWFwKSxcbiAgICAgICAgc3R5bGVzQ1NTID0gY2xhc3NOYW1lcy5yZWR1Y2UoKHN0eWxlc0NTUywgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgc3R5bGVDU1MgPSBzdHlsZS5hc0NTUyhjbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3R5bGVzQ1NTICs9IHN0eWxlQ1NTO1xuXG4gICAgICAgICAgcmV0dXJuIHN0eWxlc0NTUztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gc3R5bGVzQ1NTO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDSEFSQUNURVJTLCBFTVBUWV9TVFJJTkcsIENMQVNTX05BTUVfTEVOR1RIIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCBsZW5ndGggPSBDTEFTU19OQU1FX0xFTkdUSCxcbiAgICAgIGNoYXJhY3RlcnMgPSBDSEFSQUNURVJTLFxuICAgICAgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuXG5jb25zdCBjbGFzc05hbWVzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNsYXNzTmFtZSgpIHtcbiAgbGV0IGNsYXNzTmFtZSA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgbGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXJzW2luZGV4XTtcblxuICAgIGNsYXNzTmFtZSArPSBjaGFyYWN0ZXI7XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUgPSBjbGFzc05hbWVzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG5cbiAgaWYgKCFjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlQ2xhc3NOYW1lKGVsZW1lbnQpIHtcbiAgY29uc3QgeyBjbGFzc05hbWUgfSA9IGVsZW1lbnQucmVhY3RGdW5jdGlvbiB8fCBlbGVtZW50LnJlYWN0Q29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2VuZXJhdGVDbGFzc05hbWUsXG4gIHJldHJpZXZlQ2xhc3NOYW1lXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHRhZ05hbWVzIH0gZnJvbSBcIi4vdGFnTmFtZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTTGV4ZXIgfSBmcm9tIFwiLi9jc3MvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTUGFyc2VyIH0gZnJvbSBcIi4vY3NzL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHlsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3R5bGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsYXNzTmFtZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc05hbWVcIjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGFzcyhhcmd1bWVudCkgeyByZXR1cm4gaXNTdWJjbGFzc09mKGFyZ3VtZW50LCBFbGVtZW50KTsgfSAgLy8vXG5cbmZ1bmN0aW9uIGlzU3ViY2xhc3NPZihhcmd1bWVudCwgQ2xhc3MpIHtcbiAgY29uc3Qgc3ViY2xhc3NPZiA9IChhcmd1bWVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBDbGFzcyk7XG5cbiAgcmV0dXJuIHN1YmNsYXNzT2Y7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FID0gXCJjbGFzc05hbWVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUmVhY3QgfSBmcm9tIFwiZWFzeVwiO1xuaW1wb3J0IHsgdGFnTmFtZXMsIHN0eWxlc1V0aWxpdGllcywgY2xhc3NOYW1lVXRpbGl0aWVzIH0gZnJvbSBcIndpdGgtc3R5bGVcIjtcblxuaW1wb3J0IHsgaXNDbGFzcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc1wiO1xuaW1wb3J0IHsgQ0xBU1NfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IGdlbmVyYXRlQ2xhc3NOYW1lIH0gPSBjbGFzc05hbWVVdGlsaXRpZXMsXG4gICAgICB7IHJlbmRlclN0eWxlLCByZW5kZXJTdHlsZXMsIGdlbmVyYXRlU3R5bGUsIHJldHJpZXZlU3R5bGUgfSA9IHN0eWxlc1V0aWxpdGllcztcblxuZnVuY3Rpb24gd2l0aFN0eWxlKENsYXNzT3JGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYXJncyA9IFsgLi4uYXJndW1lbnRzIF07ICAvLy9cblxuICAgIGxldCB7IGNsYXNzTmFtZSA9IG51bGwgfSA9IENsYXNzT3JGdW5jdGlvbjtcblxuICAgIGNvbnN0IHN1cGVyU3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSk7XG5cbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuXG4gICAgZ2VuZXJhdGVTdHlsZShhcmdzLCBjbGFzc05hbWUsIHN1cGVyU3R5bGUpO1xuXG4gICAgY29uc3QgQ2xhc3NPckZ1bmN0aW9uQ2xhc3MgPSBpc0NsYXNzKENsYXNzT3JGdW5jdGlvbik7XG5cbiAgICBpZiAoQ2xhc3NPckZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgIGNvbnN0IENsYXNzID0gQ2xhc3NPckZ1bmN0aW9uOyAgLy8vXG5cbiAgICAgIENsYXNzT3JGdW5jdGlvbiA9IGNsYXNzIGV4dGVuZHMgQ2xhc3Mge1xuICAgICAgICBzdGF0aWMgZnJvbUNsYXNzKF9DbGFzcywgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgcmV0dXJuIENsYXNzLmZyb21DbGFzcyhfQ2xhc3MsIHByb3BlcnRpZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgRnVuY3Rpb24gPSBDbGFzc09yRnVuY3Rpb247IC8vL1xuXG4gICAgICBDbGFzc09yRnVuY3Rpb24gPSAocHJvcGVydGllcykgPT4ge1xuICAgICAgICBwcm9wZXJ0aWVzID0gYXBwZW5kQ2xhc3NOYW1lVG9Qcm9wZXJ0aWVzKGNsYXNzTmFtZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKHByb3BlcnRpZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKENsYXNzT3JGdW5jdGlvbiwge1xuICAgICAgY2xhc3NOYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ2xhc3NPckZ1bmN0aW9uO1xuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKHdpdGhTdHlsZSwge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlO1xuXG50YWdOYW1lcy5mb3JFYWNoKCh0YWdOYW1lKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aXRoU3R5bGUsIHRhZ05hbWUsIHtcbiAgICBnZXQ6ICgpID0+IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYXJncyA9IFsuLi5hcmd1bWVudHNdLCAgLy8vXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuXG4gICAgICBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSk7XG5cbiAgICAgIGNvbnN0IEZ1bmN0aW9uID0gKHByb3BlcnRpZXMpID0+IHtcbiAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmFzc2lnbihGdW5jdGlvbiwge1xuICAgICAgICBjbGFzc05hbWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gRnVuY3Rpb247XG4gICAgfVxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBhcHBlbmRDbGFzc05hbWVUb1Byb3BlcnRpZXMoY2xhc3NOYW1lLCBwcm9wZXJ0aWVzKSB7XG4gIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KENMQVNTX05BTUUpID8gcHJvcGVydGllcyA6IHsgLi4ucHJvcGVydGllcywgY2xhc3NOYW1lIH07IC8vL1xuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCIuL3dpdGhTdHlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDVVJTT1IgPSBcImN1cnNvclwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgQVVUT19DVVJTT1IgPSBcImF1dG9cIjtcbmV4cG9ydCBjb25zdCBQT0lOVEVSX0NVUlNPUiA9IFwicG9pbnRlclwiO1xuZXhwb3J0IGNvbnN0IENPTF9SRVNJWkVfQ1VSU09SID0gXCJjb2wtcmVzaXplXCI7XG5leHBvcnQgY29uc3QgUk9XX1JFU0laRV9DVVJTT1IgPSBcInJvdy1yZXNpemVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQm9keSB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCB7IENVUlNPUiB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQVVUT19DVVJTT1IsIFBPSU5URVJfQ1VSU09SLCBDT0xfUkVTSVpFX0NVUlNPUiwgUk9XX1JFU0laRV9DVVJTT1IgfSBmcm9tIFwiLi9jdXJzb3JzXCI7XG5cbmNvbnN0IGJvZHkgPSBuZXcgQm9keSgpO1xuXG5sZXQgcHJldmlvdXNDdXJzb3I7ICAvLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9DdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IEFVVE9fQ1VSU09SO1xuXG4gIHVwZGF0ZUN1cnNvcihjdXJzb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDdXJzb3IoKSB7XG4gIHNldEN1cnNvcihwcmV2aW91c0N1cnNvcik7IC8vL1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlckN1cnNvcigpIHtcbiAgY29uc3QgY3Vyc29yID0gUE9JTlRFUl9DVVJTT1I7XG5cbiAgdXBkYXRlQ3Vyc29yKGN1cnNvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3dSZXNpemVDdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IFJPV19SRVNJWkVfQ1VSU09SO1xuXG4gIHVwZGF0ZUN1cnNvcihjdXJzb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sdW1uUmVzaXplQ3Vyc29yKCkge1xuICBjb25zdCBjdXJzb3IgPSBDT0xfUkVTSVpFX0NVUlNPUjtcblxuICB1cGRhdGVDdXJzb3IoY3Vyc29yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhdXRvQ3Vyc29yLFxuICByZXNldEN1cnNvcixcbiAgcG9pbnRlckN1cnNvcixcbiAgcm93UmVzaXplQ3Vyc29yLFxuICBjb2x1bW5SZXNpemVDdXJzb3Jcbn1cblxuZnVuY3Rpb24gc2V0Q3Vyc29yKGN1cnNvcikge1xuICBjb25zdCBjc3MgPSB7XG4gICAgY3Vyc29yXG4gIH07XG5cbiAgYm9keS5jc3MoY3NzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKGN1cnNvcikge1xuICBjb25zdCBjdXJyZW50Q3Vyc29yID0gZ2V0Q3VycmVudEN1cnNvcigpO1xuXG4gIGlmIChjdXJyZW50Q3Vyc29yICE9PSBjdXJzb3IpIHtcbiAgICBwcmV2aW91c0N1cnNvciA9IGN1cnJlbnRDdXJzb3I7IC8vL1xuXG4gICAgc2V0Q3Vyc29yKGN1cnNvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEN1cnNvcigpIHtcbiAgY29uc3QgY3VycmVudEN1cnNvciA9IGJvZHkuY3NzKENVUlNPUikgfHwgQVVUT19DVVJTT1I7XG5cbiAgcmV0dXJuIGN1cnJlbnRDdXJzb3I7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBSb3dEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwicm93XCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFJvd0RpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgUm93c0RpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJyb3dzXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFJvd3NEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZ3JvdzogMTtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmNsYXNzIENvbHVtbkRpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb2x1bW5cIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoQ29sdW1uRGl2KWBcblxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWdyb3c6IDE7XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBDb2x1bW5zRGl2IGV4dGVuZHMgRWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImNvbHVtbnNcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoQ29sdW1uc0RpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfRFJBR0dJTkdfREVMQVkgPSAxNzU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50KGRyYWdFbGVtZW50LCBkcm9wRWxlbWVudCkge1xuICBjb25zdCByZWZlcmVuY2UgPSBkcm9wRWxlbWVudC5nZXRSZWZlcmVuY2UoKSxcbiAgICAgICAgcmVmZXJlbmNlcyA9IGRyYWdFbGVtZW50LmdldFJlZmVyZW5jZXMoKSxcbiAgICAgICAgcmVmZXJlbmNlc0luY2x1ZGVzUmVmZXJlbmNlID0gcmVmZXJlbmNlcy5pbmNsdWRlcyhyZWZlcmVuY2UpLFxuICAgICAgICBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9ICFyZWZlcmVuY2VzSW5jbHVkZXNSZWZlcmVuY2U7XG5cbiAgcmV0dXJuIGRyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50O1xufSIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdXNlVG9wRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IHsgcGFnZVkgfSA9IGV2ZW50LFxuICAgICAgICBtb3VzZVRvcCA9IHBhZ2VZOyAvLy9cblxuICByZXR1cm4gbW91c2VUb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VzZUxlZnRGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgeyBwYWdlWCB9ID0gZXZlbnQsXG4gICAgICAgIG1vdXNlTGVmdCA9IHBhZ2VYOyAgLy8vXG5cbiAgcmV0dXJuIG1vdXNlTGVmdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcImRyYWdcIjtcbmV4cG9ydCBjb25zdCBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFID0gXCJkcm9wXCI7XG5leHBvcnQgY29uc3QgRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcImRyYWctb3V0XCI7XG5leHBvcnQgY29uc3QgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFID0gXCJkcmFnLW92ZXJcIjtcbmV4cG9ydCBjb25zdCBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcInN0b3AtZHJhZ1wiO1xuZXhwb3J0IGNvbnN0IFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcInN0YXJ0LWRyYWdcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBEUkFHX09VVF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gIFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGtleUNvZGVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiIDtcbmltcG9ydCB7IHdpbmRvdywgbW91c2VCdXR0b25zIH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IHsgU1RBUlRfRFJBR0dJTkdfREVMQVkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9yZWZlcmVuY2VcIjtcbmltcG9ydCB7IG1vdXNlVG9wRnJvbUV2ZW50LCBtb3VzZUxlZnRGcm9tRXZlbnQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2V2ZW50XCI7XG5pbXBvcnQgeyBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLCBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsIFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vY3VzdG9tRXZlbnRUeXBlc1wiO1xuXG5jb25zdCB7IEVTQ0FQRV9LRVlfQ09ERSB9ID0ga2V5Q29kZXMsXG4gICAgICB7IExFRlRfTU9VU0VfQlVUVE9OIH0gPSBtb3VzZUJ1dHRvbnM7XG5cbmZ1bmN0aW9uIGdldERyYWdFbGVtZW50KCkge1xuICBjb25zdCB7IGRyYWdFbGVtZW50IH0gPSBnbG9iYWxUaGlzO1xuXG4gIHJldHVybiBkcmFnRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gc2V0RHJhZ0VsZW1lbnQoZHJhZ0VsZW1lbnQpIHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gICAgZHJhZ0VsZW1lbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0RHJhZ0VsZW1lbnQoKSB7XG4gIGNvbnN0IGRyYWdFbGVtZW50ID0gbnVsbDtcblxuICBzZXREcmFnRWxlbWVudChkcmFnRWxlbWVudCk7XG59XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywge1xuICBnZXREcmFnRWxlbWVudCxcbiAgc2V0RHJhZ0VsZW1lbnQsXG4gIHJlc2V0RHJhZ0VsZW1lbnRcbn0pO1xuXG5yZXNldERyYWdFbGVtZW50KCk7XG5cbmZ1bmN0aW9uIGVuYWJsZURyYWcoKSB7XG4gIGNvbnN0IHRpbWVvdXQgPSBudWxsLFxuICAgICAgICB0b3BPZmZzZXQgPSBudWxsLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgZHJhZ0VuYWJsZWQgPSB0cnVlLFxuICAgICAgICBzdGFydE1vdXNlVG9wID0gbnVsbCxcbiAgICAgICAgc3RhcnRNb3VzZUxlZnQgPSBudWxsO1xuXG4gIHRoaXMub25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgdGltZW91dCxcbiAgICB0b3BPZmZzZXQsXG4gICAgbGVmdE9mZnNldCxcbiAgICBkcmFnRW5hYmxlZCxcbiAgICBzdGFydE1vdXNlVG9wLFxuICAgIHN0YXJ0TW91c2VMZWZ0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlRHJhZygpIHtcbiAgY29uc3QgZHJhZ0VuYWJsZWQgPSBmYWxzZTtcblxuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBkcmFnRW5hYmxlZFxuICB9KTtcblxuICB0aGlzLm9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25DdXN0b21EcmFnKGRyYWdDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnKGRyYWdDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub2ZmQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb25DdXN0b21TdG9wRHJhZyhzdG9wRHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RPUF9EUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gc3RvcERyYWdDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZkN1c3RvbVN0b3BEcmFnKHN0b3BEcmFnQ3VzdG9tSGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBjdXN0b21FdmVudFR5cGUgPSBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBzdG9wRHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9uQ3VzdG9tU3RhcnREcmFnKHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RBUlRfRFJBR19DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9uQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb2ZmQ3VzdG9tU3RhcnREcmFnKHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RBUlRfRFJBR19DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzRHJhZ0VuYWJsZWQoKSB7XG4gIGNvbnN0IHsgZHJhZ0VuYWJsZWQgPSBmYWxzZSB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBkcmFnRW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmhhc0NsYXNzKFwiZHJhZ2dpbmdcIik7XG5cbiAgcmV0dXJuIGRyYWdnaW5nO1xufVxuXG5mdW5jdGlvbiBzdGFydERyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgYm91bmRzVG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICBib3VuZHNMZWZ0ID0gYm91bmRzLmdldExlZnQoKSxcbiAgICAgICAgYm91bmRzUmlnaHQgPSBib3VuZHMuZ2V0UmlnaHQoKSxcbiAgICAgICAgYm91bmRzQm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kc1JpZ2h0IC0gYm91bmRzTGVmdCxcbiAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzQm90dG9tIC0gYm91bmRzVG9wLFxuICAgICAgICB0b3BPZmZzZXQgPSBNYXRoLmZsb29yKGJvdW5kc0hlaWdodCAvIDIpLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gTWF0aC5mbG9vcihib3VuZHNXaWR0aCAvIDIpLFxuICAgICAgICBkcmFnRWxlbWVudCA9IHRoaXMsIC8vL1xuICAgICAgICBzdGFydE1vdXNlVG9wID0gbW91c2VUb3AsIC8vL1xuICAgICAgICBzdGFydE1vdXNlTGVmdCA9IG1vdXNlTGVmdCwgLy8vXG4gICAgICAgIGN1c3RvbUV2ZW50VHlwZSA9IFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEU7XG5cbiAgd2luZG93Lm9uS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9uTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIHRoaXMpO1xuXG4gIHRoaXMuYWRkQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICBzZXREcmFnRWxlbWVudChkcmFnRWxlbWVudCk7XG5cbiAgdGhpcy5zZXRUb3BPZmZzZXQodG9wT2Zmc2V0KTtcblxuICB0aGlzLnNldExlZnRPZmZzZXQobGVmdE9mZnNldCk7XG5cbiAgdGhpcy5zZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApO1xuXG4gIHRoaXMuc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpO1xuXG4gIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQpO1xuXG4gIHRoaXMuZHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BEcmFnKGV2ZW50LCBlbGVtZW50LCBhYm9ydGVkKSB7XG4gIGNvbnN0IGRyb3BFbGVtZW50ID0gZ2V0RHJvcEVsZW1lbnQoKSxcbiAgICAgICAgY3VzdG9tRXZlbnRUeXBlID0gU1RPUF9EUkFHX0NVU1RPTV9FVkVOVF9UWVBFO1xuXG4gIHRoaXMucmVtb3ZlQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICB3aW5kb3cub2ZmS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9mZk1vdXNlTW92ZShtb3VzZU1vdmVIYW5kbGVyLCB0aGlzKTtcblxuICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzQXN5bmMoY3VzdG9tRXZlbnRUeXBlLCBldmVudCwgZWxlbWVudCwgZHJvcEVsZW1lbnQsIGFib3J0ZWQsICgpID0+IHtcbiAgICAgIHJlc2V0RHJhZ0VsZW1lbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkcm9wRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxldCBkcmFnRWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgY29uc3QgZHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQgPSBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50KGRyYWdFbGVtZW50LCBkcm9wRWxlbWVudCk7XG5cbiAgICBpZiAoZHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQpIHtcbiAgICAgIGRyYWdFbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkcm9wRWxlbWVudC5kcm9wKGV2ZW50LCBlbGVtZW50LCBkcmFnRWxlbWVudCwgYWJvcnRlZCwgZG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LmdldFNjcm9sbFRvcCgpLFxuICAgICAgICBzY3JvbGxMZWZ0ID0gd2luZG93LmdldFNjcm9sbExlZnQoKSxcbiAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICBzdGFydE1vdXNlVG9wID0gdGhpcy5nZXRTdGFydE1vdXNlVG9wKCksXG4gICAgICAgIHN0YXJ0TW91c2VMZWZ0ID0gdGhpcy5nZXRTdGFydE1vdXNlTGVmdCgpLFxuICAgICAgICBjdXN0b21FdmVudFR5cGUgPSBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICByZWxhdGl2ZU1vdXNlVG9wID0gbW91c2VUb3AgLSBzdGFydE1vdXNlVG9wLFxuICAgICAgICByZWxhdGl2ZU1vdXNlTGVmdCA9IG1vdXNlTGVmdCAtIHN0YXJ0TW91c2VMZWZ0O1xuXG4gIGxldCB0b3AgPSBzdGFydE1vdXNlVG9wICsgcmVsYXRpdmVNb3VzZVRvcCAtIHRvcE9mZnNldCAtIHNjcm9sbFRvcCxcbiAgICAgIGxlZnQgPSBzdGFydE1vdXNlTGVmdCArIHJlbGF0aXZlTW91c2VMZWZ0IC0gbGVmdE9mZnNldCAtIHNjcm9sbExlZnQ7XG5cbiAgdG9wID0gYCR7dG9wfXB4YDsgLy8vXG4gIGxlZnQgPSBgJHtsZWZ0fXB4YDsgLy8vXG5cbiAgY29uc3QgY3NzID0ge1xuICAgIHRvcCxcbiAgICBsZWZ0XG4gIH07XG5cbiAgdGhpcy5jc3MoY3NzKTtcblxuICB0aGlzLmNhbGxDdXN0b21IYW5kbGVycyhjdXN0b21FdmVudFR5cGUsIGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2FpdGluZ1RvRHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCkge1xuICBsZXQgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ID09PSBudWxsKSB7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcblxuICAgICAgdGhpcy5zdGFydERyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpO1xuICAgIH0sIFNUQVJUX0RSQUdHSU5HX0RFTEFZKTtcblxuICAgIHRoaXMudXBkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV2FpdGluZ1RvRHJhZygpIHtcbiAgY29uc3QgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0KCkge1xuICBjb25zdCB7IHRpbWVvdXQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICByZXR1cm4gdGltZW91dDtcbn1cblxuZnVuY3Rpb24gcmVzZXRUaW1lb3V0KCkge1xuICBjb25zdCB0aW1lb3V0ID0gbnVsbDtcblxuICB0aGlzLnVwZGF0ZVRpbWVvdXQodGltZW91dCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVvdXQodGltZW91dCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0aW1lb3V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BPZmZzZXQoKSB7XG4gIGNvbnN0IHsgdG9wT2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIHRvcE9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCgpIHtcbiAgY29uc3QgeyBsZWZ0T2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIGxlZnRPZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0TW91c2VUb3AoKSB7XG4gIGNvbnN0IHsgc3RhcnRNb3VzZVRvcCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlVG9wO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydE1vdXNlTGVmdCgpIHtcbiAgY29uc3QgeyBzdGFydE1vdXNlTGVmdCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlTGVmdDtcbn1cblxuZnVuY3Rpb24gc2V0VG9wT2Zmc2V0KHRvcE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0b3BPZmZzZXRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldExlZnRPZmZzZXQobGVmdE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBsZWZ0T2Zmc2V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZVRvcFxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZUxlZnRcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW5hYmxlRHJhZyxcbiAgZGlzYWJsZURyYWcsXG4gIG9uQ3VzdG9tRHJhZyxcbiAgb2ZmQ3VzdG9tRHJhZyxcbiAgb25DdXN0b21TdG9wRHJhZyxcbiAgb2ZmQ3VzdG9tU3RvcERyYWcsXG4gIG9uQ3VzdG9tU3RhcnREcmFnLFxuICBvZmZDdXN0b21TdGFydERyYWcsXG4gIGlzRHJhZ0VuYWJsZWQsXG4gIGlzRHJhZ2dpbmcsXG4gIHN0YXJ0RHJhZyxcbiAgc3RvcERyYWcsXG4gIGRyYWcsXG4gIHN0YXJ0V2FpdGluZ1RvRHJhZyxcbiAgc3RvcFdhaXRpbmdUb0RyYWcsXG4gIGdldFRpbWVvdXQsXG4gIHJlc2V0VGltZW91dCxcbiAgdXBkYXRlVGltZW91dCxcbiAgZ2V0VG9wT2Zmc2V0LFxuICBnZXRMZWZ0T2Zmc2V0LFxuICBnZXRTdGFydE1vdXNlVG9wLFxuICBnZXRTdGFydE1vdXNlTGVmdCxcbiAgc2V0VG9wT2Zmc2V0LFxuICBzZXRMZWZ0T2Zmc2V0LFxuICBzZXRTdGFydE1vdXNlVG9wLFxuICBzZXRTdGFydE1vdXNlTGVmdFxufTtcblxuZnVuY3Rpb24ga2V5RG93bkhhbmRsZXIoZXZlbnQsIGVsZW1lbnQpIHtcbiAgY29uc3QgeyBrZXlDb2RlIH0gPSBldmVudCxcbiAgICAgICAgZXNjYXBlS2V5ID0gKGtleUNvZGUgPT09IEVTQ0FQRV9LRVlfQ09ERSksXG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuXG4gIGlmIChlc2NhcGVLZXkpIHtcbiAgICB0aGlzLnN0b3BEcmFnKGV2ZW50LCBlbGVtZW50LCBhYm9ydGVkKTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNlVXBIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCksXG4gICAgICAgIGFib3J0ZWQgPSBmYWxzZTtcblxuICBkcmFnZ2luZyA/XG4gICAgdGhpcy5zdG9wRHJhZyhldmVudCwgZWxlbWVudCwgYWJvcnRlZCkgOlxuICAgICAgdGhpcy5zdG9wV2FpdGluZ1RvRHJhZygpO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIHdpbmRvdy5vZmZCbHVyKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTsgIC8vL1xuXG4gIHdpbmRvdy5vZmZNb3VzZVVwKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gbW91c2VEb3duSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCB7IGJ1dHRvbiB9ID0gZXZlbnQ7XG5cbiAgaWYgKGJ1dHRvbiA9PT0gTEVGVF9NT1VTRV9CVVRUT04pIHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpO1xuXG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgY29uc3QgbW91c2VUb3AgPSBtb3VzZVRvcEZyb21FdmVudChldmVudCksXG4gICAgICAgICAgICBtb3VzZUxlZnQgPSBtb3VzZUxlZnRGcm9tRXZlbnQoZXZlbnQpO1xuXG4gICAgICB0aGlzLnN0YXJ0V2FpdGluZ1RvRHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gICAgfVxuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgd2luZG93Lm9uQmx1cihtb3VzZVVwSGFuZGxlciwgdGhpcyk7IC8vL1xuXG4gIHdpbmRvdy5vbk1vdXNlVXAobW91c2VVcEhhbmRsZXIsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBtb3VzZU1vdmVIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XG5cbiAgaWYgKGRyYWdnaW5nKSB7XG4gICAgY29uc3QgbW91c2VUb3AgPSBtb3VzZVRvcEZyb21FdmVudChldmVudCksXG4gICAgICAgICAgbW91c2VMZWZ0ID0gbW91c2VMZWZ0RnJvbUV2ZW50KGV2ZW50KTtcblxuICAgIHRoaXMuZHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hlY2tEcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFLCBEUkFHX09VVF9DVVNUT01fRVZFTlRfVFlQRSwgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2N1c3RvbUV2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gZ2V0RHJvcEVsZW1lbnQoKSB7XG4gIGNvbnN0IHsgZHJvcEVsZW1lbnQgfSA9IGdsb2JhbFRoaXM7XG5cbiAgcmV0dXJuIGRyb3BFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBzZXREcm9wRWxlbWVudChkcm9wRWxlbWVudCkge1xuICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgICBkcm9wRWxlbWVudFxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXREcm9wRWxlbWVudCgpIHtcbiAgY29uc3QgZHJvcEVsZW1lbnQgPSBudWxsO1xuXG4gIHNldERyb3BFbGVtZW50KGRyb3BFbGVtZW50KTtcbn1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gIGdldERyb3BFbGVtZW50LFxuICBzZXREcm9wRWxlbWVudCxcbiAgcmVzZXREcm9wRWxlbWVudFxufSk7XG5cbnJlc2V0RHJvcEVsZW1lbnQoKTtcblxuZnVuY3Rpb24gZHJvcChldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQsIGFib3J0ZWQsIGRvbmUpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRTtcblxuICB0aGlzLmNhbGxDdXN0b21IYW5kbGVyc0FzeW5jKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50LCBhYm9ydGVkLCBkb25lKTtcbn1cblxuZnVuY3Rpb24gZHJhZ091dChldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEU7XG5cbiAgdGhpcy5jYWxsQ3VzdG9tSGFuZGxlcnMoY3VzdG9tRXZlbnRUeXBlLCBldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBkcmFnT3ZlcihldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFO1xuXG4gIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRHJvcCgpIHtcbiAgdGhpcy5vbk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gIHRoaXMub25Nb3VzZU92ZXIobW91c2VPdmVySGFuZGxlciwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVEcm9wKCkge1xuICB0aGlzLm9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gIHRoaXMub2ZmTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkN1c3RvbURyb3AoZHJvcEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyb3BDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZkN1c3RvbURyb3AoZHJvcEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyb3BDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvbkN1c3RvbURyYWdPdXQoZHJhZ091dEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnT3V0Q3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnT3V0KGRyYWdPdXRDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfT1VUX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gZHJhZ091dEN1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9uQ3VzdG9tRHJhZ092ZXIoZHJhZ092ZXJDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfT1ZFUl9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyYWdPdmVyQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnT3ZlcihkcmFnT3ZlckN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gZHJhZ092ZXJDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyb3AsXG4gIGRyYWdPdXQsXG4gIGRyYWdPdmVyLFxuICBlbmFibGVEcm9wLFxuICBkaXNhYmxlRHJvcCxcbiAgb25DdXN0b21Ecm9wLFxuICBvZmZDdXN0b21Ecm9wLFxuICBvbkN1c3RvbURyYWdPdXQsXG4gIG9mZkN1c3RvbURyYWdPdXQsXG4gIG9uQ3VzdG9tRHJhZ092ZXIsXG4gIG9mZkN1c3RvbURyYWdPdmVyXG59XG5cbmZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnRWxlbWVudCA9IGdldERyYWdFbGVtZW50KCk7XG5cbiAgaWYgKGRyYWdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcmVzZXREcm9wRWxlbWVudCgpO1xuXG4gICAgdGhpcy5kcmFnT3V0KGV2ZW50LCBlbGVtZW50LCBkcmFnRWxlbWVudCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnRWxlbWVudCA9IGdldERyYWdFbGVtZW50KCk7XG5cbiAgaWYgKGRyYWdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgZHJvcEVsZW1lbnQgPSB0aGlzLCAvLy9cbiAgICAgICAgICBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9IGNoZWNrRHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQoZHJhZ0VsZW1lbnQsIGRyb3BFbGVtZW50KTtcblxuICAgIGlmIChkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldERyb3BFbGVtZW50KGRyb3BFbGVtZW50KTtcblxuICAgIHRoaXMuZHJhZ092ZXIoZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50KTtcbiAgfVxuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBkcmFnTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZHJhZ1wiO1xuXG5jbGFzcyBEcmFnRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRSZWZlcmVuY2VzKCkge1xuICAgIGNvbnN0IHsgcmVmZXJlbmNlcyA9IFtdIH0gPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgfVxuXG4gIGRpZE1vdW50KCkge1xuICAgIHRoaXMuZW5hYmxlRHJhZygpO1xuICB9XG5cbiAgd2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlRHJhZygpO1xuICB9XG5cbiAgc3RhdGljIGlnbm9yZWRQcm9wZXJ0aWVzID0gW1xuICAgIFwicmVmZXJlbmNlc1wiXG4gIF07XG59XG5cbk9iamVjdC5hc3NpZ24oRHJhZ0VsZW1lbnQucHJvdG90eXBlLCBkcmFnTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKERyYWdFbGVtZW50KWBcblxuICAuZHJhZ2dpbmcge1xuICAgIHotaW5kZXg6IDE7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBkcm9wTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZHJvcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRSZWZlcmVuY2UoKSB7XG4gICAgY29uc3QgeyByZWZlcmVuY2UgPSBudWxsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlO1xuICB9XG5cbiAgZGlkTW91bnQoKSB7XG4gICAgdGhpcy5lbmFibGVEcm9wKCk7XG4gIH1cblxuICB3aWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGVEcm9wKCk7XG4gIH1cblxuICBzdGF0aWMgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgXCJyZWZlcmVuY2VcIlxuICBdO1xufVxuXG5PYmplY3QuYXNzaWduKERyb3BFbGVtZW50LnByb3RvdHlwZSwgZHJvcE1peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJhZ01peGlucyB9IGZyb20gXCIuL21peGlucy9kcmFnXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BNaXhpbnMgfSBmcm9tIFwiLi9taXhpbnMvZHJvcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcmFnRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnQvZHJhZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcm9wRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnQvZHJvcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjdXN0b21FdmVudFR5cGVzIH0gZnJvbSBcIi4vY3VzdG9tRXZlbnRUeXBlc1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgU2l6ZWFibGVEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwic2l6ZWFibGVcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoU2l6ZWFibGVEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5pbXBvcnQgeyBkcmFnTWl4aW5zIH0gZnJvbSBcImVhc3ktZHJhZy1hbmQtZHJvcFwiO1xuXG5pbXBvcnQgU2l6ZWFibGVEaXYgZnJvbSBcIi4uL2Rpdi9zaXplYWJsZVwiO1xuXG5pbXBvcnQgeyByZXNldEN1cnNvciB9IGZyb20gXCIuLi9jdXJzb3JcIjtcblxuY2xhc3MgU3BsaXR0ZXJEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RvcERyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCBkcm9wRWxlbWVudCwgYWJvcnRlZCwgZG9uZSkgPT4ge1xuICAgIHJlc2V0Q3Vyc29yKCk7XG5cbiAgICBkb25lKCk7XG4gIH1cblxuICBtb3VzZU91dEhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICByZXNldEN1cnNvcigpO1xuICB9XG5cbiAgZ2V0U2l6ZWFibGVEaXYoKSB7XG4gICAgbGV0IHNpemVhYmxlRGl2O1xuXG4gICAgY29uc3QgbmV4dFNpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXROZXh0U2libGluZ0VsZW1lbnQoKSxcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmdFbGVtZW50KCksXG4gICAgICAgICAgbmV4dFNpYmxpbmdFbGVtZW50U2l6ZWFibGVEaXYgPSAobmV4dFNpYmxpbmdFbGVtZW50IGluc3RhbmNlb2YgU2l6ZWFibGVEaXYpLFxuICAgICAgICAgIHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdiA9IChwcmV2aW91c1NpYmxpbmdFbGVtZW50IGluc3RhbmNlb2YgU2l6ZWFibGVEaXYpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nRWxlbWVudFNpemVhYmxlRGl2KSB7XG4gICAgICBzaXplYWJsZURpdiA9IG5leHRTaWJsaW5nRWxlbWVudDsgLy8vXG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgc2l6ZWFibGVEaXYgPSBwcmV2aW91c1NpYmxpbmdFbGVtZW50OyAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZWFibGVEaXY7XG4gIH1cblxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgbGV0IGRpcmVjdGlvbjtcblxuICAgIGNvbnN0IG5leHRTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdFbGVtZW50KCksXG4gICAgICAgICAgcHJldmlvdXNTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudCgpLFxuICAgICAgICAgIG5leHRTaWJsaW5nRWxlbWVudFNpemVhYmxlRGl2ID0gKG5leHRTaWJsaW5nRWxlbWVudCBpbnN0YW5jZW9mIFNpemVhYmxlRGl2KSxcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50U2l6ZWFibGVEaXYgPSAocHJldmlvdXNTaWJsaW5nRWxlbWVudCBpbnN0YW5jZW9mIFNpemVhYmxlRGl2KTtcblxuICAgIGlmIChuZXh0U2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgZGlyZWN0aW9uID0gKzE7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIGdldFJlZmVyZW5jZXMoKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICBlbmFibGUoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKTtcblxuICAgIGlmICghZHJhZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuZW5hYmxlRHJhZygpO1xuXG4gICAgICB0aGlzLm9uQ3VzdG9tRHJhZyh0aGlzLmRyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vbkN1c3RvbVN0b3BEcmFnKHRoaXMuc3RvcERyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vbkN1c3RvbVN0YXJ0RHJhZyh0aGlzLnN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKTtcblxuICAgIGlmIChkcmFnRW5hYmxlZCkge1xuICAgICAgdGhpcy5vZmZDdXN0b21TdGFydERyYWcodGhpcy5zdGFydERyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vZmZDdXN0b21TdG9wRHJhZyh0aGlzLnN0b3BEcmFnQ3VzdG9tSGFuZGxlcik7XG5cbiAgICAgIHRoaXMub2ZmQ3VzdG9tRHJhZyh0aGlzLmRyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5kaXNhYmxlRHJhZygpO1xuICAgIH1cbiAgfVxuXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKSxcbiAgICAgICAgICBkaXNhYmxlZCA9ICFkcmFnRW5hYmxlZDtcblxuICAgIHJldHVybiBkaXNhYmxlZDtcbiAgfVxuXG4gIGRpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQgPSBmYWxzZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uTW91c2VPdmVyKHRoaXMubW91c2VPdmVySGFuZGxlcik7XG5cbiAgICB0aGlzLm9uTW91c2VPdXQodGhpcy5tb3VzZU91dEhhbmRsZXIpO1xuICB9XG5cbiAgd2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKTtcblxuICAgIHRoaXMub2ZmTW91c2VPdXQodGhpcy5tb3VzZU91dEhhbmRsZXIpO1xuXG4gICAgdGhpcy5vZmZNb3VzZU92ZXIodGhpcy5tb3VzZU92ZXJIYW5kbGVyKTtcblxuICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpc2UoKSB7XG4gICAgdGhpcy5zZXRJbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgXCJkaXNhYmxlZFwiXG4gIF07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJzcGxpdHRlclwiXG4gIH07XG59XG5cbk9iamVjdC5hc3NpZ24oU3BsaXR0ZXJEaXYucHJvdG90eXBlLCBkcmFnTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFNwbGl0dGVyRGl2KWBcblxuICBmbGV4LXNocmluazogMDtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IFNwbGl0dGVyIGZyb20gXCIuLi9zcGxpdHRlclwiO1xuXG5pbXBvcnQgeyBjb2x1bW5SZXNpemVDdXJzb3IgfSBmcm9tIFwiLi4vLi4vY3Vyc29yXCI7XG5cbmNsYXNzIFZlcnRpY2FsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gc2l6ZWFibGVEaXYuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSBzaXplYWJsZURpdldpZHRoOyAgLy8vXG5cbiAgICB0aGlzLnNldFByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aChwcmV2aW91c1NpemVhYmxlRGl2V2lkdGgpO1xuXG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIGRyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdldpZHRoID0gdGhpcy5nZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSxcbiAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gcHJldmlvdXNTaXplYWJsZURpdldpZHRoIC0gZGlyZWN0aW9uICogcmVsYXRpdmVNb3VzZUxlZnQsXG4gICAgICAgICAgd2lkdGggPSBzaXplYWJsZURpdldpZHRoOyAvLy9cblxuICAgIHNpemVhYmxlRGl2LnNldFdpZHRoKHdpZHRoKTtcbiAgfVxuXG4gIG1vdXNlT3ZlckhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICB0aGlzLnNldEN1cnNvcigpO1xuICB9XG5cbiAgc2V0Q3Vyc29yKCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5pc0Rpc2FibGVkKCk7XG5cbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICBjb2x1bW5SZXNpemVDdXJzb3IoKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSB7XG4gICAgY29uc3QgeyBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIHJldHVybiBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGg7XG4gIH1cblxuICBzZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgocHJldmlvdXNTaXplYWJsZURpdldpZHRoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGhcbiAgICB9KTtcbiAgfVxuXG4gIHNldEluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSBudWxsO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGhcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwidmVydGljYWxcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVmVydGljYWxTcGxpdHRlcilgXG5cbiAgd2lkdGg6IDFyZW07XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCBTcGxpdHRlciBmcm9tIFwiLi4vc3BsaXR0ZXJcIjtcblxuaW1wb3J0IHsgcm93UmVzaXplQ3Vyc29yIH0gZnJvbSBcIi4uLy4uL2N1cnNvclwiO1xuXG5jbGFzcyBIb3Jpem9udGFsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICBzaXplYWJsZURpdkhlaWdodCA9IHNpemVhYmxlRGl2LmdldEhlaWdodCgpLFxuICAgICAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgPSBzaXplYWJsZURpdkhlaWdodDsgIC8vL1xuXG4gICAgdGhpcy5zZXRQcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQpO1xuXG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIGRyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IHRoaXMuZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpLFxuICAgICAgICAgIHNpemVhYmxlRGl2SGVpZ2h0ID0gcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCAtIGRpcmVjdGlvbiAqIHJlbGF0aXZlTW91c2VUb3AsXG4gICAgICAgICAgaGVpZ2h0ID0gc2l6ZWFibGVEaXZIZWlnaHQ7IC8vL1xuXG4gICAgc2l6ZWFibGVEaXYuc2V0SGVpZ2h0KGhlaWdodCk7XG4gIH1cblxuICBtb3VzZU92ZXJIYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50KSA9PiB7XG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIHNldEN1cnNvcigpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgcm93UmVzaXplQ3Vyc29yKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpIHtcbiAgICBjb25zdCB7IHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIHJldHVybiBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0O1xuICB9XG5cbiAgc2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodChwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBzZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiaG9yaXpvbnRhbFwiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShIb3Jpem9udGFsU3BsaXR0ZXIpYFxuXG4gIGhlaWdodDogMXJlbTtcblxuYDtcbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3Vyc29yIH0gZnJvbSBcIi4vY3Vyc29yXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm93RGl2IH0gZnJvbSBcIi4vZGl2L3Jvd1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb3dzRGl2IH0gZnJvbSBcIi4vZGl2L3Jvd3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sdW1uRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2x1bW5zRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtbnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2l6ZWFibGVEaXYgfSBmcm9tIFwiLi9kaXYvc2l6ZWFibGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmVydGljYWxTcGxpdHRlckRpdiB9IGZyb20gXCIuL2Rpdi9zcGxpdHRlci92ZXJ0aWNhbFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIb3Jpem9udGFsU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXIvaG9yaXpvbnRhbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBsZXZlbHMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmV4cG9ydCBjb25zdCB7IFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwgfSA9IGxldmVscztcblxuZXhwb3J0IGNvbnN0IExFVkVMUyA9IFtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTFxuXTtcblxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgU0lOR0xFX1NQQUNFID0gXCIgXCI7XG5leHBvcnQgY29uc3QgRE9VQkxFX1NQQUNFID0gXCIgIFwiO1xuZXhwb3J0IGNvbnN0IEJSRUFLX01FU1NBR0UgPSBcIjo6IEJSRUFLIDo6XCI7XG5leHBvcnQgY29uc3QgTEVWRUxfTUFYSU1VTV9MRU5HVEggPSA3O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBMRVZFTFMsIFNJTkdMRV9TUEFDRSwgRU1QVFlfU1RSSU5HLCBMRVZFTF9NQVhJTVVNX0xFTkdUSCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCBbIFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwgXSA9IExFVkVMUztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZXMsIGxvZ0xldmVsLCBmb2xsb3cpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgIHRoaXMuZm9sbG93ID0gZm9sbG93O1xuICB9XG5cbiAgZ2V0TWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XG4gIH1cblxuICBnZXRMb2dMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dMZXZlbDtcbiAgfVxuXG4gIGdldEZvbGxvdygpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xsb3c7XG4gIH1cblxuICB0cmFjZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBUUkFDRV9MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gREVCVUdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGluZm8obWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gSU5GT19MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd2FybmluZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBXQVJOSU5HX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZShsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBlcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBFUlJPUl9MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd3JpdGUobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoID0gbnVsbCwgbGluZUluZGV4ID0gbnVsbCkge1xuICAgIGNvbnN0IGxldmVsSW5kZXggPSBMRVZFTFMuaW5kZXhPZihsZXZlbCksXG4gICAgICAgICAgbG9nTGV2ZWxJbmRleCA9IExFVkVMUy5pbmRleE9mKHRoaXMubG9nTGV2ZWwpO1xuXG4gICAgaWYgKGxldmVsSW5kZXggPCBsb2dMZXZlbEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpOyAgLy8vXG5cbiAgICB0aGlzLmZvbGxvdyA/XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKSA6XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IG51bGwsXG4gICAgICAgICAgbG9nTGV2ZWwgPSBUUkFDRV9MRVZFTCxcbiAgICAgICAgICBmb2xsb3cgPSB0cnVlLFxuICAgICAgICAgIGxvZyA9IG5ldyBMb2cobWVzc2FnZXMsIGxvZ0xldmVsLCBmb2xsb3cpO1xuXG4gICAgcmV0dXJuIGxvZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRm9sbG93QW5kTG9nTGV2ZWwoZm9sbG93LCBsb2dMZXZlbCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gZm9sbG93ID9cbiAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgbG9nID0gbmV3IExvZyhtZXNzYWdlcywgbG9nTGV2ZWwsIGZvbGxvdyk7XG5cbiAgICByZXR1cm4gbG9nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpIHtcbiAgbGV0IGZvcm1hdHRlZE1lc3NhZ2UgPSBFTVBUWV9TVFJJTkc7XG5cbiAgY29uc3QgbGVmdFBhZGRlZExldmVsID0gbGVmdFBhZExldmVsKGxldmVsKSxcbiAgICAgICAgdXBwZXJDYXNlTGVmdFBhZGRlZExldmVsID0gbGVmdFBhZGRlZExldmVsLnRvVXBwZXJDYXNlKCk7XG5cbiAgZm9ybWF0dGVkTWVzc2FnZSArPSBgJHt1cHBlckNhc2VMZWZ0UGFkZGVkTGV2ZWx9OiBgO1xuXG4gIGlmIChmaWxlUGF0aCAhPT0gbnVsbCkge1xuICAgIGZvcm1hdHRlZE1lc3NhZ2UgKz0gYCR7ZmlsZVBhdGh9IGA7XG4gIH1cblxuICBpZiAobGluZUluZGV4ICE9PSBudWxsKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgWyR7bGluZUluZGV4fV0gYDtcbiAgfVxuXG4gIGlmICgoZmlsZVBhdGggIT09IG51bGwpIHx8IChsaW5lSW5kZXggIT09IG51bGwpKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgLSBgO1xuICB9XG5cbiAgZm9ybWF0dGVkTWVzc2FnZSArPSBtZXNzYWdlO1xuXG4gIG1lc3NhZ2UgPSBmb3JtYXR0ZWRNZXNzYWdlOyAvLy9cblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZExldmVsKGxldmVsKSB7XG4gIGNvbnN0IG1heGltdW1MZW5ndGggPSBMRVZFTF9NQVhJTVVNX0xFTkdUSCxcbiAgICAgICAgbGVmdFBhZGRlZExldmVsID0gbGVmdFBhZChsZXZlbCwgbWF4aW11bUxlbmd0aCk7XG5cbiAgcmV0dXJuIGxlZnRQYWRkZWRMZXZlbDtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZChzdHJpbmcsIG1heGltdW1MZW5ndGgpIHtcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgbGVuZ3RoID0gbWF4aW11bUxlbmd0aCAtIHN0cmluZ0xlbmd0aCxcbiAgICAgICAgaW5kZW50ID0gU0lOR0xFX1NQQUNFLnJlcGVhdChsZW5ndGgpLFxuICAgICAgICBsZWZ0UGFkZGVkU3RyaW5nID0gYCR7aW5kZW50fSR7c3RyaW5nfWA7XG5cbiAgcmV0dXJuIGxlZnRQYWRkZWRTdHJpbmc7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgfVxuXG4gIGdldFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gIH1cblxuICBnZXROb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgc2V0U3RyaW5nKHN0cmluZykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICB9XG5cbiAgc2V0Tm9kZShub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGFzeW5jIGJyZWFrKGNvbnRleHQpIHtcbiAgICBhd2FpdCBjb250ZXh0LmJyZWFrKHRoaXMubm9kZSk7XG4gIH1cblxuICBtYXRjaE5vZGUobm9kZSkgeyByZXR1cm4gdGhpcy5ub2RlLm1hdGNoKG5vZGUpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERPVUJMRV9TUEFDRSwgVFJBQ0VfTEVWRUwsIERFQlVHX0xFVkVMLCBJTkZPX0xFVkVMLCBFUlJPUl9MRVZFTCwgV0FSTklOR19MRVZFTCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICBnZXREZXB0aCgpIHtcbiAgICBsZXQgZGVwdGggPSB0aGlzLmNvbnRleHQuZ2V0RGVwdGgoKTtcblxuICAgIGRlcHRoKys7XG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBnZXRSZWxlYXNlQ29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRSZWxlYXNlQ29udGV4dCgpOyB9XG5cbiAgbm9kZXNBc1N0cmluZyhub2RlKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZXNBc1N0cmluZyhub2RlKTsgfVxuXG4gIG5vZGVBc1N0cmluZyhub2RlKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpOyB9XG5cbiAgdHJhY2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gVFJBQ0VfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gREVCVUdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgaW5mbyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBJTkZPX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHdhcm5pbmcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gV0FSTklOR19MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBlcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBFUlJPUl9MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICB3cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZGVwdGggPSB0aGlzLmdldERlcHRoKCksXG4gICAgICAgICAgaW5kZW50ID0gRE9VQkxFX1NQQUNFLnJlcGVhdChkZXB0aCk7XG5cbiAgICBtZXNzYWdlID0gYCR7aW5kZW50fSR7bWVzc2FnZX1gOyAgLy8vXG5cbiAgICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHRoaXMuZ2V0UmVsZWFzZUNvbnRleHQoKTtcblxuICAgIHJlbGVhc2VDb250ZXh0LndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsobm9kZSkgeyBhd2FpdCB0aGlzLmNvbnRleHQuYnJlYWsobm9kZSk7IH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBjb250ZXh0ID0gcmVtYWluaW5nQXJndW1lbnRzLnBvcCgpO1xuXG4gICAgY29udGV4dCA9IG5ldyBDbGFzcyhjb250ZXh0LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpOyAgLy8vXG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZUluZGV4RnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gIGxldCBsaW5lSW5kZXggPSAwO1xuXG4gIGNvbnN0IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9kZS5nZXRGaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gIHRva2Vucy5zb21lKCh0b2tlbiwgdG9rZW5JbmRleCkgPT4ge1xuICAgIGNvbnN0IHRva2VuRW5kT2ZMaW5lVG9rZW4gPSB0b2tlbi5pc0VuZE9mTGluZVRva2VuKCk7XG5cbiAgICBpZiAodG9rZW5FbmRPZkxpbmVUb2tlbikge1xuICAgICAgbGluZUluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuSW5kZXggPT09IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsaW5lSW5kZXg7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVBc1N0cmluZyhub2RlLCB0b2tlbnMpIHtcbiAgbGV0IHN0cmluZztcblxuICB0b2tlbnMgPSBub2RlQXNUb2tlbnMobm9kZSwgdG9rZW5zKTsgIC8vL1xuXG4gIHN0cmluZyA9IHRva2Vuc0FzU3RyaW5nKHRva2Vucyk7XG5cbiAgc3RyaW5nID0gdHJpbVN0cmluZyhzdHJpbmcpOyAgLy8vXG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzQXNTdHJpbmcobm9kZXMsIHRva2Vucykge1xuICBjb25zdCBzdHJpbmcgPSBub2Rlcy5yZWR1Y2UoKHN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IG5vZGVTdHJpbmcgPSBub2RlQXNTdHJpbmcobm9kZSwgdG9rZW5zKTtcblxuICAgIHN0cmluZyA9IChzdHJpbmcgPT09IG51bGwpID9cbiAgICAgIG5vZGVTdHJpbmcgOlxuICAgICAgYCR7c3RyaW5nfSwgJHtub2RlU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBudWxsKTtcblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5vZGVBc1N0cmluZyxcbiAgbm9kZXNBc1N0cmluZyxcbn07XG5cbmZ1bmN0aW9uIHRyaW1TdHJpbmcoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXHMrJC8sIEVNUFRZX1NUUklORyk7ICAvLy9cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b2tlbnNBc1N0cmluZyh0b2tlbnMpIHtcbiAgY29uc3Qgc3RyaW5nID0gdG9rZW5zLnJlZHVjZSgoc3RyaW5nLCB0b2tlbikgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0b2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICBzdHJpbmcgPSBgJHtzdHJpbmd9JHtjb250ZW50fWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIG5vZGVBc1Rva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgIHRva2VucyA9IHRlcm1pbmFsTm9kZUFzVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlOyAvLy9cblxuICAgIHRva2VucyA9IG5vblRlcm1pbmFsTm9kZUFzVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIHRlcm1pbmFsTm9kZUFzVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gIGNvbnN0IHNpZ25pZmljYW50VG9rZW4gPSB0ZXJtaW5hbE5vZGUuZ2V0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICB0b2tlbiA9IHNpZ25pZmljYW50VG9rZW47IC8vL1xuXG4gIHRva2VucyA9IFsgIC8vL1xuICAgIHRva2VuXG4gIF07XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gbm9uVGVybWluYWxOb2RlQXNUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgY29uc3QgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgIHN0YXJ0ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgsIC8vL1xuICAgICAgICBlbmQgPSBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICsgMTtcblxuICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICByZXR1cm4gdG9rZW5zO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQ29udGV4dCBmcm9tICcuLi9jb250ZXh0JztcblxuaW1wb3J0IHsgbGluZUluZGV4RnJvbU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2xpbmVJbmRleFwiO1xuaW1wb3J0IHsgbm9kZUFzU3RyaW5nLCBub2Rlc0FzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcblxuICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9XG5cbiAgZ2V0RmlsZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZVBhdGg7XG4gIH1cblxuICBnZXRUb2tlbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICB9XG5cbiAgZ2V0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgZ2V0TGV4ZXIoKSB7XG4gICAgY29uc3QgbGV4ZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIGxleGVyO1xuICB9XG5cbiAgZ2V0UGFyc2VyKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IG51bGw7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgZ2V0VHlwZVByZWZpeCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgdHlwZVByZWZpeCA9IGNvbnRleHQuZ2V0VHlwZVByZWZpeCgpO1xuXG4gICAgcmV0dXJuIHR5cGVQcmVmaXg7XG4gIH1cblxuICBtYXRjaEZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgZmlsZVBhdGhNYXRjaGVzID0gKHRoaXMuZmlsZVBhdGggPT09IGZpbGVQYXRoKTtcblxuICAgIHJldHVybiBmaWxlUGF0aE1hdGNoZXM7XG4gIH1cblxuICBmaW5kRmlsZSgpIHtcbiAgICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHRoaXMuZ2V0UmVsZWFzZUNvbnRleHQoKSxcbiAgICAgICAgICBmaWxlID0gcmVsZWFzZUNvbnRleHQuZmluZEZpbGUodGhpcy5maWxlUGF0aCk7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIG5vZGVBc1N0cmluZyhub2RlKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gbm9kZUFzU3RyaW5nKG5vZGUsIHRoaXMudG9rZW5zKTtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBub2Rlc0FzU3RyaW5nKG5vZGVzKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gbm9kZXNBc1N0cmluZyhub2RlcywgdGhpcy50b2tlbnMpO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHByZXBhcmUoKSB7XG4gICAgaWYgKHRoaXMudG9rZW5zICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZmluZEZpbGUoKSxcbiAgICAgICAgICBsZXhlciA9IHRoaXMuZ2V0TGV4ZXIoKSxcbiAgICAgICAgICBwYXJzZXIgPSB0aGlzLmdldFBhcnNlcigpLFxuICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKTtcblxuICAgIHRoaXMudG9rZW5zID0gbGV4ZXIudG9rZW5pc2UoY29udGVudCk7XG5cbiAgICB0aGlzLm5vZGUgPSBwYXJzZXIucGFyc2UodGhpcy50b2tlbnMpO1xuICB9XG5cbiAgaW5pdGlhbGlzZShqc29uKSB7XG4gICAgY29uc3QgeyBjb250ZW50IH0gPSBqc29uLFxuICAgICAgICAgIGxleGVyID0gdGhpcy5nZXRMZXhlcigpLFxuICAgICAgICAgIHBhcnNlciA9IHRoaXMuZ2V0UGFyc2VyKCk7XG5cbiAgICB0aGlzLnRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpO1xuXG4gICAgdGhpcy5ub2RlID0gcGFyc2VyLnBhcnNlKHRoaXMudG9rZW5zKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuYWRkUHJvY2VkdXJlcygpO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsobm9kZSkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBsaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0aGlzLnRva2VucyksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLmdldFJlbGVhc2VDb250ZXh0KCk7XG5cbiAgICBhd2FpdCByZWxlYXNlQ29udGV4dC5icmVhayhmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSgpIHtcbiAgICBsZXQgdmVyaWZpZXMgPSBmYWxzZTtcblxuICAgIHRoaXMucHJlcGFyZSgpO1xuXG4gICAgaWYgKHRoaXMubm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy53YXJuaW5nKGBVbmFibGUgdG8gdmVyaWZ5IHRoZSAnJHt0aGlzLmZpbGVQYXRofScgZmlsZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBwYXJzZWQuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoYFZlcmlmeWluZyB0aGUgJyR7dGhpcy5maWxlUGF0aH0nIGZpbGUuLi5gKTtcblxuICAgICAgY29uc3QgZmlsZVZlcmlmaWVzID0gYXdhaXQgdGhpcy52ZXJpZnlGaWxlKCk7XG5cbiAgICAgIGlmIChmaWxlVmVyaWZpZXMpIHtcbiAgICAgICAgdmVyaWZpZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2ZXJpZmllcyA/XG4gICAgICAgIHRoaXMuY29tcGxldGUoKSA6XG4gICAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICBpZiAodmVyaWZpZXMpIHtcbiAgICAgICAgdGhpcy5pbmZvKGAuLi52ZXJpZmllZCB0aGUgJyR7dGhpcy5maWxlUGF0aH0nIGZpbGUuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcmlmaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21GaWxlKENsYXNzLCBmaWxlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgIHRva2VucyA9IG51bGwsXG4gICAgICAgICAgbm9kZSA9IG51bGwsXG4gICAgICAgICAgY29udGV4dCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKSwgLy8vXG4gICAgICAgICAgZmlsZUNvbnRleHQgPSBuZXcgQ2xhc3MoY29udGV4dCwgZmlsZVBhdGgsIHRva2Vucywgbm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiBmaWxlQ29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihDbGFzcywganNvbiwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyBmaWxlUGF0aCB9ID0ganNvbixcbiAgICAgICAgICB0b2tlbnMgPSBudWxsLFxuICAgICAgICAgIG5vZGUgPSBudWxsLFxuICAgICAgICAgIGNvbnRleHQgPSByZW1haW5pbmdBcmd1bWVudHMucG9wKCksIC8vL1xuICAgICAgICAgIGZpbGVDb250ZXh0ID0gbmV3IENsYXNzKGNvbnRleHQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gZmlsZUNvbnRleHQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jU29tZShhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4LCBhcnJheSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgsIGFycmF5KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNSZWR1Y2UoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlOyAvLy9cblxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICB2YWx1ZSA9IGF3YWl0IGNhbGxiYWNrKHZhbHVlLCBlbGVtZW50LCBpbmRleCwgYXJyYXkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICBhd2FpdCBjYWxsYmFjayhlbGVtZW50LCBpbmRleCwgYXJyYXkpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1Jlc29sdmUoYXJyYXlBLCBhcnJheUIsIGNhbGxiYWNrKSB7XG4gIGxldCByZXNvbHZlZDtcblxuICBhcnJheUEgPSBbICAvLy9cbiAgICAuLi5hcnJheUFcbiAgXTtcblxuICBmb3IgKDs7KSB7XG4gICAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aDtcblxuICAgIGlmIChhcnJheUFMZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgYXdhaXQgYXN5bmNGb3JFYWNoKGFycmF5QSwgYXN5bmMgKGVsZW1lbnRBLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFzc2VkID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudEEsIGluZGV4LCBhcnJheUEpO1xuXG4gICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRCID0gZWxlbWVudEE7ICAvLy9cblxuICAgICAgICBhcnJheUIucHVzaChlbGVtZW50Qik7XG5cbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZmlsdGVyKGFycmF5QSwgKGVsZW1lbnRBKSA9PiB7XG4gICAgICBjb25zdCBhcnJheUJJbmNsdWRlc0VsZW1lbnRBID0gYXJyYXlCLmluY2x1ZGVzKGVsZW1lbnRBKTtcblxuICAgICAgaWYgKCFhcnJheUJJbmNsdWRlc0VsZW1lbnRBKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aDtcblxuICByZXNvbHZlZCA9IChhcnJheUFMZW5ndGggPT09IDApO1xuXG4gIHJldHVybiByZXNvbHZlZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jRm9yd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGF3YWl0IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4LCBhcnJheSk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNCYWNrd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gbGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgsIGFycmF5KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXN5bmNTb21lLFxuICBhc3luY0V2ZXJ5LFxuICBhc3luY1JlZHVjZSxcbiAgYXN5bmNGb3JFYWNoLFxuICBhc3luY1Jlc29sdmUsXG4gIGFzeW5jRm9yd2FyZHNFdmVyeSxcbiAgYXN5bmNCYWNrd2FyZHNFdmVyeVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IGFzeW5jUmVzb2x2ZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNocm9ub3VzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIGZpbHRlciwgY29tcHJlc3MgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RmlsZUNvbnRleHRzKGZpbGVDb250ZXh0cywgdmVyaWZpZWRGaWxlQ29udGV4dHMpIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCBhc3luY1Jlc29sdmUoZmlsZUNvbnRleHRzLCB2ZXJpZmllZEZpbGVDb250ZXh0cywgYXN5bmMgKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZUNvbnRleHRWZXJpZmllcyA9IGF3YWl0IGZpbGVDb250ZXh0LnZlcmlmeSgpO1xuXG4gICAgICAgICAgaWYgKGZpbGVDb250ZXh0VmVyaWZpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGZpbGVDb250ZXh0c1ZlcmlmeSA9IHJlc29sdmVkOyAgLy8vXG5cbiAgcmV0dXJuIGZpbGVDb250ZXh0c1ZlcmlmeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVQcmVmaXhlcyh0eXBlUHJlZml4ZXMsIHJlbGVhc2VDb250ZXh0KSB7XG4gIGxldCB0eXBlUHJlZml4ZXNWZXJpZnkgPSB0cnVlO1xuXG4gIGNvbnN0IHR5cGVQcmVmaXhlc0xlbmd0aCA9IHR5cGVQcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgIGNvbXByZXNzZWRUeXBlUHJlZml4ZXMgPSBbICAvLy9cbiAgICAgICAgICAuLi50eXBlUHJlZml4ZXMsXG4gICAgICAgIF07XG5cbiAgY29tcHJlc3MoY29tcHJlc3NlZFR5cGVQcmVmaXhlcywgKHR5cGVQcmVmaXhBLCB0eXBlUHJlZml4QikgPT4ge1xuICAgIGNvbnN0IHR5cGVQcmVmaXhBTmFtZSA9IHR5cGVQcmVmaXhBLmdldE5hbWUoKSxcbiAgICAgICAgICB0eXBlUHJlZml4Qk5hbWUgPSB0eXBlUHJlZml4Qi5nZXROYW1lKCk7XG5cbiAgICBpZiAodHlwZVByZWZpeEFOYW1lICE9PSB0eXBlUHJlZml4Qk5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgY29tcHJlc3NUeXBlUHJlZml4ZXNMZW5ndGggPSBjb21wcmVzc2VkVHlwZVByZWZpeGVzLmxlbmd0aDtcblxuICBpZiAodHlwZVByZWZpeGVzTGVuZ3RoID4gY29tcHJlc3NUeXBlUHJlZml4ZXNMZW5ndGgpIHtcbiAgICBmaWx0ZXIoY29tcHJlc3NlZFR5cGVQcmVmaXhlcywgKHR5cGVQcmVmaXgpID0+IHtcbiAgICAgIGNvbnN0IHR5cGVQcmVmaXhlc0luY2x1ZGVzVHlwZVByZWZpeCA9IHR5cGVQcmVmaXhlcy5pbmNsdWRlcyh0eXBlUHJlZml4KTtcblxuICAgICAgaWYgKCF0eXBlUHJlZml4ZXNJbmNsdWRlc1R5cGVQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaXJzdFR5cGVQcmVmaXggPSBmaXJzdCh0eXBlUHJlZml4ZXMpLFxuICAgICAgICAgIHR5cGVQcmVmaXggPSBmaXJzdFR5cGVQcmVmaXgsIC8vL1xuICAgICAgICAgIHR5cGVQcmVmaXhTdHJpbmcgPSB0eXBlUHJlZml4LmdldFN0cmluZygpO1xuXG4gICAgcmVsZWFzZUNvbnRleHQuaW5mbyhgVGhlICcke3R5cGVQcmVmaXhTdHJpbmd9JyB0eXBlIHByZWZpeCBpcyBkdXBsaWNhdGVkLmApXG5cbiAgICB0eXBlUHJlZml4ZXNWZXJpZnkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlUHJlZml4ZXNWZXJpZnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NVU1RPTV9HUkFNTUFSX05BTUUgPSBcIkRlZmF1bHRcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRFUk1fUlVMRV9OQU1FID0gXCJ0ZXJtXCI7XG5leHBvcnQgY29uc3QgU1RBVEVNRU5UX1JVTEVfTkFNRSA9IFwic3RhdGVtZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVEVSTV9SVUxFX05BTUUsXG4gIFNUQVRFTUVOVF9SVUxFX05BTUVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUWVBFX1ZPQ0FCVUxBUllfTkFNRSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IFNZTUJPTF9WT0NBQlVMQVJZX05BTUUgPSBcInN5bWJvbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRZUEVfVk9DQUJVTEFSWV9OQU1FLFxuICBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBWRVJUSUNBTF9CQVIgPSBcInxcIjtcbmV4cG9ydCBjb25zdCBWRVJUSUNBTF9TUEFDRSA9IGBcblxuYFxuZXhwb3J0IGNvbnN0IFVOQVNTSUdORURfVFlQRSA9IFwidW5hc3NpZ25lZFwiO1xuZXhwb3J0IGNvbnN0IFNUVUZGX1JVTEVfTkFNRSA9IFwic3R1ZmZcIjtcbmV4cG9ydCBjb25zdCBCQVNFX1RZUEVfU1lNQk9MID0gXCI8PlwiO1xuZXhwb3J0IGNvbnN0IE5PTlNFTlNFX1JVTEVfTkFNRSA9IFwibm9uc2Vuc2VcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBERUZBVUxUX0NVU1RPTV9HUkFNTUFSX05BTUUgfSBmcm9tIFwiLi9ncmFtbWFyTmFtZXNcIjtcbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FLCBTVEFURU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBUWVBFX1ZPQ0FCVUxBUllfTkFNRSwgU1lNQk9MX1ZPQ0FCVUxBUllfTkFNRSB9IGZyb20gXCIuL3ZvY2FidWxhcnlOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21HcmFtbWFyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50ZXJtQk5GID0gdGVybUJORjtcbiAgICB0aGlzLnN0YXRlbWVudEJORiA9IHN0YXRlbWVudEJORjtcbiAgICB0aGlzLnR5cGVWb2NhYnVsYXJ5ID0gdHlwZVZvY2FidWxhcnk7XG4gICAgdGhpcy5zeW1ib2xWb2NhYnVsYXJ5ID0gc3ltYm9sVm9jYWJ1bGFyeTtcbiAgfVxuICBcbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0VGVybUJORigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtQk5GO1xuICB9XG5cbiAgZ2V0U3RhdGVtZW50Qk5GKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlbWVudEJORjtcbiAgfVxuXG4gIGdldFR5cGVWb2NhYnVsYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVWb2NhYnVsYXJ5O1xuICB9XG5cbiAgZ2V0U3ltYm9sVm9jYWJ1bGFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW1ib2xWb2NhYnVsYXJ5O1xuICB9XG5cbiAgZ2V0Qk5GKHJ1bGVOYW1lKSB7XG4gICAgbGV0IGJuZjtcblxuICAgIHN3aXRjaCAocnVsZU5hbWUpIHtcbiAgICAgIGNhc2UgVEVSTV9SVUxFX05BTUU6IGJuZiA9IHRoaXMudGVybUJORjsgYnJlYWs7XG4gICAgICBjYXNlIFNUQVRFTUVOVF9SVUxFX05BTUU6IGJuZiA9IHRoaXMuc3RhdGVtZW50Qk5GOyBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gYm5mO1xuICB9XG5cbiAgZ2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSkge1xuICAgIGxldCB2b2NhYnVsYXJ5O1xuXG4gICAgc3dpdGNoICh2b2NhYnVsYXJ5TmFtZSkge1xuICAgICAgY2FzZSBUWVBFX1ZPQ0FCVUxBUllfTkFNRTogdm9jYWJ1bGFyeSA9IHRoaXMudHlwZVZvY2FidWxhcnk7IGJyZWFrO1xuICAgICAgY2FzZSBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FOiB2b2NhYnVsYXJ5ID0gdGhpcy5zeW1ib2xWb2NhYnVsYXJ5OyBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdm9jYWJ1bGFyeTtcbiAgfVxuXG4gIGdldFZvY2FidWxhcmllcygpIHtcbiAgICBjb25zdCB2b2NhYnVsYXJpZXMgPSBbXG4gICAgICB0aGlzLnR5cGVWb2NhYnVsYXJ5LFxuICAgICAgdGhpcy5zeW1ib2xWb2NhYnVsYXJ5XG4gICAgXTtcblxuICAgIHJldHVybiB2b2NhYnVsYXJpZXM7XG4gIH1cblxuICBpc0RlZmF1bHRDdXN0b21HcmFtbWFyKCkge1xuICAgIGNvbnN0IGRlZmF1bHRDdXN0b21HcmFtbWFyID0gKHRoaXMubmFtZSA9PT0gREVGQVVMVF9DVVNUT01fR1JBTU1BUl9OQU1FKTtcblxuICAgIHJldHVybiBkZWZhdWx0Q3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBzZXRCTkYocnVsZU5hbWUsIGJuZikge1xuICAgIHN3aXRjaCAocnVsZU5hbWUpIHtcbiAgICAgIGNhc2UgVEVSTV9SVUxFX05BTUU6XG4gICAgICAgIHRoaXMudGVybUJORiA9IGJuZjtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTVEFURU1FTlRfUlVMRV9OQU1FOlxuICAgICAgICB0aGlzLnN0YXRlbWVudEJORiA9IGJuZjtcblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lLCB2b2NhYnVsYXJ5KSB7XG4gICAgc3dpdGNoICh2b2NhYnVsYXJ5TmFtZSkge1xuICAgICAgY2FzZSBUWVBFX1ZPQ0FCVUxBUllfTkFNRTpcbiAgICAgICAgdGhpcy50eXBlVm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1lNQk9MX1ZPQ0FCVUxBUllfTkFNRTpcbiAgICAgICAgdGhpcy5zeW1ib2xWb2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTtcblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXNldEJORihydWxlTmFtZSkge1xuICAgIGNvbnN0IGJuZiA9IEVNUFRZX1NUUklORztcblxuICAgIHRoaXMuc2V0Qk5GKHJ1bGVOYW1lLCBibmYpO1xuICB9XG5cbiAgcmVzZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lKSB7XG4gICAgY29uc3Qgdm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORztcblxuICAgIHRoaXMuc2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSwgdm9jYWJ1bGFyeSk7XG4gIH1cblxuICB1cGRhdGUocnVsZU5hbWUsIGJuZiwgdm9jYWJ1bGFyeU5hbWUsIHZvY2FidWxhcnkpIHtcbiAgICB0aGlzLnNldEJORihydWxlTmFtZSwgYm5mKTtcblxuICAgIHRoaXMuc2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSwgdm9jYWJ1bGFyeSk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgICB0ZXJtQk5GID0gdGhpcy50ZXJtQk5GLFxuICAgICAgICAgIHN0YXRlbWVudEJORiA9IHRoaXMuc3RhdGVtZW50Qk5GLFxuICAgICAgICAgIHR5cGVWb2NhYnVsYXJ5ID0gdGhpcy50eXBlVm9jYWJ1bGFyeSxcbiAgICAgICAgICBzeW1ib2xWb2NhYnVsYXJ5ID0gdGhpcy5zeW1ib2xWb2NhYnVsYXJ5LFxuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVybUJORixcbiAgICAgICAgICAgIHN0YXRlbWVudEJORixcbiAgICAgICAgICAgIHR5cGVWb2NhYnVsYXJ5LFxuICAgICAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeVxuICAgICAgICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IHsgbmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSB9ID0ganNvbixcbiAgICAgICAgICBjdXN0b21HcmFtbWFyID0gbmV3IEN1c3RvbUdyYW1tYXIobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSk7XG5cbiAgICByZXR1cm4gY3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgY29uc3QgdGVybUJORiA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBzdGF0ZW1lbnRCTkYgPSBFTVBUWV9TVFJJTkcsXG4gICAgICAgICAgdHlwZVZvY2FidWxhcnkgPSBFTVBUWV9TVFJJTkcsXG4gICAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBjdXN0b21HcmFtbWFyID0gbmV3IEN1c3RvbUdyYW1tYXIobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSk7XG5cbiAgICByZXR1cm4gY3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZVRlcm1CTkZTdGF0ZW1lbnRCTkZUeXBlVm9jYWJ1bGFyeUFuZFN5bWJvbFZvY2FidWxhcnkobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSkge1xuICAgIGNvbnN0IGN1c3RvbUdyYW1tYXIgPSBuZXcgQ3VzdG9tR3JhbW1hcihuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5KTtcblxuICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBDdXN0b21HcmFtbWFyIGZyb20gXCIuLi9jdXN0b21HcmFtbWFyXCI7XG5cbmltcG9ydCB7IERFRkFVTFRfQ1VTVE9NX0dSQU1NQVJfTkFNRSB9IGZyb20gXCIuLi9ncmFtbWFyTmFtZXNcIjtcblxuZXhwb3J0IGNvbnN0IHRlcm1CTkYgPSBgdGVybSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCIoXCIgYXJndW1lbnQgXCIpXCJcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdmFyaWFibGUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtgO1xuXG5leHBvcnQgY29uc3Qgc3RhdGVtZW50Qk5GID0gYHN0YXRlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIG1ldGFBcmd1bWVudCBcIilcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlcXVhbGl0eVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBqdWRnZW1lbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdHlwZUFzc2VydGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBkZWZpbmVkQXNzZXJ0aW9uICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgY29udGFpbmVkQXNzZXJ0aW9uICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgc2F0aXNmaWVzQXNzZXJ0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHN1YnByb29mQXNzZXJ0aW9uICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHByb3BlcnR5QXNzZXJ0aW9uICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbWV0YXZhcmlhYmxlICggZnJhbWVTdWJzdGl0dXRpb24gfCB0ZXJtU3Vic3RpdHV0aW9uICk/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuZXF1YWxpdHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSBcIj1cIiB0ZXJtIDtcblxudHlwZUFzc2VydGlvbiAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSBcIjpcIiB0eXBlIDtcblxuZGVmaW5lZEFzc2VydGlvbiAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBmcmFtZSB8IHRlcm0gKSBcImlzXCIgKCBcImRlZmluZWRcIiB8IFwidW5kZWZpbmVkXCIgKTtcblxuY29udGFpbmVkQXNzZXJ0aW9uICAgICAgICAgICAgICAgICAgIDo6PSAgKCBmcmFtZSB8IHRlcm0gKSBcImlzXCIgKCBcInByZXNlbnRcIiB8IFwibWlzc2luZ1wiICkgXCJpblwiIHN0YXRlbWVudCA7XG5cbnNhdGlzZmllc0Fzc2VydGlvbiAgICAgICAgICAgICAgICAgICA6Oj0gIHNpZ25hdHVyZSBcInNhdGlzZmllc1wiIG1ldGF2YXJpYWJsZSA7ICBcblxuc3VicHJvb2ZBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgc3RhdGVtZW50ICggXCIsXCIgc3RhdGVtZW50ICkqIFwiXVwiIFwiLi4uXCIgc3RhdGVtZW50IDtcblxucHJvcGVydHlBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSBcImlzXCIgKCBcImFcIiB8IFwiYW5cIiApIHByb3BlcnR5UmVsYXRpb24gO1xuXG5wcm9wZXJ0eVJlbGF0aW9uICAgICAgICAgICAgICAgICAgICAgOjo9ICBwcm9wZXJ0eSBcIm9mXCIgdGVybSA7XG5cbmp1ZGdlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGZyYW1lIFwifFwiPE5PX1dISVRFU1BBQ0U+XCItXCIgYXNzdW1wdGlvbiA7XG5cbmZyYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiICggKCBhc3N1bXB0aW9uICggXCIsXCIgYXNzdW1wdGlvbiApKiApIHwgbWV0YXZhcmlhYmxlICkgXCJdXCIgO1xuIFxuYXNzdW1wdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXZhcmlhYmxlIFwiOjpcIiBzdGF0ZW1lbnQgO1xuXG50ZXJtU3Vic3RpdHV0aW9uICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIiB0ZXJtIFwiZm9yXCIgdGVybSBcIl1cIjtcblxuZnJhbWVTdWJzdGl0dXRpb24gICAgICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgZnJhbWUgXCJmb3JcIiBmcmFtZSBcIl1cIjtcblxuc3RhdGVtZW50U3Vic3RpdHV0aW9uICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgc3RhdGVtZW50IFwiZm9yXCIgc3RhdGVtZW50IFwiXVwiO1xuXG5yZWZlcmVuY2VTdWJzdGl0dXRpb24gICAgICAgICAgICAgICAgOjo9ICBcIltcIiByZWZlcmVuY2UgXCJmb3JcIiByZWZlcmVuY2UgXCJdXCI7YDtcblxuZXhwb3J0IGNvbnN0IHR5cGVWb2NhYnVsYXJ5ID0gXCJcIjtcblxuZXhwb3J0IGNvbnN0IHN5bWJvbFZvY2FidWxhcnkgPSBcIlwiO1xuXG5jb25zdCBuYW1lID0gREVGQVVMVF9DVVNUT01fR1JBTU1BUl9OQU1FLFxuICAgICAganNvbiA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdGVybUJORixcbiAgICAgICAgc3RhdGVtZW50Qk5GLFxuICAgICAgICB0eXBlVm9jYWJ1bGFyeSxcbiAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeVxuICAgICAgfTtcblxuY29uc3QgZGVmYXVsdEN1c3RvbUdyYW1tYXIgPSBDdXN0b21HcmFtbWFyLmZyb21KU09OKGpzb24pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0Q3VzdG9tR3JhbW1hcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGFtcGxlTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhFeGFtcGxlTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jbGFzcyBBIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShBLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgQiBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQiwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIEMgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEMsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBEIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShELCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgRSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIEYgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEYsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBTIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgVCBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVCwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIFYgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFYsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jb25zdCBOb25UZXJtaW5hbE5vZGVNYXAgPSB7XG4gIEEsXG4gIEIsXG4gIEMsXG4gIEQsXG4gIEUsXG4gIEYsXG4gIFMsXG4gIFQsXG4gIFZcbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9uVGVybWluYWxOb2RlTWFwO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlTWFwIGZyb20gXCIuL25vblRlcm1pbmFsTm9kZU1hcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGFtcGxlUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIE5vblRlcm1pbmFsTm9kZU1hcCA9IE5vblRlcm1pbmFsTm9kZU1hcDtcbn0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgQ09NTUFfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDeWNsZSB7XG4gIGNvbnN0cnVjdG9yKGVkZ2VzKSB7XG4gICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB9XG5cbiAgZ2V0RWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXM7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5lZGdlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG5cbiAgZ2V0RWRnZShpbmRleCkge1xuICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmVkZ2VzW2luZGV4XTtcblxuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgZ2V0VmVydGV4ZXMoKSB7XG4gICAgY29uc3QgdmVydGV4ZXMgPSB0aGlzLm1hcEVkZ2UoKGVkZ2UpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IGVkZ2UuZ2V0U291cmNlVmVydGV4KCksXG4gICAgICAgICAgICB2ZXJ0ZXggPSBzb3VyY2VWZXJ0ZXg7ICAvLy9cblxuICAgICAgcmV0dXJuIHZlcnRleDtcbiAgICB9KTtcblxuICAgIHJldHVybiB2ZXJ0ZXhlcztcbiAgfVxuXG4gIG1hcEVkZ2UoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuZWRnZXMubWFwKGNhbGxiYWNrKTsgfVxuXG4gIGV2ZXJ5RWRnZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5lZGdlcy5ldmVyeShjYWxsYmFjayk7IH1cblxuICBmb3JFYWNoRWRnZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5lZGdlcy5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGlzRXF1YWxUbyhjeWNsZSkge1xuICAgIGxldCBlcXVhbFRvID0gZmFsc2U7XG5cbiAgICBjb25zdCBjeWNsZUEgPSB0aGlzLCAgLy8vXG4gICAgICAgICAgY3ljbGVCID0gY3ljbGUsICAvLy9cbiAgICAgICAgICBjeWNsZUFMZW5ndGggPSBjeWNsZUEuZ2V0TGVuZ3RoKCksXG4gICAgICAgICAgY3ljbGVCTGVuZ3RoID0gY3ljbGVCLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKGN5Y2xlQUxlbmd0aCA9PT0gY3ljbGVCTGVuZ3RoKSB7XG4gICAgICBlcXVhbFRvID0gY3ljbGVBLmV2ZXJ5RWRnZSgoZWRnZUEsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGVkZ2VCID0gY3ljbGVCLmdldEVkZ2UoaW5kZXgpLFxuICAgICAgICAgICAgICBtYXRjaGVzID0gZWRnZUEubWF0Y2goZWRnZUIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBlcXVhbFRvO1xuICB9XG5cbiAgcGVybXV0ZWQoKSB7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLmVkZ2VzLnNsaWNlKCksIC8vL1xuICAgICAgICAgIGVkZ2UgPSBlZGdlcy5wb3AoKTtcblxuICAgIGVkZ2VzLnVuc2hpZnQoZWRnZSk7XG5cbiAgICBjb25zdCBjeWNsZSA9IG5ldyBDeWNsZShlZGdlcyk7XG5cbiAgICByZXR1cm4gY3ljbGU7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCB2ZXJ0ZXhlcyA9IHRoaXMuZ2V0VmVydGV4ZXMoKSxcbiAgICAgICAgICBzdHJpbmcgPSB2ZXJ0ZXhlcy5qb2luKENPTU1BX0NIQVJBQ1RFUik7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21FZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtcbiAgICAgICAgICAgIGVkZ2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGN5Y2xlID0gbmV3IEN5Y2xlKGVkZ2VzKTtcblxuICAgIHJldHVybiBjeWNsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRWRnZXMoZWRnZXMpIHtcbiAgICBjb25zdCBjeWNsZSA9IG5ldyBDeWNsZShlZGdlcyk7XG5cbiAgICByZXR1cm4gY3ljbGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBDeWNsZSBmcm9tIFwiLi9jeWNsZVwiO1xuXG5jb25zdCB7IGxhc3QsIGZpbmQsIGNvbXByZXNzIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0ZWRHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKGVkZ2VzLCBzdGFydFZlcnRleCkge1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgICB0aGlzLnN0YXJ0VmVydGV4ID0gc3RhcnRWZXJ0ZXg7XG4gIH1cblxuICBnZXRFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcztcbiAgfVxuXG4gIGdldFN0YXJ0VmVydGV4KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0VmVydGV4O1xuICB9XG5cbiAgYWRkRWRnZShlZGdlKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGVkZ2VzTWF0Y2hFZGdlKHRoaXMuZWRnZXMsIGVkZ2UpO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aGlzLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuICB9XG5cbiAgYWRkRWRnZXMoZWRnZXMpIHtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICB0aGlzLmFkZEVkZ2UoZWRnZSk7XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZWRnZXMuaW5kZXhPZihlZGdlKSxcbiAgICAgICAgICBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgdGhpcy5lZGdlcy5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KTtcbiAgfVxuXG4gIGRlcHRoRmlyc3RTZWFyY2godmVydGV4LCB2ZXJ0ZXhlcywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcmV2aW91c1ZlcnRleGVzID0gdmVydGV4ZXMsICAvLy9cbiAgICAgICAgICBzdWNjZXNzb3JWZXJ0ZXhlcyA9IHRoaXMuZmluZFN1Y2Nlc3NvclZlcnRleGVzKHZlcnRleCk7XG5cbiAgICBzdWNjZXNzb3JWZXJ0ZXhlcy5mb3JFYWNoKChzdWNjZXNzb3JWZXJ0ZXgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVmVydGV4ZXNJbmNsdWRlc1N1Y2Nlc3NvclZlcnRleCA9IHByZXZpb3VzVmVydGV4ZXMuaW5jbHVkZXMoc3VjY2Vzc29yVmVydGV4KSxcbiAgICAgICAgICAgIHZlcnRleGVzID0gW1xuICAgICAgICAgICAgICAuLi5wcmV2aW91c1ZlcnRleGVzLFxuICAgICAgICAgICAgICBzdWNjZXNzb3JWZXJ0ZXhcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB2ZXJ0ZXggPSBzdWNjZXNzb3JWZXJ0ZXg7ICAvLy9cblxuICAgICAgaWYgKHByZXZpb3VzVmVydGV4ZXNJbmNsdWRlc1N1Y2Nlc3NvclZlcnRleCkge1xuICAgICAgICBjYWxsYmFjayh2ZXJ0ZXhlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcHRoRmlyc3RTZWFyY2godmVydGV4LCB2ZXJ0ZXhlcywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZmluZEN5Y2xlcygpIHtcbiAgICBjb25zdCB0cml2aWFsQ3ljbGVzID0gdGhpcy5maW5kVHJpdmlhbEN5Y2xlcygpLFxuICAgICAgICAgIG5vblRyaXZpYWxDeWNsZXMgPSB0aGlzLmZpbmROb25Ucml2aWFsQ3ljbGVzKCksXG4gICAgICAgICAgY3ljbGVzID0gW1xuICAgICAgICAgICAgLi4udHJpdmlhbEN5Y2xlcyxcbiAgICAgICAgICAgIC4uLm5vblRyaXZpYWxDeWNsZXNcbiAgICAgICAgICBdO1xuXG4gICAgY29tcHJlc3MoY3ljbGVzLCAoY3ljbGVBLCBjeWNsZUIpID0+IHtcbiAgICAgIGNvbnN0IGN5Y2xlc0NvaW5jaWRlbnQgPSBhcmVDeWNsZXNDb2luY2lkZW50KGN5Y2xlQSwgY3ljbGVCKTtcblxuICAgICAgaWYgKCFjeWNsZXNDb2luY2lkZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN5Y2xlcztcbiAgfVxuXG4gIGZpbmRUcml2aWFsQ3ljbGVzKCkge1xuICAgIGNvbnN0IHRyaXZpYWxseUN5Y2xpY0VkZ2VzID0gdGhpcy5maW5kVHJpdmlhbGx5Q3ljbGljRWRnZXMoKSxcbiAgICAgICAgICB0cml2aWFsQ3ljbGVzID0gdHJpdmlhbGx5Q3ljbGljRWRnZXMubWFwKCh0cml2aWFsbHlDeWNsaWNFZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGdlID0gdHJpdmlhbGx5Q3ljbGljRWRnZSwgIC8vL1xuICAgICAgICAgICAgICAgICAgY3ljbGUgPSBDeWNsZS5mcm9tRWRnZShlZGdlKSxcbiAgICAgICAgICAgICAgICAgIHRyaXZpYWxDeWNsZSA9IGN5Y2xlOyAvLy9cblxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxDeWNsZTtcbiAgICAgICAgICB9KTtcblxuICAgIHJldHVybiB0cml2aWFsQ3ljbGVzO1xuICB9XG5cbiAgZmluZE5vblRyaXZpYWxDeWNsZXMoKSB7XG4gICAgY29uc3Qgbm9uVHJpdmlhbEN5Y2xlcyA9IFtdLFxuICAgICAgICAgIGRpcmVjdGVkR3JhcGggPSB0aGlzLCAvLy9cbiAgICAgICAgICB2ZXJ0ZXggPSB0aGlzLnN0YXJ0VmVydGV4LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleFxuICAgICAgICAgIF07XG5cbiAgICB0aGlzLmRlcHRoRmlyc3RTZWFyY2godmVydGV4LCB2ZXJ0ZXhlcywgKHZlcnRleGVzKSA9PiB7XG4gICAgICBjb25zdCBub25Ucml2aWFsQ3ljbGUgPSBub25Ucml2aWFsQ3ljbGVGcm9tVmVydGV4ZXModmVydGV4ZXMsIGRpcmVjdGVkR3JhcGgpO1xuXG4gICAgICBub25Ucml2aWFsQ3ljbGVzLnB1c2gobm9uVHJpdmlhbEN5Y2xlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBub25Ucml2aWFsQ3ljbGVzO1xuICB9XG5cbiAgZmluZFN1Y2Nlc3NvckVkZ2VzKHZlcnRleCkge1xuICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IHZlcnRleCwgIC8vL1xuICAgICAgICAgIGVkZ2VzID0gdGhpcy5maW5kRWRnZXNCeVNvdXJjZVZlcnRleChzb3VyY2VWZXJ0ZXgpLFxuICAgICAgICAgIHN1Y2Nlc3NvckVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRWZXJ0ZXggPSBlZGdlLmdldFRhcmdldFZlcnRleCgpO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0VmVydGV4ICE9PSBzb3VyY2VWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gc3VjY2Vzc29yRWRnZXM7XG4gIH1cblxuICBmaW5kU3VjY2Vzc29yVmVydGV4ZXModmVydGV4KSB7XG4gICAgY29uc3Qgc3VjY2Vzc29yRWRnZXMgPSB0aGlzLmZpbmRTdWNjZXNzb3JFZGdlcyh2ZXJ0ZXgpLFxuICAgICAgICAgIHN1Y2Nlc3NvclZlcnRleGVzID0gc3VjY2Vzc29yRWRnZXMubWFwKChzdWNjZXNzb3JFZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzb3JFZGdlVGFyZ2V0VmVydGV4ID0gc3VjY2Vzc29yRWRnZS5nZXRUYXJnZXRWZXJ0ZXgoKSxcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NvclZlcnRleCA9IHN1Y2Nlc3NvckVkZ2VUYXJnZXRWZXJ0ZXg7ICAvLy9cblxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3NvclZlcnRleDtcbiAgICAgICAgICB9KTtcblxuICAgIHJldHVybiBzdWNjZXNzb3JWZXJ0ZXhlcztcbiAgfVxuXG4gIGZpbmRFZGdlc0J5U291cmNlVmVydGV4KHNvdXJjZVZlcnRleCkge1xuICAgIGNvbnN0IGVkZ2VzID0gZmluZCh0aGlzLmVkZ2VzLCAoZWRnZSkgPT4geyAvLy9cbiAgICAgIGNvbnN0IGVkZ2VNYXRjaGVzU291cmNlVmVydGV4ID0gZWRnZS5tYXRjaFNvdXJjZVZlcnRleChzb3VyY2VWZXJ0ZXgpO1xuXG4gICAgICBpZiAoZWRnZU1hdGNoZXNTb3VyY2VWZXJ0ZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWRnZXM7XG4gIH1cblxuICBmaW5kVHJpdmlhbGx5Q3ljbGljRWRnZXMoKSB7XG4gICAgY29uc3QgdHJpdmlhbGx5Q3ljbGljRWRnZXMgPSBmaW5kKHRoaXMuZWRnZXMsIChlZGdlKSA9PiB7XG4gICAgICBjb25zdCBlZGdlVHJpdmlhbGx5Q3ljbGljID0gZWRnZS5pc1RyaXZpYWxseUN5Y2xpYygpO1xuXG4gICAgICBpZiAoZWRnZVRyaXZpYWxseUN5Y2xpYykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cml2aWFsbHlDeWNsaWNFZGdlcztcbiAgfVxuXG4gIGZpbmRFZGdlQnlTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgoc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBlZGdlID0gdGhpcy5lZGdlcy5maW5kKChlZGdlKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZWRnZS5tYXRjaFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCk7XG5cbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRWRnZXNBbmRTdGFydFZlcnRleChlZGdlcywgc3RhcnRWZXJ0ZXgpIHtcbiAgICBjb25zdCBkaXJlY3RlZEdyYXBoID0gbmV3IERpcmVjdGVkR3JhcGgoZWRnZXMsIHN0YXJ0VmVydGV4KTtcblxuICAgIHJldHVybiBkaXJlY3RlZEdyYXBoO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGdlc01hdGNoRWRnZShlZGdlcywgZWRnZSkge1xuICBjb25zdCBlZGdlQSA9IGVkZ2UsIC8vL1xuICAgICAgICBtYXRjaGVzID0gZWRnZXMuc29tZSgoZWRnZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVkZ2VCID0gZWRnZSwgLy8vXG4gICAgICAgICAgICAgICAgZWRnZUFNYXRjaGVzRWRnZUIgPSBlZGdlQS5tYXRjaChlZGdlQik7XG5cbiAgICAgICAgICBpZiAoZWRnZUFNYXRjaGVzRWRnZUIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIG5vblRyaXZpYWxDeWNsZUZyb21WZXJ0ZXhlcyh2ZXJ0ZXhlcywgZGlyZWN0ZWRHcmFwaCkge1xuICBjb25zdCBsYXN0VmVydGV4ID0gbGFzdCh2ZXJ0ZXhlcyksXG4gICAgICAgIGluZGV4ID0gdmVydGV4ZXMuaW5kZXhPZihsYXN0VmVydGV4KSxcbiAgICAgICAgc3RhcnQgPSBpbmRleDsgIC8vL1xuXG4gIHZlcnRleGVzID0gdmVydGV4ZXMuc2xpY2Uoc3RhcnQpOyAvLy9cblxuICB2ZXJ0ZXhlcy5wb3AoKTtcblxuICBjb25zdCBsZW5ndGggPSB2ZXJ0ZXhlcy5sZW5ndGgsXG4gICAgICAgIGVkZ2VzID0gdmVydGV4ZXMubWFwKCh2ZXJ0ZXgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBsZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV4dFZlcnRleCA9IHZlcnRleGVzW25leHRJbmRleF0sXG4gICAgICAgICAgICAgICAgc291cmNlVmVydGV4ID0gdmVydGV4LCAgLy8vXG4gICAgICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gbmV4dFZlcnRleCwgLy8vXG4gICAgICAgICAgICAgICAgZWRnZSA9IGRpcmVjdGVkR3JhcGguZmluZEVkZ2VCeVNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCk7XG5cbiAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgfSksXG4gICAgICAgIGN5Y2xlID0gQ3ljbGUuZnJvbUVkZ2VzKGVkZ2VzKTtcblxuICByZXR1cm4gY3ljbGU7XG59XG5cbmZ1bmN0aW9uIHNvbWVDeWNsZVBlcm11dGF0aW9uKGN5Y2xlLCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgY29uc3QgbGVuZ3RoID0gY3ljbGUuZ2V0TGVuZ3RoKCk7XG5cbiAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIHJlc3VsdCA9IGNhbGxiYWNrKGN5Y2xlKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGN5Y2xlID0gY3ljbGUucGVybXV0ZWQoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFyZUN5Y2xlc0NvaW5jaWRlbnQoY3ljbGVBLCBjeWNsZUIpIHtcbiAgbGV0IGN5Y2xlc0NvaW5jaWRlbnQgPSBmYWxzZTtcblxuICBjb25zdCBjeWNsZUFMZW5ndGggPSBjeWNsZUEuZ2V0TGVuZ3RoKCksXG4gICAgICAgIGN5Y2xlQkxlbmd0aCA9IGN5Y2xlQi5nZXRMZW5ndGgoKTtcblxuICBpZiAoY3ljbGVBTGVuZ3RoID09PSBjeWNsZUJMZW5ndGgpIHtcbiAgICBjeWNsZXNDb2luY2lkZW50ID0gc29tZUN5Y2xlUGVybXV0YXRpb24oY3ljbGVBLCAoY3ljbGVBKSA9PiB7XG4gICAgICBjb25zdCBjeWNsZUFFcXVhbFRvID0gY3ljbGVBLmlzRXF1YWxUbyhjeWNsZUIpO1xuXG4gICAgICBpZiAoY3ljbGVBRXF1YWxUbykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjeWNsZXNDb2luY2lkZW50O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVkdWNlZE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IGAke3J1bGVOYW1lfV9gO1xuXG4gIHJldHVybiByZWR1Y2VkUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZUZyb21SZWR1Y2VkUnVsZU5hbWUocmVkdWNlZFJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lLnJlcGxhY2UoL18kL2csIEVNUFRZX1NUUklORyk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGAke3J1bGVOYW1lfX5gO1xuXG4gIHJldHVybiBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZUZyb21JbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSkge1xuICBjb25zdCBydWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLnJlcGxhY2UoL34uKyQvZywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVGcm9tSW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUoaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUpIHtcbiAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUucmVwbGFjZSgvXltefl0rfi9nLCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gYCR7cnVsZU5hbWV9fiR7bGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lfWA7XG5cbiAgcmV0dXJuIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBwdXNoLCBjb21wcmVzcyB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3ljbGVJcnJlZHVjaWJsZShjeWNsZSwgcnVsZU1hcCkge1xuICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpLFxuICAgICAgICByZWR1Y2VkUnVsZXMgPSBydWxlTmFtZXMucmVkdWNlKChyZWR1Y2VkUnVsZXMsIHJ1bGVOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICAgICAgICByZWR1Y2VkUnVsZSA9IHJ1bGVNYXBbcmVkdWNlZFJ1bGVOYW1lXSB8fCBudWxsO1xuXG4gICAgICAgICAgaWYgKHJlZHVjZWRSdWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWR1Y2VkUnVsZXMucHVzaChyZWR1Y2VkUnVsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlZHVjZWRSdWxlcztcbiAgICAgICAgfSwgW10pLFxuICAgICAgICByZWR1Y2VkUnVsZXNMZW5ndGggPSByZWR1Y2VkUnVsZXMubGVuZ3RoLFxuICAgICAgICBjeWNsZUlycmVkdWNpYmxlID0gKHJlZHVjZWRSdWxlc0xlbmd0aCA9PT0gMCk7IC8vL1xuXG4gIHJldHVybiBjeWNsZUlycmVkdWNpYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlLCBydWxlTmFtZXMgPSBbXSkge1xuICBjb25zdCBjeWNsZVZlcnRleGVzID0gY3ljbGUuZ2V0VmVydGV4ZXMoKSxcbiAgICAgICAgY3ljbGVSdWxlTmFtZXMgPSBjeWNsZVZlcnRleGVzOyAvLy9cblxuICBwdXNoKHJ1bGVOYW1lcywgY3ljbGVSdWxlTmFtZXMpO1xuXG4gIHJldHVybiBydWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZXNGcm9tQ3ljbGVzKGN5Y2xlcywgcnVsZU5hbWVzID0gW10pIHtcbiAgY3ljbGVzLmZvckVhY2goKGN5Y2xlKSA9PiB7XG4gICAgcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlLCBydWxlTmFtZXMpO1xuICB9KTtcblxuICBjb21wcmVzcyhydWxlTmFtZXMsIChydWxlTmFtZUEsIHJ1bGVOYW1lQikgPT4ge1xuICAgIGlmIChydWxlTmFtZUEgIT09IHJ1bGVOYW1lQikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcnVsZU5hbWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZUN5Y2xlc0Zyb21SdWxlTmFtZUFuZEN5Y2xlcyhydWxlTmFtZSwgY3ljbGVzKSB7XG4gIGNvbnN0IHJ1bGVDeWNsZXMgPSBjeWNsZXMucmVkdWNlKChydWxlQ3ljbGVzLCBjeWNsZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSksXG4gICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZVJ1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgIGlmIChydWxlTmFtZXNJbmNsdWRlUnVsZU5hbWUpIHtcbiAgICAgIGNvbnN0IHJ1bGVDeWNsZSA9IGN5Y2xlOyAgLy8vXG5cbiAgICAgIHJ1bGVDeWNsZXMucHVzaChydWxlQ3ljbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlQ3ljbGVzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHJ1bGVDeWNsZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuY29uc3QgeyBlcHNpbG9uLCBub1doaXRlc3BhY2UsIHN0YXJ0T2ZDb250ZW50IH0gPSBzcGVjaWFsU3ltYm9scyxcbiAgICAgIHsgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgICAgICAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gICAgICAgIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gICAgICAgIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bGVOb25Db25zdW1pbmcocnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzID0gW10pIHtcbiAgbGV0IHJ1bGVOb25Db25zdW1pbmcgPSBmYWxzZTtcblxuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICBpZiAoIXJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICBydWxlTmFtZXMgPSBbIC8vL1xuICAgICAgLi4ucnVsZU5hbWVzLFxuICAgICAgcnVsZU5hbWVcbiAgICBdO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCksXG4gICAgICAgICAgZGVmaW5pdGlvbnNOb25Db25zdW1pbmcgPSBhcmVEZWZpbml0aW9uc05vbkNvbnN1bWluZyhkZWZpbml0aW9ucywgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIHJ1bGVOb25Db25zdW1pbmcgPSBkZWZpbml0aW9uc05vbkNvbnN1bWluZzsgLy8vXG4gIH1cblxuICByZXR1cm4gcnVsZU5vbkNvbnN1bWluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFydE5vbkNvbnN1bWluZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMgPSBbXSkge1xuICBsZXQgcGFydE5vbkNvbnN1bWluZztcblxuICBjb25zdCBwYXJUZXJtaW5hbFBhcnQgPSBwYXJ0LmlzVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhclRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmcgPSBpc1Rlcm1pbmFsUGFydE5vbkNvbnN1bWluZyh0ZXJtaW5hbFBhcnQpO1xuXG4gICAgcGFydE5vbkNvbnN1bWluZyA9IHRlcm1pbmFsUGFydE5vbkNvbnN1bWluZzsgLy8vXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbFBhcnROb25Db25zdW1pbmcgPSBpc05vblRlcm1pbmFsUGFydE5vbkNvbnN1bWluZyhub25UZXJtaW5hbE5QYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgcGFydE5vbkNvbnN1bWluZyA9IG5vblRlcm1pbmFsUGFydE5vbkNvbnN1bWluZzsgLy8vXG4gIH1cblxuICByZXR1cm4gcGFydE5vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gYXJlRGVmaW5pdGlvbnNOb25Db25zdW1pbmcoZGVmaW5pdGlvbnMsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBkZWZpbml0aW9uc05vbkNvbnN1bWluZyA9IGRlZmluaXRpb25zLnNvbWUoKGRlZmluaXRpb24pID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uTm9uQ29uc3VtaW5nID0gaXNEZWZpbml0aW9uTm9uQ29uc3VtaW5nKGRlZmluaXRpb24sIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbk5vbkNvbnN1bWluZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvbnNOb25Db25zdW1pbmc7XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5pdGlvbk5vbkNvbnN1bWluZyhkZWZpbml0aW9uLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIHBhcnRzTm9uQ29uc3VtaW5nID0gYXJlUGFydHNOb25Db25zdW1pbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcyksXG4gICAgICAgIGRlZmluaXRpb25Ob25Db25zdW1pbmcgPSBwYXJ0c05vbkNvbnN1bWluZzsgLy8vXG5cbiAgcmV0dXJuIGRlZmluaXRpb25Ob25Db25zdW1pbmc7XG59XG5cbmZ1bmN0aW9uIGFyZVBhcnRzTm9uQ29uc3VtaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHNOb25Db25zdW1pbmcgPSBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgIGNvbnN0IHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIGlmIChwYXJ0Tm9uQ29uc3VtaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJ0c05vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gaXNUZXJtaW5hbFBhcnROb25Db25zdW1pbmcodGVybWluYWxQYXJ0KSB7XG4gIGxldCB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmc7XG5cbiAgY29uc3QgdGVybWluYWxQYXJ0U3RyaW5nID0gdGVybWluYWxQYXJ0LmFzU3RyaW5nKCk7XG5cbiAgc3dpdGNoICh0ZXJtaW5hbFBhcnRTdHJpbmcpIHtcbiAgICBjYXNlIGVwc2lsb246XG4gICAgY2FzZSBub1doaXRlc3BhY2U6XG4gICAgY2FzZSBzdGFydE9mQ29udGVudDoge1xuICAgICAgdGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nID0gdHJ1ZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgdGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nID0gZmFsc2U7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmc7XG59XG5cbmZ1bmN0aW9uIGlzTm9uVGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nKG5vblRlcm1pbmFsUGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGxldCBwYXJ0Tm9uQ29uc3VtaW5nID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSdWxlTmFtZVBhcnRUeXBlOiB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVQYXJ0LmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0gfHwgbnVsbDtcblxuICAgICAgaWYgKHJ1bGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcnVsZU5vbkNvbnN1bWluZyA9IGlzUnVsZU5vbkNvbnN1bWluZyhydWxlLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICAgIHBhcnROb25Db25zdW1pbmcgPSBydWxlTm9uQ29uc3VtaW5nOyAgLy8vXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgT3B0aW9uYWxQYXJ0UGFydFR5cGU6IHtcbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSB0cnVlO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIE9uZU9yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgcGFydE5vbkNvbnN1bWluZyA9IHRydWU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgcGFydHMgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c05vbkNvbnN1bWluZyA9IGFyZVBhcnRzTm9uQ29uc3VtaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICBwYXJ0Tm9uQ29uc3VtaW5nID0gcGFydHNOb25Db25zdW1pbmc7IC8vL1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIENob2ljZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgcGFydHMgPSBjaG9pY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpLFxuICAgICAgICAgICAgcGFydHNOb25Db25zdW1pbmcgPSBwYXJ0cy5zb21lKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgICAgICAgICByZXR1cm4gcGFydE5vbkNvbnN1bWluZztcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSBwYXJ0c05vbkNvbnN1bWluZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uQ29uc3VtaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJ0VHlwZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IGlzUGFydE5vbkNvbnN1bWluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvbm9uQ29uc3VtaW5nXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUoZGVmaW5pdGlvbiwgcnVsZU1hcCkge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgcGFydHNMZWZ0UmVjdXJzaXZlID0gYXJlUGFydHNMZWZ0UmVjdXJzaXZlKHBhcnRzLCBydWxlTWFwKSxcbiAgICAgICAgZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUgPSBwYXJ0c0xlZnRSZWN1cnNpdmU7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZShydWxlLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCk7XG5cbiAgZGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IFtdKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydHMocGFydHMsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gIHJldHVybiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzO1xufVxuXG5mdW5jdGlvbiBhcmVQYXJ0c0xlZnRSZWN1cnNpdmUocGFydHMsIHJ1bGVNYXApIHtcbiAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydHMocGFydHMsIHJ1bGVNYXApLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5sZW5ndGgsXG4gICAgICAgIHBhcnRzTGVmdFJlY3Vyc2l2ZSA9IChsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID4gMCk7XG5cbiAgcmV0dXJuIHBhcnRzTGVmdFJlY3Vyc2l2ZTtcbn1cblxuZnVuY3Rpb24gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydE5vblRlcm1pbmFsUGFydCA9IHBhcnQuaXNOb25UZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgIHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVQYXJ0LmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lOyAvLy9cblxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMucHVzaChsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgT3B0aW9uYWxQYXJ0UGFydFR5cGU6IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0UGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnQgPSBvcHRpb25hbFBhcnRQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvbmVPck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHplcm9Pck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gemVyb09yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydHMgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgICAgICAgcGFydCA9IGZpcnN0UGFydDsgLy8vXG5cbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIENob2ljZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBjaG9pY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gY2hvaWNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKTtcblxuICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnRzKHBhcnRzLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgcGFydHMuZXZlcnkoKHBhcnQpID0+IHtcbiAgICBjb25zdCBwYXJ0Tm9uQ29uc3VtaW5nID0gaXNQYXJ0Tm9uQ29uc3VtaW5nKHBhcnQsIHJ1bGVNYXApO1xuXG4gICAgaWYgKCFwYXJ0Tm9uQ29uc3VtaW5nKSB7XG4gICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2Uge1xuICBjb25zdHJ1Y3RvcihsYWJlbCxzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnNvdXJjZVZlcnRleCA9IHNvdXJjZVZlcnRleDtcbiAgICB0aGlzLnRhcmdldFZlcnRleCA9IHRhcmdldFZlcnRleDtcbiAgfVxuXG4gIGdldExhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICB9XG5cbiAgZ2V0U291cmNlVmVydGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZVZlcnRleDtcbiAgfVxuXG4gIGdldFRhcmdldFZlcnRleCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRWZXJ0ZXg7XG4gIH1cblxuICBpc1RyaXZpYWxseUN5Y2xpYygpIHtcbiAgICBjb25zdCB0cml2aWFsbHlDeWNsaWMgPSAodGhpcy5zb3VyY2VWZXJ0ZXggPT09IHRoaXMudGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiB0cml2aWFsbHlDeWNsaWM7XG4gIH1cblxuICBtYXRjaChlZGdlKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsKCksXG4gICAgICAgICAgc291cmNlVmVydGV4ID0gZWRnZS5nZXRTb3VyY2VWZXJ0ZXgoKSxcbiAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSBlZGdlLmdldFRhcmdldFZlcnRleCgpLFxuICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLm1hdGNoTGFiZWxTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgbWF0Y2hTb3VyY2VWZXJ0ZXgoc291cmNlVmVydGV4KSB7XG4gICAgY29uc3QgbWF0Y2hlc1NvdXJjZVZlcnRleCA9ICh0aGlzLnNvdXJjZVZlcnRleCA9PT0gc291cmNlVmVydGV4KTtcblxuICAgIHJldHVybiBtYXRjaGVzU291cmNlVmVydGV4O1xuICB9XG5cbiAgbWF0Y2hUYXJnZXRWZXJ0ZXgodGFyZ2V0VmVydGV4KSB7XG4gICAgY29uc3QgbWF0Y2hlc1RhcmdldFZlcnRleCA9ICh0aGlzLnRhcmdldFZlcnRleCA9PT0gdGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiBtYXRjaGVzVGFyZ2V0VmVydGV4O1xuICB9XG5cbiAgbWF0Y2hTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgoc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gKCh0aGlzLnNvdXJjZVZlcnRleCA9PT0gc291cmNlVmVydGV4KSAmJiAodGhpcy50YXJnZXRWZXJ0ZXggPT09IHRhcmdldFZlcnRleCkpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBtYXRjaExhYmVsU291cmNlVmVydGV4QW5kVGFyZ2V0VmVydGV4KGxhYmVsLCBzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoKHRoaXMubGFiZWwgPT09IGxhYmVsKSAmJiAodGhpcy5zb3VyY2VWZXJ0ZXggPT09IHNvdXJjZVZlcnRleCkgJiYgKHRoaXMudGFyZ2V0VmVydGV4ID09PSB0YXJnZXRWZXJ0ZXgpKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21MYWJlbFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBlZGdlID0gbmV3IEVkZ2UobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiBlZGdlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNvbnN0IHsgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgICAgICAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gICAgICAgIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUsXG4gICAgICAgIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZShydWxlLCByZWN1cnNpdmVSdWxlTmFtZXMgPSBbXSkge1xuICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICBkZWZpbml0aW9ucy5mb3JFYWNoKChkZWZpbml0aW9uKSA9PiB7XG4gICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlY3Vyc2l2ZVJ1bGVOYW1lcztcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCk7XG5cbiAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnRzKHBhcnRzLCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gIHJldHVybiByZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0cyhwYXJ0cywgcmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gIH0pO1xuXG4gIHJldHVybiByZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUnVsZU5hbWVQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJlY3Vyc2l2ZVJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFyZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgY29uc3QgcmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXMucHVzaChyZWN1cnNpdmVSdWxlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvbmVPck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpOyAgLy8vXG5cbiAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gc2VxdWVuY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpO1xuXG4gICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBDaG9pY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0cyA9IGNob2ljZU9mUGFydHNQYXJ0LmdldFBhcnRzKCk7XG5cbiAgICAgICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBSRUNVUlNJVkVfTEFCRUwgPSBcInJlY3Vyc2l2ZVwiO1xuZXhwb3J0IGNvbnN0IExFRlRfUkVDVVJTSVZFX0xBQkVMID0gXCJsZWZ0LXJlY3Vyc2l2ZVwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWRnZSBmcm9tIFwiLi4vZWRnZVwiO1xuXG5pbXBvcnQgeyBlZGdlc01hdGNoRWRnZSB9IGZyb20gXCIuLi9kaXJlY3RlZEdyYXBoXCI7XG5pbXBvcnQgeyByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVjdXJzaXZlXCI7XG5pbXBvcnQgeyBSRUNVUlNJVkVfTEFCRUwsIExFRlRfUkVDVVJTSVZFX0xBQkVMIH0gZnJvbSBcIi4uL2xhYmVsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZWRnZXNGcm9tUnVsZU5hbWVzKHJ1bGVOYW1lcykge1xuICBjb25zdCBsZW5ndGggPSBydWxlTmFtZXMubGVuZ3RoLFxuICAgICAgICBlZGdlcyA9IHJ1bGVOYW1lcy5tYXAoKHJ1bGVOYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IChpbmRleCArIDEpICUgbGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5leHRSdWxlTmFtZSA9IHJ1bGVOYW1lc1tuZXh0SW5kZXhdLFxuICAgICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IG5leHRSdWxlTmFtZSwgLy8vXG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2VGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZXNGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHJ1bGUgPSBzdGFydFJ1bGUsIC8vL1xuICAgICAgICBlZGdlcyA9IFtdLFxuICAgICAgICB2ZXJ0ZXhlcyA9IFtdO1xuXG4gIGVkZ2VzRnJvbVJ1bGUocnVsZSwgZWRnZXMsIHZlcnRleGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICBjb25zdCBsYWJlbCA9IExFRlRfUkVDVVJTSVZFX0xBQkVMLFxuICAgICAgICBzb3VyY2VWZXJ0ZXggPSBydWxlTmFtZSwgIC8vL1xuICAgICAgICB0YXJnZXRWZXJ0ZXggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIC8vL1xuICAgICAgICBlZGdlID0gRWRnZS5mcm9tTGFiZWxTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gZWRnZXNGcm9tUnVsZShydWxlLCBlZGdlcywgdmVydGV4ZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICB2ZXJ0ZXggPSBydWxlTmFtZSwgIC8vL1xuICAgICAgICB2ZXJ0ZXhlc0luY2x1ZGVzVmVydGV4ID0gdmVydGV4ZXMuaW5jbHVkZXModmVydGV4KTtcblxuICBpZiAodmVydGV4ZXNJbmNsdWRlc1ZlcnRleCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZlcnRleGVzID0gW1xuICAgIC4uLnZlcnRleGVzLFxuICAgIHZlcnRleFxuICBdO1xuXG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc01hcFtydWxlTmFtZV0sXG4gICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21SdWxlKHJ1bGUpLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gcnVsZU5hbWVzOyAvLy9cblxuICByZWN1cnNpdmVSdWxlTmFtZXMuZm9yRWFjaCgocmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSZWN1cnNpdmVSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMuaW5jbHVkZXMocmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJlY3Vyc2l2ZVJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgbGFiZWwgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSZWN1cnNpdmVSdWxlTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIExFRlRfUkVDVVJTSVZFX0xBQkVMIDpcbiAgICAgICAgICAgICAgICAgICAgICBSRUNVUlNJVkVfTEFCRUwsXG4gICAgICAgICAgc291cmNlVmVydGV4ID0gcnVsZU5hbWUsICAvLy9cbiAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIC8vL1xuICAgICAgICAgIGVkZ2UgPSBFZGdlLmZyb21MYWJlbFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpLFxuICAgICAgICAgIG1hdGNoZXMgPSBlZGdlc01hdGNoRWRnZShlZGdlcywgZWRnZSk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjdXJzaXZlUnVsZSA9IHJ1bGVNYXBbcmVjdXJzaXZlUnVsZU5hbWVdIHx8IG51bGw7XG5cbiAgICBpZiAocmVjdXJzaXZlUnVsZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcnVsZSA9IHJlY3Vyc2l2ZVJ1bGU7IC8vL1xuXG4gICAgICBlZGdlc0Zyb21SdWxlKHJ1bGUsIGVkZ2VzLCB2ZXJ0ZXhlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcbiAgICB9XG4gIH0pO1xufVxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJ1bGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgUmVkdWNlZE5vZGUgZnJvbSBcIi4uL25vZGUvcmVkdWNlZFwiO1xuXG5pbXBvcnQgeyBlZGdlc01hdGNoRWRnZSB9IGZyb20gXCIuLi9kaXJlY3RlZEdyYXBoXCI7XG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5pbXBvcnQgeyByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5pbXBvcnQgeyBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24gfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2xlZnRSZWN1cnNpdmVcIjtcbmltcG9ydCB7IGVkZ2VzRnJvbVJ1bGVOYW1lcywgZWRnZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvZGlyZWN0ZWRHcmFwaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VkUnVsZSBleHRlbmRzIFJ1bGUge1xuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gUmVkdWNlZE5vZGU7XG5cbiAgICByZXR1cm4gTm9uVGVybWluYWxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBsZXQgcmVkdWNlZFJ1bGUgPSBudWxsLFxuICAgICAgICBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnMuZmlsdGVyKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uTGVmdFJlZHVjaWJsZSA9IGlzRGVmaW5pdGlvblJlZHVjaWJsZShkZWZpbml0aW9uLCBydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwKTtcblxuICAgICAgaWYgKGRlZmluaXRpb25MZWZ0UmVkdWNpYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnNMZW5ndGggPSBkZWZpbml0aW9ucy5sZW5ndGg7XG5cbiAgICBpZiAoZGVmaW5pdGlvbnNMZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICAgIG5hbWUgPSByZWR1Y2VkUnVsZU5hbWUsIC8vL1xuICAgICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpO1xuXG4gICAgICByZWR1Y2VkUnVsZSA9IG5ldyBSZWR1Y2VkUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHVjZWRSdWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5pdGlvblJlZHVjaWJsZShkZWZpbml0aW9uLCBydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwKSB7XG4gIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcnVsZU1hcCksXG4gICAgICAgIGRlZmluaXRpb25SZWR1Y2libGUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmV2ZXJ5KChsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBjeWNsZXNJbmNsdWRlUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBjeWNsZXMuc29tZSgoY3ljbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN5Y2xlSW5jbHVkZXNSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGRvZXNDeWNsZUluY2x1ZGVSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShjeWNsZSwgcnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChjeWNsZUluY2x1ZGVzUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWN5Y2xlc0luY2x1ZGVSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvblJlZHVjaWJsZTtcbn1cblxuZnVuY3Rpb24gZG9lc0N5Y2xlSW5jbHVkZVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKGN5Y2xlLCBydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSksXG4gICAgICAgIGVkZ2UgPSBlZGdlRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICBlZGdlcyA9IGVkZ2VzRnJvbVJ1bGVOYW1lcyhydWxlTmFtZXMpLFxuICAgICAgICBtYXRjaGVzID0gZWRnZXNNYXRjaEVkZ2UoZWRnZXMsIGVkZ2UpLFxuICAgICAgICBjeWNsZUluY2x1ZGVzUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBtYXRjaGVzOyAgLy8vXG5cbiAgcmV0dXJuIGN5Y2xlSW5jbHVkZXNSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlZHVjZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVkdWNlZFwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZWRSdWxlcyhjeWNsZXMsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlcyhjeWNsZXMpO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgICByZWR1Y2VkUnVsZSA9IFJlZHVjZWRSdWxlLmZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCk7XG5cbiAgICBpZiAocmVkdWNlZFJ1bGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IHJlZHVjZWRSdWxlLmdldE5hbWUoKTtcblxuICAgICAgcnVsZU1hcFtyZWR1Y2VkUnVsZU5hbWVdID0gcmVkdWNlZFJ1bGU7XG4gICAgfVxuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZChub25UZXJtaW5hbE5vZGUpIHtcbiAgbGV0IG5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQ7XG5cbiAgY29uc3QgY2hpbGROb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gbm9uVGVybWluYWxOb2RlLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgY2hpbGROb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gaXNOb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkKGNoaWxkTm9uVGVybWluYWxOb2RlKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIGlmIChjaGlsZE5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQpIHtcbiAgICBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gbm9uVGVybWluYWxOb2RlLmdldFByZWNlZGVuY2UoKTtcblxuICAgIGlmIChwcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gbm9uVGVybWluYWxOb2RlLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4geyAgLy8vXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSA9IGNoaWxkTm9kZS5pc0xvd2VyUHJlY2VkZW5jZShydWxlTmFtZSwgcHJlY2VkZW5jZSk7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IHsgcmV3cml0ZURpcmVjdGx5UmVwZWF0ZWROb2RlcyB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcmV3cml0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RseVJlcGVhdGVkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJld3JpdGUoc3RhdGUpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSB0aGlzLmNsb25lKCk7XG5cbiAgICByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGlyZWN0bHlSZXBlYXRlZE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFcHNpbG9uTm9kZSwgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaXJlY3RseVJlcGVhdGVkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGlzTnVsbGFyeSgpIHtcbiAgICBsZXQgbnVsbGFyeSA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc2luZ3VsYXIgPSB0aGlzLmlzU2luZ3VsYXIoKTtcblxuICAgIGlmIChzaW5ndWxhcikge1xuICAgICAgbnVsbGFyeSA9IHRoaXMuZXZlcnlDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgRXBzaWxvbk5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxhcnk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEluZGlyZWN0bHlSZXBlYXRlZE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFJlZHVjZWROb2RlIGZyb20gXCIuLi9ub2RlL3JlZHVjZWRcIjtcbmltcG9ydCBEaXJlY3RseVJlcGVhdGVkTm9kZSBmcm9tIFwiLi4vbm9kZS9yZXBlYXRlZC9kaXJlY3RseVwiO1xuaW1wb3J0IEluZGlyZWN0bHlSZXBlYXRlZE5vZGUgZnJvbSBcIi4uL25vZGUvcmVwZWF0ZWQvaW5kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZUZyb21SZWR1Y2VkUnVsZU5hbWUsIHJ1bGVOYW1lRnJvbUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVGcm9tSW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmNvbnN0IHsgcHVzaCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlUmVkdWNlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpIHtcbiAgbGV0IHJlZHVjZWRDaGlsZE5vZGU7XG5cbiAgY29uc3QgZmlyc3RDaGlsZE5vZGVSZWR1Y2VkTm9kZSA9IG5vblRlcm1pbmFsTm9kZS5zb21lQ2hpbGROb2RlKChjaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgUmVkdWNlZE5vZGUpIHtcbiAgICAgICAgcmVkdWNlZENoaWxkTm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGlmICghZmlyc3RDaGlsZE5vZGVSZWR1Y2VkTm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub25UZXJtaW5hbE5vZGUsIC8vL1xuICAgICAgICByZXBsYWNlZENoaWxkTm9kZSA9IHJlZHVjZWRDaGlsZE5vZGUsIC8vL1xuICAgICAgICByZXBsYWNlZENoaWxkTm9kZU9wYWNpdHkgPSByZXBsYWNlZENoaWxkTm9kZS5nZXRPcGFjaXR5KCksXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlUnVsZU5hbWUgPSByZXBsYWNlZENoaWxkTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICByZXBsYWNlZENoaWxkTm9kZVByZWNlZGVuY2UgPSByZXBsYWNlZENoaWxkTm9kZS5nZXRQcmVjZWRlbmNlKCksXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlQ2hpbGROb2RlcyA9IHJlcGxhY2VkQ2hpbGROb2RlLnJlbW92ZUNoaWxkTm9kZXMoKSxcbiAgICAgICAgcGFyZW50Tm9kZVJ1bGVOYW1lID0gcGFyZW50Tm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICByZWR1Y2VkUnVsZU5hbWUgPSByZXBsYWNlZENoaWxkTm9kZVJ1bGVOYW1lLCAgLy8vXG4gICAgICAgIHBhcmVudFJ1bGVOYW1lID0gcGFyZW50Tm9kZVJ1bGVOYW1lLCAgLy8vXG4gICAgICAgIHByZWNlZGVuY2UgPSByZXBsYWNlZENoaWxkTm9kZVByZWNlZGVuY2UsIC8vL1xuICAgICAgICBvcGFjaXR5ID0gcmVwbGFjZWRDaGlsZE5vZGVPcGFjaXR5LCAvLy9cbiAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZUZyb21SZWR1Y2VkUnVsZU5hbWUocmVkdWNlZFJ1bGVOYW1lKTtcblxuICBsZXQgcmVwbGFjZW1lbnRDaGlsZE5vZGVzO1xuXG4gIGlmIChydWxlTmFtZSA9PT0gcGFyZW50UnVsZU5hbWUpIHtcbiAgICByZXBsYWNlbWVudENoaWxkTm9kZXMgPSByZXBsYWNlZENoaWxkTm9kZUNoaWxkTm9kZXM7ICAvLy9cblxuICAgIHBhcmVudE5vZGUuc2V0UHJlY2VkZW5jZShwcmVjZWRlbmNlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gcmVwbGFjZWRDaGlsZE5vZGVDaGlsZE5vZGVzLCAvLy9cbiAgICAgICAgICBOb25UZXJtaW5hbE5vZGUgPSBzdGF0ZS5Ob25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpLFxuICAgICAgICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlID0gbm9uVGVybWluYWxOb2RlOyAvLy9cblxuICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlcyA9IFtcbiAgICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlXG4gICAgXTtcbiAgfVxuXG4gIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkTm9kZShyZXBsYWNlZENoaWxkTm9kZSwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJld3JpdGVEaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBzdGF0ZSkge1xuICBsZXQgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQ7XG5cbiAgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSByZXBsYWNlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgd2hpbGUgKGRpcmVjdGx5UmVwZWF0ZWROb2Rlc1JlcGxhY2VkKSB7XG4gICAgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSByZXBsYWNlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJld3JpdGVJbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUsIHN0YXRlKSB7XG4gIGxldCBwYXJlbnROb2RlID0gbm9uVGVybWluYWxOb2RlOyAvLy9cblxuICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlcyA9IGZpbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpO1xuXG4gIGluZGlyZWN0bHlSZXBlYXRlZE5vZGVzLmZvckVhY2goKGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpID0+IHtcbiAgICBjb25zdCBsZWZ0UmVjdXJzaXZlTm9kZSA9IGxlZnRSZWN1cnNpdmVOb2RlRnJvbVBhcmVudE5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUsIHN0YXRlKSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0Zyb21MZWZ0UmVjdXJzaXZlTm9kZU5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKGxlZnRSZWN1cnNpdmVOb2RlLCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlKTtcblxuICAgIGFkanVzdFBhcmVudE5vZGVQcmVjZWRlbmNlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpO1xuXG4gICAgcGFyZW50Tm9kZS5zZXRDaGlsZE5vZGVzKGNoaWxkTm9kZXMpO1xuXG4gICAgcGFyZW50Tm9kZSA9IGxlZnRSZWN1cnNpdmVOb2RlOyAvLy9cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgUmVwZWF0ZWROb2RlKSB7XG4gIGxldCByZXBlYXRlZE5vZGVzO1xuXG4gIGxldCBlbmRJbmRleCA9IC0xO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5iYWNrd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlUmVwZWF0ZWROb2RlID0gKGNoaWxkTm9kZSBpbnN0YW5jZW9mIFJlcGVhdGVkTm9kZSk7XG5cbiAgICBpZiAoY2hpbGROb2RlUmVwZWF0ZWROb2RlKSB7XG4gICAgICBlbmRJbmRleCA9IGluZGV4ICsgMTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZW5kSW5kZXggPT09IC0xKSB7XG4gICAgcmVwZWF0ZWROb2RlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIGxldCBzdGFydEluZGV4O1xuXG4gICAgbm9uVGVybWluYWxOb2RlLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZVJlcGVhdGVkTm9kZSA9IChjaGlsZE5vZGUgaW5zdGFuY2VvZiBSZXBlYXRlZE5vZGUpO1xuXG4gICAgICBpZiAoIWNoaWxkTm9kZVJlcGVhdGVkTm9kZSkge1xuICAgICAgICBpZiAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDsgLy8vXG4gICAgfSk7XG5cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLnNsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cbiAgICByZXBlYXRlZE5vZGVzID0gY2hpbGROb2RlczsgLy8vXG4gIH1cblxuICByZXR1cm4gcmVwZWF0ZWROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbnRDaGlsZE5vZGVzKHBhcmVudE5vZGUpIHtcbiAgY29uc3QgbXVsdGlwbGljaXR5ID0gcGFyZW50Tm9kZS5nZXRNdWx0aXBsaWNpdHkoKSxcbiAgICAgICAgZGVsZXRlQ291bnQgPSBtdWx0aXBsaWNpdHkgLSAxLFxuICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgIHJlbW92ZWRGcm9udENoaWxkTm9kZXMgPSBwYXJlbnROb2RlLnNwbGljZUNoaWxkTm9kZXMoc3RhcnQsIGRlbGV0ZUNvdW50KTtcblxuICByZXR1cm4gcmVtb3ZlZEZyb250Q2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gZmluZERpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpIHtcbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZE5vZGVzID0gZmluZFJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBEaXJlY3RseVJlcGVhdGVkTm9kZSk7XG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWROb2Rlcztcbn1cblxuZnVuY3Rpb24gZmluZEluZGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSkge1xuICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlcyA9IGZpbmRSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgSW5kaXJlY3RseVJlcGVhdGVkTm9kZSk7XG5cbiAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZXMucmV2ZXJzZSgpO1xuXG4gIHJldHVybiBpbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZURpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpIHtcbiAgbGV0IGRpcmVjdGx5UmVwZWF0ZWROb2Rlc1JlcGxhY2VkID0gZmFsc2U7XG5cbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZE5vZGVzID0gZmluZERpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkTm9kZXNMZW5ndGggPSBkaXJlY3RseVJlcGVhdGVkTm9kZXMubGVuZ3RoO1xuXG4gIGlmIChkaXJlY3RseVJlcGVhdGVkTm9kZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vblRlcm1pbmFsTm9kZSwgLy8vXG4gICAgICAgICAgcmVwbGFjZWRDaGlsZE5vZGVzID0gZGlyZWN0bHlSZXBlYXRlZE5vZGVzLCAvLy9cbiAgICAgICAgICByZXBsYWNlbWVudENoaWxkTm9kZXMgPSBbXTsgLy8vXG5cbiAgICBkaXJlY3RseVJlcGVhdGVkTm9kZXMuZm9yRWFjaCgoZGlyZWN0bHlSZXBlYXRlZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWROb2Rlc0NoaWxkTm9kZXMgPSBkaXJlY3RseVJlcGVhdGVkTm9kZS5yZW1vdmVDaGlsZE5vZGVzKCk7XG5cbiAgICAgIHB1c2gocmVwbGFjZW1lbnRDaGlsZE5vZGVzLCBkaXJlY3RseVJlcGVhdGVkTm9kZXNDaGlsZE5vZGVzKTtcbiAgICB9KTtcblxuICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkTm9kZXMocmVwbGFjZWRDaGlsZE5vZGVzLCByZXBsYWNlbWVudENoaWxkTm9kZXMpO1xuXG4gICAgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWROb2Rlc1JlcGxhY2VkO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RQYXJlbnROb2RlUHJlY2VkZW5jZShwYXJlbnROb2RlLCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgcGFyZW50Tm9kZU5vZGVSdWxlTmFtZSA9IHBhcmVudE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZUZyb21JbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSk7XG5cbiAgaWYgKHBhcmVudE5vZGVOb2RlUnVsZU5hbWUgPT09IHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgcGFyZW50Tm9kZS5zZXRQcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVOb2RlRnJvbVBhcmVudE5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUsIHN0YXRlKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZU9wYWNpdHkgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlLmdldE9wYWNpdHkoKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgcmVtb3ZlZEZyb250Q2hpbGROb2RlcyA9IHJlbW92ZUZyb250Q2hpbGROb2RlcyhwYXJlbnROb2RlKSxcbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lRnJvbUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSxcbiAgICAgICAgcnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIC8vL1xuICAgICAgICBjaGlsZE5vZGVzID0gcmVtb3ZlZEZyb250Q2hpbGROb2RlcywgIC8vL1xuICAgICAgICBvcGFjaXR5ID0gaW5kaXJlY3RseVJlcGVhdGVkTm9kZU9wYWNpdHksICAvLy9cbiAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHN0YXRlLk5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlTm9kZSA9IG5vblRlcm1pbmFsTm9kZTsgIC8vL1xuXG4gIHJldHVybiBsZWZ0UmVjdXJzaXZlTm9kZTtcbn1cblxuZnVuY3Rpb24gY2hpbGROb2Rlc0Zyb21MZWZ0UmVjdXJzaXZlTm9kZU5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKGxlZnRSZWN1cnNpdmVOb2RlLCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlKSB7XG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBbXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZU5vZGVcbiAgICAgICAgXSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZU51bGxhcnkgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlLmlzTnVsbGFyeSgpO1xuXG4gIGlmICghaW5kaXJlY3RseVJlcGVhdGVkTm9kZU51bGxhcnkpIHtcbiAgICBjb25zdCByZW1vdmVkQ2hpbGROb2RlcyA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUucmVtb3ZlQ2hpbGROb2RlcygpO1xuXG4gICAgcHVzaChjaGlsZE5vZGVzLCByZW1vdmVkQ2hpbGROb2Rlcyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGROb2Rlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IHsgaXNOb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wcmVjZWRlbmNlXCI7XG5pbXBvcnQgeyByZXdyaXRlUmVkdWNlZE5vZGVzLCByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzLCByZXdyaXRlSW5kaXJlY3RseVJlcGVhdGVkTm9kZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Jld3JpdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJld3JpdGUoc3RhdGUpIHtcbiAgICBsZXQgbm9uVGVybWluYWxOb2RlO1xuXG4gICAgY29uc3QgcnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgTm9uVGVybWluYWxOb2RlID0gc3RhdGUuTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIGNvbnN0IG9wYWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBub25UZXJtaW5hbE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IHJld3JpdGVJbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUsIHN0YXRlKTtcblxuICAgIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHBhcmVudE5vZGU7IC8vL1xuXG4gICAgICByZXdyaXRlUmVkdWNlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBpc1VucHJlY2VkZW50ZWQoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdGhpcywgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZCA9IGlzTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZChub25UZXJtaW5hbE5vZGUpLFxuICAgICAgICAgIHVucHJlY2VkZW50ZWQgPSBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkOyAvLy9cblxuICAgIHJldHVybiB1bnByZWNlZGVudGVkO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSZXdyaXR0ZW5Ob2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBlcm11dGVSdWxlTmFtZXMocnVsZU5hbWVzLCBydWxlTmFtZSkge1xuICBsZXQgc3RhcnQsXG4gICAgICAgIGVuZDtcblxuICBjb25zdCBpbmRleCA9IHJ1bGVOYW1lcy5pbmRleE9mKHJ1bGVOYW1lKTtcblxuICBzdGFydCA9IDA7XG5cbiAgZW5kID0gaW5kZXg7ICAvLy9cblxuICBjb25zdCBsZWFkaW5nUnVsZU5hbWVzID0gcnVsZU5hbWVzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIHN0YXJ0ID0gaW5kZXg7ICAvLy9cblxuICBjb25zdCB0cmFpbGluZ1J1bGVOYW1lcyA9IHJ1bGVOYW1lcy5zbGljZShzdGFydCksXG4gICAgICAgIHBlcm11dGVkUnVsZU5hbWVzID0gW1xuICAgICAgICAgIC4uLnRyYWlsaW5nUnVsZU5hbWVzLFxuICAgICAgICAgIC4uLmxlYWRpbmdSdWxlTmFtZXNcbiAgICAgICAgXTtcblxuICByZXR1cm4gcGVybXV0ZWRSdWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWVzLCBjYWxsYmFjaykge1xuICBjb25zdCBydWxlTmFtZXNMZW5ndGggPSBydWxlTmFtZXMubGVuZ3RoLFxuICAgICAgICBsYXN0SW5kZXggPSBydWxlTmFtZXNMZW5ndGggLSAxO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBuZXh0SW5kZXggPSAoaW5kZXggPT09IGxhc3RJbmRleCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZXNbbmV4dEluZGV4XTtcblxuICAgIGNhbGxiYWNrKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIGluZGV4KTtcbiAgfSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFBhcnRzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuY29uc3QgeyBSdWxlTmFtZVBhcnQsIFplcm9Pck1vcmVQYXJ0c1BhcnQgfSA9IFBhcnRzO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gIHJldHVybiBydWxlTmFtZVBhcnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvT3JNb3JlUGFydHNQYXJ0RnJvbVBhcnQocGFydCkge1xuICBjb25zdCB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gWmVyb09yTW9yZVBhcnRzUGFydC5mcm9tUGFydChwYXJ0KTtcblxuICByZXR1cm4gemVyb09yTW9yZVBhcnRzUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IHBlcm11dGVSdWxlTmFtZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jeWNsZVwiO1xuaW1wb3J0IHsgcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJ0XCI7XG5pbXBvcnQgeyByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmNvbnN0IHsgbGFzdCwgbWF0Y2gsIGNvbXByZXNzIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGFyZVBhdGhzRXF1YWwocGF0aEEsIHBhdGhCKSB7XG4gIGNvbnN0IHJ1bGVOYW1lc0EgPSBwYXRoQSwgLy8vXG4gICAgICAgIHJ1bGVOYW1lc0IgPSBwYXRoQiwgLy8vXG4gICAgICAgIHJ1bGVOYW1lc01hdGNoID0gbWF0Y2gocnVsZU5hbWVzQSwgcnVsZU5hbWVzQiwgKHJ1bGVOYW1lQSwgcnVsZU5hbWVCKSA9PiB7XG4gICAgICAgICAgaWYgKHJ1bGVOYW1lQSA9PT0gcnVsZU5hbWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwYXRoc0VxdWFsID0gcnVsZU5hbWVzTWF0Y2g7ICAvLy9cblxuICByZXR1cm4gcGF0aHNFcXVhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZlcmVuY2VGcm9tUGF0aHMocGF0aEEsIHBhdGhCLCBydWxlTmFtZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGxldCBkaWZmZXJlbmNlO1xuXG4gIGNvbnN0IHBhdGhBTGVuZ3RoID0gcGF0aEEubGVuZ3RoLFxuICAgICAgICBwYXRoQkxlbmd0aCA9IHBhdGhCLmxlbmd0aDtcblxuICBpZiAoZmFsc2UpIHtcbiAgICAvLy9cbiAgfSBlbHNlIGlmICgocGF0aEFMZW5ndGggPT09IDEpKSB7XG4gICAgZGlmZmVyZW5jZSA9IC0xO1xuICB9IGVsc2UgaWYgKChwYXRoQkxlbmd0aCA9PT0gMSkpIHtcbiAgICBkaWZmZXJlbmNlID0gKzE7XG4gIH0gZWxzZSBpZiAoKHBhdGhBTGVuZ3RoID09PSAwKSAmJiAocGF0aEJMZW5ndGggPT09IDApKSB7XG4gICAgZGlmZmVyZW5jZSA9IDA7XG4gIH0gZWxzZSBpZiAoKHBhdGhBTGVuZ3RoID09PSAwKSkge1xuICAgIGRpZmZlcmVuY2UgPSArMTtcbiAgfSBlbHNlIGlmICgocGF0aEJMZW5ndGggPT09IDApKSB7XG4gICAgZGlmZmVyZW5jZSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJ1bGVOYW1lc0EgPSBwYXRoQS5zbGljZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lc0IgPSBwYXRoQi5zbGljZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lQSA9IHJ1bGVOYW1lc0Euc2hpZnQoKSxcbiAgICAgICAgICBydWxlTmFtZUIgPSBydWxlTmFtZXNCLnNoaWZ0KCk7XG5cbiAgICBpZiAocnVsZU5hbWVBID09PSBydWxlTmFtZUIpIHtcbiAgICAgIHBhdGhBID0gcnVsZU5hbWVzQTsgLy8vXG5cbiAgICAgIHBhdGhCID0gcnVsZU5hbWVzQjsgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVBOyAvLy9cblxuICAgICAgZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VGcm9tUGF0aHMocGF0aEEsIHBhdGhCLCBydWxlTmFtZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgICAgIGluZGV4QSA9IHJ1bGVOYW1lcy5pbmRleE9mKHJ1bGVOYW1lQSksXG4gICAgICAgICAgICBpbmRleEIgPSBydWxlTmFtZXMuaW5kZXhPZihydWxlTmFtZUIpO1xuXG4gICAgICBkaWZmZXJlbmNlID0gKGluZGV4QSAtIGluZGV4Qik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpZmZlcmVuY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VkUnVsZU5hbWVGcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHBhdGgsIC8vL1xuICAgICAgICBsYXN0UnVsZU5hbWUgPSBsYXN0KHJ1bGVOYW1lcyksXG4gICAgICAgIHJ1bGVOYW1lID0gbGFzdFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICByZXR1cm4gcmVkdWNlZFJ1bGVOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aHNGcm9tUnVsZU5hbWVBbmRDeWNsZXMocnVsZU5hbWUsIGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHBhdGhzID0gY3ljbGVzLnJlZHVjZSgocGF0aHMsIGN5Y2xlKSA9PiB7XG4gICAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlKSxcbiAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICBjb25zdCBwZXJtdXRlZFJ1bGVOYW1lcyA9IHBlcm11dGVSdWxlTmFtZXMocnVsZU5hbWVzLCBydWxlTmFtZSksXG4gICAgICAgICAgICBwYXRoID0gcGVybXV0ZWRSdWxlTmFtZXM7IC8vL1xuXG4gICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSwgW10pO1xuXG4gIGxldCBsZW5ndGg7XG5cbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IDEpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKCk7ICAvLy9cblxuICAgICAgcGF0aC5wb3AoKTtcblxuICAgICAgcGF0aHMucHVzaChwYXRoKTtcblxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICBjb21wcmVzcyhwYXRocywgKHBhdGhBLCBwYXRoQikgPT4ge1xuICAgIGNvbnN0IHBhdGhzRXF1YWwgPSBhcmVQYXRoc0VxdWFsKHBhdGhBLCBwYXRoQik7XG5cbiAgICBpZiAoIXBhdGhzRXF1YWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZU5hbWUgPSBudWxsO1xuXG4gIHBhdGhzLnNvcnQoKHBhdGhBLCBwYXRoQikgPT4ge1xuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlRnJvbVBhdGhzKHBhdGhBLCBwYXRoQiwgcnVsZU5hbWUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCk7XG5cbiAgICByZXR1cm4gZGlmZmVyZW5jZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlZFJ1bGVOYW1lUGFydEZyb21QYXRoKHBhdGgpIHtcbiAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVBhdGgocGF0aCksXG4gICAgICAgIHJlZHVjZWRSdWxlTmFtZVBhcnQgPSBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUocmVkdWNlZFJ1bGVOYW1lKTtcblxuICByZXR1cm4gcmVkdWNlZFJ1bGVOYW1lUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRGVmaW5pdGlvbiB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21QYXRoLCByZWR1Y2VkUnVsZU5hbWVQYXJ0RnJvbVBhdGggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhdGhcIjtcbmltcG9ydCB7IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZSwgemVyb09yTW9yZVBhcnRzUGFydEZyb21QYXJ0IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJ0XCI7XG5pbXBvcnQgeyBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUsIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlTmFtZVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVBhdGgocGF0aCwgcnVsZU1hcCkge1xuICAgIGxldCByZXdyaXR0ZW5EZWZpbml0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IHJlZHVjZWRSdWxlTmFtZUZyb21QYXRoKHBhdGgpLFxuICAgICAgICAgIHJlZHVjZWRSdWxlID0gcnVsZU1hcFtyZWR1Y2VkUnVsZU5hbWVdIHx8IG51bGw7XG5cbiAgICBpZiAocmVkdWNlZFJ1bGUgIT09IG51bGwpIHtcbiAgICAgIHJld3JpdHRlbkRlZmluaXRpb24gPSByZXdyaXR0ZW5EZWZpbml0aW9uRnJvbVBhdGgocGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJld3JpdHRlbkRlZmluaXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBhdGgocGF0aCkge1xuICBjb25zdCByZXZlcnNlZFBhdGggPSBwYXRoLnNsaWNlKCk7XG5cbiAgcmV2ZXJzZWRQYXRoLnJldmVyc2UoKTtcblxuICByZXR1cm4gcmV2ZXJzZWRQYXRoO1xufVxuXG5mdW5jdGlvbiByZXdyaXR0ZW5EZWZpbml0aW9uRnJvbVBhdGgocGF0aCkge1xuICBjb25zdCByZWR1Y2VkUnVsZU5hbWVQYXJ0ID0gcmVkdWNlZFJ1bGVOYW1lUGFydEZyb21QYXRoKHBhdGgpLFxuICAgICAgICByZXZlcnNlZFBhdGggPSByZXZlcnNlUGF0aChwYXRoKSxcbiAgICAgICAgcnVsZU5hbWVzID0gcmV2ZXJzZWRQYXRoLCAvLy9cbiAgICAgICAgcnVsZU5hbWVzTGVuZ3RoID0gcnVsZU5hbWVzLmxlbmd0aCxcbiAgICAgICAgbGFzdEluZGV4ID0gcnVsZU5hbWVzTGVuZ3RoIC0gMSxcbiAgICAgICAgcGFydHMgPSBbXTsgLy8vXG5cbiAgcGFydHMucHVzaChyZWR1Y2VkUnVsZU5hbWVQYXJ0KTtcblxuICBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWVzLCAocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgICBwYXJ0cy5wdXNoKGRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcblxuICAgICAgY29uc3QgdGVtcG9yYXJ5UnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWU7IC8vL1xuXG4gICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gdGVtcG9yYXJ5UnVsZU5hbWU7ICAvLy9cblxuICAgICAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUGFydCA9IGluZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgIHBhcnRzLnB1c2goaW5kaXJlY3RseVJlcGVhdGVkUGFydCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAocnVsZU5hbWVzTGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZmlyc3RSdWxlTmFtZSA9IGZpcnN0KHJ1bGVOYW1lcyksXG4gICAgICAgICAgcnVsZU5hbWUgPSBmaXJzdFJ1bGVOYW1lLFxuICAgICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcGFydHMucHVzaChkaXJlY3RseVJlcGVhdGVkUGFydCk7XG4gIH1cblxuICBjb25zdCBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgcmV3cml0dGVuRGVmaW5pdGlvbiA9IG5ldyBSZXdyaXR0ZW5EZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICByZXR1cm4gcmV3cml0dGVuRGVmaW5pdGlvbjtcbn1cblxuZnVuY3Rpb24gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCA9IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZShkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUpLFxuICAgICAgICB6ZXJvT3JNb3JlRGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydHNQYXJ0ID0gemVyb09yTW9yZVBhcnRzUGFydEZyb21QYXJ0KGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnQpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkUGFydCA9IHplcm9Pck1vcmVEaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0c1BhcnQ7IC8vL1xuXG4gIHJldHVybiBkaXJlY3RseVJlcGVhdGVkUGFydDtcbn1cblxuZnVuY3Rpb24gaW5kaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSksXG4gICAgICAgIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCA9IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSksXG4gICAgICAgIGluZGlyZWN0bHlSZXBlYXRlZFBhcnQgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnQ7ICAvLy9cblxuICByZXR1cm4gaW5kaXJlY3RseVJlcGVhdGVkUGFydDtcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSdWxlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IFJld3JpdHRlbk5vZGUgZnJvbSBcIi4uL25vZGUvcmV3cml0dGVuXCI7XG5pbXBvcnQgUmV3cml0dGVuRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvbi9yZXdyaXR0ZW5cIjtcblxuaW1wb3J0IHsgcGF0aHNGcm9tUnVsZU5hbWVBbmRDeWNsZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuUnVsZSBleHRlbmRzIFJ1bGUge1xuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gUmV3cml0dGVuTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApIHtcbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IFtdLFxuICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgcGF0aHMgPSBwYXRoc0Zyb21SdWxlTmFtZUFuZEN5Y2xlcyhydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuXG4gICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgY29uc3QgcmV3cml0dGVuRGVmaW5pdGlvbiA9IFJld3JpdHRlbkRlZmluaXRpb24uZnJvbVBhdGgocGF0aCwgcnVsZU1hcCk7XG5cbiAgICAgIGlmIChyZXdyaXR0ZW5EZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSByZXdyaXR0ZW5EZWZpbml0aW9uOyAvLy9cblxuICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbmFtZSA9IHJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIHJld3JpdHRlblJ1bGUgPSBuZXcgUmV3cml0dGVuUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcmV3cml0dGVuUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBEZWZpbml0aW9uIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IHJ1bGVOYW1lc0Zyb21DeWNsZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvY3ljbGVcIjtcbmltcG9ydCB7IHBlcm11dGVSdWxlTmFtZXMsIGZvckVhY2hSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUsIHplcm9Pck1vcmVQYXJ0c1BhcnRGcm9tUGFydCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcGFydFwiO1xuaW1wb3J0IHsgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lLCBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21SdWxlQW5kQ3ljbGUocnVsZSwgY3ljbGUpIHtcbiAgICBsZXQgZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gPSBudWxsO1xuXG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpLFxuICAgICAgICAgIHJ1bGVOYW1lSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICBpZiAocnVsZU5hbWVJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICBjb25zdCBwZXJtdXRlZFJ1bGVOYW1lcyA9IHBlcm11dGVSdWxlTmFtZXMocnVsZU5hbWVzLCBydWxlTmFtZSksXG4gICAgICAgICAgICBwYXRoID0gcGVybXV0ZWRSdWxlTmFtZXMsIC8vL1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0c0Zyb21QYXRoKHBhdGgpLFxuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGw7XG5cbiAgICAgIGRpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uID0gbmV3IERpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVybXV0ZVBhdGgocGF0aCkge1xuICBjb25zdCBwZXJtdXRlZFBhdGggPSBwYXRoLnNsaWNlKCk7ICAvLy9cblxuICBwZXJtdXRlZFBhdGgucmV2ZXJzZSgpO1xuXG4gIGNvbnN0IHJ1bGVOYW1lID0gcGVybXV0ZWRQYXRoLnBvcCgpO1xuXG4gIHBlcm11dGVkUGF0aC51bnNoaWZ0KHJ1bGVOYW1lKTtcblxuICByZXR1cm4gcGVybXV0ZWRQYXRoO1xufVxuXG5mdW5jdGlvbiBwYXJ0c0Zyb21QYXRoKHBhdGgpIHtcbiAgY29uc3QgcGVybXV0ZWRQYXRoID0gcGVybXV0ZVBhdGgocGF0aCksXG4gICAgICAgIHJ1bGVOYW1lcyA9IHBlcm11dGVkUGF0aCwgLy8vXG4gICAgICAgIHBhcnRzID0gW107XG5cbiAgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lcywgKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCB0ZW1wb3JhcnlSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZTsgLy8vXG5cbiAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICBydWxlTmFtZSA9IHRlbXBvcmFyeVJ1bGVOYW1lOyAgLy8vXG5cbiAgICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gaW5kaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZUFuZExlZnRSZXVjcnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSxcbiAgICAgICAgICBkaXJlY3RseVJlcGVhdGVkUGFydCA9IGRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHBhcnRzLnB1c2goaW5kaXJlY3RseVJlcGVhdGVkUGFydCk7XG5cbiAgICBwYXJ0cy5wdXNoKGRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcbiAgfSk7XG5cbiAgcGFydHMucG9wKCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZShydWxlTmFtZSkge1xuICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSksXG4gICAgICAgIHplcm9Pck1vcmVEaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0c1BhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0RnJvbVBhcnQoZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCksXG4gICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gemVyb09yTW9yZURpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnRzUGFydDsgLy8vXG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0O1xufVxuXG5mdW5jdGlvbiBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lQW5kTGVmdFJldWNyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUGFydCA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydDsgIC8vL1xuXG4gIHJldHVybiBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSdWxlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWROb2RlIGZyb20gXCIuLi8uLi9ub2RlL3JlcGVhdGVkL2RpcmVjdGx5XCI7XG5pbXBvcnQgRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcmVwZWF0ZWQvZGlyZWN0bHlcIlxuXG5pbXBvcnQgeyBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdGx5UmVwZWF0ZWRSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIE5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSwgc3RhdGUpIHtcbiAgICBjb25zdCBOb25UZXJtaW5hbE5vZGUgPSBEaXJlY3RseVJlcGVhdGVkTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgY3ljbGVzLm1hcCgoY3ljbGUpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uID0gRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24uZnJvbVJ1bGVBbmRDeWNsZShydWxlLCBjeWNsZSk7XG5cbiAgICAgIGlmIChkaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb247ICAvLy9cblxuICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICBuYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gcnVsZS5nZXRPcGFjaXR5KCksXG4gICAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBuZXcgRGlyZWN0bHlSZXBlYXRlZFJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWRSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUmV3cml0dGVuUnVsZSBmcm9tIFwiLi9ydWxlL3Jld3JpdHRlblwiO1xuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHlcIjtcblxuaW1wb3J0IHsgaXNSdWxlTm9uQ29uc3VtaW5nIH0gZnJvbSBcIi4vdXRpbGl0aWVzL25vbkNvbnN1bWluZ1wiO1xuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jeWNsZVwiO1xuaW1wb3J0IHsgaXNDeWNsZUlycmVkdWNpYmxlLCBydWxlQ3ljbGVzRnJvbVJ1bGVOYW1lQW5kQ3ljbGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5cbmNvbnN0IHsgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmV3cml0ZUxlZnRSZWN1cnNpdmVSdWxlcyhjeWNsZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGVzKGN5Y2xlcyk7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgbGV0IHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXTtcblxuICAgIGNvbnN0IHJld3JpdHRlblJ1bGUgPSBSZXdyaXR0ZW5SdWxlLmZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcblxuICAgIHJ1bGUgPSByZXdyaXR0ZW5SdWxlOyAvLy9cblxuICAgIHJ1bGVNYXBbcnVsZU5hbWVdID0gcnVsZTtcbiAgfSk7XG5cbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVzID0gcnVsZXNGcm9tUnVsZShEaXJlY3RseVJlcGVhdGVkUnVsZSwgcnVsZU1hcCk7XG5cbiAgZGlyZWN0bHlSZXBlYXRlZFJ1bGVzLmZvckVhY2goKGRpcmVjdGx5UmVwZWF0ZWRSdWxlKSA9PiB7XG4gICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOb25Db25zdW1pbmcgPSBpc1J1bGVOb25Db25zdW1pbmcoZGlyZWN0bHlSZXBlYXRlZFJ1bGUsIHJ1bGVNYXApO1xuXG4gICAgaWYgKGRpcmVjdGx5UmVwZWF0ZWRSdWxlTm9uQ29uc3VtaW5nKSB7XG4gICAgICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZS5nZXROYW1lKCk7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRpcmVjdGx5IHJlcGVhdGVkICcke2RpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZX0nIHJ1bGUgaXMgbm9uLWNvbnN1bWluZy5gKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVDeWNsZXMgPSBydWxlQ3ljbGVzRnJvbVJ1bGVOYW1lQW5kQ3ljbGVzKHJ1bGVOYW1lLCBjeWNsZXMpLFxuICAgICAgICAgIHJ1bGVDeWNsZXNJcnJlZHVjaWJsZSA9IHJ1bGVDeWNsZXMuZXZlcnkoKHJ1bGVDeWNsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVsZUN5Y2xlSXJyZWR1Y2libGUgPSBpc0N5Y2xlSXJyZWR1Y2libGUocnVsZUN5Y2xlLCBydWxlTWFwKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVDeWNsZUlycmVkdWNpYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgaWYgKHJ1bGVDeWNsZXNJcnJlZHVjaWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25lIG9mIHRoZSBjeWNsZXMgaW5jbHVkaW5nIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUgaGF2ZSBhIHJlZHVjZWQgcnVsZS5gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydWxlc0Zyb21SdWxlKFJ1bGUsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZXMgPSBPYmplY3QudmFsdWVzKHJ1bGVNYXApOyAvLy9cblxuICBmaWx0ZXIocnVsZXMsIChydWxlKSA9PiB7XG4gICAgY29uc3QgcnVsZVJ1bGUgPSAocnVsZSBpbnN0YW5jZW9mIFJ1bGUpO1xuXG4gICAgaWYgKHJ1bGVSdWxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBydWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHlcIjtcblxuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jeWNsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZXMoY3ljbGVzKTtcblxuICBydWxlTmFtZXMuZm9yRWFjaCgocnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBEaXJlY3RseVJlcGVhdGVkUnVsZS5mcm9tUnVsZUFuZEN5Y2xlcyhydWxlLCBjeWNsZXMsIHJ1bGVNYXApLFxuICAgICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGRpcmVjdGx5UmVwZWF0ZWRSdWxlLmdldE5hbWUoKTtcblxuICAgIHJ1bGVNYXBbZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lXSA9IGRpcmVjdGx5UmVwZWF0ZWRSdWxlO1xuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUGFydHMsIERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IEVwc2lsb25QYXJ0IH0gPSBQYXJ0cztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXBzaWxvbkRlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21QcmVjZWRlbmNlKHByZWNlZGVuY2UpIHtcbiAgICBjb25zdCBlcHNpbG9uUGFydCA9IEVwc2lsb25QYXJ0LmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBlcHNpbG9uUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXBzaWxvbkRlZmluaXRpb24gPSBFcHNpbG9uRGVmaW5pdGlvbi5mcm9tUGFydHNBbmRQcmVjZWRlbmNlKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBlcHNpbG9uRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVQYXJ0c0VxdWFsKHBhcnRzKSB7XG4gIGNvbnN0IGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgZmlyc3RQYXJ0U3RyaW5nID0gZmlyc3RQYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgIHBhcnRzRXF1YWwgPSBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcnRTdHJpbmcgPSBwYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcGFydFN0cmluZ0ZpcnN0UGFydFN0cmluZyA9IChwYXJ0U3RyaW5nID09PSBmaXJzdFBhcnRTdHJpbmcpO1xuXG4gICAgICAgICAgaWYgKHBhcnRTdHJpbmdGaXJzdFBhcnRTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHBhcnRzRXF1YWw7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNvbnN0IHsgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgICAgICAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gICAgICAgIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gICAgICAgIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bGVOb25Qcm9kdWNpbmcocnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzID0gW10pIHtcbiAgbGV0IHJ1bGVOb25Qcm9kdWNpbmcgPSBmYWxzZTtcblxuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICBpZiAoIXJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICBydWxlTmFtZXMgPSBbIC8vL1xuICAgICAgLi4ucnVsZU5hbWVzLFxuICAgICAgcnVsZU5hbWVcbiAgICBdO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCksXG4gICAgICAgICAgZGVmaW5pdGlvbnNOb25Qcm9kdWNpbmcgPSBhcmVEZWZpbml0aW9uc05vblByb2R1Y2luZyhkZWZpbml0aW9ucywgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIHJ1bGVOb25Qcm9kdWNpbmcgPSBkZWZpbml0aW9uc05vblByb2R1Y2luZzsgLy8vXG4gIH1cblxuICByZXR1cm4gcnVsZU5vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gYXJlRGVmaW5pdGlvbnNOb25Qcm9kdWNpbmcoZGVmaW5pdGlvbnMsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBkZWZpbml0aW9uc05vblByb2R1Y2luZyA9IGRlZmluaXRpb25zLmV2ZXJ5KChkZWZpbml0aW9uKSA9PiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk5vblByb2R1Y2luZyA9IGlzRGVmaW5pdGlvbk5vblByb2R1Y2luZyhkZWZpbml0aW9uLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgaWYgKGRlZmluaXRpb25Ob25Qcm9kdWNpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlZmluaXRpb25zTm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluaXRpb25Ob25Qcm9kdWNpbmcoZGVmaW5pdGlvbiwgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBwYXJ0c05vblByb2R1Y2luZyA9IGFyZVBhcnRzTm9uUHJvZHVjaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpLFxuICAgICAgICBkZWZpbml0aW9uTm9uUHJvZHVjaW5nID0gcGFydHNOb25Qcm9kdWNpbmc7XG5cbiAgcmV0dXJuIGRlZmluaXRpb25Ob25Qcm9kdWNpbmc7XG59XG5cbmZ1bmN0aW9uIGFyZVBhcnRzTm9uUHJvZHVjaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHNOb25Qcm9kdWNpbmcgPSBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgIGNvbnN0IHBhcnROb25Qcm9kdWNpbmcgPSBpc1BhcnROb25Qcm9kdWNpbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIGlmIChwYXJ0Tm9uUHJvZHVjaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJ0c05vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gaXNQYXJ0Tm9uUHJvZHVjaW5nKHBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBsZXQgcGFydE5vblByb2R1Y2luZztcblxuICBjb25zdCBwYXJUZXJtaW5hbFBhcnQgPSBwYXJ0LmlzVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhclRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbFBhcnRVc2VsZXNzID0gaXNUZXJtaW5hbFBhcnROb25Qcm9kdWNpbmcodGVybWluYWxQYXJ0KTtcblxuICAgIHBhcnROb25Qcm9kdWNpbmcgPSB0ZXJtaW5hbFBhcnRVc2VsZXNzOyAvLy9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5QYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgIG5vblRlcm1pbmFsUGFydE5vblByb2R1Y2luZyA9IGlzTm9uVGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nKG5vblRlcm1pbmFsTlBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gbm9uVGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nOyAvLy9cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBpc1Rlcm1pbmFsUGFydE5vblByb2R1Y2luZyh0ZXJtaW5hbFBhcnQpIHtcbiAgY29uc3QgdGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRlcm1pbmFsUGFydE5vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gaXNOb25UZXJtaW5hbFBhcnROb25Qcm9kdWNpbmcobm9uVGVybWluYWxQYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgbGV0IHBhcnROb25Qcm9kdWNpbmcgPSBmYWxzZTtcblxuICBjb25zdCB0eXBlID0gbm9uVGVybWluYWxQYXJ0LmdldFR5cGUoKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSB8fCBudWxsO1xuXG4gICAgICBpZiAocnVsZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBydWxlTm9uUHJvZHVjaW5nID0gaXNSdWxlTm9uUHJvZHVjaW5nKHJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgICAgcGFydE5vblByb2R1Y2luZyA9IHJ1bGVOb25Qcm9kdWNpbmc7ICAvLy9cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgcGFydE5vblByb2R1Y2luZyA9IHRydWU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3Qgb25lT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgcGFydE5vblByb2R1Y2luZyA9IGlzUGFydE5vblByb2R1Y2luZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gdHJ1ZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IHNlcXVlbmNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKSxcbiAgICAgICAgICAgIHBhcnRzTm9uUHJvZHVjaW5nID0gYXJlUGFydHNOb25Qcm9kdWNpbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgIHBhcnROb25Qcm9kdWNpbmcgPSBwYXJ0c05vblByb2R1Y2luZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBjb25zdCBjaG9pY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IGNob2ljZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c05vblByb2R1Y2luZyA9IHBhcnRzLmV2ZXJ5KChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnROb25Qcm9kdWNpbmcgPSBpc1BhcnROb25Qcm9kdWNpbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgICAgICAgICByZXR1cm4gcGFydE5vblByb2R1Y2luZztcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIHBhcnROb25Qcm9kdWNpbmcgPSBwYXJ0c05vblByb2R1Y2luZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uUHJvZHVjaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJ0VHlwZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkNvbXBsZXgoZGVmaW5pdGlvbikge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBmaXJzdFBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChmaXJzdFBhcnQpLFxuICAgICAgICBkZWZpbml0aW9uQ29tcGxleCA9IGZpcnN0UGFydENvbXBsZXg7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uQ29tcGxleDtcbn1cblxuZnVuY3Rpb24gaXNQYXJ0Q29tcGxleChwYXJ0KSB7XG4gIGxldCBwYXJ0Q29tcGxleCA9IHRydWU7XG5cbiAgY29uc3QgcGFydE5vblRlcm1pbmFsUGFydCA9IHBhcnQuaXNOb25UZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgIHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgICAgcGFydENvbXBsZXggPSBmYWxzZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgIHBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChwYXJ0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICBwYXJ0Q29tcGxleCA9IGlzUGFydENvbXBsZXgocGFydCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgWmVyb09yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTsgIC8vL1xuXG4gICAgICAgIHBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChwYXJ0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZTpcbiAgICAgIGNhc2UgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIHBhcnRDb21wbGV4ID0gdHJ1ZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydENvbXBsZXg7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHtpc1BhcnROb25Db25zdW1pbmd9IGZyb20gXCIuL25vbkNvbnN1bWluZ1wiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbk9jY2x1ZGVkKGRlZmluaXRpb24sIHJ1bGVNYXAsIHJ1bGVOYW1lcyA9IFtdKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIGZpcnN0UGFydE5vbkNvbnN1bWluZyA9IGlzUGFydE5vbkNvbnN1bWluZyhmaXJzdFBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyksXG4gICAgICAgIGRlZmluaXRpb25PY2NsdWRlZCA9IGZpcnN0UGFydE5vbkNvbnN1bWluZzsgIC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uT2NjbHVkZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkNhbGxBaGVhZChkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIGZpcnN0UGFydENhbGxBaGVhZCA9IGlzUGFydENhbGxBaGVhZChmaXJzdFBhcnQpLFxuICAgICAgICBkZWZpbml0aW9uQ2FsbEFoZWFkID0gZmlyc3RQYXJ0Q2FsbEFoZWFkOyAvLy9cblxuICByZXR1cm4gZGVmaW5pdGlvbkNhbGxBaGVhZDtcbn1cblxuZnVuY3Rpb24gaXNQYXJ0Q2FsbEFoZWFkKHBhcnQpIHtcbiAgbGV0IHBhcnRDYWxsQWhlYWQgPSBmYWxzZTtcblxuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LmlzUnVsZU5hbWVQYXJ0KCk7XG5cbiAgICBpZiAobm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0KSB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgY2FsbEFoZWFkID0gcnVsZU5hbWVQYXJ0LmlzQ2FsbEFoZWFkKCk7XG5cbiAgICAgIHBhcnRDYWxsQWhlYWQgPSBjYWxsQWhlYWQ7ICAvLy9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydENhbGxBaGVhZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFydFR5cGVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IE9wdGlvbmFsUGFydFBhcnRUeXBlLCBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLCBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSB9ID0gcGFydFR5cGVzO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFydFF1YWxpZmllZChwYXJ0KSB7XG4gIGxldCBwYXJ0UXVhbGlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgcGFydE5vblRlcm1pbmFsUGFydCA9IHBhcnQuaXNOb25UZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgIHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIE9wdGlvbmFsUGFydFBhcnRUeXBlOlxuICAgICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOlxuICAgICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBwYXJ0UXVhbGlmaWVkID0gdHJ1ZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydFF1YWxpZmllZDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uUXVhbGlmaWVkKGRlZmluaXRpb24pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgZmlyc3RQYXJ0UXVhbGlmaWVkID0gaXNQYXJ0UXVhbGlmaWVkKGZpcnN0UGFydCksXG4gICAgICAgIGRlZmluaXRpb25RdWFsaWZpZWQgPSBmaXJzdFBhcnRRdWFsaWZpZWQ7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uUXVhbGlmaWVkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IFJ1bGUsIERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgRXBzaWxvbkRlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZXBzaWxvblwiO1xuaW1wb3J0IEluZGlyZWN0bHlSZXBlYXRlZE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvcmVwZWF0ZWQvaW5kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBhcmVQYXJ0c0VxdWFsIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wYXJ0c1wiO1xuaW1wb3J0IHsgaXNSdWxlTm9uUHJvZHVjaW5nIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub25Qcm9kdWNpbmdcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvbkNvbXBsZXggfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2NvbXBsZXhcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvbk9jY2x1ZGVkIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9vY2NsdWRlZFwiO1xuaW1wb3J0IHsgaXNEZWZpbml0aW9uQ2FsbEFoZWFkIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9jYWxsQWhlYWRcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvblF1YWxpZmllZCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcXVhbGlmaWVkXCI7XG5pbXBvcnQgeyBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbiB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaXJlY3RseVJlcGVhdGVkUnVsZSBleHRlbmRzIFJ1bGUge1xuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gSW5kaXJlY3RseVJlcGVhdGVkTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRMZWZ0UmVjdXJzaXZlUnVsZShydWxlLCBsZWZ0UmVjdXJzaXZlUnVsZSwgcnVsZU1hcCkge1xuICAgIGxldCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlLmdldE5hbWUoKTtcblxuICAgIGxldCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucy5maWx0ZXIoKGRlZmluaXRpb24pID0+IHsgIC8vL1xuICAgICAgY29uc3QgZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUgPSBpc0RlZmluaXRpb25MZWZ0UmVjdXJzaXZlKGRlZmluaXRpb24sIHJ1bGVNYXApO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUpIHtcbiAgICAgICAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCBydWxlTWFwKSxcbiAgICAgICAgICAgICAgZmlyc3RMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBmaXJzdChsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBpZiAoZmlyc3RMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPT09IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25Db21wbGV4ID0gaXNEZWZpbml0aW9uQ29tcGxleChkZWZpbml0aW9uKTtcblxuICAgICAgICAgIGlmIChkZWZpbml0aW9uQ29tcGxleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGxlZnQgcmVjdXJzaXZlLWRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyBjb21wbGV4LmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25PY2NsdWRlZCA9IGlzRGVmaW5pdGlvbk9jY2x1ZGVkKGRlZmluaXRpb24sIHJ1bGVNYXApO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25PY2NsdWRlZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyBvY2NsdWRlZC5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkZWZpbml0aW9uQ2FsbEFoZWFkID0gaXNEZWZpbml0aW9uQ2FsbEFoZWFkKGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25DYWxsQWhlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpcnN0IHBhcnQgb2YgdGhlICcke2RlZmluaXRpb25TdHJpbmd9JyBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIG9mIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUgaXMgbG9vay1haGVhZC5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkZWZpbml0aW9uUXVhbGlmaWVkID0gaXNEZWZpbml0aW9uUXVhbGlmaWVkKGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25RdWFsaWZpZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpcnN0IHBhcnQgb2YgdGhlICcke2RlZmluaXRpb25TdHJpbmd9JyBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIG9mIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUgaXMgcXVhbGlmaWVkLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaXJzdFBhcnRzRXF1YWwgPSBhcmVGaXJzdFBhcnRzRXF1YWwobGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zKTtcblxuICAgIGlmICghZmlyc3RQYXJ0c0VxdWFsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaXJzdCBwYXJ0cyBvZiB0aGUgJyR7bGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lfScgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnMgaW4gdGhlICcke3J1bGVOYW1lfScgcnVsZSBhcmUgbm90IGVxdWFsLmApO1xuICAgIH1cblxuICAgIGxldCBwcmVjZWRlbmNlID0gbnVsbDtcblxuICAgIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucy5maWx0ZXIoKGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICAgICAgaWYgKHBhcnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHByZWNlZGVuY2UgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRQcmVjZWRlbmNlKCk7XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlT3BhY2l0eSA9IGxlZnRSZWN1cnNpdmVSdWxlLmdldE9wYWNpdHkoKSxcbiAgICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICAgIG5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBsZWZ0UmVjdXJzaXZlUnVsZU9wYWNpdHk7IC8vL1xuXG4gICAgZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9uc0Zyb21MZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMobGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zKTtcblxuICAgIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBuZXcgSW5kaXJlY3RseVJlcGVhdGVkUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyksXG4gICAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5vblByb2R1Y2luZyA9IGlzUnVsZU5vblByb2R1Y2luZyhpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlLCBydWxlTWFwKTtcblxuICAgIGlmIChpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTm9uUHJvZHVjaW5nKSB7XG4gICAgICBjb25zdCBlcHNpbG9uRGVmaW5pdGlvbiA9IEVwc2lsb25EZWZpbml0aW9uLmZyb21QcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuXG4gICAgICBkZWZpbml0aW9ucy5wdXNoKGVwc2lsb25EZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaXJlY3RseVJlcGVhdGVkUnVsZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmVGaXJzdFBhcnRzRXF1YWwoZGVmaW5pdGlvbnMpIHtcbiAgY29uc3QgZmlyc3RQYXJ0cyA9IGRlZmluaXRpb25zLm1hcCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICAgICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKTtcblxuICAgICAgICAgIHJldHVybiBmaXJzdFBhcnQ7XG4gICAgICAgIH0pLFxuICAgICAgICBmaXJzdFBhcnRzRXF1YWwgPSBhcmVQYXJ0c0VxdWFsKGZpcnN0UGFydHMpO1xuXG4gIHJldHVybiBmaXJzdFBhcnRzRXF1YWw7XG59XG5cbmZ1bmN0aW9uIGRlZmluaXRpb25zRnJvbUxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucyhsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMpIHtcbiAgY29uc3QgZGVmaW5pdGlvbnMgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMubWFwKChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbikgPT4geyAvLy9cbiAgICAgICAgICBsZXQgcGFydHMgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gICAgICAgICAgcGFydHMgPSBbIC8vL1xuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgICBdXG5cbiAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gRGVmaW5pdGlvbi5mcm9tUGFydHNBbmRQcmVjZWRlbmNlKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvbnM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVwZWF0ZWQvaW5kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvY3ljbGVcIjtcbmltcG9ydCB7IGZvckVhY2hSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVzKGN5Y2xlcywgcnVsZU1hcCkge1xuICBjeWNsZXMuZm9yRWFjaCgoY3ljbGUpID0+IHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpO1xuXG4gICAgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lcywgKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgIGxldCBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlID0gcnVsZU1hcFtpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZV0gfHwgbnVsbDtcblxuICAgICAgaWYgKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZSA9IHJ1bGVNYXBbbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lXTtcblxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlID0gSW5kaXJlY3RseVJlcGVhdGVkUnVsZS5mcm9tUnVsZUFuZExlZnRSZWN1cnNpdmVSdWxlKHJ1bGUsIGxlZnRSZWN1cnNpdmVSdWxlLCBydWxlTWFwKTtcblxuICAgICAgICBydWxlTWFwW2luZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lXSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IHJ1bGVzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IERpcmVjdGVkR3JhcGggZnJvbSBcIi4vZGlyZWN0ZWRHcmFwaFwiO1xuaW1wb3J0IGNyZWF0ZVJlZHVjZWRSdWxlcyBmcm9tIFwiLi9jcmVhdGVSZWR1Y2VkUnVsZXNcIjtcbmltcG9ydCByZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzIGZyb20gXCIuL3Jld3JpdGVMZWZ0UmVjdXJzaXZlUnVsZXNcIjtcbmltcG9ydCBjcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXMgZnJvbSBcIi4vY3JlYXRlRGlyZWN0bHlSZXBlYXRlZFJ1bGVzXCI7XG5pbXBvcnQgY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXMgZnJvbSBcIi4vY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXNcIjtcblxuaW1wb3J0IHsgZWRnZXNGcm9tU3RhcnRSdWxlIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2RpcmVjdGVkR3JhcGhcIjtcbmltcG9ydCB7IExFRlRfUkVDVVJTSVZFX0xBQkVMIH0gZnJvbSBcIi4vbGFiZWxzXCI7XG5pbXBvcnQgeyBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVJ1bGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZVwiO1xuXG5jb25zdCB7IGZpbHRlciB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHJ1bGVNYXBGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlcywgcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcCB9ID0gcnVsZXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpIHtcbiAgY29uc3QgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBzdGFydFJ1bGUgPSBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBydWxlTmFtZXNNYXAgPSBydWxlTmFtZXNNYXBGcm9tTm90aGluZyhydWxlTWFwKSxcbiAgICAgICAgY3ljbGVzID0gY3ljbGVzRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCk7XG5cbiAgY3JlYXRlUmVkdWNlZFJ1bGVzKGN5Y2xlcywgcnVsZU1hcCk7XG5cbiAgY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKTtcblxuICBjcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKTtcblxuICByZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzKGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcblxuICBydWxlcyA9IHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAoc3RhcnRSdWxlLCBydWxlTWFwKTsgLy8vXG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RlZEdyYXBoRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICBjb25zdCBzdGFydFJ1bGVOYW1lID0gc3RhcnRSdWxlLmdldE5hbWUoKSxcbiAgICAgICAgZWRnZXMgPSBlZGdlc0Zyb21TdGFydFJ1bGUoc3RhcnRSdWxlLCBydWxlTWFwLCBydWxlTmFtZXNNYXApLFxuICAgICAgICBzdGFydFZlcnRleCA9IHN0YXJ0UnVsZU5hbWUsICAvLy9cbiAgICAgICAgZGlyZWN0ZWRHcmFwaCA9IERpcmVjdGVkR3JhcGguZnJvbUVkZ2VzQW5kU3RhcnRWZXJ0ZXgoZWRnZXMsIHN0YXJ0VmVydGV4KTtcblxuICByZXR1cm4gZGlyZWN0ZWRHcmFwaDtcbn1cblxuZnVuY3Rpb24gcnVsZU5hbWVzTWFwRnJvbU5vdGhpbmcocnVsZU1hcCkge1xuICBjb25zdCBydWxlTmFtZXNNYXAgPSB7fSxcbiAgICAgICAgcnVsZU5hbWVzID0gT2JqZWN0LmtleXMocnVsZU1hcCk7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVJ1bGUocnVsZSwgcnVsZU1hcCksXG4gICAgICAgICAgcnVsZU5hbWVzID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lczsgLy8vXG5cbiAgICBydWxlTmFtZXNNYXBbcnVsZU5hbWVdID0gcnVsZU5hbWVzO1xuICB9KTtcblxuICByZXR1cm4gcnVsZU5hbWVzTWFwO1xufVxuXG5mdW5jdGlvbiBpc0N5Y2xlTGVmdFJlY3Vyc2l2ZShjeWNsZSkge1xuICBjb25zdCBjeWNsZUxlZnRSZWN1cnNpdmUgPSBjeWNsZS5ldmVyeUVkZ2UoKGVkZ2UpID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IGVkZ2UuZ2V0TGFiZWwoKSxcbiAgICAgICAgICBsYWJlbExlZnRSZWN1cnNpdmVMYWJlbCA9IChsYWJlbCA9PT0gTEVGVF9SRUNVUlNJVkVfTEFCRUwpLFxuICAgICAgICAgIGVkZ2VMZWZ0UmVjdXJzaXZlID0gbGFiZWxMZWZ0UmVjdXJzaXZlTGFiZWw7ICAvLy9cblxuICAgIGlmIChlZGdlTGVmdFJlY3Vyc2l2ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY3ljbGVMZWZ0UmVjdXJzaXZlO1xufVxuXG5mdW5jdGlvbiBjeWNsZXNGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IGRpcmVjdGVkR3JhcGggPSBkaXJlY3RlZEdyYXBoRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCksXG4gICAgICAgIGN5Y2xlcyA9IGRpcmVjdGVkR3JhcGguZmluZEN5Y2xlcygpO1xuXG4gIGZpbHRlcihjeWNsZXMsIChjeWNsZSkgPT4ge1xuICAgIGNvbnN0IGN5Y2xlTGVmdFJlY3Vyc2l2ZSA9IGlzQ3ljbGVMZWZ0UmVjdXJzaXZlKGN5Y2xlKTtcblxuICAgIGlmIChjeWNsZUxlZnRSZWN1cnNpdmUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGN5Y2xlcztcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4YW1wbGVMZXhlciB9IGZyb20gXCIuL2V4YW1wbGUvbGV4ZXIvZXhhbXBsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeGFtcGxlUGFyc2VyIH0gZnJvbSBcIi4vZXhhbXBsZS9wYXJzZXIvZXhhbXBsZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24gfSBmcm9tIFwiLi9lbGltaW5hdGVMZWZ0UmVjdXJzaW9uXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlUXVlcnkoZXhwcmVzc2lvblN0cmluZykge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgbm9kZSA9IG5vZGVzLnNoaWZ0KCkgfHwgbnVsbDsgLy8vXG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnkoZXhwcmVzc2lvblN0cmluZykge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgZW50cmllcyA9IFtcclxuICB7XHJcbiAgICBcInNwZWNpYWxcIjogXCJeKD86XFxcXCRcXFxcJHxcXFxcJHxcXFxcXFxcXFxcXFwofFxcXFxcXFxcXFxcXCl8XFxcXFxcXFxcXFxcW3xcXFxcXFxcXFxcXFxdKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeKD86Lis/KD89XFxcXCRcXFxcJHxcXFxcJHxcXFxcXFxcXFxcXFwofFxcXFxcXFxcXFxcXCl8XFxcXFxcXFxcXFxcW3xcXFxcXFxcXFxcXFxdKXwuKylcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcblxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb21tb25MZXhlciwgV2hpdGVzcGFjZVRva2VuLCBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVYTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuO1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhUZVhMZXhlcik7IH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKFRlWExleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKFRlWExleGVyLCBlbnRyaWVzKTsgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/Oix8OnxcXFxce3xcXFxcfXxcXFxcW3xcXFxcXSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJudW1iZXJcIjogXCJeLT9bMS05XVswLTldKihcXFxcLlswLTldKyk/XCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYm9vbGVhblwiOiBcIl4oPzp0cnVlfGZhbHNlKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bGxcIjogXCJeKD86bnVsbClcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsXHJcbiAgICAgICAgIFdoaXRlc3BhY2VUb2tlbixcclxuICAgICAgICAgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbixcclxuICAgICAgICAgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNPTkxleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoSlNPTkxleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoSlNPTkxleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEpTT05MZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBMQVRJTiA9IFwiW1xcXFxwe1NjcmlwdD1MYXRpbn1dXCIsXHJcbiAgICAgIERFQ0lNQUwgPSBcIlswLTldXCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwidHlwZVwiOiBcIl4oPzpOb2Rlc3xOb2RlfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbilcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJxdWVyeVwiOiBcIl4oPzpub2RlUXVlcnl8bm9kZXNRdWVyeSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJwcmltYXJ5LWtleXdvcmRcIjogXCJecmV0dXJuXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwic2Vjb25kYXJ5LWtleXdvcmRcIjogXCJeKD86aWZ8ZWxzZXxyZWR1Y2V8ZXZlcnl8c29tZXxhcylcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJudWxsXCI6IFwiXm51bGxcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJib29sZWFuXCI6IFwiXig/OnRydWV8ZmFsc2UpXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYnJhY2tldFwiOiBcIl4oPzpcXFxce3xcXFxcfSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OiE9fD09fCF8PXwsfDt8X3wmJnxcXFxcfFxcXFx8fFxcXFwofFxcXFwpfFxcXFxbfFxcXFxdKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogYF4ke0xBVElOfSske0RFQ0lNQUx9KmAsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBgXiR7REVDSU1BTH0rYFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsXHJcbiAgICAgICAgIFdoaXRlc3BhY2VUb2tlbixcclxuICAgICAgICAgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbixcclxuICAgICAgICAgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLFxyXG4gICAgICAgICBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXJ0bGVMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbjtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoRnVydGxlTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhGdXJ0bGVMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhGdXJ0bGVMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBHUkVFSyA9IFwiW1xcXFxwe1NjcmlwdD1HcmVla31dXCIsXHJcbiAgICAgIExBVElOID0gXCJbXFxcXHB7U2NyaXB0PUxhdGlufV1cIixcclxuICAgICAgREVDSU1BTCA9IFwiWzAtOV1cIixcclxuICAgICAgTEFUSU5fTE9XRVJfQ0FTRSA9IFwiW1xcXFxwe1NjcmlwdD1MYXRpbn0mJlxcXFxwe0xvd2VyY2FzZX1dXCIsXHJcbiAgICAgIExBVElOX1VQUEVSX0NBU0UgPSBcIltcXFxccHtTY3JpcHQ9TGF0aW59JiZcXFxccHtVcHBlcmNhc2V9XVwiLFxyXG4gICAgICBNQVRIRU1BVElDQUxfU0FOU19TRVJJRl9CT0xEID0gXCJbXFxcXHV7MUQ1RDR9LVxcXFx1ezFENjA3fV1cIixcclxuICAgICAgTUFUSEVNQVRJQ0FMX0lUQUxJQ19VUFBFUl9DQVNFID0gXCJbXFxcXHV7MUQ0MzR9LVxcXFx1ezFENDREfV1cIixcclxuICAgICAgTUFUSEVNQVRJQ0FMX1NDUklQVF9VUFBFUl9DQVNFID0gXCJbXFxcXHV7MUQ0OUN9XFxcXHV7MjEyQ31cXFxcdXsxRDQ5RX1cXFxcdXsxRDQ5Rn1cXFxcdXsyMTMwfVxcXFx1ezIxMzF9XFxcXHV7MUQ0QTJ9XFxcXHV7MjEwQn1cXFxcdXsyMTEwfVxcXFx1ezFENEE1fVxcXFx1ezFENEE2fVxcXFx1ezIxMTJ9XFxcXHV7MjEzM31cXFxcdXsxRDRBOX0tXFxcXHV7MUQ0QUN9XFxcXHV7MjExQn1cXFxcdXsxRDRBRX0tXFxcXHV7MUQ0QjV9XVwiLFxyXG4gICAgICBNQVRIRU1BVElDQUxfRlJBS1RVUl9VUFBFUl9DQVNFID0gXCJbXFxcXHV7MUQ1MDR9XFxcXHV7MUQ1MDV9XFxcXHV7MjEyRH1cXFxcdXsxRDUwN30tXFxcXHV7MUQ1MEF9XFxcXHV7MjEwQ31cXFxcdXsyMTExfVxcXFx1ezFENTBEfS1cXFxcdXsxRDUxNH1cXFxcdXsyMTFDfVxcXFx1ezFENTE2fS1cXFxcdXsxRDUxQ31cXFxcdXsyMTI4fV1cIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJwcmltYXJ5LWtleXdvcmRcIjogXCJeKD86UnVsZXxBeGlvbXxUaGVvcmVtfExlbW1hfENvbmplY3R1cmV8TWV0YUxlbW1hfE1ldGF0aGVvcmVtfFByZW1pc2VzfFByZW1pc2V8Q29uY2x1c2lvbnxQcm9vZnxUaGVyZWZvcmV8U3VwcG9zZXxIZW5jZXxUaGVufFByb3Zpc2lvbmFsfFR5cGV8VHlwZVByZWZpeHxQcm9wZXJ0aWVzfFByb3BlcnR5fFZhcmlhYmxlfENvbnN0cnVjdG9yfENvbWJpbmF0b3J8TWV0YXZhcmlhYmxlfEdpdmVuKVxcXFxiXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwic2Vjb25kYXJ5LWtleXdvcmRcIjogXCJeKD86aXN8aW58YW58YXxvZnxieXxmcm9tfGJlY2F1c2V8Zm9yfHNhdGlzZmllc3xwcm92aXNpb25hbGx5fGRlZmluZWR8dW5kZWZpbmVkfG1pc3Npbmd8cHJlc2VudClcXFxcYlwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm1ldGEtdHlwZVwiOiBcIl4oPzpTdGF0ZW1lbnR8UmVmZXJlbmNlfEZyYW1lKVxcXFxiXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBgXig/OiR7TEFUSU5fVVBQRVJfQ0FTRX0ke0xBVElOfSoke0RFQ0lNQUx9Knwke0xBVElOX0xPV0VSX0NBU0V9JHtMQVRJTn0rJHtERUNJTUFMfSopYCxcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRlbnRpZmllclwiOiBgXig/OiR7TEFUSU5fTE9XRVJfQ0FTRX0ke0RFQ0lNQUx9Knwke0dSRUVLfSt8JHtNQVRIRU1BVElDQUxfU0FOU19TRVJJRl9CT0xEfSt8JHtNQVRIRU1BVElDQUxfSVRBTElDX1VQUEVSX0NBU0V9K3wke01BVEhFTUFUSUNBTF9TQ1JJUFRfVVBQRVJfQ0FTRX0rfCR7TUFUSEVNQVRJQ0FMX0ZSQUtUVVJfVVBQRVJfQ0FTRX0rKWBcclxuICB9LFxyXG4gIHtcclxuICAgIFwicHJpbWl0aXZlXCI6IFwiXig/OlxcXFx8fFxcXFwuXFxcXC5cXFxcLnxcXFxcKHxcXFxcKXxcXFxcW3xcXFxcXXxcXFxcK3wtfCx8PHw+KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInNwZWNpYWxcIjogXCJeKD86QHw6Onw6fD0pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXFxcXChcXFxcKVxcXFxbXFxcXF06LF0rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb21tb25MZXhlcixcclxuICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxyXG4gICAgICAgICBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sXHJcbiAgICAgICAgIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcclxuXHJcbmltcG9ydCBlbnRyaWVzIGZyb20gXCIuL2VudHJpZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbWluYWxMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbjtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwiYWxwaGEtbnVtZXJpY1wiOiBcIl5bYS16QS1aMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJwdW5jdHVhdGlvblwiOiBcIl5bQCxcXFxcLlxcXCInYF0rXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXStcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFpblRleHRMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW47ICAvLy5cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoUGxhaW5UZXh0TGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhQbGFpblRleHRMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhQbGFpblRleHRMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwic3BlY2lhbFwiOiBcIl4oPzpcXFxcfHxcXFxcKHxcXFxcKXxcXFxcP3xcXFxcKnxcXFxcK3w6Oj18O3w8Tk9fV0hJVEVTUEFDRT58PEVORF9PRl9MSU5FPilcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJudW1iZXJcIjogXCJeKD86MHxbMS05XVswLTldKilcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiXltcXFxcd35dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInR5cGVcIjogXCJeXFxcXFtbXlxcXFxdXStcXFxcXVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc10rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21HcmFtbWFyQk5GbkxleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XG5cbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcblxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhDdXN0b21HcmFtbWFyQk5GbkxleGVyKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhDdXN0b21HcmFtbWFyQk5GbkxleGVyLCBydWxlcyk7IH1cblxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoQ3VzdG9tR3JhbW1hckJORm5MZXhlciwgZW50cmllcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25MZXhlciwgV2hpdGVzcGFjZVRva2VuLCBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcblxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuO1xuXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XG5cbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIsIHJ1bGVzKTsgfVxuXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLCBlbnRyaWVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgICggZGVsaW1pdGVkVGVYIHwgcGxhaW5NYXJrdXAgKSsgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIGRlbGltaXRlZFRlWCAgICAgICAgICAgICAgICAgICAgOjo9ICAgZG9sbGFyRGVsaW1pdGVyIGlubGluZVRlWCBkb2xsYXJEZWxpbWl0ZXIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBkb3VibGVEb2xsYXJEZWxpbWl0ZXIgZGlzcGxheVRlWCBkb3VibGVEb2xsYXJEZWxpbWl0ZXIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBvcGVuaW5nQnJhY2tldERlbGltaXRlciBpbmxpbmVUZVggY2xvc2luZ0JyYWNrZXREZWxpbWl0ZXIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBvcGVuaW5nU3F1YXJlQnJhY2tldERlbGltaXRlciBkaXNwbGF5VGVYIGNsb3NpbmdTcXVhcmVCcmFja2V0RGVsaW1pdGVyIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgIFxuXG4gICAgXG4gICAgaW5saW5lVGVYICAgICAgICAgICAgICAgICAgICAgICA6Oj0gICBbdW5hc3NpZ25lZF0qIDtcblxuICAgIGRpc3BsYXlUZVggICAgICAgICAgICAgICAgICAgICAgOjo9ICAgW3VuYXNzaWduZWRdKiA7XG5cblxuXG4gICAgZG9sbGFyRGVsaW1pdGVyICAgICAgICAgICAgICAgICA6Oj0gICBcIiRcIiA7XG4gXG4gICAgZG91YmxlRG9sbGFyRGVsaW1pdGVyICAgICAgICAgICA6Oj0gICBcIiQkXCIgO1xuICAgIFxuXG4gICAgXG4gICAgb3BlbmluZ0JyYWNrZXREZWxpbWl0ZXIgICAgICAgICA6Oj0gICBcIlxcXFwoXCIgO1xuXG4gICAgY2xvc2luZ0JyYWNrZXREZWxpbWl0ZXIgICAgICAgICA6Oj0gICBcIlxcXFwpXCIgO1xuXG4gICAgb3BlbmluZ1NxdWFyZUJyYWNrZXREZWxpbWl0ZXIgICA6Oj0gICBcIlxcXFxbXCIgO1xuICAgIFxuICAgIGNsb3NpbmdTcXVhcmVCcmFja2V0RGVsaW1pdGVyICAgOjo9ICAgXCJcXFxcXVwiIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICBwbGFpbk1hcmt1cCAgICAgICAgICAgICAgICAgICAgIDo6PSAgIC4gO1xuXG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVYUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoVGVYUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoVGVYUGFyc2VyLCBibmYpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21SdWxlcyhUZVhQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgOjo9ICBqc29uIGVycm9yKiBcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBlcnJvcisgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gIFxuICBcbiAgXG4gICAganNvbiAgICAgICAgIDo6PSAgYXJyYXkgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgb2JqZWN0IFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFtzdHJpbmctbGl0ZXJhbF0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgW2Jvb2xlYW5dIFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFtudW1iZXJdIFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFtudWxsXSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gIFxuICBcbiAgXG4gICAgYXJyYXkuLiAgICAgIDo6PSAgXCJbXCIgKCBlbGVtZW50ICggXCIsXCIgZWxlbWVudCApKiApPyBub25zZW5zZT8gXCJdXCIgO1xuICBcbiAgXG4gICAgIFxuICAgIG9iamVjdC4uICAgICA6Oj0gIFwie1wiICggcHJvcGVydHkgKCBcIixcIiBwcm9wZXJ0eSApKiApPyBub25zZW5zZT8gXCJ9XCIgO1xuICBcbiAgXG4gICAgXG4gICAgcHJvcGVydHkgICAgIDo6PSAgW3N0cmluZy1saXRlcmFsXSBcIjpcIiBqc29uIDtcbiAgXG4gICAgXG5cbiAgICBlbGVtZW50ICAgICAgOjo9ICBqc29uIDtcbiAgXG4gICAgXG5cbiAgICBub25zZW5zZS4gICAgOjo9ICAoIFwiOlwiIHwgXCIsXCIgfCBbc3RyaW5nLWxpdGVyYWxdIHwgW251bWJlcl0gfCBbYm9vbGVhbl0gfCBbbnVsbF0gfCBbdW5hc3NpZ25lZF0gKSsgO1xuICAgIFxuXG5cbiAgICBlcnJvci4gICAgICAgOjo9ICAuIDtcbiAgICBcbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNPTlBhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEpTT05QYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihKU09OUGFyc2VyLCBibmYpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21SdWxlcyhKU09OUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYFxuXG4gICAgZG9jdW1lbnQgICAgICAgICAgICAgICAgOjo9ICAoIHByb2NlZHVyZURlY2xhcmF0aW9uIHwgZXJyb3IgKSsgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIHByb2NlZHVyZURlY2xhcmF0aW9uICAgIDo6PSAgW3R5cGVdIGxhYmVsPE5PX1dISVRFU1BBQ0U+XCIoXCIgcGFyYW1ldGVycz8gXCIpXCIgcmV0dXJuQmxvY2sgO1xuICAgIFxuICAgIGFub255bW91c1Byb2NlZHVyZSAgICAgIDo6PSAgW3R5cGVdIFwiKFwiIHBhcmFtZXRlcnM/IFwiKVwiIHJldHVybkJsb2NrIDtcbiAgICBcbiAgICByZXR1cm5TdGF0ZW1lbnQgICAgICAgICA6Oj0gIFwicmV0dXJuXCIgdGVybSBcIjtcIiA7IFxuICAgIFxuICAgIFxuICAgIFxuICAgIHN0ZXAgICAgICAgICAgICAgICAgICAgIDo6PSAgYXJyYXlBc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9iamVjdEFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdmFyaWFibGVBc3NpZ25tZW50c1xuICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgIFxuICAgICAgXG4gICAgICBcbiAgICBcbiAgICBhcnJheUFzc2lnbm1lbnQgICAgICAgICA6Oj0gIFwiW1wiIHBhcmFtZXRlcnMgXCJdXCIgXCI9XCIgdmFyaWFibGUgXCI7XCIgO1xuICAgIFxuICAgIG9iamVjdEFzc2lnbm1lbnQgICAgICAgIDo6PSAgXCJ7XCIgbmFtZWRQYXJhbWV0ZXJzIFwifVwiIFwiPVwiIHZhcmlhYmxlIFwiO1wiIDtcbiAgICBcbiAgICB2YXJpYWJsZUFzc2lnbm1lbnRzICAgICA6Oj0gIFt0eXBlXSB2YXJpYWJsZUFzc2lnbm1lbnQgKCBcIixcIiB2YXJpYWJsZUFzc2lnbm1lbnQgKSogXCI7XCIgO1xuICAgIFxuICAgIHZhcmlhYmxlQXNzaWdubWVudCAgICAgIDo6PSAgdmFyaWFibGUgXCI9XCIgZXhwcmVzc2lvbiA7XG4gICAgXG5cblxuICAgIG5hbWVkUGFyYW1ldGVycyAgICAgICAgIDo6PSAgbmFtZWRQYXJhbWV0ZXIgKCBcIixcIiBuYW1lZFBhcmFtZXRlciApKiA7XG4gICAgXG4gICAgcGFyYW1ldGVycyAgICAgICAgICAgICAgOjo9ICBwYXJhbWV0ZXIgKCBcIixcIiBwYXJhbWV0ZXIgKSogO1xuICAgIFxuICAgIHRlcm1zICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSAoIFwiLFwiIHRlcm0gKSogO1xuICAgIFxuXG5cbiAgICBuYW1lZFBhcmFtZXRlciAgICAgICAgICA6Oj0gIFt0eXBlXSBbbmFtZV0gKCBcImFzXCIgW25hbWVdICk/IDsgICBcbiAgICBcbiAgICBwYXJhbWV0ZXIgICAgICAgICAgICAgICA6Oj0gIFt0eXBlXSBbbmFtZV1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFwiX1wiIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBcbiAgICBwcm9jZWR1cmVDYWxsICAgICAgICAgICA6Oj0gIHJlZmVyZW5jZTxOT19XSElURVNQQUNFPlwiKFwiIHRlcm1zPyBcIilcIiA7XG4gICAgXG4gICAgcmV0dXJuQmxvY2suLiAgICAgICAgICAgOjo9ICBcIntcIiAoIHN0ZXAgfCBub25zZW5zZSApKiByZXR1cm5TdGF0ZW1lbnQgXCJ9XCIgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIG5vZGVzUXVlcnkgICAgICAgICAgICAgIDo6PSAgXCJub2Rlc1F1ZXJ5XCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBbc3RyaW5nLWxpdGVyYWxdIFwiKVwiIDtcbiAgICBcbiAgICBub2RlUXVlcnkgICAgICAgICAgICAgICA6Oj0gIFwibm9kZVF1ZXJ5XCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBbc3RyaW5nLWxpdGVyYWxdIFwiKVwiIDtcbiAgICBcbiAgICB0ZXJuYXJ5ICAgICAgICAgICAgICAgICA6Oj0gIFwiaWZcIiBcIihcIiB0ZXJtIFwiKVwiIGV4cHJlc3Npb24gXCJlbHNlXCIgZXhwcmVzc2lvbiA7XG4gICAgXG4gICAgcmVkdWNlICAgICAgICAgICAgICAgICAgOjo9ICBcInJlZHVjZVwiPE5PX1dISVRFU1BBQ0U+XCIoXCIgdmFyaWFibGUgXCIsXCIgYW5vbnltb3VzUHJvY2VkdXJlIFwiLFwiIGV4cHJlc3Npb24gXCIpXCIgO1xuICAgIFxuICAgIGV2ZXJ5ICAgICAgICAgICAgICAgICAgIDo6PSAgXCJldmVyeVwiPE5PX1dISVRFU1BBQ0U+XCIoXCIgdmFyaWFibGUgXCIsXCIgYW5vbnltb3VzUHJvY2VkdXJlIFwiKVwiIDtcbiAgICBcbiAgICBzb21lICAgICAgICAgICAgICAgICAgICA6Oj0gIFwic29tZVwiPE5PX1dISVRFU1BBQ0U+XCIoXCIgdmFyaWFibGUgXCIsXCIgYW5vbnltb3VzUHJvY2VkdXJlIFwiKVwiIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICBjb21wYXJpc29uVGVybSAgICAgICAgICA6Oj0gIHRlcm0gKCBcIj09XCIgfCBcIiE9XCIgKSB0ZXJtIDsgXG4gICAgXG4gICAgYnJhY2tldGVkVGVybSAgICAgICAgICAgOjo9ICBcIihcIiB0ZXJtIFwiKVwiIDsgXG4gICAgXG4gICAgbmVnYXRlZFRlcm0gICAgICAgICAgICAgOjo9ICBcIiFcIjxOT19XSElURVNQQUNFPnRlcm0gOyBcbiAgICBcbiAgICBsb2dpY2FsVGVybSAgICAgICAgICAgICA6Oj0gIHRlcm0gKCBcInx8XCIgfCBcIiYmXCIgKSB0ZXJtIDsgXG5cblxuICAgIFxuICAgIGV4cHJlc3Npb24gICAgICAgICAgICAgIDo6PSAgcHJvY2VkdXJlQ2FsbFxuICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJldHVybkJsb2NrXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub2Rlc1F1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vZGVRdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJuYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJlZHVjZVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgZXZlcnlcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICB0ZXJtICAgICAgICAgICAgICAgICAgICA6Oj0gIGNvbXBhcmlzb25UZXJtIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgYnJhY2tldGVkVGVybSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIGxvZ2ljYWxUZXJtIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbmVnYXRlZFRlcm0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBwcmltaXRpdmUgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB2YXJpYWJsZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBcbiAgICBwcmltaXRpdmUgICAgICAgICAgICAgICA6Oj0gIFtzdHJpbmctbGl0ZXJhbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW2Jvb2xlYW5dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtudW1iZXJdIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuXG4gICAgcmVmZXJlbmNlLiAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuICAgIFxuICAgIHZhcmlhYmxlICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcbiAgICBcbiAgICBsYWJlbC4gICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSA7XG4gICAgXG4gICAgXG4gICAgXG4gICAgbm9uc2Vuc2UuICAgICAgICAgICAgICAgOjo9ICBbc2Vjb25kYXJ5LWtleXdvcmRdIHwgW3R5cGVdIHwgW251bGxdIHwgW2Jvb2xlYW5dIHwgW3N0cmluZy1saXRlcmFsXSB8IFtxdWVyeV0gfCBbc3BlY2lhbF0gfCBbbmFtZV0gfCBbbnVtYmVyXSB8IFt1bmFzc2lnbmVkXSA7XG5cblxuICAgIFxuICAgIGVycm9yLiAgICAgICAgICAgICAgICAgIDo6PSAgLiA7XG4gICAgXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZVBhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEZ1cnRsZVBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKEZ1cnRsZVBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoRnVydGxlUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYGRvY3VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gICggdmFyaWFibGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY29tYmluYXRvckRlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtZXRhdmFyaWFibGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHlwZVByZWZpeERlY2xhcmF0aW9uICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNpbXBsZVR5cGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY29tcGxleFR5cGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBydWxlIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGF4aW9tIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlbW1hIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRoZW9yZW0gXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY29uamVjdHVyZSBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtZXRhTGVtbWEgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbWV0YXRoZW9yZW0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNlY3Rpb24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdmVydGljYWxTcGFjZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlcnJvciApKyA7XG5cblxuXG5zZWN0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkdpdmVuXCIgPEVORF9PRl9MSU5FPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeXBvdGhlc2lzK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYXhpb20gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGVtbWEgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdGhlb3JlbSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb25qZWN0dXJlICkgOyBcblxuXG5cbnZlcnRpY2FsU3BhY2UgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIDxFTkRfT0ZfTElORT4rIDtcblxuXG5cbmVycm9yLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5cblxudmFyaWFibGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICAgIDo6PSAgXCJWYXJpYWJsZVwiIHZhcmlhYmxlICggXCI6XCIgdHlwZSBcInByb3Zpc2lvbmFsbHlcIj8gKT8gPEVORF9PRl9MSU5FPiA7XG4gXG5jb21iaW5hdG9yRGVjbGFyYXRpb24gICAgICAgICAgICAgICAgOjo9ICBcIkNvbWJpbmF0b3JcIiBjb21iaW5hdG9yLi4uIDxFTkRfT0ZfTElORT4gO1xuIFxuY29uc3RydWN0b3JEZWNsYXJhdGlvbiAgICAgICAgICAgICAgIDo6PSAgXCJDb25zdHJ1Y3RvclwiIGNvbnN0cnVjdG9yLi4uICggXCI6XCIgdHlwZSBcInByb3Zpc2lvbmFsbHlcIj8gKT8gPEVORF9PRl9MSU5FPiA7XG4gXG5tZXRhdmFyaWFibGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgOjo9ICBcIk1ldGF2YXJpYWJsZVwiIG1ldGF2YXJpYWJsZS4uLiBcIjpcIiBtZXRhVHlwZSA8RU5EX09GX0xJTkU+IDtcbiBcbnR5cGVQcmVmaXhEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICA6Oj0gIFwiVHlwZVByZWZpeFwiIHR5cGVQcmVmaXggPEVORF9PRl9MSU5FPiA7XG5cbnNpbXBsZVR5cGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICA6Oj0gIFwiUHJvdmlzaW9uYWxcIj8gXCJUeXBlXCIgdHlwZSAoIFwiOlwiIHR5cGVzICk/IDxFTkRfT0ZfTElORT4gO1xuIFxuY29tcGxleFR5cGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgIDo6PSAgXCJQcm92aXNpb25hbFwiPyBcIlR5cGVcIiA8RU5EX09GX0xJTkU+IFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlICggXCI6XCIgdHlwZXMgKT8gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcIlByb3BlcnRpZXNcIiA8RU5EX09GX0xJTkU+IHByb3BlcnR5RGVjbGFyYXRpb24gcHJvcGVydHlEZWNsYXJhdGlvbisgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCJQcm9wZXJ0eVwiIDxFTkRfT0ZfTElORT4gcHJvcGVydHlEZWNsYXJhdGlvbiApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICBcblxuICBcbnJ1bGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHJ1bGVIZWFkZXIgcnVsZUJvZHkgOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbm1ldGFMZW1tYSAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIG1ldGFMZW1tYUhlYWRlciBtZXRhTGVtbWFCb2R5IDtcblxubWV0YXRoZW9yZW0gICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXRoZW9yZW1IZWFkZXIgbWV0YXRoZW9yZW1Cb2R5IDtcblxuYXhpb20gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgYXhpb21IZWFkZXIgYXhpb21Cb2R5IDtcblxubGVtbWEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbGVtbWFIZWFkZXIgbGVtbWFCb2R5IDtcblxudGhlb3JlbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGhlb3JlbUhlYWRlciB0aGVvcmVtQm9keSA7XG5cbmNvbmplY3R1cmUgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGNvbmplY3R1cmVIZWFkZXIgY29uamVjdHVyZUJvZHkgO1xuXG5cblxucnVsZUhlYWRlciAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIlJ1bGVcIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gOyBcblxubWV0YUxlbW1hSGVhZGVyICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIk1ldGFMZW1tYVwiIHBhcmVudGhlc2lzZWRMYWJlbC4uLiA8RU5EX09GX0xJTkU+IHwgXCJNZXRhTGVtbWFcIiA8RU5EX09GX0xJTkU+IDtcblxubWV0YXRoZW9yZW1IZWFkZXIgICAgICAgICAgICAgICAgICAgOjo9ICBcIk1ldGF0aGVvcmVtXCIgcGFyZW50aGVzaXNlZExhYmVsLi4uIDxFTkRfT0ZfTElORT4gOyBcblxuYXhpb21IZWFkZXIgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkF4aW9tXCIgc2lnbmF0dXJlPyBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gOyBcblxubGVtbWFIZWFkZXIgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkxlbW1hXCIgcGFyZW50aGVzaXNlZExhYmVscy4uLiA8RU5EX09GX0xJTkU+IHwgXCJMZW1tYVwiIDxFTkRfT0ZfTElORT4gOyBcblxudGhlb3JlbUhlYWRlciAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIlRoZW9yZW1cIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gOyBcblxuY29uamVjdHVyZUhlYWRlciAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkNvbmplY3R1cmVcIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gO1xuXG5cblxucnVsZUJvZHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFwiUHJlbWlzZXNcIiA8RU5EX09GX0xJTkU+IHByZW1pc2UgcHJlbWlzZSsgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCJQcmVtaXNlXCIgPEVORF9PRl9MSU5FPiBwcmVtaXNlICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29uY2x1c2lvblwiIDxFTkRfT0ZfTElORT4gY29uY2x1c2lvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mPyA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxubWV0YUxlbW1hQm9keSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uKyBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mIDtcblxubWV0YXRoZW9yZW1Cb2R5ICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uKyBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2YgO1xuXG5heGlvbUJvZHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uIDtcblxubGVtbWFCb2R5ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uK1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZiA7XG5cbnRoZW9yZW1Cb2R5ICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTdXBwb3NlXCIgPEVORF9PRl9MSU5FPiBzdXBwb3NpdGlvbitcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mIDtcblxuY29uamVjdHVyZUJvZHkgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uK1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2Y/IDtcblxuXG5cbnByb29mICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiUHJvb2ZcIiA8RU5EX09GX0xJTkU+IGRlcml2YXRpb24gO1xuXG5zdWJwcm9vZiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uKyBzdWJEZXJpdmF0aW9uIDtcblxuZGVyaXZhdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHN0ZXAgfCBzdWJwcm9vZiApKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmVmb3JlXCIgPEVORF9PRl9MSU5FPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5zdWJEZXJpdmF0aW9uICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJIZW5jZVwiIDxFTkRfT0ZfTElORT5cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzdGVwIHwgc3VicHJvb2YgKSsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5cblxucHJvcGVydHlEZWNsYXJhdGlvbi4gICAgICAgICAgICAgICAgIDo6PSAgcHJvcGVydHkgKCBcIjpcIiB0eXBlICk/IDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub25zZW5zZS4uLiA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5cbmNvbWJpbmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHN0YXRlbWVudCA7XG5cbmNvbnN0cnVjdG9yICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHRlcm0gOyBcblxuIFxuXG5wcmVtaXNlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBwcm9jZWR1cmVDYWxsIDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5zdXBwb3NpdGlvbi4gICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBwcm9jZWR1cmVDYWxsIDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5jb25jbHVzaW9uLiAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5kZWR1Y3Rpb24uICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5oeXBvdGhlc2lzLiAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cblxuc3RlcC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgc3RhdGVtZW50Li4uIHF1YWxpZmljYXRpb24/IDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub25zZW5zZS4uLiBxdWFsaWZpY2F0aW9uPyA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5cbnF1YWxpZmljYXRpb24gICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiYmVjYXVzZVwiIHNhdGlzZmllc0Fzc2VydGlvblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAoIFwiYnlcIiB8IFwiZnJvbVwiICkgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgXG5cblxuXG5wYXJlbnRoZXNpc2VkTGFiZWxzICAgICAgICAgICAgICAgICAgOjo9ICBcIihcIiBsYWJlbHMgXCIpXCIgOyBcblxucGFyZW50aGVzaXNlZExhYmVsICAgICAgICAgICAgICAgICAgIDo6PSAgXCIoXCIgbGFiZWwgXCIpXCIgOyBcblxuXG5cbnByb2NlZHVyZUNhbGwgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiQFwiPE5PX1dISVRFU1BBQ0U+cHJvY2VkdXJlUmVmZXJlbmNlPE5PX1dISVRFU1BBQ0U+XCIoXCIgcGFyYW1ldGVyICggXCIsXCIgcGFyYW1ldGVyICkqIFwiKVwiIDtcblxuXG5cbnNpZ25hdHVyZSAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiIHRlcm0gKCBcIixcIiB0ZXJtICkqIFwiXVwiIDtcblxuXG5cbmFyZ3VtZW50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGFyZ3VtZW50ICggXCIsXCIgYXJndW1lbnQgKSogO1xuXG5sYWJlbHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBsYWJlbCAoIFwiLFwiIGxhYmVsICkqIDtcblxudHlwZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdHlwZSAoIFwiLFwiIHR5cGUgKSogO1xuXG5cblxuYXJndW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSAoICkgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHR5cGUgKCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxubWV0YUFyZ3VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgc3RhdGVtZW50ICggKSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbWV0YVR5cGUgKCApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbmZyYW1lQXJndW1lbnQgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGZyYW1lICggKSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbWV0YVR5cGUgKCApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxucHJvY2VkdXJlUmVmZXJlbmNlLiAgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcblxucmVmZXJlbmNlLiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXZhcmlhYmxlIDtcblxubGFiZWwuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXZhcmlhYmxlIDtcblxuXG5cbmVxdWl2YWxlbmNlcyAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGVxdWl2YWxlbmNlICggXCIsXCIgZXF1aXZhbGVuY2UgKSogO1xuXG5lcXVpdmFsZW5jZSAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIiB0ZXJtICggXCIsXCIgdGVybSApKyBcIl1cIiA7XG5cblxuXG5tZXRhdmFyaWFibGUuICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gKCA8Tk9fV0hJVEVTUEFDRT5cIihcIiAoIHRlcm0gfCB0eXBlIHwgc3R1ZmYgKSBcIilcIiApPyA7XG5cbnBhcmFtZXRlci4gICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSB8IFtpZGVudGlmaWVyXSA7XG5cbnZhcmlhYmxlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXSA7XG5cbm1ldGFUeXBlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFttZXRhLXR5cGVdIDtcblxucHJvcGVydHkuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdKyA7XG5cbnR5cGVQcmVmaXguICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFt0eXBlXSA7XG5cbnR5cGUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFt0eXBlXSAoIDxOT19XSElURVNQQUNFPlt0eXBlXSApPyBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgXCI8XCI8Tk9fV0hJVEVTUEFDRT5cIj5cIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuXG5zdHVmZi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoIFtzdHJpbmctbGl0ZXJhbF0gfCBbc3ltYm9sXSB8IFt0eXBlXSB8IFtuYW1lXSB8IFtpZGVudGlmaWVyXSB8IFtwcmltaXRpdmVdIHwgW3VuYXNzaWduZWRdICkrIDtcblxubm9uc2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBbc2Vjb25kYXJ5LWtleXdvcmRdIHwgW21ldGEtdHlwZV0gfCBbc3BlY2lhbF0gfCBbc3ltYm9sXSB8IFt0eXBlXSB8IFtuYW1lXSB8IFtpZGVudGlmaWVyXSB8IFtwcmltaXRpdmVdIHwgW3VuYXNzaWduZWRdICkrIDtgO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbWluYWxQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICA6Oj0gICggYmxvY2sgfCB2ZXJ0aWNhbFNwYWNlICkrIDtcblxuICAgIGJsb2NrICAgICAgICAgIDo6PSAgZW5kZWRMaW5lKiBsYXN0TGluZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICB8ICBlbmRlZExpbmUrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgbGFzdExpbmUgICAgICAgOjo9ICAoIFthbHBoYS1udW1lcmljXSB8IFtwdW5jdHVhdGlvbl0gfCBbdW5hc3NpZ25lZF0gKSsgO1xuXG4gICAgZW5kZWRMaW5lICAgICAgOjo9ICAoIFthbHBoYS1udW1lcmljXSB8IFtwdW5jdHVhdGlvbl0gfCBbdW5hc3NpZ25lZF0gKSsgPEVORF9PRl9MSU5FPiA7XG5cbiAgICB2ZXJ0aWNhbFNwYWNlICA6Oj0gIDxFTkRfT0ZfTElORT4rIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFpblRleHRQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhQbGFpblRleHRQYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihQbGFpblRleHRQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKFBsYWluVGV4dFBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgICAgZG9jdW1lbnQgICAgICAgICAgICAgICAgIDo6PSAgKCBydWxlIHwgZXJyb3IgKSsgO1xuXG4gICAgICBydWxlICAgICAgICAgICAgICAgICAgICAgOjo9ICBuYW1lIFwiOjo9XCIgZGVmaW5pdGlvbnMgXCI7XCIgO1xuXG4gICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBkZWZpbml0aW9ucyAgICAgICAgICAgICAgOjo9ICBkZWZpbml0aW9uICggXCJ8XCIgZGVmaW5pdGlvbiApKiA7XG5cbiAgICAgIGRlZmluaXRpb24gICAgICAgICAgICAgICA6Oj0gIHBhcnQrIHByZWNlZGVuY2U/IDtcbiBcbiAgICAgIHBhcnQgICAgICAgICAgICAgICAgICAgICA6Oj0gIG5vblRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtaW5hbFBhcnQgcXVhbnRpZmllcipcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBub25UZXJtaW5hbFBhcnQgICAgICAgICAgOjo9ICBjaG9pY2VPZlBhcnRzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNlcXVlbmNlT2ZQYXJ0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBydWxlTmFtZSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICB0ZXJtaW5hbFBhcnQgICAgICAgICAgICAgOjo9ICBzaWduaWZpY2FudFRva2VuVHlwZVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHN0cmluZ0xpdGVyYWxcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlbmRPZkxpbmVcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub1doaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICBzZXF1ZW5jZU9mUGFydHMgICAgICAgICAgOjo9ICBcIihcIiBwYXJ0IHBhcnQrIFwiKVwiIDtcblxuICAgICAgY2hvaWNlT2ZQYXJ0cyAgICAgICAgICAgIDo6PSAgXCIoXCIgcGFydENob2ljZSAoIFwifFwiIHBhcnRDaG9pY2UgKSsgXCIpXCIgO1xuXG4gICAgICBwYXJ0Q2hvaWNlICAgICAgICAgICAgICAgOjo9ICBwYXJ0IHByZWNlZGVuY2U/IDtcblxuICAgICAgcnVsZU5hbWUgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcblxuICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGUgICAgIDo6PSAgW3R5cGVdIDtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCAgICAgICAgICAgIDo6PSAgW3N0cmluZy1saXRlcmFsXSA7XG5cbiAgICAgIHByZWNlZGVuY2UgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIFtudW1iZXJdPyBcIilcIiA7XG4gICAgICBcbiAgICAgIGVuZE9mTGluZSAgICAgICAgICAgICAgICA6Oj0gIFwiPEVORF9PRl9MSU5FPlwiIDtcbiAgICAgIFxuICAgICAgbm9XaGl0ZXNwYWNlICAgICAgICAgICAgIDo6PSAgXCI8Tk9fV0hJVEVTUEFDRT5cIiA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgIHF1YW50aWZpZXIgICAgICAgICAgICAgICA6Oj0gIG9wdGlvbmFsUXVhbnRpZmllclxuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb25lT3JNb3JlUXVhbnRpZmllclxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHplcm9Pck1vcmVRdWFudGlmaWVyXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBvcHRpb25hbFF1YW50aWZpZXIgICAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIj9cIiA7XG5cbiAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXIgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiK1wiIDtcblxuICAgICAgemVyb09yTW9yZVF1YW50aWZpZXIgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIqXCIgO1xuXG4gICAgICBlcnJvci4gICAgICAgICAgICAgICAgICAgOjo9ICAuIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21HcmFtbWFyQk5GUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoQ3VzdG9tR3JhbW1hckJORlBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICA6Oj0gICggZXhwcmVzc2lvbiB8IHZlcnRpY2FsU3BhY2UgfCBlcnJvciApKyA7XG5cbiAgICBleHByZXNzaW9uICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlt1bmFzc2lnbmVkXTxOT19XSElURVNQQUNFPjxFTkRfT0ZfTElORT4gO1xuXG4gICAgdmVydGljYWxTcGFjZSAgOjo9ICA8RU5EX09GX0xJTkU+KyA7XG4gICBcbiAgICBlcnJvci4gICAgICAgICA6Oj0gIC4gO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlWExleGVyIH0gZnJvbSBcIi4vdGVYL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEpTT05MZXhlciB9IGZyb20gXCIuL2pzb24vbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlTGV4ZXIgfSBmcm9tIFwiLi9mdXJ0bGUvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9taW5hbExleGVyIH0gZnJvbSBcIi4vbm9taW5hbC9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQbGFpblRleHRMZXhlciB9IGZyb20gXCIuL3BsYWluVGV4dC9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDdXN0b21HcmFtbWFyQk5GTGV4ZXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyQk5GL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlWFBhcnNlciB9IGZyb20gXCIuL3RlWC9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSlNPTlBhcnNlciB9IGZyb20gXCIuL2pzb24vcGFyc2VyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZ1cnRsZVBhcnNlciB9IGZyb20gXCIuL2Z1cnRsZS9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9taW5hbFBhcnNlciB9IGZyb20gXCIuL25vbWluYWwvcGFyc2VyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYWluVGV4dFBhcnNlciB9IGZyb20gXCIuL3BsYWluVGV4dC9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ3VzdG9tR3JhbW1hckJORlBhcnNlciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXJCTkYvcGFyc2VyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIH0gZnJvbSBcIi4vY3VzdG9tR3JhbW1hclZvY2FidWxhcnkvcGFyc2VyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEN1c3RvbUdyYW1tYXJCTkZMZXhlciwgQ3VzdG9tR3JhbW1hckJORlBhcnNlciB9IGZyb20gXCJvY2NhbS1ncmFtbWFyc1wiO1xuaW1wb3J0IHsgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciwgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgfSBmcm9tIFwib2NjYW0tZ3JhbW1hcnNcIjtcblxuZXhwb3J0IGNvbnN0IGN1c3RvbUdyYW1tYXJCTkZMZXhlciA9IEN1c3RvbUdyYW1tYXJCTkZMZXhlci5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgY29uc3QgY3VzdG9tR3JhbW1hckJORlBhcnNlciA9IEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIgPSBDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciA9IEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyLmZyb21Ob3RoaW5nKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBub2Rlc1F1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciwgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2dyYW1tYXJcIlxuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNvbnN0IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8vZXhwcmVzc2lvblwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cHJlc3Npb25zRnJvbVZvY2FidWxhcnkodm9jYWJ1bGFyeSwgZXhwcmVzc2lvbnMpIHtcbiAgY29uc3QgY29udGVudCA9IHZvY2FidWxhcnksIC8vL1xuICAgICAgICB0b2tlbnMgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGV4cHJlc3Npb25Ob2RlcyA9IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5KG5vZGUpO1xuXG4gIGV4cHJlc3Npb25Ob2Rlcy5mb3JFYWNoKChleHByZXNzaW9uTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICBleHByZXNzaW9uID0gZXNjYXBlKGNvbnRlbnQpO1xuXG4gICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgc2Vjb25kQ2hpbGROb2RlID0gc2Vjb25kKGNoaWxkTm9kZXMpLFxuICAgICAgICB1bmFzc2lnbmVkVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgIGNvbnRlbnQgPSB1bmFzc2lnbmVkVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25MZXhlciB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBOb21pbmFsTGV4ZXIsIE5vbWluYWxQYXJzZXIgfSBmcm9tIFwib2NjYW0tZ3JhbW1hcnNcIjtcblxuZXhwb3J0IGNvbnN0IG5vbWluYWxMZXhlciA9IENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKE5vbWluYWxMZXhlcik7XG5cbmV4cG9ydCBjb25zdCBub21pbmFsUGFyc2VyID0gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKE5vbWluYWxQYXJzZXIpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgbm9taW5hbFBhcnNlciB9IGZyb20gXCIuL3V0aWxpdGllcy9ub21pbmFsXCI7XG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSwgU1RBVEVNRU5UX1JVTEVfTkFNRSB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgU1RVRkZfUlVMRV9OQU1FLCBOT05TRU5TRV9SVUxFX05BTUUgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNvbnN0IHJ1bGVNYXAgPSBub21pbmFsUGFyc2VyLmdldFJ1bGVNYXAoKSxcbiAgICAgIHN0dWZmUnVsZSA9IHJ1bGVNYXBbU1RVRkZfUlVMRV9OQU1FXSxcbiAgICAgIG5vbnNlbnNlUnVsZSA9IHJ1bGVNYXBbTk9OU0VOU0VfUlVMRV9OQU1FXSxcbiAgICAgIHN0dWZmVHlwZXMgPSB0eXBlc0Zyb21SdWxlKHN0dWZmUnVsZSksXG4gICAgICBub25zZW5zZVR5cGVzID0gdHlwZXNGcm9tUnVsZShub25zZW5zZVJ1bGUpLFxuICAgICAgdGVybVR5cGVzID0gc3R1ZmZUeXBlcywgLy8vXG4gICAgICBzdGF0ZW1lbnRUeXBlcyA9IG5vbnNlbnNlVHlwZXMsXG4gICAgICB0eXBlc01hcCA9IHtcbiAgICAgICAgW1RFUk1fUlVMRV9OQU1FXTogdGVybVR5cGVzLFxuICAgICAgICBbU1RBVEVNRU5UX1JVTEVfTkFNRV06IHN0YXRlbWVudFR5cGVzXG4gICAgICB9O1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlc01hcDtcblxuZnVuY3Rpb24gdHlwZXNGcm9tUnVsZShydWxlKSB7XG4gIGxldCBwYXJ0cztcblxuICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKSxcbiAgICAgICAgZmlyc3RERGVmaW5pdGlvbiA9IGZpcnN0KGRlZmluaXRpb25zKSxcbiAgICAgICAgZGVmaW5pdGlvbiA9IGZpcnN0RERlZmluaXRpb247ICAvLy9cblxuICBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKTtcblxuICBjb25zdCBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIG9uZU9yTW9yZVBhcnRzUGFydCA9IGZpcnN0UGFydCwgLy8vXG4gICAgICAgIHBhcnQgPSBvbmVPck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpLFxuICAgICAgICBjaG9pY2VPclBhcnRzUGFydCA9IHBhcnQ7IC8vL1xuXG4gIHBhcnRzID0gY2hvaWNlT3JQYXJ0c1BhcnQuZ2V0UGFydHMoKTtcblxuICBjb25zdCB0eXBlcyA9IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZSA9IHNpZ25pZmljYW50VG9rZW5UeXBlUGFydC5nZXRTaWduaWZpY2FudFRva2VuVHlwZSgpLFxuICAgICAgICAgIHR5cGUgPSBzaWduaWZpY2FudFRva2VuVHlwZTsgIC8vL1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiB0eXBlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB0eXBlc01hcCBmcm9tIFwiLi4vdHlwZXNNYXBcIjtcblxuaW1wb3J0IHsgbm9taW5hbExleGVyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ub21pbmFsXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBVTkFTU0lHTkVEX1RZUEUsIEJBU0VfVFlQRV9TWU1CT0wgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjdXN0b21HcmFtbWFyQk5GTGV4ZXIsIGN1c3RvbUdyYW1tYXJCTkZQYXJzZXIsIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIsIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ncmFtbWFyXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNvbnN0IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8vZXhwcmVzc2lvblwiKSxcbiAgICAgIHJ1bGVOYW1lVGVybWluYWxOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvZG9jdW1lbnQvcnVsZS9uYW1lL0AqIVwiKSxcbiAgICAgIHVuYXNzaWduZWRUZXJtaW5hbE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9leHByZXNzaW9uL0B1bmFzc2lnbmVkXCIpLFxuICAgICAgc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvL3N0cmluZ0xpdGVyYWwvQCohXCIpLFxuICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5KFwiLy9zaWduaWZpY2FudFRva2VuVHlwZS9AKiFcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJORihibmYsIHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBibmYsXG4gICAgICAgIHRva2VucyA9IGN1c3RvbUdyYW1tYXJCTkZMZXhlci50b2tlbmlzZShjb250ZW50KSxcbiAgICAgICAgbm9kZSA9IGN1c3RvbUdyYW1tYXJCTkZQYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJ1bGVOYW1lVGVybWluYWxOb2RlID0gcnVsZU5hbWVUZXJtaW5hbE5vZGVRdWVyeShub2RlKTtcblxuICBpZiAocnVsZU5hbWVUZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBuYW1lID0gbmFtZUZyb21SdWxlTmFtZVRlcm1pbmFsTm9kZShydWxlTmFtZVRlcm1pbmFsTm9kZSk7XG5cbiAgICBpZiAobmFtZSAhPT0gcnVsZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke25hbWV9JyBydWxlIHNob3VsZCBiZSBuYW1lZCAnJHtydWxlTmFtZX0nLmApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHR5cGVzID0gdHlwZXNNYXBbcnVsZU5hbWVdLFxuICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXMgPSBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXNRdWVyeShub2RlKTtcblxuICBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXMuZm9yRWFjaCgoc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZUZyb21TaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZShzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZSksXG4gICAgICAgICAgdHlwZXNJbmNsdWRlVHlwZSA9IHR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuXG4gICAgaWYgKCF0eXBlc0luY2x1ZGVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHt0eXBlfScgdHlwZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlICcke3J1bGVOYW1lfScgcnVsZSdzIHR5cGVzLmApXG4gICAgfVxuICB9KTtcblxuICBjb25zdCBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlcyA9IHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVzUXVlcnkobm9kZSk7XG5cbiAgc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXMuZm9yRWFjaCgoc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUoc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZSk7XG5cbiAgICBpZiAoY29udGVudCA9PT0gQkFTRV9UWVBFX1NZTUJPTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke2NvbnRlbnR9XCIgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBiYXNlIHR5cGUgc3ltYm9sLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VucyA9IG5vbWluYWxMZXhlci50b2tlbmlzZShjb250ZW50KSxcbiAgICAgICAgICB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRva2Vuc0xlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbmlzaW5nIHRoZSBcIiR7Y29udGVudH1cIiBzdHJpbmcgbGl0ZXJhbCBkb2VzIG5vdCByZXN1bHQgaW4gYSBzaW5nbGUgdG9rZW4uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IGZpcnN0KHRva2VucyksXG4gICAgICAgICAgdG9rZW4gPSBmaXJzdFRva2VuLCAvLy9cbiAgICAgICAgICB0eXBlID0gdG9rZW4uZ2V0VHlwZSgpLFxuICAgICAgICAgIHR5cGVzSW5jbHVkZVR5cGUgPSB0eXBlcy5pbmNsdWRlcyh0eXBlKTtcblxuICAgIGlmICghdHlwZXNJbmNsdWRlVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke2NvbnRlbnR9XCIgc3RyaW5nIGxpdGVyYWwncyB0b2tlbidzICcke3R5cGV9JyB0eXBlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlJ3MgdHlwZXMuYClcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWb2NhYnVsYXJ5KHZvY2FidWxhcnkpIHtcbiAgY29uc3QgY29udGVudCA9IHZvY2FidWxhcnksIC8vL1xuICAgICAgICB0b2tlbnMgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGV4cHJlc3Npb25Ob2RlcyA9IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5KG5vZGUpO1xuXG4gIGV4cHJlc3Npb25Ob2Rlcy5mb3JFYWNoKChleHByZXNzaW9uTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICB0b2tlbnMgPSBub21pbmFsTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgICAgdG9rZW5zTGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIGlmICh0b2tlbnNMZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuaXNpbmcgdGhlICcke2NvbnRlbnR9JyBjb250ZW50IHJlc3VsdHMgaW4gbW9yZSB0aGFuIG9uZSB0b2tlbi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFRva2VuID0gZmlyc3QodG9rZW5zKSxcbiAgICAgICAgICB0b2tlbiA9IGZpcnN0VG9rZW4sXG4gICAgICAgICAgdHlwZSA9IHRva2VuLmdldFR5cGUoKTtcblxuICAgIGlmICh0eXBlICE9PSBVTkFTU0lHTkVEX1RZUEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke3R5cGV9JyB0eXBlIG9mIHRoZSAnJHtjb250ZW50fScgdG9rZW4gaXMgbm90ICd1bmFzc2lnbmVkJy5gKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGVudCA9PT0gQkFTRV9UWVBFX1NZTUJPTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7Y29udGVudH0nIHRva2VuIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgYmFzZSB0eXBlIHN5bWJvbC5gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSB7XG4gIGxldCBjb250ZW50O1xuXG4gIGNvbnN0IHVuYXNzaWduZWRUZXJtaW5hbE5vZGUgPSB1bmFzc2lnbmVkVGVybWluYWxOb2RlUXVlcnkoZXhwcmVzc2lvbk5vZGUpO1xuXG4gIGNvbnRlbnQgPSB1bmFzc2lnbmVkVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICByZXR1cm4gY29udGVudDs7XG59XG5cbmZ1bmN0aW9uIG5hbWVGcm9tUnVsZU5hbWVUZXJtaW5hbE5vZGUocnVsZU5hbWVUZXJtaW5hbE5vZGUpIHtcbiAgbGV0IG5hbWU7XG5cbiAgY29uc3QgY29udGVudCA9IHJ1bGVOYW1lVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICBuYW1lID0gY29udGVudDsgLy8vXG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZShzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlKSB7XG4gIGxldCBjb250ZW50O1xuXG4gIGNvbnRlbnQgPSBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaCgvXCIoW15cIl0qKVwiLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gIGNvbnRlbnQgPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHR5cGVGcm9tU2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUoc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUpIHtcbiAgbGV0IHR5cGU7XG5cbiAgY29uc3QgY29udGVudCA9IHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goL1xcWyhbXlxcXV0qKVxcXS8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKTtcblxuICB0eXBlID0gc2Vjb25kTWF0Y2g7IC8vL1xuXG4gIHJldHVybiB0eXBlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuaW1wb3J0IHsgcGFyc2VyVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24gfSBmcm9tIFwib2NjYW0tZ3JhbW1hci11dGlsaXRpZXNcIjtcblxuaW1wb3J0IGRlZmF1bHRDdXN0b21HcmFtbWFyIGZyb20gXCIuLi9jdXN0b21HcmFtbWFyL2RlZmF1bHRcIjtcblxuaW1wb3J0IHsgZXhwcmVzc2lvbnNGcm9tVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdm9jYWJ1bGFyeVwiO1xuaW1wb3J0IHsgVkVSVElDQUxfQkFSLCBWRVJUSUNBTF9TUEFDRSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQk5GLCB2YWxpZGF0ZVZvY2FidWxhcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ZhbGlkYXRlXCI7XG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSwgU1RBVEVNRU5UX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IFRZUEVfVk9DQUJVTEFSWV9OQU1FLCBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FIH0gZnJvbSBcIi4uL3ZvY2FidWxhcnlOYW1lc1wiO1xuXG5jb25zdCB7IG9wYXF1ZSAgfSA9IHNwZWNpYWxTeW1ib2xzLFxuICAgICAgeyBydWxlc0Zyb21CTkYgfSA9IHBhcnNlclV0aWxpdGllcyxcbiAgICAgIHsgdW5zaGlmdCwgZm9yd2FyZHNGb3JFYWNoLCBiYWNrd2FyZHNGb3JFYWNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tYmluZWRDdXN0b21HcmFtbWFyIHtcbiAgY29uc3RydWN0b3IocnVsZXMsIGVudHJpZXMpIHtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuICBcbiAgZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXM7XG4gIH1cblxuICBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXM7XG4gIH1cblxuICBwb3N0UHJvY2VzcyhydWxlcykge1xuICAgIHJ1bGVzID0gWyAvLy9cbiAgICAgIC4uLnJ1bGVzLFxuICAgICAgLi4udGhpcy5ydWxlc1xuICAgIF07XG5cbiAgICBydWxlcyA9IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpOyAgLy8vXG5cbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoaW5jbHVkZURlZmF1bHQgPSB0cnVlKSB7XG4gICAgbGV0IGN1c3RvbUdyYW1tYXJzID0gW107XG5cbiAgICBpZiAoaW5jbHVkZURlZmF1bHQpIHtcbiAgICAgIGN1c3RvbUdyYW1tYXJzID0gWyBkZWZhdWx0Q3VzdG9tR3JhbW1hciwgLi4uY3VzdG9tR3JhbW1hcnMgXTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcnVsZXMgPSBydWxlc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyksXG4gICAgICAgICAgZW50cmllcyA9IGVudHJpZXNGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpLFxuICAgICAgICAgIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IG5ldyBDb21iaW5lZEN1c3RvbUdyYW1tYXIocnVsZXMsIGVudHJpZXMpO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIGluY2x1ZGVEZWZhdWx0ID0gdHJ1ZSkge1xuICAgIGlmIChpbmNsdWRlRGVmYXVsdCkge1xuICAgICAgY3VzdG9tR3JhbW1hcnMgPSBbIGRlZmF1bHRDdXN0b21HcmFtbWFyLCAuLi5jdXN0b21HcmFtbWFycyBdOyAvLy9cbiAgICB9XG5cbiAgICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSxcbiAgICAgICAgICBlbnRyaWVzID0gZW50cmllc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyksXG4gICAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gbmV3IENvbWJpbmVkQ3VzdG9tR3JhbW1hcihydWxlcywgZW50cmllcyk7XG4gICAgXG4gICAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBydWxlc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycykge1xuICBjb25zdCBydWxlTmFtZXMgPSBbXG4gICAgICAgICAgVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgXSxcbiAgICAgICAgYm5mcyA9IHJ1bGVOYW1lcy5tYXAoKHJ1bGVOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgYm5mID0gYm5mRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzLCBydWxlTmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gYm5mO1xuICAgICAgICB9KSxcbiAgICAgICAgYm5mID0gYm5mcy5qb2luKFZFUlRJQ0FMX1NQQUNFKSxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICBjb21iaW5lUnVsZXMocnVsZXMpO1xuXG4gIGNvbnN0IG9wYWNpdHkgPSBvcGFxdWU7IC8vL1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlcy5maW5kKChydWxlKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICAgIGlmIChuYW1lID09PSBydWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJ1bGUuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuXG5mdW5jdGlvbiBlbnRyaWVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSB7XG4gIGNvbnN0IHZvY2FidWxhcnlOYW1lcyA9IFtcbiAgICAgICAgICBUWVBFX1ZPQ0FCVUxBUllfTkFNRSxcbiAgICAgICAgICBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FXG4gICAgICAgIF0sXG4gICAgICAgIGVudHJpZXMgPSB2b2NhYnVsYXJ5TmFtZXMubWFwKCh2b2NhYnVsYXJ5TmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIHZvY2FidWxhcnlOYW1lKTtcblxuICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIGVudHJpZXM7XG59XG5cbmZ1bmN0aW9uIGVudHJ5RnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzLCB2b2NhYnVsYXJ5TmFtZSkge1xuICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuXG4gIGJhY2t3YXJkc0ZvckVhY2goY3VzdG9tR3JhbW1hcnMsIChjdXN0b21HcmFtbWFyKSA9PiB7XG4gICAgY29uc3Qgdm9jYWJ1bGFyeSA9IGN1c3RvbUdyYW1tYXIuZ2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSksXG4gICAgICAgICAgY3VzdG9tR3JhbW1hckRlZmF1bHRDdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hci5pc0RlZmF1bHRDdXN0b21HcmFtbWFyKCk7XG5cbiAgICBpZiAoIWN1c3RvbUdyYW1tYXJEZWZhdWx0Q3VzdG9tR3JhbW1hcikge1xuICAgICAgdmFsaWRhdGVWb2NhYnVsYXJ5KHZvY2FidWxhcnkpO1xuICAgIH1cblxuICAgIGV4cHJlc3Npb25zRnJvbVZvY2FidWxhcnkodm9jYWJ1bGFyeSwgZXhwcmVzc2lvbnMpO1xuICB9KTtcblxuICBjb25zdCBwYXR0ZXJuID0gZXhwcmVzc2lvbnMuam9pbihWRVJUSUNBTF9CQVIpLFxuICAgICAgICBlbnRyeU5hbWUgPSB2b2NhYnVsYXJ5TmFtZSwgIC8vL1xuICAgICAgICBlbnRyeVZhbHVlID0gYF4oPzoke3BhdHRlcm59KWAsXG4gICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgIFtlbnRyeU5hbWVdOiBlbnRyeVZhbHVlXG4gICAgICAgIH07XG5cbiAgcmV0dXJuIGVudHJ5O1xufVxuXG5mdW5jdGlvbiBibmZGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGJuZnMgPSBbXTtcblxuICBmb3J3YXJkc0ZvckVhY2goY3VzdG9tR3JhbW1hcnMsIChjdXN0b21HcmFtbWFyKSA9PiB7XG4gICAgY29uc3QgYm5mID0gY3VzdG9tR3JhbW1hci5nZXRCTkYocnVsZU5hbWUpLFxuICAgICAgICAgIGN1c3RvbUdyYW1tYXJEZWZhdWx0Q3VzdG9tR3JhbW1hciA9IGN1c3RvbUdyYW1tYXIuaXNEZWZhdWx0Q3VzdG9tR3JhbW1hcigpO1xuXG4gICAgaWYgKCFjdXN0b21HcmFtbWFyRGVmYXVsdEN1c3RvbUdyYW1tYXIpIHtcbiAgICAgIHZhbGlkYXRlQk5GKGJuZiwgcnVsZU5hbWUpO1xuICAgIH1cblxuICAgIGJuZnMucHVzaChibmYpO1xuICB9KTtcblxuICBjb25zdCBibmYgPSBibmZzLmpvaW4oVkVSVElDQUxfU1BBQ0UpO1xuXG4gIHJldHVybiBibmY7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVSdWxlcyhydWxlcykge1xuICBsZXQgb3V0ZXJJbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBydWxlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKG91dGVySW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb25zdCBvdXRlclJ1bGUgPSBydWxlc1tvdXRlckluZGV4XSxcbiAgICAgICAgICBvdXRlclJ1bGVOYW1lID0gb3V0ZXJSdWxlLmdldE5hbWUoKTtcblxuICAgIGxldCBpbm5lckluZGV4ID0gb3V0ZXJJbmRleCArIDE7XG5cbiAgICB3aGlsZSAoaW5uZXJJbmRleCA8IGxlbmd0aCkge1xuICAgICAgY29uc3QgaW5uZXJSdWxlID0gcnVsZXNbaW5uZXJJbmRleF0sXG4gICAgICAgICAgICBpbm5lclJ1bGVOYW1lID0gaW5uZXJSdWxlLmdldE5hbWUoKTtcblxuICAgICAgaWYgKGlubmVyUnVsZU5hbWUgPT09IG91dGVyUnVsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5uZXJSdWxlRGVmaW5pdGlvbnMgPSBpbm5lclJ1bGUuZ2V0RGVmaW5pdGlvbnMoKSxcbiAgICAgICAgICAgICAgb3V0ZXJSdWxlRGVmaW5pdGlvbnMgPSBvdXRlclJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgICAgICB1bnNoaWZ0KG91dGVyUnVsZURlZmluaXRpb25zLCBpbm5lclJ1bGVEZWZpbml0aW9ucyk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpbm5lckluZGV4LCAvLy9cbiAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgICAgIHJ1bGVzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuXG4gICAgICAgIGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVySW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRlckluZGV4Kys7XG5cbiAgICBsZW5ndGggPSBydWxlcy5sZW5ndGg7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbGV4ZXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBDb21iaW5lZEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXIvY29tYmluZWRcIjtcblxuY29uc3QgeyBsZXhlckZyb21SdWxlcywgcnVsZXNGcm9tRW50cmllcyB9ID0gbGV4ZXJVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXhlckZyb21Ob3RoaW5nKENsYXNzKSB7XG4gIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXG4gICAgICAgIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IENvbWJpbmVkQ3VzdG9tR3JhbW1hci5mcm9tTm90aGluZygpLFxuICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXNBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoZW50cmllcywgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgbGV4ZXIgPSBsZXhlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBsZXhlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxleGVyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcihDbGFzcywgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGxleGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4ZXJGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihDbGFzcywgZW50cmllcywgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGxleGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGxleGVyRnJvbU5vdGhpbmcsXG4gIGxleGVyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgbGV4ZXJGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hclxufTtcblxuZnVuY3Rpb24gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hckVudHJpZXMgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXIuZ2V0RW50cmllcygpO1xuXG4gIGVudHJpZXMgPSBbIC8vL1xuICAgIC4uLmN1c3RvbUdyYW1tYXJFbnRyaWVzLFxuICAgIC4uLmVudHJpZXNcbiAgXTtcblxuICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJzZXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgQ29tYmluZWRDdXN0b21HcmFtbWFyIGZyb20gXCIuLi9jdXN0b21HcmFtbWFyL2NvbWJpbmVkXCI7XG5cbmNvbnN0IHsgcnVsZXNGcm9tQk5GLCBwYXJzZXJGcm9tUnVsZXMsIHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUgfSA9IHBhcnNlclV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21Ob3RoaW5nKENsYXNzKSB7XG4gIGNvbnN0IHsgYm5mIH0gPSBDbGFzcyxcbiAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21Ob3RoaW5nKCksXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21TdGFydFJ1bGVOYW1lKENsYXNzLCBzdGFydFJ1bGVOYW1lKSB7XG4gIGNvbnN0IHsgYm5mIH0gPSBDbGFzcyxcbiAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21Ob3RoaW5nKCksXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tU3RhcnRSdWxlTmFtZUFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihDbGFzcywgc3RhcnRSdWxlTmFtZSwgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHsgYm5mIH0gPSBDbGFzcyxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoYm5mLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXNBbmRTdGFydFJ1bGVOYW1lKENsYXNzLCBydWxlcywgc3RhcnRSdWxlTmFtZSk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21CTkZTdGFydFJ1bGVOYW1lQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBibmYsIHN0YXJ0UnVsZU5hbWUsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUoQ2xhc3MsIHJ1bGVzLCBzdGFydFJ1bGVOYW1lKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHBhcnNlckZyb21Ob3RoaW5nLFxuICBwYXJzZXJGcm9tU3RhcnRSdWxlTmFtZSxcbiAgcGFyc2VyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgcGFyc2VyRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgcGFyc2VyRnJvbVN0YXJ0UnVsZU5hbWVBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIsXG4gIHBhcnNlckZyb21CTkZTdGFydFJ1bGVOYW1lQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyXG59O1xuXG5mdW5jdGlvbiBydWxlc0Zyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoYm5mLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgbGV0IHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZik7XG5cbiAgcnVsZXMgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXIucG9zdFByb2Nlc3MocnVsZXMpO1xuXG4gIHJldHVybiBydWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXJcIjtcbmltcG9ydCBDb21iaW5lZEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXIvY29tYmluZWRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21KU09OKGpzb24pIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hcnNKU09OID0ganNvbiwgIC8vL1xuICAgICAgICBjdXN0b21HcmFtbWFycyA9IGN1c3RvbUdyYW1tYXJzSlNPTi5tYXAoKGN1c3RvbUdyYW1tYXJKU09OKSA9PiB7XG4gICAgICAgICAgY29uc3QganNvbiA9IGN1c3RvbUdyYW1tYXJKU09OLCAvLy9cbiAgICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyID0gQ3VzdG9tR3JhbW1hci5mcm9tSlNPTihqc29uKTtcblxuICAgICAgICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICAgICAgICB9KTtcblxuICBjdXN0b21HcmFtbWFycy5yZXZlcnNlKCk7IC8vXG5cbiAgY29uc3QgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21Ob3RoaW5nKCkge1xuICBjb25zdCBjdXN0b21HcmFtbWFycyA9IFtdLFxuICAgICAgICBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBDb21iaW5lZEN1c3RvbUdyYW1tYXIuZnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKTtcblxuICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSB7XG4gIGN1c3RvbUdyYW1tYXJzID0gWyAgLy8vXG4gICAgLi4uY3VzdG9tR3JhbW1hcnNcbiAgXTtcblxuICBjdXN0b21HcmFtbWFycy5yZXZlcnNlKCk7IC8vL1xuXG4gIGNvbnN0IGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IENvbWJpbmVkQ3VzdG9tR3JhbW1hci5mcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpO1xuXG4gIHJldHVybiBjb21iaW5lZEN1c3RvbUdyYW1tYXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUpTT04sXG4gIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21Ob3RoaW5nLFxuICBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tQ3VzdG9tR3JhbW1hcnNcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IERFRkFVTFRfQ1VTVE9NX0dSQU1NQVJfTkFNRSB9IGZyb20gXCIuL2dyYW1tYXJOYW1lc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHJ1bGVOYW1lcyB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2b2NhYnVsYXJ5TmFtZXMgfSBmcm9tIFwiLi92b2NhYnVsYXJ5TmFtZXNcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBDdXN0b21HcmFtbWFyIH0gZnJvbSBcIi4vY3VzdG9tR3JhbW1hclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZWZhdWx0Q3VzdG9tR3JhbW1hciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXIvZGVmYXVsdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21iaW5lZEN1c3RvbUdyYW1tYXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyL2NvbWJpbmVkXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGV4ZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2xleGVyc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3VzdG9tR3JhbW1hclV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEN1c3RvbUdyYW1tYXIsIGN1c3RvbUdyYW1tYXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tY3VzdG9tLWdyYW1tYXJzXCI7XG5cbmNvbnN0IHsgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUN1c3RvbUdyYW1tYXJzIH0gPSBjdXN0b21HcmFtbWFyVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKSB7XG4gIGNvbnN0IHRlcm1CTkYgPSBlbnRyaWVzLmdldFRlcm1CTkYoKSxcbiAgICAgICAgc3RhdGVtZW50Qk5GID0gZW50cmllcy5nZXRTdGF0ZW1lbnRCTkYoKSxcbiAgICAgICAgdHlwZVZvY2FidWxhcnkgPSBlbnRyaWVzLmdldFR5cGVWb2NhYnVsYXJ5KCksXG4gICAgICAgIHN5bWJvbFZvY2FidWxhcnkgPSBlbnRyaWVzLmdldFN5bWJvbFZvY2FidWxhcnkoKSxcbiAgICAgICAgY3VzdG9tR3JhbW1hciA9IEN1c3RvbUdyYW1tYXIuZnJvbU5hbWVUZXJtQk5GU3RhdGVtZW50Qk5GVHlwZVZvY2FidWxhcnlBbmRTeW1ib2xWb2NhYnVsYXJ5KG5hbWUsIHRlcm1CTkYsIHN0YXRlbWVudEJORiwgdHlwZVZvY2FidWxhcnksIHN5bWJvbFZvY2FidWxhcnkpO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dHMpIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hcnMgPSByZWxlYXNlQ29udGV4dHMubWFwKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGN1c3RvbUdyYW1tYXIgPSByZWxlYXNlQ29udGV4dC5nZXRDdXN0b21HcmFtbWFyKCk7XG5cbiAgICByZXR1cm4gY3VzdG9tR3JhbW1hcjtcbiAgfSk7XG5cbiAgY29uc3QgY29tYmluZWRDdXN0b21HcmFtbWFyID0gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKTtcblxuICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsZUNvbnRleHRzRnJvbUpTT04oanNvbiwgZmlsZUNvbnRleHRzLCByZWxlYXNlQ29udGV4dCwgRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgpIHtcbiAgY29uc3QgZmlsZUNvbnRleHRzSlNPTiA9IGpzb247ICAvLy9cblxuICBmaWxlQ29udGV4dHNKU09OLmZvckVhY2goKGZpbGVDb250ZXh0SlNPTikgPT4ge1xuICAgIGNvbnN0IHsgZmlsZVBhdGggfSA9IGZpbGVDb250ZXh0SlNPTixcbiAgICAgICAgICBGaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgIGlmIChGaWxlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QganNvbiA9IGZpbGVDb250ZXh0SlNPTiwgLy8vXG4gICAgICAgICAgICBmaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0LmZyb21KU09OKGpzb24sIHJlbGVhc2VDb250ZXh0KTtcblxuICAgICAgZmlsZUNvbnRleHRzLnB1c2goZmlsZUNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlQ29udGV4dHNGcm9tRW50cmllcyhlbnRyaWVzLCBmaWxlQ29udGV4dHMsIHJlbGVhc2VDb250ZXh0LCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCkge1xuICBlbnRyaWVzLmZvckVhY2hGaWxlKChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBGaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgIGlmIChGaWxlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZmlsZUNvbnRleHQgPSBGaWxlQ29udGV4dC5mcm9tRmlsZShmaWxlLCByZWxlYXNlQ29udGV4dCk7XG5cbiAgICAgIGZpbGVDb250ZXh0cy5wdXNoKGZpbGVDb250ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpbGVDb250ZXh0c0Zyb21KU09OLFxuICBmaWxlQ29udGV4dHNGcm9tRW50cmllc1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IHZlcmlmeVR5cGVQcmVmaXhlcywgdmVyaWZ5RmlsZUNvbnRleHRzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy92ZXJpZnlcIjtcbmltcG9ydCB7IGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21SZWxlYXNlQ29udGV4dHMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2N1c3RvbUdyYW1tYXJcIjtcbmltcG9ydCB7IGZpbGVDb250ZXh0c0Zyb21KU09OLCBmaWxlQ29udGV4dHNGcm9tRW50cmllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvZmlsZUNvbnRleHRcIjtcbmltcG9ydCB7IFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwsIEJSRUFLX01FU1NBR0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgcHVzaCwgdGFpbCwgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxlYXNlQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIsIHZlcmlmaWVzLCBpbml0aWFsaXNlZCwgZmlsZUNvbnRleHRzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIsIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMpIHtcbiAgICB0aGlzLmxvZyA9IGxvZztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hcjtcbiAgICB0aGlzLnZlcmlmaWVzID0gdmVyaWZpZXM7XG4gICAgdGhpcy5pbml0aWFsaXNlZCA9IGluaXRpYWxpc2VkO1xuICAgIHRoaXMuZmlsZUNvbnRleHRzID0gZmlsZUNvbnRleHRzO1xuICAgIHRoaXMuY29tYmluZWRDdXN0b21HcmFtbWFyID0gY29tYmluZWRDdXN0b21HcmFtbWFyO1xuICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyA9IGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHM7XG4gIH1cblxuICBnZXRMb2coKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0SlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5qc29uO1xuICB9XG5cbiAgZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzO1xuICB9XG5cbiAgZ2V0Q2FsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2s7XG4gIH1cblxuICBnZXRDdXN0b21HcmFtbWFyKCkge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbUdyYW1tYXI7XG4gIH1cblxuICBnZXRWZXJpZmllcygpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZmllcztcbiAgfVxuXG4gIGlzSW5pdGlhbGlzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGlzZWQ7XG4gIH1cblxuICBnZXRGaWxlQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZUNvbnRleHRzO1xuICB9XG5cbiAgZ2V0Q29tYmluZWRDdXN0b21HcmFtbWFyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIGdldERlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cztcbiAgfVxuXG4gIGdldFJlbGVhc2VDb250ZXh0KCkge1xuICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0ID0gdGhpczsgIC8vL1xuXG4gICAgcmV0dXJuIHJlbGVhc2VDb250ZXh0O1xuICB9XG5cbiAgZ2V0RGVwdGgoKSB7XG4gICAgY29uc3QgZGVwdGggPSAwO1xuXG4gICAgcmV0dXJuIGRlcHRoO1xuICB9XG5cbiAgaGFzVmVyaWZpZWQoKSB7XG4gICAgY29uc3QgdmVyaWZpZWQgPSB0aGlzLnZlcmlmaWVzOyAvLy9cblxuICAgIHJldHVybiB2ZXJpZmllZDtcbiAgfVxuXG4gIGlzUmVsZWFzZWQoKSB7XG4gICAgY29uc3QgcmVsZWFzZWQgPSAodGhpcy5qc29uICE9PSBudWxsKTtcblxuICAgIHJldHVybiByZWxlYXNlZDtcbiAgfVxuXG4gIGdldFR5cGVQcmVmaXgoKSB7XG4gICAgbGV0IHR5cGVQcmVmaXggPSBudWxsO1xuXG4gICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgIHR5cGVQcmVmaXhlcyA9IHRoaXMuZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpLFxuICAgICAgICAgIHR5cGVQcmVmaXhlc0xlbmd0aCA9IHR5cGVQcmVmaXhlcy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZVByZWZpeGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBmaXJzdFR5cGVQcmVmaXggPSBmaXJzdCh0eXBlUHJlZml4ZXMpO1xuXG4gICAgICB0eXBlUHJlZml4ID0gZmlyc3RUeXBlUHJlZml4OyAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZVByZWZpeDtcbiAgfVxuXG4gIGdldExhYmVscyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dExhYmVscyA9IGZpbGVDb250ZXh0LmdldExhYmVscyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2gobGFiZWxzLCBmaWxlQ29udGV4dExhYmVscyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRMYWJlbHMgPSByZWxlYXNlQ29udGV4dC5nZXRMYWJlbHMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChsYWJlbHMsIHJlbGVhc2VDb250ZXh0TGFiZWxzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH1cblxuICBnZXRUeXBlcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHR5cGVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0VHlwZXMgPSBmaWxlQ29udGV4dC5nZXRUeXBlcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2godHlwZXMsIGZpbGVDb250ZXh0VHlwZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0VHlwZXMgPSByZWxlYXNlQ29udGV4dC5nZXRUeXBlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKHR5cGVzLCByZWxlYXNlQ29udGV4dFR5cGVzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlcztcbiAgfVxuXG4gIGdldFJ1bGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgcnVsZXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRSdWxlcyA9IGZpbGVDb250ZXh0LmdldFJ1bGVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChydWxlcywgZmlsZUNvbnRleHRSdWxlcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRSdWxlcyA9IHJlbGVhc2VDb250ZXh0LmdldFJ1bGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2gocnVsZXMsIHJlbGVhc2VDb250ZXh0UnVsZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgZ2V0QXhpb21zKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgYXhpb21zID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0QXhpb21zID0gZmlsZUNvbnRleHQuZ2V0QXhpb21zKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChheGlvbXMsIGZpbGVDb250ZXh0QXhpb21zKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dEF4aW9tcyA9IHJlbGVhc2VDb250ZXh0LmdldEF4aW9tcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKGF4aW9tcywgcmVsZWFzZUNvbnRleHRBeGlvbXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF4aW9tcztcbiAgfVxuXG4gIGdldExlbW1hcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxlbW1hcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dExlbW1hcyA9IGZpbGVDb250ZXh0LmdldExlbW1hcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2gobGVtbWFzLCBmaWxlQ29udGV4dExlbW1hcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGVtbWFzO1xuICB9XG5cbiAgZ2V0VGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCB0aGVvcmVtcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dFRoZW9yZW1zID0gZmlsZUNvbnRleHQuZ2V0VGhlb3JlbXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKHRoZW9yZW1zLCBmaWxlQ29udGV4dFRoZW9yZW1zKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFRoZW9yZW1zID0gcmVsZWFzZUNvbnRleHQuZ2V0VGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaCh0aGVvcmVtcywgcmVsZWFzZUNvbnRleHRUaGVvcmVtcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhlb3JlbXM7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dFByb2NlZHVyZXMgPSBmaWxlQ29udGV4dC5nZXRQcm9jZWR1cmVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChwcm9jZWR1cmVzLCBmaWxlQ29udGV4dFByb2NlZHVyZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0UHJvY2VkdXJlcyA9IHJlbGVhc2VDb250ZXh0LmdldFByb2NlZHVyZXMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChwcm9jZWR1cmVzLCByZWxlYXNlQ29udGV4dFByb2NlZHVyZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2NlZHVyZXM7XG4gIH1cblxuICBnZXRNZXRhTGVtbWFzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YUxlbW1hcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dE1ldGFMZW1tYXMgPSBmaWxlQ29udGV4dC5nZXRNZXRhTGVtbWFzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChtZXRhTGVtbWFzLCBmaWxlQ29udGV4dE1ldGFMZW1tYXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1ldGFMZW1tYXM7XG4gIH1cblxuICBnZXRDb25qZWN0dXJlcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbmplY3R1cmVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0Q29uamVjdHVyZXMgPSBmaWxlQ29udGV4dC5nZXRDb25qZWN0dXJlcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2goY29uamVjdHVyZXMsIGZpbGVDb250ZXh0Q29uamVjdHVyZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0Q29uamVjdHVyZXMgPSByZWxlYXNlQ29udGV4dC5nZXRDb25qZWN0dXJlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKGNvbmplY3R1cmVzLCByZWxlYXNlQ29udGV4dENvbmplY3R1cmVzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb25qZWN0dXJlcztcbiAgfVxuXG4gIGdldENvbWJpbmF0b3JzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgY29tYmluYXRvcnMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRDb21iaW5hdG9ycyA9IGZpbGVDb250ZXh0LmdldENvbWJpbmF0b3JzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChjb21iaW5hdG9ycywgZmlsZUNvbnRleHRDb21iaW5hdG9ycyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRDb21iaW5hdG9ycyA9IHJlbGVhc2VDb250ZXh0LmdldENvbWJpbmF0b3JzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2goY29tYmluYXRvcnMsIHJlbGVhc2VDb250ZXh0Q29tYmluYXRvcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmF0b3JzO1xuICB9XG5cbiAgZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgdHlwZVByZWZpeGVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0VHlwZVByZWZpeGVzID0gZmlsZUNvbnRleHQuZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaCh0eXBlUHJlZml4ZXMsIGZpbGVDb250ZXh0VHlwZVByZWZpeGVzKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFR5cGVQcmVmaXhlcyA9IHJlbGVhc2VDb250ZXh0LmdldFR5cGVQcmVmaXhlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKHR5cGVQcmVmaXhlcywgcmVsZWFzZUNvbnRleHRUeXBlUHJlZml4ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVQcmVmaXhlcztcbiAgfVxuXG4gIGdldENvbnN0cnVjdG9ycyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9ycyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dENvbnN0cnVjdG9ycyA9IGZpbGVDb250ZXh0LmdldENvbnN0cnVjdG9ycyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2goY29uc3RydWN0b3JzLCBmaWxlQ29udGV4dENvbnN0cnVjdG9ycyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRDb25zdHJ1Y3RvcnMgPSByZWxlYXNlQ29udGV4dC5nZXRDb25zdHJ1Y3RvcnMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChjb25zdHJ1Y3RvcnMsIHJlbGVhc2VDb250ZXh0Q29uc3RydWN0b3JzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zdHJ1Y3RvcnM7XG4gIH1cblxuICBnZXRNZXRhdGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhdGhlb3JlbXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRNZXRhdGhlb3JlbXMgPSBmaWxlQ29udGV4dC5nZXRNZXRhdGhlb3JlbXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKG1ldGF0aGVvcmVtcywgZmlsZUNvbnRleHRNZXRhdGhlb3JlbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0TWV0YXRoZW9yZW1zID0gcmVsZWFzZUNvbnRleHQuZ2V0TWV0YXRoZW9yZW1zKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2gobWV0YXRoZW9yZW1zLCByZWxlYXNlQ29udGV4dE1ldGF0aGVvcmVtcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YXRoZW9yZW1zO1xuICB9XG5cbiAgZ2V0RGVwZW5kZW5jaWVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldERlcGVuZGVuY2llcygpOyB9XG5cbiAgbWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pIHsgcmV0dXJuIHRoaXMuZW50cmllcy5tYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbik7IH1cblxuICBmaW5kRmlsZShmaWxlUGF0aCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmZpbmRGaWxlKGZpbGVQYXRoKTsgfVxuXG4gIGZpbmRGaWxlQ29udGV4dChmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVDb250ZXh0ID0gdGhpcy5maWxlQ29udGV4dHMuZmluZCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoTWF0Y2hlcyA9IGZpbGVDb250ZXh0Lm1hdGNoRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgICBpZiAoZmlsZVBhdGhNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gZmlsZUNvbnRleHQ7XG4gIH1cblxuICB0cmFjZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBUUkFDRV9MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBERUJVR19MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBpbmZvKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IElORk9fTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd2FybmluZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBXQVJOSU5HX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IEVSUk9SX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHdyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoID0gbnVsbCwgbGluZUluZGV4ID0gbnVsbCkge1xuICAgIHRoaXMubG9nLndyaXRlKGxldmVsLCBtZXNzYWdlLCBmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGluaXRpYWxpc2UocmVsZWFzZUNvbnRleHRzLCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCkge1xuICAgIGNvbnN0IHJlbGVhc2VkID0gdGhpcy5pc1JlbGVhc2VkKCksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLCAgLy8vXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHRzVGFpbCA9IHRhaWwocmVsZWFzZUNvbnRleHRzKTtcblxuICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyA9IHJlbGVhc2VDb250ZXh0c1RhaWw7IC8vL1xuXG4gICAgdGhpcy5jb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tUmVsZWFzZUNvbnRleHRzKHJlbGVhc2VDb250ZXh0cyk7XG5cbiAgICByZWxlYXNlZCA/XG4gICAgICBmaWxlQ29udGV4dHNGcm9tSlNPTih0aGlzLmpzb24sIHRoaXMuZmlsZUNvbnRleHRzLCByZWxlYXNlQ29udGV4dCwgRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgpIDpcbiAgICAgICAgZmlsZUNvbnRleHRzRnJvbUVudHJpZXModGhpcy5lbnRyaWVzLCB0aGlzLmZpbGVDb250ZXh0cywgcmVsZWFzZUNvbnRleHQsIEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKTtcblxuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsoZmlsZVBhdGgsIGxpbmVJbmRleCkge1xuICAgIGNvbnN0IGxldmVsID0gVFJBQ0VfTEVWRUwsXG4gICAgICAgICAgbWVzc2FnZSA9IEJSRUFLX01FU1NBR0U7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7IC8vL1xuXG4gICAgYXdhaXQgdGhpcy5jYWxsYmFjayhjb250ZXh0LCBmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSgpIHtcbiAgICBsZXQgdmVyaWZpZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IHR5cGVQcmVmaXhlcyA9IHRoaXMuZ2V0VHlwZVByZWZpeGVzKCksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLCAvLy9cbiAgICAgICAgICB0eXBlUHJlZml4ZXNWZXJpZnkgPSB2ZXJpZnlUeXBlUHJlZml4ZXModHlwZVByZWZpeGVzLCByZWxlYXNlQ29udGV4dCk7XG5cbiAgICBpZiAodHlwZVByZWZpeGVzVmVyaWZ5KSB7XG4gICAgICBjb25zdCB2ZXJpZmllZEZpbGVDb250ZXh0cyA9IFtdLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRzVmVyaWZ5ID0gYXdhaXQgdmVyaWZ5RmlsZUNvbnRleHRzKHRoaXMuZmlsZUNvbnRleHRzLCB2ZXJpZmllZEZpbGVDb250ZXh0cyk7XG5cbiAgICAgIGlmIChmaWxlQ29udGV4dHNWZXJpZnkpIHtcbiAgICAgICAgdmVyaWZpZXMgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMudmVyaWZpZXMgPSB2ZXJpZmllcztcblxuICAgICAgICB0aGlzLmZpbGVDb250ZXh0cyA9IHZlcmlmaWVkRmlsZUNvbnRleHRzOyAvLy9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZpZXM7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZmlsZUNvbnRleHRzSlNPTiA9IHRoaXMuZmlsZUNvbnRleHRzLm1hcCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZXh0SlNPTiA9IGZpbGVDb250ZXh0LnRvSlNPTigpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRleHRKU09OO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGpzb24gPSBmaWxlQ29udGV4dHNKU09OOyAgLy8vXG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTG9nTmFtZUpTT05FbnRyaWVzQ2FsbGJhY2tBbmRDdXN0b21HcmFtbWFyKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIpIHtcbiAgICBjb25zdCB2ZXJpZmllcyA9IGZhbHNlLFxuICAgICAgICAgIGluaXRpYWxpc2VkID0gZmFsc2UsXG4gICAgICAgICAgZmlsZUNvbnRleHRzID0gW10sXG4gICAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gbnVsbCxcbiAgICAgICAgICBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzID0gbnVsbCxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IG5ldyBSZWxlYXNlQ29udGV4dChsb2csIG5hbWUsIGpzb24sIGVudHJpZXMsIGNhbGxiYWNrLCBjdXN0b21HcmFtbWFyLCB2ZXJpZmllcywgaW5pdGlhbGlzZWQsIGZpbGVDb250ZXh0cywgY29tYmluZWRDdXN0b21HcmFtbWFyLCBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzKTtcblxuICAgIHJldHVybiByZWxlYXNlQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIGFzIE5vblRlcm1pbmFsTm9kZUJhc2UgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uVGVybWluYWxOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlQmFzZSB7XG4gIHNvbWVUZXJtaW5hbE5vZGUoY2FsbGJhY2ssIHRva2VuVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZVRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHRlcm1pbmFsTm9kZVR5cGUgPSB0ZXJtaW5hbE5vZGUuZ2V0VHlwZSgpO1xuXG4gICAgICAgIGlmICh0ZXJtaW5hbE5vZGVUeXBlID09PSB0b2tlblR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGVybWluYWxOb2RlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldE5vZGVCeVJ1bGVOYW1lKC4uLnJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmRDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldE5vZGVzQnlSdWxlTmFtZSguLi5ydWxlTmFtZXMpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZmlsdGVyQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGdldExhc3ROb2RlQnlSdWxlTmFtZSguLi5ydWxlTmFtZXMpIHtcbiAgICBsZXQgbGFzdE5vZGUgPSBudWxsO1xuXG4gICAgdGhpcy5iYWNrd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXN0Tm9kZTtcbiAgfVxuXG4gIGdldEZpcnN0Tm9kZUJ5UnVsZU5hbWUoLi4ucnVsZU5hbWVzKSB7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IG51bGw7XG5cbiAgICB0aGlzLmZvcndhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAocnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgIGZpcnN0Tm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpcnN0Tm9kZTtcbiAgfVxuXG4gIGdldFNpbmd1bGFyTm9kZUJ5UnVsZU5hbWUoLi4ucnVsZU5hbWVzKSB7XG4gICAgbGV0IHNpbmd1bGFyTm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZmlsdGVyQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChub2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3Qobm9kZXMpO1xuXG4gICAgICBzaW5ndWxhck5vZGUgPSBmaXJzdE5vZGU7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBzaW5ndWxhck5vZGU7XG4gIH1cblxuICBnZXREZXNjZW5kYW50Tm9kZXNCeVJ1bGVOYW1lKC4uLnJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5maWx0ZXJEZXNjZW5kYW50Tm9kZSgoZGVzY2VuZGFudE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NlbmRhbnROb2RlTm9uVGVybWluYWxOb2RlID0gZGVzY2VuZGFudE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgaWYgKGRlc2NlbmRhbnROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGRlc2NlbmRhbnROb2RlLCAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZUJhc2UuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICBub2RlID0gbm9kZXMuc2hpZnQoKSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZXNRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbm9kZVF1ZXJ5LFxuICBub2Rlc1F1ZXJ5LFxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgbm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuXG5jb25zdCB7IG1hdGNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGNvbnN0IG5vblRlcm1pbmFsTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiLypcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMobm9kZXMpIHtcbiAgY29uc3QgdGVybWluYWxOb2RlTWFwID0ge307XG5cbiAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvL1xuXG4gICAgICB0ZXJtaW5hbE5vZGVNYXBbaW5kZXhdID0gdGVybWluYWxOb2RlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1pbmFsTm9kZU1hcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbChnZW5lcmFsVGVybWluYWxOb2RlTWFwLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZU1hcCkge1xuICBsZXQgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gZmFsc2U7XG5cbiAgY29uc3QgZ2VuZXJhbEluZGV4ZXMgPSBPYmplY3Qua2V5cyhnZW5lcmFsVGVybWluYWxOb2RlTWFwKSwgLy8vXG4gICAgICAgIHNwZWNpZmljSW5kZXhlcyA9IE9iamVjdC5rZXlzKHNwZWNpZmljVGVybWluYWxOb2RlTWFwKSwgLy8vXG4gICAgICAgIHRlcm1pbmFsTm9kZU1hcEtleXNNYXRjaCA9IG1hdGNoKGdlbmVyYWxJbmRleGVzLCBzcGVjaWZpY0luZGV4ZXMsIChnZW5lcmFsSW5kZXgsIHNwZWNpZmljSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoZ2VuZXJhbEluZGV4ID09PSBzcGVjaWZpY0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIGlmICh0ZXJtaW5hbE5vZGVNYXBLZXlzTWF0Y2gpIHtcbiAgICBjb25zdCBnZW5lcmFsVGVybWluYWxOb2RlcyA9IE9iamVjdC52YWx1ZXMoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCksIC8vL1xuICAgICAgICAgIHNwZWNpZmljVGVybWluYWxOb2RlcyA9IE9iamVjdC52YWx1ZXMoc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXApLCAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVNYXBWYWx1ZXNNYXRjaCA9IG1hdGNoKGdlbmVyYWxUZXJtaW5hbE5vZGVzLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZXMsIChnZW5lcmFsVGVybWluYWxOb2RlLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhbFRlcm1pbmFsTm9kZU1hdGNoZXNTcGVjaWZpY1Rlcm1pbmFsTm9kZSA9IGdlbmVyYWxUZXJtaW5hbE5vZGUubWF0Y2goc3BlY2lmaWNUZXJtaW5hbE5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hdGNoZXNTcGVjaWZpY1Rlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgIHRlcm1pbmFsTm9kZU1hcHNFcXVhbCA9IHRlcm1pbmFsTm9kZU1hcFZhbHVlc01hdGNoOyAvLy9cbiAgfVxuXG4gIHJldHVybiB0ZXJtaW5hbE5vZGVNYXBzRXF1YWw7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LCB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMsIGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaaXBQYXNzIHtcbiAgcnVuKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBzdWNjZXNzO1xuXG4gICAgY29uc3QgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICBzdWNjZXNzID0gdmlzaXRlZDsgIC8vL1xuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cblxuICBkZXNjZW5kKGdlbmVyYWxDaGlsZE5vZGVzLCBzcGVjaWZpY0NoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBkZXNjZW5kZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGdlbmVyYWxDaGlsZE5vZGVzTGVuZ3RoID0gZ2VuZXJhbENoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgIHNwZWNpZmljQ2hpbGROb2Rlc0xlbmd0aCA9IHNwZWNpZmljQ2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoZ2VuZXJhbENoaWxkTm9kZXNMZW5ndGggPT09IHNwZWNpZmljQ2hpbGROb2Rlc0xlbmd0aCkge1xuICAgICAgY29uc3Qgc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMoc3BlY2lmaWNDaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIGdlbmVyYWxUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMoZ2VuZXJhbENoaWxkTm9kZXMpLFxuICAgICAgICAgICAgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gYXJlVGVybWluYWxOb2RlTWFwc0VxdWFsKGdlbmVyYWxUZXJtaW5hbE5vZGVNYXAsIHNwZWNpZmljVGVybWluYWxOb2RlTWFwKTtcblxuICAgICAgaWYgKHRlcm1pbmFsTm9kZU1hcHNFcXVhbCkge1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gZ2VuZXJhbENoaWxkTm9kZXMuZXZlcnkoKGdlbmVyYWxDaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWNDaGlsZE5vZGUgPSBzcGVjaWZpY0NoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIHNwZWNpZmljTm9kZSA9IHNwZWNpZmljQ2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICBnZW5lcmFsTm9kZSA9IGdlbmVyYWxDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShnZW5lcmFsTm9kZSwgc3BlY2lmaWNOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgICBkZXNjZW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NlbmRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShnZW5lcmFsTm9kZSwgc3BlY2lmaWNOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgZ2VuZXJhbE5vZGVUZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHNwZWNpZmljTm9kZVRlcm1pbmFsTm9kZSA9IHNwZWNpZmljTm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIGdlbmVyYWxOb2RlTm9uVGVybWluYWxOb2RlID0gZ2VuZXJhbE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgICBzcGVjaWZpY05vZGVOb25UZXJtaW5hbE5vZGUgPSBzcGVjaWZpY05vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmIChnZW5lcmFsTm9kZVRlcm1pbmFsTm9kZSAmJiBzcGVjaWZpY05vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGdlbmVyYWxUZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZSwgIC8vL1xuICAgICAgICAgICAgc3BlY2lmaWNUZXJtaW5hbE5vZGUgPSBzcGVjaWZpY05vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUoZ2VuZXJhbFRlcm1pbmFsTm9kZSwgc3BlY2lmaWNUZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChnZW5lcmFsTm9kZU5vblRlcm1pbmFsTm9kZSAmJiBzcGVjaWZpY05vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGdlbmVyYWxOb25UZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZSwgIC8vL1xuICAgICAgICAgICAgc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUgPSBzcGVjaWZpY05vZGU7IC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShnZW5lcmFsTm9uVGVybWluYWxOb2RlLCBzcGVjaWZpY05vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0VGVybWluYWxOb2RlKGdlbmVyYWxUZXJtaW5hbE5vZGUsIHNwZWNpZmljVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgLy8vXG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICB2aXNpdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUoZ2VuZXJhbE5vblRlcm1pbmFsTm9kZSwgc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBnZW5lcmFsTm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgc3BlY2lmaWNOb2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IChnZW5lcmFsTm9kZSwgc3BlY2lmaWNOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgZ2VuZXJhbE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gZ2VuZXJhbE5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLCAvLy9cbiAgICAgICAgICAgICAgICBzcGVjaWZpY05vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTsgLy8vXG5cbiAgICAgICAgICBpZiAoZ2VuZXJhbE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBzcGVjaWZpY05vblRlcm1pbmFsTm9kZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmFsTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcyA9IGdlbmVyYWxOb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgc3BlY2lmaWNOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgZ2VuZXJhbENoaWxkTm9kZXMgPSBnZW5lcmFsTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgICAgICBzcGVjaWZpY0NoaWxkTm9kZXMgPSBzcGVjaWZpY05vblRlcm1pbmFsTm9kZUNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGdlbmVyYWxDaGlsZE5vZGVzLCBzcGVjaWZpY0NoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChkZXNjZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBtYXBzLnNvbWUoKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBnZW5lcmFsTm9kZVF1ZXJ5LCBzcGVjaWZpY05vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IGdlbmVyYWxOb2RlID0gZ2VuZXJhbE5vZGVRdWVyeShnZW5lcmFsTm9uVGVybWluYWxOb2RlKSwgIC8vL1xuICAgICAgICAgICAgc3BlY2lmaWNOb2RlID0gc3BlY2lmaWNOb2RlUXVlcnkoc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUpOyAgLy8vXG5cbiAgICAgIGlmICgoZ2VuZXJhbE5vZGUgIT09IG51bGwpICYmIChzcGVjaWZpY05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgID0gcnVuKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgdmlzaXRlZCA9IHN1Y2Nlc3M7ICAvLy9cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vblRlcm1pbmFsTm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXNzXCI7XG5pbXBvcnQgeyBhc3luY1NvbWUsIGFzeW5jRXZlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc3luY1Bhc3Mge1xuICBhc3luYyBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gYXdhaXQgdGhpcy52aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGFzeW5jIGRlc2NlbmQoY2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlc2NlbmRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgdmlzaXRlZCA9IGF3YWl0IGFzeW5jRXZlcnkoY2hpbGROb2RlcywgYXN5bmMgKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICB2aXNpdGVkID0gYXdhaXQgdGhpcy52aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodmlzaXRlZCkge1xuICAgICAgZGVzY2VuZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY2VuZGVkO1xuICB9XG5cbiAgYXN5bmMgdmlzaXROb2RlKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlOyAgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSBhd2FpdCB0aGlzLnZpc2l0VGVybWluYWxOb2RlKHRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gYXdhaXQgdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICBhc3luYyB2aXNpdFRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGNvbnN0IHZpc2l0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICBhc3luYyB2aXNpdE5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBub2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IGFzeW5jIChub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksIC8vL1xuICAgICAgICAgICAgICAgIGRlc2NlbmRlZCA9IGF3YWl0IHRoaXMuZGVzY2VuZChjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKGRlc2NlbmRlZCkge1xuICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBhd2FpdCBhc3luY1NvbWUobWFwcywgYXN5bmMgKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBub2RlUXVlcnksIHJ1biB9ID0gbWFwO1xuXG4gICAgICBjb25zdCBub2RlID0gbm9kZVF1ZXJ5KG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzczsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Bhc3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlUGFzcyB7XG4gIHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgc3VjY2VzcztcblxuICAgIGNvbnN0IHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgc3VjY2VzcyA9IHZpc2l0ZWQ7ICAvLy9cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG5cbiAgZGVzY2VuZChjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgZGVzY2VuZGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gY2hpbGROb2Rlcy5ldmVyeSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh2aXNpdGVkKSB7XG4gICAgICBkZXNjZW5kZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjZW5kZWQ7XG4gIH1cblxuICB2aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUodGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlOyAgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0VGVybWluYWxOb2RlKHRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgdmlzaXRlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIGxldCB7IG1hcHMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBtYXBzID0gWyAvLy9cbiAgICAgIC4uLm1hcHMsXG4gICAgICB7XG4gICAgICAgIG5vZGVRdWVyeTogbm9uVGVybWluYWxOb2RlUXVlcnksXG4gICAgICAgIHJ1bjogKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgPT4ge1xuICAgICAgICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSwgLy8vXG4gICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAoZGVzY2VuZGVkKSB7XG4gICAgICAgICAgICB2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlzaXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cblxuICAgIG1hcHMuc29tZSgobWFwKSA9PiB7XG4gICAgICBjb25zdCB7IG5vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlUXVlcnkobm9uVGVybWluYWxOb2RlKTtcblxuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgIHZpc2l0ZWQgPSBzdWNjZXNzO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Bhc3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9yd2FyZFBhc3Mge1xuICBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gdGhpcy52aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGRlc2NlbmQoaW5kZXgsIGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBkZXNjZW5kZWRGb3J3YXJkID0gZmFsc2U7XG5cbiAgICBjb25zdCBkZXNjZW5kRm9yd2FyZCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKSwgLy8vXG4gICAgICAgICAgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKGluZGV4ID09PSBjaGlsZE5vZGVzTGVuZ3RoKSB7XG4gICAgICBkZXNjZW5kZWRGb3J3YXJkID0gZGVzY2VuZEZvcndhcmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgICBub2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzLnB1c2goZGVzY2VuZEZvcndhcmQpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGFoZWFkSW5kZXggPSBpbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRlZEZvcndhcmQgPSB0aGlzLmRlc2NlbmQoYWhlYWRJbmRleCwgY2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZGVzY2VuZGVkRm9yd2FyZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICBkZXNjZW5kZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY2VuZGVkRm9yd2FyZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZDtcblxuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdFRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXRUZXJtaW5hbE5vZGUodGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgZGVzY2VuZEZvcndhcmQgPSByZW1haW5pbmdBcmd1bWVudHMucG9wKCksIC8vL1xuICAgICAgICAgIGRlc2NlbmRlZEZvcndhcmQgPSBkZXNjZW5kRm9yd2FyZCgpO1xuXG4gICAgaWYgKGRlc2NlbmRlZEZvcndhcmQpIHtcbiAgICAgIHZpc2l0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlbWFpbmluZ0FyZ3VtZW50cy5wdXNoKGRlc2NlbmRGb3J3YXJkKTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgbGV0IHsgbWFwcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgIG1hcHMgPSBbIC8vL1xuICAgICAgLi4ubWFwcyxcbiAgICAgIHtcbiAgICAgICAgbm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgcnVuOiAobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSA9PiB7XG4gICAgICAgICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSwgLy8vXG4gICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGluZGV4LCBjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKGRlc2NlbmRlZCkge1xuICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBtYXBzLnNvbWUoKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBub2RlUXVlcnksIHJ1biB9ID0gbWFwO1xuXG4gICAgICBjb25zdCBub2RlID0gbm9kZVF1ZXJ5KG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzcztcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LCB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMsIGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcXVpdmFsZW5jZVBhc3Mge1xuICBydW4obGVmdE5vZGUsIHJpZ2h0Tm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gdGhpcy52aXNpdE5vZGUobGVmdE5vZGUsIHJpZ2h0Tm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGRlc2NlbmQobGVmdENoaWxkTm9kZXMsIHJpZ2h0Q2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlc2NlbmRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgbGVmdENoaWxkTm9kZXNMZW5ndGggPSBsZWZ0Q2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICByaWdodENoaWxkTm9kZXNMZW5ndGggPSByaWdodENoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlZnRDaGlsZE5vZGVzTGVuZ3RoID09PSByaWdodENoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxlZnRUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMobGVmdENoaWxkTm9kZXMpLFxuICAgICAgICAgICAgcmlnaHRUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMocmlnaHRDaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZU1hcHNFcXVhbCA9IGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbChsZWZ0VGVybWluYWxOb2RlTWFwLCByaWdodFRlcm1pbmFsTm9kZU1hcCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVNYXBzRXF1YWwpIHtcbiAgICAgICAgZGVzY2VuZGVkID0gbGVmdENoaWxkTm9kZXMuZXZlcnkoKGxlZnRDaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmlnaHRDaGlsZE5vZGUgPSByaWdodENoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxlZnROb2RlID0gbGVmdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHRDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NlbmRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgbGVmdE5vZGVUZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHJpZ2h0Tm9kZVRlcm1pbmFsTm9kZSA9IHJpZ2h0Tm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIGxlZnROb2RlTm9uVGVybWluYWxOb2RlID0gbGVmdE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgICByaWdodE5vZGVOb25UZXJtaW5hbE5vZGUgPSByaWdodE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmIChsZWZ0Tm9kZVRlcm1pbmFsTm9kZSAmJiByaWdodE5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGxlZnRUZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZSwgIC8vL1xuICAgICAgICAgICAgcmlnaHRUZXJtaW5hbE5vZGUgPSByaWdodE5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUobGVmdFRlcm1pbmFsTm9kZSwgcmlnaHRUZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChsZWZ0Tm9kZU5vblRlcm1pbmFsTm9kZSAmJiByaWdodE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGxlZnROb25UZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZSwgIC8vL1xuICAgICAgICAgICAgcmlnaHROb25UZXJtaW5hbE5vZGUgPSByaWdodE5vZGU7IC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShsZWZ0Tm9uVGVybWluYWxOb2RlLCByaWdodE5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0VGVybWluYWxOb2RlKGxlZnRUZXJtaW5hbE5vZGUsIHJpZ2h0VGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgLy8vXG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICB2aXNpdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUobGVmdE5vblRlcm1pbmFsTm9kZSwgcmlnaHROb25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBsZWZ0Tm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgcmlnaHROb2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IChsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgbGVmdE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbGVmdE5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLCAvLy9cbiAgICAgICAgICAgICAgICByaWdodE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gcmlnaHROb25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTsgLy8vXG5cbiAgICAgICAgICBpZiAobGVmdE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSByaWdodE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0Tm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcyA9IGxlZnROb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgcmlnaHROb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gcmlnaHROb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgbGVmdENoaWxkTm9kZXMgPSBsZWZ0Tm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgICAgICByaWdodENoaWxkTm9kZXMgPSByaWdodE5vblRlcm1pbmFsTm9kZUNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGxlZnRDaGlsZE5vZGVzLCByaWdodENoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChkZXNjZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBtYXBzLnNvbWUoKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBsZWZ0Tm9kZVF1ZXJ5LCByaWdodE5vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IGxlZnROb2RlID0gbGVmdE5vZGVRdWVyeShsZWZ0Tm9uVGVybWluYWxOb2RlKSwgIC8vL1xuICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHROb2RlUXVlcnkocmlnaHROb25UZXJtaW5hbE5vZGUpOyAgLy8vXG5cbiAgICAgIGlmICgobGVmdE5vZGUgIT09IG51bGwpICYmIChyaWdodE5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBydW4obGVmdE5vZGUsIHJpZ2h0Tm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzczsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXN5bmNFdmVyeSAgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNFdmVyeURlcGVuZGVuY3koZGVwZW5kZW5jaWVzLCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheSA9IGRlcGVuZGVuY2llcy5nZXRBcnJheSgpO1xuXG4gIHJldHVybiBhd2FpdCBhc3luY0V2ZXJ5KGFycmF5LCBjYWxsYmFjayk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBhc3luY0V2ZXJ5RGVwZW5kZW5jeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvZGVwZW5kZW5jeVwiO1xuXG5jb25zdCB7IGxhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGlzZVJlbGVhc2VDb250ZXh0KGRlcGVuZGVuY3ksIGNvbnRleHQpIHtcbiAgY29uc3QgeyBsb2csIHJlbGVhc2VDb250ZXh0TWFwIH0gPSBjb250ZXh0LFxuICAgICAgICBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICByZWxlYXNlTmFtZSA9IGRlcGVuZGVuY3lOYW1lLCAvLy9cbiAgICAgICAgcmVsZWFzZUNvbnRleHQgPSByZWxlYXNlQ29udGV4dE1hcFtyZWxlYXNlTmFtZV0gfHwgbnVsbDtcblxuICBpZiAocmVsZWFzZUNvbnRleHQgPT09IG51bGwpIHtcbiAgICBsb2cud2FybmluZyhgVW5hYmxlIHRvIGluaXRpYWxpc2UgdGhlICcke2RlcGVuZGVuY3lOYW1lfScgY29udGV4dCBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiBjcmVhdGVkLmApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0SW5pdGlhbGlzZWQgPSByZWxlYXNlQ29udGV4dC5pc0luaXRpYWxpc2VkKCk7XG5cbiAgICBpZiAoIXJlbGVhc2VDb250ZXh0SW5pdGlhbGlzZWQpIHtcbiAgICAgIGluaXRpYWxpc2VEZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzKGRlcGVuZGVuY3ksIHJlbGVhc2VDb250ZXh0LCBjb250ZXh0KTtcblxuICAgICAgY29uc3QgcmVsZWFzZUNvbnRleHRzID0gcmV0cmlldmVSZWxlYXNlQ29udGV4dHMocmVsZWFzZUNvbnRleHQsIHJlbGVhc2VDb250ZXh0TWFwKTtcblxuICAgICAgbG9nLmluZm8oYEluaXRpYWxpc2luZyB0aGUgJyR7ZGVwZW5kZW5jeU5hbWV9JyBjb250ZXh0Li4uYCk7XG5cbiAgICAgIGNvbnN0IHsgRmlsZUNvbnRleHRGcm9tRmlsZVBhdGggfSA9IGNvbnRleHQ7XG5cbiAgICAgIHJlbGVhc2VDb250ZXh0LmluaXRpYWxpc2UocmVsZWFzZUNvbnRleHRzLCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCk7XG5cbiAgICAgIGxvZy5kZWJ1ZyhgLi4uaW5pdGlhbGlzZWQgdGhlICcke2RlcGVuZGVuY3lOYW1lfScgY29udGV4dC5gKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlbGVhc2VDb250ZXh0KGRlcGVuZGVuY3ksIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KSB7XG4gIGxldCByZWxlYXNlQ29udGV4dENyZWF0ZWQgPSBmYWxzZTtcblxuICBjb25zdCB7IGxvZywgcmVsZWFzZUNvbnRleHRNYXAgfSA9IGNvbnRleHQsXG4gICAgICAgIGRlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgIHJlbGVhc2VOYW1lID0gZGVwZW5kZW5jeU5hbWUsIC8vL1xuICAgICAgICByZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0TWFwW3JlbGVhc2VOYW1lXSB8fCBudWxsO1xuXG4gIGlmIChyZWxlYXNlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHJlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeSA9IGNoZWNrUmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5KHJlbGVhc2VDb250ZXh0LCBkZXBlbmRlbmN5LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCk7XG5cbiAgICBpZiAocmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5KSB7XG4gICAgICBsb2cuZGVidWcoYFRoZSAnJHtyZWxlYXNlTmFtZX0nIGNvbnRleHQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkLmApO1xuXG4gICAgICByZWxlYXNlQ29udGV4dENyZWF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZXBlbmRlbmN5U3RyaW5nID0gZGVwZW5kZW5jeS5hc1N0cmluZygpLFxuICAgICAgICAgIGRlcGVuZGVudE5hbWVzTGVuZ3RoID0gZGVwZW5kZW50TmFtZXMubGVuZ3RoO1xuXG4gICAgaWYgKGRlcGVuZGVudE5hbWVzTGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2cuaW5mbyhgQ3JlYXRpbmcgdGhlICcke3JlbGVhc2VOYW1lfScgY29udGV4dC4uLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0RGVwZW5kZW50TmFtZSA9IGxhc3QoZGVwZW5kZW50TmFtZXMpLFxuICAgICAgICAgICAgZGVwZW5kZW50TmFtZSA9IGxhc3REZXBlbmRlbnROYW1lOyAgLy8vXG5cbiAgICAgIGxvZy5pbmZvKGBDcmVhdGluZyB0aGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0IGdpdmVuIHRoZSAnJHtkZXBlbmRlbnROYW1lfScgZGVwZW5kYW50J3MgJyR7ZGVwZW5kZW5jeVN0cmluZ30nIGRlcGVuZGVuY3kuLi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlbGVhc2VDb250ZXh0RnJvbURlcGVuZGVuY3kgfSA9IGNvbnRleHQsXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSBhd2FpdCByZWxlYXNlQ29udGV4dEZyb21EZXBlbmRlbmN5KGRlcGVuZGVuY3ksIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlbGVhc2VDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kgPSBjaGVja1JlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeShyZWxlYXNlQ29udGV4dCwgZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuXG4gICAgICBpZiAocmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5KSB7XG4gICAgICAgIHJlbGVhc2VDb250ZXh0TWFwW3JlbGVhc2VOYW1lXSA9IHJlbGVhc2VDb250ZXh0O1xuXG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNDcmVhdGVkID0gYXdhaXQgY3JlYXRlRGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhkZXBlbmRlbmN5LCByZWxlYXNlQ29udGV4dCwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzQ3JlYXRlZCkge1xuICAgICAgICAgIHJlbGVhc2VDb250ZXh0Q3JlYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgICAgIHJlbGVhc2VOYW1lID0gZGVwZW5kZW5jeU5hbWU7IC8vL1xuXG4gICAgICBsb2cud2FybmluZyhgVGhlICcke3JlbGVhc2VOYW1lfScgY29udGV4dCBjb3VsZCBub3QgYmUgY3JlYXRlZC4gUGVyaGFwcyB0aGUgJ21ldGEuanNvbicgZmlsZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuIE9yIHRoZXJlIGNvdWxkIGJlIGEgZGVwZW5kZW5jeSBtaXNtYXRjaC5gKTtcbiAgICB9XG5cbiAgICByZWxlYXNlQ29udGV4dENyZWF0ZWQgP1xuICAgICAgbG9nLmRlYnVnKGAuLi5jcmVhdGVkIHRoZSAnJHtyZWxlYXNlTmFtZX0nIGNvbnRleHQuYCkgOlxuICAgICAgICBsb2cud2FybmluZyhgLi4udW5hYmxlIHRvIGNyZWF0ZSB0aGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0LmApO1xuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VDb250ZXh0Q3JlYXRlZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVJlbGVhc2VDb250ZXh0KHJlbGVhc2VOYW1lLCBkZXBlbmRlbnROYW1lLCBkZXBlbmRlbnRSZWxlYXNlZCwgcmVsZWFzZUNvbnRleHRNYXApIHtcbiAgbGV0IHJlbGVhc2VDb250ZXh0VmVyaWZpZXMgPSBmYWxzZTtcblxuICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0TWFwW3JlbGVhc2VOYW1lXTtcblxuICBpZiAocmVsZWFzZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICBjb25zdCByZWxlYXNlZCA9IHJlbGVhc2VDb250ZXh0LmlzUmVsZWFzZWQoKTtcblxuICAgIGlmIChyZWxlYXNlZCkge1xuICAgICAgcmVsZWFzZUNvbnRleHRWZXJpZmllcyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZXBlbmRlbnRSZWxlYXNlZCkge1xuICAgICAgICByZWxlYXNlQ29udGV4dC53YXJuaW5nKGBUaGUgJyR7cmVsZWFzZU5hbWV9JyBwcm9qZWN0IGNhbm5vdCBiZSB2ZXJpZmllcyBiZWNhdXNlIGl0cyAnJHtkZXBlbmRlbnROYW1lfScgZGVwZW5kZW50IGlzIGEgcGFja2FnZS5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVudE5hbWUgPSByZWxlYXNlTmFtZSwgIC8vL1xuICAgICAgICAgICAgICBkZXBlbmRlbnRSZWxlYXNlZCA9IHJlbGVhc2VkLCAvLy9cbiAgICAgICAgICAgICAgZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c1ZlcmlmeSA9IGF3YWl0IHZlcmlmeURlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVudE5hbWUsIGRlcGVuZGVudFJlbGVhc2VkLCByZWxlYXNlQ29udGV4dE1hcCk7XG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNWZXJpZnkpIHtcbiAgICAgICAgICBjb25zdCByZWxlYXNlQ29udGV4dFZlcmlmaWVkID0gcmVsZWFzZUNvbnRleHQuaGFzVmVyaWZpZWQoKTtcblxuICAgICAgICAgIGlmIChyZWxlYXNlQ29udGV4dFZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZWxlYXNlQ29udGV4dFZlcmlmaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsZWFzZUNvbnRleHQuaW5mbyhgVmVyaWZ5aW5nIHRoZSAnJHtyZWxlYXNlTmFtZX0nIHByb2plY3QuLi5gKTtcblxuICAgICAgICAgICAgY29uc3QgdmVyaWZpZXMgPSBhd2FpdCByZWxlYXNlQ29udGV4dC52ZXJpZnkoKTtcblxuICAgICAgICAgICAgaWYgKHZlcmlmaWVzKSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0LmluZm8oYC4uLnZlcmlmaWVkIHRoZSAnJHtyZWxlYXNlTmFtZX0nIHByb2plY3QuYCk7XG5cbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRWZXJpZmllcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VDb250ZXh0VmVyaWZpZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY3JlYXRlUmVsZWFzZUNvbnRleHQsXG4gIHZlcmlmeVJlbGVhc2VDb250ZXh0LFxuICBpbml0aWFsaXNlUmVsZWFzZUNvbnRleHRcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMoZGVwZW5kZW5jeSwgcmVsZWFzZUNvbnRleHQsIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KSB7XG4gIGxldCBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzQ3JlYXRlZDtcblxuICBjb25zdCBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSByZWxlYXNlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoKTtcblxuICBkZXBlbmRlbnROYW1lcyA9IFsgLi4uZGVwZW5kZW50TmFtZXMsIGRlcGVuZGVuY3lOYW1lIF07ICAvLy9cblxuICBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzQ3JlYXRlZCA9IGF3YWl0IGFzeW5jRXZlcnlEZXBlbmRlbmN5KGRlcGVuZGVuY2llcywgYXN5bmMgKGRlcGVuZGVuY3kpID0+IHtcbiAgICBjb25zdCBjeWNsaWNEZXBlbmRlbmN5RXhpc3RzID0gY2hlY2tDeWNsaWNEZXBlbmRlbmN5RXhpc3RzKGRlcGVuZGVuY3ksIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KTtcblxuICAgIGlmICghY3ljbGljRGVwZW5kZW5jeUV4aXN0cykge1xuICAgICAgY29uc3QgcmVsZWFzZUNvbnRleHRDcmVhdGVkID0gYXdhaXQgY3JlYXRlUmVsZWFzZUNvbnRleHQoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuXG4gICAgICBpZiAocmVsZWFzZUNvbnRleHRDcmVhdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNDcmVhdGVkO1xufVxuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlEZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzKHJlbGVhc2VDb250ZXh0LCBkZXBlbmRlbnROYW1lLCBkZXBlbmRlbnRSZWxlYXNlZCwgcmVsZWFzZUNvbnRleHRNYXApIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gcmVsZWFzZUNvbnRleHQuZ2V0RGVwZW5kZW5jaWVzKCksXG4gICAgICAgIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNWZXJpZnkgPSBhd2FpdCBhc3luY0V2ZXJ5RGVwZW5kZW5jeShkZXBlbmRlbmNpZXMsIGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgIHJlbGVhc2VOYW1lID0gbmFtZSwgLy8vXG4gICAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRWZXJpZmllcyA9IGF3YWl0IHZlcmlmeVJlbGVhc2VDb250ZXh0KHJlbGVhc2VOYW1lLCBkZXBlbmRlbnROYW1lLCBkZXBlbmRlbnRSZWxlYXNlZCwgcmVsZWFzZUNvbnRleHRNYXApO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VDb250ZXh0VmVyaWZpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNWZXJpZnk7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlUmVsZWFzZUNvbnRleHRzKHJlbGVhc2VDb250ZXh0LCByZWxlYXNlQ29udGV4dE1hcCkge1xuICBjb25zdCByZWxlYXNlQ29udGV4dHMgPSBbXSxcbiAgICAgICAgcmVtYWluaW5nUmVsZWFzZUNvbnRleHQgPSByZWxlYXNlQ29udGV4dCwgIC8vL1xuICAgICAgICByZW1haW5pbmdSZWxlYXNlQ29udGV4dHMgPSBbXG4gICAgICAgICAgcmVtYWluaW5nUmVsZWFzZUNvbnRleHRcbiAgICAgICAgXTtcblxuICBsZXQgcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzTGVuZ3RoID0gcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzLmxlbmd0aDtcblxuICB3aGlsZSAocmVtYWluaW5nUmVsZWFzZUNvbnRleHRzTGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0ID0gcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzLnNoaWZ0KCksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSByZW1haW5pbmdSZWxlYXNlQ29udGV4dDsgIC8vL1xuXG4gICAgcmVsZWFzZUNvbnRleHRzLnB1c2gocmVsZWFzZUNvbnRleHQpO1xuXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gcmVsZWFzZUNvbnRleHQuZ2V0RGVwZW5kZW5jaWVzKCk7XG5cbiAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaERlcGVuZGVuY3koKGRlcGVuZGVuY3kpID0+IHtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgICAgICByZWxlYXNlTmFtZSA9IGRlcGVuZGVuY3lOYW1lLCAvLy9cbiAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHRNYXBbcmVsZWFzZU5hbWVdLFxuICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRzSW5jbHVkZXNSZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0cy5pbmNsdWRlcyhyZWxlYXNlQ29udGV4dCksXG4gICAgICAgICAgICByZW1haW5pbmdSZWxlYXNlQ29udGV4dHNJbmNsdWRlc1JlbGVhc2VDb250ZXh0ID0gcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzLmluY2x1ZGVzKHJlbGVhc2VDb250ZXh0KTtcblxuICAgICAgaWYgKCFyZWxlYXNlQ29udGV4dHNJbmNsdWRlc1JlbGVhc2VDb250ZXh0ICYmICFyZW1haW5pbmdSZWxlYXNlQ29udGV4dHNJbmNsdWRlc1JlbGVhc2VDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHQ7IC8vL1xuXG4gICAgICAgIHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0cy5wdXNoKHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0c0xlbmd0aCA9IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0cy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZUNvbnRleHRzO1xufVxuXG5mdW5jdGlvbiBjaGVja0N5Y2xpY0RlcGVuZGVuY3lFeGlzdHMoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgZGVwZW5kZW50TmFtZXNJbmNsdWRlc0RlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW50TmFtZXMuaW5jbHVkZXMoZGVwZW5kZW5jeU5hbWUpLFxuICAgICAgICBjeWNsaWNEZXBlbmRlbmN5RXhpc3RzID0gZGVwZW5kZW50TmFtZXNJbmNsdWRlc0RlcGVuZGVuY3lOYW1lOyAgLy8vXG5cbiAgaWYgKGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHMpIHtcbiAgICBjb25zdCB7IGxvZyB9ID0gY29udGV4dCxcbiAgICAgICAgICBmaXJzdERlcGVuZGVudE5hbWUgPSBmaXJzdChkZXBlbmRlbnROYW1lcyksXG4gICAgICAgICAgZGVwZW5kZW5jeU5hbWVzID0gWyAgLy8vXG4gICAgICAgICAgICAuLi5kZXBlbmRlbnROYW1lcyxcbiAgICAgICAgICAgIGZpcnN0RGVwZW5kZW50TmFtZVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZGVwZW5kZW5jeU5hbWVzU3RyaW5nID0gZGVwZW5kZW5jeU5hbWVzLmpvaW4oYCcgLT4gJ2ApO1xuXG4gICAgbG9nLndhcm5pbmcoYFRoZXJlIGlzIGEgY3ljbGljIGRlcGVuZGVuY3ksICcke2RlcGVuZGVuY3lOYW1lc1N0cmluZ30nLmApO1xuICB9XG5cbiAgcmV0dXJuIGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHM7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5KHJlbGVhc2VDb250ZXh0LCBkZXBlbmRlbmN5LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCkge1xuICBsZXQgcmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5ID0gdHJ1ZTtcblxuICBjb25zdCBzaG9ydGVuZWRWZXJzaW9uID0gZGVwZW5kZW5jeS5nZXRTaG9ydGVkVmVyc2lvbigpO1xuXG4gIGlmIChzaG9ydGVuZWRWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgY29uc3QgZW50cmllc01hdGNoU2hvcnRlbmVkVmVyc2lvbiA9IHJlbGVhc2VDb250ZXh0Lm1hdGNoU2hvcnRlbmVkVmVyc2lvbihzaG9ydGVuZWRWZXJzaW9uKTtcblxuICAgIGlmICghZW50cmllc01hdGNoU2hvcnRlbmVkVmVyc2lvbikge1xuICAgICAgY29uc3QgeyBsb2cgfSA9IGNvbnRleHQsXG4gICAgICAgICAgICB2ZXJzaW9uID0gcmVsZWFzZUNvbnRleHQuZ2V0VmVyc2lvbigpLFxuICAgICAgICAgICAgbGFzdERlcGVuZGVudE5hbWUgPSBsYXN0KGRlcGVuZGVudE5hbWVzKSxcbiAgICAgICAgICAgIGRlcGVuZGVudE5hbWUgPSBsYXN0RGVwZW5kZW50TmFtZSwgIC8vL1xuICAgICAgICAgICAgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGRlcGVuZGVuY3lTdHJpbmcgPSBkZXBlbmRlbmN5LmFzU3RyaW5nKCk7XG5cbiAgICAgIGxvZy53YXJuaW5nKGBUaGUgJyR7ZGVwZW5kZW50TmFtZX0nIGRlcGVuZGVudCByZXF1aXJlcyB0aGUgJyR7ZGVwZW5kZW5jeVN0cmluZ30nIGRlcGVuZGVuY3kgYnV0IGEgY29udGV4dCB3aXRoIHZlcnNpb24gJyR7dmVyc2lvblN0cmluZ30nIHdhcyBwcm92aWRlZC5gKTtcblxuICAgICAgcmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGlzZURlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMoZGVwZW5kZW5jeSwgcmVsZWFzZUNvbnRleHQsIGNvbnRleHQpIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gcmVsZWFzZUNvbnRleHQuZ2V0RGVwZW5kZW5jaWVzKCk7XG5cbiAgZGVwZW5kZW5jaWVzLmZvckVhY2hEZXBlbmRlbmN5KChkZXBlbmRlbmN5KSA9PiB7ICAvLy9cbiAgICBpbml0aWFsaXNlUmVsZWFzZUNvbnRleHQoZGVwZW5kZW5jeSwgY29udGV4dCk7XG4gIH0pO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgRklMRV9UWVBFID0gXCJGaWxlXCI7XG5leHBvcnQgY29uc3QgRElSRUNUT1JZX1RZUEUgPSBcIkRpcmVjdG9yeVwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBET1VCTEVfU1BBQ0UgPSBcIiAgXCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9BTVBFUlNBTkQgPSBcIiZhbXA7XCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9MRVNTX1RIQU4gPSBcIiZsdDtcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0dSRUFURVJfVEhBTiA9IFwiJmd0O1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBET1VCTEVfU1BBQ0UsIEVNUFRZX1NUUklORywgRVNDQVBFRF9BTVBFUlNBTkQsIEVTQ0FQRURfTEVTU19USEFOLCBFU0NBUEVEX0dSRUFURVJfVEhBTiB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXNlQ29udGVudChjb250ZW50KSB7XG4gIGNvbnN0IHNhbml0aXNlZENvbnRlbnQgPSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csIEVTQ0FQRURfQU1QRVJTQU5EKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCBFU0NBUEVEX0xFU1NfVEhBTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgRVNDQVBFRF9HUkVBVEVSX1RIQU4pO1xuXG4gIHJldHVybiBzYW5pdGlzZWRDb250ZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJpbURvdWJsZVF1b3Rlcyhjb250ZW50KSB7IHJldHVybiBjb250ZW50LnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBFTVBUWV9TVFJJTkcpOyB9IC8vL1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydENvbnRlbnRUYWJzVG9XaGl0ZXNwYWNlKGNvbnRlbnQpIHsgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvXFx0L2csIERPVUJMRV9TUEFDRSk7IH0gLy8vXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2FuaXRpc2VDb250ZW50LFxuICB0cmltRG91YmxlUXVvdGVzLFxuICBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2Vcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEZJTEVfVFlQRSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UgfSBmcm9tIFwiLi91dGlsaXRpZXMvY29udGVudFwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGUge1xuICBjb25zdHJ1Y3RvcihwYXRoLCBjb250ZW50LCByZWxlYXNlZCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLnJlbGVhc2VkID0gcmVsZWFzZWQ7XG4gIH1cblxuICBnZXRQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cblxuICBpc1JlbGVhc2VkKCkge1xuICAgIHJldHVybiB0aGlzLnJlbGVhc2VkO1xuICB9XG5cbiAgaXNGaWxlKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICBpc0RpcmVjdG9yeSgpIHtcbiAgICBjb25zdCBkaXJlY3RvcnkgPSBmYWxzZTtcblxuICAgIHJldHVybiBkaXJlY3Rvcnk7XG4gIH1cblxuICBzZXRQYXRoKHBhdGgpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICB9XG5cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuXG4gIHNldFJlbGVhc2VkKHJlbGVhc2VkKSB7XG4gICAgdGhpcy5yZWxlYXNlZCA9IHJlbGVhc2VkO1xuICB9XG5cbiAgbWF0Y2hGaWxlUGF0aChmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVQYXRoTWF0Y2hlcyA9ICh0aGlzLnBhdGggPT09IGZpbGVQYXRoKTtcblxuICAgIHJldHVybiBmaWxlUGF0aE1hdGNoZXM7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBGaWxlLFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgICAgICByZWxlYXNlZCA9IHRoaXMucmVsZWFzZWQsXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIHJlbGVhc2VkXG4gICAgICAgICAgfTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBGSUxFX1RZUEU7XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBsZXQgZmlsZSA9IG51bGw7XG5cbiAgICBpZiAoanNvbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgeyB0eXBlIH0gPSBqc29uO1xuXG4gICAgICBpZiAodHlwZSA9PT0gRklMRV9UWVBFKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQgfSA9IGpzb247XG5cbiAgICAgICAgY29uc3QgeyBwYXRoLCByZWxlYXNlZCB9ID0ganNvbjtcblxuICAgICAgICBjb250ZW50ID0gY29udmVydENvbnRlbnRUYWJzVG9XaGl0ZXNwYWNlKGNvbnRlbnQpOyAgLy8vXG5cbiAgICAgICAgZmlsZSA9IG5ldyBGaWxlKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGRvY3VtZW50LmdldEZpbGVQYXRoKCksXG4gICAgICAgICAgcmVsZWFzZWQgPSBkb2N1bWVudC5pc1JlbGVhc2VkKCksXG4gICAgICAgICAgcGF0aCA9IGZpbGVQYXRoOyAgLy8vXG5cbiAgICBsZXQgY29udGVudCA9IGRvY3VtZW50LmdldENvbnRlbnQoKTtcblxuICAgIGNvbnRlbnQgPSBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UoY29udGVudCk7ICAvLy9cblxuICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShwYXRoLCBjb250ZW50LCByZWxlYXNlZCk7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGF0aENvbnRlbnRBbmRSZWxlYXNlZChwYXRoLCBjb250ZW50LCByZWxlYXNlZCkge1xuICAgIGNvbnRlbnQgPSBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UoY29udGVudCk7ICAvLy9cblxuICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShwYXRoLCBjb250ZW50LCByZWxlYXNlZCk7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRmlsZSBmcm9tIFwiLi9maWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVzIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGdldEZpbGVQYXRocygpIHtcbiAgICBjb25zdCBmaWxlUGF0aHMgPSB0aGlzLm1hcEZpbGUoKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCk7XG5cbiAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9KTtcblxuICAgIHJldHVybiBmaWxlUGF0aHM7XG4gIH1cblxuICBhZGRGaWxlKGZpbGUpIHsgdGhpcy5hcnJheS5wdXNoKGZpbGUpOyB9XG5cbiAgbWFwRmlsZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5tYXAoY2FsbGJhY2spOyB9XG5cbiAgc29tZUZpbGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICByZWR1Y2VGaWxlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHsgcmV0dXJuIHRoaXMuYXJyYXkucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbiAgZm9yRWFjaEZpbGUoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGZpbmRGaWxlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5LmZpbmQoY2FsbGJhY2spIHx8IG51bGw7IH0gIC8vL1xuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBmaWxlc0pTT04gPSB0aGlzLmFycmF5Lm1hcCgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZUpTT04gPSAoZmlsZSAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnRvSlNPTigpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICBcbiAgICAgICAgICAgIHJldHVybiBmaWxlSlNPTjtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBqc29uID0gZmlsZXNKU09OOyAvLy9cblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBjb25zdCBmaWxlc0pTT04gPSBqc29uLCAvLy9cbiAgICAgICAgICBhcnJheSA9IFtdLFxuICAgICAgICAgIGZpbGVzID0gbmV3IEZpbGVzKGFycmF5KTtcbiAgICBcbiAgICBmaWxlc0pTT04uZm9yRWFjaCgoZmlsZUpTT04pID0+IHtcbiAgICAgIGNvbnN0IGpzb24gPSBmaWxlSlNPTiwgIC8vL1xuICAgICAgICAgICAgZmlsZSA9IEZpbGUuZnJvbUpTT04oanNvbik7XG5cbiAgICAgIGZpbGVzLmFkZEZpbGUoZmlsZSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGZpbGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgZmlsZXMgPSBuZXcgRmlsZXMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIGZpbGVzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBNQUpPUl9OVU1CRVJfTVVMVElQTElFUiA9IDFlMTI7XG5leHBvcnQgY29uc3QgTUlOT1JfTlVNQkVSX01VTFRJUExJRVIgPSAxZTY7XG5leHBvcnQgY29uc3QgUEFUQ0hfTlVNQkVSX01VTFRJUExJRVIgPSAxZTA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBNQUpPUl9OVU1CRVJfTVVMVElQTElFUiwgTUlOT1JfTlVNQkVSX01VTFRJUExJRVIsIFBBVENIX05VTUJFUl9NVUxUSVBMSUVSIH0gZnJvbSBcIi4uL211bHRpcGxlcnNcIjtcblxuY29uc3QgeyBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFqb3JOdW1iZXJGcm9tTnVtYmVyKG51bWJlcikge1xuICBjb25zdCBtYWpvck51bWJlciA9IChudW1iZXIgIT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IobnVtYmVyIC8gTUFKT1JfTlVNQkVSX01VTFRJUExJRVIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMDsgIC8vL1xuXG4gIHJldHVybiBtYWpvck51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbm9yTnVtYmVyRnJvbU51bWJlcihudW1iZXIpIHtcbiAgY29uc3QgbWlub3JOdW1iZXIgPSAobnVtYmVyICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKChudW1iZXIgJSBNQUpPUl9OVU1CRVJfTVVMVElQTElFUikgLyBNSU5PUl9OVU1CRVJfTVVMVElQTElFUikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAwOyAgLy8vXG5cbiAgcmV0dXJuIG1pbm9yTnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hOdW1iZXJGcm9tTnVtYmVyKG51bWJlcikge1xuICBjb25zdCBwYXRjaE51bWJlciA9IChudW1iZXIgIT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG51bWJlciAlIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSKSAvIFBBVENIX05VTUJFUl9NVUxUSVBMSUVSKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDA7ICAvLy9cblxuICByZXR1cm4gcGF0Y2hOdW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWpvck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSB7XG4gIGxldCBtYWpvck51bWJlciA9IDA7XG5cbiAgaWYgKHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHJpbmcubWF0Y2goL14oXFxkKykvKSxcbiAgICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKTtcblxuICAgIG1ham9yTnVtYmVyID0gTnVtYmVyKHNlY29uZE1hdGNoKTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG1ham9yTnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlub3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZykge1xuICBsZXQgbWlub3JOdW1iZXIgPSAwO1xuXG4gIGlmIChzdHJpbmcpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gc3RyaW5nLm1hdGNoKC9eXFxkK1xcLihcXGQrKS8pLFxuICAgICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgbWlub3JOdW1iZXIgPSBOdW1iZXIoc2Vjb25kTWF0Y2gpOyAgLy8vXG4gIH1cblxuICByZXR1cm4gbWlub3JOdW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaE51bWJlckZyb21TdHJpbmcoc3RyaW5nKSB7XG4gIGxldCBwYXRjaE51bWJlciA9IDA7XG5cbiAgaWYgKHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHJpbmcubWF0Y2goL15cXGQrXFwuXFxkK1xcLihcXGQrKS8pLFxuICAgICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgcGF0Y2hOdW1iZXIgPSBOdW1iZXIoc2Vjb25kTWF0Y2gpOyAgLy8vXG4gIH1cblxuICByZXR1cm4gcGF0Y2hOdW1iZXI7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSLCBNSU5PUl9OVU1CRVJfTVVMVElQTElFUiwgUEFUQ0hfTlVNQkVSX01VTFRJUExJRVIgfSBmcm9tIFwiLi9tdWx0aXBsZXJzXCI7XG5pbXBvcnQgeyBtYWpvck51bWJlckZyb21OdW1iZXIsXG4gICAgICAgICBtaW5vck51bWJlckZyb21OdW1iZXIsXG4gICAgICAgICBwYXRjaE51bWJlckZyb21OdW1iZXIsXG4gICAgICAgICBtYWpvck51bWJlckZyb21TdHJpbmcsXG4gICAgICAgICBtaW5vck51bWJlckZyb21TdHJpbmcsXG4gICAgICAgICBwYXRjaE51bWJlckZyb21TdHJpbmcgfSBmcm9tIFwiLi91dGlsaXRpZXMvdmVyc2lvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJzaW9uIHtcbiAgY29uc3RydWN0b3IobWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyLCBwYXRjaE51bWJlcikge1xuICAgIHRoaXMubWFqb3JOdW1iZXIgPSBtYWpvck51bWJlcjtcbiAgICB0aGlzLm1pbm9yTnVtYmVyID0gbWlub3JOdW1iZXI7XG4gICAgdGhpcy5wYXRjaE51bWJlciA9IHBhdGNoTnVtYmVyO1xuICB9XG5cbiAgZ2V0TWFqb3JOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFqb3JOdW1iZXI7XG4gIH1cblxuICBnZXRNaW5vck51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5taW5vck51bWJlcjtcbiAgfVxuXG4gIGdldFBhdGNoTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGNoTnVtYmVyO1xuICB9XG5cbiAgYnVtcE1ham9yTnVtYmVyKCkge1xuICAgIHRoaXMubWFqb3JOdW1iZXIgKz0gMTtcbiAgfVxuXG4gIGJ1bXBNaW5vck51bWJlcigpIHtcbiAgICB0aGlzLm1pbm9yTnVtYmVyICs9IDE7XG4gIH1cblxuICBidW1wUGF0Y2hOdW1iZXIoKSB7XG4gICAgdGhpcy5wYXRjaE51bWJlciArPSAxO1xuICB9XG5cbiAgcmVzZXRNYWpvck51bWJlcigpIHtcbiAgICB0aGlzLm1ham9yTnVtYmVyID0gMDtcbiAgfVxuXG4gIHJlc2V0TWlub3JOdW1iZXIoKSB7XG4gICAgdGhpcy5taW5vck51bWJlciA9IDA7XG4gIH1cblxuICByZXNldFBhdGNoTnVtYmVyKCkge1xuICAgIHRoaXMucGF0Y2hOdW1iZXIgPSAwO1xuICB9XG5cbiAgbWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pIHtcbiAgICBsZXQgbWF0Y2hlc1Nob3J0ZW5lZFZlcnNpb24gPSBmYWxzZTtcblxuICAgIGlmIChzaG9ydGVuZWRWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICBtYXRjaGVzU2hvcnRlbmVkVmVyc2lvbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ham9yTnVtYmVyID0gc2hvcnRlbmVkVmVyc2lvbi5nZXRNYWpvck51bWJlcigpO1xuXG4gICAgICBpZiAodGhpcy5tYWpvck51bWJlciA9PT0gbWFqb3JOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWlub3JOdW1iZXIgPSBzaG9ydGVuZWRWZXJzaW9uLmdldE1pbm9yTnVtYmVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWlub3JOdW1iZXIgPj0gbWlub3JOdW1iZXIpIHtcbiAgICAgICAgICBtYXRjaGVzU2hvcnRlbmVkVmVyc2lvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlc1Nob3J0ZW5lZFZlcnNpb247XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBgJHt0aGlzLm1ham9yTnVtYmVyfS4ke3RoaXMubWlub3JOdW1iZXJ9LiR7dGhpcy5wYXRjaE51bWJlcn1gO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHRvVmVyc2lvbk51bWJlcigpIHtcbiAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gdGhpcy5tYWpvck51bWJlciAqIE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSICsgdGhpcy5taW5vck51bWJlciAqIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSICsgdGhpcy5wYXRjaE51bWJlciAqIFBBVENIX05VTUJFUl9NVUxUSVBMSUVSO1xuXG4gICAgcmV0dXJuIHZlcnNpb25OdW1iZXI7XG4gIH1cblxuICBzdGF0aWMgZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IG1ham9yTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgIG1pbm9yTnVtYmVyID0gbWlub3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgcGF0Y2hOdW1iZXIgPSBwYXRjaE51bWJlckZyb21TdHJpbmcoc3RyaW5nKSxcbiAgICAgICAgICB2ZXJzaW9uID0gbmV3IFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyLCBwYXRjaE51bWJlcik7XG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IDAsXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSAwLFxuICAgICAgICAgIHBhdGNoTnVtYmVyID0gMCxcbiAgICAgICAgICB2ZXJzaW9uID0gbmV3IFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyLCBwYXRjaE51bWJlcik7XG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgY29uc3QgbWFqb3JOdW1iZXIgPSB2ZXJzaW9uLmdldE1ham9yTnVtYmVyKCksXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSB2ZXJzaW9uLmdldE1pbm9yTnVtYmVyKCksXG4gICAgICAgICAgcGF0Y2hOdW1iZXIgPSB2ZXJzaW9uLmdldFBhdGNoTnVtYmVyKCk7XG5cbiAgICB2ZXJzaW9uID0gbmV3IFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyLCBwYXRjaE51bWJlcik7IC8vL1xuXG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cblxuICBzdGF0aWMgZnJvbVZlcnNpb25OdW1iZXIodmVyc2lvbk51bWJlcikge1xuICAgIGNvbnN0IG51bWJlciA9IHZlcnNpb25OdW1iZXIsIC8vL1xuICAgICAgICAgIG1ham9yTnVtYmVyID0gbWFqb3JOdW1iZXJGcm9tTnVtYmVyKG51bWJlciksXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSBtaW5vck51bWJlckZyb21OdW1iZXIobnVtYmVyKSxcbiAgICAgICAgICBwYXRjaE51bWJlciA9IHBhdGNoTnVtYmVyRnJvbU51bWJlcihudW1iZXIpLFxuICAgICAgICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTtcblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERJUkVDVE9SWV9UWVBFIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0b3J5IHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cblxuICBnZXRQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH1cblxuICBpc0ZpbGUoKSB7XG4gICAgY29uc3QgZmlsZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICBpc0RpcmVjdG9yeSgpIHtcbiAgICBjb25zdCBkaXJlY3RvcnkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IERpcmVjdG9yeSxcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gRElSRUNUT1JZX1RZUEU7XG5cbiAgc3RhdGljIGZyb21QYXRoKHBhdGgpIHtcbiAgICBjb25zdCBkaXJlY3RvcnkgPSBuZXcgRGlyZWN0b3J5KHBhdGgpO1xuXG4gICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgbGV0IGRpcmVjdG9yeSA9IG51bGw7XG5cbiAgICBpZiAoanNvbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgeyB0eXBlIH0gPSBqc29uO1xuXG4gICAgICBpZiAodHlwZSA9PT0gRElSRUNUT1JZX1RZUEUpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoIH0gPSBqc29uO1xuXG4gICAgICAgIGRpcmVjdG9yeSA9IG5ldyBEaXJlY3RvcnkocGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXRoVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IGJvdHRvbW1vc3ROYW1lRnJvbVBhdGggfSA9IHBhdGhVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlTmFtZUZyb21GaWxlUGF0aChmaWxlUGF0aCkge1xuICBjb25zdCBwYXRoID0gZmlsZVBhdGgsICAvLy9cbiAgICAgICAgYm90dG9tbW9zdE5hbWUgPSBib3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpLFxuICAgICAgICBmaWxlTmFtZSA9IGJvdHRvbW1vc3ROYW1lOyAgLy9cblxuICByZXR1cm4gZmlsZU5hbWU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBSRUFETUVfTURfRklMRV9OQU1FID0gXCJSRUFETUUubWRcIjtcbmV4cG9ydCBjb25zdCBNRVRBX0pTT05fRklMRV9OQU1FID0gXCJtZXRhLmpzb25cIjtcblxuZXhwb3J0IGNvbnN0IFRFUk1fQk5GX0ZJTEVfTkFNRSA9IFwidGVybS5ibmZcIjtcbmV4cG9ydCBjb25zdCBTVEFURU1FTlRfQk5GX0ZJTEVfTkFNRSA9IFwic3RhdGVtZW50LmJuZlwiO1xuZXhwb3J0IGNvbnN0IFRZUEVfVk9DQUJVTEFSWV9GSUxFX05BTUUgPSBcInR5cGUudmNiXCI7XG5leHBvcnQgY29uc3QgU1lNQk9MX1ZPQ0FCVUxBUllfRklMRV9OQU1FID0gXCJzeW1ib2wudmNiXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUkVBRE1FX01EX0ZJTEVfTkFNRSxcbiAgTUVUQV9KU09OX0ZJTEVfTkFNRSxcbiAgVEVSTV9CTkZfRklMRV9OQU1FLFxuICBTVEFURU1FTlRfQk5GX0ZJTEVfTkFNRSxcbiAgVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSxcbiAgU1lNQk9MX1ZPQ0FCVUxBUllfRklMRV9OQU1FXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBmaWxlTmFtZUZyb21GaWxlUGF0aCB9IGZyb20gXCIuLi91dGlsaXRpZXMvbmFtZVwiO1xuaW1wb3J0IHsgVEVSTV9CTkZfRklMRV9OQU1FLCBTVEFURU1FTlRfQk5GX0ZJTEVfTkFNRSB9IGZyb20gXCIuLi9maWxlTmFtZXNcIjtcblxuZnVuY3Rpb24gZ2V0Qk5GKGJuZkZpbGVOYW1lKSB7XG4gIGxldCBibmYgPSBFTVBUWV9TVFJJTkc7XG5cbiAgY29uc3QgY3VzdG9tR3JhbW1hckJORkZpbGVzID0gdGhpcy5nZXRDdXN0b21HcmFtbWFyQk5GRmlsZXMoKSxcbiAgICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGUgPSBjdXN0b21HcmFtbWFyQk5GRmlsZXMuZmluZCgoY3VzdG9tR3JhbW1hckJORkZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGggPSBjdXN0b21HcmFtbWFyQk5GRmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVOYW1lID0gZmlsZU5hbWVGcm9tRmlsZVBhdGgoY3VzdG9tR3JhbW1hckJORkZpbGVQYXRoKTtcblxuICAgICAgICAgIGlmIChjdXN0b21HcmFtbWFyQk5GRmlsZU5hbWUgPT09IGJuZkZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IG51bGw7XG5cbiAgaWYgKGN1c3RvbUdyYW1tYXJCTkZGaWxlICE9PSBudWxsKSB7XG4gICAgY29uc3QgY3VzdG9tR3JhbW1hckJORkZpbGVDb250ZW50ID0gY3VzdG9tR3JhbW1hckJORkZpbGUuZ2V0Q29udGVudCgpO1xuXG4gICAgYm5mID0gY3VzdG9tR3JhbW1hckJORkZpbGVDb250ZW50OyAgLy8vXG4gIH1cblxuICByZXR1cm4gYm5mO1xufVxuXG5mdW5jdGlvbiBnZXRUZXJtQk5GKCkge1xuICBjb25zdCBmaWxlTmFtZSA9IFRFUk1fQk5GX0ZJTEVfTkFNRSwgLy8vXG4gICAgICAgIGJuZiA9IHRoaXMuZ2V0Qk5GKGZpbGVOYW1lKSxcbiAgICAgICAgdGVybUJORiA9IGJuZjsgIC8vL1xuXG4gIHJldHVybiB0ZXJtQk5GO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZW1lbnRCTkYoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gU1RBVEVNRU5UX0JORl9GSUxFX05BTUUsIC8vL1xuICAgICAgICBibmYgPSB0aGlzLmdldEJORihmaWxlTmFtZSksXG4gICAgICAgIHN0YXRlbWVudEJORiA9IGJuZjsgIC8vL1xuXG4gIHJldHVybiBzdGF0ZW1lbnRCTkY7XG59XG5cbmNvbnN0IGJuZk1peGlucyA9IHtcbiAgZ2V0Qk5GLFxuICBnZXRUZXJtQk5GLFxuICBnZXRTdGF0ZW1lbnRCTkZcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJuZk1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IHJlYWRtZUZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfVJFQURNRVxcXFwubWQkXCIsXHJcbiAgICAgIGZ1cnRsZUZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxLH1bXlxcXFwuXStcXFxcLmZ0bCRcIixcclxuICAgICAgbm9taW5hbEZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxLH1bXlxcXFwuXStcXFxcLm5tbCRcIixcclxuICAgICAgbWFya2Rvd25GaWxlUGF0aFBhdHRlcm4gPSBcIl4oPzpbXlxcXFwvXStcXFxcLyl7MSx9W15cXFxcLl0rXFxcXC5tZCRcIixcclxuICAgICAgbWV0YUpTT05GaWxlUGF0aFBhdHRlcm4gPSBcIl4oPzpbXlxcXFwvXStcXFxcLyl7MX1tZXRhXFxcXC5qc29uJFwiLFxyXG4gICAgICBpbmRleEpTT05GaWxlUGF0aFBhdHRlcm4gPSBcIl4oPzpbXlxcXFwvXStcXFxcLyl7MX1pbmRleFxcXFwuanNvbiRcIixcclxuICAgICAgbWFya2Rvd25TdHlsZUZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxLH1bXlxcXFwuXStcXFxcLm1kcyRcIixcclxuICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfSh0ZXJtfHN0YXRlbWVudClcXFxcLmJuZiRcIixcclxuICAgICAgZGVmYXVsdE1hcmtkb3duU3R5bGVGaWxlUGF0aFBhdHRlcm4gPSBcIl5bXlxcXFwvXStcXFxcL2RlZmF1bHRcXFxcLm1kcyRcIixcclxuICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aFBhdHRlcm4gPSBcIl4oPzpbXlxcXFwvXStcXFxcLyl7MX0odHlwZXxzeW1ib2wpXFxcXC52Y2IkXCIsXHJcbiAgICAgIHJlbGVhc2VGaWxlUGF0aFBhdHRlcm4gPSBgJHtyZWFkbWVGaWxlUGF0aFBhdHRlcm59fCR7ZnVydGxlRmlsZVBhdGhQYXR0ZXJufXwke25vbWluYWxGaWxlUGF0aFBhdHRlcm59fCR7bWV0YUpTT05GaWxlUGF0aFBhdHRlcm59fCR7Y3VzdG9tR3JhbW1hckJORkZpbGVQYXRoUGF0dGVybn18JHtjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUGF0dGVybn1gLFxyXG4gICAgICByZWNvZ25pc2VkRmlsZVBhdGhQYXR0ZXJuID0gYCR7cmVsZWFzZUZpbGVQYXRoUGF0dGVybn18JHtpbmRleEpTT05GaWxlUGF0aFBhdHRlcm59fCR7bWFya2Rvd25GaWxlUGF0aFBhdHRlcm59fCR7bWFya2Rvd25TdHlsZUZpbGVQYXRoUGF0dGVybn1gO1xyXG5cclxuY29uc3QgcmVhZG1lRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocmVhZG1lRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgZnVydGxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoZnVydGxlRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgcmVsZWFzZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKHJlbGVhc2VGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBub21pbmFsRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAobm9taW5hbEZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG1hcmtkb3duRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAobWFya2Rvd25GaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBtZXRhSlNPTkZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKG1ldGFKU09ORmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgaW5kZXhKU09ORmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoaW5kZXhKU09ORmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgcmVjb2duaXNlZEZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKHJlY29nbmlzZWRGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBtYXJrZG93blN0eWxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAobWFya2Rvd25TdHlsZUZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgZGVmYXVsdE1hcmtkb3duU3R5bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChkZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aFBhdHRlcm4pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhSZWFkbWVGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gcmVhZG1lRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhGdXJ0bGVGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gZnVydGxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIHJlbGVhc2VGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aE5vbWluYWxGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gbm9taW5hbEZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTWFya2Rvd25GaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gbWFya2Rvd25GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aE1ldGFKU09ORmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIG1ldGFKU09ORmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhJbmRleEpTT05GaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gaW5kZXhKU09ORmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhSZWNvZ25pc2VkRmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIHJlY29nbmlzZWRGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aE1hcmtkb3duU3R5bGVGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gbWFya2Rvd25TdHlsZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhEZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBkZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgaXNGaWxlUGF0aFJlYWRtZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhGdXJ0bGVGaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoUmVsZWFzZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhOb21pbmFsRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aE1hcmtkb3duRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aE1ldGFKU09ORmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aEluZGV4SlNPTkZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhSZWNvZ25pc2VkRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aE1hcmtkb3duU3R5bGVGaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhEZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoXHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgaXNGaWxlUGF0aFJlYWRtZUZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aEZ1cnRsZUZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aE5vbWluYWxGaWxlUGF0aCxcbiAgICAgICAgIGlzRmlsZVBhdGhNZXRhSlNPTkZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aCxcbiAgICAgICAgIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9maWxlUGF0aFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZG1lRmlsZUZyb21GaWxlcyhmaWxlcykge1xuICBsZXQgcmVhZG1lRmlsZSA9IG51bGw7XG5cbiAgZmlsZXMuc29tZUZpbGUoKGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgIGZpbGVQYXRoUmVhZG1lRmlsZVBhdGggPSBpc0ZpbGVQYXRoUmVhZG1lRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgaWYgKGZpbGVQYXRoUmVhZG1lRmlsZVBhdGgpIHtcbiAgICAgIHJlYWRtZUZpbGUgPSBmaWxlOyAgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlYWRtZUZpbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdXJ0bGVGaWxlc0Zyb21GaWxlcyhmaWxlcykge1xuICBjb25zdCBmdXJ0bGVGaWxlcyA9IGZpbGVzLnJlZHVjZUZpbGUoKGZ1cnRsZUZpbGVzLCBmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBmaWxlUGF0aEZ1cnRsZUZpbGVQYXRoID0gaXNGaWxlUGF0aEZ1cnRsZUZpbGVQYXRoKGZpbGVQYXRoKSxcbiAgICAgICAgICBmaWxlRnVydGxlRmlsZSA9IGZpbGVQYXRoRnVydGxlRmlsZVBhdGg7ICAvLy9cblxuICAgIGlmIChmaWxlRnVydGxlRmlsZSkge1xuICAgICAgY29uc3QgZnVydGxlRmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgZnVydGxlRmlsZXMucHVzaChmdXJ0bGVGaWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVydGxlRmlsZXM7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gZnVydGxlRmlsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub21pbmFsRmlsZXNGcm9tRmlsZXMoZmlsZXMpIHtcbiAgY29uc3Qgbm9taW5hbEZpbGVzID0gZmlsZXMucmVkdWNlRmlsZSgobm9taW5hbEZpbGVzLCBmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgIGZpbGVQYXRoTm9taW5hbEZpbGVQYXRoID0gaXNGaWxlUGF0aE5vbWluYWxGaWxlUGF0aChmaWxlUGF0aCksXG4gICAgICBmaWxlTm9taW5hbEZpbGUgPSBmaWxlUGF0aE5vbWluYWxGaWxlUGF0aDsgIC8vL1xuXG4gICAgaWYgKGZpbGVOb21pbmFsRmlsZSkge1xuICAgICAgY29uc3Qgbm9taW5hbEZpbGUgPSBmaWxlOyAgLy8vXG5cbiAgICAgIG5vbWluYWxGaWxlcy5wdXNoKG5vbWluYWxGaWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9taW5hbEZpbGVzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIG5vbWluYWxGaWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGFKU09ORmlsZUZyb21GaWxlcyhmaWxlcykge1xuICBsZXQgbWV0YUpTT05GaWxlID0gbnVsbDtcblxuICBmaWxlcy5zb21lRmlsZSgoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgZmlsZVBhdGhNZXRhSlNPTkZpbGVQYXRoID0gaXNGaWxlUGF0aE1ldGFKU09ORmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgaWYgKGZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aCkge1xuICAgICAgbWV0YUpTT05GaWxlID0gZmlsZTsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBtZXRhSlNPTkZpbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21HcmFtbWFyQk5GRmlsZXNGcm9tRmlsZXMoZmlsZXMpIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hckJORkZpbGVzID0gZmlsZXMucmVkdWNlRmlsZSgoY3VzdG9tR3JhbW1hckJORkZpbGVzLCBmaWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICAgICAgICBmaWxlUGF0aEN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aCA9IGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgoZmlsZVBhdGgpLFxuICAgICAgICAgICAgICAgIGZpbGVDdXN0b21HcmFtbWFyQk5GRmlsZSA9IGZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoOyAgLy8vXG5cbiAgICAgICAgICBpZiAoZmlsZUN1c3RvbUdyYW1tYXJCTkZGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVzLnB1c2goY3VzdG9tR3JhbW1hckJORkZpbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXN0b21HcmFtbWFyQk5GRmlsZXM7XG4gICAgICAgIH0sIFtdKTtcblxuICByZXR1cm4gY3VzdG9tR3JhbW1hckJORkZpbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc0Zyb21GaWxlcyhmaWxlcykge1xuICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzID0gZmlsZXMucmVkdWNlRmlsZSgoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcywgZmlsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgICAgICAgZmlsZVBhdGhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoID0gaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGgoZmlsZVBhdGgpLFxuICAgICAgICAgICAgICAgIGZpbGVDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUgPSBmaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGg7ICAvLy9cblxuICAgICAgICAgIGlmIChmaWxlQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUgPSBmaWxlOyAgLy8vXG5cbiAgICAgICAgICAgIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMucHVzaChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzO1xuICAgICAgICB9LCBbXSk7XG5cbiAgcmV0dXJuIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHJlYWRtZUZpbGVGcm9tRmlsZXMsXG4gICAgICAgICBmdXJ0bGVGaWxlc0Zyb21GaWxlcyxcbiAgICAgICAgIG5vbWluYWxGaWxlc0Zyb21GaWxlcyxcbiAgICAgICAgIG1ldGFKU09ORmlsZUZyb21GaWxlcyxcbiAgICAgICAgIGN1c3RvbUdyYW1tYXJCTkZGaWxlc0Zyb21GaWxlcyxcbiAgICAgICAgIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXNGcm9tRmlsZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2ZpbGVzXCI7XG5cbmZ1bmN0aW9uIGdldFJlYWRtZUZpbGUoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICByZWFkbWVGaWxlID0gcmVhZG1lRmlsZUZyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIHJlYWRtZUZpbGU7XG59XG5cbmZ1bmN0aW9uIGdldEZ1cnRsZUZpbGVzKCkge1xuICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgZnVydGxlRmlsZXMgPSBmdXJ0bGVGaWxlc0Zyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIGZ1cnRsZUZpbGVzO1xufVxuXG5mdW5jdGlvbiBnZXROb21pbmFsRmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBub21pbmFsRmlsZXMgPSBub21pbmFsRmlsZXNGcm9tRmlsZXMoZmlsZXMpO1xuXG4gIHJldHVybiBub21pbmFsRmlsZXM7XG59XG5cbmZ1bmN0aW9uIGdldE1ldGFKU09ORmlsZSgpIHtcbiAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKCksXG4gICAgICAgIG1ldGFKU09ORmlsZSA9IG1ldGFKU09ORmlsZUZyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIG1ldGFKU09ORmlsZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VzdG9tR3JhbW1hckJORkZpbGVzKCkge1xuICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVzID0gY3VzdG9tR3JhbW1hckJORkZpbGVzRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gY3VzdG9tR3JhbW1hckJORkZpbGVzO1xufVxuXG5mdW5jdGlvbiBnZXRDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzKCkge1xuICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcyA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXNGcm9tRmlsZXMoZmlsZXMpO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzO1xufVxuXG5jb25zdCBmaWxlc01peGlucyA9IHtcbiAgZ2V0UmVhZG1lRmlsZSxcbiAgZ2V0RnVydGxlRmlsZXMsXG4gIGdldE5vbWluYWxGaWxlcyxcbiAgZ2V0TWV0YUpTT05GaWxlLFxuICBnZXRDdXN0b21HcmFtbWFyQk5GRmlsZXMsXG4gIGdldEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZpbGVzTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXBlbmRlbmN5IHtcbiAgY29uc3RydWN0b3IobmFtZSwgc2hvcnRlbmVkVmVyc2lvbikge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zaG9ydGVuZWRWZXJzaW9uID0gc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldFNob3J0ZWRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNob3J0ZW5lZFZlcnNpb247XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBsZXQgc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuc2hvcnRlbmVkVmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2hvcnRlbmVkVmVyc2lvblN0cmluZyA9IHRoaXMuc2hvcnRlbmVkVmVyc2lvbi50b1N0cmluZygpO1xuXG4gICAgICBzdHJpbmcgPSBgJHt0aGlzLm5hbWV9QCR7c2hvcnRlbmVkVmVyc2lvblN0cmluZ31gO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJpbmcgPSB0aGlzLm5hbWU7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWUobmFtZSkge1xuICAgIGNvbnN0IHNob3J0ZW5lZFZlcnNpb24gPSBudWxsLFxuICAgICAgICAgIGRlcGVuZGVuY3kgPSBuZXcgRGVwZW5kZW5jeShuYW1lLCBzaG9ydGVuZWRWZXJzaW9uKTtcblxuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lQW5kU2hvcnRlbmVkVmVyc2lvbihuYW1lLCBzaG9ydGVuZWRWZXJzaW9uKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jeSA9IG5ldyBEZXBlbmRlbmN5KG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTUFKT1JfTlVNQkVSX01VTFRJUExJRVIsIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSIH0gZnJvbSBcIi4vbXVsdGlwbGVyc1wiO1xuaW1wb3J0IHsgbWFqb3JOdW1iZXJGcm9tTnVtYmVyLCBtaW5vck51bWJlckZyb21OdW1iZXIsIG1ham9yTnVtYmVyRnJvbVN0cmluZywgbWlub3JOdW1iZXJGcm9tU3RyaW5nIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3ZlcnNpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hvcnRlbmVkVmVyc2lvbiB7XG4gIGNvbnN0cnVjdG9yKG1ham9yTnVtYmVyLCBtaW5vck51bWJlcikge1xuICAgIHRoaXMubWFqb3JOdW1iZXIgPSBtYWpvck51bWJlcjtcbiAgICB0aGlzLm1pbm9yTnVtYmVyID0gbWlub3JOdW1iZXI7XG4gIH1cblxuICBnZXRNYWpvck51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYWpvck51bWJlcjtcbiAgfVxuXG4gIGdldE1pbm9yTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLm1pbm9yTnVtYmVyO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gYCR7dGhpcy5tYWpvck51bWJlcn0uJHt0aGlzLm1pbm9yTnVtYmVyfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgdG9WZXJzaW9uTnVtYmVyKCkge1xuICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSB0aGlzLm1ham9yTnVtYmVyICogTUFKT1JfTlVNQkVSX01VTFRJUExJRVIgKyB0aGlzLm1pbm9yTnVtYmVyICogTUlOT1JfTlVNQkVSX01VTFRJUExJRVI7XG5cbiAgICByZXR1cm4gdmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIGdldExlYXN0TWF0Y2hpbmdWZXJzaW9uTnVtYmVyKCkge1xuICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSB0aGlzLnRvVmVyc2lvbk51bWJlcigpLFxuICAgICAgICAgIGxlYXN0TWF0Y2hpbmdWZXJzaW9uTnVtYmVyID0gdmVyc2lvbk51bWJlcjsgLy8vXG5cbiAgICByZXR1cm4gbGVhc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXI7XG4gIH1cblxuICBnZXRHcmVhdGVzdE1hdGNoaW5nVmVyc2lvbk51bWJlcigpIHtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IHRoaXMubWFqb3JOdW1iZXIgKyAxLFxuICAgICAgICAgIG1pbm9yTnVtYmVyID0gMCxcbiAgICAgICAgICBzaG9ydGVuZWRWZXJzaW9uID0gU2hvcnRlbmVkVmVyc2lvbi5mcm9tTWFqb3JOdW1iZXJBbmRNaW5vck51bWJlcihtYWpvck51bWJlciwgbWlub3JOdW1iZXIpLFxuICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb25OdW1iZXIgPSBzaG9ydGVuZWRWZXJzaW9uLnRvVmVyc2lvbk51bWJlcigpLFxuICAgICAgICAgIGdyZWF0ZXN0TWF0Y2hpbmdWZXJzaW9uTnVtYmVyID0gc2hvcnRlbmVkVmVyc2lvbk51bWJlciAtIDE7XG5cbiAgICByZXR1cm4gZ3JlYXRlc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXI7XG4gIH1cblxuICBzdGF0aWMgZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IG1ham9yTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgIG1pbm9yTnVtYmVyID0gbWlub3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IG5ldyBTaG9ydGVuZWRWZXJzaW9uKG1ham9yTnVtYmVyLCBtaW5vck51bWJlcik7XG5cbiAgICByZXR1cm4gc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVyc2lvbk51bWJlcih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgY29uc3QgbnVtYmVyID0gdmVyc2lvbk51bWJlciwgLy8vXG4gICAgICAgICAgbWFqb3JOdW1iZXIgPSBtYWpvck51bWJlckZyb21OdW1iZXIobnVtYmVyKSxcbiAgICAgICAgICBtaW5vck51bWJlciA9IG1pbm9yTnVtYmVyRnJvbU51bWJlcihudW1iZXIpLFxuICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb24gPSBuZXcgU2hvcnRlbmVkVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIpO1xuXG4gICAgcmV0dXJuIHNob3J0ZW5lZFZlcnNpb247XG4gIH1cblxuICBzdGF0aWMgZnJvbU1ham9yTnVtYmVyQW5kTWlub3JOdW1iZXIobWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKSB7XG4gICAgY29uc3Qgc2hvcnRlbmVkVmVyc2lvbiA9IG5ldyBTaG9ydGVuZWRWZXJzaW9uKG1ham9yTnVtYmVyLCBtaW5vck51bWJlcik7XG5cbiAgICByZXR1cm4gc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBEZXBlbmRlbmN5IGZyb20gXCIuL2RlcGVuZGVuY3lcIjtcbmltcG9ydCBTaG9ydGVuZWRWZXJzaW9uIGZyb20gXCIuL3Nob3J0ZW5lZFZlcnNpb25cIjtcblxuY29uc3QgeyBmb3JFYWNoIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlcGVuZGVuY2llcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBhZGREZXBlbmRlbmN5KGRlcGVuZGVuY3kpIHsgdGhpcy5hcnJheS5wdXNoKGRlcGVuZGVuY3kpOyB9XG5cbiAgbWFwRGVwZW5kZW5jeShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5tYXAoY2FsbGJhY2spOyB9XG5cbiAgZXZlcnlEZXBlbmRlbmN5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5LmV2ZXJ5KGNhbGxiYWNrKTsgfVxuXG4gIHJlZHVjZURlcGVuZGVuY3koY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkgeyByZXR1cm4gdGhpcy5hcnJheS5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7IH1cblxuICBmb3JFYWNoRGVwZW5kZW5jeShjYWxsYmFjaykgeyB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spOyB9XG5cbiAgYXN5bmNocm9ub3VzRm9yRWFjaERlcGVuZGVuY3kob3BlcmF0aW9uLCBkb25lKSB7IGZvckVhY2godGhpcy5hcnJheSwgb3BlcmF0aW9uLCBkb25lKTsgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXNKU09OID0gdGhpcy5hcnJheS5yZWR1Y2UoKGRlcGVuZGVuY2llc0pTT04sIGRlcGVuZGVuY3kpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb24gPSBkZXBlbmRlbmN5LmdldFNob3J0ZWRWZXJzaW9uKCksXG4gICAgICAgICAgICAgICAgICBzaG9ydGVuZWRWZXJzaW9uU3RyaW5nID0gc2hvcnRlbmVkVmVyc2lvbi50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXNKU09OW25hbWVdID0gc2hvcnRlbmVkVmVyc2lvblN0cmluZztcbiAgXG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzSlNPTjtcbiAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAganNvbiA9IGRlcGVuZGVuY2llc0pTT047IC8vL1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llc0pTT04gPSBqc29uLCAvLy9cbiAgICAgICAgICBkZXBlbmRlbmNpZXNKU09OS2V5cyA9IE9iamVjdC5rZXlzKGRlcGVuZGVuY2llc0pTT04pLFxuICAgICAgICAgIG5hbWVzID0gZGVwZW5kZW5jaWVzSlNPTktleXMsIC8vL1xuICAgICAgICAgIGFycmF5ID0gbmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaG9ydGVuZWRWZXJzaW9uU3RyaW5nID0gZGVwZW5kZW5jaWVzSlNPTltuYW1lXSxcbiAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHNob3J0ZW5lZFZlcnNpb25TdHJpbmcsICAvLy9cbiAgICAgICAgICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb24gPSBTaG9ydGVuZWRWZXJzaW9uLmZyb21TdHJpbmcoc3RyaW5nKSxcbiAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBEZXBlbmRlbmN5LmZyb21OYW1lQW5kU2hvcnRlbmVkVmVyc2lvbihuYW1lLCBzaG9ydGVuZWRWZXJzaW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGVwZW5kZW5jaWVzID0gbmV3IERlcGVuZGVuY2llcyhhcnJheSk7XG5cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgZGVwZW5kZW5jaWVzID0gbmV3IERlcGVuZGVuY2llcyhhcnJheSk7XG5cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlUXVlcnkoZXhwcmVzc2lvblN0cmluZykge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgbm9kZSA9IG5vZGVzLnNoaWZ0KCkgfHwgbnVsbDsgLy8vXG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnkoZXhwcmVzc2lvblN0cmluZykge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdWZXJzaW9uU3RyaW5nKHN0cmluZykgeyByZXR1cm4gLyg/OjB8KFsxLTldXFxkKikpXFwuKD86MHwoWzEtOV1cXGQqKSlcXC4oPzowfChbMS05XVxcZCopKS8udGVzdChzdHJpbmcpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ1Nob3J0ZW5lZFZlcnNpb25TdHJpbmcoc3RyaW5nKSB7IHJldHVybiAvKD86MHwoWzEtOV1cXGQqKSlcXC4oPzowfChbMS05XVxcZCopKS8udGVzdChzdHJpbmcpOyB9XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OX1BST1BFUlRZX05BTUUgPSBcInZlcnNpb25cIjtcbmV4cG9ydCBjb25zdCBSRVBPU0lUT1JZX1BST1BFUlRZX05BTUUgPSBcInJlcG9zaXRvcnlcIjtcbmV4cG9ydCBjb25zdCBERVBFTkRFTkNJRVNfUFJPUEVSVFlfTkFNRSA9IFwiZGVwZW5kZW5jaWVzXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEpTT05MZXhlciwgSlNPTlBhcnNlciB9IGZyb20gXCJvY2NhbS1ncmFtbWFyc1wiO1xuXG5pbXBvcnQgVmVyc2lvbiBmcm9tIFwiLi4vdmVyc2lvblwiO1xuaW1wb3J0IERlcGVuZGVuY3kgZnJvbSBcIi4uL2RlcGVuZGVuY3lcIjtcbmltcG9ydCBEZXBlbmRlbmNpZXMgZnJvbSBcIi4uL2RlcGVuZGVuY2llc1wiO1xuaW1wb3J0IFNob3J0ZW5lZFZlcnNpb24gZnJvbSBcIi4uL3Nob3J0ZW5lZFZlcnNpb25cIjtcblxuaW1wb3J0IHsgRE9VQkxFX1NQQUNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgdHJpbURvdWJsZVF1b3RlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29udGVudFwiO1xuaW1wb3J0IHsgbm9kZVF1ZXJ5LCBub2Rlc1F1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgaXNTdHJpbmdWZXJzaW9uU3RyaW5nLCBpc1N0cmluZ1Nob3J0ZW5lZFZlcnNpb25TdHJpbmcgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ZhbGlkYXRlXCI7XG5pbXBvcnQgeyBWRVJTSU9OX1BST1BFUlRZX05BTUUsIFJFUE9TSVRPUllfUFJPUEVSVFlfTkFNRSwgREVQRU5ERU5DSUVTX1BST1BFUlRZX05BTUUgfSBmcm9tIFwiLi4vcHJvcGVydHlOYW1lc1wiO1xuXG5jb25zdCBqc29uTGV4ZXIgPSBKU09OTGV4ZXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgIGpzb25QYXJzZXIgPSBKU09OUGFyc2VyLmZyb21Ob3RoaW5nKCk7XG5cbmNvbnN0IGVycm9yTm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvKi9lcnJvclwiKSxcbiAgICAgIHByb3BlcnR5Tm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvcHJvcGVydHkvanNvbi9vYmplY3QvcHJvcGVydHlcIiksXG4gICAgICBkb2N1bWVudFByb3BlcnR5Tm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvZG9jdW1lbnQvanNvbi9vYmplY3QvcHJvcGVydHlcIiksXG4gICAgICBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9wcm9wZXJ0eS9Ac3RyaW5nLWxpdGVyYWxcIiksXG4gICAgICBwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvcHJvcGVydHkvanNvbi9Ac3RyaW5nLWxpdGVyYWwhXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRhSlNPTkZpbGVWYWxpZChtZXRhSlNPTkZpbGUpIHtcbiAgbGV0IG1ldGFKU09ORmlsZVZhbGlkID0gZmFsc2U7XG5cbiAgY29uc3QgZG9jdW1lbnROb2RlID0gZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZShtZXRhSlNPTkZpbGUpO1xuXG4gIGlmIChkb2N1bWVudE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBlcnJvck5vZGVzID0gZXJyb3JOb2Rlc1F1ZXJ5KGRvY3VtZW50Tm9kZSksXG4gICAgICAgICAgZXJyb3JOb2Rlc0xlbmd0aCA9IGVycm9yTm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKGVycm9yTm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpLFxuICAgICAgICAgICAgcmVwb3NpdG9yeSA9IHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSksXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgICAgIG1ldGFKU09ORmlsZVZhbGlkID0gKCh2ZXJzaW9uICE9PSBudWxsKSAmJiAocmVwb3NpdG9yeSAhPT0gbnVsbCkgJiYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRhSlNPTkZpbGVWYWxpZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1ldGFKU09ORmlsZVZlcnNpb24obWV0YUpTT05GaWxlLCB2ZXJzaW9uKSB7XG4gIGNvbnN0IGRvY3VtZW50Tm9kZSA9IGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSxcbiAgICAgICAgcmVwb3NpdG9yeSA9IHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgbGV0IGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBjb25zdCBzdHJpbmcgPSB2ZXJzaW9uLnRvU3RyaW5nKCksXG4gICAgICAgIGRlcGVuZGVuY2llc0pTT04gPSBkZXBlbmRlbmNpZXMudG9KU09OKCk7XG5cbiAgdmVyc2lvbiA9IHN0cmluZzsgIC8vL1xuXG4gIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc0pTT047ICAvLy9cblxuICBjb25zdCBtZXRhSlNPTiA9IHtcbiAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgIHJlcG9zaXRvcnksXG4gICAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFKU09OU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkobWV0YUpTT04sIG51bGwsIERPVUJMRV9TUEFDRSksXG4gICAgICAgIG1ldGFKU09ORmlsZUNvbnRlbnQgPSBtZXRhSlNPTlN0cmluZzsgLy8vXG5cbiAgbWV0YUpTT05GaWxlLnNldENvbnRlbnQobWV0YUpTT05GaWxlQ29udGVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSkge1xuICBsZXQgZG9jdW1lbnROb2RlID0gbnVsbDtcblxuICBpZiAobWV0YUpTT05GaWxlICE9PSBudWxsKSB7XG4gICAgY29uc3QgY29udGVudCA9IG1ldGFKU09ORmlsZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgdG9rZW5zID0ganNvbkxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIG5vZGUgPSBqc29uUGFyc2VyLnBhcnNlKHRva2Vucyk7XG5cbiAgICBkb2N1bWVudE5vZGUgPSBub2RlOyAgLy8vXG4gIH1cblxuICByZXR1cm4gZG9jdW1lbnROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVyc2lvbkZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSB7XG4gIGxldCB2ZXJzaW9uID0gbnVsbDtcblxuICBjb25zdCBkb2N1bWVudFByb3BlcnR5Tm9kZXMgPSBkb2N1bWVudFByb3BlcnR5Tm9kZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgZG9jdW1lbnRQcm9wZXJ0eU5vZGVzLnNvbWUoKGRvY3VtZW50UHJvcGVydHlOb2RlKSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZG9jdW1lbnRQcm9wZXJ0eU5vZGUsICAvLy9cbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSk7XG5cbiAgICBpZiAocHJvcGVydHlOYW1lID09PSBWRVJTSU9OX1BST1BFUlRZX05BTUUpIHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgc3RyaW5nVmVyc2lvblN0cmluZyA9IGlzU3RyaW5nVmVyc2lvblN0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChzdHJpbmdWZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IFZlcnNpb24uZnJvbVN0cmluZyhzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdmVyc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBsZXQgcmVwb3NpdG9yeSA9IG51bGw7XG5cbiAgY29uc3QgZG9jdW1lbnRQcm9wZXJ0eU5vZGVzID0gZG9jdW1lbnRQcm9wZXJ0eU5vZGVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIGRvY3VtZW50UHJvcGVydHlOb2Rlcy5zb21lKChkb2N1bWVudFByb3BlcnR5Tm9kZSkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IGRvY3VtZW50UHJvcGVydHlOb2RlLCAgLy8vXG4gICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gUkVQT1NJVE9SWV9QUk9QRVJUWV9OQU1FKSB7XG4gICAgICBjb25zdCBzdHJpbmdQcm9wZXJ0eVZhbHVlID0gc3RyaW5nUHJvcGVydHlWYWx1ZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgICAgaWYgKHN0cmluZ1Byb3BlcnR5VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmVwb3NpdG9yeSA9IHN0cmluZ1Byb3BlcnR5VmFsdWU7ICAvLy9cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXBvc2l0b3J5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVwZW5kZW5jaWVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpIHtcbiAgbGV0IGRlcGVuZGVuY2llcyA9IG51bGw7XG5cbiAgY29uc3QgZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlID0gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIGlmIChkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgIT09IG51bGwpIHtcbiAgICBkZXBlbmRlbmNpZXMgPSBEZXBlbmRlbmNpZXMuZnJvbU5vdGhpbmcoKTtcblxuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZSwgIC8vL1xuICAgICAgICAgIHByb3BlcnR5Tm9kZXMgPSBwcm9wZXJ0eU5vZGVzUXVlcnkocHJvcGVydHlOb2RlKTtcblxuICAgIHByb3BlcnR5Tm9kZXMuZm9yRWFjaCgocHJvcGVydHlOb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdHJpbmdQcm9wZXJ0eVZhbHVlID0gc3RyaW5nUHJvcGVydHlWYWx1ZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgICAgaWYgKHN0cmluZ1Byb3BlcnR5VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gc3RyaW5nUHJvcGVydHlWYWx1ZSwgLy8vXG4gICAgICAgICAgICAgIHN0cmluZ1Nob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBpc1N0cmluZ1Nob3J0ZW5lZFZlcnNpb25TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICBpZiAoc3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZykge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKSxcbiAgICAgICAgICAgICAgICBuYW1lID0gcHJvcGVydHlOYW1lLCAgLy8vXG4gICAgICAgICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IFNob3J0ZW5lZFZlcnNpb24uZnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBEZXBlbmRlbmN5LmZyb21OYW1lQW5kU2hvcnRlbmVkVmVyc2lvbihuYW1lLCBzaG9ydGVuZWRWZXJzaW9uKTtcblxuICAgICAgICAgIGRlcGVuZGVuY2llcy5hZGREZXBlbmRlbmN5KGRlcGVuZGVuY3kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVwZW5kZW5jeU5hbWVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpIHtcbiAgbGV0IGRlcGVuZGVuY3lOYW1lcyA9IG51bGw7XG5cbiAgY29uc3QgZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlID0gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIGlmIChkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgIT09IG51bGwpIHtcbiAgICBkZXBlbmRlbmN5TmFtZXMgPSBbXTtcblxuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZSwgIC8vL1xuICAgICAgICAgIHByb3BlcnR5Tm9kZXMgPSBwcm9wZXJ0eU5vZGVzUXVlcnkocHJvcGVydHlOb2RlKTtcblxuICAgIHByb3BlcnR5Tm9kZXMuZm9yRWFjaCgocHJvcGVydHlOb2RlKSA9PiB7XG4gICAgICBjb25zdCBzdHJpbmdQcm9wZXJ0eVZhbHVlID0gc3RyaW5nUHJvcGVydHlWYWx1ZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgICAgaWYgKHN0cmluZ1Byb3BlcnR5VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gc3RyaW5nUHJvcGVydHlWYWx1ZSwgLy8vXG4gICAgICAgICAgICAgIHN0cmluZ1Nob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBpc1N0cmluZ1Nob3J0ZW5lZFZlcnNpb25TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICBpZiAoc3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZykge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKSxcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSA9IHByb3BlcnR5TmFtZTsgIC8vL1xuXG4gICAgICAgICAgZGVwZW5kZW5jeU5hbWVzLnB1c2goZGVwZW5kZW5jeU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jeU5hbWVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzTWV0YUpTT05GaWxlVmFsaWQsXG4gIHVwZGF0ZU1ldGFKU09ORmlsZVZlcnNpb24sXG4gIGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUsXG4gIHZlcnNpb25Gcm9tRG9jdW1lbnROb2RlLFxuICByZXBvc2l0b3J5RnJvbURvY3VtZW50Tm9kZSxcbiAgZGVwZW5kZW5jaWVzRnJvbURvY3VtZW50Tm9kZSxcbiAgZGVwZW5kZW5jeU5hbWVzRnJvbURvY3VtZW50Tm9kZVxufTtcblxuZnVuY3Rpb24gcHJvcGVydHlOYW1lRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpIHtcbiAgY29uc3QgcHJvcGVydHlTdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlID0gcHJvcGVydHlTdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlUXVlcnkocHJvcGVydHlOb2RlKSxcbiAgICAgICAgcHJvcGVydHlTdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlQ29udGVudCA9IHByb3BlcnR5U3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IHRyaW1Eb3VibGVRdW90ZXMocHJvcGVydHlTdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlQ29udGVudCk7IC8vL1xuXG4gIHJldHVybiBwcm9wZXJ0eU5hbWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1Byb3BlcnR5VmFsdWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSkge1xuICBsZXQgc3RyaW5nUHJvcGVydHlWYWx1ZSA9IG51bGw7XG5cbiAgY29uc3QgcHJvcGVydHlKU09OU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZSA9IHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVRdWVyeShwcm9wZXJ0eU5vZGUpO1xuXG4gIGlmIChwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgcHJvcGVydHlKU09OU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZUNvbnRlbnQgPSBwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgIHN0cmluZ1Byb3BlcnR5VmFsdWUgPSB0cmltRG91YmxlUXVvdGVzKHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVDb250ZW50KTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3RyaW5nUHJvcGVydHlWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZG9jdW1lbnRQcm9wZXJ0eU5vZGVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpIHtcbiAgY29uc3QgZG9jdW1lbnRQcm9wZXJ0eU5vZGVzID0gZG9jdW1lbnRQcm9wZXJ0eU5vZGVzUXVlcnkoZG9jdW1lbnROb2RlKTtcblxuICByZXR1cm4gZG9jdW1lbnRQcm9wZXJ0eU5vZGVzO1xufVxuXG5mdW5jdGlvbiBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGVGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBsZXQgZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlID0gbnVsbDtcblxuICBjb25zdCBkb2N1bWVudFByb3BlcnR5Tm9kZXMgPSBkb2N1bWVudFByb3BlcnR5Tm9kZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgZG9jdW1lbnRQcm9wZXJ0eU5vZGVzLnNvbWUoKGRvY3VtZW50UHJvcGVydHlOb2RlKSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZG9jdW1lbnRQcm9wZXJ0eU5vZGUsICAvLy9cbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSk7XG5cbiAgICBpZiAocHJvcGVydHlOYW1lID09PSBERVBFTkRFTkNJRVNfUFJPUEVSVFlfTkFNRSkge1xuICAgICAgZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlID0gcHJvcGVydHlOb2RlOyAgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgdmVyc2lvbkZyb21Eb2N1bWVudE5vZGUsIHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlLCBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlLCBkZXBlbmRlbmN5TmFtZXNGcm9tRG9jdW1lbnROb2RlLCBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9tZXRhSlNPTlwiO1xuXG5mdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICBjb25zdCBtZXRhSlNPTkZpbGUgPSB0aGlzLmdldE1ldGFKU09ORmlsZSgpLFxuICAgICAgICBkb2N1bWVudE5vZGUgPSBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSksXG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5mdW5jdGlvbiBnZXRSZXBvc2l0b3J5KCkge1xuICBjb25zdCBtZXRhSlNPTkZpbGUgPSB0aGlzLmdldE1ldGFKU09ORmlsZSgpLFxuICAgICAgICBkb2N1bWVudE5vZGUgPSBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSksXG4gICAgICAgIHJlcG9zaXRvcnkgPSByZXBvc2l0b3J5RnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIHJldHVybiByZXBvc2l0b3J5O1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoKSB7XG4gIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgIGRvY3VtZW50Tm9kZSA9IGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSxcbiAgICAgICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lOYW1lcygpIHtcbiAgY29uc3QgbWV0YUpTT05GaWxlID0gdGhpcy5nZXRNZXRhSlNPTkZpbGUoKSxcbiAgICAgICAgZG9jdW1lbnROb2RlID0gZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZShtZXRhSlNPTkZpbGUpLFxuICAgICAgICBkZXBlbmRlbmN5TmFtZXMgPSBkZXBlbmRlbmN5TmFtZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGRlcGVuZGVuY3lOYW1lcztcbn1cblxuY29uc3QgbWV0YUpTT05NaXhpbnMgPSB7XG4gIGdldFZlcnNpb24sXG4gIGdldFJlcG9zaXRvcnksXG4gIGdldERlcGVuZGVuY2llcyxcbiAgZ2V0RGVwZW5kZW5jeU5hbWVzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZXRhSlNPTk1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZmlsZU5hbWVGcm9tRmlsZVBhdGggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL25hbWVcIjtcbmltcG9ydCB7IFRZUEVfVk9DQUJVTEFSWV9GSUxFX05BTUUsIFNZTUJPTF9WT0NBQlVMQVJZX0ZJTEVfTkFNRSB9IGZyb20gXCIuLi9maWxlTmFtZXNcIjtcblxuZnVuY3Rpb24gZ2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5RmlsZU5hbWUpIHtcbiAgbGV0IHZvY2FidWxhcnkgPSBFTVBUWV9TVFJJTkc7XG5cbiAgY29uc3QgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcyA9IHRoaXMuZ2V0Q3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzLmZpbmQoKGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSkgPT4ge1xuICAgICAgICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlTmFtZSA9IGZpbGVOYW1lRnJvbUZpbGVQYXRoKGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGgpO1xuXG4gICAgICAgIGlmIChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVOYW1lID09PSB2b2NhYnVsYXJ5RmlsZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlICE9PSBudWxsKSB7XG4gICAgY29uc3QgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlQ29udGVudCA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZS5nZXRDb250ZW50KCk7XG5cbiAgICB2b2NhYnVsYXJ5ID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlQ29udGVudDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIHZvY2FidWxhcnk7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGVWb2NhYnVsYXJ5KCkge1xuICBjb25zdCBmaWxlTmFtZSA9IFRZUEVfVk9DQUJVTEFSWV9GSUxFX05BTUUsIC8vL1xuICAgICAgICB2b2NhYnVsYXJ5ID0gdGhpcy5nZXRWb2NhYnVsYXJ5KGZpbGVOYW1lKSxcbiAgICAgICAgdHlwZVZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5OyAgLy8vXG5cbiAgcmV0dXJuIHR5cGVWb2NhYnVsYXJ5O1xufVxuXG5mdW5jdGlvbiBnZXRTeW1ib2xWb2NhYnVsYXJ5KCkge1xuICBjb25zdCBmaWxlTmFtZSA9IFNZTUJPTF9WT0NBQlVMQVJZX0ZJTEVfTkFNRSwgLy8vXG4gICAgICAgIHZvY2FidWxhcnkgPSB0aGlzLmdldFZvY2FidWxhcnkoZmlsZU5hbWUpLFxuICAgICAgICBzeW1ib2xWb2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTsgIC8vL1xuXG4gIHJldHVybiBzeW1ib2xWb2NhYnVsYXJ5O1xufVxuXG5jb25zdCB2b2NhYnVsYXJ5TWl4aW5zID0gIHtcbiAgZ2V0Vm9jYWJ1bGFyeSxcbiAgZ2V0VHlwZVZvY2FidWxhcnksXG4gIGdldFN5bWJvbFZvY2FidWxhcnlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHZvY2FidWxhcnlNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhdGhVdGlsaXRpZXMsIGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgRmlsZSBmcm9tIFwiLi9maWxlXCI7XG5pbXBvcnQgRmlsZXMgZnJvbSBcIi4vZmlsZXNcIjtcbmltcG9ydCBEaXJlY3RvcnkgZnJvbSBcIi4vZGlyZWN0b3J5XCI7XG5pbXBvcnQgYm5mTWl4aW5zIGZyb20gXCIuL21peGlucy9ibmZcIjtcbmltcG9ydCBmaWxlc01peGlucyBmcm9tIFwiLi9taXhpbnMvZmlsZXNcIjtcbmltcG9ydCBtZXRhSlNPTk1peGlucyBmcm9tIFwiLi9taXhpbnMvbWV0YUpTT05cIjtcbmltcG9ydCB2b2NhYnVsYXJ5TWl4aW5zIGZyb20gXCIuL21peGlucy92b2NhYnVsYXJ5XCI7XG5cbmNvbnN0IHsgZmlyc3QsIGZpbHRlciB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGggfSA9IHBhdGhVdGlsaXRpZXM7XG5cbmNsYXNzIEVudHJpZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgZ2V0VG9wbW9zdERpcmVjdG9yeU5hbWUoKSB7XG4gICAgbGV0IHRvcG1vc3REaXJlY3RvcnlOYW1lID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBmaXJzdEVudHJ5ID0gZmlyc3QodGhpcy5hcnJheSk7IC8vL1xuXG4gICAgaWYgKGZpcnN0RW50cnkpIHsgLy8vXG4gICAgICBjb25zdCBmaXJzdEVudHJ5UGF0aCA9IGZpcnN0RW50cnkuZ2V0UGF0aCgpO1xuXG4gICAgICB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IHRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGgoZmlyc3RFbnRyeVBhdGgpO1xuXG4gICAgICBpZiAodG9wbW9zdERpcmVjdG9yeU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBmaXJzdEVudHJ5UGF0aDsgIC8vL1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3Btb3N0RGlyZWN0b3J5TmFtZTtcbiAgfVxuXG4gIHJlbW92ZUZpbGVCeVBhdGgocGF0aCkge1xuICAgIGZpbHRlcih0aGlzLmFycmF5LCAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5RmlsZSA9IGVudHJ5LmlzRmlsZSgpO1xuXG4gICAgICBpZiAoZW50cnlGaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBlbnRyeSwgLy8vXG4gICAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCk7XG5cbiAgICAgICAgaWYgKGZpbGVQYXRoID09PSBwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgZmluZEZpbGUoZmlsZVBhdGgpIHtcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgICBmaWxlID0gZmlsZXMuZmluZEZpbGUoKGZpbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoTWF0Y2hlcyA9IGZpbGUubWF0Y2hGaWxlUGF0aChmaWxlUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlUGF0aE1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkgfHwgbnVsbDtcblxuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgZ2V0RmlsZXMoKSB7XG4gICAgY29uc3QgZmlsZXMgPSBGaWxlcy5mcm9tTm90aGluZygpO1xuXG4gICAgdGhpcy5tYXBFbnRyeSgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5RmlsZSA9IGVudHJ5LmlzRmlsZSgpO1xuXG4gICAgICBpZiAoZW50cnlGaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBlbnRyeTsgLy8vXG5cbiAgICAgICAgZmlsZXMuYWRkRmlsZShmaWxlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmaWxlcztcbiAgfVxuXG4gIGdldEZpbGVQYXRocygpIHtcbiAgICBjb25zdCBmaWxlUGF0aHMgPSB0aGlzLnJlZHVjZUVudHJ5KChmaWxlUGF0aHMsIGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBlbnRyeUZpbGUgPSBlbnRyeS5pc0ZpbGUoKTtcblxuICAgICAgaWYgKGVudHJ5RmlsZSkge1xuICAgICAgICBjb25zdCBmaWxlID0gZW50cnksIC8vL1xuICAgICAgICAgICAgICBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpO1xuXG4gICAgICAgIGZpbGVQYXRocy5wdXNoKGZpbGVQYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbGVQYXRocztcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gZmlsZVBhdGhzO1xuICB9XG5cbiAgZ2V0RGlyZWN0b3J5UGF0aHMoKSB7XG4gICAgY29uc3QgZGlyZWN0b3J5UGF0aHMgPSB0aGlzLnJlZHVjZUVudHJ5KChkaXJlY3RvcnlQYXRocywgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5RGlyZWN0b3J5ID0gZW50cnkuaXNEaXJlY3RvcnkoKTtcblxuICAgICAgaWYgKGVudHJ5RGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IGVudHJ5LCAvLy9cbiAgICAgICAgICAgICAgZGlyZWN0b3J5UGF0aCA9IGRpcmVjdG9yeS5nZXRQYXRoKCk7XG5cbiAgICAgICAgZGlyZWN0b3J5UGF0aHMucHVzaChkaXJlY3RvcnlQYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcmVjdG9yeVBhdGhzO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBkaXJlY3RvcnlQYXRocztcbiAgfVxuXG4gIG1hdGNoU2hvcnRlbmVkVmVyc2lvbihzaG9ydGVuZWRWZXJzaW9uKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRoaXMuZ2V0VmVyc2lvbigpLFxuICAgICAgICAgIHZlcnNpb25NYXRjaGVzU2hvcnRlbmVkVmVyc2lvbiA9IHZlcnNpb24ubWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgcmV0dXJuIHZlcnNpb25NYXRjaGVzU2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIGFkZEZpbGUoZmlsZSkge1xuICAgIGNvbnN0IGVudHJ5ID0gZmlsZTsgLy8vXG5cbiAgICB0aGlzLmFkZEVudHJ5KGVudHJ5KTtcbiAgfVxuXG4gIGFkZEVudHJ5KGVudHJ5KSB7IHRoaXMuYXJyYXkucHVzaChlbnRyeSk7IH1cblxuICBhZGREaXJlY3RvcnkoZGlyZWN0b3J5KSB7XG4gICAgY29uc3QgZW50cnkgPSBkaXJlY3Rvcnk7ICAvLy9cblxuICAgIHRoaXMuYWRkRW50cnkoZW50cnkpO1xuICB9XG5cbiAgZm9yRWFjaEZpbGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKTtcblxuICAgIGZpbGVzLmZvckVhY2hGaWxlKGNhbGxiYWNrKTtcbiAgfVxuXG4gIG1hcEVudHJ5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICBzb21lRW50cnkoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICBldmVyeUVudHJ5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5LmV2ZXJ5KGNhbGxiYWNrKTsgfVxuXG4gIGZvckVhY2hFbnRyeShjYWxsYmFjaykgeyB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spOyB9XG5cbiAgcmVkdWNlRW50cnkoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkgeyByZXR1cm4gdGhpcy5hcnJheS5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7IH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZW50cmllc0pTT04gPSB0aGlzLmFycmF5Lm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5SlNPTiA9IGVudHJ5LnRvSlNPTigpO1xuICBcbiAgICAgICAgICAgIHJldHVybiBlbnRyeUpTT047XG4gICAgICAgICAgfSksXG4gICAgICAgICAganNvbiA9IGVudHJpZXNKU09OOyAvLy9cblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBjb25zdCBhcnJheSA9IFtdLFxuICAgICAgICAgIGVudHJpZXMgPSBuZXcgRW50cmllcyhhcnJheSksXG4gICAgICAgICAgZW50cmllc0pTT04gPSBqc29uOyAvLy9cblxuICAgIGVudHJpZXNKU09OLm1hcCgoZW50cnlKU09OKSA9PiB7XG4gICAgICBjb25zdCBqc29uID0gZW50cnlKU09OLCAvLy9cbiAgICAgICAgICAgIGZpbGUgPSBGaWxlLmZyb21KU09OKGpzb24pLFxuICAgICAgICAgICAgZGlyZWN0b3J5ID0gRGlyZWN0b3J5LmZyb21KU09OKGpzb24pLFxuICAgICAgICAgICAgZW50cnkgPSBmaWxlIHx8IGRpcmVjdG9yeTsgIC8vL1xuXG4gICAgICBlbnRyaWVzLmFkZEVudHJ5KGVudHJ5KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21FbnRyeShlbnRyeSkge1xuICAgIGNvbnN0IGFycmF5ID0gW1xuICAgICAgICAgICAgZW50cnlcbiAgICAgICAgICBdLFxuICAgICAgICAgIGVudHJpZXMgPSBuZXcgRW50cmllcyhhcnJheSk7XG5cbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdLFxuICAgICAgICAgIGVudHJpZXMgPSBuZXcgRW50cmllcyhhcnJheSk7XG5cbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCBibmZNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbnRyaWVzLnByb3RvdHlwZSwgZmlsZXNNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbnRyaWVzLnByb3RvdHlwZSwgbWV0YUpTT05NaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbnRyaWVzLnByb3RvdHlwZSwgdm9jYWJ1bGFyeU1peGlucyk7XG5cbmV4cG9ydCBkZWZhdWx0IEVudHJpZXM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGZvckVhY2hGaWxlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZm9yRWFjaEZpbGUoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZpbmRGaWxlKGZpbGVQYXRoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZmluZEZpbGUoZmlsZVBhdGgpOyB9XG5cbmZ1bmN0aW9uIGdldEJORigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRCTkYoKTsgfVxuXG5mdW5jdGlvbiBnZXRGaWxlcygpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRGaWxlcygpOyB9XG5cbmZ1bmN0aW9uIGdldFRlcm1CTkYoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0VGVybUJORigpOyB9XG5cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0VmVyc2lvbigpOyB9XG5cbmZ1bmN0aW9uIGdldEZpbGVQYXRocygpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRGaWxlUGF0aHMoKTsgfVxuXG5mdW5jdGlvbiBnZXRWb2NhYnVsYXJ5KCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldFZvY2FidWxhcnkoKTsgfVxuXG5mdW5jdGlvbiBnZXRSZXBvc2l0b3J5KCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldFJlcG9zaXRvcnkoKTsgfVxuXG5mdW5jdGlvbiBnZXRSZWFkbWVGaWxlKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldFJlYWRtZUZpbGUoKTsgfVxuXG5mdW5jdGlvbiBnZXRTdGF0ZW1lbnRCTkYoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0U3RhdGVtZW50Qk5GKCk7IH1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldERlcGVuZGVuY2llcygpOyB9XG5cbmZ1bmN0aW9uIGdldFR5cGVWb2NhYnVsYXJ5KCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldFR5cGVWb2NhYnVsYXJ5KCk7IH1cblxuZnVuY3Rpb24gZ2V0U3ltYm9sVm9jYWJ1bGFyeSgpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRTeW1ib2xWb2NhYnVsYXJ5KCk7IH1cblxuZnVuY3Rpb24gZ2V0TWV0YUpTT05GaWxlKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldE1ldGFKU09ORmlsZSgpOyB9XG5cbmZ1bmN0aW9uIGdldEZ1cnRsZUZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEZ1cnRsZUZpbGVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0Tm9taW5hbEZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldE5vbWluYWxGaWxlcygpOyB9XG5cbmZ1bmN0aW9uIGdldERpcmVjdG9yeVBhdGhzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldERpcmVjdG9yeVBhdGhzKCk7IH1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeU5hbWVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldERlcGVuZGVuY3lOYW1lcygpOyB9XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcygpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRDdXN0b21HcmFtbWFyQk5GRmlsZXMoKTsgfVxuXG5mdW5jdGlvbiBnZXRDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMoKTsgfVxuXG5jb25zdCBlbnRyaWVzTWl4aW5zID0ge1xuICBmb3JFYWNoRmlsZSxcbiAgZmluZEZpbGUsXG4gIGdldEJORixcbiAgZ2V0RmlsZXMsXG4gIGdldFRlcm1CTkYsXG4gIGdldFZlcnNpb24sXG4gIGdldEZpbGVQYXRocyxcbiAgZ2V0Vm9jYWJ1bGFyeSxcbiAgZ2V0UmVwb3NpdG9yeSxcbiAgZ2V0UmVhZG1lRmlsZSxcbiAgZ2V0U3RhdGVtZW50Qk5GLFxuICBnZXREZXBlbmRlbmNpZXMsXG4gIGdldFR5cGVWb2NhYnVsYXJ5LFxuICBnZXRTeW1ib2xWb2NhYnVsYXJ5LFxuICBnZXRNZXRhSlNPTkZpbGUsXG4gIGdldEZ1cnRsZUZpbGVzLFxuICBnZXROb21pbmFsRmlsZXMsXG4gIGdldERpcmVjdG9yeVBhdGhzLFxuICBnZXREZXBlbmRlbmN5TmFtZXMsXG4gIGdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcyxcbiAgZ2V0Q3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZW50cmllc01peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xuaW1wb3J0IGVudHJpZXNNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2VudHJpZXNcIjtcblxuY2xhc3MgUHJvamVjdCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGVudHJpZXMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXM7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZW50cmllc0pTT04gPSB0aGlzLmVudHJpZXMudG9KU09OKCksXG4gICAgICAgICAgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgICBlbnRyaWVzID0gZW50cmllc0pTT04sICAvLy9cbiAgICAgICAgICBqc29uID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVudHJpZXNcbiAgICAgICAgICB9O1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGxldCB7IGVudHJpZXMgfSA9IGpzb247XG5cbiAgICBjb25zdCB7IG5hbWUgfSA9IGpzb24sXG4gICAgICAgICAgZW50cmllc0pTT04gPSBlbnRyaWVzOyAgLy8vXG5cbiAgICBqc29uID0gZW50cmllc0pTT047IC8vL1xuXG4gICAgZW50cmllcyA9IEVudHJpZXMuZnJvbUpTT04oanNvbik7IC8vL1xuXG4gICAgY29uc3QgcHJvamVjdCA9IG5ldyBQcm9qZWN0KG5hbWUsIGVudHJpZXMpO1xuXG4gICAgcmV0dXJuIHByb2plY3Q7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWUobmFtZSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBFbnRyaWVzLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcHJvamVjdCA9IG5ldyBQcm9qZWN0KG5hbWUsIGVudHJpZXMpO1xuXG4gICAgcmV0dXJuIHByb2plY3Q7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWVBbmRFbnRyaWVzKG5hbWUsIGVudHJpZXMpIHtcbiAgICBjb25zdCBwcm9qZWN0ID0gbmV3IFByb2plY3QobmFtZSwgZW50cmllcyk7XG5cbiAgICByZXR1cm4gcHJvamVjdDtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFByb2plY3QucHJvdG90eXBlLCBlbnRyaWVzTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvamVjdDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEZpbGUgZnJvbSBcIi4vZmlsZVwiO1xuaW1wb3J0IEVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xuaW1wb3J0IGVudHJpZXNNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2VudHJpZXNcIjtcblxuaW1wb3J0IHsgRE9VQkxFX1NQQUNFIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBpc01ldGFKU09ORmlsZVZhbGlkIH0gZnJvbSBcIi4vdXRpbGl0aWVzL21ldGFKU09OXCI7XG5pbXBvcnQgeyBpc0ZpbGVQYXRoUmVsZWFzZUZpbGVQYXRoIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2ZpbGVQYXRoXCI7XG5pbXBvcnQgeyByZWFkbWVGaWxlRnJvbUZpbGVzLCBtZXRhSlNPTkZpbGVGcm9tRmlsZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZmlsZXNcIjtcblxuY2xhc3MgUmVsZWFzZSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGVudHJpZXMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXM7XG4gIH1cblxuICB1cGRhdGVWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBsZXQgcmVwb3NpdG9yeSA9IHRoaXMuZ2V0UmVwb3NpdG9yeSgpLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSB0aGlzLmdldERlcGVuZGVuY2llcygpO1xuXG4gICAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICByZXBvc2l0b3J5SlNPTiA9IHJlcG9zaXRvcnksICAvLy9cbiAgICAgICAgICBkZXBlbmRlbmNpZXNKU09OID0gZGVwZW5kZW5jaWVzLnRvSlNPTigpO1xuXG4gICAgdmVyc2lvbiA9IHZlcnNpb25TdHJpbmc7ICAvLy9cbiAgICByZXBvc2l0b3J5ID0gcmVwb3NpdG9yeUpTT047ICAvLy9cbiAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXNKU09OOyAgLy8vXG5cbiAgICBjb25zdCBtZXRhSlNPTkZpbGUgPSB0aGlzLmdldE1ldGFKU09ORmlsZSgpLFxuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgcmVwb3NpdG9yeSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llc1xuICAgICAgICAgIH0sXG4gICAgICAgICAganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIERPVUJMRV9TUEFDRSksXG4gICAgICAgICAgZmlsZSA9IG1ldGFKU09ORmlsZSwgIC8vL1xuICAgICAgICAgIGNvbnRlbnQgPSBqc29uU3RyaW5nOyAvLy9cblxuICAgIGZpbGUuc2V0Q29udGVudChjb250ZW50KTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlbnRyaWVzSlNPTiA9IHRoaXMuZW50cmllcy50b0pTT04oKSxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzSlNPTiwgIC8vL1xuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZW50cmllc1xuICAgICAgICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgbGV0IHsgZW50cmllcyB9ID0ganNvbjtcblxuICAgIGNvbnN0IHsgbmFtZSB9ID0ganNvbixcbiAgICAgICAgICBlbnRyaWVzSlNPTiA9IGVudHJpZXM7ICAvLy9cblxuICAgIGpzb24gPSBlbnRyaWVzSlNPTjsgLy8vXG5cbiAgICBlbnRyaWVzID0gRW50cmllcy5mcm9tSlNPTihqc29uKTsgLy8vXG5cbiAgICBjb25zdCByZWxlYXNlID0gbmV3IFJlbGVhc2UobmFtZSwgZW50cmllcyk7XG5cbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUHJvamVjdChwcm9qZWN0KSB7XG4gICAgbGV0IHJlbGVhc2UgPSBudWxsLFxuICAgICAgICBlbnRyaWVzID0gcHJvamVjdC5nZXRFbnRyaWVzKCk7XG5cbiAgICBjb25zdCBlbnRyaWVzUmVsZWFzYWJsZSA9IGFyZUVudHJpZXNSZWxlYXNhYmxlKGVudHJpZXMpO1xuXG4gICAgaWYgKGVudHJpZXNSZWxlYXNhYmxlKSB7XG4gICAgICBjb25zdCBuYW1lID0gcHJvamVjdC5nZXROYW1lKCksXG4gICAgICAgICAgICByZWxlYXNlZEVudHJpZXMgPSByZWxlYXNlRW50cmllc0Zyb21FbnRyaWVzKGVudHJpZXMpO1xuXG4gICAgICBlbnRyaWVzID0gcmVsZWFzZWRFbnRyaWVzOyAgLy8vXG5cbiAgICAgIHJlbGVhc2UgPSBuZXcgUmVsZWFzZShuYW1lLCBlbnRyaWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZUFuZEVudHJpZXMobmFtZSwgZW50cmllcykge1xuICAgIGxldCByZWxlYXNlID0gbnVsbDtcblxuICAgIGNvbnN0IGVudHJpZXNSZWxlYXNhYmxlID0gYXJlRW50cmllc1JlbGVhc2FibGUoZW50cmllcyk7XG5cbiAgICBpZiAoZW50cmllc1JlbGVhc2FibGUpIHtcbiAgICAgIHJlbGVhc2UgPSBuZXcgUmVsZWFzZShuYW1lLCBlbnRyaWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFJlbGVhc2UucHJvdG90eXBlLCBlbnRyaWVzTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgUmVsZWFzZTtcblxuZnVuY3Rpb24gcmVsZWFzZUVudHJpZXNGcm9tRW50cmllcyhlbnRyaWVzKSB7XG4gIGNvbnN0IHJlbGVhc2VkRW50cmllcyA9IEVudHJpZXMuZnJvbU5vdGhpbmcoKSwgIC8vL1xuICAgICAgICBmaWxlcyA9IGVudHJpZXMuZ2V0RmlsZXMoKTtcblxuICBmaWxlcy5mb3JFYWNoRmlsZSgoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgZmlsZVBhdGhSZWxlYXNlRmlsZVBhdGggPSBpc0ZpbGVQYXRoUmVsZWFzZUZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgIGlmIChmaWxlUGF0aFJlbGVhc2VGaWxlUGF0aCkge1xuICAgICAgY29uc3QgcGF0aCA9IGZpbGVQYXRoLCAgLy8vXG4gICAgICAgICAgICBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgICByZWxlYXNlZCA9IHRydWU7XG5cbiAgICAgIGZpbGUgPSBGaWxlLmZyb21QYXRoQ29udGVudEFuZFJlbGVhc2VkKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKTsgIC8vL1xuXG4gICAgICByZWxlYXNlZEVudHJpZXMuYWRkRmlsZShmaWxlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZWxlYXNlZEVudHJpZXM7XG59XG5cbmZ1bmN0aW9uIGFyZUVudHJpZXNSZWxlYXNhYmxlKGVudHJpZXMpIHtcbiAgbGV0IGVudHJpZXNSZWxlYXNhYmxlID0gZmFsc2U7XG5cbiAgY29uc3QgZmlsZXMgPSBlbnRyaWVzLmdldEZpbGVzKCksXG4gICAgICAgIHJlYWRtZUZpbGUgPSByZWFkbWVGaWxlRnJvbUZpbGVzKGZpbGVzKSxcbiAgICAgICAgbWV0YUpTT05GaWxlID0gbWV0YUpTT05GaWxlRnJvbUZpbGVzKGZpbGVzKTtcblxuICBpZiAoKHJlYWRtZUZpbGUgIT09IG51bGwpICYmIChtZXRhSlNPTkZpbGUgIT09IG51bGwpKSB7XG4gICAgY29uc3QgbWV0YUpTT05GaWxlVmFsaWQgPSBpc01ldGFKU09ORmlsZVZhbGlkKG1ldGFKU09ORmlsZSk7XG5cbiAgICBpZiAobWV0YUpTT05GaWxlVmFsaWQpIHtcbiAgICAgIGVudHJpZXNSZWxlYXNhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW50cmllc1JlbGVhc2FibGU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFByb2plY3QgZnJvbSBcIi4vcHJvamVjdFwiO1xuXG5jb25zdCB7IGZvckVhY2ggfSA9IGFzeW5jaHJvbm91c1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvamVjdHMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgZ2V0TGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7IH1cblxuICBhZGRQcm9qZWN0KHByb2plY3QpIHsgdGhpcy5hcnJheS5wdXNoKHByb2plY3QpOyB9XG5cbiAgbWFwUHJvamVjdChjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5tYXAoY2FsbGJhY2spOyB9XG5cbiAgcmVkdWNlUHJvamVjdChjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmFycmF5LnJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKTsgfVxuXG4gIGZvckVhY2hQcm9qZWN0KGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBhc3luY2hyb25vdXNGb3JFYWNoUHJvamVjdChjYWxsYmFjaywgZG9uZSkgeyBmb3JFYWNoKHRoaXMuYXJyYXksIGNhbGxiYWNrLCBkb25lKTsgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5hcnJheS5tYXAoKHByb2plY3QpID0+IHtcbiAgICAgIGNvbnN0IHByb2plY3RKU09OID0gcHJvamVjdC50b0pTT04oKTtcblxuICAgICAgcmV0dXJuIHByb2plY3RKU09OO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGFycmF5ID0ganNvbi5tYXAoKGpzb24pID0+IHsgIC8vL1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IFByb2plY3QuZnJvbUpTT04oanNvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb2plY3RzID0gbmV3IFByb2plY3RzKGFycmF5KTtcblxuICAgIHJldHVybiBwcm9qZWN0cztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdLFxuICAgICAgICAgIHByb2plY3RzID0gbmV3IFByb2plY3RzKGFycmF5KTtcblxuICAgIHJldHVybiBwcm9qZWN0cztcbiAgfVxufVxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFJlbGVhc2UgZnJvbSBcIi4vcmVsZWFzZVwiO1xuXG5jb25zdCB7IGZvckVhY2ggfSA9IGFzeW5jaHJvbm91c1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVsZWFzZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgZ2V0TGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7IH1cblxuICBhZGRSZWxlYXNlKHJlbGVhc2UpIHsgdGhpcy5hcnJheS5wdXNoKHJlbGVhc2UpOyB9XG5cbiAgbWFwUmVsZWFzZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5tYXAoY2FsbGJhY2spOyB9XG5cbiAgcmVkdWNlUmVsZWFzZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmFycmF5LnJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKTsgfVxuXG4gIGZvckVhY2hSZWxlYXNlKGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBhc3luY2hyb25vdXNGb3JFYWNoUmVsZWFzZShjYWxsYmFjaywgZG9uZSkgeyBmb3JFYWNoKHRoaXMuYXJyYXksIGNhbGxiYWNrLCBkb25lKTsgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5hcnJheS5tYXAoKHJlbGVhc2UpID0+IHtcbiAgICAgIGNvbnN0IHJlbGVhc2VKU09OID0gcmVsZWFzZS50b0pTT04oKTtcblxuICAgICAgcmV0dXJuIHJlbGVhc2VKU09OO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGFycmF5ID0ganNvbi5tYXAoKGpzb24pID0+IHsgIC8vL1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZSA9IFJlbGVhc2UuZnJvbUpTT04oanNvbik7XG5cbiAgICAgICAgICAgIHJldHVybiByZWxlYXNlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHJlbGVhc2VzID0gbmV3IFJlbGVhc2VzKGFycmF5KTtcblxuICAgIHJldHVybiByZWxlYXNlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdLFxuICAgICAgICAgIHJlbGVhc2VzID0gbmV3IFJlbGVhc2VzKGFycmF5KTtcblxuICAgIHJldHVybiByZWxlYXNlcztcbiAgfVxufVxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsZSB9IGZyb20gXCIuL2ZpbGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsZXMgfSBmcm9tIFwiLi9maWxlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbnRyaWVzIH0gZnJvbSBcIi4vZW50cmllc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcm9qZWN0IH0gZnJvbSBcIi4vcHJvamVjdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWxlYXNlIH0gZnJvbSBcIi4vcmVsZWFzZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcm9qZWN0cyB9IGZyb20gXCIuL3Byb2plY3RzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlbGVhc2VzIH0gZnJvbSBcIi4vcmVsZWFzZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlyZWN0b3J5IH0gZnJvbSBcIi4vZGlyZWN0b3J5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbGVOYW1lcyB9IGZyb20gXCIuL2ZpbGVOYW1lc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEZXBlbmRlbmN5IH0gZnJvbSBcIi4vZGVwZW5kZW5jeVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi9kZXBlbmRlbmNpZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2hvcnRlbmVkVmVyc2lvbiB9IGZyb20gXCIuL3Nob3J0ZW5lZFZlcnNpb25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29udGVudFV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jb250ZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbGVQYXRoVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2ZpbGVQYXRoXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG1ldGFKU09OVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL21ldGFKU09OXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVudHJpZXMsIG1ldGFKU09OVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLW1vZGVsXCI7XG5cbmltcG9ydCBSZWxlYXNlQ29udGV4dCBmcm9tIFwiLi4vY29udGV4dC9yZWxlYXNlXCI7XG5cbmltcG9ydCB7IGN1c3RvbUdyYW1tYXJGcm9tTmFtZUFuZEVudHJpZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2N1c3RvbUdyYW1tYXJcIjtcblxuY29uc3QgeyBpc01ldGFKU09ORmlsZVZhbGlkIH0gPSBtZXRhSlNPTlV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VDb250ZXh0RnJvbUpTT04oanNvbiwgY29udGV4dCkge1xuICBjb25zdCB7IGxvZywgY2FsbGJhY2sgfSA9IGNvbnRleHQsXG4gICAgICAgIHsgbmFtZSB9ID0ganNvbjtcblxuICBsZXQgeyBlbnRyaWVzIH0gPSBqc29uO1xuXG4gICh7Y29udGV4dH0gPSBqc29uKTsgLy8vXG5cbiAganNvbiA9IGVudHJpZXM7IC8vL1xuXG4gIGVudHJpZXMgPSBFbnRyaWVzLmZyb21KU09OKGpzb24pO1xuXG4gIGNvbnN0IGNvbnRleHRKU09OID0gY29udGV4dDsgIC8vL1xuXG4gIGpzb24gPSBjb250ZXh0SlNPTjsgLy8vXG5cbiAgY29uc3QgY3VzdG9tR3JhbW1hciA9IGN1c3RvbUdyYW1tYXJGcm9tTmFtZUFuZEVudHJpZXMobmFtZSwgZW50cmllcyksXG4gICAgICAgIHJlbGVhc2VDb250ZXh0ID0gUmVsZWFzZUNvbnRleHQuZnJvbUxvZ05hbWVKU09ORW50cmllc0NhbGxiYWNrQW5kQ3VzdG9tR3JhbW1hcihsb2csIG5hbWUsIGpzb24sIGVudHJpZXMsIGNhbGxiYWNrLCBjdXN0b21HcmFtbWFyKTtcblxuICByZXR1cm4gcmVsZWFzZUNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxlYXNlQ29udGV4dEZyb21Qcm9qZWN0KHByb2plY3QsIGNvbnRleHQpIHtcbiAgbGV0IHJlbGVhc2VDb250ZXh0ID0gbnVsbDtcblxuICBpZiAocHJvamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG1ldGFKU09ORmlsZSA9IHByb2plY3QuZ2V0TWV0YUpTT05GaWxlKCk7XG5cbiAgICBpZiAobWV0YUpTT05GaWxlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBtZXRhSlNPTkZpbGVWYWxpZCA9IGlzTWV0YUpTT05GaWxlVmFsaWQobWV0YUpTT05GaWxlKTtcblxuICAgICAgaWYgKG1ldGFKU09ORmlsZVZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHsgbG9nLCBjYWxsYmFjayB9ID0gY29udGV4dCxcbiAgICAgICAgICAgICAgbmFtZSA9IHByb2plY3QuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICBqc29uID0gbnVsbCxcbiAgICAgICAgICAgICAgZW50cmllcyA9IHByb2plY3QuZ2V0RW50cmllcygpLFxuICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKTtcblxuICAgICAgICByZWxlYXNlQ29udGV4dCA9IFJlbGVhc2VDb250ZXh0LmZyb21Mb2dOYW1lSlNPTkVudHJpZXNDYWxsYmFja0FuZEN1c3RvbUdyYW1tYXIobG9nLCBuYW1lLCBqc29uLCBlbnRyaWVzLCBjYWxsYmFjaywgY3VzdG9tR3JhbW1hcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VDb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZUNvbnRleHRGcm9tUmVsZWFzZShyZWxlYXNlLCBjb250ZXh0KSB7XG4gIGxldCByZWxlYXNlQ29udGV4dCA9IG51bGw7XG5cbiAgaWYgKHJlbGVhc2UgIT09IG51bGwpIHtcbiAgICBjb25zdCB7IGxvZywgY2FsbGJhY2sgfSA9IGNvbnRleHQsXG4gICAgICAgICAgbmFtZSA9IHJlbGVhc2UuZ2V0TmFtZSgpLFxuICAgICAgICAgIGpzb24gPSBudWxsLFxuICAgICAgICAgIGVudHJpZXMgPSByZWxlYXNlLmdldEVudHJpZXMoKSxcbiAgICAgICAgICBjdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKTtcblxuICAgIHJlbGVhc2VDb250ZXh0ID0gUmVsZWFzZUNvbnRleHQuZnJvbUxvZ05hbWVKU09ORW50cmllc0NhbGxiYWNrQW5kQ3VzdG9tR3JhbW1hcihsb2csIG5hbWUsIGpzb24sIGVudHJpZXMsIGNhbGxiYWNrLCBjdXN0b21HcmFtbWFyKTtcbiAgfVxuXG4gIHJldHVybiByZWxlYXNlQ29udGV4dDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICByZWxlYXNlQ29udGV4dEZyb21KU09OLFxuICByZWxlYXNlQ29udGV4dEZyb21Qcm9qZWN0LFxuICByZWxlYXNlQ29udGV4dEZyb21SZWxlYXNlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIExvZyB9IGZyb20gXCIuL2xvZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbGVtZW50IH0gZnJvbSBcIi4vZWxlbWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlQ29udGV4dCB9IGZyb20gXCIuL2NvbnRleHQvZmlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWxlYXNlQ29udGV4dCB9IGZyb20gXCIuL2NvbnRleHQvcmVsZWFzZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwiLi9ub25UZXJtaW5hbE5vZGVcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBaaXBQYXNzIH0gZnJvbSBcIi4vcGFzcy96aXBcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXN5bmNQYXNzIH0gZnJvbSBcIi4vcGFzcy9hc3luY1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaW1wbGVQYXNzIH0gZnJvbSBcIi4vcGFzcy9zaW1wbGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRm9yd2FyZFBhc3MgfSBmcm9tIFwiLi9wYXNzL2ZvcndhcmRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXF1aXZhbGVuY2VQYXNzIH0gZnJvbSBcIi4vcGFzcy9lcXVpdmFsZW5jZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vZGVVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBxdWVyeVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9xdWVyeVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaWxlQ29udGV4dFV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9maWxlQ29udGV4dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJpZmljYXRpb25VdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvdmVyaWZpY2F0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9hc3luY2hyb25vdXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcmVsZWFzZUNvbnRleHRVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcmVsZWFzZUNvbnRleHRcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgZWxlbWVudHMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZShFbGVtZW50KSB7XG4gIGNvbnN0IHsgbmFtZSB9ID0gRWxlbWVudDtcblxuICBlbGVtZW50c1tuYW1lXSA9IEVsZW1lbnQ7XG5cbiAgcmV0dXJuIEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVsZW1lbnRzO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFN0ZXAgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheUFzc2lnbm1lbnQsIG9iamVjdEFzc2lnbWVudCwgdmFyaWFibGVzc0Fzc2lnbm1lbnQpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5QXNzaWdubWVudCA9IGFycmF5QXNzaWdubWVudDtcbiAgICB0aGlzLm9iamVjdEFzc2lnbWVudCA9IG9iamVjdEFzc2lnbWVudDtcbiAgICB0aGlzLnZhcmlhYmxlc3NBc3NpZ25tZW50ID0gdmFyaWFibGVzc0Fzc2lnbm1lbnQ7XG4gIH1cblxuICBnZXRBcnJheUFzc2lnbm1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlBc3NpZ25tZW50O1xuICB9XG5cbiAgZ2V0T2JqZWN0QXNzaWdtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdEFzc2lnbWVudDtcbiAgfVxuXG4gIGdldFZhcmlhYmxlc3NBc3NpZ25tZW50KCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlc3NBc3NpZ25tZW50O1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmICh0aGlzLmFycmF5QXNzaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hcnJheUFzc2lnbm1lbnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9iamVjdEFzc2lnbWVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vYmplY3RBc3NpZ21lbnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhcmlhYmxlc3NBc3NpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBhd2FpdCB0aGlzLnZhcmlhYmxlc3NBc3NpZ25tZW50LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJTdGVwXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICBnZXRNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cblxuICBzdGF0aWMgZnJvbU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGV4Y2VwdGlvbiA9IG5ldyBFeGNlcHRpb24obWVzc2FnZSk7XG5cbiAgICByZXR1cm4gZXhjZXB0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBOT0RFX1RZUEUgPSBcIk5vZGVcIjtcbmV4cG9ydCBjb25zdCBOT0RFU19UWVBFID0gXCJOb2Rlc1wiO1xuZXhwb3J0IGNvbnN0IFNUUklOR19UWVBFID0gXCJTdHJpbmdcIjtcbmV4cG9ydCBjb25zdCBOVU1CRVJfVFlQRSA9IFwiTnVtYmVyXCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTl9UWVBFID0gXCJCb29sZWFuXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNsYXNzIE51bGxOb2RlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG51bGxOb2RlID0gbmV3IE51bGxOb2RlKCk7XG5cbiAgICByZXR1cm4gbnVsbE5vZGU7XG4gIH1cbn1cblxuY29uc3QgbnVsbE5vZGUgPSBOdWxsTm9kZS5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgZGVmYXVsdCBudWxsTm9kZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE5VTEwgPSBcIm51bGxcIjtcbmV4cG9ydCBjb25zdCBUUlVFID0gXCJ0cnVlXCI7XG5leHBvcnQgY29uc3QgRkFMU0UgPSBcImZhbHNlXCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBOT1RfRVFVQUxfVE8gPSBcIiE9XCI7XG5leHBvcnQgY29uc3QgQ09OSlVOQ1RJT05fT1BFUkFUT1IgPSBcIiYmXCI7XG5leHBvcnQgY29uc3QgRElTSlVOQ1RJT05fT1BFUkFUT1IgPSBcInx8XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwpIHtcbiAgY29uc3Qgc3RyaW5nID0gc3RyaW5nTGl0ZXJhbC5yZXBsYWNlKC8oXlwifFwiJCkvZywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nTGl0ZXJhbEZyb21TdHJpbmcoc3RyaW5nKSB7XG4gIGNvbnN0IHN0cmluZ0xpdGVyYWwgPSBgXCIke3N0cmluZ31cImA7XG5cbiAgcmV0dXJuIHN0cmluZ0xpdGVyYWw7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBudWxsTm9kZSBmcm9tIFwiLi4vbnVsbE5vZGVcIjtcblxuaW1wb3J0IHsgTlVMTCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4vc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVybmFyeVN0cmluZ0Zyb21UZXJtKHRlcm0pIHtcbiAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgIHRlcm5hcnlTdHJpbmcgPSBgaWYgKCR7dGVybVN0cmluZ30pIHsgLi4uIH0gZWxzZSB7IC4uLiB9YDtcblxuICByZXR1cm4gdGVybmFyeVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUobmFtZSkge1xuICBjb25zdCB2YXJpYWJsZVN0cmluZyA9IG5hbWU7ICAvLy9cblxuICByZXR1cm4gdmFyaWFibGVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltdGl2ZVN0cmluZ0Zyb21Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHJpbXRpdmVTdHJpbmcgPSAobm9kZSA9PT0gbnVsbE5vZGUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTlVMTCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSk7XG5cbiAgcmV0dXJuIHByaW10aXZlU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbXRpdmVTdHJpbmdGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3Qgc3RyaW5nID0gY29udGV4dC5ub2Rlc0FzU3RyaW5nKG5vZGVzKSxcbiAgICAgICAgcHJpbXRpdmVTdHJpbmcgPSBzdHJpbmc7ICAvLy9cblxuICByZXR1cm4gcHJpbXRpdmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtU3RyaW5nRnJvbVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICBsZXQgdGVybVN0cmluZztcblxuICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgaWYgKHByb3BlcnR5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eVN0cmluZyA9IHByb3BlcnR5LmdldFN0cmluZygpO1xuXG4gICAgICB0ZXJtU3RyaW5nID0gcHJvcGVydHlTdHJpbmc7ICAvLy9cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZXJtU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbXRpdmVTdHJpbmdGcm9tQm9vbGVhbihib29sZWFuKSB7XG4gIGNvbnN0IGV4cHJlc3NzaW9uU3RyaW5nID0gYCR7Ym9vbGVhbn1gO1xuXG4gIHJldHVybiBleHByZXNzc2lvblN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1zU3RyaW5nRnJvbVRlcm1zQXJyYXkodGVybXNBcnJheSkge1xuICBjb25zdCB0ZXJtc1N0cmluZyA9IHRlcm1zQXJyYXkucmVkdWNlKCh0ZXJtc1N0cmluZywgdGVybSkgPT4ge1xuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgdGVybXNTdHJpbmcgPSAodGVybXNTdHJpbmcgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgdGVybVN0cmluZyA6XG4gICAgICAgICAgICAgICAgICAgICBgJHt0ZXJtc1N0cmluZ30sICR7dGVybVN0cmluZ31gO1xuXG4gICAgcmV0dXJuIHRlcm1zU3RyaW5nO1xuICB9LCBudWxsKTsgLy8vXG5cbiAgcmV0dXJuIHRlcm1zU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvblN0cmluZ0Zyb21Qcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgbGV0IGV4cHJlc3Npb25TdHJpbmc7XG5cbiAgcHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgIGlmIChwcm9wZXJ0eSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJvcGVydHlTdHJpbmcgPSBwcm9wZXJ0eS5nZXRTdHJpbmcoKTtcblxuICAgICAgZXhwcmVzc2lvblN0cmluZyA9IHByb3BlcnR5U3RyaW5nOyAgLy8vXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZXhwcmVzc2lvblN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW10aXZlU3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCkge1xuICBjb25zdCBzdHJpbmcgPSBzdHJpbmdGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsKSxcbiAgICAgICAgcHJpbXRpdmVTdHJpbmcgPSBzdHJpbmc7ICAvLy9cblxuICByZXR1cm4gcHJpbXRpdmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlUHJvcGVydHlTdHJpbmdGcm9tTmFtZUFuZFR5cGUobmFtZSwgdHlwZSkge1xuICBjb25zdCB0eXBlU3RyaW5nID0gdHlwZSwgIC8vL1xuICAgICAgICBuYW1lU3RyaW5nID0gbmFtZSwgIC8vL1xuICAgICAgICBub2RlUHJvcGVydHlTdHJpbmcgPSBgJHt0eXBlU3RyaW5nfSAke25hbWVTdHJpbmd9YDtcblxuICByZXR1cm4gbm9kZVByb3BlcnR5U3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2VkdXJlRGVjbGFyYXRpb25TdHJpbmdGcm9tUHJvY2VkdXJlKHByb2NlZHVyZSkge1xuICBjb25zdCB0eXBlID0gcHJvY2VkdXJlLmdldFR5cGUoKSxcbiAgICAgICAgbGFiZWwgPSBwcm9jZWR1cmUuZ2V0TGFiZWwoKSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHByb2NlZHVyZS5nZXRQYXJhbWV0ZXJzKCksXG4gICAgICAgIHJldHVyblN0YXRlbWVudCA9IHByb2NlZHVyZS5nZXRSZXR1cm5TdGF0ZW1lbnQoKSxcbiAgICAgICAgbGFiZWxTdHJpbmcgPSBsYWJlbC5nZXRTdHJpbmcoKSxcbiAgICAgICAgcGFyYW1ldGVyc1N0cmluZyA9IHBhcmFtZXRlcnMuZ2V0U3RyaW5nKCksXG4gICAgICAgIHJldHVyblN0YXRlbWVudFN0cmluZyA9IHJldHVyblN0YXRlbWVudC5nZXRTdHJpbmcoKSxcbiAgICAgICAgcHJvY2VkdXJlRGVsY2FyYXRpb25TdHJpbmcgPSBgJHt0eXBlfSAke2xhYmVsU3RyaW5nIH0oJHtwYXJhbWV0ZXJzU3RyaW5nfSkgeyAuLi4gJHtyZXR1cm5TdGF0ZW1lbnRTdHJpbmd9IH1gO1xuXG4gIHJldHVybiBwcm9jZWR1cmVEZWxjYXJhdGlvblN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkJsb2NrU3RyaW5nRnJvbVJldHVyblN0YXRlbWVudE5vZGUocmV0dXJuU3RhdGVtZW50KSB7XG4gIGNvbnN0IHJldHVyblN0YXRlbWVudFN0cmluZyA9IHJldHVyblN0YXRlbWVudC5nZXRTdHJpbmcoKSxcbiAgICAgICAgcmV0dXJuQmxvY2tTdHJpbmcgPSBgeyAuLi4gJHtyZXR1cm5TdGF0ZW1lbnRTdHJpbmd9IH1gO1xuXG4gIHJldHVybiByZXR1cm5CbG9ja1N0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVQcm9wZXJ0aWVzU3RyaW5nRnJvbU5vZGVQcm9wZXJ0aWVzQXJyYXkobm9kZVByb3BlcnRpZXNBcnJheSkge1xuICBjb25zdCBub2RlUHJvcGVydGllc1N0cmluZyA9IG5vZGVQcm9wZXJ0aWVzQXJyYXkucmVkdWNlKChub2RlUHJvcGVydGllc1N0cmluZywgbm9kZVByb3BlcnR5KSA9PiB7XG4gICAgICBjb25zdCBub2RlUHJvcGVydHlTdHJpbmcgPSBub2RlUHJvcGVydHkuZ2V0U3RyaW5nKCk7XG5cbiAgICAgIG5vZGVQcm9wZXJ0aWVzU3RyaW5nID0gKG5vZGVQcm9wZXJ0aWVzU3RyaW5nID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVByb3BlcnR5U3RyaW5nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7bm9kZVByb3BlcnRpZXNTdHJpbmd9LCAke25vZGVQcm9wZXJ0eVN0cmluZ31gO1xuXG4gICAgICByZXR1cm4gbm9kZVByb3BlcnRpZXNTdHJpbmc7XG4gICAgfSwgbnVsbCk7XG5cbiAgcmV0dXJuIG5vZGVQcm9wZXJ0aWVzU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVR5cGVBbmRWYXJpYWJsZSh0eXBlLCB2YXJpYWJsZSkge1xuICBjb25zdCB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlLmdldFN0cmluZygpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSBgJHt0eXBlfSAke3ZhcmlhYmxlU3RyaW5nfSA9IC4uLiA7YDtcblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc29tZVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSh2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZVN0cmluZyA9IGFub255bW91c1Byb2NlZHVyZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgc29tZVN0cmluZyA9IGBTb21lKCR7dmFyaWFibGVTdHJpbmd9LCAke2Fub255bW91c1Byb2NlZHVyZVN0cmluZ30pIGA7XG5cbiAgcmV0dXJuIHNvbWVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVyeVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSh2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZVN0cmluZyA9IGFub255bW91c1Byb2NlZHVyZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgZXZlcnlTdHJpbmcgPSBgRXZlcnkoJHt2YXJpYWJsZVN0cmluZ30sICR7YW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nfSkgYDtcblxuICByZXR1cm4gZXZlcnlTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVmFyaWFibGVBc3NpZ25tZW50KHZhcmlhYmxlQXNzaWdubWVudCkge1xuICBjb25zdCB2YXJpYWJsZSA9IHZhcmlhYmxlQXNzaWdubWVudC5nZXRWYXJpYWJsZSgpLFxuICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlLmdldFN0cmluZygpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSBgJHt2YXJpYWJsZVN0cmluZ30gPSAuLi5gO1xuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVTdHJpbmdGcm9tVHlwZUxhYmVsUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrKHR5cGUsIGxhYmVsLCBwYXJhbWV0ZXJzLCByZXR1cm5CbG9jaykge1xuICBjb25zdCB0eXBlU3RyaW5nID0gdHlwZSwgIC8vL1xuICAgICAgICBsYWJlbFN0cmluZyA9IGxhYmVsLmdldFN0cmluZygpLFxuICAgICAgICBwYXJhbWV0ZXJzU3RyaW5nID0gcGFyYW1ldGVycy5nZXRTdHJpbmcoKSxcbiAgICAgICAgcmV0dXJuQmxvY2tTdHJpbmcgPSByZXR1cm5CbG9jay5nZXRTdHJpbmcoKSxcbiAgICAgICAgcHJvY2VkdXJlU3RyaW5nID0gYCR7dHlwZVN0cmluZ30gJHtsYWJlbFN0cmluZ30oJHtwYXJhbWV0ZXJzU3RyaW5nfSkgJHtyZXR1cm5CbG9ja1N0cmluZ31gO1xuXG4gIHJldHVybiBwcm9jZWR1cmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmdGcm9tVHlwZVBhcmFtZXRlcnNBbmRSZXR1cm5CbG9jayh0eXBlLCBwYXJhbWV0ZXJzLCByZXR1cm5CbG9jaykge1xuICBjb25zdCB0eXBlU3RyaW5nID0gdHlwZSwgIC8vL1xuICAgICAgICBwYXJhbWV0ZXJzU3RyaW5nID0gcGFyYW1ldGVycy5nZXRTdHJpbmcoKSxcbiAgICAgICAgcmV0dXJuQmxvY2tTdHJpbmcgPSByZXR1cm5CbG9jay5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYCR7dHlwZVN0cmluZ30gKCR7cGFyYW1ldGVyc1N0cmluZ30pICR7cmV0dXJuQmxvY2tTdHJpbmd9YDtcblxuICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50c0FycmF5KSB7XG4gIGxldCB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nID0gdmFyaWFibGVBc3NpZ25tZW50c0FycmF5LnJlZHVjZSgodmFyaWFibGVBc3NpZ25tZW50c1N0cmluZywgdmFyaWFibGVBc3NpZ25tZW50KSA9PiB7XG4gICAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nID0gdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVZhcmlhYmxlQXNzaWdubWVudCh2YXJpYWJsZUFzc2lnbm1lbnQpO1xuXG4gICAgdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZyA9ICh2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nID09PSBudWxsKSA/XG4gICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgOlxuICAgICAgYCR7dmFyaWFibGVBc3NpZ25tZW50c1N0cmluZ30sICR7dmFyaWFibGVBc3NpZ25tZW50U3RyaW5nfWA7XG5cbiAgICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZztcbiAgfSwgbnVsbCk7IC8vL1xuXG4gIHZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmcgPSBgJHt0eXBlfSAke3ZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmd9IDtgOyAvLy9cblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVN0cmluZ0Zyb21WYXJpYWJsZUluaXRpYWxFeHByZXNzaW9uQW5kQW5vbnltb3VzUHJvY2VkdXJlKHZhcmlhYmxlLCBpbml0aWFsRXhwcmVzc2lvbiwgYW5vbnltb3VzUHJvY2VkdXJlKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIGluaXRpYWxFeHByZXNzaW9uU3RyaW5nID0gaW5pdGlhbEV4cHJlc3Npb24uZ2V0U3RyaW5nKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZVN0cmluZyA9IGFub255bW91c1Byb2NlZHVyZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgcmVkdWNlU3RyaW5nID0gYFJlZHVjZSgke3ZhcmlhYmxlU3RyaW5nfSwgJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9LCAke2luaXRpYWxFeHByZXNzaW9uU3RyaW5nfSlgO1xuXG4gIHJldHVybiByZWR1Y2VTdHJpbmc7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGVsZW1lbnRzIGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5pbXBvcnQgeyBOT0RFX1RZUEUsIE5PREVTX1RZUEUsIFNUUklOR19UWVBFLCBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHByaW10aXZlU3RyaW5nRnJvbU5vZGUsIHByaW10aXZlU3RyaW5nRnJvbU5vZGVzLCBwcmltdGl2ZVN0cmluZ0Zyb21Cb29sZWFuLCBwcmltdGl2ZVN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcmltaXRpdmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBwcmltaXRpdmVTdHJpbmcgPSBwcmltdGl2ZVN0cmluZ0Zyb21Ob2RlKG5vZGUsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmVTdHJpbmcsICAvLy9cbiAgICAgICAgdHlwZSA9IE5PREVfVFlQRSxcbiAgICAgICAgdmFsdWUgPSBub2RlOyAvLy9cblxuICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcmltaXRpdmUgPSBuZXcgUHJpbWl0aXZlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdmFsdWUpO1xuXG4gIHJldHVybiBwcmltaXRpdmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcmltaXRpdmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBwcmltaXRpdmVTdHJpbmcgPSBwcmltdGl2ZVN0cmluZ0Zyb21Ob2Rlcyhub2RlcywgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZVN0cmluZywgIC8vL1xuICAgICAgICB0eXBlID0gTk9ERVNfVFlQRSxcbiAgICAgICAgdmFsdWUgPSBub2RlcywgIC8vL1xuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcmltaXRpdmUgPSBuZXcgUHJpbWl0aXZlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdmFsdWUpO1xuXG4gIHJldHVybiBwcmltaXRpdmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJpbWl0aXZlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgcHJpbWl0aXZlU3RyaW5nID0gcHJpbXRpdmVTdHJpbmdGcm9tQm9vbGVhbihib29sZWFuKSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlU3RyaW5nLCAgLy8vXG4gICAgICAgIHR5cGUgPSBCT09MRUFOX1RZUEUsXG4gICAgICAgIHZhbHVlID0gYm9vbGVhbiwgIC8vL1xuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcmltaXRpdmUgPSBuZXcgUHJpbWl0aXZlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdmFsdWUpO1xuXG4gIHJldHVybiBwcmltaXRpdmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJpbWl0aXZlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgcHJpbWl0aXZlU3RyaW5nID0gcHJpbXRpdmVTdHJpbmdGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsKSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlU3RyaW5nLCAgLy8vXG4gICAgICAgIHR5cGUgPSBTVFJJTkdfVFlQRSxcbiAgICAgICAgdmFsdWUgPSBzdHJpbmdMaXRlcmFsLCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcmltaXRpdmVGcm9tTm9kZSxcbiAgcHJpbWl0aXZlRnJvbU5vZGVzLFxuICBwcmltaXRpdmVGcm9tQm9vbGVhbixcbiAgcHJpbWl0aXZlRnJvbVN0cmluZ0xpdGVyYWxcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuaW1wb3J0IHsgcHJpbWl0aXZlRnJvbU5vZGUsIHByaW1pdGl2ZUZyb21Ob2RlcywgcHJpbWl0aXZlRnJvbUJvb2xlYW4sIHByaW1pdGl2ZUZyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wcmltaXRpdmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgVGVybSB9ID0gZWxlbWVudHMsXG4gICAgICAgIHZhcmlhYmxlID0gbnVsbCxcbiAgICAgICAgcHJpbWl0aXZlID0gcHJpbWl0aXZlRnJvbU5vZGUobm9kZSwgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZS5nZXRTdHJpbmcoKTtcblxuICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlKTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmUuZ2V0U3RyaW5nKCksXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm0gPSBuZXcgVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlKTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgVGVybSB9ID0gZWxlbWVudHMsXG4gICAgICAgIHZhcmlhYmxlID0gbnVsbCxcbiAgICAgICAgcHJpbWl0aXZlID0gcHJpbWl0aXZlRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCwgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbVByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgbm9kZSA9IG51bGwsXG4gICAgICAgIHZhcmlhYmxlID0gbnVsbCxcbiAgICAgICAgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdGVybUZyb21Ob2RlLFxuICB0ZXJtRnJvbU5vZGVzLFxuICB0ZXJtRnJvbUJvb2xlYW4sXG4gIHRlcm1Gcm9tU3RyaW5nTGl0ZXJhbCxcbiAgdGVybUZyb21QcmltaXRpdmVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQsIGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IGVsZW1lbnRzIGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgTk9ERVNfVFlQRSwgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGUsIHRlcm1Gcm9tQm9vbGVhbiB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5jb25zdCB7IGFzeW5jU29tZSB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgU29tZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3Qgc29tZVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtzb21lU3RyaW5nfScgc29tZS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFU19UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFU19UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIG5vZGVzID0gcHJpbWl0aXZlVmFsdWUsIC8vL1xuICAgICAgICAgIGJvb2xlYW4gPSBhd2FpdCBhc3luY1NvbWUobm9kZXMsIGFzeW5jIChub2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGVybTtcblxuICAgICAgICAgICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgY29uc3QgeyBUZXJtcyB9ID0gZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICB0ZXJtcyA9IFRlcm1zLmZyb21UZXJtKHRlcm0sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICB0ZXJtID0gYXdhaXQgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUuY2FsbCh0ZXJtcywgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXJtVHlwZSAhPT0gQk9PTEVBTl9UWVBFKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIHR5cGUgaXMgJyR7dGVybVR5cGV9JyB3aGVuIGl0IHNob3VsZCBiZSBvZiB0eXBlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgYm9vbGVhbiA9IHByaW1pdGl2ZVZhbHVlOyAvLy9cblxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW47XG4gICAgICAgICAgfSk7XG5cbiAgICB0ZXJtID0gdGVybUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGAuLi5ldmFsdWF0ZWQgdGhlICcke3NvbWVTdHJpbmd9JyBzb21lIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlNvbWVcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVGVybSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUsIG5lZ2F0ZWRUZXJtLCBsb2dpY2FsVGVybSwgYnJhY2tldGVkVGVybSwgY29tcGFyaXNvblRlcm0pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgdGhpcy5uZWdhdGVkVGVybSA9IG5lZ2F0ZWRUZXJtO1xuICAgIHRoaXMubG9naWNhbFRlcm0gPSBsb2dpY2FsVGVybTtcbiAgICB0aGlzLmJyYWNrZXRlZFRlcm0gPSBicmFja2V0ZWRUZXJtO1xuICAgIHRoaXMuY29tcGFyaXNvblRlcm0gPSBjb21wYXJpc29uVGVybTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0UHJpbWl0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZTtcbiAgfVxuXG4gIGdldE5lZ2F0ZWRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0ZWRUZXJtO1xuICB9XG5cbiAgZ2V0TG9naWNhbFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMubG9naWNhbFRlcm07XG4gIH1cblxuICBnZXRCcmVlZGluZ1Rlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJhY2tldGVkVGVybTtcbiAgfVxuXG4gIGdldENvbXBhcmlzb25UZXJtKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmlzb25UZXJtO1xuICB9XG5cbiAgZ2V0UHJpbWl0aXZlVmFsdWUoKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0aGlzLnByaW1pdGl2ZS5nZXRWYWx1ZSgpO1xuXG4gICAgcmV0dXJuIHByaW1pdGl2ZVZhbHVlO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy52YXJpYWJsZS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByaW1pdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMucHJpbWl0aXZlLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRlZFRlcm0gIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLm5lZ2F0ZWRUZXJtLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9naWNhbFRlcm0gIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLmxvZ2ljYWxUZXJtLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnJhY2tldGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMuYnJhY2tldGVkVGVybS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBhcmlzb25UZXJtICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5jb21wYXJpc29uVGVybS5nZXRUeXBlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBpc0Jvb2xlYW4oKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAgICAgIGJvb2xlYW4gPSAodHlwZSA9PT0gQk9PTEVBTl9UWVBFKTtcblxuICAgIHJldHVybiBib29sZWFuO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLnZhcmlhYmxlLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmltaXRpdmUgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLnByaW1pdGl2ZS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRlZFRlcm0gIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLm5lZ2F0ZWRUZXJtLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2dpY2FsVGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMubG9naWNhbFRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJyYWNrZXRlZFRlcm0gIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLmJyYWNrZXRlZFRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBhcmlzb25UZXJtICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gdGhpcy5jb21wYXJpc29uVGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGlzRXF1YWxUbyh0ZXJtKSB7XG4gICAgbGV0IGVxdWFsVG8gPSBmYWxzZTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHRlcm0uZ2V0VmFyaWFibGUoKTtcblxuICAgICAgaWYgKHZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICAgIGVxdWFsVG8gPSB0aGlzLnZhcmlhYmxlLmlzRXF1YWxUbyh2YXJpYWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByaW1pdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcHJpbWl0aXZlID0gdGVybS5nZXRQcmltaXRpdmUoKTtcblxuICAgICAgaWYgKHByaW1pdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgICBlcXVhbFRvID0gdGhpcy5wcmltaXRpdmUuaXNFcXVhbFRvKHByaW1pdGl2ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVxdWFsVG87XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVGVybVwiO1xuXG4gIHN0YXRpYyBmcm9tUHJpbWl0aXZlKHByaW1pdGl2ZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHByaW1pdGl2ZVN0cmluZyA9IHByaW1pdGl2ZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmVTdHJpbmcsIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsLFxuICAgICAgICAgIHZhcmlhYmxlID0gbnVsbCxcbiAgICAgICAgICBuZWdhdGVkVGVybSA9IG51bGwsXG4gICAgICAgICAgbG9naWNhbFRlcm0gPSBudWxsLFxuICAgICAgICAgIGJyYWNrZXRlZFRlcm0gPSBudWxsLFxuICAgICAgICAgIGNvbXBhcmlzb25UZXJtID0gbnVsbDtcblxuICAgIGNvbnRleHQgPSBudWxsO1xuXG4gICAgY29uc3QgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSwgbmVnYXRlZFRlcm0sIGxvZ2ljYWxUZXJtLCBicmFja2V0ZWRUZXJtLCBjb21wYXJpc29uVGVybSk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSB9IGZyb20gXCIuLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBUZXJtcyBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG5cbiAgZ2V0VGVybShpbmRleCkge1xuICAgIGNvbnN0IHRlcm0gPSB0aGlzLmFycmF5W2luZGV4XSB8fCBudWxsOyAgLy8vXG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGFkZFRlcm0odGVybSkge1xuICAgIHRoaXMuYXJyYXkucHVzaCh0ZXJtKTtcbiAgfVxuXG4gIG1hcFRlcm0oY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkubWFwKGNhbGxiYWNrKTsgfVxuXG4gIGZvckVhY2hUZXJtKGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybXNBcnJheSA9IHRoaXMubWFwVGVybSgodGVybSkgPT4ge1xuICAgICAgICAgICAgdGVybSA9IHRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXJtO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRlcm1zU3RyaW5nID0gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5LCBjb250ZXh0KSxcbiAgICAgICAgICBzdHJpbmcgPSB0ZXJtc1N0cmluZywgLy8vXG4gICAgICAgICAgYXJyYXkgPSB0ZXJtc0FycmF5LCAvLy9cbiAgICAgICAgICBub2RlID0gbnVsbDtcblxuICAgIGNvbnRleHQgPSBudWxsO1xuXG4gICAgY29uc3QgdGVybXMgPSBuZXcgVGVybXMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgICByZXR1cm4gdGVybXM7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVGVybXNcIjtcblxuICBzdGF0aWMgZnJvbVRlcm0odGVybSwgY29udGV4dCkge1xuICAgIGNvbnN0IHRlcm1zQXJyYXkgPSBbXG4gICAgICAgICAgICB0ZXJtXG4gICAgICAgICAgXSxcbiAgICAgICAgICB0ZXJtc1N0cmluZyA9IHRlcm1zU3RyaW5nRnJvbVRlcm1zQXJyYXkodGVybXNBcnJheSwgY29udGV4dCksXG4gICAgICAgICAgc3RyaW5nID0gdGVybXNTdHJpbmcsIC8vL1xuICAgICAgICAgIGFycmF5ID0gdGVybXNBcnJheSwgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIGNvbnN0IHRlcm1zID0gbmV3IFRlcm1zKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpO1xuXG4gICAgcmV0dXJuIHRlcm1zO1xuICB9XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBMYWJlbCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIG5hbWUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgY29tcGFyZVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSkge1xuICAgIGNvbnN0IHByb2NlZHVyZU5hbWVDb21wYXJlcyA9ICh0aGlzLm5hbWUgPT09IHByb2NlZHVyZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZU5hbWVDb21wYXJlcztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJMYWJlbFwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgRXJyb3IgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGVyeHQsIHN0cmluZywgbm9kZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcbiAgfVxuXG4gIHZlcmlmeShjb250ZXh0KSB7XG4gICAgY29uc3QgdmVyaWZpZXMgPSBmYWxzZSxcbiAgICAgICAgICBlcnJvclN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQud2FybmluZyhgVGhlICcke2Vycm9yU3RyaW5nfScgZXJyb3IgY2Fubm90IGJlIHZlcmlmaWVkLmApO1xuXG4gICAgcmV0dXJuIHZlcmlmaWVzO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkVycm9yXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCwgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFU19UWVBFLCBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZSwgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmNvbnN0IHsgYXN5bmNFdmVyeSB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgRXZlcnkgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHRoaXMuYW5vbnltb3VzUHJvY2VkdXJlID0gYW5vbnltb3VzUHJvY2VkdXJlO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRBbm9ueW1vdXNQcm9jZWR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5vbnltb3VzUHJvY2VkdXJlO1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgYXdhaXQgdGhpcy5icmVhayhjb250ZXh0KTtcblxuICAgIGNvbnN0IGV2ZXJ5U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke2V2ZXJ5U3RyaW5nfScgZXZlcnkuLi5gKTtcblxuICAgIHRlcm0gPSB0aGlzLnZhcmlhYmxlLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gTk9ERVNfVFlQRSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzICcke3Rlcm1UeXBlfScgdHlwZSBzaG91bGQgYmUgJyR7Tk9ERVNfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlcyA9IHRlcm0uZ2V0Tm9kZXMoKSxcbiAgICAgICAgICBib29sZWFuID0gYXdhaXQgYXN5bmNFdmVyeShub2RlcywgYXN5bmMgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXJtO1xuXG4gICAgICAgICAgICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cztcblxuICAgICAgICAgICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBUZXJtcy5mcm9tVGVybSh0ZXJtLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgdGVybSA9IGF3YWl0IHRoaXMuYW5vbnltb3VzUHJvY2VkdXJlLmNhbGwodGVybXMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgICAgICAgICBpZiAodGVybVR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgICAgICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyB0eXBlIGlzICcke3Rlcm1UeXBlfScgd2hlbiBpdCBzaG91bGQgYmUgb2YgdHlwZSAnJHtCT09MRUFOX1RZUEV9Jy5gLFxuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBib29sZWFuID0gdGVybS5nZXRCb29sZWFuKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBib29sZWFuO1xuICAgICAgICAgIH0pO1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgLi4uZXZhbHVhdGVkIHRoZSAnJHtldmVyeVN0cmluZ30nIGV2ZXJ5IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkV2ZXJ5XCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCwgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFU19UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuY29uc3QgeyBhc3luY1JlZHVjZSB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUmVkdWNlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5pbml0aWFsRXhwcmVzc2lvbiA9IGluaXRpYWxFeHByZXNzaW9uO1xuICAgIHRoaXMuYW5vbnltb3VzUHJvY2VkdXJlID0gYW5vbnltb3VzUHJvY2VkdXJlO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRJbml0aWFsRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgcmVkdWNlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3JlZHVjZVN0cmluZ30nIHJlZHVjZS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFU19UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFU19UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gdGVybS5nZXROb2RlcygpLFxuICAgICAgICAgIGluaXRpYWxFeHByZXNzaW9uID0gYXdhaXQgdGhpcy5pbml0aWFsRXhwcmVzc2lvbi5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIHRlcm0gPSBhd2FpdCBhc3luY1JlZHVjZShub2RlcywgYXN5bmMgKGN1cnJlbnRFeHByZXNzaW9uLCBub2RlKSA9PiB7XG4gICAgICBsZXQgdGVybTtcblxuICAgICAgY29uc3QgeyBUZXJtcyB9ID0gZWxlbWVudHM7XG5cbiAgICAgIHRlcm0gPSBjdXJyZW50VGVybTsgLy8vXG5cbiAgICAgIGNvbnN0IHRlcm1zID0gVGVybXMuZnJvbVRlcm0odGVybSwgY29udGV4dCk7XG5cbiAgICAgIHRlcm0gPSB0ZXJtRnJvbU5vZGUobm9kZSwgY29udGV4dCk7XG5cbiAgICAgIHRlcm1zLmFkZFRlcm0odGVybSk7XG5cbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLmFub255bW91c1Byb2NlZHVyZS5jYWxsKHRlcm1zLCBjb250ZXh0KTtcblxuICAgICAgcmV0dXJuIHRlcm07XG4gICAgfSwgaW5pdGlhbEV4cHJlc3Npb24pO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGAuLi5ldmFsdWF0ZWQgdGhlICcke3JlZHVjZVN0cmluZ30nIHJlZHVjZSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJSZWR1Y2VcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFRlcm5hcnkgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtLCBpZkV4cHJlc3Npb24sIGVsc2VFeHByZXNzaW9uKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgICB0aGlzLmlmRXhwcmVzc2lvbiA9IGlmRXhwcmVzc2lvbjtcbiAgICB0aGlzLmVsc2VFeHByZXNzaW9uID0gZWxzZUV4cHJlc3Npb247XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBnZXRJZkJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmlmRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldEVsc2VCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5lbHNlRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IHRlcm5hcnlTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3Rlcm5hcnlTdHJpbmd9JyB0ZXJuYXJ5Li4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy50ZXJtLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gQk9PTEVBTl9UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgdHlwZSBpcyAnJHt0ZXJtVHlwZX0nIHdoZW4gaXQgc2hvdWxkIGJlIG9mIHR5cGUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIGJvb2xlYW4gPSBwcmltaXRpdmVWYWx1ZTsgLy8vXG5cbiAgICB0ZXJtID0gYm9vbGVhbiA/XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuaWZFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpIDpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVsc2VFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke3Rlcm5hcnlTdHJpbmd9JyB0ZXJuYXJ5IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlRlcm5hcnlcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB2YXJpYWJsZVN0cmluZ0Zyb21OYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFZhcmlhYmxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgdGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtO1xuICB9XG5cbiAgY29tcGFyZVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUpIHtcbiAgICBjb25zdCBjb21wYXJlc1RvVmFyaWFibGVOYW1lID0gKHRoaXMubmFtZSA9PT0gdmFyaWFibGVOYW1lKTtcblxuICAgIHJldHVybiBjb21wYXJlc1RvVmFyaWFibGVOYW1lO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlLi4uYCk7XG5cbiAgICBjb25zdCBuZXN0ZWQgPSB0cnVlLFxuICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IHRoaXMubmFtZSwgLy8vXG4gICAgICAgICAgdmFyaWFibGVQcmVzZW50ID0gY29udGV4dC5pc1ZhcmlhYmxlUHJlc2VudEJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSwgbmVzdGVkKTtcblxuICAgIGlmICghdmFyaWFibGVQcmVzZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIGlzIG5vdCBwcmVzZW50LidgLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgdmFyaWFibGUgPSBjb250ZXh0LmZpbmRWYXJpYWJsZUJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSksXG4gICAgICAgICAgdGVybSA9IHZhcmlhYmxlLmdldFRlcm0oKSxcbiAgICAgICAgICB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7dmFyaWFibGVTdHJpbmd9JyB2YXJpYWJsZSBhcyB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0uYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIGFzc2lnbih0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbmVzdGVkID0gZmFsc2UsXG4gICAgICAgICAgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgdmFyaWFibGVOYW1lID0gdGhpcy5uYW1lLCAvLy9cbiAgICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCksIC8vL1xuICAgICAgICAgIHZhcmlhYmxlUHJlc2VudCA9IGNvbnRleHQuaXNWYXJpYWJsZVByZXNlbnRCeVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUsIG5lc3RlZCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBBc3NpZ25pbmcgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtIHRvIHRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlLi4uYCk7XG5cbiAgICBpZiAodmFyaWFibGVQcmVzZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIGlzIGFscmVhZHkgcHJlc2VudC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKSxcbiAgICAgICAgICB2YXJpYWJsZVR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IHZhcmlhYmxlVHlwZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dmFyaWFibGVTdHJpbmd9IHZhcmlhYmxlJ3MgJyR7dmFyaWFibGVUeXBlfScgdHlwZSBkb2VzIG5vdCBjb21wYXJlIHRvIHRoZSB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlLidgLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcblxuICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpczsgIC8vL1xuXG4gICAgY29udGV4dC5hZGRWYXJpYWJsZSh2YXJpYWJsZSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5hc3NpZ25lZCB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gdG8gdGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUuYCk7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVmFyaWFibGVcIjtcblxuICBzdGF0aWMgZnJvbVBhcmFtZXRlcihwYXJhbWV0ZXIsIGNvbnRleHQpIHtcbiAgICBjb25zdCB0eXBlID0gcGFyYW1ldGVyLmdldFR5cGUoKSxcbiAgICAgICAgICBuYW1lID0gcGFyYW1ldGVyLmdldE5hbWUoKSxcbiAgICAgICAgICB0ZXJtID0gbnVsbCxcbiAgICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUobmFtZSksXG4gICAgICAgICAgc3RyaW5nID0gdmFyaWFibGVTdHJpbmcsICAvLy9cbiAgICAgICAgICBub2RlID0gbnVsbDtcblxuICAgIGNvbnRleHQgPSBudWxsO1xuXG4gICAgY29uc3QgdmFyaWFibGUgPSBuZXcgVmFyaWFibGUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lLCB0ZXJtKTtcblxuICAgIHJldHVybiB2YXJpYWJsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpIHtcbiAgICBjb25zdCBhbGlhc2VkTmFtZSA9IG5hbWVkUGFyYW1ldGVyLmdldEFsaWFzZWROYW1lKCksXG4gICAgICAgICAgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKSxcbiAgICAgICAgICBuYW1lID0gYWxpYXNlZE5hbWUsIC8vL1xuICAgICAgICAgIHRlcm0gPSBudWxsLFxuICAgICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGVTdHJpbmdGcm9tTmFtZShuYW1lKSxcbiAgICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZVN0cmluZywgIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIHRlcm0pO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21UZXJtQW5kUGFyYW1ldGVyKHRlcm0sIHBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWUgPSBwYXJhbWV0ZXIuZ2V0TmFtZSgpLFxuICAgICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGVTdHJpbmdGcm9tTmFtZShuYW1lKSxcbiAgICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZVN0cmluZywgIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIHRlcm0pO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgbnVsbE5vZGUgZnJvbSBcIi4uL251bGxOb2RlXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBOT0RFU19UWVBFLCBTVFJJTkdfVFlQRSwgTlVNQkVSX1RZUEUsIEJPT0xFQU5fVFlQRSAgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgeyBtYXRjaCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBQcmltaXRpdmUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgICBwcmltaXRpdmUgPSB0aGlzLFxuICAgICAgICAgIHRlcm0gPSBUZXJtLmZyb21QcmltaXRpdmUocHJpbWl0aXZlLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgaXNFcXVhbFRvKHByaW1pdGl2ZSkge1xuICAgIGxldCBlcXVhbFRvID0gZmFsc2U7XG5cbiAgICBjb25zdCB0eXBlID0gcHJpbWl0aXZlLmdldFR5cGUoKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcHJpbWl0aXZlLmdldFZhbHVlKCk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE5PREVfVFlQRToge1xuICAgICAgICAgIGNvbnN0IG5vZGVBID0gdGhpcy52YWx1ZSwgLy8vXG4gICAgICAgICAgICAgICAgbm9kZUIgPSB2YWx1ZSwgIC8vL1xuICAgICAgICAgICAgICAgIG5vZGVNYXRjaGVzID0gbWF0Y2hOb2RlKG5vZGVBLCBub2RlQik7XG5cbiAgICAgICAgICBpZiAobm9kZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIGVxdWFsVG8gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBOT0RFU19UWVBFOiB7XG4gICAgICAgICAgY29uc3Qgbm9kZXNBID0gdGhpcy52YWx1ZSwgLy8vXG4gICAgICAgICAgICAgICAgbm9kZXNCID0gdmFsdWUsICAvLy9cbiAgICAgICAgICAgICAgICBub2Rlc01hdGNoID0gbWF0Y2hOb2Rlcyhub2Rlc0EsIG5vZGVzQik7XG5cbiAgICAgICAgICBpZiAobm9kZXNNYXRjaCkge1xuICAgICAgICAgICAgZXF1YWxUbyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIFNUUklOR19UWVBFOiB7XG4gICAgICAgICAgY29uc3Qgc3RyaW5nTGl0ZXJhbEEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBzdHJpbmdMaXRlcmFsQiA9IHZhbHVlOyAgLy8vXG5cbiAgICAgICAgICBpZiAoc3RyaW5nTGl0ZXJhbEEgPT09IHN0cmluZ0xpdGVyYWxCKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgTlVNQkVSX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBudW1iZXJBID0gdGhpcy52YWx1ZSwgLy8vXG4gICAgICAgICAgICAgICAgbnVtYmVyQiA9IHZhbHVlOyAgLy8vXG5cbiAgICAgICAgICBpZiAobnVtYmVyQSA9PT0gbnVtYmVyQikge1xuICAgICAgICAgICAgZXF1YWxUbyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIEJPT0xFQU5fVFlQRToge1xuICAgICAgICAgIGNvbnN0IGJvb2xlYW5BID0gdGhpcy52YWx1ZSwgLy8vXG4gICAgICAgICAgICAgICAgYm9vbGVhbkIgPSB2YWx1ZTsgIC8vL1xuXG4gICAgICAgICAgaWYgKGJvb2xlYW5BID09PSBib29sZWFuQikge1xuICAgICAgICAgICAgZXF1YWxUbyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWxUbztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQcmltaXRpdmVcIjtcbn0pO1xuXG5mdW5jdGlvbiBtYXRjaE5vZGUobm9kZUEsIG5vZGVCKSB7XG4gIGxldCBub2RlTWF0Y2hlcztcblxuICBpZiAoKG5vZGVBID09PSBudWxsTm9kZSkgfHwgKG5vZGVCID09PSBudWxsTm9kZSkpIHtcbiAgICBub2RlTWF0Y2hlcyA9IChub2RlQSA9PT0gbm9kZUIpO1xuICB9IGVsc2UgaWYgKG5vZGVBID09PSBudWxsTm9kZSkge1xuICAgIG5vZGVNYXRjaGVzID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAobm9kZUIgPT09IG51bGxOb2RlKSB7XG4gICAgbm9kZU1hdGNoZXMgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub2RlQU1hdGNoZXNOb2RlQiA9IG5vZGVBLm1hdGNoKG5vZGVCKTtcblxuICAgIG5vZGVNYXRjaGVzID0gbm9kZUFNYXRjaGVzTm9kZUI7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlTWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gbWF0Y2hOb2Rlcyhub2Rlc0EsIG5vZGVzQikge1xuICBjb25zdCBub2Rlc01hdGNoID0gbWF0Y2gobm9kZXNBLCBub2Rlc0IsIChub2RlQSwgbm9kZUIpID0+IHtcbiAgICBjb25zdCBub2RlTWF0Y2hlcyA9IG1hdGNoTm9kZShub2RlQSwgbm9kZUIpO1xuXG4gICAgaWYgKG5vZGVNYXRjaGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBub2Rlc01hdGNoO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFJlZmVyZW5jZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIG5hbWUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0UHJvY2VkdXJlTmFtZSgpIHtcbiAgICBjb25zdCBwcm9jZWR1cmVOYW1lID0gdGhpcy5uYW1lOyAgLy8vXG5cbiAgICByZXR1cm4gcHJvY2VkdXJlTmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJSZWZlcmVuY2VcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFByb2NlZHVyZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIGxhYmVsLCBwYXJhbWV0ZXJzLCByZXR1cm5CbG9jaykge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5yZXR1cm5CbG9jayA9IHJldHVybkJsb2NrO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0TGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnM7XG4gIH1cblxuICBnZXRSZXR1cm5CbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXR1cm5CbG9jaztcbiAgfVxuXG4gIGlzQm9vbGVhbigpIHtcbiAgICBjb25zdCB0eXBlQm9vbGVhblR5cGUgPSAodGhpcy50eXBlID09PSBCT09MRUFOX1RZUEUpLFxuICAgICAgICAgIGJvb2xlYW4gPSB0eXBlQm9vbGVhblR5cGU7ICAvLy9cblxuICAgIHJldHVybiBib29sZWFuO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHsgcmV0dXJuIHRoaXMubGFiZWwuZ2V0TmFtZSgpOyB9XG5cbiAgZ2V0UmV0dXJuU3RhdGVtZW50KCkgeyByZXR1cm4gdGhpcy5yZXR1cm5CbG9jay5nZXRSZXR1cm5TdGF0ZW1lbnQoKTsgfVxuXG4gIGNvbXBhcmVQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpIHsgcmV0dXJuIHRoaXMubGFiZWwuY29tcGFyZVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSk7IH1cblxuICBhc3luYyBjYWxsKHRlcm1zLCBjb250ZXh0KSB7XG4gICAgYXdhaXQgdGhpcy5icmVhayhjb250ZXh0KTtcblxuICAgIGNvbnN0IHByb2NlZHVyZVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENhbGxpbmcgdGhlICcke3Byb2NlZHVyZVN0cmluZ30nIHByb2NlZHVyZS4uLmApO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmNvbXBhcmVUZXJtcyh0ZXJtcywgY29udGV4dCk7XG5cbiAgICBjb25zdCB2YXJpYWJsZXMgPSB2YXJpYWJsZXNGcm9tVGVybXNBbmRQYXJhbWV0ZXJzKHRlcm1zLCB0aGlzLnBhcmFtZXRlcnMsIGNvbnRleHQpLFxuICAgICAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnJldHVybkJsb2NrLmV2YWx1YXRlKHZhcmlhYmxlcywgY29udGV4dCksXG4gICAgICAgICAgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09IHRlcm1UeXBlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIGlzIG5vdCBlcXVhbCB0byB0aGUgJyR7cHJvY2VkdXJlU3RyaW5nfScgcHJvY2VkdXJlJ3MgJyR7dGhpcy50eXBlfScgdHlwZS5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY2FsbGVkIHRoZSAnJHtwcm9jZWR1cmVTdHJpbmd9JyBwcm9jZWR1cmUuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQcm9jZWR1cmVcIjtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVzRnJvbVRlcm1zQW5kUGFyYW1ldGVycyh0ZXJtcywgcGFyYW1ldGVycywgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcblxuICB0ZXJtcy5mb3JFYWNoVGVybSgodGVybSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzLmdldFBhcmFtZXRlcihpbmRleCk7XG5cbiAgICBpZiAocGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7IFZhcmlhYmxlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgICAgIHZhcmlhYmxlID0gVmFyaWFibGUuZnJvbVRlcm1BbmRQYXJhbWV0ZXIodGVybSwgcGFyYW1ldGVyLCBjb250ZXh0KTtcblxuICAgICAgdmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE5vZGVRdWVyeSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBxdWVyeSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3Qgbm9kZVF1ZXJ5U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bm9kZVF1ZXJ5U3RyaW5nfScgbm9kZSBxdWVyeS4uLmApO1xuXG4gICAgaWYgKHRoaXMucXVlcnkgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ2Fubm90IGV2YWx1YXRlIHRoZSAnJHtub2RlUXVlcnlTdHJpbmd9JyBub2RlIHF1ZXJ5IGJlY2F1c2UgaXRzIGV4cHJlc3Npb24gaXMgbWFsZm9ybWVkLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IE5PREVfVFlQRSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzICcke3Rlcm1UeXBlfScgdHlwZSBzaG91bGQgYmUgJyR7Tk9ERV9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGxldCBub2RlO1xuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCk7XG5cbiAgICBub2RlID0gcHJpbWl0aXZlVmFsdWU7ICAvLy9cblxuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3Mgbm9kZSBpcyBudWxsLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlcyA9IHRoaXMucXVlcnkuZXhlY3V0ZShub2RlKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChub2Rlc0xlbmd0aCAhPT0gMSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBub2RlcyBpcyAke25vZGVzTGVuZ3RofSB3aGVuIGl0IHNob3VsZCBiZSAxLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdE5vZGUgPSBmaXJzdChub2Rlcyk7XG5cbiAgICBub2RlID0gZmlyc3ROb2RlOyAvLy9cblxuICAgIHRlcm0gPSB0ZXJtRnJvbU5vZGUobm9kZSwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bm9kZVF1ZXJ5U3RyaW5nfScgbm9kZSBxdWVyeSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJOb2RlUXVlcnlcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBQYXJhbWV0ZXIgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgY29tcGFyZVRlcm0odGVybSwgY29udGV4dCkge1xuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgIHBhcmFtZXRlclN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gYWdhaW5zdCB0aGUgJyR7cGFyYW1ldGVyU3RyaW5nfScgcGFyYW1ldGVyLi4uYCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdGVybVR5cGUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIGlzIG5vdCBlcXVhbCB0byB0aGUgJyR7cGFyYW1ldGVyU3RyaW5nfScgcGFyYW1ldGVyJ3MgJyR7dGhpcy50eXBlfScgdHlwZS5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyaW5nIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSBhZ2FpbnN0IHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIuYCk7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiUGFyYW1ldGVyXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUGFyYW1ldGVycyBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVyKGluZGV4KSB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5hcnJheVtpbmRleF0gfHwgbnVsbDtcblxuICAgIHJldHVybiBwYXJhbWV0ZXI7XG4gIH1cblxuICBmb3JFYWNoUGFyYW1ldGVyKGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBjb21wYXJlVGVybXModGVybXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtc1N0cmluZyA9IHRlcm1zLmdldFN0cmluZygpLFxuICAgICAgICAgIHBhcmFtZXRlcnNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7dGVybXNTdHJpbmd9JyB0ZXJtcyBhZ2FpbnN0IHRoZSAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycy4uLmApO1xuXG4gICAgY29uc3QgdGVybXNMZW5ndGggPSB0ZXJtcy5nZXRMZW5ndGgoKSxcbiAgICAgICAgICBwYXJhbWV0ZXJzTGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuICAgIGlmICh0ZXJtc0xlbmd0aCAhPT0gcGFyYW1ldGVyc0xlbmd0aCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dGVybXNTdHJpbmd9JyBleHByZXNzaW9ucyBhbmQgJyR7cGFyYW1ldGVyc1N0cmluZ30nIHBhcmFtZXRlcnMgYXJlIG5vdCBvZiB0aGUgc2FtZSBsZW5ndGguYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZm9yRWFjaFBhcmFtZXRlcigocGFyYW1ldGVyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHBhcmFtZXRlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0ZXJtID0gdGVybXMuZ2V0VGVybShpbmRleCk7XG5cbiAgICAgICAgcGFyYW1ldGVyLmNvbXBhcmVUZXJtKHRlcm0sIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyZWQgdGhlICcke3Rlcm1zU3RyaW5nfScgdGVybXMgYWdhaW5zdCB0aGUgJyR7cGFyYW1ldGVyc1N0cmluZ30nIHBhcmFtZXRlcnMuYCk7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiUGFyYW1ldGVyc1wiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVfVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgTm9kZXNRdWVyeSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBxdWVyeSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3Qgbm9kZXNRdWVyeVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke25vZGVzUXVlcnlTdHJpbmd9JyBub2RlcyBxdWVyeS4uLmApO1xuXG4gICAgaWYgKHRoaXMucXVlcnkgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQ2Fubm90IGV2YWx1YXRlIHRoZSAnJHtub2Rlc1F1ZXJ5U3RyaW5nfScgbm9kZXMgcXVlcnkgYmVjYXVzZSBpdHMgZXhwcmVzc2lvbiBpcyBtYWxmb3JtZWQuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRlcm0gPSB0aGlzLnZhcmlhYmxlLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gTk9ERV9UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgbGV0IG5vZGU7XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKTtcblxuICAgIG5vZGUgPSBwcmltaXRpdmVWYWx1ZTsgIC8vL1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyBub2RlIGlzIG51bGwuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5xdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke25vZGVzUXVlcnlTdHJpbmd9JyBub2RlcyBxdWVyeSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJOb2Rlc1F1ZXJ5XCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBFeHByZXNzaW9uIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdGVybSwgc29tZSwgZXZlcnksIHJlZHVjZSwgdGVybmFyeSwgbm9kZVF1ZXJ5LCBub2Rlc1F1ZXJ5LCByZXR1cm5CbG9jaywgcHJvY2VkdXJlQ2FsbCkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudGVybSA9IHRlcm07XG4gICAgdGhpcy5zb21lID0gc29tZTtcbiAgICB0aGlzLmV2ZXJ5ID0gZXZlcnk7XG4gICAgdGhpcy5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgdGhpcy50ZXJuYXJ5ID0gdGVybmFyeTtcbiAgICB0aGlzLm5vZGVRdWVyeSA9IG5vZGVRdWVyeTtcbiAgICB0aGlzLm5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5O1xuICAgIHRoaXMucmV0dXJuQmxvY2sgPSByZXR1cm5CbG9jaztcbiAgICB0aGlzLnByb2NlZHVyZUNhbGwgPSBwcm9jZWR1cmVDYWxsO1xuICB9XG5cbiAgZ2V0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtO1xuICB9XG5cbiAgZ2V0U29tZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zb21lO1xuICB9XG5cbiAgZ2V0RXZlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlcnk7XG4gIH1cblxuICBnZXRSZWR1Y2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlO1xuICB9XG5cbiAgZ2V0VGVybmFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJuYXk7XG4gIH1cblxuICBnZXROb2RlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVF1ZXJ5O1xuICB9XG5cbiAgZ2V0Tm9kZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1F1ZXJ5O1xuICB9XG5cbiAgZ2V0UmV0dXJuQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucmV0dXJuQmxvY2s7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVDYWxsKCkge1xuICAgIHJldHVybiB0aGlzLnByb2NlZHVyZUNhbGw7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudGVybSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMudGVybS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNvbWUgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnNvbWUuZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ldmVyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMuZXZlcnkuZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWR1Y2UgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnJlZHVjZS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlcm5hcnkgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnRlcm5hcnkuZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ub2RlUXVlcnkgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLm5vZGVRdWVyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGVzUXVlcnkgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLm5vZGVzUXVlcnkuZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZXR1cm5CbG9jayAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMucmV0dXJuQmxvY2suZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9jZWR1cmVDYWxsICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5wcm9jZWR1cmVDYWxsLmdldFR5cGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmICh0aGlzLnRlcm0gIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLnRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGVRdWVyeSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMubm9kZVF1ZXJ5LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ub2Rlc1F1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gdGhpcy5ub2Rlc1F1ZXJ5LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zb21lICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gYXdhaXQgdGhpcy5zb21lLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ldmVyeSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IGF3YWl0ICB0aGlzLmV2ZXJ5LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWR1Y2UgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnJlZHVjZS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVybmFyeSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IGF3YWl0IHRoaXMudGVybmFyeS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmV0dXJuQmxvY2sgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnJldHVybkJsb2NrLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9jZWR1cmVDYWxsICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gYXdhaXQgdGhpcy5wcm9jZWR1cmVDYWxsLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkV4cHJlc3Npb25cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5jb25zdCB7IHB1c2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9ja0NvbnRleHQgZXh0ZW5kcyBDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgdmFyaWFibGVzKSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG5cbiAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgfVxuXG4gIGdldFZhcmlhYmxlcyhuZXN0ZWQgPSB0cnVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW107XG5cbiAgICBwdXNoKHZhcmlhYmxlcywgdGhpcy52YXJpYWJsZXMpO1xuXG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcyA9IGNvbnRleHQuZ2V0VmFyaWFibGVzKCk7XG5cbiAgICAgIHB1c2godmFyaWFibGVzLCBjb250ZXh0VmFyaWFibGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyaWFibGVzO1xuICB9XG5cbiAgYWRkVmFyaWFibGUodmFyaWFibGUpIHtcbiAgICBjb25zdCBuZXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgICB2YXJpYWJsZU5hbWUgPSB2YXJpYWJsZS5nZXROYW1lKCksXG4gICAgICAgICAgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICB2YXJpYWJsZVByZXNlbnQgPSB0aGlzLmlzVmFyaWFibGVQcmVzZW50QnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lLCBuZXN0ZWQpO1xuXG4gICAgaWYgKHZhcmlhYmxlUHJlc2VudCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dmFyaWFibGVTdHJpbmd9JyB2YXJpYWJsZSBpcyBhbHJlYWR5IHByZXNlbnQuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpczsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBBZGRlZCB0aGUgJyR7dmFyaWFibGVTdHJpbmd9JyB2YXJpYWJsZSB0byB0aGUgY29udGV4dC5gKTtcblxuICAgIHRoaXMudmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICB9XG5cbiAgZmluZFByb2NlZHVyZUJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgIHByb2NlZHVyZSA9IGNvbnRleHQuZmluZFByb2NlZHVyZUJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTtcblxuICAgIHJldHVybiBwcm9jZWR1cmU7XG4gIH1cblxuICBpc1Byb2NlZHVyZVByZXNlbnRCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoKSxcbiAgICAgICAgICBwcm9jZWR1cmVQcmVzZW50ID0gY29udGV4dC5pc1Byb2NlZHVyZVByZXNlbnRCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSk7XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlUHJlc2VudDtcbiAgfVxuXG4gIGZpbmRWYXJpYWJsZUJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSwgbmVzdGVkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKG5lc3RlZCksXG4gICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZXMuZmluZCgodmFyaWFibGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlQ29tcGFyZXNUb1ZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlLmNvbXBhcmVWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lKTtcblxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlQ29tcGFyZXNUb1ZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG5cbiAgaXNWYXJpYWJsZVByZXNlbnRCeVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUsIG5lc3RlZCA9IHRydWUpIHtcbiAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZmluZFZhcmlhYmxlQnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lLCBuZXN0ZWQpLFxuICAgICAgICAgIHZhcmlhYmxlUHJlc2VudCA9ICh2YXJpYWJsZSAhPT0gbnVsbCk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVQcmVzZW50O1xuICB9XG5cbiAgc3RhdGljIGZyb21WYXJpYWJsZXModmFyaWFibGVzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYmxvY2tDb250ZXh0ID0gQ29udGV4dC5mcm9tTm90aGluZyhCbG9ja0NvbnRleHQsIHZhcmlhYmxlcywgY29udGV4dClcblxuICAgIHJldHVybiBibG9ja0NvbnRleHQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCwgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcbmltcG9ydCBCbG9ja0NvbnRleHQgZnJvbSBcIi4uL2NvbnRleHQvYmxvY2tcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmNvbnN0IHsgYXN5bmNGb3JFYWNoIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBSZXR1cm5CbG9jayBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHN0ZXBzLCBub25zZW5zaWNhbCwgcmV0dXJuU3RhdGVtZW50KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgIHRoaXMubm9uc2Vuc2ljYWwgPSBub25zZW5zaWNhbDtcbiAgICB0aGlzLnJldHVyblN0YXRlbWVudCA9IHJldHVyblN0YXRlbWVudDtcbiAgfVxuXG4gIGdldFN0ZXBzKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzO1xuICB9XG5cbiAgaXNOb25zZW5zaWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub25zZW5zaWNhbDtcbiAgfVxuXG4gIGdldFJldHVyblN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZW1lbnQ7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZSh2YXJpYWJsZXMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250ZXh0ID0gdmFyaWFibGVzOyAgLy8vXG5cbiAgICAgIHZhcmlhYmxlcyA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldHVybkJsb2NrU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtyZXR1cm5CbG9ja1N0cmluZ30nIHJldHVybiBibG9jay4uLmApO1xuXG4gICAgaWYgKHRoaXMubm9uc2Vuc2ljYWwpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlIHJldHVybiBibG9jayBpcyBub25zZW5zaWNhbC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tDb250ZXh0ID0gQmxvY2tDb250ZXh0LmZyb21WYXJpYWJsZXModmFyaWFibGVzLCBjb250ZXh0KTtcblxuICAgIGNvbnRleHQgPSBibG9ja0NvbnRleHQ7IC8vL1xuXG4gICAgYXdhaXQgYXN5bmNGb3JFYWNoKHRoaXMuc3RlcHMsIGFzeW5jIChzdGVwKSA9PiB7XG4gICAgICBhd2FpdCBzdGVwLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdGVybSA9IHRoaXMucmV0dXJuU3RhdGVtZW50LmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgRXZhbHVhdGVkLi4uIHRoZSAnJHtyZXR1cm5CbG9ja1N0cmluZ30nIHJldHVybiBibG9jayBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJSZXR1cm5CbG9ja1wiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBOZWdhdGVkVGVybSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHRlcm0pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGVybSA9IHRlcm07XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBuZWdhdGVkVGVybVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bmVnYXRlZFRlcm1TdHJpbmd9JyBuZWdhdGVkIHRlcm0uLi5gKTtcblxuICAgIHRlcm0gPSB0aGlzLnRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIGxlZnQgdGVybSdzIHR5cGUgaXMgJyR7dGVybVR5cGV9JyB3aGVuIGl0IHNob3VsZCBiZSBvZiB0eXBlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgYm9vbGVhbjtcblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpO1xuXG4gICAgYm9vbGVhbiA9IHByaW1pdGl2ZVZhbHVlOyAvLy9cblxuICAgIGJvb2xlYW4gPSAhYm9vbGVhbjtcblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bmVnYXRlZFRlcm1TdHJpbmd9JyBuZWdhdGVkIHRlcm0gYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiTmVnYXRlZFRlcm1cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tQm9vbGVhbiB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvdGVybVwiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgTG9naWNhbFRlcm0gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBkaXNqdW5jdGlvbiwgbGVmdFRlcm0sIHJpZ2h0VGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kaXNqdW5jdGlvbiA9IGRpc2p1bmN0aW9uO1xuICAgIHRoaXMubGVmdFRlcm0gPSBsZWZ0VGVybTtcbiAgICB0aGlzLnJpZ2h0VGVybSA9IHJpZ2h0VGVybTtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGlzRGlzanVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzanVuY3Rpb247XG4gIH1cblxuICBnZXRMZWZ0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0VGVybTtcbiAgfVxuXG4gIGdldFJpZ2h0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodFRlcm07XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBsb2dpY2FsVGVybVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bG9naWNhbFRlcm1TdHJpbmd9JyBsb2dpY2FsIHRlcm0uLi5gKTtcblxuICAgIGNvbnN0IGxlZnRUZXJtID0gdGhpcy5sZWZ0VGVybS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICByaWdodFRlcm0gPSB0aGlzLnJpZ2h0VGVybS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICBsZWZ0VGVybVR5cGUgPSBsZWZ0VGVybS5nZXRUeXBlKCksXG4gICAgICAgICAgcmlnaHRUZXJtVHlwZSA9IHJpZ2h0VGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAobGVmdFRlcm1UeXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgIGNvbnN0IGxlZnRUZXJtU3RyaW5nID0gbGVmdFRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHtsZWZ0VGVybVN0cmluZ30nIGxlZnQgdGVybSdzIHR5cGUgaXMgJyR7bGVmdFRlcm1UeXBlfScgd2hlbiBpdCBzaG91bGQgYmUgb2YgdHlwZSAnJHtCT09MRUFOX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0VGVybVR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgcmlnaHRUZXJtU3RyaW5nID0gcmlnaHRUZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7cmlnaHRUZXJtU3RyaW5nfScgcmlnaHQgdGVybSdzIHR5cGUgaXMgJyR7cmlnaHRUZXJtVHlwZX0nIHdoZW4gaXQgc2hvdWxkIGJlIG9mIHR5cGUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGxlZnRUZXJtUHJpbWl0aXZlVmFsdWUgPSBsZWZ0VGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIHJpZ2h0VGVybVByaW1pdGl2ZVZhbHVlID0gcmlnaHRUZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgbGVmdEJvb2xlYW4gPWxlZnRUZXJtUHJpbWl0aXZlVmFsdWUsIC8vL1xuICAgICAgICAgIHJpZ2h0Qm9vbGVhbiA9IHJpZ2h0VGVybVByaW1pdGl2ZVZhbHVlLCAvLy9cbiAgICAgICAgICBib29sZWFuID0gdGhpcy5kaXNqdW5jdGlvbiA/XG4gICAgICAgICAgICAgICAgICAgICAgKGxlZnRCb29sZWFuIHx8IHJpZ2h0Qm9vbGVhbikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKGxlZnRCb29sZWFuICYmIHJpZ2h0Qm9vbGVhbik7XG5cbiAgICB0ZXJtID0gdGVybUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke2xvZ2ljYWxUZXJtU3RyaW5nfScgbG9naWNhbCB0ZXJtIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkxvZ2ljYWxUZXJtXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBCcmFja2V0ZWRUZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudGVybSA9IHRlcm07XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBnZXRUeXBlKCkgeyByZXR1cm4gdGhpcy50ZXJtLmdldFR5cGUoKTsgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IGJyYWNrZXRlZFRlcm1TdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke2JyYWNrZXRlZFRlcm1TdHJpbmd9JyBicmFja2V0ZWQgdGVybS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHticmFja2V0ZWRUZXJtU3RyaW5nfScgYnJhY2tldGVkIHRlcm0gYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiQnJhY2tldGVkVGVybVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFByb2NlZHVyZUNhbGwgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCByZWZlcmVuY2UsIHRlcm1zKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XG4gICAgdGhpcy50ZXJtcyA9IHRlcm1zO1xuICB9XG5cbiAgZ2V0UmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZTtcbiAgfVxuXG4gIGdldFRlcm1zKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm1zO1xuICB9XG5cbiAgZ2V0UHJvY2VkdXJlTmFtZSgpIHsgcmV0dXJuIHRoaXMucmVmZXJlbmNlLmdldFByb2NlZHVyZU5hbWUoKTsgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgcHJvY2VkdXJlQ2FsbFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3Byb2NlZHVyZUNhbGxTdHJpbmd9JyBwcm9jZWR1cmUgY2FsbC4uLmApO1xuXG4gICAgY29uc3QgcHJvY2VkdXJlTmFtZSA9IHRoaXMuZ2V0UHJvY2VkdXJlTmFtZSgpLFxuICAgICAgICAgIHByb2NlZHVyZVByZXNlbnQgPSBjb250ZXh0LmlzUHJvY2VkdXJlUHJlc2VudEJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTtcblxuICAgIGlmICghcHJvY2VkdXJlUHJlc2VudCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7cHJvY2VkdXJlQ2FsbFN0cmluZ30gcHJvY2VkdXJlIGlzIG5vdCBwcmVzZW50LidgLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJvY2VkdXJlID0gY29udGV4dC5maW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpLFxuICAgICAgICAgIHRlcm1zID0gdGhpcy50ZXJtcy5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtID0gYXdhaXQgcHJvY2VkdXJlLmNhbGwodGVybXMsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke3Byb2NlZHVyZUNhbGxTdHJpbmd9JyBwcm9jZWR1cmUgY2FsbCBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQcm9jZWR1cmVDYWxsXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBDb21wYXJpc29uVGVybSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIG5lZ2F0ZWQsIGxlZnRUZXJtLCByaWdodFRlcm0pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLm5lZ2F0ZWQgPSBuZWdhdGVkO1xuICAgIHRoaXMubGVmdFRlcm0gPSBsZWZ0VGVybTtcbiAgICB0aGlzLnJpZ2h0VGVybSA9IHJpZ2h0VGVybTtcbiAgfVxuXG4gIGlzTmVnYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGVkO1xuICB9XG5cbiAgZ2V0TGVmdFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdFRlcm07XG4gIH1cblxuICBnZXRSaWdodFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHRUZXJtO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgY29tcGFyaXNvblRlcm1TdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke2NvbXBhcmlzb25UZXJtU3RyaW5nfScgY29tcGFyaXNvbiB0ZXJtLi4uYCk7XG5cbiAgICBjb25zdCBsZWZ0VGVybSA9IHRoaXMubGVmdFRlcm0uZXZhbHVhdGUoY29udGV4dCksXG4gICAgICAgICAgcmlnaHRUZXJtID0gdGhpcy5yaWdodFRlcm0uZXZhbHVhdGUoY29udGV4dCksXG4gICAgICAgICAgbGVmdFRlcm1UeXBlID0gbGVmdFRlcm0uZ2V0VHlwZSgpLFxuICAgICAgICAgIHJpZ2h0VGVybVR5cGUgPSByaWdodFRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKGxlZnRUZXJtVHlwZSAhPT0gcmlnaHRUZXJtVHlwZSkge1xuICAgICAgY29uc3QgbGVmdFRlcm1TdHJpbmcgPSBsZWZ0VGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIHJpZ2h0VGVybVN0cmluZyA9IHJpZ2h0VGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke2xlZnRUZXJtU3RyaW5nfScgbGVmdCB0ZXJtJ3MgdHlwZSBpcyAnJHtsZWZ0VGVybVR5cGV9JyB3aGVyZWFzIHRoZSAnJHtyaWdodFRlcm1TdHJpbmd9JyByaWdodCB0ZXJtJ3MgdHlwZSBpcyAnJHtyaWdodFRlcm1UeXBlfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGxlZnRUZXJtRXF1YWxUb1JpZ2h0VGVybSA9IGxlZnRUZXJtLmlzRXF1YWxUbyhyaWdodFRlcm0pO1xuXG4gICAgbGV0IGJvb2xlYW4gPSBsZWZ0VGVybUVxdWFsVG9SaWdodFRlcm07IC8vL1xuXG4gICAgaWYgKHRoaXMubmVnYXRlZCkge1xuICAgICAgYm9vbGVhbiA9ICFib29sZWFuOyAvLy9cbiAgICB9XG5cbiAgICB0ZXJtID0gdGVybUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke2NvbXBhcmlzb25UZXJtU3RyaW5nfScgY29tcGFyaXNvbiB0ZXJtIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkNvbXBhcmlzb25UZXJtXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgTmFtZWRQYXJhbWV0ZXIgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lLCBhbGlhcykge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRBbGlhcygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGlhcztcbiAgfVxuXG4gIGlzQWxpYXNlZCgpIHtcbiAgICBjb25zdCBhbGlhc2VkID0gKHRoaXMuYWxpYXMgIT09IG51bGwpO1xuXG4gICAgcmV0dXJuIGFsaWFzZWQ7XG4gIH1cblxuICBnZXRBbGlhc2VkTmFtZSgpIHtcbiAgICBjb25zdCBhbGlhc2VkID0gdGhpcy5pc0FsaWFzZWQoKSxcbiAgICAgICAgICBhbGlhc2VkTmFtZSA9IGFsaWFzZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaWFzIDogIC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZTsgLy8vXG5cbiAgICByZXR1cm4gYWxpYXNlZE5hbWU7XG4gIH1cblxuICBjb21wYXJlVGVybSh0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLi4uYCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdGVybVR5cGUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIGlzIG5vdCBlcXVhbCB0byAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlcidzICcke3RoaXMudHlwZX0nIHR5cGUuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci5gKTtcbiAgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGxldCBuYW1lZFBhcmFtZXRlckNvbXBhcmVzO1xuXG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJBID0gdGhpcywgIC8vL1xuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyQiA9IG5hbWVkUGFyYW1ldGVyOyAvLy9cblxuICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyQVN0cmluZyA9IG5hbWVkUGFyYW1ldGVyQS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlckJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlckIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke25hbWVkUGFyYW1ldGVyQVN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlckJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlci5nZXROYW1lKCksXG4gICAgICAgICAgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKTtcblxuICAgIG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMgPSAoKHRoaXMubmFtZSA9PT0gbmFtZSkgJiYgKHRoaXMudHlwZSA9PT0gdHlwZSkpO1xuXG4gICAgaWYgKG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlckFTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJCU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLmApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lZFBhcmFtZXRlckNvbXBhcmVzO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5hbWVkUGFyYW1ldGVyXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IGVsZW1lbnRzIGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIE5PREVTX1RZUEUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIEFycmF5QXNzaWdtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGNvbnN0IGFycmF5QXNzaWdubWVudFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7YXJyYXlBc3NpZ25tZW50U3RyaW5nfScgYXJyYXkgYXNzaWdubWVudC4uLmApO1xuXG4gICAgY29uc3QgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCksXG4gICAgICAgICAgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gTk9ERVNfVFlQRSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzICcke3Rlcm1UeXBlfScgdHlwZSBzaG91bGQgYmUgJyR7Tk9ERVNfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBub2RlcyA9IHByaW1pdGl2ZVZhbHVlLCAvLy9cbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBwYXJhbWV0ZXJzTGVuZ3RoID0gdGhpcy5wYXJhbWV0ZXJzLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKHBhcmFtZXRlcnNMZW5ndGggPiBub2Rlc0xlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1ldGVyc1N0cmluZyA9IHRoaXMucGFyYW1ldGVycy5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG5vZGVzU3RyaW5nID0gY29udGV4dC5ub2Rlc0FzU3RyaW5nKG5vZGV4KSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlIGxlbmd0aCBvZiB0aGUgJyR7cGFyYW1ldGVyc1N0cmluZ30nIHBhcmFtZXRlcnMgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlICcke25vZGVzU3RyaW5nfScgbm9kZXMuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRoaXMucGFyYW1ldGVycy5mb3JFYWNoUGFyYW1ldGVyKChwYXJhbWV0ZXIsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpbmRleF0sXG4gICAgICAgICAgICAgIHRlcm0gPSB0ZXJtRnJvbU5vZGUobm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgdGhpcy5ldmFsdWF0ZVBhcmFtZXRlcihwYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHthcnJheUFzc2lnbm1lbnRTdHJpbmd9JyBhcnJheSBhc3NpZ25tZW50LmApO1xuICB9XG5cbiAgZXZhbHVhdGVQYXJhbWV0ZXIocGFyYW1ldGVyLCBleHByZXNzaW9uLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZXhwcmVzc2lvblN0cmluZyA9IGV4cHJlc3Npb24uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgcGFyYW1ldGVyU3RyaW5nID0gcGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cGFyYW1ldGVyU3RyaW5nfScgcGFyYW1ldGVyIGFnYWluc3QgdGhlICcke2V4cHJlc3Npb25TdHJpbmd9JyBleHByZXNzaW9uLi4uYCk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJUeXBlID0gcGFyYW1ldGVyLmdldFR5cGUoKTtcblxuICAgIGlmIChwYXJhbWV0ZXJUeXBlICE9PSBOT0RFX1RZUEUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlIHR5cGUgb2YgdGhlICcke3BhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlciBzaG91bGQgYmUgJyR7Tk9ERV9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHsgVmFyaWFibGUgfSA9IGVsZW1lbnRzLFxuICAgICAgICAgIHZhcmlhYmxlID0gVmFyaWFibGUuZnJvbVBhcmFtZXRlcihwYXJhbWV0ZXIsIGNvbnRleHQpO1xuXG4gICAgdmFyaWFibGUuYXNzaWduKGV4cHJlc3Npb24sIGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIgYWdhaW5zdCB0aGUgJyR7ZXhwcmVzc2lvblN0cmluZ30nIGV4cHJlc3Npb24uYCk7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiQXJyYXlBc3NpZ25tZW50XCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBSZXR1cm5TdGF0ZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IHJldHVyblN0YXRlbWVudFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3JldHVyblN0YXRlbWVudFN0cmluZ30nIHJldHVybiBzdGF0ZW1lbnQuLi5gKTtcblxuICAgIHRlcm0gPSB0aGlzLnRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7cmV0dXJuU3RhdGVtZW50U3RyaW5nfScgcmV0dXJuIHN0YXRlbWVudCBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJSZXR1cm5TdGF0ZW1lbnRcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBOYW1lZFBhcmFtZXRlcnMgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgZ2V0TGVuZ3RoKCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuXG4gIGdldE5hbWVkUGFyYW1ldGVyKGluZGV4KSB7XG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXIgPSB0aGlzLmFycmF5W2luZGV4XSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIG5hbWVkUGFyYW1ldGVyO1xuICB9XG5cbiAgc29tZU5hbWVkUGFyYW1ldGVyKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5LnNvbWUoY2FsbGJhY2spOyB9XG5cbiAgZm9yRWFjaE5hbWVkUGFyYW1ldGVyKGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBjb21wYXJlVGVybXModGVybXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtc1N0cmluZyA9IHRlcm1zLmdldFN0cmluZygpLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ29tcGFyaW5nIHRoZSAnJHt0ZXJtc1N0cmluZ30nIHRlcm1zIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMuLi5gKTtcblxuICAgIGNvbnN0IHRlcm1zTGVuZ3RoID0gdGVybXMuZ2V0TGVuZ3RoKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJzTGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuICAgIGlmICh0ZXJtc0xlbmd0aCAhPT0gbmFtZWRQYXJhbWV0ZXJzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtc1N0cmluZ30nIHRlcm1zIGFuZCAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzIGFyZSBub3Qgb2YgdGhlIHNhbWUgbGVuZ3RoLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLmZvckVhY2hOYW1lZFBhcmFtZXRlcigobmFtZWRQYXJhbWV0ZXIsIGluZGV4KSA9PiB7XG4gICAgICBpZiAobmFtZWRQYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdGVybSA9IHRlcm1zLmdldFRlcm0oaW5kZXgpO1xuXG4gICAgICAgIG5hbWVkUGFyYW1ldGVyLmNvbXBhcmVUZXJtKHRlcm0sIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyZWQgdGhlICcke3Rlcm1zU3RyaW5nfScgdGVybXMgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJzU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVycy5gKTtcbiAgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWRQYXJhbWV0ZXIgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJzU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVycy4uLmApO1xuXG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJBID0gbmFtZWRQYXJhbWV0ZXIsIC8vL1xuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMgPSB0aGlzLnNvbWVOYW1lZFBhcmFtZXRlcigobmFtZWRQYXJhbWV0ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lZFBhcmFtZXRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lZFBhcmFtZXRlckIgPSBuYW1lZFBhcmFtZXRlciwgLy8vXG4gICAgICAgICAgICAgICAgICAgIG5hbWVkUGFyYW1ldGVyQkNvbXBhcmVzVG9OYW1lZFBhcmFtZXRlckEgPSBuYW1lZFBhcmFtZXRlckEuY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyQiwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgaWYgKG5hbWVkUGFyYW1ldGVyQkNvbXBhcmVzVG9OYW1lZFBhcmFtZXRlckEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgaWYgKCFuYW1lZFBhcmFtZXRlckNvbXBhcmVzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkUGFyYW1ldGVyIGRvZXMgbm90IGNvbXBhcmUgdG8gYW55IG9mIHRoZSAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZFBhcmFtZXRlciB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzLmApO1xuICB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVycyhuYW1lZFBhcmFtZXRlcnMsIGNvbnRleHQpIHtcbiAgICBuYW1lZFBhcmFtZXRlcnMuZm9yRWFjaE5hbWVkUGFyYW1ldGVyKChuYW1lZFBhcmFtZXRlcikgPT4ge1xuICAgICAgaWYgKG5hbWVkUGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJOYW1lZFBhcmFtZXRlcnNcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBub2RlUHJvcGVydHlTdHJpbmdGcm9tTmFtZUFuZFR5cGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vZGVQcm9wZXJ0eSB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZywgdHlwZSwgbmFtZSkge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIGdldFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBjb21wYXJlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpIHtcbiAgICBsZXQgbmFtZWRQYXJhbWV0ZXJDb21wYXJlcztcblxuICAgIGNvbnN0IG5vZGVQcm9wZXJ0eVN0cmluZyA9IHRoaXMuc3RyaW5nLCAvLy9cbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgQ29tcGFyaW5nIHRoZSAnJHtub2RlUHJvcGVydHlTdHJpbmd9JyBub2RlIHByb3BlcnR5IHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLi4uYCk7XG5cbiAgICBjb25zdCBuYW1lID0gbmFtZWRQYXJhbWV0ZXIuZ2V0TmFtZSgpLFxuICAgICAgICAgIHR5cGUgPSBuYW1lZFBhcmFtZXRlci5nZXRUeXBlKCk7XG5cbiAgICBuYW1lZFBhcmFtZXRlckNvbXBhcmVzID0gKCh0aGlzLm5hbWUgPT09IG5hbWUpICYmICh0aGlzLnR5cGUgPT09IHR5cGUpKTtcblxuICAgIGlmIChuYW1lZFBhcmFtZXRlckNvbXBhcmVzKSB7XG4gICAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7bm9kZVByb3BlcnR5U3RyaW5nfScgbm9kZSBwcm9wZXJ0eSB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZWRQYXJhbWV0ZXJDb21wYXJlcztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQYXJhbWV0ZXJcIjtcblxuICBzdGF0aWMgZnJvbU5hbWVBbmRUeXBlKG5hbWUsIHR5cGUpIHtcbiAgICBjb25zdCBub2RlUHJvcGVydHlTdHJpbmcgPSBub2RlUHJvcGVydHlTdHJpbmdGcm9tTmFtZUFuZFR5cGUobmFtZSwgdHlwZSksXG4gICAgICAgICAgc3RyaW5nID0gbm9kZVByb3BlcnR5U3RyaW5nLCAgLy8vXG4gICAgICAgICAgbm9kZVByb3BlcnR5ID0gbmV3IE5vZGVQcm9wZXJ0eShzdHJpbmcsIHR5cGUsIG5hbWUpO1xuXG4gICAgcmV0dXJuIG5vZGVQcm9wZXJ0eTtcbiAgfVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IENPTlRFTlRfUEFSQU1FVEVSX05BTUUgPSBcImNvbnRlbnRcIjtcbmV4cG9ydCBjb25zdCBURVJNSU5BTF9QQVJBTUVURVJfTkFNRSA9IFwidGVybWluYWxcIjtcbmV4cG9ydCBjb25zdCBDSElMRF9OT0RFU19QQVJBTUVURVJfTkFNRSA9IFwiY2hpbGROb2Rlc1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuL2V4Y2VwdGlvblwiO1xuaW1wb3J0IE5vZGVQcm9wZXJ0eSBmcm9tIFwiLi9ub2RlUHJvcGVydHlcIjtcblxuaW1wb3J0IHsgTk9ERVNfVFlQRSwgU1RSSU5HX1RZUEUsIEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBub2RlUHJvcGVydGllc1N0cmluZ0Zyb21Ob2RlUHJvcGVydGllc0FycmF5IH0gZnJvbSBcIi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgQ09OVEVOVF9QQVJBTUVURVJfTkFNRSwgVEVSTUlOQUxfUEFSQU1FVEVSX05BTUUsIENISUxEX05PREVTX1BBUkFNRVRFUl9OQU1FIH0gZnJvbSBcIi4vcGFyYW1ldGVyTmFtZXNcIjtcblxuY2xhc3MgTm9kZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihzdHJpbmcsIGFycmF5KSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgc29tZU5vZGVQcm9wZXJ0eShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5zb21lKGNhbGxiYWNrKTsgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IG5vZGVQcm9wZXJ0aWVzU3RyaW5nID0gdGhpcy5zdHJpbmcsIC8vL1xuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIHdpdGggdGhlICcke25vZGVQcm9wZXJ0aWVzU3RyaW5nfScgbm9kZSBwcm9wZXJ0aWVzLi4uYCk7XG5cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlcnNDb21wYXJlID0gdGhpcy5zb21lTm9kZVByb3BlcnR5KChub2RlUHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyQ29tcGFyZXNUb05vZGVQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eS5jb21wYXJlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpO1xuXG4gICAgICBpZiAobmFtZWRQYXJhbWV0ZXJDb21wYXJlc1RvTm9kZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFuYW1lZFBhcmFtZXRlcnNDb21wYXJlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciBkb2VzIG5vdCBjb21wbWFyZSB0byBhbnkgb2YgdGhlICcke25vZGVQcm9wZXJ0aWVzU3RyaW5nfScgbm9kZSBwcm9wZXJ0aWVzLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgd2l0aCB0aGUgJyR7bm9kZVByb3BlcnRpZXNTdHJpbmd9JyBub2RlIHByb3BlcnRpZXMuYCk7XG4gIH1cblxuICBjb21wYXJlTmFtZWRQYXJhbWV0ZXJzKG5hbWVkUGFyYW1ldGVycywgY29udGV4dCkge1xuICAgIG5hbWVkUGFyYW1ldGVycy5mb3JFYWNoTmFtZWRQYXJhbWV0ZXIoKG5hbWVkUGFyYW1ldGVyKSA9PiB7XG4gICAgICB0aGlzLmNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgbm9kZVByb3BlcnRpZXNBcnJheSA9IG5vZGVQcm9wZXJ0aWVzQXJyYXlGcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZyA9IG5vZGVQcm9wZXJ0aWVzU3RyaW5nRnJvbU5vZGVQcm9wZXJ0aWVzQXJyYXkobm9kZVByb3BlcnRpZXNBcnJheSksXG4gICAgICAgICAgYXJyYXkgPSBub2RlUHJvcGVydGllc0FycmF5LCAgLy8vXG4gICAgICAgICAgbm9kZVByb3BlcnRpZXMgPSBuZXcgTm9kZVByb3BlcnRpZXMoc3RyaW5nLCBhcnJheSk7XG5cbiAgICByZXR1cm4gbm9kZVByb3BlcnRpZXM7XG4gIH1cbn1cblxuY29uc3Qgbm9kZVByb3BlcnRpZXMgPSBOb2RlUHJvcGVydGllcy5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlUHJvcGVydGllcztcblxuZnVuY3Rpb24gbm9kZVByb3BlcnRpZXNBcnJheUZyb21Ob3RoaW5nKCkge1xuICBjb25zdCB0eXBlcyA9IFtcbiAgICAgICAgICBTVFJJTkdfVFlQRSxcbiAgICAgICAgICBCT09MRUFOX1RZUEUsXG4gICAgICAgICAgTk9ERVNfVFlQRSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZXMgPSBbXG4gICAgICAgICAgQ09OVEVOVF9QQVJBTUVURVJfTkFNRSxcbiAgICAgICAgICBURVJNSU5BTF9QQVJBTUVURVJfTkFNRSxcbiAgICAgICAgICBDSElMRF9OT0RFU19QQVJBTUVURVJfTkFNRVxuICAgICAgICBdLFxuICAgICAgICBub2RlUHJvcGVydGllc0FycmF5ID0gbmFtZXMubWFwKChuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgbm9kZVByb3BlcnR5ID0gTm9kZVByb3BlcnR5LmZyb21OYW1lQW5kVHlwZShuYW1lLCB0eXBlKTtcblxuICAgICAgICAgIHJldHVybiBub2RlUHJvcGVydHk7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBub2RlUHJvcGVydGllc0FycmF5O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcbmltcG9ydCBub2RlUHJvcGVydGllcyBmcm9tIFwiLi4vLi4vbm9kZVByb3BlcnRpZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBzdHJpbmdMaXRlcmFsRnJvbVN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBOT0RFU19UWVBFLCBTVFJJTkdfVFlQRSwgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGVzLCB0ZXJtRnJvbUJvb2xlYW4sIHRlcm1Gcm9tU3RyaW5nTGl0ZXJhbCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvdGVybVwiO1xuaW1wb3J0IHsgQ09OVEVOVF9QQVJBTUVURVJfTkFNRSwgVEVSTUlOQUxfUEFSQU1FVEVSX05BTUUsIENISUxEX05PREVTX1BBUkFNRVRFUl9OQU1FIH0gZnJvbSBcIi4uLy4uL3BhcmFtZXRlck5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBPYmplY3RBc3NpZ21lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgbmFtZWRQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHRoaXMubmFtZWRQYXJhbWV0ZXJzID0gbmFtZWRQYXJhbWV0ZXJzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXROYW1lZFBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZWRQYXJhbWV0ZXJzO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGNvbnN0IG9iamVjdEFzc2lnbm1lbnRTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke29iamVjdEFzc2lnbm1lbnRTdHJpbmd9JyBvYmplY3QgYXNzaWdubWVudC4uLmApO1xuXG4gICAgY29uc3QgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCksXG4gICAgICAgICAgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gTk9ERV9UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgbm9kZVByb3BlcnRpZXMuY29tcGFyZU5hbWVkUGFyYW1ldGVycyh0aGlzLm5hbWVkUGFyYW1ldGVycywgY29udGV4dCk7XG5cbiAgICB0aGlzLm5hbWVkUGFyYW1ldGVycy5mb3JFYWNoTmFtZWRQYXJhbWV0ZXIoKG5hbWVkUGFyYW1ldGVyKSA9PiB7XG4gICAgICB0aGlzLmV2YWx1YXRlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtvYmplY3RBc3NpZ25tZW50U3RyaW5nfScgb2JqZWN0IGFzc2lnbm1lbnQuYCk7XG4gIH1cblxuICBldmFsdWF0ZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCB0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIGFnYWluc3QgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtLi4uYCk7XG5cbiAgICBjb25zdCBuYW1lID0gbmFtZWRQYXJhbWV0ZXIuZ2V0TmFtZSgpO1xuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIENPTlRFTlRfUEFSQU1FVEVSX05BTUU6IHtcbiAgICAgICAgdGVybSA9IHRoaXMuZXZhbHVhdGVDb250ZW50TmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFRFUk1JTkFMX1BBUkFNRVRFUl9OQU1FOiB7XG4gICAgICAgIHRlcm0gPSB0aGlzLmV2YWx1YXRlVGVybWluYWxOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgQ0hJTERfTk9ERVNfUEFSQU1FVEVSX05BTUU6IHtcbiAgICAgICAgdGVybSA9IHRoaXMuZXZhbHVhdGVDaGlsZE5vZGVzTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgVmFyaWFibGUgfSA9IGVsZW1lbnRzLFxuICAgICAgICAgIHZhcmlhYmxlID0gVmFyaWFibGUuZnJvbU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KTtcblxuICAgIHZhcmlhYmxlLmFzc2lnbih0ZXJtLCBjb250ZXh0KTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIgbmFtZWQgYWdhaW5zdCB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0uYCk7XG4gIH1cblxuICBldmFsdWF0ZUNvbnRlbnROYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCkge1xuICAgIGNvbnN0IHR5cGUgPSBuYW1lZFBhcmFtZXRlci5nZXRUeXBlKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlIGNvbnRlbnQgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGlmICh0eXBlICE9PSBTVFJJTkdfVFlQRSkge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgdHlwZSBzaG91bGQgYmUgJyR7U1RSSU5HX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgbm9kZSA9IHByaW1pdGl2ZVZhbHVlLCAgLy8vXG4gICAgICAgICAgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmICghbm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIG5vZGUgbXVzdCBiZSB0ZXJtaW5hbC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIHN0cmluZyA9IGNvbnRlbnQsICAvLy9cbiAgICAgICAgICBzdHJpbmdMaXRlcmFsID0gc3RyaW5nTGl0ZXJhbEZyb21TdHJpbmcoc3RyaW5nKTtcblxuICAgIHRlcm0gPSB0ZXJtRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3R0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlIGNvbnRlbnQgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgYXMgJyR7dGVybVN0dHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXZhbHVhdGVUZXJtaW5hbE5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCB0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgdGVybWluYWwgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGlmICh0eXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlcidzIHR5cGUgc2hvdWxkIGJlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBub2RlID0gcHJpbWl0aXZlVmFsdWUsICAvLy9cbiAgICAgICAgICBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHRlcm1pbmFsID0gbm9kZVRlcm1pbmFsTm9kZTsgIC8vL1xuXG4gICAgY29uc3QgYm9vbGVhbiA9IHRlcm1pbmFsOyAvLy9cblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7ICAvLy9cblxuICAgIGNvbnN0IHRlcm1TdHRyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgdGVybWluYWwgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgYXMgJyR7dGVybVN0dHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgZXZhbHVhdGVDaGlsZE5vZGVzTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSBjaGlsZCBub2RlcyAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgaWYgKHR5cGUgIT09IE5PREVTX1RZUEUpIHtcbiAgICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlcidzIHR5cGUgc2hvdWxkIGJlICcke05PREVTX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgbm9kZSA9IHByaW1pdGl2ZVZhbHVlLCAgLy8vXG4gICAgICAgICAgbm9kZU5vblRlcm1pbmFsTm9kZSA9IG5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmICghbm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIG5vZGUgbXVzdCBiZSBub24tdGVybWluYWwuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGUsICAvLy9cbiAgICAgICAgICBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBub2RlcyA9IGNoaWxkTm9kZXM7ICAvLy9cblxuICAgIHRlcm0gPSB0ZXJtRnJvbU5vZGVzKG5vZGVzLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHRyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgY2hpbGROb2RlcyAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciBhcyAnJHt0ZXJtU3R0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiT2JqZWN0QXNzaWdtZW50XCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgdmFyaWFibGVzRnJvbVRlcm1zQW5kUGFyYW1ldGVycyB9IGZyb20gXCIuLi9wcm9jZWR1cmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIEFub255bW91c1Byb2NlZHVyZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgIHRoaXMucmV0dXJuQmxvY2sgPSByZXR1cm5CbG9jaztcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycztcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLnJldHVybkJsb2NrO1xuICB9XG5cbiAgYXN5bmMgY2FsbCh0ZXJtcywgY29udGV4dCkge1xuICAgIGNvbnN0IGFub255bW91c1Byb2NlZHVyZVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ2FsbGluZyB0aGUgJyR7YW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nfScgYW5vbnltb3VzIHByb2NlZHVyZS4uLmApO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmNvbXBhcmVUZXJtcyh0ZXJtcywgY29udGV4dCk7XG5cbiAgICBjb25zdCB2YXJpYWJsZXMgPSB2YXJpYWJsZXNGcm9tVGVybXNBbmRQYXJhbWV0ZXJzKHRlcm1zLCB0aGlzLnBhcmFtZXRlcnMsIGNvbnRleHQpLFxuICAgICAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnJldHVybkJsb2NrLmV2YWx1YXRlKHZhcmlhYmxlcywgY29udGV4dCksXG4gICAgICAgICAgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09IHRlcm1UeXBlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIGlzIG5vdCBlcXVhbCB0byB0aGUgJyR7YW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nfScgYW5vbnltb3VzIHByb2NlZHVyZSdzICcke3RoaXMudHlwZX0nIHR5cGUuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmNhbGxlZCB0aGUgJyR7YW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nfScgYW5vbnltb3VzIHByb2NlZHVyZS5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkFub255bW91c1Byb2NlZHVyZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVmFyaWFibGVBc3NpZ25tZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGV4cHJlc3Npb24pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uO1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHt2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmd9JyB2YXJpYWJsZSBhc3NpZ25tZW50Li4uYCk7XG5cbiAgICB0ZXJtID0gYXdhaXQgdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgdGhpcy52YXJpYWJsZS5hc3NpZ24odGVybSwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7dmFyaWFibGVBc3NpZ25tZW50U3RyaW5nfScgdmFyaWFibGUgYXNzaWdubWVudCBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJWYXJpYWJsZUFzc2lnbm1lbnRcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuXG5jb25zdCB7IGFzeW5jRm9yRWFjaCB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVmFyaWFibGVBc3NpZ25tZW50cyBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgYXdhaXQgdGhpcy5icmVhayhjb250ZXh0KTtcblxuICAgIGNvbnN0IHZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3ZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmd9JyB2YXJpYWJsZSBhc3NpZ25tZW50cy4uLmApO1xuXG4gICAgYXdhaXQgYXN5bmNGb3JFYWNoKHRoaXMuYXJyYXksIGFzeW5jICh2YXJpYWJsZUFzc2lnbm1lbnQpID0+IHtcbiAgICAgIGF3YWl0IHZhcmlhYmxlQXNzaWdubWVudC5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7dmFyaWFibGVBc3NpZ25tZW50c1N0cmluZ30nIHZhcmlhYmxlIGFzc2lnbm1lbnRzLmApO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlZhcmlhYmxlQXNzaWdubWVudHNcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFByb2NlZHVyZURlY2xhcmF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgcHJvY2VkdXJlKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5wcm9jZWR1cmUgPSBwcm9jZWR1cmU7XG4gIH1cblxuICBnZXRQcm9jZWR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2VkdXJlO1xuICB9XG5cbiAgdmVyaWZ5KGNvbnRleHQpIHtcbiAgICBjb25zdCB2ZXJpZmllcyA9IHRydWU7XG5cbiAgICBjb25zdCBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3Byb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nfScgcHJvY2VkdXJlIGRlY2xhcmF0aW9uLi4uYClcblxuICAgIGNvbnN0IHByb2NlZHVyZSA9IHRoaXMuZ2V0UHJvY2VkdXJlKCk7XG5cbiAgICBjb250ZXh0LmFkZFByb2NlZHVyZShwcm9jZWR1cmUpO1xuXG4gICAgaWYgKHZlcmlmaWVzKSB7XG4gICAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7cHJvY2VkdXJlRGVjbGFyYXRpb25TdHJpbmd9JyBwcm9jZWR1cmUgZGVjbGFyYXRpb24uYClcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZpZXM7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiUHJvY2VkdXJlRGVjbGFyYXRpb25cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RlcCBmcm9tIFwiLi9lbGVtZW50L3N0ZXBcIjtcbmltcG9ydCBTb21lIGZyb20gXCIuL2VsZW1lbnQvc29tZVwiO1xuaW1wb3J0IFRlcm0gZnJvbSBcIi4vZWxlbWVudC90ZXJtXCI7XG5pbXBvcnQgVGVybXMgZnJvbSBcIi4vZWxlbWVudC90ZXJtc1wiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuL2VsZW1lbnQvbGFiZWxcIjtcbmltcG9ydCBFcnJvciBmcm9tIFwiLi9lbGVtZW50L2Vycm9yXCI7XG5pbXBvcnQgRXZlcnkgZnJvbSBcIi4vZWxlbWVudC9ldmVyeVwiO1xuaW1wb3J0IFJlZHVjZSBmcm9tIFwiLi9lbGVtZW50L3JlZHVjZVwiO1xuaW1wb3J0IFRlcm5hcnkgZnJvbSBcIi4vZWxlbWVudC90ZXJuYXJ5XCI7XG5pbXBvcnQgVmFyaWFibGUgZnJvbSBcIi4vZWxlbWVudC92YXJpYWJsZVwiO1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tIFwiLi9lbGVtZW50L3ByaW1pdGl2ZVwiO1xuaW1wb3J0IFJlZmVyZW5jZSBmcm9tIFwiLi9lbGVtZW50L3JlZmVyZW5jZVwiO1xuaW1wb3J0IFByb2NlZHVyZSBmcm9tIFwiLi9lbGVtZW50L3Byb2NlZHVyZVwiO1xuaW1wb3J0IE5vZGVRdWVyeSBmcm9tIFwiLi9lbGVtZW50L25vZGVRdWVyeVwiO1xuaW1wb3J0IFBhcmFtZXRlciBmcm9tIFwiLi9lbGVtZW50L3BhcmFtZXRlclwiO1xuaW1wb3J0IFBhcmFtZXRlcnMgZnJvbSBcIi4vZWxlbWVudC9wYXJhbWV0ZXJzXCI7XG5pbXBvcnQgTm9kZXNRdWVyeSBmcm9tIFwiLi9lbGVtZW50L25vZGVzUXVlcnlcIjtcbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuL2VsZW1lbnQvZXhwcmVzc2lvblwiO1xuaW1wb3J0IFJldHVybkJsb2NrIGZyb20gXCIuL2VsZW1lbnQvcmV0dXJuQmxvY2tcIjtcbmltcG9ydCBOZWdhdGVkVGVybSBmcm9tIFwiLi9lbGVtZW50L3Rlcm0vbmVnYXRlZFwiO1xuaW1wb3J0IExvZ2ljYWxUZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9sb2dpY2FsXCI7XG5pbXBvcnQgQnJhY2tldGVkVGVybSBmcm9tIFwiLi9lbGVtZW50L3Rlcm0vYnJhY2tldGVkXCI7XG5pbXBvcnQgUHJvY2VkdXJlQ2FsbCBmcm9tIFwiLi9lbGVtZW50L3Byb2NlZHVyZUNhbGxcIjtcbmltcG9ydCBDb21wYXJpc29uVGVybSBmcm9tIFwiLi9lbGVtZW50L3Rlcm0vY29tcGFyaXNvblwiO1xuaW1wb3J0IE5hbWVkUGFyYW1ldGVyIGZyb20gXCIuL2VsZW1lbnQvcGFyYW1ldGVyL25hbWVkXCI7XG5pbXBvcnQgQXJyYXlBc3NpZ21lbnQgZnJvbSBcIi4vZWxlbWVudC9hc3NpZ25tZW50L2FycmF5XCI7XG5pbXBvcnQgUmV0dXJuU3RhdGVtZW50IGZyb20gXCIuL2VsZW1lbnQvc3RhdGVtZW50L3JldHVyblwiO1xuaW1wb3J0IE5hbWVkUGFyYW1ldGVycyBmcm9tIFwiLi9lbGVtZW50L3BhcmFtZXRlcnMvbmFtZWRcIjtcbmltcG9ydCBPYmplY3RBc3NpZ25tZW50IGZyb20gXCIuL2VsZW1lbnQvYXNzaWdubWVudC9vYmplY3RcIjtcbmltcG9ydCBBbm9ueW1vdXNQcm9jZWR1cmUgZnJvbSBcIi4vZWxlbWVudC9wcm9jZWR1cmUvYW5vbnltb3VzXCI7XG5pbXBvcnQgVmFyaWFibGVBc3NpZ25tZW50IGZyb20gXCIuL2VsZW1lbnQvYXNzaWdubWVudC92YXJpYWJsZVwiO1xuaW1wb3J0IFZhcmlhYmxlQXNzaWdubWVudHMgZnJvbSBcIi4vZWxlbWVudC9hc3NpZ25tZW50cy92YXJpYWJsZVwiO1xuaW1wb3J0IFByb2NlZHVyZURlY2xhcmF0aW9uIGZyb20gXCIuL2VsZW1lbnQvZGVjbGFyYXRpb24vcHJvY2VkdXJlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEZ1cnRsZUxleGVyIGFzIEZ1cnRsZUxleGVyQmFzZSB9IGZyb20gXCJvY2NhbS1ncmFtbWFyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXJ0bGVMZXhlciBleHRlbmRzIEZ1cnRsZUxleGVyQmFzZSB7fVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgU1RFUF9SVUxFX05BTUUgPSBcInN0ZXBcIjtcbmV4cG9ydCBjb25zdCBTT01FX1JVTEVfTkFNRSA9IFwic29tZVwiO1xuZXhwb3J0IGNvbnN0IFRFUk1fUlVMRV9OQU1FID0gXCJ0ZXJtXCI7XG5leHBvcnQgY29uc3QgVEVSTVNfUlVMRV9OQU1FID0gXCJ0ZXJtc1wiO1xuZXhwb3J0IGNvbnN0IEVWRVJZX1JVTEVfTkFNRSA9IFwiZXZlcnlcIjtcbmV4cG9ydCBjb25zdCBMQUJFTF9SVUxFX05BTUUgPSBcImxhYmVsXCI7XG5leHBvcnQgY29uc3QgRVJST1JfUlVMRV9OQU1FID0gXCJlcnJvclwiO1xuZXhwb3J0IGNvbnN0IFJFRFVDRV9SVUxFX05BTUUgPSBcInJlZHVjZVwiO1xuZXhwb3J0IGNvbnN0IFRFUk5BUllfUlVMRV9OQU1FID0gXCJ0ZXJuYXJ5XCI7XG5leHBvcnQgY29uc3QgVkFSSUFCTEVfUlVMRV9OQU1FID0gXCJ2YXJpYWJsZVwiO1xuZXhwb3J0IGNvbnN0IE5PTlNFTlNFX1JVTEVfTkFNRSA9IFwibm9uc2Vuc2VcIjtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9SVUxFX05BTUUgPSBcImRvY3VtZW50XCI7XG5leHBvcnQgY29uc3QgUFJJTUlUSVZFX1JVTEVfTkFNRSA9IFwicHJpbWl0aXZlXCI7XG5leHBvcnQgY29uc3QgUkVGRVJFTkNFX1JVTEVfTkFNRSA9IFwicmVmZXJlbmNlXCI7XG5leHBvcnQgY29uc3QgUEFSQU1FVEVSX1JVTEVfTkFNRSA9IFwicGFyYW1ldGVyXCI7XG5leHBvcnQgY29uc3QgTk9ERV9RVUVSWV9SVUxFX05BTUUgPSBcIm5vZGVRdWVyeVwiO1xuZXhwb3J0IGNvbnN0IEVYUFJFU1NJT05fUlVMRV9OQU1FID0gXCJleHByZXNzaW9uXCI7XG5leHBvcnQgY29uc3QgUEFSQU1FVEVSU19SVUxFX05BTUUgPSBcInBhcmFtZXRlcnNcIjtcbmV4cG9ydCBjb25zdCBOT0RFU19RVUVSWV9SVUxFX05BTUUgPSBcIm5vZGVzUXVlcnlcIjtcbmV4cG9ydCBjb25zdCBSRVRVUk5fQkxPQ0tfUlVMRV9OQU1FID0gXCJyZXR1cm5CbG9ja1wiO1xuZXhwb3J0IGNvbnN0IExPR0lDQUxfVEVSTV9SVUxFX05BTUUgPSBcImxvZ2ljYWxUZXJtXCI7XG5leHBvcnQgY29uc3QgTkVHQVRFRF9URVJNX1JVTEVfTkFNRSA9IFwibmVnYXRlZFRlcm1cIjtcbmV4cG9ydCBjb25zdCBCUkFDS0VURURfVEVSTV9SVUxFX05BTUUgPSBcImJyYWNrZXRlZFRlcm1cIjtcbmV4cG9ydCBjb25zdCBQUk9DRURVUkVfQ0FMTF9SVUxFX05BTUUgPSBcInByb2NlZHVyZUNhbGxcIjtcbmV4cG9ydCBjb25zdCBDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FID0gXCJjb21wYXJpc29uVGVybVwiO1xuZXhwb3J0IGNvbnN0IE5BTUVEX1BBUkFNRVRFUl9SVUxFX05BTUUgPSBcIm5hbWVkUGFyYW1ldGVyXCI7XG5leHBvcnQgY29uc3QgTkFNRURfUEFSQU1FVEVSU19SVUxFX05BTUUgPSBcIm5hbWVkUGFyYW1ldGVyc1wiO1xuZXhwb3J0IGNvbnN0IFJFVFVSTl9TVEFURU1FTlRfUlVMRV9OQU1FID0gXCJyZXR1cm5TdGF0ZW1lbnRcIjtcbmV4cG9ydCBjb25zdCBBUlJBWV9BU1NJR05NRU5UX1JVTEVfTkFNRSA9IFwiYXJyYXlBc3NpZ25tZW50XCI7XG5leHBvcnQgY29uc3QgT0JKRUNUX0FTU0lHTk1FTlRfUlVMRV9OQU1FID0gXCJvYmplY3RBc3NpZ25tZW50XCI7XG5leHBvcnQgY29uc3QgVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUUgPSBcInZhcmlhYmxlQXNzaWdubWVudFwiO1xuZXhwb3J0IGNvbnN0IEFOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FID0gXCJhbm9ueW1vdXNQcm9jZWR1cmVcIjtcbmV4cG9ydCBjb25zdCBWQVJJQUJMRV9BU1NJR05NRU5UU19SVUxFX05BTUUgPSBcInZhcmlhYmxlQXNzaWdubWVudHNcIjtcbmV4cG9ydCBjb25zdCBQUk9DRURVUkVfREVDTEFSQVRJT05fUlVMRV9OQU1FID0gXCJwcm9jZWR1cmVEZWNsYXJhdGlvblwiO1xuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgQVJSQVlfQVNTSUdOTUVOVF9SVUxFX05BTUUsIE9CSkVDVF9BU1NJR05NRU5UX1JVTEVfTkFNRSwgVkFSSUFCTEVfQVNTSUdOTUVOVFNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0ZXBOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0QXJyYXlBc3NpZ25tZW50Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEFSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgIGFycmF5QXNzaWdubWVudE5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBhcnJheUFzc2lnbm1lbnROb2RlO1xuICB9XG5cbiAgZ2V0T2JqZWN0QXNzaWdubWVudE5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBPQkpFQ1RfQVNTSUdOTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICAgb2JqZWN0QXNzaWdubWVudE5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBvYmplY3RBc3NpZ25tZW50Tm9kZTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlQXNzaWdubWVudHNOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfQVNTSUdOTUVOVFNfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlQXNzaWdubWVudHNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50c05vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFN0ZXBOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBWQVJJQUJMRV9SVUxFX05BTUUsIEFOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb21lTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsb2VOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibG9lTm9kZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU29tZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgIFBSSU1JVElWRV9SVUxFX05BTUUsXG4gICAgICAgICBORUdBVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgTE9HSUNBTF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIENPTVBBUklTT05fVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1Ob2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldFByaW1pdGl2ZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBQUklNSVRJVkVfUlVMRV9OQU1FLFxuICAgICAgICAgIHByaW1pdGl2ZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwcmltaXRpdmVOb2RlO1xuICB9XG5cbiAgZ2V0TmVnYXRlZFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTkVHQVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICBuZWdhdGVkVGVybU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBuZWdhdGVkVGVybU5vZGU7XG4gIH1cblxuICBnZXRMb2dpY2FsVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIGxvZ2ljYWxUZXJtUnVsZU5hbWUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBsb2dpY2FsVGVybVJ1bGVOYW1lO1xuICB9XG5cbiAgZ2V0QnJhY2tldGVkVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBCUkFDS0VURURfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgYnJhY2tldGVkVGVybVJ1bGVOYW1lID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYnJhY2tldGVkVGVybVJ1bGVOYW1lO1xuICB9XG5cbiAgZ2V0Q29tcGFyaXNvblRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gQ09NUEFSSVNPTl9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICBjb21wYXJpc29uTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGNvbXBhcmlzb25Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHtcbiAgICBpZiAocHJlY2VkZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmVjZWRlbmNlID0gb3BhY2l0eTsgLy8vXG5cbiAgICAgIG9wYWNpdHkgPSBjaGlsZE5vZGVzOyAvLy9cblxuICAgICAgY2hpbGROb2RlcyA9IHJ1bGVOYW1lOyAgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IFRlcm1Ob2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHRlcm1Ob2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1Ob2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VGVybU5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZXJ5Tm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZU5vZGU7XG4gIH1cblxuICBnZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUsXG4gICAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGFub255bW91c1Byb2NlZHVyZU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEV2ZXJ5Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUWVBFX1RPS0VOX1RZUEUgPSBcInR5cGVcIjtcbmV4cG9ydCBjb25zdCBOQU1FX1RPS0VOX1RZUEUgPSBcIm5hbWVcIjtcbmV4cG9ydCBjb25zdCBOVUxMX1RPS0VOX1RZUEUgPSBcIm51bGxcIjtcbmV4cG9ydCBjb25zdCBOVU1CRVJfVE9LRU5fVFlQRSA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgU1BFQ0lBTF9UT0tFTl9UWVBFID0gXCJzcGVjaWFsXCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTl9UT0tFTl9UWVBFID0gXCJib29sZWFuXCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX0xJVEVSQUxfVE9LRU5fVFlQRSA9IFwic3RyaW5nLWxpdGVyYWxcIjtcblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IE5BTUVfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi90b2tlblR5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldE5hbWUoKSB7XG4gICAgbGV0IG5hbWU7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG5hbWUgPSBjb250ZW50OyAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShMYWJlbE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9yTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXJyb3JOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBWQVJJQUJMRV9SVUxFX05BTUUsIEVYUFJFU1NJT05fUlVMRV9OQU1FLCBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVkdWNlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZU5vZGU7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEVYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgIGV4cHJlc3Npb25Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBnZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUsXG4gICAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGFub255bW91c1Byb2NlZHVyZU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJlZHVjZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUsIEVYUFJFU1NJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IGZpcnN0LCBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJuYXJ5Tm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB0ZXJtTm9kZTtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb25Ob2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEVYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgIGV4cHJlc3Npb25Ob2RlcyA9IHRoaXMuZ2V0Tm9kZXNCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBleHByZXNzaW9uTm9kZXM7XG4gIH1cblxuICBnZXRJZkV4cHJlc3Npb25Ob2RlKCkge1xuICAgIGNvbnN0IGZpcnN0RXhwcmVzc2lvbk5vZGUgPSB0aGlzLmdldEZpcnN0RXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgICBpZkV4cHJlc3Npb25Ob2RlID0gZmlyc3RFeHByZXNzaW9uTm9kZTsgIC8vL1xuXG4gICAgcmV0dXJuIGlmRXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBnZXRFbHNlRXhwcmVzc2lvbk5vZGUoKSB7XG4gICAgY29uc3Qgc2Vjb25kRXhwcmVzc2lvbk5vZGUgPSB0aGlzLmdldFNlY29uZEV4cHJlc3Npb25Ob2RlKCksXG4gICAgICAgICAgZWxzZUV4cHJlc3Npb25Ob2RlID0gc2Vjb25kRXhwcmVzc2lvbk5vZGU7IC8vL1xuXG4gICAgcmV0dXJuIGVsc2VFeHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIGdldEZpcnN0RXhwcmVzc2lvbk5vZGUoKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbk5vZGVzID0gdGhpcy5nZXRFeHByZXNzaW9uTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdEV4cHJlc3Npb25Ob2RlID0gZmlyc3QoZXhwcmVzc2lvbk5vZGVzKTtcblxuICAgIHJldHVybiBmaXJzdEV4cHJlc3Npb25Ob2RlO1xuICB9XG5cbiAgZ2V0U2Vjb25kRXhwcmVzc2lvbk5vZGUoKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbk5vZGVzID0gdGhpcy5nZXRFeHByZXNzaW9uTm9kZXMoKSxcbiAgICAgICAgICBzZWNvbmRFeHByZXNzaW9uTm9kZSA9IHNlY29uZChleHByZXNzaW9uTm9kZXMpO1xuXG4gICAgcmV0dXJuIHNlY29uZEV4cHJlc3Npb25Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShUZXJuYXJ5Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShEb2N1bWVudE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IE5BTUVfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi90b2tlblR5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhcmlhYmxlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldE5hbWUoKSB7XG4gICAgbGV0IG5hbWU7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG5hbWUgPSBjb250ZW50OyAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShWYXJpYWJsZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbnNlbnNlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9uc2Vuc2VOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgbnVsbE5vZGUgZnJvbSBcIi4uL251bGxOb2RlXCI7XG5cbmltcG9ydCB7IE5VTEwsIFRSVUUsIEZBTFNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBTVFJJTkdfVFlQRSwgTlVNQkVSX1RZUEUsIEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgTlVMTF9UT0tFTl9UWVBFLCBOVU1CRVJfVE9LRU5fVFlQRSwgQk9PTEVBTl9UT0tFTl9UWVBFLCBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpbWl0aXZlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKCksXG4gICAgICAgICAgbnVtYmVyID0gdGhpcy5nZXROdW1iZXIoKSxcbiAgICAgICAgICBib29sZWFuID0gdGhpcy5nZXRCb29sZWFuKCksXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbCA9IHRoaXMuZ2V0U3RyaW5nTGl0ZXJhbCgpO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBOT0RFX1RZUEU7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBOVU1CRVJfVFlQRTtcbiAgICB9IGVsc2UgaWYgKGJvb2xlYW4gIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBCT09MRUFOX1RZUEU7XG4gICAgfSBlbHNlIGlmIChzdHJpbmdMaXRlcmFsICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gU1RSSU5HX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWU7XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKCksXG4gICAgICAgICAgbnVtYmVyID0gdGhpcy5nZXROdW1iZXIoKSxcbiAgICAgICAgICBib29sZWFuID0gdGhpcy5nZXRCb29sZWFuKCksXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbCA9IHRoaXMuZ2V0U3RyaW5nTGl0ZXJhbCgpO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gbm9kZTsgLy8vXG4gICAgfSBlbHNlIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gbnVtYmVyOyAvLy9cbiAgICB9IGVsc2UgaWYgKGJvb2xlYW4gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gYm9vbGVhbjsgIC8vL1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nTGl0ZXJhbCAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBzdHJpbmdMaXRlcmFsOyAgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZ2V0Tm9kZSgpIHtcbiAgICBsZXQgbm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOVUxMX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSBOVUxMKSB7XG4gICAgICAgIG5vZGUgPSBudWxsTm9kZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBnZXROdW1iZXIoKSB7XG4gICAgbGV0IG51bWJlciA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOVU1CRVJfVE9LRU5fVFlQRTsgLy8vXG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSBUUlVFKSB7XG4gICAgICAgIG51bWJlciA9IE51bWJlcihjb250ZW50KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIGdldEJvb2xlYW4oKSB7XG4gICAgbGV0IGJvb2xlYW4gPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gQk9PTEVBTl9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBpZiAoY29udGVudCA9PT0gVFJVRSkge1xuICAgICAgICBib29sZWFuID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnQgPT09IEZBTFNFKSB7XG4gICAgICAgIGJvb2xlYW4gPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIGJvb2xlYW47XG4gIH1cblxuICBnZXRTdHJpbmdMaXRlcmFsKCkge1xuICAgIGxldCBzdHJpbmdMaXRlcmFsID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHN0cmluZ0xpdGVyYWwgPSBjb250ZW50OyAgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUHJpbWl0aXZlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmZXJlbmNlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldE5hbWUoKSB7XG4gICAgbGV0IG5hbWU7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG5hbWUgPSBjb250ZW50OyAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSZWZlcmVuY2VOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBUWVBFX1RPS0VOX1RZUEUsIE5BTUVfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi90b2tlblR5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcmFtdGVyTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldE5hbWUoKSB7XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gTkFNRV9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBuYW1lID0gY29udGVudDsgLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBUWVBFX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHR5cGUgPSBjb250ZW50OyAvL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBvcGFjaXR5OyAvLy9cblxuICAgICAgb3BhY2l0eSA9IGNoaWxkTm9kZXM7IC8vL1xuXG4gICAgICBjaGlsZE5vZGVzID0gcnVsZU5hbWU7ICAvLy9cblxuICAgICAgcnVsZU5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gUGFyYW10ZXJOb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtZXRlck5vZGUgPSBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gcGFyYW1ldGVyTm9kZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgeyBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZVF1ZXJ5Tm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFN0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCksXG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgZ2V0U3RyaW5nTGl0ZXJhbCgpIHtcbiAgICBsZXQgc3RyaW5nTGl0ZXJhbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHN0cmluZ0xpdGVyYWwgPSBjb250ZW50OyAgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbiAgfVxuXG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKE5vZGVRdWVyeU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgU09NRV9SVUxFX05BTUUsXG4gICAgICAgICBFVkVSWV9SVUxFX05BTUUsXG4gICAgICAgICBSRURVQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgVEVSTkFSWV9SVUxFX05BTUUsXG4gICAgICAgICBOT0RFX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVTX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICBQUk9DRURVUkVfQ0FMTF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cHJlc3Npb25Ob2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0U29tZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBTT01FX1JVTEVfTkFNRSxcbiAgICAgICAgICBzb21lTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHNvbWVOb2RlO1xuICB9XG5cbiAgZ2V0RXZlcnlOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVZFUllfUlVMRV9OQU1FLFxuICAgICAgICAgIGV2ZXJ5Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGV2ZXJ5Tm9kZTtcbiAgfVxuXG4gIGdldFJlZHVjZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSRURVQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgIHJlZHVjZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiByZWR1Y2VOb2RlO1xuICB9XG5cbiAgZ2V0VGVybmFyeU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJOQVJZX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJuYXJ5Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm5hcnlOb2RlO1xuICB9XG5cbiAgZ2V0Tm9kZVF1ZXJ5Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5PREVfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgIG5vZGVRdWVyeU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBub2RlUXVlcnlOb2RlO1xuICB9XG5cbiAgZ2V0Tm9kZXNRdWVyeU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBOT0RFU19RVUVSWV9SVUxFX05BTUUsXG4gICAgICAgICAgbm9kZVNRdWVyeU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBub2RlU1F1ZXJ5Tm9kZTtcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICAgcmV0dXJuQmxvY2tOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcmV0dXJuQmxvY2tOb2RlO1xuICB9XG5cbiAgZ2V0UHJvY2VkdXJlQ2FsbE5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBQUk9DRURVUkVfQ0FMTF9SVUxFX05BTUUsXG4gICAgICAgICAgcHJvY2VkdXJlQ2FsbE5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwcm9jZWR1cmVDYWxsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXhwcmVzc2lvbk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFBBUkFNRVRFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcmFtdGVyc05vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRQYXJhbWV0ZXJOb2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUkFNRVRFUl9SVUxFX05BTUUsXG4gICAgICAgICAgcGFyYW1ldGVyTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcGFyYW1ldGVyTm9kZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBvcGFjaXR5OyAvLy9cblxuICAgICAgb3BhY2l0eSA9IGNoaWxkTm9kZXM7IC8vL1xuXG4gICAgICBjaGlsZE5vZGVzID0gcnVsZU5hbWU7ICAvLy9cblxuICAgICAgcnVsZU5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gUGFyYW10ZXJzTm9kZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJzTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJzTm9kZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgeyBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZXNRdWVyeU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRTdHJpbmcoKSB7XG4gICAgY29uc3Qgc3RyaW5nTGl0ZXJhbCA9IHRoaXMuZ2V0U3RyaW5nTGl0ZXJhbCgpLFxuICAgICAgICAgIHN0cmluZyA9IHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwpO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIGdldFN0cmluZ0xpdGVyYWwoKSB7XG4gICAgbGV0IHN0cmluZ0xpdGVyYWwgPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1RSSU5HX0xJVEVSQUxfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCA9IGNvbnRlbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9kZXNRdWVyeU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFNURVBfUlVMRV9OQU1FLCBOT05TRU5TRV9SVUxFX05BTUUsIFJFVFVSTl9TVEFURU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXR1cm5CbG9ja05vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBpc05vbnNlbnNpY2FsKCkge1xuICAgIGNvbnN0IG5vbnNlbnNlTm9kZXMgPSB0aGlzLmdldE5vbnNlbnNlTm9kZXMoKSxcbiAgICAgICAgICBub25zZW5zZU5vZGVzTGVuZ3RoID0gbm9uc2Vuc2VOb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgbm9uc2Vuc2ljYWwgPSAobm9uc2Vuc2VOb2Rlc0xlbmd0aCA+IDApO1xuXG4gICAgcmV0dXJuIG5vbnNlbnNpY2FsO1xuICB9XG5cbiAgZ2V0U3RlcE5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gU1RFUF9SVUxFX05BTUUsXG4gICAgICAgICAgc3RlcE5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHN0ZXBOb2RlcztcbiAgfVxuXG4gIGdldE5vbnNlbnNlTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBOT05TRU5TRV9SVUxFX05BTUUsXG4gICAgICAgICAgbm9uc2Vuc2VOb2RlcyA9IHRoaXMuZ2V0Tm9kZXNCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgICAgcmV0dXJuIG5vbnNlbnNlTm9kZXM7XG4gIH1cblxuICBnZXRSZXR1cm5TdGF0ZW1lbnROb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUkVUVVJOX1NUQVRFTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICAgcmV0dXJuU3RhdGVtZW50ID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcmV0dXJuU3RhdGVtZW50O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSZXR1cm5CbG9ja05vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFRlcm1Ob2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1cIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBTUEVDSUFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuaW1wb3J0IHsgQ09OSlVOQ1RJT05fT1BFUkFUT1IsIERJU0pVTkNUSU9OX09QRVJBVE9SIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IGZpcnN0LCBsYXN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9naWNhbFRlcm1Ob2RlIGV4dGVuZHMgVGVybU5vZGUge1xuICBnZXRPcGVyYXRvcigpIHtcbiAgICBsZXQgb3BlcmF0b3IgPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1BFQ0lBTF9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBvcGVyYXRvciA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG9wZXJhdG9yO1xuICB9XG5cbiAgaXNDb25qZWN0aW9uKCkge1xuICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5nZXRPcGVyYXRvcigpLFxuICAgICAgICAgIGNvbmplY3Rpb24gPSAob3BlcmF0b3IgPT09IENPTkpVTkNUSU9OX09QRVJBVE9SKTtcblxuICAgIHJldHVybiBjb25qZWN0aW9uO1xuICB9XG5cbiAgaXNEaXNqdW5jdGlvbigpIHtcbiAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMuZ2V0T3BlcmF0b3IoKSxcbiAgICAgICAgICBkaXNqdW5jdGlvbiA9IChvcGVyYXRvciA9PT0gRElTSlVOQ1RJT05fT1BFUkFUT1IpO1xuXG4gICAgcmV0dXJuIGRpc2p1bmN0aW9uO1xuICB9XG5cbiAgZ2V0VGVybU5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlcztcbiAgfVxuXG4gIGdldExlZnRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBmaXJzdEV4cHJlc2lvbk5vZGUgPSB0aGlzLmdldEZpcnN0VGVybU5vZGUoKSxcbiAgICAgICAgICBsZWZ0VGVybU5vZGUgPSBmaXJzdEV4cHJlc2lvbk5vZGU7ICAvLy9cblxuICAgIHJldHVybiBsZWZ0VGVybU5vZGU7XG4gIH1cblxuICBnZXRSaWdodFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IGxhc3RUZXJtTm9kZSA9IHRoaXMuZ2V0TGFzdFRlcm1Ob2RlKCksXG4gICAgICAgICAgcmlnaHRUZXJtTm9kZSA9IGxhc3RUZXJtTm9kZTsgLy8vXG5cbiAgICByZXR1cm4gcmlnaHRUZXJtTm9kZTtcbiAgfVxuXG4gIGdldExhc3RUZXJtTm9kZSgpIHtcbiAgICBjb25zdCB0ZXJtTm9kZXMgPSB0aGlzLmdldFRlcm1Ob2RlcygpLFxuICAgICAgICAgIGxhc3RUZXJtTm9kZSA9IGxhc3QodGVybU5vZGVzKTtcblxuICAgIHJldHVybiBsYXN0VGVybU5vZGU7XG4gIH1cblxuICBnZXRGaXJzdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgZmlyc3RUZXJtTm9kZSA9IGZpcnN0KHRlcm1Ob2Rlcyk7XG5cbiAgICByZXR1cm4gZmlyc3RUZXJtTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFRlcm1Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShMb2dpY2FsVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybU5vZGUgZnJvbSBcIi4uLy4uL25vZGUvdGVybVwiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmVnYXRlZFRlcm1Ob2RlIGV4dGVuZHMgVGVybU5vZGUge1xuICBnZXRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm1Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBUZXJtTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmVnYXRlZFRlcm1Ob2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBURVJNU19SVUxFX05BTUUsIFJFRkVSRU5DRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2NlZHVyZUNhbGxOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VGVybXNOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTVNfUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm1zTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1zTm9kZTtcbiAgfVxuXG4gIGdldFJlZmVyZW5jZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSRUZFUkVOQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiByZWZlcmVuY2VOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcm9jZWR1cmVDYWxsTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXJtTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtXCI7XG5cbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcmFja2V0ZWRUZXJtTm9kZSBleHRlbmRzIFRlcm1Ob2RlIHtcbiAgZ2V0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gVGVybU5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEJyYWNrZXRlZFRlcm1Ob2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBUZXJtTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtXCI7XG5cbmltcG9ydCB7IE5PVF9FUVVBTF9UTyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgU1BFQ0lBTF9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3Rva2VuVHlwZXNcIjtcblxuY29uc3QgeyBmaXJzdCwgc2Vjb25kIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGFyaXNvblRlcm1Ob2RlIGV4dGVuZHMgVGVybU5vZGUge1xuICBpc05lZ2F0ZWQoKSB7XG4gICAgbGV0IG5lZ2F0ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFNQRUNJQUxfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgaWYgKGNvbnRlbnQgPT09IE5PVF9FUVVBTF9UTykge1xuICAgICAgICBuZWdhdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBuZWdhdGVkO1xuICB9XG5cbiAgZ2V0VGVybU5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlcztcbiAgfVxuXG4gIGdldExlZnRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBmaXJzdFRlcm1Ob2RlID0gdGhpcy5nZXRGaXJzdFRlcm1Ob2RlKCksXG4gICAgICAgICAgbGVmdFRlcm1Ob2RlID0gZmlyc3RUZXJtTm9kZTsgLy8vXG5cbiAgICByZXR1cm4gbGVmdFRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0UmlnaHRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBzZWNvbmRUZXJtTm9kZSA9IHRoaXMuZ2V0U2Vjb25kVGVybU5vZGUoKSxcbiAgICAgICAgICByaWdodFRlcm1Ob2RlID0gc2Vjb25kVGVybU5vZGU7ICAvLy9cblxuICAgIHJldHVybiByaWdodFRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0Rmlyc3RUZXJtTm9kZSgpIHtcbiAgICBjb25zdCB0ZXJtTm9kZXMgPSB0aGlzLmdldFRlcm1Ob2RlcygpLFxuICAgICAgICAgIGZpcnN0VGVybU5vZGUgPSBmaXJzdCh0ZXJtTm9kZXMpO1xuXG4gICAgcmV0dXJuIGZpcnN0VGVybU5vZGU7XG4gIH1cblxuICBnZXRTZWNvbmRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCB0ZXJtTm9kZXMgPSB0aGlzLmdldFRlcm1Ob2RlcygpLFxuICAgICAgICAgIHNlY29uZFRlcm1Ob2RlID0gc2Vjb25kKHRlcm1Ob2Rlcyk7XG5cbiAgICByZXR1cm4gc2Vjb25kVGVybU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBUZXJtTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ29tcGFyaXNvblRlcm1Ob2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFBhcmFtdGVyTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9wYXJhbWV0ZXJcIjtcblxuaW1wb3J0IHsgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmFtZWRQYXJhbXRlck5vZGUgZXh0ZW5kcyBQYXJhbXRlck5vZGUge1xuICBnZXRBbGlhcygpIHtcbiAgICBsZXQgYWxpYXMgPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gTkFNRV9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgICAgYWxpYXMgPSBjb250ZW50OyAvL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gYWxpYXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBQYXJhbXRlck5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKE5hbWVkUGFyYW10ZXJOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFBhcmFtdGVyc05vZGUgZnJvbSBcIi4uLy4uL25vZGUvcGFyYW1ldGVyc1wiO1xuXG5pbXBvcnQgeyBOQU1FRF9QQVJBTUVURVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lZFBhcmFtdGVyc05vZGUgZXh0ZW5kcyBQYXJhbXRlcnNOb2RlIHtcbiAgZ2V0TmFtZWRQYXJhbWV0ZXJOb2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5BTUVEX1BBUkFNRVRFUl9SVUxFX05BTUUsXG4gICAgICAgICAgbmFtZWRQYXJhbXRlck5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5hbWVkUGFyYW10ZXJOb2RlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFBhcmFtdGVyc05vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKE5hbWVkUGFyYW10ZXJzTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVtZW50Tm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0YXRlbWVudE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvc3RhdGVtZW50XCI7XG5cbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXR1cm5TdGF0ZW1lbnROb2RlIGV4dGVuZHMgU3RhdGVtZW50Tm9kZSB7XG4gIGdldFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB0ZXJtTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFN0YXRlbWVudE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJldHVyblN0YXRlbWVudE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFzc2lnbm1lbnRyTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEFzc2lnbm1lbnRyTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9hc3NpZ25tZW50XCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgUEFSQU1FVEVSU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFycmF5QXNzaWdubWVudE5vZGUgZXh0ZW5kcyBBc3NpZ25tZW50ck5vZGUge1xuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVyc05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBQQVJBTUVURVJTX1JVTEVfTkFNRSxcbiAgICAgICAgICBwYXJhbWV0ZXJzTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHBhcmFtZXRlcnNOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gQXNzaWdubWVudHJOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShBcnJheUFzc2lnbm1lbnROb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEFzc2lnbm1lbnRyTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9hc3NpZ25tZW50XCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgTkFNRURfUEFSQU1FVEVSU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9iamVjdEFzc2lnbm1lbnROb2RlIGV4dGVuZHMgQXNzaWdubWVudHJOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldE5hbWVkUGFyYW1ldGVyc05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBOQU1FRF9QQVJBTUVURVJTX1JVTEVfTkFNRSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlcnNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gbmFtZWRQYXJhbWV0ZXJzTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIEFzc2lnbm1lbnRyTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoT2JqZWN0QXNzaWdubWVudE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2NlZHVyZU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9jZWR1cmVOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Byb2NlZHVyZVwiO1xuXG5pbXBvcnQgeyBUWVBFX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuaW1wb3J0IHsgUEFSQU1FVEVSU19SVUxFX05BTUUsIFJFVFVSTl9CTE9DS19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFub255bW91c1Byb2NlZHVyZU5vZGUgZXh0ZW5kcyBQcm9jZWR1cmVOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFRZUEVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgdHlwZSA9IGNvbnRlbnQ7ICAvLy9cbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgIHBhcmFtZXRlcnNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcGFyYW1ldGVyc05vZGU7XG4gIH1cblxuICBnZXRSZXR1cm5CbG9ja05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSRVRVUk5fQkxPQ0tfUlVMRV9OQU1FLFxuICAgICAgICAgIHJldHVybkJsb2NrTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHJldHVybkJsb2NrTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFByb2NlZHVyZU5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEFub255bW91c1Byb2NlZHVyZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXNzaWdubWVudHJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL2Fzc2lnbm1lbnRcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBFWFBSRVNTSU9OX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFyaWFibGVBc3NpZ25tZW50Tm9kZSBleHRlbmRzIEFzc2lnbm1lbnRyTm9kZSB7XG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZU5vZGU7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEVYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgIGV4cHJlc3Npb25Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBBc3NpZ25tZW50ck5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFZhcmlhYmxlQXNzaWdubWVudE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXNzaWdubWVudHNOb2RlIGZyb20gXCIuLi8uLi9ub2RlL2Fzc2lnbm1lbnRcIjtcblxuaW1wb3J0IHsgVFlQRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3Rva2VuVHlwZXNcIjtcbmltcG9ydCB7IFZBUklBQkxFX0FTU0lHTk1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSBleHRlbmRzIEFzc2lnbm1lbnRzTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBUWVBFX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHR5cGUgPSBjb250ZW50OyAgLy8vXG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVBc3NpZ25tZW50Tm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9BU1NJR05NRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZUFzc2luZ25tZW50Tm9kc3MgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVBc3NpbmdubWVudE5vZHNzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gQXNzaWdubWVudHNOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShWYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb25Ob2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVjbGFyYXRpb25Ob2RlIGZyb20gXCIuLi8uLi9ub2RlL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IFRZUEVfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi8uLi90b2tlblR5cGVzXCI7XG5pbXBvcnQgeyBMQUJFTF9SVUxFX05BTUUsIFBBUkFNRVRFUlNfUlVMRV9OQU1FLCBSRVRVUk5fQkxPQ0tfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUgZXh0ZW5kcyBEZWNsYXJhdGlvbk5vZGUge1xuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gVFlQRV9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICB0eXBlID0gY29udGVudDsgIC8vL1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldExhYmVsTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IExBQkVMX1JVTEVfTkFNRSxcbiAgICAgICAgICBsYWJlbE5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBsYWJlbE5vZGU7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgIHBhcmFtZXRlcnNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcGFyYW1ldGVyc05vZGU7XG4gIH1cblxuICBnZXRSZXR1cm5CbG9ja05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSRVRVUk5fQkxPQ0tfUlVMRV9OQU1FLFxuICAgICAgICAgIHJldHVybkJsb2NrTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHJldHVybkJsb2NrTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIERlY2xhcmF0aW9uTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0ZXBOb2RlIGZyb20gXCIuL25vZGUvc3RlcFwiO1xuaW1wb3J0IFNvbWVOb2RlIGZyb20gXCIuL25vZGUvc29tZVwiO1xuaW1wb3J0IFRlcm1Ob2RlIGZyb20gXCIuL25vZGUvdGVybVwiO1xuaW1wb3J0IFRlcm1zTm9kZSBmcm9tIFwiLi9ub2RlL3Rlcm1zXCI7XG5pbXBvcnQgRXZlcnlOb2RlIGZyb20gXCIuL25vZGUvZXZlcnlcIjtcbmltcG9ydCBMYWJlbE5vZGUgZnJvbSBcIi4vbm9kZS9sYWJlbFwiO1xuaW1wb3J0IEVycm9yTm9kZSBmcm9tIFwiLi9ub2RlL2Vycm9yXCI7XG5pbXBvcnQgUmVkdWNlTm9kZSBmcm9tIFwiLi9ub2RlL3JlZHVjZVwiO1xuaW1wb3J0IFRlcm5hcnlOb2RlIGZyb20gXCIuL25vZGUvdGVybmFyeVwiO1xuaW1wb3J0IERvY3VtZW50Tm9kZSBmcm9tIFwiLi9ub2RlL2RvY3VtZW50XCI7XG5pbXBvcnQgVmFyaWFibGVOb2RlIGZyb20gXCIuL25vZGUvdmFyaWFibGVcIjtcbmltcG9ydCBOb25zZW5zZU5vZGUgZnJvbSBcIi4vbm9kZS9ub25zZW5zZVwiO1xuaW1wb3J0IFByaW1pdGl2ZU5vZGUgZnJvbSBcIi4vbm9kZS9wcmltaXRpdmVcIjtcbmltcG9ydCBSZWZlcmVuY2VOb2RlIGZyb20gXCIuL25vZGUvcmVmZXJlbmNlXCI7XG5pbXBvcnQgUGFyYW1ldGVyTm9kZSBmcm9tIFwiLi9ub2RlL3BhcmFtZXRlclwiO1xuaW1wb3J0IE5vZGVRdWVyeU5vZGUgZnJvbSBcIi4vbm9kZS9ub2RlUXVlcnlcIjtcbmltcG9ydCBFeHByZXNzaW9uTm9kZSBmcm9tIFwiLi9ub2RlL2V4cHJlc3Npb25cIjtcbmltcG9ydCBQYXJhbWV0ZXJzTm9kZSBmcm9tIFwiLi9ub2RlL3BhcmFtZXRlcnNcIjtcbmltcG9ydCBOb2Rlc1F1ZXJ5Tm9kZSBmcm9tIFwiLi9ub2RlL25vZGVzUXVlcnlcIjtcbmltcG9ydCBSZXR1cm5CbG9ja05vZGUgZnJvbSBcIi4vbm9kZS9yZXR1cm5CbG9ja1wiO1xuaW1wb3J0IExvZ2ljYWxUZXJtTm9kZSBmcm9tIFwiLi9ub2RlL3Rlcm0vbG9naWNhbFwiO1xuaW1wb3J0IE5lZ2F0ZWRUZXJtTm9kZSBmcm9tIFwiLi9ub2RlL3Rlcm0vbmVnYXRlZFwiO1xuaW1wb3J0IFByb2NlZHVyZUNhbGxOb2RlIGZyb20gXCIuL25vZGUvcHJvY2VkdXJlQ2FsbFwiO1xuaW1wb3J0IEJyYWNrZXRlZFRlcm1Ob2RlIGZyb20gXCIuL25vZGUvdGVybS9icmFja2V0ZWRcIjtcbmltcG9ydCBDb21wYXJpc29uVGVybU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJtL2NvbXBhcmlzb25cIjtcbmltcG9ydCBOYW1lZFBhcmFtZXRlck5vZGUgZnJvbSBcIi4vbm9kZS9wYXJhbWV0ZXIvbmFtZWRcIjtcbmltcG9ydCBOYW1lZFBhcmFtZXRlcnNOb2RlIGZyb20gXCIuL25vZGUvcGFyYW1ldGVycy9uYW1lZFwiO1xuaW1wb3J0IFJldHVyblN0YXRlbWVudE5vZGUgZnJvbSBcIi4vbm9kZS9zdGF0ZW1lbnQvcmV0dXJuXCI7XG5pbXBvcnQgQXJyYXlBc3NpZ25tZW50Tm9kZSBmcm9tIFwiLi9ub2RlL2Fzc2lnbm1lbnQvYXJyYXlcIjtcbmltcG9ydCBPYmplY3RBc3NpZ25tZW50Tm9kZSBmcm9tIFwiLi9ub2RlL2Fzc2lnbm1lbnQvb2JqZWN0XCI7XG5pbXBvcnQgQW5vbnltb3VzUHJvY2VkdXJlTm9kZSBmcm9tIFwiLi9ub2RlL3Byb2NlZHVyZS9hbm95bW91c1wiO1xuaW1wb3J0IFZhcmlhYmxlQXNzaWdubWVudE5vZGUgZnJvbSBcIi4vbm9kZS9hc3NpZ25tZW50L3ZhcmlhYmxlXCI7XG5pbXBvcnQgVmFyaWFibGVBc3NpZ25tZW50c05vZGUgZnJvbSBcIi4vbm9kZS9hc3NpZ25tZW50cy92YXJpYWJsZVwiO1xuaW1wb3J0IFByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSBmcm9tIFwiLi9ub2RlL2RlY2xhcmF0aW9uL3Byb2NlZHVyZVwiO1xuXG5pbXBvcnQgeyBTVEVQX1JVTEVfTkFNRSxcbiAgICAgICAgIFNPTUVfUlVMRV9OQU1FLFxuICAgICAgICAgVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBURVJNU19SVUxFX05BTUUsXG4gICAgICAgICBFVkVSWV9SVUxFX05BTUUsXG4gICAgICAgICBMQUJFTF9SVUxFX05BTUUsXG4gICAgICAgICBFUlJPUl9SVUxFX05BTUUsXG4gICAgICAgICBSRURVQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgVEVSTkFSWV9SVUxFX05BTUUsXG4gICAgICAgICBET0NVTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICBOT05TRU5TRV9SVUxFX05BTUUsXG4gICAgICAgICBQUklNSVRJVkVfUlVMRV9OQU1FLFxuICAgICAgICAgUkVGRVJFTkNFX1JVTEVfTkFNRSxcbiAgICAgICAgIFBBUkFNRVRFUl9SVUxFX05BTUUsXG4gICAgICAgICBOT0RFX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIEVYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICBOT0RFU19RVUVSWV9SVUxFX05BTUUsXG4gICAgICAgICBSRVRVUk5fQkxPQ0tfUlVMRV9OQU1FLFxuICAgICAgICAgTE9HSUNBTF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIE5FR0FURURfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBCUkFDS0VURURfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBQUk9DRURVUkVfQ0FMTF9SVUxFX05BTUUsXG4gICAgICAgICBDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgIE5BTUVEX1BBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgUkVUVVJOX1NUQVRFTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBBUlJBWV9BU1NJR05NRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIE9CSkVDVF9BU1NJR05NRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIFZBUklBQkxFX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUsXG4gICAgICAgICBWQVJJQUJMRV9BU1NJR05NRU5UU19SVUxFX05BTUUsXG4gICAgICAgICBQUk9DRURVUkVfREVDTEFSQVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IE5vblRlcm1pbmFsTm9kZU1hcCA9IHtcbiAgW1NURVBfUlVMRV9OQU1FXTogU3RlcE5vZGUsXG4gIFtTT01FX1JVTEVfTkFNRV06IFNvbWVOb2RlLFxuICBbVEVSTV9SVUxFX05BTUVdOiBUZXJtTm9kZSxcbiAgW1RFUk1TX1JVTEVfTkFNRV06IFRlcm1zTm9kZSxcbiAgW0VWRVJZX1JVTEVfTkFNRV06IEV2ZXJ5Tm9kZSxcbiAgW0xBQkVMX1JVTEVfTkFNRV06IExhYmVsTm9kZSxcbiAgW0VSUk9SX1JVTEVfTkFNRV06IEVycm9yTm9kZSxcbiAgW1JFRFVDRV9SVUxFX05BTUVdOiBSZWR1Y2VOb2RlLFxuICBbVEVSTkFSWV9SVUxFX05BTUVdOiBUZXJuYXJ5Tm9kZSxcbiAgW1ZBUklBQkxFX1JVTEVfTkFNRV06IFZhcmlhYmxlTm9kZSxcbiAgW05PTlNFTlNFX1JVTEVfTkFNRV06IE5vbnNlbnNlTm9kZSxcbiAgW0RPQ1VNRU5UX1JVTEVfTkFNRV06IERvY3VtZW50Tm9kZSxcbiAgW1BSSU1JVElWRV9SVUxFX05BTUVdOiBQcmltaXRpdmVOb2RlLFxuICBbUkVGRVJFTkNFX1JVTEVfTkFNRV06IFJlZmVyZW5jZU5vZGUsXG4gIFtQQVJBTUVURVJfUlVMRV9OQU1FXTogUGFyYW1ldGVyTm9kZSxcbiAgW05PREVfUVVFUllfUlVMRV9OQU1FXTogTm9kZVF1ZXJ5Tm9kZSxcbiAgW0VYUFJFU1NJT05fUlVMRV9OQU1FXTogRXhwcmVzc2lvbk5vZGUsXG4gIFtQQVJBTUVURVJTX1JVTEVfTkFNRV06IFBhcmFtZXRlcnNOb2RlLFxuICBbTk9ERVNfUVVFUllfUlVMRV9OQU1FXTogTm9kZXNRdWVyeU5vZGUsXG4gIFtSRVRVUk5fQkxPQ0tfUlVMRV9OQU1FXTogUmV0dXJuQmxvY2tOb2RlLFxuICBbTE9HSUNBTF9URVJNX1JVTEVfTkFNRV06IExvZ2ljYWxUZXJtTm9kZSxcbiAgW05FR0FURURfVEVSTV9SVUxFX05BTUVdOiBOZWdhdGVkVGVybU5vZGUsXG4gIFtQUk9DRURVUkVfQ0FMTF9SVUxFX05BTUVdOiBQcm9jZWR1cmVDYWxsTm9kZSxcbiAgW0JSQUNLRVRFRF9URVJNX1JVTEVfTkFNRV06IEJyYWNrZXRlZFRlcm1Ob2RlLFxuICBbQ09NUEFSSVNPTl9URVJNX1JVTEVfTkFNRV06IENvbXBhcmlzb25UZXJtTm9kZSxcbiAgW05BTUVEX1BBUkFNRVRFUl9SVUxFX05BTUVdOiBOYW1lZFBhcmFtZXRlck5vZGUsXG4gIFtOQU1FRF9QQVJBTUVURVJTX1JVTEVfTkFNRV06IE5hbWVkUGFyYW1ldGVyc05vZGUsXG4gIFtSRVRVUk5fU1RBVEVNRU5UX1JVTEVfTkFNRV06IFJldHVyblN0YXRlbWVudE5vZGUsXG4gIFtBUlJBWV9BU1NJR05NRU5UX1JVTEVfTkFNRV06IEFycmF5QXNzaWdubWVudE5vZGUsXG4gIFtPQkpFQ1RfQVNTSUdOTUVOVF9SVUxFX05BTUVdOiBPYmplY3RBc3NpZ25tZW50Tm9kZSxcbiAgW0FOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FXTogQW5vbnltb3VzUHJvY2VkdXJlTm9kZSxcbiAgW1ZBUklBQkxFX0FTU0lHTk1FTlRfUlVMRV9OQU1FXTogVmFyaWFibGVBc3NpZ25tZW50Tm9kZSxcbiAgW1ZBUklBQkxFX0FTU0lHTk1FTlRTX1JVTEVfTkFNRV06IFZhcmlhYmxlQXNzaWdubWVudHNOb2RlLFxuICBbUFJPQ0VEVVJFX0RFQ0xBUkFUSU9OX1JVTEVfTkFNRV06IFByb2NlZHVyZURlY2xhcmF0aW9uTm9kZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9uVGVybWluYWxOb2RlTWFwO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IEZ1cnRsZVBhcnNlciBhcyBGdXJ0bGVQYXJzZXJCYXNlIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXJzXCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGVNYXAgZnJvbSBcIi4uL25vblRlcm1pbmFsTm9kZU1hcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXJ0bGVQYXJzZXIgZXh0ZW5kcyBGdXJ0bGVQYXJzZXJCYXNlIHtcbiAgc3RhdGljIE5vblRlcm1pbmFsTm9kZU1hcCA9IE5vblRlcm1pbmFsTm9kZU1hcDtcblxuICBzdGF0aWMgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSA9IE5vblRlcm1pbmFsTm9kZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IGVsZW1lbnRzIGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5pbXBvcnQgeyBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm5hcnlTdHJpbmdGcm9tVGVybSxcbiAgICAgICAgIHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUsXG4gICAgICAgICB0ZXJtU3RyaW5nRnJvbVByb3BlcnRpZXMsXG4gICAgICAgICBleHByZXNzaW9uU3RyaW5nRnJvbVByb3BlcnRpZXMsXG4gICAgICAgICBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZ0Zyb21Qcm9jZWR1cmUsXG4gICAgICAgICByZXR1cm5CbG9ja1N0cmluZ0Zyb21SZXR1cm5TdGF0ZW1lbnROb2RlLFxuICAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVR5cGVBbmRWYXJpYWJsZSxcbiAgICAgICAgIHNvbWVTdHJpbmdGcm9tVmFyaWFibGVBbmRBbm9ueW1vdXNQcm9jZWR1cmUsXG4gICAgICAgICBldmVyeVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSxcbiAgICAgICAgIHByb2NlZHVyZVN0cmluZ0Zyb21UeXBlTGFiZWxQYXJhbWV0ZXJzQW5kUmV0dXJuQmxvY2ssXG4gICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmdGcm9tVHlwZVBhcmFtZXRlcnNBbmRSZXR1cm5CbG9jayxcbiAgICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZ0Zyb21UeXBlQW5kVmFyaWFibGVBc3NpZ25tZW50c0FycmF5LFxuICAgICAgICAgcmVkdWNlU3RyaW5nRnJvbVZhcmlhYmxlSW5pdGlhbEV4cHJlc3Npb25BbmRBbm9ueW1vdXNQcm9jZWR1cmUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEZyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFN0ZXAgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gc3RlcE5vZGUsICAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIGFycmF5QXNzaWdubWVudCA9IGFycmF5QXNzaWdubWVudEZyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCksXG4gICAgICAgIG9iamVjdEFzc2lnbWVudCA9IG9iamVjdEFzc2lnbm1lbnRGcm9tU3RlcE5vZGUoc3RlcE5vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiA9IHZhcmlhYmxlQXNzaWdubWVudHNGcm9tU3RlcE5vZGUoc3RlcE5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHN0ZXAgPSBuZXcgU3RlcChjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5QXNzaWdubWVudCwgb2JqZWN0QXNzaWdtZW50LCB2YXJpYWJsZXNEZWNsYXJhdGlvbik7XG5cbiAgcmV0dXJuIHN0ZXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb21lRnJvbVNvbWVOb2RlKHNvbWVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgU29tZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBzb21lTm9kZSwgIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVNvbWVOb2RlKHNvbWVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlID0gYW5vbnltb3VzUHJvY2VkdXJlRnJvbVNvbWVOb2RlKHNvbWVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgc29tZVN0cmluZyA9IHNvbWVTdHJpbmdGcm9tVmFyaWFibGVBbmRBbm9ueW1vdXNQcm9jZWR1cmUodmFyaWFibGUsIGFub255bW91c1Byb2NlZHVyZSksXG4gICAgICAgIHN0cmluZyA9IHNvbWVTdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBzb21lID0gbmV3IFNvbWUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKTtcblxuICByZXR1cm4gc29tZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHRlcm1Ob2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBuZWdhdGVkVGVybSA9IG5lZ2F0ZWRUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgbG9naWNhbFRlcm0gPSBsb2dpY2FsVGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGJyYWNrZXRlZFRlcm0gPSBicmFja2V0ZWRUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgY29tcGFyaXNvblRlcm0gPSBjb21wYXJpc29uVGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgdmFyaWFibGUsXG4gICAgICAgICAgcHJpbWl0aXZlLFxuICAgICAgICAgIG5lZ2F0ZWRUZXJtLFxuICAgICAgICAgIGxvZ2ljYWxUZXJtLFxuICAgICAgICAgIGJyYWNrZXRlZFRlcm0sXG4gICAgICAgICAgY29tcGFyaXNvblRlcm1cbiAgICAgICAgXSxcbiAgICAgICAgdGVybVN0cmluZyA9IHRlcm1TdHJpbmdGcm9tUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gdGVybVN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm0gPSBuZXcgVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUsIG5lZ2F0ZWRUZXJtLCBsb2dpY2FsVGVybSwgYnJhY2tldGVkVGVybSwgY29tcGFyaXNvblRlcm0pO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNGcm9tVGVybXNOb2RlKHRlcm1zTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHRlcm1zTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB0ZXJtTm9kZXMgPSB0ZXJtc05vZGUuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgIHRlcm1zQXJyYXkgPSB0ZXJtc0FycmF5RnJvbVRlcm1Ob2Rlcyh0ZXJtTm9kZXMsIGNvbnRleHQpLFxuICAgICAgICBhcnJheSA9IHRlcm1zQXJyYXk7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm1zID0gbmV3IFRlcm1zKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpO1xuXG4gIHJldHVybiB0ZXJtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRnJvbUVycm9yTm9kZShlcnJvck5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBFcnJvciB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBlcnJvck5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpO1xuXG4gIHJldHVybiBlcnJvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZXJ5RnJvbUV2ZXJ5Tm9kZShldmVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBFdmVyeSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBldmVyeU5vZGUsIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbUV2ZXJ5Tm9kZShldmVyeU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tRXZlcnlOb2RlKGV2ZXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGV2ZXJ5U3RyaW5nID0gZXZlcnlTdHJpbmdGcm9tVmFyaWFibGVBbmRBbm9ueW1vdXNQcm9jZWR1cmUodmFyaWFibGUsIGFub255bW91c1Byb2NlZHVyZSksXG4gICAgICAgIHN0cmluZyA9IGV2ZXJ5U3RyaW5nOyAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBldmVyeSA9IG5ldyBFdmVyeShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpO1xuXG4gIHJldHVybiBldmVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhYmVsRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBMYWJlbCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBsYWJlbE5vZGUsXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICBuYW1lID0gbmFtZUZyb21MYWJlbE5vZGUobGFiZWxOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBsYWJlbCA9IG5ldyBMYWJlbChjb250ZXh0LCBzdHJpbmcsIG5vZGUsIG5hbWUpO1xuXG4gIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBSZWR1Y2UgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcmVkdWNlTm9kZSwgIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCksXG4gICAgICAgIGluaXRpYWxFeHByZXNzaW9uID0gaW5pdGlhbEV4cHJlc3Npb25Gcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlID0gYW5vbnltb3VzUHJvY2VkdXJlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCksXG4gICAgICAgIHJlZHVjZVN0cmluZyA9IHJlZHVjZVN0cmluZ0Zyb21WYXJpYWJsZUluaXRpYWxFeHByZXNzaW9uQW5kQW5vbnltb3VzUHJvY2VkdXJlKHZhcmlhYmxlLCBpbml0aWFsRXhwcmVzc2lvbiwgYW5vbnltb3VzUHJvY2VkdXJlKSxcbiAgICAgICAgc3RyaW5nID0gcmVkdWNlU3RyaW5nOyAgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcmVkdWNlID0gbmV3IFJlZHVjZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBpbml0aWFsRXhwcmVzc2lvbiwgYW5vbnltb3VzUHJvY2VkdXJlKTtcblxuICByZXR1cm4gcmVkdWNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybmFyeUZyb21UZXJuYXJ5Tm9kZSh0ZXJuYXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm5hcnkgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdGVybmFyeU5vZGUsIC8vL1xuICAgICAgICB0ZXJtID0gdGVybUZyb21UZXJuYXJ5Tm9kZSh0ZXJuYXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGlmRXhwcmVzc2lvbiA9IGlmRXhwcmVzc2lvbkZyb21UZXJuYXJ5Tm9kZSh0ZXJuYXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGVsc2VFeHByZXNzaW9uID0gZWxzZUV4cHJlc3Npb25Gcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpLFxuICAgICAgICB0ZXJuYXJ5U3RyaW5nID0gdGVybmFyeVN0cmluZ0Zyb21UZXJtKHRlcm0pLFxuICAgICAgICBzdHJpbmcgPSB0ZXJuYXJ5U3RyaW5nOyAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJuYXJ5ID0gbmV3IFRlcm5hcnkoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtLCBpZkV4cHJlc3Npb24sIGVsc2VFeHByZXNzaW9uKTtcblxuICByZXR1cm4gdGVybmFyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBWYXJpYWJsZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSB2YXJpYWJsZU5vZGUsICAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHR5cGUgPSB0eXBlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBuYW1lID0gbmFtZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdmFyaWFibGUgPSBuZXcgVmFyaWFibGUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lLCBleHByZXNzaW9uKTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZlcmVuY2VGcm9tUmVmZXJlbmNlTm9kZShyZWZlcmVuY2VOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUmVmZXJlbmNlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHJlZmVyZW5jZU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgbmFtZSA9IG5hbWVGcm9tUmVmZXJlbmNlTm9kZShyZWZlcmVuY2VOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZWZlcmVuY2UgPSBuZXcgUmVmZXJlbmNlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSk7XG5cbiAgcmV0dXJuIHJlZmVyZW5jZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtZXRlckZyb21QYXJhbWV0ZXJOb2RlKHBhcmFtZXRlck5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHBhcmFtZXRlciA9IG51bGw7XG5cbiAgY29uc3QgdHlwZSA9IHR5cGVGcm9tUGFyYW5ldGVyTm9kZShwYXJhbWV0ZXJOb2RlLCBjb250ZXh0KTtcblxuICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHsgUGFyYW1ldGVyIH0gPSBlbGVtZW50cyxcbiAgICAgICAgICBub2RlID0gcGFyYW1ldGVyTm9kZSwgLy8vXG4gICAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgICAgbmFtZSA9IG5hbWVGcm9tUGFyYW5ldGVyTm9kZShwYXJhbWV0ZXJOb2RlLCBjb250ZXh0KTtcblxuICAgIGNvbnRleHQgPSBudWxsO1xuXG4gICAgcGFyYW1ldGVyID0gbmV3IFBhcmFtZXRlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtZXRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeUZyb21Ob2RlUXVlcnlOb2RlKG5vZGVRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOb2RlUXVlcnkgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gbm9kZVF1ZXJ5Tm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbU5vZGVRdWVyeU5vZGUobm9kZVF1ZXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnlGcm9tTm9kZVF1ZXJ5Tm9kZShub2RlUXVlcnlOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBub2RlUXVlcnkgPSBuZXcgTm9kZVF1ZXJ5KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KTtcblxuICByZXR1cm4gbm9kZVF1ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbWl0aXZlRnJvbVByaW1pdGl2ZU5vZGUocHJpbWl0aXZlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFByaW1pdGl2ZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcmltaXRpdmVOb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHR5cGUgPSB0eXBlRnJvbVByaW1pdGl2ZU5vZGUocHJpbWl0aXZlTm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhbHVlID0gdmFsdWVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcmltaXRpdmUgPSBuZXcgUHJpbWl0aXZlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdmFsdWUpO1xuXG4gIHJldHVybiBwcmltaXRpdmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc1F1ZXJ5RnJvbU5vZGVzUXVlcnlOb2RlKG5vZGVzUXVlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgTm9kZXNRdWVyeSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBub2Rlc1F1ZXJ5Tm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21Ob2Rlc1F1ZXJ5Tm9kZShub2Rlc1F1ZXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnlGcm9tTm9kZXNRdWVyeU5vZGUobm9kZXNRdWVyeU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVzUXVlcnkgPSBuZXcgTm9kZXNRdWVyeShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBxdWVyeSk7XG5cbiAgcmV0dXJuIG5vZGVzUXVlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJhbWV0ZXJzRnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUGFyYW1ldGVycyB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwYXJhbWV0ZXJzTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgcGFyYW10ZXJzQXJyYXkgPSBwYXJhbXRlcnNBcnJheUZyb21QYXJhbWV0ZXJzTm9kZShwYXJhbWV0ZXJzTm9kZSwgY29udGV4dCksXG4gICAgICAgIGFycmF5ID0gcGFyYW10ZXJzQXJyYXk7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgUGFyYW1ldGVycyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gcGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cHJlc3Npb25Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBFeHByZXNzaW9uIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGV4cHJlc3Npb25Ob2RlLCAgLy8vXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgc29tZSA9IHNvbWVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBldmVyeSA9IGV2ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmVkdWNlID0gcmVkdWNlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgdGVybmFyeSA9IHRlcm5hcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBub2RlUXVlcnkgPSBub2RlUXVlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBub2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIHJldHVybkJsb2NrID0gcmV0dXJuQmxvY2tGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwcm9jZWR1cmVDYWxsID0gcHJvY2VkdXJlQ2FsbEZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgdGVybSxcbiAgICAgICAgICBzb21lLFxuICAgICAgICAgIGV2ZXJ5LFxuICAgICAgICAgIHJlZHVjZSxcbiAgICAgICAgICB0ZXJuYXJ5LFxuICAgICAgICAgIG5vZGVRdWVyeSxcbiAgICAgICAgICBub2Rlc1F1ZXJ5LFxuICAgICAgICAgIHJldHVybkJsb2NrLFxuICAgICAgICAgIHByb2NlZHVyZUNhbGxcbiAgICAgICAgXSxcbiAgICAgICAgZXhwcmVzc2lvblN0cmluZyA9IGV4cHJlc3Npb25TdHJpbmdGcm9tUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gZXhwcmVzc2lvblN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGV4cHJlc3Npb24gPSBuZXcgRXhwcmVzc2lvbihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0sIHNvbWUsIGV2ZXJ5LCByZWR1Y2UsIHRlcm5hcnksIG5vZGVRdWVyeSwgbm9kZXNRdWVyeSwgcmV0dXJuQmxvY2ssIHByb2NlZHVyZUNhbGwpO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQmxvY2tGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFJldHVybkJsb2NrIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHJldHVybkJsb2NrTm9kZSwgLy8vXG4gICAgICAgIHN0ZXBzID0gc3RlcHNGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vbnNlbnNpY2FsID0gbm9uc2Vuc2ljYWxGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCksXG4gICAgICAgIHJldHVyblN0YXRlbWVudCA9IHJldHVyblN0YXRlbWVudEZyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuQmxvY2tTdHJpbmcgPSByZXR1cm5CbG9ja1N0cmluZ0Zyb21SZXR1cm5TdGF0ZW1lbnROb2RlKHJldHVyblN0YXRlbWVudCksXG4gICAgICAgIHN0cmluZyA9IHJldHVybkJsb2NrU3RyaW5nOyAgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcmV0dXJuQmxvY2sgPSBuZXcgUmV0dXJuQmxvY2soY29udGV4dCwgc3RyaW5nLCBub2RlLCBzdGVwcywgbm9uc2Vuc2ljYWwsIHJldHVyblN0YXRlbWVudCk7XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2VkdXJlQ2FsbEZyb21Qcm9jZWR1cmVDYWxsTm9kZShwcm9jZWR1cmVDYWxsTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFByb2NlZHVyZUNhbGwgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcHJvY2VkdXJlQ2FsbE5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgdGVybXMgPSB0ZXJtc0Zyb21Qcm9jZWR1cmVDYWxsTm9kZShwcm9jZWR1cmVDYWxsTm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcHJvY2VkdXJlQ2FsbCA9IG5ldyBQcm9jZWR1cmVDYWxsKGNvbnRleHQsIHN0cmluZywgbm9kZSwgcmVmZXJlbmNlLCB0ZXJtcyk7XG5cbiAgcmV0dXJuIHByb2NlZHVyZUNhbGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZFBhcmFtZXRlckZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgTmFtZWRQYXJhbWV0ZXIgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gbmFtZWRQYXJhbWV0ZXJOb2RlLCAgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB0eXBlID0gdHlwZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgbmFtZSA9IG5hbWVGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlKG5hbWVkUGFyYW1ldGVyTm9kZSwgY29udGV4dCksXG4gICAgICAgIGFsaWFzID0gYWxpYXNGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlKG5hbWVkUGFyYW1ldGVyTm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgbmFtZWRQYXJhbWV0ZXIgPSBuZXcgTmFtZWRQYXJhbWV0ZXIoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lLCBhbGlhcyk7XG5cbiAgcmV0dXJuIG5hbWVkUGFyYW1ldGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZWRQYXJhbWV0ZXJzRnJvbU5hbWVkUGFyYW1ldGVyc05vZGUobmFtZWRQYXJhbWV0ZXJzTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IE5hbWVkUGFyYW1ldGVycyB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBuYW1lZFBhcmFtZXRlcnNOb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIG5hbWVkUGFyYW1ldGVyTm9kZXMgPSBuYW1lZFBhcmFtZXRlcnNOb2RlLmdldE5hbWVkUGFyYW1ldGVyTm9kZXMoKSxcbiAgICAgICAgbmFtZWRQYXJhbWV0ZXJzQXJyYXkgPSBuYW1lZFBhcmFtdGVyc0FycmF5RnJvbU5hbWVkUGFyYW1ldGVyTm9kZXMobmFtZWRQYXJhbWV0ZXJOb2RlcywgY29udGV4dCksXG4gICAgICAgIGFycmF5ID0gbmFtZWRQYXJhbWV0ZXJzQXJyYXk7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IG5hbWVkUGFyYW1ldGVycyA9IG5ldyBOYW1lZFBhcmFtZXRlcnMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgcmV0dXJuIG5hbWVkUGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5QXNzaWdubWVudEZyb21BcnJheUFzc2lnbm1lbnROb2RlKGFycmF5QXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBBcnJheUFzc2lnbm1lbnQgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gYXJyYXlBc3NpZ25tZW50Tm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbUFycmF5QXNzaWdubWVudE5vZGUoYXJyYXlBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbUFycmF5QXNzaWdubWVudE5vZGUoYXJyYXlBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgYXJyYXlBc3NpZ25tZW50ID0gbmV3IEFycmF5QXNzaWdubWVudChjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwYXJhbWV0ZXJzKTtcblxuICByZXR1cm4gYXJyYXlBc3NpZ25tZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuU3RhdGVtZW50RnJvbVJldHVyblN0YXRlbWVudE5vZGUocmV0dXJuU3RhdGVtZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFJldHVyblN0YXRlbWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSByZXR1cm5TdGF0ZW1lbnROb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbVJldHVyblN0YXRlbWVudE5vZGUocmV0dXJuU3RhdGVtZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcmV0dXJuU3RhdGVtZW50ID0gbmV3IFJldHVyblN0YXRlbWVudChjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0pO1xuXG4gIHJldHVybiByZXR1cm5TdGF0ZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZFBhcmFtZXRlcnNGcm9tT2JqZWN0QXNzaWdubWVudE5vZGUob2JqZWN0QXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbmFtZWRQYXJhbWV0ZXJzTm9kZSA9IG9iamVjdEFzc2lnbm1lbnROb2RlLmdldE5hbWVkUGFyYW1ldGVyc05vZGUoKSxcbiAgICAgICAgbmFtZWRQYXJhbWV0ZXJzID0gbmFtZWRQYXJhbWV0ZXJzRnJvbU5hbWVkUGFyYW1ldGVyc05vZGUobmFtZWRQYXJhbWV0ZXJzTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIG5hbWVkUGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEFzc2lnbm1lbnRGcm9tT2JqZWN0QXNzaWdubWVudE5vZGUob2JqZWN0QXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBPYmplY3RBc3NpZ21lbnQgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gb2JqZWN0QXNzaWdubWVudE5vZGUsICAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tT2JqZWN0QXNzaWdubWVudE5vZGUob2JqZWN0QXNzaWdubWVudE5vZGUsIGNvbnRleHQpLFxuICAgICAgICBuYW1lZFBhcmFtZXRlcnMgPSBuYW1lZFBhcmFtZXRlcnNGcm9tT2JqZWN0QXNzaWdubWVudE5vZGUob2JqZWN0QXNzaWdubWVudE5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IG9iamVjdEFzc2lnbm1lbnQgPSBuZXcgT2JqZWN0QXNzaWdtZW50KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIG5hbWVkUGFyYW1ldGVycyk7XG5cbiAgcmV0dXJuIG9iamVjdEFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgQW5vbnltb3VzUHJvY2VkdXJlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGFub255bW91c1Byb2NlZHVyZU5vZGUsICAvLy9cbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tUHJvY2VkdXJlQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuQmxvY2sgPSByZXR1cm5CbG9ja0Zyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBub255bW91c1Byb2NlZHVyZVN0cmluZyA9IGFub255bW91c1Byb2NlZHVyZVN0cmluZ0Zyb21UeXBlUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrKHR5cGUsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSxcbiAgICAgICAgc3RyaW5nID0gbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmc7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGFub255bW91c1Byb2NlZHVyZSA9IG5ldyBBbm9ueW1vdXNQcm9jZWR1cmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBwYXJhbWV0ZXJzLCByZXR1cm5CbG9jayk7XG5cbiAgcmV0dXJuIGFub255bW91c1Byb2NlZHVyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlQXNzaWdubWVudHNGcm9tVmFyaWFibGVBc3NpZ25tZW50c05vZGUodmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBWYXJpYWJsZUFzc2lnbm1lbnRzIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCAvLy9cbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tVmFyaWFibGVBc3NpZ25tZW50c05vZGUodmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkgPSB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXlGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudHNOb2RlKHR5cGUsIHZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nID0gdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50c0FycmF5KSxcbiAgICAgICAgYXJyYXkgPSB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXksIC8vL1xuICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnRzID0gbmV3IFZhcmlhYmxlQXNzaWdubWVudHMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlQXNzaWdubWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVEZWNsYXJhdGlvbkZyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJvY2VkdXJlRGVjbGFyYXRpb24gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCAgLy8vXG4gICAgICAgIHByb2NlZHVyZSA9IHByb2NlZHVyZUZyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcHJvY2VkdXJlRGVjbGFyYXRpb25TdHJpbmcgPSBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZ0Zyb21Qcm9jZWR1cmUocHJvY2VkdXJlKSxcbiAgICAgICAgc3RyaW5nID0gcHJvY2VkdXJlRGVjbGFyYXRpb25TdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcm9jZWR1cmVEZWNsYXJhdGlvbiA9IG5ldyBQcm9jZWR1cmVEZWNsYXJhdGlvbihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHByb2NlZHVyZSk7XG5cbiAgcmV0dXJuIHByb2NlZHVyZURlY2xhcmF0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21MYWJlbE5vZGUobGFiZWxOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSBsYWJlbE5vZGUuZ2V0TmFtZSgpO1xuXG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21UZXJuYXJ5Tm9kZSh0ZXJuYXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0ZXJtTm9kZSA9IHRlcm5hcnlOb2RlLmdldFRlcm1Ob2RlKCksXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVNvbWVOb2RlKHNvbWVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IHNvbWVOb2RlLmdldFZhcmlhYmxlTm9kZSgpLCAvLy9cbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBsZXQgdmFyaWFibGUgPSBudWxsO1xuXG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IHRlcm1Ob2RlLmdldFZhcmlhYmxlTm9kZSgpO1xuXG4gIGlmICh2YXJpYWJsZU5vZGUgIT09IG51bGwpIHtcbiAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlKSB7XG4gIGNvbnN0IG5hbWUgPSB2YXJpYWJsZU5vZGUuZ2V0TmFtZSgpO1xuXG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBudWxsO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbWl0aXZlRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBwcmltaXRpdmUgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZU5vZGUgPSB0ZXJtTm9kZS5nZXRQcmltaXRpdmVOb2RlKCk7XG5cbiAgaWYgKHByaW1pdGl2ZU5vZGUgIT09IG51bGwpIHtcbiAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBwcmltaXRpdmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21FdmVyeU5vZGUoZXZlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IGV2ZXJ5Tm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbVBhcmFuZXRlck5vZGUocGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0eXBlID0gcGFyYW1ldGVyTm9kZS5nZXRUeXBlKCk7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lRnJvbVBhcmFuZXRlck5vZGUocGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuYW1lID0gcGFyYW1ldGVyTm9kZS5nZXROYW1lKCk7XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lRnJvbVJlZmVyZW5jZU5vZGUocmVmZXJlbmNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuYW1lID0gcmVmZXJlbmNlTm9kZS5nZXROYW1lKCk7XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbVByaW1pdGl2ZU5vZGUocHJpbWl0aXZlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0eXBlID0gcHJpbWl0aXZlTm9kZS5nZXRUeXBlKCk7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gcmVkdWNlTm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCB0ZXJtID0gbnVsbDtcblxuICBjb25zdCB0ZXJtTm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFRlcm1Ob2RlKCk7XG5cbiAgaWYgKHRlcm1Ob2RlICE9PSBudWxsKSB7XG4gICAgdGVybSA9IHRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb21lRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBzb21lID0gbnVsbDtcblxuICBjb25zdCBzb21lTm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFNvbWVOb2RlKCk7XG5cbiAgaWYgKHNvbWVOb2RlICE9PSBudWxsKSB7XG4gICAgc29tZSA9IHNvbWVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHNvbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUZyb21Ob2RlUXVlcnlOb2RlKG5vZGVRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3Qgc3RyaW5nID0gbm9kZVF1ZXJ5Tm9kZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgZXhwcmVzc2lvblN0cmluZyA9IHN0cmluZywgIC8vL1xuICAgICAgICBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBxdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlRnJvbVByaW1pdGl2ZU5vZGUocHJpbWl0aXZlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YWx1ZSA9IHByaW1pdGl2ZU5vZGUuZ2V0VmFsdWUoKTtcblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUZyb21Ob2Rlc1F1ZXJ5Tm9kZShub2Rlc1F1ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBzdHJpbmcgPSBub2Rlc1F1ZXJ5Tm9kZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgZXhwcmVzc2lvblN0cmluZyA9IHN0cmluZywgIC8vL1xuICAgICAgICBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBxdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBldmVyeSA9IG51bGw7XG5cbiAgY29uc3QgZXZlcnlOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0RXZlcnlOb2RlKCk7XG5cbiAgaWYgKGV2ZXJ5Tm9kZSAhPT0gbnVsbCkge1xuICAgIGV2ZXJ5ID0gZXZlcnlGcm9tRXZlcnlOb2RlKGV2ZXJ5Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gZXZlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGVkVGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBsZXQgbmVnYXRlZFRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IG5lZ2F0ZWRUZXJtTm9kZSA9IHRlcm1Ob2RlLmdldE5lZ2F0ZWRUZXJtTm9kZSgpO1xuXG4gIGlmIChuZWdhdGVkVGVybU5vZGUgIT09IG51bGwpIHtcbiAgICBuZWdhdGVkVGVybSA9IG5lZ2F0ZWRUZXJtRnJvbU5lZ2F0ZWRUZXJtTm9kZShuZWdhdGVkVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG5lZ2F0ZWRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9naWNhbFRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IGxvZ2ljYWxUZXJtID0gbnVsbDtcblxuICBjb25zdCBsb2dpY2FsVGVybU5vZGUgPSB0ZXJtTm9kZS5nZXRMb2dpY2FsVGVybU5vZGUoKTtcblxuICBpZiAobG9naWNhbFRlcm1Ob2RlICE9PSBudWxsKSB7XG4gICAgbG9naWNhbFRlcm0gPSBsb2dpY2FsVGVybUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBsb2dpY2FsVGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0eXBlID0gQk9PTEVBTl9UWVBFO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21OZWdhdGVkVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBCT09MRUFOX1RZUEU7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbU5lZ2F0ZWRUZXJtTm9kZShuZWdhdGVkVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybU5vZGUgPSBuZWdhdGVkVGVybU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZXhwcmVzc2lvbk5vZGUgPSByZWR1Y2VOb2RlLmdldEV4cHJlc3Npb25Ob2RlKCksXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBsZXQgcmVkdWNlID0gbnVsbDtcblxuICBjb25zdCByZWR1Y2VOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0UmVkdWNlTm9kZSgpO1xuXG4gIGlmIChyZWR1Y2VOb2RlICE9PSBudWxsKSB7XG4gICAgcmVkdWNlID0gcmVkdWNlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmVkdWNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcHNGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBzdGVwTm9kZXMgPSByZXR1cm5CbG9ja05vZGUuZ2V0U3RlcE5vZGVzKCksXG4gICAgICAgIHN0ZXBzID0gc3RlcE5vZGVzLm1hcCgoc3RlcE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcEZyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHN0ZXBzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tTm9kZVF1ZXJ5Tm9kZShub2RlUXVlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IG5vZGVRdWVyeU5vZGUuZ2V0VmFyaWFibGVOb2RlKCksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybmFyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBsZXQgdGVybmFyeSA9IG51bGw7XG5cbiAgY29uc3QgdGVybmFyeU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXRUZXJuYXJ5Tm9kZSgpO1xuXG4gIGlmICh0ZXJuYXJ5Tm9kZSAhPT0gbnVsbCkge1xuICAgIHRlcm5hcnkgPSB0ZXJuYXJ5RnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB0ZXJuYXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhY2tldGVkVGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBsZXQgYnJhY2tldGVkVGVybSA9IG51bGw7XG5cbiAgY29uc3QgYnJhY2tldGVkVGVybU5vZGUgPSB0ZXJtTm9kZS5nZXRCcmFja2V0ZWRUZXJtTm9kZSgpO1xuXG4gIGlmIChicmFja2V0ZWRUZXJtTm9kZSAhPT0gbnVsbCkge1xuICAgIGJyYWNrZXRlZFRlcm0gPSBicmFja2V0ZWRUZXJtRnJvbUJyYWNrZXRlZFRlcm1Ob2RlKGJyYWNrZXRlZFRlcm1Ob2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBicmFja2V0ZWRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21CcmFja2V0ZWRUZXJtTm9kZShicmFja2V0ZWRUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0ZXJtTm9kZSA9IGJyYWNrZXRlZFRlcm1Ob2RlLmdldFRlcm1Ob2RlKCksXG4gICAgdGVybSA9IHRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyaXNvblRlcm1Gcm9tVGVybU5vZGUodGVybU5PZGUsIGNvbnRleHQpIHtcbiAgbGV0IGNvbXBhcmlzb25UZXJtID0gbnVsbDtcblxuICBjb25zdCBjb21wYXJpc29uVGVybU5vZGUgPSB0ZXJtTk9kZS5nZXRDb21wYXJpc29uVGVybU5vZGUoKTtcblxuICBpZiAoY29tcGFyaXNvblRlcm1Ob2RlICE9PSBudWxsKSB7XG4gICAgY29tcGFyaXNvblRlcm0gPSBjb21wYXJpc29uVGVybUZyb21Db21wYXJpc29uVGVybU5vZGUoY29tcGFyaXNvblRlcm1Ob2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJpc29uVGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cHJlc3Npb25Gcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uID0gbnVsbDtcblxuICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbU5vZGVzUXVlcnlOb2RlKG5vZGVzUXVlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IG5vZGVzUXVlcnlOb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1zRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1zTm9kZSA9IHByb2NlZHVyZUNhbGxOb2RlLmdldFRlcm1zTm9kZSgpLFxuICAgICAgICB0ZXJtcyA9IHRlcm1zRnJvbVRlcm1zTm9kZSh0ZXJtc05vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB0ZXJtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlKG5hbWVkUGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0eXBlID0gbmFtZWRQYXJhbWV0ZXJOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlKG5hbWVkUGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuYW1lID0gbmFtZWRQYXJhbWV0ZXJOb2RlLmdldE5hbWUoKTtcblxuICByZXR1cm4gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRUZXJtRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbGVmdFRlcm1Ob2RlID0gbG9naWNhbFRlcm1Ob2RlLmdldExlZnRUZXJtTm9kZSgpLFxuICAgIGxlZnRUZXJtID0gdGVybUZyb21UZXJtTm9kZShsZWZ0VGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBsZWZ0VGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5QXNzaWdubWVudEZyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCkge1xuICBsZXQgYXJyYXlBc3NpZ25tZW50ID0gbnVsbDtcblxuICBjb25zdCBhcnJheUFzc2lnbm1lbnROb2RlID0gc3RlcE5vZGUuZ2V0QXJyYXlBc3NpZ25tZW50Tm9kZSgpO1xuXG4gIGlmIChhcnJheUFzc2lnbm1lbnROb2RlICE9PSBudWxsKSB7XG4gICAgYXJyYXlBc3NpZ25tZW50ID0gYXJyYXlBc3NpZ25tZW50RnJvbUFycmF5QXNzaWdubWVudE5vZGUoYXJyYXlBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlBc3NpZ25tZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaWZFeHByZXNzaW9uRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGlmRXhwcmVzc2lvbk5vZGUgPSB0ZXJuYXJ5Tm9kZS5nZXRJZkV4cHJlc3Npb25Ob2RlKCksXG4gICAgICAgIGlmRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tRXhwcmVzc2lvbk5vZGUoaWZFeHByZXNzaW9uTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGlmRXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBsZXQgbm9kZVF1ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBub2RlUXVlcnlOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0Tm9kZVF1ZXJ5Tm9kZSgpO1xuXG4gIGlmIChub2RlUXVlcnlOb2RlICE9PSBudWxsKSB7XG4gICAgbm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5RnJvbU5vZGVRdWVyeU5vZGUobm9kZVF1ZXJ5Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gbm9kZVF1ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxpYXNGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlKG5hbWVkUGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBhbGlhcyA9IG5hbWVkUGFyYW1ldGVyTm9kZS5nZXRBbGlhcygpO1xuXG4gIHJldHVybiBhbGlhcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1Ob2RlID0gcmV0dXJuU3RhdGVtZW50Tm9kZS5nZXRUZXJtTm9kZSgpLFxuICAgICAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RBc3NpZ25tZW50RnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSB7XG4gIGxldCBvYmplY3RBc3NpZ25tZW50ID0gbnVsbDtcblxuICBjb25zdCBvYmplY3RBc3NpZ25tZW50Tm9kZSA9IHN0ZXBOb2RlLmdldE9iamVjdEFzc2lnbm1lbnROb2RlKCk7XG5cbiAgaWYgKG9iamVjdEFzc2lnbm1lbnROb2RlICE9PSBudWxsKSB7XG4gICAgb2JqZWN0QXNzaWdubWVudCA9IG9iamVjdEFzc2lnbm1lbnRGcm9tT2JqZWN0QXNzaWdubWVudE5vZGUob2JqZWN0QXNzaWdubWVudE5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdEFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc1F1ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBub2Rlc1F1ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBub2Rlc1F1ZXJ5Tm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldE5vZGVzUXVlcnlOb2RlKCk7XG5cbiAgaWYgKG5vZGVzUXVlcnlOb2RlICE9PSBudWxsKSB7XG4gICAgbm9kZXNRdWVyeSA9IG5vZGVzUXVlcnlGcm9tTm9kZXNRdWVyeU5vZGUobm9kZXNRdWVyeU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzUXVlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByaWdodFRlcm1Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByaWdodFRlcm1Ob2RlID0gbG9naWNhbFRlcm1Ob2RlLmdldFJpZ2h0VGVybU5vZGUoKSxcbiAgICAgICByaWdodFRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKHJpZ2h0VGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiByaWdodFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGVkRnJvbUNvbXBhcmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbmVnYXRlZCA9IGNvbXBhcmlzb25UZXJtTm9kZS5pc05lZ2F0ZWQoKTtcblxuICByZXR1cm4gbmVnYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVsc2VFeHByZXNzaW9uRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGVsc2VFeHByZXNzaW9uTm9kZSA9IHRlcm5hcnlOb2RlLmdldEVsc2VFeHByZXNzaW9uTm9kZSgpLFxuICAgICAgICBlbHNlRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tRXhwcmVzc2lvbk5vZGUoZWxzZUV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gZWxzZUV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5CbG9ja0Zyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBsZXQgcmV0dXJuQmxvY2sgPSBudWxsO1xuXG4gIGNvbnN0IHJldHVybkJsb2NrTm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFJldHVybkJsb2NrTm9kZSgpO1xuXG4gIGlmIChyZXR1cm5CbG9ja05vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm5CbG9jayA9IHJldHVybkJsb2NrRnJvbVJldHVybkJsb2NrTm9kZShyZXR1cm5CbG9ja05vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5vbnltb3VzUHJvY2VkdXJlRnJvbVNvbWVOb2RlKHNvbWVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFub255bW91c1Byb2NlZHVyZU5vZGUgPSBzb21lTm9kZS5nZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub25zZW5zaWNhbEZyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5vbnNlbnNpY2FsID0gcmV0dXJuQmxvY2tOb2RlLmlzTm9uc2Vuc2ljYWwoKTtcblxuICByZXR1cm4gbm9uc2Vuc2ljYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZlcmVuY2VGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IHByb2NlZHVyZUNhbGxOb2RlLmdldFJlZmVyZW5jZU5vZGUoKSxcbiAgICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlRnJvbVJlZmVyZW5jZU5vZGUocmVmZXJlbmNlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJlZmVyZW5jZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRUZXJtRnJvbUNvbXB6cmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbGVmdFRlcm1Ob2RlID0gY29tcGFyaXNvblRlcm1Ob2RlLmdldExlZnRUZXJtTm9kZSgpLFxuICAgICAgICBsZWZ0VGVybSA9IHRlcm1Gcm9tVGVybU5vZGUobGVmdFRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gbGVmdFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNqdW5jdGlvbkZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGRpc2p1bmN0aW9uID0gbG9naWNhbFRlcm1Ob2RlLmlzRGlzanVuY3Rpb24oKTtcblxuICByZXR1cm4gZGlzanVuY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdhdGVkVGVybUZyb21OZWdhdGVkVGVybU5vZGUobmVnYXRlZFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgTmVnYXRlZFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gbmVnYXRlZFRlcm1Ob2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHRlcm1Ob2RlID0gbmVnYXRlZFRlcm1Ob2RlLmdldFRlcm1Ob2RlKCksXG4gICAgICAgIHR5cGUgPSB0eXBlRnJvbU5lZ2F0ZWRUZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbU5lZ2F0ZWRUZXJtTm9kZShuZWdhdGVkVGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBuZWdhdGVkVGVybSA9IG5ldyBOZWdhdGVkVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHRlcm0pO1xuXG4gIHJldHVybiBuZWdhdGVkVGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2ljYWxUZXJtRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBMb2dpY2FsVGVybSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBsb2dpY2FsVGVybU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGRpc2p1bmN0aW9uID0gZGlzanVuY3Rpb25Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGxlZnRUZXJtID0gbGVmdFRlcm1Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHJpZ2h0VGVybSA9IHJpZ2h0VGVybUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgbG9naWNhbFRlcm0gPSBuZXcgTG9naWNhbFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBkaXNqdW5jdGlvbiwgbGVmdFRlcm0sIHJpZ2h0VGVybSk7XG5cbiAgcmV0dXJuIGxvZ2ljYWxUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tVHlwZUFuZFZhcmlhYmxlTm9kZSh0eXBlLCB2YXJpYWJsZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBWYXJpYWJsZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSB2YXJpYWJsZU5vZGUsICAvLy9cbiAgICAgICAgbmFtZSA9IG5hbWVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSksXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uRnJvbVR5cGVBbmRWYXJpYWJsZU5vZGUodHlwZSwgdmFyaWFibGVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZVN0cmluZ0Zyb21OYW1lKG5hbWUpLFxuICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZVN0cmluZywgIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGV4cHJlc3Npb24pO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlQXNzaWdubWVudHNGcm9tU3RlcE5vZGUoc3RlcE5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHZhcmlhYmxlQXNzaWdubWVudHMgPSBudWxsO1xuXG4gIGNvbnN0IHZhcmlhYmxlQXNzaWdubWVudHNOb2RlID0gc3RlcE5vZGUuZ2V0VmFyaWFibGVBc3NpZ25tZW50c05vZGUoKTtcblxuICBpZiAodmFyaWFibGVBc3NpZ25tZW50c05vZGUgIT09IG51bGwpIHtcbiAgICB2YXJpYWJsZUFzc2lnbm1lbnRzID0gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFub255bW91c1Byb2NlZHVyZUZyb21FdmVyeU5vZGUoZXZlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFub255bW91c1Byb2NlZHVyZU5vZGUgPSBldmVyeU5vZGUuZ2V0QW5vbnltb3VzUHJvY2VkdXJlTm9kZSgpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbEV4cHJlc3Npb25Gcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCksXG4gICAgICAgIGluaXRpYWxFeHByZXNzaW9uID0gZXhwcmVzc2lvbjsgLy8vXG5cbiAgcmV0dXJuIGluaXRpYWxFeHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2VkdXJlQ2FsbEZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBsZXQgcHJvY2VkdXJlQ2FsbCA9IG51bGw7XG5cbiAgY29uc3QgcHJvY2VkdXJlQ2FsbE5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXRQcm9jZWR1cmVDYWxsTm9kZSgpO1xuXG4gIGlmIChwcm9jZWR1cmVDYWxsTm9kZSAhPT0gbnVsbCkge1xuICAgIHByb2NlZHVyZUNhbGwgPSBwcm9jZWR1cmVDYWxsRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBwcm9jZWR1cmVDYWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmlnaHRUZXJtRnJvbUNvbXB6cmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcmlnaHRUZXJtTm9kZSA9IGNvbXBhcmlzb25UZXJtTm9kZS5nZXRSaWdodFRlcm1Ob2RlKCksXG4gICAgICAgIHJpZ2h0VGVybSA9IHRlcm1Gcm9tVGVybU5vZGUocmlnaHRUZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJpZ2h0VGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbUFycmF5QXNzaWdubWVudE5vZGUoYXJyYXlBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSBhcnJheUFzc2lnbm1lbnROb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tVmFyaWFibGVBc3NpZ25tZW50c05vZGUodmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IHZhcmlhYmxlQXNzaWdubWVudHNOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFub255bW91c1Byb2NlZHVyZUZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IHJlZHVjZU5vZGUuZ2V0QW5vbnltb3VzUHJvY2VkdXJlTm9kZSgpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tT2JqZWN0QXNzaWdubWVudE5vZGUob2JqZWN0QXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gb2JqZWN0QXNzaWdubWVudE5vZGUuZ2V0VmFyaWFibGVOb2RlKCksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21UeXBlQW5kVmFyaWFibGVOb2RlKHR5cGUsIHZhcmlhYmxlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uID0gbnVsbDtcblxuICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtZXRlcnNGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBhcmFtZXRlcnNOb2RlID0gYXJyYXlBc3NpZ25tZW50Tm9kZS5nZXRQYXJhbWV0ZXJzTm9kZSgpLFxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVyc0Zyb21QYXJhbWV0ZXJzTm9kZShwYXJhbWV0ZXJzTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbEZyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxhYmVsTm9kZSA9IHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZS5nZXRMYWJlbE5vZGUoKSxcbiAgICAgICAgbGFiZWwgPSBsYWJlbEZyb21MYWJlbE5vZGUobGFiZWxOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gbGFiZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnRGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByZXR1cm5TdGF0ZW1lbnROb2RlID0gcmV0dXJuQmxvY2tOb2RlLmdldFJldHVyblN0YXRlbWVudE5vZGUoKSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50RnJvbVJldHVyblN0YXRlbWVudE5vZGUocmV0dXJuU3RhdGVtZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJldHVyblN0YXRlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYWNrZXRlZFRlcm1Gcm9tQnJhY2tldGVkVGVybU5vZGUoYnJhY2tldGVkVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBCcmFja2V0ZWRUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGJyYWNrZXRlZFRlcm1Ob2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksICAvLy9cbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tQnJhY2tldGVkVGVybU5vZGUoYnJhY2tldGVkVGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBicmFja2V0ZWRUZXJtID0gbmV3IEJyYWNrZXRlZFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtKTtcblxuICByZXR1cm4gYnJhY2tldGVkVGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cHJlc3Npb25Gcm9tVmFyaWFibGVBc3NpZ25tZW50Tm9kZSh2YXJpYWJsZUFzc2lnbWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZXhwcmVzc2lvbk5vZGUgPSB2YXJpYWJsZUFzc2lnbWVudE5vZGUuZ2V0RXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyc0Zyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyYW1ldGVyc05vZGUgPSBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLmdldFBhcmFtZXRlcnNOb2RlKCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmlzb25UZXJtRnJvbUNvbXBhcmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBDb21wYXJpc29uVGVybSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBjb21wYXJpc29uVGVybU5vZGUsICAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIG5lZ2F0ZWQgPSBuZWdhdGVkRnJvbUNvbXBhcmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBsZWZ0VGVybSA9IGxlZnRUZXJtRnJvbUNvbXB6cmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICByaWdodFRlcm0gPSByaWdodFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGNvbXBhcmlzb25UZXJtID0gbmV3IENvbXBhcmlzb25UZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmVnYXRlZCwgbGVmdFRlcm0sIHJpZ2h0VGVybSk7XG5cbiAgcmV0dXJuIGNvbXBhcmlzb25UZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQmxvY2tGcm9tQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHJldHVybkJsb2NrTm9kZSA9IGFub255bW91c1Byb2NlZHVyZU5vZGUuZ2V0UmV0dXJuQmxvY2tOb2RlKCksXG4gICAgICAgIHJldHVybkJsb2NrID0gcmV0dXJuQmxvY2tGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2VkdXJlRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcm9jZWR1cmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCAgLy8vXG4gICAgICAgIHR5cGUgPSB0eXBlRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBsYWJlbCA9IGxhYmVsRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVyc0Zyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuQmxvY2sgPSByZXR1cm5CbG9ja0Zyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcHJvY2VkdXJlU3RyaW5nID0gcHJvY2VkdXJlU3RyaW5nRnJvbVR5cGVMYWJlbFBhcmFtZXRlcnNBbmRSZXR1cm5CbG9jayh0eXBlLCBsYWJlbCwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spLFxuICAgICAgICBzdHJpbmcgPSBwcm9jZWR1cmVTdHJpbmcsIC8vL1xuICAgICAgICBwcm9jZWR1cmUgPSBuZXcgUHJvY2VkdXJlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbGFiZWwsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKTtcblxuICByZXR1cm4gcHJvY2VkdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyc0Zyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUocHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBhcmFtZXRlcnNOb2RlID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLmdldFBhcmFtZXRlcnNOb2RlKCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tUHJvY2VkdXJlQW5vbnltb3VzUHJvY2VkdXJlTm9kZShhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkJsb2NrRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcmV0dXJuQmxvY2tOb2RlID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLmdldFJldHVybkJsb2NrTm9kZSgpLFxuICAgICAgICByZXR1cm5CbG9jayA9IHJldHVybkJsb2NrRnJvbVJldHVybkJsb2NrTm9kZShyZXR1cm5CbG9ja05vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiByZXR1cm5CbG9jaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnROb2RlKHR5cGUsIHZhcmlhYmxlQXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gdmFyaWFibGVBc3NpZ25tZW50Tm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21UeXBlQW5kVmFyaWFibGVOb2RlKHR5cGUsIHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50RnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnROb2RlKHR5cGUsIHZhcmlhYmxlQXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBWYXJpYWJsZUFzc2lnbm1lbnQgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnROb2RlKHR5cGUsIHZhcmlhYmxlQXNzaWdubWVudE5vZGUsIGNvbnRleHQpLFxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21WYXJpYWJsZUFzc2lnbm1lbnROb2RlKHZhcmlhYmxlQXNzaWdubWVudE5vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlKHR5cGUsIHZhcmlhYmxlLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nLCAgLy8vXG4gICAgICAgIGFzc2lnbm1lbnQgPSBuZXcgVmFyaWFibGVBc3NpZ25tZW50KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGV4cHJlc3Npb24pO1xuXG4gIHJldHVybiBhc3NpZ25tZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNBcnJheUZyb21UZXJtTm9kZXModGVybU5vZGVzLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1zQXJyYXkgPSB0ZXJtTm9kZXMubWFwKCh0ZXJtTm9kZSkgPT4geyAvLy9cbiAgICBjb25zdCB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1zQXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJhbXRlcnNBcnJheUZyb21QYXJhbWV0ZXJzTm9kZShwYXJhbWV0ZXJzTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBwYXJhbWV0ZXJOb2RlcyA9IHBhcmFtZXRlcnNOb2RlLmdldFBhcmFtZXRlck5vZGVzKCksXG4gICAgICAgIHBhcmFtdGVyc0FycmF5ID0gcGFyYW1ldGVyTm9kZXMubWFwKChwYXJhbWV0ZXJOb2RlKSA9PiB7IC8vL1xuICAgICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlckZyb21QYXJhbWV0ZXJOb2RlKHBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcjtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtdGVyc0FycmF5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZWRQYXJhbXRlcnNBcnJheUZyb21OYW1lZFBhcmFtZXRlck5vZGVzKG5hbWVkUGFyYW1ldGVyTm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgbmFtZWRQYXJhbXRlcnNBcnJheSA9IG5hbWVkUGFyYW1ldGVyTm9kZXMubWFwKChuYW1lZFBhcmFtZXRlck5vZGUpID0+IHsgLy8vXG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXIgPSBuYW1lZFBhcmFtZXRlckZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBuYW1lZFBhcmFtZXRlcjtcbiAgfSk7XG5cbiAgcmV0dXJuIG5hbWVkUGFyYW10ZXJzQXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXlGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudHNOb2RlKHR5cGUsIHZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlQXNzaWdubWVudE5vZGVzID0gdmFyaWFibGVBc3NpZ25tZW50c05vZGUuZ2V0VmFyaWFibGVBc3NpZ25tZW50Tm9kZXMoKSxcbiAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50c0FycmF5ID0gdmFyaWFibGVBc3NpZ25tZW50Tm9kZXMubWFwKCh2YXJpYWJsZUFzc2lnbm1lbnROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50ID0gdmFyaWFibGVBc3NpZ25tZW50RnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnROb2RlKHR5cGUsIHZhcmlhYmxlQXNzaWdubWVudE5vZGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgcmV0dXJuIHZhcmlhYmxlQXNzaWdubWVudDtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlQXNzaWdubWVudHNBcnJheTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgU2ltcGxlUGFzcywgcXVlcnlVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGVycm9yRnJvbUVycm9yTm9kZSwgcHJvY2VkdXJlRGVjbGFyYXRpb25Gcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9lbGVtZW50XCI7XG5cbmNvbnN0IHsgbm9kZVF1ZXJ5IH0gPSBxdWVyeVV0aWxpdGllcztcblxuY29uc3QgZXJyb3JOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvZXJyb3JcIiksXG4gICAgICBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9wcm9jZWR1cmVEZWNsYXJhdGlvblwiKTtcblxuY2xhc3MgVG9wTGV2ZWxQYXNzIGV4dGVuZHMgU2ltcGxlUGFzcyB7XG4gIHN0YXRpYyBtYXBzID0gW1xuICAgIHtcbiAgICAgIG5vZGVRdWVyeTogZXJyb3JOb2RlUXVlcnksXG4gICAgICBydW46IChlcnJvck5vZGUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yRnJvbUVycm9yTm9kZShlcnJvck5vZGUsIGNvbnRleHQpLFxuICAgICAgICAgICAgICBlcnJvclZlcmlmaWVzID0gZXJyb3IudmVyaWZ5KGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChlcnJvclZlcmlmaWVzKSB7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vZGVRdWVyeTogcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlUXVlcnksXG4gICAgICBydW46IChwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBwcm9jZWR1cmVEZWNsYXJhdGlvbiA9IHByb2NlZHVyZURlY2xhcmF0aW9uRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICAgICAgICBwcm9jZWR1cmVEZWNsYXJhdGlvblZlcmlmaWVzID0gcHJvY2VkdXJlRGVjbGFyYXRpb24udmVyaWZ5KGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChwcm9jZWR1cmVEZWNsYXJhdGlvblZlcmlmaWVzKSB7XG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5cbmNvbnN0IHRvcExldmVsUGFzcyA9IG5ldyBUb3BMZXZlbFBhc3MoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUZpbGUoZmlsZU5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IGZpbGVWZXJpZmllcyA9IGZhbHNlO1xuXG4gIGNvbnN0IG5vZGUgPSBmaWxlTm9kZSwgLy8vXG4gICAgICAgIHN1Y2VzcyA9IHRvcExldmVsUGFzcy5ydW4obm9kZSwgY29udGV4dCk7XG5cbiAgaWYgKHN1Y2Vzcykge1xuICAgIGZpbGVWZXJpZmllcyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZmlsZVZlcmlmaWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBsZXhlclV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IEZ1cnRsZUxleGVyIGZyb20gXCIuLi9mdXJ0bGUvbGV4ZXJcIjtcblxuY29uc3QgeyBsZXhlckZyb21SdWxlcywgcnVsZXNGcm9tRW50cmllcyB9ID0gbGV4ZXJVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdXJ0bGVMZXhlckZyb21Ob3RoaW5nKENsYXNzKSB7XG4gIGlmIChDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgQ2xhc3MgPSBGdXJ0bGVMZXhlcjsgIC8vL1xuICB9XG5cbiAgY29uc3QgeyBlbnRyaWVzIH0gPSBGdXJ0bGVMZXhlcjtcblxuICBsZXQgcnVsZXM7XG5cbiAgcnVsZXMgPSBydWxlc0Zyb21FbnRyaWVzKGVudHJpZXMpO1xuXG4gIGNvbnN0IGZ1cnRsZUxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gZnVydGxlTGV4ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdXJ0bGVMZXhlckZyb21FbnRyaWVzKENsYXNzLCBlbnRyaWVzKSB7XG4gIGlmIChlbnRyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBlbnRyaWVzID0gQ2xhc3M7ICAvLy9cblxuICAgIENsYXNzID0gRnVydGxlTGV4ZXI7ICAvLy9cbiAgfVxuXG4gIGxldCBydWxlcztcblxuICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgY29uc3QgZnVydGxlTGV4ZXIgPSBsZXhlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBmdXJ0bGVMZXhlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBmdXJ0bGVMZXhlckZyb21FbnRyaWVzLFxuICBmdXJ0bGVMZXhlckZyb21Ob3RoaW5nXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJzZXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgZWxpbWluYXRlTGVmdFJlY3Vyc2lvbiB9IGZyb20gXCJvY2NhbS1ncmFtbWFyLXV0aWxpdGllc1wiO1xuXG5pbXBvcnQgRnVydGxlUGFyc2VyIGZyb20gXCIuLi9mdXJ0bGUvcGFyc2VyXCI7XG5cbmNvbnN0IHsgcnVsZXNGcm9tQk5GLCBwYXJzZXJGcm9tUnVsZXMsIHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUgfSA9IHBhcnNlclV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZVBhcnNlckZyb21CTkYoQ2xhc3MsIGJuZikge1xuICBpZiAoYm5mID09PSB1bmRlZmluZWQpIHtcbiAgICBibmYgPSBDbGFzczsgIC8vL1xuXG4gICAgQ2xhc3MgPSBGdXJ0bGVQYXJzZXI7ICAvLy9cbiAgfVxuXG4gIGxldCBydWxlcztcblxuICBydWxlcyA9IHJ1bGVzRnJvbUJORihibmYpO1xuXG4gIHJ1bGVzID0gZWxpbWluYXRlTGVmdFJlY3Vyc2lvbihydWxlcyk7ICAvLy9cblxuICBjb25zdCBmdXJ0bGVQYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gZnVydGxlUGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVydGxlUGFyc2VyRnJvbU5vdGhpbmcoQ2xhc3MpIHtcbiAgaWYgKENsYXNzID09PSB1bmRlZmluZWQpIHtcbiAgICBDbGFzcyA9IEZ1cnRsZVBhcnNlcjsgIC8vL1xuICB9XG5cbiAgY29uc3QgeyBibmYgfSA9IEZ1cnRsZVBhcnNlcjtcblxuICBsZXQgcnVsZXM7XG5cbiAgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICBydWxlcyA9IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpOyAgLy8vXG5cbiAgY29uc3QgZnVydGxlUGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGZ1cnRsZVBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZVBhcnNlckZyb21CTkZBbmRTdGFydFJ1bGVOYW1lKENsYXNzLCBibmYsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgaWYgKHN0YXJ0UnVsZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0UnVsZU5hbWUgPSBibmY7ICAvLy9cblxuICAgIGJuZiA9IENsYXNzOyAgLy8vXG5cbiAgICBDbGFzcyA9IEZ1cnRsZVBhcnNlcjsgIC8vL1xuICB9XG5cbiAgbGV0IHJ1bGVzO1xuXG4gIHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZik7XG5cbiAgcnVsZXMgPSBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uKHJ1bGVzKTsgIC8vL1xuXG4gIGNvbnN0IGZ1cnRsZVBhcnNlciA9IHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUoQ2xhc3MsIHJ1bGVzLCBzdGFydFJ1bGVOYW1lKTtcblxuICByZXR1cm4gZnVydGxlUGFyc2VyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZ1cnRsZVBhcnNlckZyb21CTkYsXG4gIGZ1cnRsZVBhcnNlckZyb21Ob3RoaW5nLFxuICBmdXJ0bGVQYXJzZXJGcm9tQk5GQW5kU3RhcnRSdWxlTmFtZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEZ1cnRsZUxleGVyIGZyb20gXCIuLi9mdXJ0bGUvbGV4ZXJcIjtcbmltcG9ydCBGdXJ0bGVQYXJzZXIgZnJvbSBcIi4uL2Z1cnRsZS9wYXJzZXJcIjtcblxuaW1wb3J0IHsgZnVydGxlTGV4ZXJGcm9tTm90aGluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvbGV4ZXJzXCI7XG5pbXBvcnQgeyBmdXJ0bGVQYXJzZXJGcm9tTm90aGluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFyc2Vyc1wiO1xuXG5leHBvcnQgY29uc3QgZnVydGxlTGV4ZXIgPSBmdXJ0bGVMZXhlckZyb21Ob3RoaW5nKEZ1cnRsZUxleGVyKTtcblxuZXhwb3J0IGNvbnN0IGZ1cnRsZVBhcnNlciA9IGZ1cnRsZVBhcnNlckZyb21Ob3RoaW5nKEZ1cnRsZVBhcnNlcik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEZpbGVDb250ZXh0IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyB2ZXJpZnlGaWxlIH0gZnJvbSBcIi4uLy4uL3Byb2Nlc3MvdmVyaWZ5XCI7XG5pbXBvcnQgeyBmdXJ0bGVMZXhlciwgZnVydGxlUGFyc2VyIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9mdXJ0bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVydGxlRmlsZUNvbnRleHQgZXh0ZW5kcyBGaWxlQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUsIHByb2NlZHVyZXMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBmaWxlUGF0aCwgdG9rZW5zLCBub2RlKTtcblxuICAgIHRoaXMucHJvY2VkdXJlcyA9IHByb2NlZHVyZXM7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHByb2NlZHVyZXMgPSBpbmNsdWRlUmVsZWFzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmdldFByb2NlZHVyZXMoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2NlZHVyZXM7XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlcztcbiAgfVxuXG4gIGdldExleGVyKCkge1xuICAgIGNvbnN0IGxleGVyID0gZnVydGxlTGV4ZXI7ICAvLy9cblxuICAgIHJldHVybiBsZXhlcjtcbiAgfVxuXG4gIGdldFBhcnNlcigpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBmdXJ0bGVQYXJzZXI7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZXI7XG4gIH1cblxuICBnZXRMYWJlbHMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgICByZXR1cm4gbGFiZWxzO1xuICB9XG5cbiAgZ2V0VHlwZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgdHlwZXMgPSBbXTtcblxuICAgIHJldHVybiB0eXBlcztcbiAgfVxuXG4gIGdldFJ1bGVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHJ1bGVzID0gW11cblxuICAgIHJldHVybiBydWxlcztcbiAgfVxuXG4gIGdldEF4aW9tcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBheGlvbXMgPSBbXTtcblxuICAgIHJldHVybiBheGlvbXM7XG4gIH1cblxuICBnZXRMZW1tYXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgbGVtbWFzID0gW107XG5cbiAgICByZXR1cm4gbGVtbWFzO1xuICB9XG5cbiAgZ2V0VGhlb3JlbXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgdGhlb3JlbXMgPSBbXTtcblxuICAgIHJldHVybiB0aGVvcmVtcztcbiAgfVxuXG4gIGdldFZhcmlhYmxlcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcblxuICAgIHJldHVybiB2YXJpYWJsZXM7XG4gIH1cblxuICBnZXRNZXRhTGVtbWFzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGFMZW1tYXMgPSBbXTtcblxuICAgIHJldHVybiBtZXRhTGVtbWFzO1xuICB9XG5cbiAgZ2V0Q29uamVjdHVyZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgY29uamVjdHVyZXMgPSBbXTtcblxuICAgIHJldHVybiBjb25qZWN0dXJlcztcbiAgfVxuXG4gIGdldENvbWJpbmF0b3JzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbWJpbmF0b3JzID0gW107XG5cbiAgICByZXR1cm4gY29tYmluYXRvcnM7XG4gIH1cblxuICBnZXRUeXBlUHJlZml4ZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgdHlwZVByZWZpeGVzID0gW107XG5cbiAgICByZXR1cm4gdHlwZVByZWZpeGVzO1xuICB9XG5cbiAgZ2V0Q29uc3RydWN0b3JzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9ycyA9IFtdO1xuXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9ycztcbiAgfVxuXG4gIGdldE1ldGF0aGVvcmVtcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhdGhlb3JlbXMgPSBbXTtcblxuICAgIHJldHVybiBtZXRhdGhlb3JlbXM7XG4gIH1cblxuICBnZXRNZXRhdmFyaWFibGVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGF2YXJpYWJsZXMgPSBbXTtcblxuICAgIHJldHVybiBtZXRhdmFyaWFibGVzO1xuICB9XG5cbiAgYWRkUHJvY2VkdXJlKHByb2NlZHVyZSkge1xuICAgIGNvbnN0IHByb2NlZHVyZVN0cmluZyA9IHByb2NlZHVyZS5nZXRTdHJpbmcoKTtcblxuICAgIHRoaXMucHJvY2VkdXJlcy5wdXNoKHByb2NlZHVyZSk7XG5cbiAgICBjb25zdCBmaWxlUGF0aCA9IHRoaXMuZ2V0RmlsZVBhdGgoKTtcblxuICAgIHRoaXMuZGVidWcoYEFkZGVkIHRoZSAnJHtwcm9jZWR1cmVTdHJpbmd9JyBwcm9jZWR1cmUgdG8gdGhlICcke2ZpbGVQYXRofScgZmlsZSBjb250ZXh0LmApO1xuICB9XG5cbiAgZmluZFByb2NlZHVyZUJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IHRoaXMuZ2V0UHJvY2VkdXJlcygpLFxuICAgICAgICAgIHByb2NlZHVyZSA9IHByb2NlZHVyZXMuZmluZCgocHJvY2VkdXJlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZWR1cmVDb21wYXJlc1RvUHJvY2VkdXJlTmFtZSA9IHByb2NlZHVyZS5jb21wYXJlUHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTtcblxuICAgICAgICAgICAgaWYgKHByb2NlZHVyZUNvbXBhcmVzVG9Qcm9jZWR1cmVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlO1xuICB9XG5cbiAgaXNQcm9jZWR1cmVQcmVzZW50QnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpIHtcbiAgICBjb25zdCBwcm9jZWR1cmUgPSB0aGlzLmZpbmRQcm9jZWR1cmVCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSksXG4gICAgICAgICAgcHJvY2VkdXJlUHJlc2VudCA9IChwcm9jZWR1cmUgIT09IG51bGwpO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZVByZXNlbnQ7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLnByb2NlZHVyZXMgPSBbXTtcbiAgfVxuXG4gIGNvbXBsZXRlKCkge1xuICAgIC8vL1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5RmlsZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKCksXG4gICAgICAgICAgY29udGV4dCA9IHRoaXMsIC8vL1xuICAgICAgICAgIGZpbGVOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIGZpbGVWZXJpZmllcyA9IHZlcmlmeUZpbGUoZmlsZU5vZGUsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGZpbGVWZXJpZmllcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRmlsZShmaWxlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IFtdLFxuICAgICAgICAgIGZ1cnRsZUZpbGVDb250ZXh0ID0gRmlsZUNvbnRleHQuZnJvbUZpbGUoRnVydGxlRmlsZUNvbnRleHQsIGZpbGUsIHByb2NlZHVyZXMsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGZ1cnRsZUZpbGVDb250ZXh0O1xuICB9XG5cbiAgc3RhdGljIGZyb21GaWxlUGF0aChmaWxlUGF0aCwgY29udGV4dCkge1xuICAgIGNvbnN0IHByb2NlZHVyZXMgPSBudWxsLFxuICAgICAgICAgIGZ1cnRsZUZpbGVDb250ZXh0ID0gaWxlQ29udGV4dC5mcm9tRmlsZVBhdGgoRnVydGxlRmlsZUNvbnRleHQsIGZpbGVQYXRoLCBwcm9jZWR1cmVzLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBmdXJ0bGVGaWxlQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmltcG9ydCB7IHRlcm1zU3RyaW5nRnJvbVRlcm1zQXJyYXkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlLCB0ZXJtRnJvbVByaW1pdGl2ZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtcyB9ID0gZWxlbWVudHMsXG4gICAgICAgIHRlcm1zQXJyYXkgPSB0ZXJtc0FycmF5RnJvbU5vZGVzKG5vZGVzLCBjb250ZXh0KSxcbiAgICAgICAgdGVybXNTdHJpbmcgPSB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5KHRlcm1zQXJyYXkpLFxuICAgICAgICBzdHJpbmcgPSB0ZXJtc1N0cmluZywgLy8vXG4gICAgICAgIGFycmF5ID0gdGVybXNBcnJheSwgIC8vL1xuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJtcyA9IG5ldyBUZXJtcyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gdGVybXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0Zyb21QcmltaXRpdmVzKHByaW1pdGl2ZXMpIHtcbiAgY29uc3QgeyBUZXJtcyB9ID0gZWxlbWVudHMsXG4gICAgICAgIHRlcm1zQXJyYXkgPSB0ZXJtc0FycmF5RnJvbVByaW1pdGl2ZXMocHJpbWl0aXZlcyksXG4gICAgICAgIHRlcm1zU3RyaW5nID0gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5KSxcbiAgICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICAgIHN0cmluZyA9IHRlcm1zU3RyaW5nLCAvLy9cbiAgICAgICAgYXJyYXkgPSB0ZXJtc0FycmF5LCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsLFxuICAgICAgICB0ZXJtcyA9IG5ldyBUZXJtcyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gdGVybXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdGVybXNGcm9tTm9kZXMsXG4gIHRlcm1zRnJvbVByaW1pdGl2ZXNcbn07XG5cbmZ1bmN0aW9uIHRlcm1zQXJyYXlGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybXNBcnJheSA9IG5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IHRlcm0gPSB0ZXJtRnJvbU5vZGUobm9kZSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1zQXJyYXk7XG59XG5cbmZ1bmN0aW9uIHRlcm1zQXJyYXlGcm9tUHJpbWl0aXZlcyhwcmltaXRpdmVzKSB7XG4gIGNvbnN0IHRlcm1zQXJyYXkgPSBwcmltaXRpdmVzLm1hcCgocHJpbWl0aXZlKSA9PiB7XG4gICAgY29uc3QgdGVybSA9IHRlcm1Gcm9tUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1zQXJyYXk7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFwiLi9wcmVhbWJsZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlcm1zIH0gZnJvbSBcIi4vZWxlbWVudC90ZXJtc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZ1cnRsZUxleGVyIH0gZnJvbSBcIi4vZnVydGxlL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZ1cnRsZVBhcnNlciB9IGZyb20gXCIuL2Z1cnRsZS9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlRmlsZUNvbnRleHQgfSBmcm9tIFwiLi9jb250ZXh0L2ZpbGUvZnVydGxlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGVybVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy90ZXJtXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRlcm1zVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3Rlcm1zXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxleGVyc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9sZXhlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2Vyc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9wYXJzZXJzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByaW1pdGl2ZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9wcmltaXRpdmVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuY29uc3QgU3ViSGVhZGluZyA9IHdpdGhTdHlsZS5oMmBcblxuICBtYXJnaW46IDFyZW0gMCAwLjVyZW0gMDtcbiAgZm9udC1zaXplOiAycmVtO1xuICBcbiAgOmZpcnN0LW9mLXR5cGUge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gIH1cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgU3ViSGVhZGluZztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgU2l6ZWFibGVEaXYgfSBmcm9tIFwiZWFzeS1sYXlvdXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFNpemVhYmxlRGl2KWBcblxuICB3aWR0aDogODByZW07XG4gIG1pbi13aWR0aDogNDhyZW07XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgVGV4dGFyZWEgfSBmcm9tIFwiZWFzeVwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVGV4dGFyZWEpYFxuXG4gIGJvcmRlcjogMXB4IHNvbGlkIGRhcmtncmV5O1xuICBoZWlnaHQ6IDM2cmVtO1xuICByZXNpemU6IHZlcnRpY2FsO1xuICBwYWRkaW5nOiAwLjI1cmVtO1xuICBmb250LXNpemU6IDEuMnJlbTtcbiAgbGluZS1oZWlnaHQ6IDEuNXJlbTtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCTkZUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgZ2V0Qk5GKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpLFxuICAgICAgICAgIGJuZiA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBibmY7XG4gIH1cblxuICBzZXRCTkYoYm5mKSB7XG4gICAgY29uc3QgdmFsdWUgPSBibmY7XG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0Qk5GID0gdGhpcy5nZXRCTkYuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXRCTkYgPSB0aGlzLnNldEJORi5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRCTkYsXG4gICAgICBzZXRCTkZcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiYm5mXCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiXG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IElucHV0IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgUnVsZU5hbWVJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgZ2V0UnVsZU5hbWUoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgcnVsZU5hbWUgPSB2YWx1ZTsgLy8vXG5cbiAgICByZXR1cm4gcnVsZU5hbWU7XG4gIH1cblxuICBzZXRSdWxlTmFtZShydWxlTmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gcnVsZU5hbWU7IC8vL1xuXG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBwYXJlbnRDb250ZXh0KCkge1xuICAgIGNvbnN0IGdldFJ1bGVOYW1lID0gdGhpcy5nZXRSdWxlTmFtZS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldFJ1bGVOYW1lID0gdGhpcy5zZXRSdWxlTmFtZS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRSdWxlTmFtZSxcbiAgICAgIHNldFJ1bGVOYW1lXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInJ1bGUtbmFtZVwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoUnVsZU5hbWVJbnB1dClgXG5cbiAgYm9yZGVyOiAxcHggc29saWQgZGFya2dyZXk7XG4gIHBhZGRpbmc6IDAuMjVyZW07XG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0YXJlYSBmcm9tIFwiLi4vdGV4dGFyZWFcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uLy4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbnNUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgc2V0VG9rZW5zKHRva2Vucykge1xuICAgIGxldCBsaW5lTnVtYmVyID0gMSxcbiAgICAgICAgcHJldmlvdXNUb2tlbiA9IG51bGw7XG5cbiAgICBjb25zdCBodG1sID0gdG9rZW5zLnJlZHVjZSgoaHRtbCwgdG9rZW4pID0+IHtcbiAgICAgIGNvbnN0IHRva2VuSFRNTCA9IHRva2VuLmFzSFRNTCgpO1xuXG4gICAgICBpZiAocHJldmlvdXNUb2tlbiA9PT0gbnVsbCkge1xuICAgICAgICBodG1sICs9IGAke2xpbmVOdW1iZXIrK306IGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2aW91c1Rva2VuRW5kT2ZMaW5lVG9rZW4gPSBwcmV2aW91c1Rva2VuLmlzRW5kT2ZMaW5lVG9rZW4oKTtcblxuICAgICAgICBpZiAocHJldmlvdXNUb2tlbkVuZE9mTGluZVRva2VuKSB7XG4gICAgICAgICAgaHRtbCArPSBgJHtsaW5lTnVtYmVyKyt9OiBgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gdG9rZW5IVE1MO1xuXG4gICAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG5cbiAgICAgIHJldHVybiBodG1sO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICB0aGlzLmh0bWwoaHRtbCk7XG4gIH1cblxuICBjbGVhclRva2VucygpIHtcbiAgICBjb25zdCBodG1sID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgdGhpcy5odG1sKGh0bWwpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXRUb2tlbnMgPSB0aGlzLnNldFRva2Vucy5iaW5kKHRoaXMpLFxuICAgICAgICAgIGNsZWFyVG9rZW5zID0gdGhpcy5jbGVhclRva2Vucy5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBzZXRUb2tlbnMsXG4gICAgICBjbGVhclRva2Vuc1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJ0b2tlbnNcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50VGV4dGFyZWEgZXh0ZW5kcyBUZXh0YXJlYSB7XG4gIGdldENvbnRlbnQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgY29udGVudCA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb250ZW50OyAgLy8vXG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0Q29udGVudCA9IHRoaXMuZ2V0Q29udGVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldENvbnRlbnQgPSB0aGlzLnNldENvbnRlbnQuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgZ2V0Q29udGVudCxcbiAgICAgIHNldENvbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29udGVudFwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGV4dGFyZWEgZnJvbSBcIi4uL3RleHRhcmVhXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2VUcmVlVGV4dGFyZWEgZXh0ZW5kcyBUZXh0YXJlYSB7XG4gIHNldFBhcnNlVHJlZShwYXJzZVRyZWUpIHtcbiAgICBpZiAocGFyc2VUcmVlICE9PSBudWxsKSB7XG4gICAgICBwYXJzZVRyZWUuc2hpZnRMaW5lKCk7ICAvL1xuXG4gICAgICBjb25zdCBwYXJzZVRyZWVTdHJpbmcgPSBwYXJzZVRyZWUuYXNTdHJpbmcoKSxcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VUcmVlU3RyaW5nOyAgLy8vXG5cbiAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyUGFyc2VUcmVlKCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJQYXJzZVRyZWUoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3Qgc2V0UGFyc2VUcmVlID0gdGhpcy5zZXRQYXJzZVRyZWUuYmluZCh0aGlzKSxcbiAgICAgICAgICBjbGVhclBhcnNlVHJlZSA9IHRoaXMuY2xlYXJQYXJzZVRyZWUuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgc2V0UGFyc2VUcmVlLFxuICAgICAgY2xlYXJQYXJzZVRyZWVcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwidG9rZW5zXCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0YXJlYSBmcm9tIFwiLi4vdGV4dGFyZWFcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV4aWNhbEVudHJpZXNUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgZ2V0TGV4aWNhbEVudHJpZXMoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgbGV4aWNhbEVudHJpZXMgPSBKU09OLnBhcnNlKHZhbHVlKTtcblxuICAgIHJldHVybiBsZXhpY2FsRW50cmllcztcbiAgfVxuXG4gIHNldExleGljYWxFbnRyaWVzKGxleGljYWxFbnRyaWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShsZXhpY2FsRW50cmllcywgbnVsbCwgXCIgIFwiKTtcblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBnZXRMZXhpY2FsRW50cmllcyA9IHRoaXMuZ2V0TGV4aWNhbEVudHJpZXMuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXRMZXhpY2FsRW50cmllcyA9IHRoaXMuc2V0TGV4aWNhbEVudHJpZXMuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgZ2V0TGV4aWNhbEVudHJpZXMsXG4gICAgICBzZXRMZXhpY2FsRW50cmllc1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJsZXhpY2FsLWVudHJpZXNcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCJcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5pbXBvcnQgeyBSb3dzRGl2LCBDb2x1bW5EaXYsIENvbHVtbnNEaXYsIFZlcnRpY2FsU3BsaXR0ZXJEaXYgfSBmcm9tIFwiZWFzeS1sYXlvdXRcIjtcbmltcG9ydCB7IEZ1cnRsZUxleGVyLEZ1cnRsZVBhcnNlciwgbGV4ZXJzVXRpbGl0aWVzLCBwYXJzZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4uL2luZGV4XCI7IC8vL1xuXG5pbXBvcnQgU3ViSGVhZGluZyBmcm9tIFwiLi92aWV3L3N1YkhlYWRpbmdcIjtcbmltcG9ydCBTaXplYWJsZURpdiBmcm9tIFwiLi92aWV3L2Rpdi9zaXplYWJsZVwiO1xuaW1wb3J0IEJORlRleHRhcmVhIGZyb20gXCIuL3ZpZXcvdGV4dGFyZWEvYm5mXCI7XG5pbXBvcnQgUnVsZU5hbWVJbnB1dCBmcm9tIFwiLi92aWV3L2lucHV0L3J1bGVOYW1lXCI7XG5pbXBvcnQgVG9rZW5zVGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS90b2tlbnNcIjtcbmltcG9ydCBDb250ZW50VGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS9jb250ZW50XCI7XG5pbXBvcnQgUGFyc2VUcmVlVGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS9wYXJzZVRyZWVcIjtcbmltcG9ydCBMZXhpY2FsRW50cmllc1RleHRhcmVhIGZyb20gXCIuL3ZpZXcvdGV4dGFyZWEvbGV4aWNhbEVudHJpZXNcIjtcblxuY29uc3QgeyBmdXJ0bGVQYXJzZXJGcm9tQk5GIH0gPSBwYXJzZXJzVXRpbGl0aWVzLFxuICAgICAgeyBmdXJ0bGVMZXhlckZyb21FbnRyaWVzIH0gPSBsZXhlcnNVdGlsaXRpZXM7XG5cbmNvbnN0IHsgYm5mIH0gPSBGdXJ0bGVQYXJzZXIsXG4gICAgICB7IGVudHJpZXMgfSA9IEZ1cnRsZUxleGVyO1xuXG5jbGFzcyBWaWV3IGV4dGVuZHMgRWxlbWVudCB7XG4gIGtleVVwSGFuZGxlciA9IChldmVudCwgZWxlbWVudCkgPT4ge1xuICAgIC8vIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmdldFRva2VucygpLFxuICAgICAgICAgICAgcGFyc2VUcmVlID0gdGhpcy5nZXRQYXJzZVRyZWUodG9rZW5zKTtcblxuICAgICAgdGhpcy5zZXRUb2tlbnModG9rZW5zKTtcblxuICAgICAgdGhpcy5zZXRQYXJzZVRyZWUocGFyc2VUcmVlKTtcbiAgICAvLyB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgIC8vXG4gICAgLy8gICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgLy9cbiAgICAvLyAgIHRoaXMuY2xlYXJQYXJzZVRyZWUoKTtcbiAgICAvLyB9XG4gIH1cblxuICBnZXRUb2tlbnMoKSB7XG4gICAgY29uc3QgbGV4aWNhbEVudHJpZXMgPSB0aGlzLmdldExleGljYWxFbnRyaWVzKCksXG4gICAgICAgICAgZW50cmllcyA9IGxleGljYWxFbnRyaWVzLCAvLy9cbiAgICAgICAgICBmdXJ0bGVMZXhlciA9IGZ1cnRsZUxleGVyRnJvbUVudHJpZXMoZW50cmllcyksXG4gICAgICAgICAgbGV4ZXIgPSBmdXJ0bGVMZXhlciwgIC8vL1xuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICB0b2tlbnMgPSBsZXhlci50b2tlbmlzZShjb250ZW50KTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBnZXRQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgbGV0IHBhcnNlVHJlZSA9IG51bGw7XG5cbiAgICBjb25zdCBibmYgPSB0aGlzLmdldEJORigpLFxuICAgICAgICAgIGZ1cnRsZVBhcnNlciA9IGZ1cnRsZVBhcnNlckZyb21CTkYoYm5mKSxcbiAgICAgICAgICBwYXJzZXIgPSBmdXJ0bGVQYXJzZXIsICAvLy9cbiAgICAgICAgICBydWxlTmFtZSA9IHRoaXMuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTWFwID0gcGFyc2VyLmdldFJ1bGVNYXAoKSxcbiAgICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgICAgbm9kZSA9IHBhcnNlci5wYXJzZSh0b2tlbnMsIHJ1bGUpO1xuXG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHBhcnNlVHJlZSA9IG5vZGUuYXNQYXJzZVRyZWUodG9rZW5zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgY2hpbGRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gKFxuXG4gICAgICA8Q29sdW1uc0Rpdj5cbiAgICAgICAgPFNpemVhYmxlRGl2PlxuICAgICAgICAgIDxSb3dzRGl2PlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIExleGljYWwgZW50cmllc1xuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPExleGljYWxFbnRyaWVzVGV4dGFyZWEgb25LZXlVcD17dGhpcy5rZXlVcEhhbmRsZXJ9IC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgQk5GXG4gICAgICAgICAgICA8L1N1YkhlYWRpbmc+XG4gICAgICAgICAgICA8Qk5GVGV4dGFyZWEgb25LZXlVcD17dGhpcy5rZXlVcEhhbmRsZXJ9IC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgUnVsZSBuYW1lXG4gICAgICAgICAgICA8L1N1YkhlYWRpbmc+XG4gICAgICAgICAgICA8UnVsZU5hbWVJbnB1dCBvbktleVVwPXt0aGlzLmtleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICA8L1Jvd3NEaXY+XG4gICAgICAgIDwvU2l6ZWFibGVEaXY+XG4gICAgICAgIDxWZXJ0aWNhbFNwbGl0dGVyRGl2IC8+XG4gICAgICAgIDxDb2x1bW5EaXY+XG4gICAgICAgICAgPFJvd3NEaXY+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgQ29udGVudFxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPENvbnRlbnRUZXh0YXJlYSBvbktleVVwPXt0aGlzLmtleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBUb2tlbnNcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxUb2tlbnNUZXh0YXJlYSAvPlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIFBhcnNlIHRyZWVcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxQYXJzZVRyZWVUZXh0YXJlYSAvPlxuICAgICAgICAgIDwvUm93c0Rpdj5cbiAgICAgICAgPC9Db2x1bW5EaXY+XG4gICAgICA8L0NvbHVtbnNEaXY+XG5cbiAgICApO1xuICB9XG5cbiAgaW5pdGlhbGlzZSgpIHtcbiAgICB0aGlzLmFzc2lnbkNvbnRleHQoKTtcblxuICAgIGNvbnN0IHsgaW5pdGlhbENvbnRlbnQsIGluaXRpYWxSdWxlTmFtZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBjb250ZW50ID0gaW5pdGlhbENvbnRlbnQsIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lID0gaW5pdGlhbFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgICBsZXhpY2FsRW50cmllcyA9IGVudHJpZXM7IC8vL1xuXG4gICAgdGhpcy5zZXRCTkYoYm5mKTtcblxuICAgIHRoaXMuc2V0Q29udGVudChjb250ZW50KTtcblxuICAgIHRoaXMuc2V0UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgdGhpcy5zZXRMZXhpY2FsRW50cmllcyhsZXhpY2FsRW50cmllcyk7XG5cbiAgICB0aGlzLmtleVVwSGFuZGxlcigpO1xuICB9XG5cbiAgc3RhdGljIGluaXRpYWxSdWxlTmFtZSA9IFwidmFyaWFibGVBc3NpZ25tZW50XCI7XG5cbiAgc3RhdGljIGluaXRpYWxDb250ZW50ID0gYEJvb2xlYW4gdmFyaWFibGVCb3VuZCA9IGlzVmFyaWFibGVCb3VuZCh0ZXJtTm9kZSwgc3RhdGVtZW50Tm9kZSk7YDtcblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJ2aWV3XCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFZpZXcpYFxuXG4gIHBhZGRpbmc6IDFyZW07XG4gXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgXCJqdXh0YXBvc2VcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgQm9keSB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBWaWV3IGZyb20gXCIuL2V4YW1wbGUvdmlld1wiO1xuXG5jb25zdCB7IHJlbmRlclN0eWxlcyB9ID0gd2l0aFN0eWxlO1xuXG5yZW5kZXJTdHlsZXMoKTtcblxuY29uc3QgYm9keSA9IG5ldyBCb2R5KCk7XG5cbmJvZHkubW91bnQoXG5cbiAgPFZpZXcvPlxuXG4pO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7OztBQUFBOzs7OzttQ0FFQSxXQUFBOzs7ZUFBcUI7OztBQUFOLHVCQUFNO01BQ25CLFlBQVksS0FBSyxNQUFNO0FBQ3JCLGFBQUssTUFBTTtBQUNYLGFBQUssT0FBTzs7TUFHZCxTQUFTO0FBQ1AsZUFBTyxLQUFLOztNQUdkLFVBQVU7QUFDUixlQUFPLEtBQUs7O2FBR1AsZUFBZSxZQUFZO0FBQ2hDLGNBQU0sQ0FBRSxXQUFXLGNBQWUsWUFDNUIsTUFBTSxXQUNOLE9BQU8sWUFDUCxTQUFTLElBQUksT0FBTyxLQUFLO0FBRS9CLGVBQU87Ozs7OztBQ3RCWDs7Ozs7bUNBRUEsV0FBQTs7O2VBQXFCOzs7QUFBTix1QkFBTTtNQUNuQixZQUFZLEtBQUssTUFBTSxPQUFPLFFBQVE7QUFDcEMsYUFBSyxNQUFNO0FBQ1gsYUFBSyxPQUFPO0FBQ1osYUFBSyxRQUFRO0FBQ2IsYUFBSyxTQUFTOztNQUdoQixTQUFTO0FBQ1AsZUFBTyxLQUFLOztNQUdkLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsV0FBVztBQUNULGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxjQUFNLFFBQVMsS0FBSyxRQUFRLEtBQUs7QUFFakMsZUFBTzs7TUFHVCxZQUFZO0FBQ1YsY0FBTSxTQUFVLEtBQUssU0FBUyxLQUFLO0FBRW5DLGVBQU87O01BR1QsT0FBTyxLQUFLO0FBQ1YsYUFBSyxNQUFNOztNQUdiLFFBQVEsTUFBTTtBQUNaLGFBQUssT0FBTzs7TUFHZCxTQUFTLE9BQU87QUFDZCxhQUFLLFFBQVE7O01BR2YsVUFBVSxRQUFRO0FBQ2hCLGFBQUssU0FBUzs7TUFHaEIsZUFBZSxRQUFRO0FBQ3JCLGNBQU0sU0FBUyxPQUFPLGFBQ2hCLFFBQVEsT0FBTyxZQUNmLE9BQU8sT0FBTyxXQUNkLE1BQU0sT0FBTyxVQUNiLGNBQWdCLEtBQUssTUFBTSxVQUNYLEtBQUssT0FBTyxTQUNaLEtBQUssUUFBUSxRQUNiLEtBQUssU0FBUztBQUVwQyxlQUFPOztNQUdULDJCQUEyQixLQUFLLE1BQU07QUFDcEMsY0FBTSxjQUFnQixLQUFLLE9BQU8sT0FDWixLQUFLLFFBQVEsUUFDYixLQUFLLFFBQVEsUUFDYixLQUFLLFNBQVM7QUFFcEMsZUFBTzs7YUFHRixlQUFlLFlBQVk7QUFDaEMsY0FBTSxDQUFFLGFBQWEsZUFBZ0IsUUFDL0IscUJBQXFCLFdBQVcseUJBQ2hDLGtCQUFrQixhQUNsQixtQkFBbUIsYUFDbkIsTUFBTSxtQkFBbUIsTUFBTSxpQkFDL0IsT0FBTyxtQkFBbUIsT0FBTyxrQkFDakMsUUFBUSxtQkFBbUIsUUFBUSxrQkFDbkMsU0FBUyxtQkFBbUIsU0FBUyxpQkFDckMsU0FBUyxJQUFJLE9BQU8sS0FBSyxNQUFNLE9BQU87QUFFNUMsZUFBTzs7YUFHRiwwQkFBMEIsS0FBSyxNQUFNLE9BQU8sUUFBUTtBQUN6RCxjQUFNLFNBQVMsTUFBTSxRQUNmLFFBQVEsT0FBTyxPQUNmLFNBQVMsSUFBSSxPQUFPLEtBQUssTUFBTSxPQUFPO0FBRTVDLGVBQU87Ozs7OztBQy9GWDs7Ozs7Ozs7Ozs7OztVQU1nQixVQUFBO2VBQUE7O1VBSkEsUUFBQTtlQUFBOztVQWtCQSxVQUFBO2VBQUE7O1VBUUEsWUFBQTtlQUFBOztVQXhCQSxPQUFBO2VBQUE7OztBQUZULG9CQUFlLE9BQUs7QUFBSSxhQUFPLE1BQU07O0FBRXJDLGtCQUFjLFFBQVEsUUFBTTtBQUFJLFlBQU0sVUFBVSxLQUFLLE1BQU0sUUFBUTs7QUFFbkUscUJBQWlCLFFBQVEsUUFBUSxNQUFJO0FBQzFDLGVBQVM7V0FBSzs7QUFFZCxhQUFPLFFBQVEsQ0FBQyxTQUFTLFVBQUE7QUFDdkIsY0FBTSxTQUFTLEtBQUssU0FBUztBQUU3QixZQUFJLFFBQVE7QUFDVixpQkFBTyxLQUFLOzs7QUFJaEIsYUFBTzs7QUFHRixxQkFBaUIsT0FBSztBQUMzQixhQUFPLE1BQU0sT0FBTyxDQUFDLFFBQU8sWUFBQTtBQUMxQixpQkFBUSxPQUFNLE9BQU87QUFFckIsZUFBTztTQUNOOztBQUdFLHVCQUFtQixnQkFBYztBQUN0Qyx1QkFBaUIsa0JBQWtCO0FBRW5DLGFBQVEsMEJBQTBCLFFBQ3hCLGlCQUNFO1FBQUM7Ozs7OztBQ2pDZjs7Ozs7Ozs7Ozs7OztVQVFhLFFBQUE7ZUFBQTs7VUFMQSxPQUFBO2VBQUE7O1VBVUEsVUFBQTtlQUFBOztVQVBBLFFBQUE7ZUFBQTs7VUFhQSxhQUFBO2VBQUE7O1VBR0EscUJBQUE7ZUFBQTs7VUFSQSxXQUFBO2VBQUE7O1VBRkEsVUFBQTtlQUFBOztVQVFBLGVBQUE7ZUFBQTs7VUFsQkEsTUFBQTtlQUFBOztVQWFBLFdBQUE7ZUFBQTs7VUFOQSxTQUFBO2VBQUE7O1VBUUEsV0FBQTtlQUFBOztVQU1BLHFCQUFBO2VBQUE7O1VBbkJBLE9BQUE7ZUFBQTs7VUFNQSxTQUFBO2VBQUE7O1VBTEEsUUFBQTtlQUFBOztVQU1BLFNBQUE7ZUFBQTs7VUFVQSxvQkFBQTtlQUFBOztVQUhBLFlBQUE7ZUFBQTs7VUFYQSxRQUFBO2VBQUE7O1VBU0EsV0FBQTtlQUFBOzs7QUFkTixRQUFNLE1BQU07QUFDWixRQUFNLE9BQU87QUFDYixRQUFNLE9BQU87QUFDYixRQUFNLFFBQVE7QUFDZCxRQUFNLFFBQVE7QUFDZCxRQUFNLFFBQVE7QUFDZCxRQUFNLFFBQVE7QUFDZCxRQUFNLFNBQVM7QUFDZixRQUFNLFNBQVM7QUFDZixRQUFNLFNBQVM7QUFDZixRQUFNLFVBQVU7QUFDaEIsUUFBTSxVQUFVO0FBQ2hCLFFBQU0sV0FBVztBQUNqQixRQUFNLFdBQVc7QUFDakIsUUFBTSxXQUFXO0FBQ2pCLFFBQU0sV0FBVztBQUNqQixRQUFNLFlBQVk7QUFDbEIsUUFBTSxhQUFhO0FBQ25CLFFBQU0sZUFBZTtBQUNyQixRQUFNLG9CQUFvQjtBQUMxQixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLHFCQUFxQjs7OztBQ3ZCbEM7Ozs7Ozs7Ozs7Ozs7VUFJZ0IsVUFBQTtlQUFBOztVQW9CQSxRQUFBO2VBQUE7Ozs7QUFwQlQscUJBQWlCLFFBQVEsU0FBUyxJQUFFO0FBQ3pDLGVBQVM7V0FDSjs7QUFHTCxZQUFNLFFBQVEsT0FBTyxLQUFLO0FBRTFCLFlBQU0sUUFBUSxDQUFDLFNBQUE7QUFDYixjQUFNLGNBQWMsT0FBTyxPQUNyQixjQUFjLE9BQU8sT0FDckIsdUJBQXVCLE9BQU8sZUFBZTtBQUVuRCxlQUFPLFFBQVEsdUJBQ0UsY0FBYyxhQUFhLGVBQ3pCOztBQUdyQixhQUFPOztBQUdGLG1CQUFlLFFBQVEsUUFBUSxJQUFFO0FBQ3RDLGVBQVM7V0FDSjs7QUFHTCxZQUFNLFFBQVEsQ0FBQyxTQUFBO0FBQ2IsY0FBTSx1QkFBdUIsT0FBTyxlQUFlO0FBRW5ELFlBQUksc0JBQXNCO0FBQ3hCLGlCQUFPLE9BQU87OztBQUlsQixhQUFPOztBQUdULDJCQUF1QixhQUFhLGFBQVc7QUFDN0MsWUFBTSxxQkFBcUIsZUFBZSxjQUNwQyxxQkFBcUIsZUFBZSxjQUNwQyxnQkFBaUIsc0JBQXNCLHFCQUNyQixjQUNFLEdBQUcsZUFBZTtBQUU1QyxhQUFPOztBQUdULDRCQUF3QixPQUFLO0FBQzNCLFlBQU0sZUFBZ0IsT0FBTyxVQUFVLFdBQUE7QUFFdkMsYUFBTzs7Ozs7QUNyRFQ7Ozs7O21DQUVnQix3QkFBQTs7O2VBQUE7OztBQUFULGtDQUE4QixRQUFNO0FBQ3pDLGFBQU8sT0FBTyxRQUFRLGFBQWEsQ0FBQyxPQUFPLGVBQUE7QUFDekMsY0FBTSxzQkFBc0IsV0FBVyxlQUNqQyxzQkFBc0IsSUFBSTtBQUVoQyxlQUFPOzs7Ozs7QUNQWDs7Ozs7Ozs7Ozs7OztVQVVnQixzQkFBQTtlQUFBOztVQUpBLHFCQUFBO2VBQUE7O1VBSkEsZUFBQTtlQUFBOzs7QUFBVCwwQkFBc0IsU0FBTztBQUNsQyxhQUFPLFlBQVksU0FBUzs7QUFHdkIsZ0NBQTRCLGVBQWE7QUFDOUMsYUFBTyxrQkFBa0IsU0FBUzs7QUFHN0IsaUNBQTZCLGVBQWE7QUFDL0MsYUFBTyxtQkFBbUIsU0FBUzs7QUFHckMsUUFBTSxjQUFjO01BQ1o7TUFBWTtNQUFXO01BQWdCO01BQWlCO01BQW9CO01BQWE7TUFDekY7TUFBVTtNQUFZO01BQWlCO01BQ3ZDO01BQVE7TUFBUTtNQUNoQjtNQUNBO01BQVc7TUFBaUI7TUFBdUI7TUFBZTtNQUFvQjtNQUFxQjtNQUFxQjtNQUFrQjtNQUFnQjtNQUFXO01BQVc7TUFBVztNQUFXO01BQVc7TUFBa0I7TUFBVztNQUFXO01BQWU7TUFBZ0I7TUFBWTtNQUFnQjtNQUFzQjtNQUFlO01BQVU7TUFBZ0I7TUFBVTtNQUFRO01BQWE7TUFBb0I7TUFBa0I7TUFBaUI7TUFDamQ7TUFBSztNQUFTO01BQ2Q7TUFBVztNQUFTO01BQWE7TUFDakM7TUFBUztNQUFRO01BQ2pCO01BQ0E7TUFBVTtNQUFRO01BQVE7TUFBZ0I7TUFBYTtNQUFXO01BQVk7TUFBaUI7TUFDL0Y7TUFBUTtNQUFXO01BQVc7TUFBWTtNQUMxQztNQUFrQjtNQUNsQjtNQUFVO01BQU87TUFBYztNQUFRO01BQVM7TUFBTztNQUFVO01BQ2pFO01BQVU7TUFBUTtNQUFZO01BQVk7TUFBUztNQUFRO01BQzNEO01BQVc7TUFDWDtNQUFTO01BQVE7O0FBaEJ6QixRQWtCTSxvQkFBb0I7TUFDbEI7TUFBaUI7TUFBYztNQUFZO01BQXNCO01BQWM7TUFBYTtNQUFlO01BQVU7TUFBaUI7TUFBaUI7TUFDdko7TUFBYTtNQUFpQjtNQUFlO01BQWtCO01BQVE7TUFBUztNQUFRO01BQ3hGO01BQVk7TUFBYztNQUFRO01BQWE7TUFBYTtNQUFhO01BQWlCO01BQVM7TUFBdUI7TUFBK0I7TUFBaUI7TUFBbUI7TUFBcUI7TUFBb0I7TUFBZTtNQUFVO01BQU07TUFDclE7TUFBSztNQUFpQjtNQUFXO01BQW1CO01BQWE7TUFBVztNQUFXO01BQXFCO01BQVk7TUFBTztNQUFNO01BQ3JJO01BQVk7TUFBWTtNQUFhO01BQXFCO01BQU87TUFBUztNQUFZO01BQ3RGO01BQVE7TUFBZ0I7TUFBYTtNQUFVO01BQWE7TUFBZTtNQUFlO01BQWlCO01BQWtCO01BQWE7TUFBZTtNQUFhO01BQW9CO01BQWdCO01BQWM7TUFBZ0I7TUFBZTtNQUFVO01BQU07TUFBUTtNQUFNO01BQ3JSO01BQU07TUFBTTtNQUFjO01BQWdDO01BQThCO01BQVk7TUFBcUI7TUFDekg7TUFBVztNQUFXO01BQXFCO01BQWM7TUFBVTtNQUFlO01BQWtCO01BQWtCO01BQVE7TUFDOUg7TUFBTTtNQUFlO01BQW1CO01BQU07TUFBTztNQUFxQjtNQUMxRTtNQUFLO01BQU07TUFBTTtNQUFNO01BQU07TUFBZ0I7TUFBb0I7TUFBVztNQUFhO01BQWM7TUFDdkc7TUFBZ0I7TUFBa0I7TUFBa0I7TUFBcUI7TUFDekU7TUFBYztNQUFjO01BQWdCO01BQWdCO01BQWU7TUFBZTtNQUFRO01BQW9CO01BQWE7TUFBZ0I7TUFBTztNQUFTO01BQTBCO01BQXlCO01BQWE7TUFBYTtNQUFVO01BQU87TUFDalE7TUFBUTtNQUFZO01BQWlCO01BQWtCO01BQVk7TUFBWTtNQUFZO01BQWE7TUFBVTtNQUFlO01BQWdCO01BQ2pKO01BQVk7TUFBVTtNQUFXO01BQVk7TUFBUztNQUFVO01BQWU7TUFBVTtNQUFZO01BQVc7TUFBcUI7TUFDckk7TUFBWTtNQUFRO01BQWM7TUFBdUI7TUFBb0I7TUFBZ0I7TUFBUztNQUFTO01BQWlCO01BQWlCO01BQWtCO01BQVU7TUFBYTtNQUFhO01BQWE7TUFBaUI7TUFBdUI7TUFBa0I7TUFDOVE7TUFBSztNQUFVO01BQVE7TUFBUTtNQUFvQjtNQUFlO01BQWE7TUFBc0I7TUFBb0I7TUFBaUI7TUFBbUI7TUFBVztNQUFVO01BQVU7TUFBTTtNQUNsTTtNQUFTO01BQVE7TUFBbUI7TUFBUTtNQUFTO01BQWdCO01BQVc7TUFBb0I7TUFBb0I7TUFBZ0I7TUFBTztNQUFlO01BQWdCO01BQVM7TUFBUztNQUFlO01BQWM7TUFBZ0I7TUFBMEI7TUFBMkI7TUFBVTtNQUFVO01BQW9CO01BQXFCO01BQWtCO01BQW1CO01BQXFCO01BQWtCO01BQWdCO01BQVM7TUFBZ0I7TUFBZ0I7TUFBdUI7TUFBYztNQUFpQjtNQUF3QjtNQUNsakI7TUFBZTtNQUFVO01BQVc7TUFBVztNQUFlO01BQW1CO01BQWtCO01BQWM7TUFBaUI7TUFBaUI7TUFBUztNQUFNO01BQWE7TUFBcUI7TUFDcE07TUFBTTtNQUFNO01BQXNCO01BQXVCO01BQVc7TUFBZ0I7TUFBaUI7TUFDckc7TUFBZ0I7TUFBYTtNQUFpQjtNQUFrQjtNQUFVO01BQVc7TUFBYztNQUFpQjtNQUFpQjtNQUFXO01BQWM7TUFDOUo7TUFBUztNQUFVO01BQWdCO01BQ25DO01BQUs7TUFBWTtNQUFNO01BQU07TUFDN0I7TUFBSztNQUFNO01BQU07TUFDakI7TUFBSzs7QUExQ2IsUUE0Q00scUJBQXFCO01BQ25CO01BQVU7TUFBaUI7TUFBYTtNQUFVO01BQVM7TUFBbUI7TUFBcUI7TUFBTztNQUFTO01BQWdCO01BQWE7TUFDaEo7TUFBVztNQUFlO01BQWU7TUFBYTtNQUFXO01BQVc7TUFBUTtNQUFXO01BQWE7TUFBVztNQUFRO01BQVc7TUFBbUI7TUFBZTtNQUFZO01BQVU7TUFDbE07TUFBUTtNQUFZO01BQVc7TUFBUztNQUFPO01BQVk7TUFBWTtNQUN2RTtNQUNBO01BQVE7TUFBYztNQUFlO01BQWM7TUFBa0I7TUFBYztNQUNuRjtNQUFXO01BQVU7TUFBVTtNQUFRO01BQVE7TUFBWTtNQUFXO01BQ3RFO01BQVE7TUFBTTtNQUFhO01BQWE7TUFDeEM7TUFBYTtNQUFXO01BQ3hCO01BQVM7TUFBUTtNQUFRO01BQVE7TUFDakM7TUFBWTtNQUFnQjtNQUFlO01BQU87TUFBYTtNQUFTO01BQWM7TUFBVTtNQUFPO01BQWE7TUFBWTtNQUNoSTtNQUFRO01BQWM7TUFDdEI7TUFBUTtNQUNSO01BQVc7TUFBZTtNQUFVO01BQVc7TUFDL0M7TUFBYztNQUFZO01BQU87TUFBWTtNQUFZO01BQVE7TUFBVztNQUM1RTtNQUFXO01BQVM7TUFBVTtNQUFhO01BQVk7TUFBWTtNQUFTO01BQVE7TUFBUztNQUFRO01BQWM7TUFBTztNQUFVO01BQVc7TUFBVTtNQUFTO01BQVE7TUFBUztNQUNuTDtNQUFZO01BQVU7TUFBUztNQUMvQjtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQy9FUjs7Ozs7Ozs7Ozs7OztVQUVnQixtQkFBQTtlQUFBOztVQWdEaEIsVUFBQTtlQUFBOztVQTFDZ0IsaUJBQUE7ZUFBQTs7VUFnQkEsZUFBQTtlQUFBOztVQWNBLGlCQUFBO2VBQUE7OztBQXBDVCw4QkFBMEIsU0FBUyxZQUFVO0FBQ2xELGNBQVEsYUFBYTtBQUVyQixpQkFBVyxjQUFjOztBQUdwQiw0QkFBd0IsU0FBTztBQUNwQyxZQUFNLHFCQUFxQixRQUFRLHlCQUM3QixXQUFXO1FBQ1Q7V0FDRzs7QUFHWCxlQUFTLFFBQVEsQ0FBQyxhQUFBO0FBQ2hCLGNBQU0sYUFBYSxTQUFRO0FBRTNCLGVBQU8sU0FBUTtBQUVmLGVBQU8sV0FBVzs7O0FBSWYsMEJBQXNCLFNBQU87QUFDbEMsWUFBTSxxQkFBcUIsUUFBUSx5QkFDN0IsV0FBVztRQUNUO1dBQ0c7O0FBR1gsZUFBUztBQUVULGVBQVMsUUFBUSxDQUFDLGFBQUE7QUFDaEIsaUJBQVEsWUFBWSxTQUFROzs7QUFJekIsNEJBQXdCLFNBQU87QUFDcEMsWUFBTSxxQkFBcUIsUUFBUSx5QkFDN0IsV0FBVztRQUNUO1dBQ0c7O0FBR1gsZUFBUyxRQUFRLENBQUMsYUFBQTtBQUNoQixpQkFBUSxlQUFlLFNBQVE7OztRQUluQyxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDdERGOzs7Ozs7Ozs7Ozs7O1VBb0JnQiwrQkFBQTtlQUFBOztVQWdCQSxnQ0FBQTtlQUFBOztVQTBCQSx5QkFBQTtlQUFBOztVQXpEQSwwQkFBQTtlQUFBOztVQTZFQSxpQkFBQTtlQUFBOztVQTlCQSwyQkFBQTtlQUFBOzs7OztBQS9DVCxxQ0FBaUMsYUFBVztBQUNqRCxZQUFNLDBCQUEwQixlQUFlLGFBQWEsQ0FBQyxlQUFBO0FBQ3JELFlBQUssV0FBVyxhQUFjO0FBQzVCLGlCQUFPOztVQUdYLFdBQVcsd0JBQXdCLElBQUksQ0FBQyxlQUFBO0FBQ3RDLGNBQU0sVUFBVSxXQUFXO0FBRTNCLGVBQU87O0FBR2YsYUFBTzs7QUFHRiwwQ0FBc0MsU0FBUyxRQUFRLG9CQUFvQixJQUFFO0FBQ2xGLFVBQUksU0FBUyxHQUFHO0FBQ2QsY0FBTSxnQkFBZ0IsUUFBUTtBQUU5QixZQUFJLGtCQUFrQixNQUFNO0FBQzFCLDRCQUFrQixLQUFLO0FBRXZCO0FBRUEsdUNBQTZCLGVBQWUsUUFBUTs7O0FBSXhELGFBQU87O0FBR0YsMkNBQXVDLFNBQVMsT0FBTyxxQkFBcUIsSUFBRTtBQUNuRixVQUFJLFFBQVEsR0FBRztBQUNiLGNBQU0sZ0JBQWdCLFFBQVE7QUFFOUIsUUFBQSxJQUFBLE9BQUEsTUFBSyxvQkFBb0I7QUFFekI7QUFFQSxzQkFBYyxRQUFRLENBQUMsaUJBQUE7QUFDckIsd0NBQThCLGNBQWMsT0FBTzs7O0FBSXZELGFBQU87O0FBR0Ysc0NBQWtDLFVBQVUsVUFBUTtBQUN6RCxZQUFNLG1CQUFtQixlQUFlLFVBQVUsQ0FBQyxZQUFBO0FBQ2pELFlBQUksdUJBQXVCLFNBQVMsV0FBVztBQUM3QyxpQkFBTzs7O0FBSVgsYUFBTzs7QUFHRixvQ0FBZ0MsU0FBUyxVQUFRO0FBQ3RELFlBQU0sY0FBYyxRQUFRO0FBRTVCLGNBQVE7YUFDRCxLQUFLLGNBQWM7QUFDdEIsZ0JBQU0sYUFBYTtBQUVuQixpQkFBTyxXQUFXLFFBQVE7O2FBR3ZCLEtBQUssV0FBVztBQUNuQixjQUFJLGFBQWEsV0FBQSxVQUFVO0FBQ3pCLG1CQUFPOzs7O0FBS2IsYUFBTzs7QUFHRiw0QkFBd0IsVUFBVSxNQUFJO0FBQzNDLFlBQU0sbUJBQW1CLElBQ25CLGlCQUFpQixTQUFTO0FBRWhDLGVBQVMsUUFBUSxHQUFHLFFBQVEsZ0JBQWdCLFNBQVM7QUFDbkQsY0FBTSxVQUFVLFNBQVMsUUFDbkIsU0FBUyxLQUFLO0FBRXBCLFlBQUksUUFBUTtBQUNWLDJCQUFpQixLQUFLOzs7QUFJMUIsYUFBTzs7Ozs7QUMvRlQ7Ozs7Ozs7Ozs7Ozs7VUF1RkEsVUFBQTtlQUFBOztVQXJEZ0IsdUJBQUE7ZUFBQTs7VUFSQSxtQkFBQTtlQUFBOztVQWtCQSx3QkFBQTtlQUFBOztVQVVBLHdCQUFBO2VBQUE7O1VBaERBLG1CQUFBO2VBQUE7O1VBNERBLDRCQUFBO2VBQUE7Ozs7OztBQTVEVCw4QkFBMEIsV0FBVyxXQUFBLFVBQVE7QUFDbEQsVUFBSSxnQkFBZ0I7QUFFcEIsWUFBTSxtQkFBbUIsS0FBSyxXQUFXO0FBRXpDLFVBQUkscUJBQXFCLE1BQU07QUFDN0IsWUFBSSxpQkFBaUIsUUFBUSxXQUFXO0FBQ3RDLGdCQUFNLG9CQUFvQjtZQUNsQjthQUVGLGlCQUFpQixJQUFBLEtBQUEseUJBQXdCLG9CQUN6QyxxQkFBcUIsSUFBQSxPQUFBLE9BQU07QUFFakMsMEJBQWdCLHNCQUFzQjs7O0FBSTFDLGFBQU87O0FBR0YsOEJBQTBCLFdBQVcsV0FBQSxVQUFRO0FBQ2xELFlBQU0sZ0JBQWdCLEtBQUssV0FBVyxZQUNoQyxtQkFBbUIsSUFBQSxLQUFBLDBCQUF5QixlQUFlLFdBQzNELGdCQUFnQixJQUFBLEtBQUEseUJBQXdCO0FBRTlDLGFBQU87O0FBR0Ysa0NBQThCLFdBQVcsV0FBQSxVQUFVLGdCQUFnQixVQUFRO0FBQ2hGLFlBQU0sU0FBUyxlQUNULFVBQVUsS0FBSyxZQUNmLG9CQUFvQixJQUFBLEtBQUEsOEJBQTZCLFNBQVMsU0FDMUQsdUJBQXVCLElBQUEsS0FBQSwwQkFBeUIsbUJBQW1CLFdBQ25FLG9CQUFvQixJQUFBLEtBQUEseUJBQXdCO0FBRWxELGFBQU87O0FBR0YsbUNBQStCLFdBQVcsV0FBQSxVQUFVLGVBQWUsVUFBUTtBQUNoRixZQUFNLFFBQVEsY0FDUixVQUFVLEtBQUssWUFDZixxQkFBcUIsSUFBQSxLQUFBLCtCQUE4QixTQUFTLFFBQzVELHdCQUF3QixJQUFBLEtBQUEsMEJBQXlCLG9CQUFvQixXQUNyRSxxQkFBcUIsSUFBQSxLQUFBLHlCQUF3QjtBQUVuRCxhQUFPOztBQUdGLG1DQUErQixXQUFXLFdBQUEsVUFBUTtBQUN2RCxVQUFJLHFCQUFxQjtBQUV6QixZQUFNLHFCQUFxQixLQUFLLFdBQVc7QUFFM0MsVUFBSyx1QkFBdUIsUUFBUyxJQUFBLEtBQUEsd0JBQXVCLG9CQUFvQixXQUFXO0FBQ3pGLDZCQUFxQixtQkFBbUIsZUFBZTs7QUFHekQsYUFBTzs7QUFHRix1Q0FBbUMsV0FBVyxXQUFBLFVBQVE7QUFDM0QsVUFBSSx5QkFBeUI7QUFFN0IsWUFBTSx5QkFBeUIsS0FBSyxXQUFXO0FBRS9DLFVBQUssMkJBQTJCLFFBQVMsSUFBQSxLQUFBLHdCQUF1Qix3QkFBd0IsV0FBVztBQUNqRyxpQ0FBeUIsdUJBQXVCLGVBQWU7O0FBR2pFLGFBQU87O0FBR1QsUUFBTSxnQkFBZ0I7TUFDcEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztRQUdGLFdBQWU7Ozs7QUN2RmY7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBQU4sNEJBQU07TUFDbkIsWUFBWSxNQUFNO0FBQ2hCLGNBQU0sVUFBVSxNQUNWLGFBQWEsU0FBUyxlQUFlO0FBRTNDLFFBQUEsSUFBQSxTQUFBLGtCQUFpQixTQUFTOztNQUc1QixnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsWUFBWTtBQUNWLGNBQU0sU0FBUyxRQUFBLFFBQU8sZUFBZSxLQUFLO0FBRTFDLGVBQU87O01BR1QsWUFBWTtBQUNWLGNBQU0sU0FBUyxRQUFBLFFBQU8sZUFBZSxLQUFLO0FBRTFDLGVBQU87O01BR1QsV0FBVztBQUFFLGVBQU8sS0FBSyxXQUFXOztNQUVwQyxZQUFZO0FBQUUsZUFBTyxLQUFLLFdBQVc7O01BRXJDLFVBQVU7QUFDUixjQUFNLFlBQVksS0FBSyxXQUFXLFdBQzVCLE9BQU87QUFFYixlQUFPOztNQUdULFFBQVEsTUFBTTtBQUNaLGNBQU0sWUFBWTtBQUVsQixhQUFLLFdBQVcsWUFBWTs7TUFHOUIsVUFBVSxlQUFlO0FBQUUsc0JBQWMsUUFBUTs7TUFFakQsU0FBUyxlQUFlO0FBQUUsc0JBQWMsT0FBTzs7TUFFL0MsTUFBTSxlQUFlO0FBQUUsc0JBQWMsSUFBSTs7TUFFekMsV0FBVyxlQUFlO0FBQUUsc0JBQWMsT0FBTzs7TUFFakQsYUFBYSxnQkFBZ0I7QUFDM0IsY0FBTSxnQkFBZ0IsZUFBZSxXQUFXLFlBQzFDLG9CQUFvQixlQUFlO0FBRXpDLHNCQUFjLGFBQWEsS0FBSyxZQUFZOztNQUc5QyxZQUFZLGdCQUFnQjtBQUMxQixjQUFNLGdCQUFnQixlQUFlLFdBQVcsWUFDMUMsb0JBQW9CLGVBQWU7QUFFekMsc0JBQWMsYUFBYSxLQUFLLFlBQVksa0JBQWtCOztNQUdoRSxTQUFTO0FBQ1AsYUFBSyxXQUFXOztNQUdsQixVQUFVO0FBQ1IsY0FBTSxVQUFVO0FBRWhCLFFBQUEsSUFBQSxTQUFBLGdCQUFlOzs7QUFJbkIsV0FBTyxPQUFPLFlBQVksV0FBVztNQUNuQyxrQkFBQSxVQUFBO01BQ0Esc0JBQUEsVUFBQTtNQUNBLHVCQUFBLFVBQUE7TUFDQSwyQkFBQSxVQUFBOzs7OztBQ3RGRjs7Ozs7Ozs7Ozs7OztVQU1nQix1QkFBQTtlQUFBOztVQVlBLGlDQUFBO2VBQUE7Ozs7Ozs7Ozs7QUFaVCxrQ0FBOEIsVUFBUTtBQUMzQyxpQkFBVyxTQUFTLE9BQU8sQ0FBQyxXQUFVLFlBQUE7QUFDcEMsWUFBSSxTQUFTO0FBQ1gsb0JBQVMsS0FBSzs7QUFHaEIsZUFBTztTQUNOO0FBRUgsYUFBTzs7QUFHRiw0Q0FBd0MsVUFBUTtBQUNyRCxpQkFBVyxTQUFTLElBQUksQ0FBQyxZQUFBO0FBQ3ZCLFlBQUksT0FBTyxZQUFZLFdBQUEsUUFBUTtBQUM3QixnQkFBTSxPQUFPLFNBQ1AsY0FBYyxJQUFJLGFBQUEsUUFBWTtBQUVwQyxvQkFBVTs7QUFHWixlQUFPOztBQUdULGFBQU87Ozs7O0FDOUJUOzs7Ozs7Ozs7Ozs7O1VBa0JhLHNCQUFBO2VBQUE7O1VBZEEsa0JBQUE7ZUFBQTs7VUFTQSxvQkFBQTtlQUFBOztVQUhBLG1CQUFBO2VBQUE7O1VBaUJBLHlCQUFBO2VBQUE7O1VBeEJBLGtCQUFBO2VBQUE7O1VBREEsaUJBQUE7ZUFBQTs7VUFrQkEsc0JBQUE7ZUFBQTs7VUFmQSxtQkFBQTtlQUFBOztVQUlBLG1CQUFBO2VBQUE7O1VBb0JBLDhCQUFBO2VBQUE7O1VBckJBLG1CQUFBO2VBQUE7O1VBUUEscUJBQUE7ZUFBQTs7VUFMQSxtQkFBQTtlQUFBOztVQWFBLHVCQUFBO2VBQUE7O1VBQ0EsdUJBQUE7ZUFBQTs7VUFOQSxzQkFBQTtlQUFBOztVQUlBLHVCQUFBO2VBQUE7O1VBTkEscUJBQUE7ZUFBQTs7VUFYQSxtQkFBQTtlQUFBOztVQVFBLG9CQUFBO2VBQUE7O1VBQ0Esb0JBQUE7ZUFBQTs7VUFhQSw2QkFBQTtlQUFBOztVQWhCQSxvQkFBQTtlQUFBOztVQVNBLHNCQUFBO2VBQUE7O1VBQ0EsdUJBQUE7ZUFBQTs7VUFJQSx3QkFBQTtlQUFBOztVQUlBLGdDQUFBO2VBQUE7O1VBdkJBLG1CQUFBO2VBQUE7O1VBeUJiLFVBQUE7ZUFBQTs7O0FBOUJPLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0seUJBQXlCO0FBQy9CLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sOEJBQThCO0FBQ3BDLFFBQU0sZ0NBQWdDO1FBRTdDLFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQzdERjs7Ozs7bUNBeUZBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7O0FBL0VBLFFBQU0sMEJBQTBCO0FBQWhDLFFBQ00sOEJBQThCO0FBRHBDLFFBRU0sZ0NBQWdDO0FBRXRDLDZCQUF5QixZQUFZLG1CQUFtQixtQkFBaUI7QUFDdkUsV0FBSyxhQUFhLElBQUEsUUFBQSxTQUFRLFlBQVk7QUFFdEMsbUJBQWEsSUFBQSxRQUFBLE9BQU0sS0FBSyxZQUFZO0FBRXBDLFlBQU0sZUFBZSxLQUFLLFdBQVcsY0FDL0IsTUFBTyxpQkFBaUIsV0FBQSxtQkFDeEIsaUJBQWlCLE9BQU8sS0FBSyxhQUM3QixRQUFRO0FBRWQsWUFBTSxRQUFRLENBQUMsU0FBQTtBQUNiLGNBQU0sUUFBUSxXQUFXLE9BQ25CLGtCQUFrQixrQkFBa0IsT0FDcEMsd0JBQXdCLHdCQUF3QjtBQUV0RCxZQUFJLE9BQU87bUJBRUEsaUJBQWlCO0FBQzFCLHFCQUFXLE1BQU0sTUFBTTttQkFDZCx1QkFBdUI7QUFDaEMsMkJBQWlCLE1BQU0sTUFBTTtlQUN4QjtBQUNMLGdCQUFNLG9CQUFvQixvQkFBb0IsTUFBTTtBQUVwRCxjQUFJLG1CQUFtQjtBQUNyQix5QkFBYSxNQUFNLE1BQU07Ozs7QUFLL0IsWUFBTSxnQkFBZ0IseUJBQXlCLFNBQVMsV0FBVyxlQUM3RCxXQUFVO0FBRWhCLG9CQUFjLFFBQVEsQ0FBQyxpQkFBQTtBQUNyQixzQkFBYyxjQUFjO0FBRTVCLGFBQUssSUFBSTs7QUFHWCxXQUFLLFVBQVU7O0FBR2pCLDZCQUFTO0FBQ1AsYUFBTyxLQUFLOztBQUdkLDBCQUFTO0FBQ1AsYUFBTyxLQUFLOztBQUdkLDJCQUF1QixPQUFLO0FBQzFCLFVBQUksVUFBVSxRQUFXO0FBQ3ZCLGdCQUFRLE9BQU8sS0FBSyxLQUFLOztBQUczQixZQUFNLFFBQVEsQ0FBQyxTQUFBO0FBQ2IsY0FBTSxRQUFRLEtBQUssUUFBUSxPQUNyQixlQUFlLE1BQ2YsYUFBYTtVQUNYOztBQUdSLGVBQU8sZUFBZSxNQUFNLGNBQWM7QUFFMUMsZUFBTyxLQUFLLFFBQVE7OztBQUl4QixRQUFNLFlBQVk7TUFDaEI7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTtBQUVmLHNDQUFrQyxTQUFPO0FBQ3ZDLFVBQUksZ0JBQWdCO0FBRXBCLFVBQUksT0FBTyxRQUFRLGtCQUFrQixXQUFBLFVBQVU7QUFDN0Msd0JBQWdCLFFBQVEsY0FBYyxLQUFLO0FBRTNDLHdCQUFnQixJQUFBLE9BQUEsV0FBVTtBQUUxQix3QkFBZ0IsSUFBQSxVQUFBLHNCQUFxQjtBQUVyQyx3QkFBZ0IsSUFBQSxVQUFBLGdDQUErQjs7QUFHakQsYUFBTzs7QUFHVCwyQkFBdUIsY0FBYyxVQUFPO0FBQzFDLFlBQU0sZ0JBQWlCLE9BQU8sYUFBYSxrQkFBa0IsV0FBQSxXQUNyQyxhQUFhLGtCQUNYLGFBQWE7QUFFdkMsYUFBTyxPQUFPLFVBQVM7O0FBR3pCLHdCQUFvQixTQUFTLE1BQU0sT0FBSztBQUN0QyxVQUFJLFlBQVksS0FBSyxVQUFVLEdBQUc7QUFFbEMsY0FBUTthQUNELHlCQUF5QjtBQUM1QixzQkFBWSxZQUFBO0FBRVo7O2FBR0csNkJBQTZCO0FBQ2hDLHNCQUFZLFlBQUE7QUFFWjs7YUFHRywrQkFBK0I7QUFDbEMsc0JBQVksWUFBQTtBQUVaOzs7QUFLSixZQUFNLFVBQVU7QUFFaEIsY0FBUSxRQUFRLFdBQVc7O0FBRzdCLDhCQUEwQixTQUFTLE1BQU0sT0FBSztBQUM1QyxZQUFNLGtCQUFrQixJQUFBLFFBQUEsc0JBQXFCLE1BQU0sUUFBUSxjQUFjLEtBQ25FLGdCQUFnQjtBQUV0QixjQUFRLGNBQWMsaUJBQWlCOztBQUd6QywwQkFBc0IsU0FBUyxNQUFNLE9BQUs7QUFDeEMsVUFBSSxTQUFTLFdBQUEsWUFBWTtBQUN2QixlQUFPLFdBQUE7O0FBR1QsVUFBSSxTQUFTLFdBQUEsVUFBVTtBQUNyQixlQUFPLFdBQUE7O0FBR1QsVUFBSSxPQUFPLFVBQVUsV0FBQSxRQUFRO0FBQzNCLGNBQU0sT0FBTyxPQUFPLEtBQUs7QUFFekIsYUFBSyxRQUFRLENBQUMsUUFBQTtBQUNaLGtCQUFRLFdBQVcsTUFBTSxPQUFPLE1BQU07O2lCQUUvQixPQUFPLFVBQVUsV0FBQSxTQUFTO0FBQ25DLFlBQUksT0FBTztBQUNULGtCQUFRO0FBRVIsa0JBQVEsYUFBYSxNQUFNOzthQUV4QjtBQUNMLGdCQUFRLGFBQWEsTUFBTTs7O0FBSS9CLCtCQUEyQixNQUFJO0FBQzdCLFlBQU0sa0JBQW1CLGdCQUFnQixLQUFLO0FBRTlDLGFBQU87O0FBR1QsaUNBQTZCLE1BQU0sS0FBRztBQUNwQyxZQUFNLG9CQUFvQixNQUNDLElBQUEsTUFBQSxvQkFBbUIsUUFDakIsSUFBQSxNQUFBLHFCQUFvQjtBQUVqRCxhQUFPOztBQUdULHFDQUFpQyxNQUFJO0FBQ25DLFlBQU0sd0JBQXdCLFlBQVksS0FBSztBQUUvQyxhQUFPOzs7OztBQ2xNVDs7Ozs7bUNBbUJBLFdBQUE7OztlQUFBOzs7O0FBZkEscUJBQWlCLGNBQWMsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLGtCQUFrQixjQUFjOztBQUV2RixzQkFBa0IsY0FBYyxTQUFPO0FBQUksV0FBSyxTQUFTLFlBQUEsa0JBQWtCLGNBQWM7O0FBRXpGLHVCQUFtQixnQkFBZ0IsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLG9CQUFvQixnQkFBZ0I7O0FBRS9GLHdCQUFvQixnQkFBZ0IsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLG9CQUFvQixnQkFBZ0I7O0FBRWpHLFFBQU0sWUFBWTtNQUNoQjtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDbkJmOzs7OzttQ0FzQkEsV0FBQTs7O2VBQUE7OztBQXBCQSx3QkFBUztBQUNQLGFBQU8sS0FBSzs7QUFHZCxzQkFBa0IsT0FBSztBQUNyQixXQUFLLFFBQVE7O0FBR2YseUJBQXFCLE9BQUs7QUFDdkIsV0FBSyxVQUFVLFNBQ2QsS0FBSyxRQUFRLFFBQ1gsT0FBTyxPQUFPLEtBQUssT0FBTzs7QUFHaEMsUUFBTSxjQUFjO01BQ2xCO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDdEJmOzs7OzttQ0E4SUEsV0FBQTs7O2VBQUE7Ozs7O0FBeklBLHFCQUFpQixZQUFZLFNBQVMsVUFBVSxNQUFJO0FBQ2xELG1CQUFhLFdBQVcsTUFBTSxXQUFBO0FBRTlCLGlCQUFXLFFBQVEsQ0FBQyxjQUFBO0FBQ2xCLFlBQUksY0FBYyxZQUFBLG1CQUFtQjtBQUNuQyxnQkFBTSx1QkFBdUIsS0FBSyxtQkFBbUIsWUFBQSxvQkFDL0MsNkJBQTZCLHFCQUFxQjtBQUV4RCxjQUFJLCtCQUErQixHQUFHO0FBQ3BDLGlCQUFLLGlCQUFpQixJQUFJLGVBQWUsQ0FBQyxZQUFBO0FBQ3hDLG9CQUFNLHdCQUF1QixLQUFLLG1CQUFtQixZQUFBO0FBRXJELG9DQUFxQixRQUFRLENBQUMsd0JBQUE7QUFDNUIsc0JBQU0sUUFBUTtBQUVkLG9DQUFvQjs7O0FBSXhCLGlCQUFLLGVBQWUsUUFBUSxLQUFLOztBQUduQyxlQUFLLGlCQUFpQixXQUFXLFNBQVM7ZUFDckM7QUFDTCxnQkFBTSxnQkFBZ0IsS0FBSyxpQkFBaUIsV0FBVyxTQUFTO0FBRWhFLGVBQUssV0FBVyxpQkFBaUIsV0FBVzs7OztBQUtsRCxzQkFBa0IsWUFBWSxTQUFTLFVBQVUsTUFBSTtBQUNuRCxtQkFBYSxXQUFXLE1BQU0sV0FBQTtBQUU5QixpQkFBVyxRQUFRLENBQUMsY0FBQTtBQUNsQixZQUFJLGNBQWMsWUFBQSxtQkFBbUI7QUFDbkMsZUFBSyxvQkFBb0IsV0FBVyxTQUFTO0FBRTdDLGdCQUFNLHVCQUF1QixLQUFLLG1CQUFtQixZQUFBLG9CQUMvQyw2QkFBNkIscUJBQXFCO0FBRXhELGNBQUksK0JBQStCLEdBQUc7QUFDcEMsaUJBQUssZUFBZSxVQUFVLEtBQUs7QUFFbkMsbUJBQU8sS0FBSzs7ZUFFVDtBQUNMLGdCQUFNLGdCQUFnQixLQUFLLG9CQUFvQixXQUFXLFNBQVM7QUFFbkUsZUFBSyxXQUFXLG9CQUFvQixXQUFXOzs7O0FBS3JELDhCQUEwQixXQUFXLFNBQVMsU0FBTztBQUNuRCxZQUFNLGdCQUFnQixLQUFLLG9CQUFvQixXQUFXLFNBQVM7QUFFbkUsVUFBSSxDQUFDLEtBQUssZ0JBQWdCO0FBQ3hCLGFBQUssaUJBQWlCOztBQUd4QixXQUFLLGVBQWUsS0FBSztBQUV6QixhQUFPOztBQUdULGlDQUE2QixXQUFXLFNBQVMsU0FBTztBQUN0RCxZQUFNLGdCQUFnQixLQUFLLGtCQUFrQixXQUFXLFNBQVMsVUFDM0QsUUFBUSxLQUFLLGVBQWUsUUFBUSxnQkFDcEMsUUFBUSxPQUNSLGNBQWM7QUFFcEIsV0FBSyxlQUFlLE9BQU8sT0FBTztBQUVsQyxVQUFJLEtBQUssZUFBZSxXQUFXLEdBQUc7QUFDcEMsZUFBTyxLQUFLOztBQUdkLGFBQU87O0FBR1QsK0JBQTJCLFdBQVcsU0FBUyxTQUFPO0FBQ3BELFlBQU0sZ0JBQWdCLEtBQUssZUFBZSxLQUFLLENBQUMsbUJBQUE7QUFDOUMsWUFBSyxlQUFjLFlBQVksV0FBYSxlQUFjLFlBQVksV0FBYSxlQUFjLGNBQWMsV0FBWTtBQUN6SCxpQkFBTzs7O0FBSVgsYUFBTzs7QUFHVCxnQ0FBNEIsV0FBUztBQUNuQyxZQUFNLGlCQUFpQjtBQUV2QixVQUFJLEtBQUssZ0JBQWdCO0FBQ3ZCLGFBQUssZUFBZSxRQUFRLENBQUMsa0JBQUE7QUFDM0IsZ0JBQU0sUUFBUyxjQUFjLGNBQWM7QUFFM0MsY0FBSSxPQUFPO0FBQ1QsMkJBQWUsS0FBSzs7OztBQUsxQixhQUFPOztBQUdULGlDQUE2QixXQUFXLFNBQVMsU0FBTztBQUN0RCxVQUFJO0FBRUosWUFBTSxpQkFBaUI7QUFFdkIsc0JBQWdCLENBQUMsVUFBQTtBQUNmLGNBQU0sV0FBVTtBQUVoQixnQkFBUSxLQUFLLGdCQUFnQixPQUFPOztBQUd0QyxhQUFPLE9BQU8sZUFBZTtRQUMzQjtRQUNBO1FBQ0E7O0FBR0YsYUFBTzs7QUFHVCxRQUFNLGNBQWM7TUFDbEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQzlJZjs7Ozs7bUNBcUNBLFdBQUE7OztlQUFBOzs7O0FBakNBLHVCQUFtQixnQkFBZ0IsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLG9CQUFvQixnQkFBZ0I7O0FBRS9GLHdCQUFvQixnQkFBZ0IsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLG9CQUFvQixnQkFBZ0I7O0FBRWpHLHdCQUFvQixpQkFBaUIsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLHFCQUFxQixpQkFBaUI7O0FBRW5HLHlCQUFxQixpQkFBaUIsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLHFCQUFxQixpQkFBaUI7O0FBRXJHLHlCQUFxQixrQkFBa0IsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLHNCQUFzQixrQkFBa0I7O0FBRXZHLDBCQUFzQixrQkFBa0IsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLHNCQUFzQixrQkFBa0I7O0FBRXpHLHlCQUFxQixrQkFBa0IsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLHNCQUFzQixrQkFBa0I7O0FBRXZHLDBCQUFzQixrQkFBa0IsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLHNCQUFzQixrQkFBa0I7O0FBRXpHLHlCQUFxQixrQkFBa0IsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLHNCQUFzQixrQkFBa0I7O0FBRXZHLDBCQUFzQixrQkFBa0IsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLHNCQUFzQixrQkFBa0I7O0FBRXpHLFFBQU0sY0FBYztNQUNsQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDckNmOzs7OzttQ0F5QkEsV0FBQTs7O2VBQUE7Ozs7QUFyQkEscUJBQWlCLGNBQWMsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLGtCQUFrQixjQUFjOztBQUV2RixzQkFBa0IsY0FBYyxTQUFPO0FBQUksV0FBSyxTQUFTLFlBQUEsa0JBQWtCLGNBQWM7O0FBRXpGLHdCQUFvQixpQkFBaUIsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLHFCQUFxQixpQkFBaUI7O0FBRW5HLHlCQUFxQixpQkFBaUIsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLHFCQUFxQixpQkFBaUI7O0FBRXJHLDJCQUF1QixvQkFBb0IsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLHFCQUFxQixvQkFBb0I7O0FBRTVHLDRCQUF3QixvQkFBb0IsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLHFCQUFxQixvQkFBb0I7O0FBRTlHLFFBQU0sY0FBYztNQUNsQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ3pCZjs7Ozs7bUNBeUJBLFdBQUE7OztlQUFBOzs7O0FBckJBLDBCQUFzQixtQkFBaUI7QUFBSSxXQUFLLFFBQVEsWUFBQSx1QkFBdUI7O0FBRS9FLDJCQUF1QixtQkFBaUI7QUFBSSxXQUFLLFNBQVMsWUFBQSx1QkFBdUI7O0FBRWpGLHlCQUFxQixtQkFBaUI7QUFBSSxXQUFLLFFBQVEsWUFBQSxzQkFBc0I7O0FBRTdFLDBCQUFzQixtQkFBaUI7QUFBSSxXQUFLLFNBQVMsWUFBQSxzQkFBc0I7O0FBRS9FLHdCQUFvQixtQkFBaUI7QUFBSSxXQUFLLFFBQVEsWUFBQSxxQkFBcUI7O0FBRTNFLHlCQUFxQixtQkFBaUI7QUFBSSxXQUFLLFNBQVMsWUFBQSxxQkFBcUI7O0FBRTdFLFFBQU0sY0FBYztNQUNsQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ3pCZjs7Ozs7Ozs7Ozs7OztVQWtDQSxVQUFBO2VBQUE7O1VBNUJnQixZQUFBO2VBQUE7O1VBRkEsV0FBQTtlQUFBOzs7O0FBQVQsc0JBQWtCLGVBQWUsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLG1CQUFtQixlQUFlOztBQUUzRix1QkFBbUIsZUFBZSxTQUFPO0FBQUksV0FBSyxTQUFTLFlBQUEsbUJBQW1CLGVBQWU7O0FBRXBHLHNCQUFrQixXQUFXLFlBQVU7QUFBSSxXQUFLLFdBQVcsU0FBUyxZQUFZOztBQUVoRiw0QkFBUztBQUFpQixhQUFPLEtBQUssV0FBVzs7QUFFakQsNkJBQVM7QUFBa0IsYUFBTyxLQUFLLFdBQVc7O0FBRWxELDhCQUFTO0FBQW1CLGFBQU8sS0FBSyxXQUFXOztBQUVuRCwrQkFBUztBQUFvQixhQUFPLEtBQUssV0FBVzs7QUFFcEQsMEJBQXNCLFdBQVM7QUFBSSxXQUFLLFdBQVcsWUFBWTs7QUFFL0QsMkJBQXVCLFlBQVU7QUFBSSxXQUFLLFdBQVcsYUFBYTs7QUFFbEUsUUFBTSxlQUFlO01BQ25CO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDbENmOzs7OzttQ0FhQSxXQUFBOzs7ZUFBQTs7OztBQVRBLHNCQUFrQixlQUFlLFNBQU87QUFBSSxXQUFLLFFBQVEsWUFBQSxtQkFBbUIsZUFBZTs7QUFFM0YsdUJBQW1CLGVBQWUsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLG1CQUFtQixlQUFlOztBQUU3RixRQUFNLGVBQWU7TUFDbkI7TUFDQTs7UUFHRixXQUFlOzs7O0FDYmY7Ozs7O21DQWtDQSxXQUFBOzs7ZUFBQTs7OztBQTlCQSxnQ0FBNEIseUJBQXlCLFNBQU87QUFBSSxXQUFLLFFBQVEsWUFBQSw2QkFBNkIseUJBQXlCOztBQUVuSSxpQ0FBNkIseUJBQXlCLFNBQU87QUFBSSxXQUFLLFNBQVMsWUFBQSw2QkFBNkIseUJBQXlCOztBQUVySSwrQkFBMkIsY0FBWTtBQUNyQyxZQUFNLGFBQWEsS0FBSztBQUV4QixpQkFBVyxvQkFDUixNQUFNOztBQUdYLDhCQUFTO0FBQ1AsZUFBUzs7QUFHWCw0QkFBUztBQUNQLFlBQU0sQ0FBRSxxQkFBc0IsVUFDeEIsYUFBYyxzQkFBc0I7QUFFMUMsYUFBTzs7QUFHVCxRQUFNLG1CQUFtQjtNQUN2QjtNQUNBO01BQ0E7TUFDQTtNQUNBOztRQUdGLFdBQWU7Ozs7QUNsQ2Y7Ozs7O21DQUVnQixXQUFBOzs7ZUFBQTs7O0FBQVQscUJBQWlCLE9BQU8sV0FBVyxNQUFNLFVBQU87QUFDckQsWUFBTSxTQUFTLE1BQU07QUFFckIsVUFBSSxRQUFRO0FBRVosc0JBQVM7QUFDUDtBQUVBLGNBQU0sWUFBYSxVQUFVO0FBRTdCLFlBQUksV0FBVztBQUNiO2VBQ0s7QUFDTCxnQkFBTSxRQUFRLE9BQ1IsVUFBVSxNQUFNO0FBRXRCLG9CQUFVLFNBQVMsTUFBTSxNQUFNLFVBQVM7OztBQUk1Qzs7Ozs7QUN0QkY7Ozs7O21DQTBIQSxXQUFBOzs7ZUFBQTs7Ozs7QUFySEEsMkJBQXVCLGtCQUFrQixlQUFlLFVBQVUsTUFBSTtBQUNwRSx5QkFBbUIsaUJBQWlCLE1BQU0sV0FBQTtBQUUxQyx1QkFBaUIsUUFBUSxDQUFDLG9CQUFBO0FBQ3hCLGFBQUssdUJBQXVCLGlCQUFpQixlQUFlOzs7QUFJaEUsNEJBQXdCLGtCQUFrQixlQUFlLFVBQVUsTUFBSTtBQUNyRSx5QkFBbUIsaUJBQWlCLE1BQU0sV0FBQTtBQUUxQyx1QkFBaUIsUUFBUSxDQUFDLG9CQUFBO0FBQ3hCLGFBQUssMEJBQTBCLGlCQUFpQixlQUFlOzs7QUFJbkUsZ0NBQTRCLG9CQUFvQixvQkFBa0I7QUFDaEUsWUFBTSx1QkFBdUIsS0FBSyx5QkFBeUI7QUFFM0QsMkJBQXFCLFFBQVEsQ0FBQyx3QkFBQTtBQUM1QixjQUFNLENBQUUsZUFBZSxTQUFTLHdCQUF5QjtBQUV6RCxzQkFBYyxLQUFLLHNCQUFBLEdBQXlCOzs7QUFJaEQscUNBQWlDLG9CQUFvQixvQkFBa0I7QUFDckUsWUFBTSx1QkFBdUIsS0FBSyx5QkFBeUIsa0JBQ3JELE9BQU8sbUJBQW1CO0FBRWhDLE1BQUEsSUFBQSxPQUFBLFNBQVEsc0JBQXNCLENBQUMscUJBQXFCLFNBQUE7QUFDbEQsY0FBTSxDQUFFLGVBQWUsU0FBUyx3QkFBeUIscUJBQ25ELFFBQU87QUFFYixzQkFBYyxLQUFLLHNCQUFBLEdBQXlCLG9CQUFvQjtTQUMvRDs7QUFHTCxvQ0FBZ0MsaUJBQWlCLGVBQWUsU0FBTztBQUNyRSxZQUFNLHNCQUFzQixLQUFLLDBCQUEwQixpQkFBaUIsZUFBZTtBQUUzRixVQUFJLENBQUMsS0FBSyxzQkFBc0I7QUFDOUIsYUFBSyx1QkFBdUI7O0FBRzlCLFdBQUsscUJBQXFCLEtBQUs7QUFFL0IsYUFBTzs7QUFHVCx1Q0FBbUMsaUJBQWlCLGVBQWUsU0FBTztBQUN4RSxZQUFNLHNCQUFzQixLQUFLLHdCQUF3QixpQkFBaUIsZUFBZSxVQUNuRixRQUFRLEtBQUsscUJBQXFCLFFBQVEsc0JBQzFDLFFBQVEsT0FDUixjQUFjO0FBRXBCLFdBQUsscUJBQXFCLE9BQU8sT0FBTztBQUV4QyxVQUFJLEtBQUsscUJBQXFCLFdBQVcsR0FBRztBQUMxQyxlQUFPLEtBQUs7O0FBR2QsYUFBTzs7QUFHVCxxQ0FBaUMsaUJBQWlCLGVBQWUsU0FBTztBQUN0RSxZQUFNLHNCQUFzQixLQUFLLHFCQUFxQixLQUFLLENBQUMseUJBQUE7QUFDMUQsWUFBSyxxQkFBb0IsWUFBWSxXQUFhLHFCQUFvQixrQkFBa0IsaUJBQW1CLHFCQUFvQixvQkFBb0IsaUJBQWtCO0FBQ25LLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdULHNDQUFrQyxpQkFBZTtBQUMvQyxZQUFNLHVCQUF1QjtBQUU3QixVQUFJLEtBQUssc0JBQXNCO0FBQzdCLGFBQUsscUJBQXFCLFFBQVEsQ0FBQyx3QkFBQTtBQUNqQyxnQkFBTSxRQUFTLG9CQUFvQixvQkFBb0I7QUFFdkQsY0FBSSxPQUFPO0FBQ1QsaUNBQXFCLEtBQUs7Ozs7QUFLaEMsYUFBTzs7QUFHVCx1Q0FBbUMsaUJBQWlCLGVBQWUsU0FBTztBQUN4RSxVQUFJO0FBRUosNEJBQXNCLE1BQUE7O0FBRXRCLGFBQU8sT0FBTyxxQkFBcUI7UUFDakM7UUFDQTtRQUNBOztBQUdGLGFBQU87O0FBR1QsUUFBTSxvQkFBb0I7TUFDeEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztRQUdGLFdBQWU7Ozs7QUMxSGY7Ozs7O21DQWlDQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFOLHdCQUFNO01BQ25CLFlBQVksVUFBVTtBQUNwQixZQUFJLGFBQWEsTUFBTTtBQUNyQixnQkFBTSxVQUFTLE1BQ1QsYUFBYSxTQUFTLGNBQWM7QUFFMUMsVUFBQSxJQUFBLFVBQUEsa0JBQWlCLFNBQVM7OztNQUk5QixnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsWUFBWTtBQUNWLGNBQU0sU0FBUyxRQUFBLFFBQU8sZUFBZSxLQUFLO0FBRTFDLGVBQU87O01BR1QsWUFBWTtBQUNWLGNBQU0sU0FBUyxRQUFBLFFBQU8sZUFBZSxLQUFLO0FBRTFDLGVBQU87O01BR1QsV0FBVztBQUFFLGVBQU8sS0FBSyxXQUFXOztNQUVwQyxZQUFZO0FBQUUsZUFBTyxLQUFLLFdBQVc7O01BRXJDLGdCQUFnQjtBQUFFLGVBQU8sS0FBSyxXQUFXOztNQUV6QyxpQkFBaUI7QUFBRSxlQUFPLEtBQUssV0FBVzs7TUFFMUMsU0FBUyxPQUFPO0FBQ2QsZ0JBQVEsR0FBRztBQUVYLGFBQUssTUFBTSxXQUFBLE9BQU87O01BR3BCLFVBQVUsUUFBUTtBQUNoQixpQkFBUyxHQUFHO0FBRVosYUFBSyxNQUFNLFdBQUEsUUFBUTs7TUFHckIsYUFBYSxNQUFNO0FBQUUsZUFBTyxLQUFLLFdBQVcsYUFBYTs7TUFFekQsYUFBYSxNQUFNO0FBQUUsZUFBTyxLQUFLLFdBQVcsYUFBYTs7TUFFekQsYUFBYSxNQUFNLE9BQU87QUFBRSxhQUFLLFdBQVcsYUFBYSxNQUFNOztNQUUvRCxlQUFlLE1BQU07QUFBRSxhQUFLLFdBQVcsZ0JBQWdCOztNQUV2RCxhQUFhLE1BQU0sT0FBTztBQUFFLGFBQUssYUFBYSxNQUFNOztNQUVwRCxnQkFBZ0IsTUFBTTtBQUFFLGFBQUssZUFBZTs7TUFFNUMsU0FBUyxXQUFXO0FBQUUsZUFBTyxLQUFLLFdBQVcsVUFBVSxTQUFTOztNQUVoRSxTQUFTLFdBQVc7QUFBRSxhQUFLLFdBQVcsWUFBWTs7TUFFbEQsU0FBUyxXQUFXO0FBQUUsYUFBSyxXQUFXLFVBQVUsSUFBSTs7TUFFcEQsWUFBWSxXQUFXO0FBQUUsYUFBSyxXQUFXLFVBQVUsT0FBTzs7TUFFMUQsWUFBWSxXQUFXO0FBQUUsYUFBSyxXQUFXLFVBQVUsT0FBTzs7TUFFMUQsbUJBQW1CO0FBQUUsYUFBSyxXQUFXLFlBQVksV0FBQTs7TUFFakQsTUFBTSxlQUFlO0FBQUUsc0JBQWMsSUFBSTs7TUFFekMsU0FBUyxlQUFlO0FBQUUsc0JBQWMsT0FBTzs7TUFFL0MsVUFBVSxlQUFlO0FBQUUsc0JBQWMsUUFBUTs7TUFFakQsV0FBVyxlQUFlO0FBQUUsc0JBQWMsT0FBTzs7TUFFakQsT0FBTyxTQUFTO0FBQUUsYUFBSyxPQUFPOztNQUU5QixJQUFJLFNBQVM7QUFBRSxhQUFLLE9BQU87O01BRTNCLE9BQU8sU0FBUztBQUNkLFlBQUksU0FBUztBQUNYLGtCQUFRO0FBRVI7O0FBR0YsYUFBSyxXQUFXOztNQUdsQixRQUFRLFNBQVM7QUFDZixjQUFNLGFBQWEsUUFBUSxZQUNyQixzQkFBc0IsS0FBSyxXQUFXO0FBRTVDLGFBQUssV0FBVyxhQUFhLFlBQVk7O01BRzNDLE9BQU8sU0FBUztBQUNkLGNBQU0sYUFBYSxRQUFRLFlBQ3JCLHNCQUFzQjtBQUU1QixhQUFLLFdBQVcsYUFBYSxZQUFZOztNQUczQyxhQUFhLGdCQUFnQjtBQUMzQixjQUFNLGdCQUFnQixlQUFlLFdBQVcsWUFDMUMsc0JBQXNCLGVBQWU7QUFFM0Msc0JBQWMsYUFBYSxLQUFLLFlBQVk7O01BRzlDLFlBQVksZ0JBQWdCO0FBQzFCLGNBQU0sZ0JBQWdCLGVBQWUsV0FBVyxZQUMxQyxzQkFBc0IsZUFBZSxXQUFXO0FBRXRELHNCQUFjLGFBQWEsS0FBSyxZQUFZOztNQUc5QyxNQUFNLFNBQVM7QUFDYixhQUFLLElBQUk7QUFFVCxRQUFBLElBQUEsVUFBQSxjQUFhOztNQUdmLFFBQVEsU0FBUztBQUNmLFFBQUEsSUFBQSxVQUFBLGdCQUFlO0FBRWYsYUFBSyxPQUFPOztNQUdkLFlBQVksZ0JBQWdCO0FBQzFCLGFBQUssYUFBYTtBQUVsQixjQUFNLFVBQVU7QUFFaEIsUUFBQSxJQUFBLFVBQUEsY0FBYTs7TUFHZixXQUFXLGdCQUFnQjtBQUN6QixhQUFLLFlBQVk7QUFFakIsY0FBTSxVQUFVO0FBRWhCLFFBQUEsSUFBQSxVQUFBLGNBQWE7O01BR2YsS0FBSyxlQUFlLFdBQUEsT0FBTztBQUFFLGFBQUssUUFBUTs7TUFFMUMsT0FBTztBQUFFLGFBQUssTUFBTSxXQUFBLFNBQVMsV0FBQTs7TUFFN0IsUUFBUSxTQUFTO0FBQUUsYUFBSyxNQUFNLFdBQUEsU0FBUzs7TUFFdkMsU0FBUztBQUFFLGFBQUssZUFBZSxXQUFBOztNQUUvQixVQUFVO0FBQUUsYUFBSyxhQUFhLFdBQUEsVUFBVSxXQUFBOztNQUV4QyxZQUFZO0FBQ1YsY0FBTSxXQUFXLEtBQUssY0FDaEIsVUFBVSxDQUFDO0FBRWpCLGVBQU87O01BR1QsYUFBYTtBQUNYLGNBQU0sV0FBVyxLQUFLLGFBQWEsV0FBQTtBQUVuQyxlQUFPOztNQUdULGNBQWM7QUFDWixjQUFNLFVBQVUsS0FBSyxJQUFJLFdBQUEsVUFDbkIsWUFBYSxZQUFZLFdBQUE7QUFFL0IsZUFBTzs7TUFHVCxZQUFZO0FBQ1YsY0FBTSxZQUFZLEtBQUssZUFDakIsVUFBVTtBQUVoQixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFlBQVksS0FBSyxlQUNqQixTQUFTLENBQUM7QUFFaEIsZUFBTzs7TUFHVCxNQUFNLE1BQU0sUUFBUSxNQUFNO0FBQ3hCLFlBQUksVUFBVSxNQUFNO0FBQ2xCLGVBQUssV0FBVyxNQUFNLFFBQVE7QUFFOUI7O0FBR0YsY0FBTSxRQUFRLEtBQUssV0FBVyxNQUFNO0FBRXBDLGVBQU87O01BR1QsS0FBSyxPQUFPLE1BQU07QUFDaEIsWUFBSSxTQUFTLE1BQU07QUFDakIsZ0JBQU0sYUFBWTtBQUVsQixlQUFLLFdBQVcsWUFBWTtBQUU1Qjs7QUFHRixjQUFNLFlBQVksS0FBSyxXQUFXO0FBRWxDLGVBQU87QUFFUCxlQUFPOztNQUdULElBQUksTUFBTSxNQUFNO0FBQ2QsWUFBSSxRQUFRLE1BQU07QUFDaEIsZ0JBQU07QUFFTixnQkFBTSxpQkFBaUIsaUJBQWlCLEtBQUs7QUFFN0MsbUJBQVMsUUFBUSxHQUFHLFFBQVEsZUFBZSxRQUFRLFNBQVM7QUFDMUQsa0JBQU0sZ0JBQWdCLGVBQWUsUUFDL0IsT0FBTyxlQUNQLFFBQVEsZUFBZSxpQkFBaUI7QUFFOUMsZ0JBQUksUUFBUTs7bUJBRUwsT0FBTyxRQUFRLFdBQUEsUUFBUTtBQUNoQyxjQUFJLE9BQU87QUFFWCxnQkFBTSxpQkFBaUIsaUJBQWlCLEtBQUssYUFDdkMsUUFBUSxlQUFlLGlCQUFpQjtBQUU5QyxnQkFBTTtlQUNEO0FBQ0wsZ0JBQU0sUUFBUSxPQUFPLEtBQUs7QUFFMUIsZ0JBQU0sUUFBUSxDQUFDLFNBQUE7QUFDYixrQkFBTSxRQUFRLElBQUk7QUFFbEIsaUJBQUssTUFBTSxNQUFNOzs7QUFJckIsZUFBTzs7TUFHVCxVQUFVO0FBQ1IsY0FBTSxVQUFVO0FBRWhCLFFBQUEsSUFBQSxVQUFBLGdCQUFlOzthQUdWLFVBQVUsT0FBTyxlQUFlLG9CQUFvQjtBQUN6RCxjQUFNLENBQUUsV0FBWSxPQUNkLFVBQVUsbUJBQW1CLE9BQU8sU0FBQSxHQUFZLHFCQUNoRCxvQkFBb0IsMkJBQTJCLFFBQy9DLG9CQUFvQiwyQkFBMkI7QUFFckQsZ0JBQVEsZ0JBQWdCLFlBQVksbUJBQW1CO0FBRXZELGdCQUFRLGNBQWMsUUFBUTtBQUU5QixlQUFPOzthQUdGLFlBQVksU0FBUyxlQUFlLG9CQUFvQjtBQUM3RCxjQUFNLFFBQVEsU0FDUixVQUFVLG1CQUFtQixPQUFPLFNBQUEsR0FBWSxxQkFDaEQsb0JBQW9CLElBQ3BCLG9CQUFvQjtBQUUxQixnQkFBUSxnQkFBZ0IsWUFBWSxtQkFBbUI7QUFFdkQsZ0JBQVEsY0FBYyxRQUFRO0FBRTlCLGVBQU87OztBQUlYLFdBQU8sT0FBTyxRQUFRLFdBQVcsS0FBQTtBQUNqQyxXQUFPLE9BQU8sUUFBUSxXQUFXLEtBQUE7QUFDakMsV0FBTyxPQUFPLFFBQVEsV0FBVyxPQUFBO0FBQ2pDLFdBQU8sT0FBTyxRQUFRLFdBQVcsT0FBQTtBQUNqQyxXQUFPLE9BQU8sUUFBUSxXQUFXLE9BQUE7QUFDakMsV0FBTyxPQUFPLFFBQVEsV0FBVyxPQUFBO0FBQ2pDLFdBQU8sT0FBTyxRQUFRLFdBQVcsT0FBQTtBQUNqQyxXQUFPLE9BQU8sUUFBUSxXQUFXLFFBQUE7QUFDakMsV0FBTyxPQUFPLFFBQVEsV0FBVyxRQUFBO0FBQ2pDLFdBQU8sT0FBTyxRQUFRLFdBQVcsU0FBQTtBQUNqQyxXQUFPLE9BQU8sUUFBUSxXQUFXLFlBQUE7QUFDakMsV0FBTyxPQUFPLFFBQVEsV0FBVyxhQUFBO0FBRWpDLGdDQUE0QixPQUFPLFlBQVksb0JBQWtCO0FBQy9ELFlBQU0sV0FBVyxNQUNYLFVBQVUsSUFBSyxVQUFTLFVBQVUsS0FBSyxLQUFLLE9BQU8sTUFBTSxVQUFBLEdBQWEsd0JBQ3RFLGFBQWEsSUFBQSxNQUFBLGNBQWEsV0FDWCxTQUFTLGdCQUFnQixXQUFBLG1CQUFtQixXQUMxQyxTQUFTLGNBQWM7QUFFOUMsTUFBQSxJQUFBLFVBQUEsa0JBQWlCLFNBQVM7QUFFMUIsYUFBTzs7QUFHVCx3Q0FBb0MsT0FBTyxvQkFBb0IsSUFBRTtBQUMvRCxVQUFJLE1BQU0sZUFBZSxXQUFBLHFCQUFxQjtBQUM1Qyw0QkFBb0IsSUFBQSxRQUFBLFNBQVEsbUJBQW1CLE1BQU0sV0FBQTs7QUFHdkQsWUFBTSxhQUFhLE9BQU8sZUFBZTtBQUV6QyxVQUFJLGVBQWUsTUFBTTtBQUN2Qiw0QkFBb0IsMkJBQTJCLFlBQVk7O0FBRzdELGFBQU87O0FBR1Qsd0NBQW9DLE9BQU8sb0JBQW9CLElBQUU7QUFDL0QsVUFBSSxNQUFNLGVBQWUsV0FBQSxxQkFBcUI7QUFDNUMsNEJBQW9CLElBQUEsT0FBQSxTQUFRLG1CQUFtQixNQUFNLFdBQUEscUJBQXFCLENBQUMsb0JBQUE7QUFDekUsY0FBSSxDQUFDLGtCQUFrQixTQUFTLGtCQUFrQjtBQUNoRCxtQkFBTzs7OztBQUtiLFlBQU0sYUFBYSxPQUFPLGVBQWU7QUFFekMsVUFBSSxlQUFlLE1BQU07QUFDdkIsNEJBQW9CLDJCQUEyQixZQUFZOztBQUc3RCxhQUFPOzs7OztBQ3JYVDs7Ozs7bUNBMENBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7QUFsQ0EsMkJBQXVCLGVBQWUsZUFBZSxlQUFhO0FBQ2hFLFVBQUksVUFBVTtBQUVkLFVBQUksZUFBZTtBQUNqQix3QkFBZ0Isc0JBQXNCO0FBRXRDLHFCQUFhLE9BQU8sT0FBTztVQUN6QjtXQUNDO0FBRUgsWUFBSSxPQUFPO21CQUVBLGFBQWEsZUFBZSxTQUFBLFVBQVU7QUFDL0MsZ0JBQU0sUUFBUTtBQUVkLG9CQUFVLE1BQU0sVUFBVSxPQUFPO21CQUN4QixPQUFPLGtCQUFrQixXQUFBLFFBQVE7QUFDMUMsZ0JBQU0sVUFBVTtBQUVoQixvQkFBVSxTQUFBLFFBQVEsWUFBWSxTQUFTO21CQUM5QixPQUFPLGtCQUFrQixXQUFBLFVBQVU7QUFDNUMsZ0JBQU0sa0JBQWtCO0FBRXhCLG9CQUFVLGdCQUFnQjs7O0FBSTlCLGFBQU87O0FBR1QsUUFBTSxTQUFRO01BQ1o7O1FBR0YsV0FBZTtBQUVmLG1DQUErQixlQUFhO0FBQzFDLHNCQUFnQixJQUFBLE9BQUEsU0FBUTtBQUV4QixzQkFBZ0IsSUFBQSxVQUFBLHNCQUFxQjtBQUVyQyxzQkFBZ0IsSUFBQSxVQUFBLGdDQUErQjtBQUUvQyxhQUFPOztBQUlULDBCQUFzQixVQUFVLE9BQUs7QUFDbkMsWUFBTSxhQUFjLFNBQVMscUJBQXFCO0FBRWxELGFBQU87Ozs7O0FDMURUOzs7Ozs7Ozs7Ozs7O1VBRWEsb0JBQUE7ZUFBQTs7VUFFQSxzQkFBQTtlQUFBOztVQURBLHFCQUFBO2VBQUE7O1VBR2IsVUFBQTtlQUFBOzs7QUFKTyxRQUFNLG9CQUFvQjtBQUMxQixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLHNCQUFzQjtRQUVuQyxXQUFlO01BQ2I7TUFDQTtNQUNBOzs7OztBQ1RGOzs7OzttQ0ErQkEsV0FBQTs7O2VBQUE7Ozs7QUEzQkEscUJBQWlCLGNBQWMsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLGtCQUFrQixjQUFjOztBQUV2RixzQkFBa0IsY0FBYyxTQUFPO0FBQUksV0FBSyxTQUFTLFlBQUEsa0JBQWtCLGNBQWM7O0FBRXpGLHNCQUFrQixlQUFlLFNBQU87QUFBSSxXQUFLLFFBQVEsWUFBQSxtQkFBbUIsZUFBZTs7QUFFM0YsdUJBQW1CLGVBQWUsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLG1CQUFtQixlQUFlOztBQUU3Rix3QkFBUztBQUFhLGFBQU8sS0FBSyxXQUFXOztBQUU3QyxzQkFBa0IsT0FBSztBQUFJLFdBQUssV0FBVyxRQUFROztBQUVuRCwwQkFBUztBQUFlLGFBQU8sS0FBSyxXQUFXOztBQUUvQyx5QkFBcUIsVUFBUTtBQUFJLFdBQUssV0FBVyxXQUFXOztBQUU1RCxRQUFNLGNBQWM7TUFDbEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDL0JmOzs7OzttQ0FnQ0EsV0FBQTs7O2VBQUE7Ozs7QUE1QkEsb0JBQWdCLGFBQWEsU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLGlCQUFpQixhQUFhOztBQUVuRixxQkFBaUIsYUFBYSxTQUFPO0FBQUksV0FBSyxTQUFTLFlBQUEsaUJBQWlCLGFBQWE7O0FBRXJGLHFCQUFpQixjQUFjLFNBQU87QUFBSSxXQUFLLFFBQVEsWUFBQSxrQkFBa0IsY0FBYzs7QUFFdkYsc0JBQWtCLGNBQWMsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLGtCQUFrQixjQUFjOztBQUV6RixvQkFBUztBQUFTLFdBQUssV0FBVzs7QUFFbEMscUJBQVM7QUFBVSxXQUFLLFdBQVc7O0FBRW5DLHdCQUFTO0FBQ1AsWUFBTSxTQUFTLFNBQVMsa0JBQWtCLEtBQUs7QUFFL0MsYUFBTzs7QUFHVCxRQUFNLGNBQWM7TUFDbEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ2hDZjs7Ozs7bUNBd0NBLFdBQUE7OztlQUFBOzs7O0FBcENBLG1CQUFlLFlBQVksU0FBTztBQUFJLFdBQUssUUFBUSxZQUFBLGdCQUFnQixZQUFZOztBQUUvRSxvQkFBZ0IsWUFBWSxTQUFPO0FBQUksV0FBSyxTQUFTLFlBQUEsZ0JBQWdCLFlBQVk7O0FBRWpGLG9CQUFnQixhQUFhLFNBQU87QUFBSSxXQUFLLFFBQVEsWUFBQSxpQkFBaUIsYUFBYTs7QUFFbkYscUJBQWlCLGFBQWEsU0FBTztBQUFJLFdBQUssU0FBUyxZQUFBLGlCQUFpQixhQUFhOztBQUVyRixxQkFBaUIsY0FBYyxTQUFPO0FBQUksV0FBSyxRQUFRLFlBQUEsa0JBQWtCLGNBQWM7O0FBRXZGLHNCQUFrQixjQUFjLFNBQU87QUFBSSxXQUFLLFNBQVMsWUFBQSxrQkFBa0IsY0FBYzs7QUFFekYsaUNBQVM7QUFBc0IsYUFBTyxLQUFLLFdBQVc7O0FBRXRELCtCQUFTO0FBQW9CLGFBQU8sS0FBSyxXQUFXOztBQUVwRCwrQkFBMkIsZ0JBQWM7QUFBSSxXQUFLLFdBQVcsaUJBQWlCOztBQUU5RSw2QkFBeUIsY0FBWTtBQUFJLFdBQUssV0FBVyxlQUFlOztBQUV4RSxzQkFBUztBQUFXLFdBQUssV0FBVzs7QUFFcEMsUUFBTSxrQkFBa0I7TUFDdEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDeENmOzs7OzttQ0FpRUE7OztlQUFBOzs7Ozs7Ozs7Ozs7OztBQXZEQSx5QkFBTTtNQUNKLGNBQWM7QUFDWixhQUFLLGFBQWE7O01BR3BCLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQUUsZUFBTyxLQUFLLFdBQVc7O01BRXhDLGNBQWM7QUFBRSxlQUFPLEtBQUssV0FBVzs7TUFFdkMsZUFBZSxNQUFNO0FBQUUsZUFBTyxLQUFLLFdBQVcsZUFBZTs7TUFFN0Qsa0JBQWtCLHdCQUF3QixTQUFTO0FBQUUsYUFBSyxRQUFRLFlBQUEsNEJBQTRCLHdCQUF3Qjs7TUFFdEgsbUJBQW1CLHdCQUF3QixTQUFTO0FBQUUsYUFBSyxTQUFTLFlBQUEsNEJBQTRCLHdCQUF3Qjs7TUFFeEgsb0JBQW9CLFdBQVcsU0FBUyxTQUFTO0FBQy9DLFlBQUk7QUFFSixjQUFNLGlCQUFpQjtBQUV2Qix3QkFBZ0IsQ0FBQyxVQUFBO0FBQ2YsY0FBSSxjQUFjLFlBQUEsNEJBQTRCO0FBQzVDLGtCQUFNLENBQUUsY0FBZSxnQkFDakIsQ0FBRSxpQkFBa0IsT0FDcEIsQ0FBRSxpQkFBa0I7QUFFMUIsZ0JBQUksZUFBZSxlQUFlO0FBQ2hDOzs7QUFJSixnQkFBTSxXQUFVO0FBRWhCLGtCQUFRLEtBQUssZ0JBQWdCLE9BQU87O0FBR3RDLGVBQU8sT0FBTyxlQUFlO1VBQzNCO1VBQ0E7VUFDQTs7QUFHRixlQUFPOzs7QUFJWCxXQUFPLE9BQU8sU0FBUyxXQUFXLEtBQUE7QUFDbEMsV0FBTyxPQUFPLFNBQVMsV0FBVyxPQUFBO0FBQ2xDLFdBQU8sT0FBTyxTQUFTLFdBQVcsT0FBQTtBQUNsQyxXQUFPLE9BQU8sU0FBUyxXQUFXLE9BQUE7UUFFbEMsV0FBZ0IsT0FBTyxhQUFhLFdBQUEsWUFBYSxTQUFZLElBQUk7Ozs7QUNqRWpFOzs7OzttQ0F3RUE7OztlQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBNURBLHVCQUFNO01BQ0osY0FBYztBQUNaLGFBQUssYUFBYTs7TUFHcEIsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLOztNQUdkLFVBQVUsU0FBUztBQUNqQixjQUFNLFNBQVMsS0FBSztBQUVwQixlQUFPLE9BQU8sUUFBQSxHQUFXOztNQUczQixTQUFTO0FBQ1AsZUFBTyxTQUFTOztNQUdsQixXQUFXO0FBQUUsZUFBTyxLQUFLLFdBQVc7O01BRXBDLFlBQVk7QUFBRSxlQUFPLEtBQUssV0FBVzs7TUFFckMsZUFBZTtBQUFFLGVBQU8sS0FBSyxXQUFXOztNQUV4QyxnQkFBZ0I7QUFBRSxlQUFPLEtBQUssV0FBVzs7TUFFekMsZUFBZTtBQUFFLGVBQU8sS0FBSyxXQUFXOztNQUV4QyxpQkFBaUI7QUFBRSxlQUFPLEtBQUssV0FBVyxPQUFPOztNQUVqRCxrQkFBa0I7QUFBRSxlQUFPLEtBQUssV0FBVyxPQUFPOztNQUVsRCxTQUFTLFdBQVcsWUFBWTtBQUFFLGFBQUssV0FBVyxTQUFTLFlBQVk7O01BRXZFLFNBQVMsZUFBZSxTQUFTO0FBQy9CLGNBQU0sWUFBWSxZQUFBLG1CQUNaLGdCQUFnQixLQUFLLGlCQUFpQixXQUFXLGVBQWU7QUFFdEUsYUFBSyxXQUFXLGlCQUFpQixXQUFXOztNQUc5QyxVQUFVLGVBQWUsU0FBUztBQUNoQyxjQUFNLFlBQVksWUFBQSxtQkFDWixnQkFBZ0IsS0FBSyxvQkFBb0IsV0FBVyxlQUFlO0FBRXpFLGFBQUssV0FBVyxvQkFBb0IsV0FBVzs7O0FBSW5ELFdBQU8sT0FBTyxPQUFPLFdBQVcsS0FBQTtBQUNoQyxXQUFPLE9BQU8sT0FBTyxXQUFXLE9BQUE7QUFDaEMsV0FBTyxPQUFPLE9BQU8sV0FBVyxPQUFBO0FBQ2hDLFdBQU8sT0FBTyxPQUFPLFdBQVcsT0FBQTtBQUNoQyxXQUFPLE9BQU8sT0FBTyxXQUFXLE9BQUE7QUFDaEMsV0FBTyxPQUFPLE9BQU8sV0FBVztNQUM5QixVQUFBLFFBQUE7TUFDQSxXQUFBLFFBQUE7O1FBR0YsV0FBZ0IsT0FBTyxXQUFXLFdBQUEsWUFBYSxTQUFZLElBQUk7Ozs7QUN4RS9EOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiw2QkFBbUIsU0FBQSxRQUFPO01BQ3ZDLFlBQVksV0FBVyxXQUFBLE1BQU07QUFDM0IsY0FBTTs7O0FBR0Qsa0JBTE0sTUFLTixXQUFVOzs7O0FDWG5COzs7OzttQ0FLQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiw2QkFBbUIsU0FBQSxRQUFPO01BQ3ZDLFVBQVU7QUFBRSxlQUFPLEtBQUssYUFBYTs7TUFFckMsUUFBUSxNQUFNO0FBQUUsZUFBTyxLQUFLLGFBQWEsUUFBUTs7O0FBRTFDLGtCQUxNLE1BS04sV0FBVTtBQUduQixXQUFPLE9BQU8sS0FBSyxXQUFXLE9BQUE7Ozs7QUNiOUI7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBQU4sOEJBQW9CLFNBQUEsUUFBTzs7QUFDakMsa0JBRE0sT0FDTixXQUFVO0FBR25CLFdBQU8sT0FBTyxNQUFNLFdBQVcsT0FBQTtBQUMvQixXQUFPLE9BQU8sTUFBTSxXQUFXLE9BQUE7QUFDL0IsV0FBTyxPQUFPLE1BQU0sV0FBVyxXQUFBOzs7O0FDYi9COzs7OzttQ0FLQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiwrQkFBcUIsU0FBQSxRQUFPOztBQUNsQyxrQkFETSxRQUNOLFdBQVU7QUFHbkIsV0FBTyxPQUFPLE9BQU8sV0FBVyxPQUFBOzs7O0FDVGhDOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sK0JBQXFCLFNBQUEsUUFBTzs7QUFDbEMsa0JBRE0sUUFDTixXQUFVO0FBR25CLFdBQU8sT0FBTyxPQUFPLFdBQVcsT0FBQTtBQUNoQyxXQUFPLE9BQU8sT0FBTyxXQUFXLE9BQUE7Ozs7QUNYaEM7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTixpQ0FBdUIsU0FBQSxRQUFPO01BQzNDLFlBQVk7QUFBRSxlQUFPLEtBQUssV0FBVzs7TUFFckMsTUFBTSxVQUFVLE1BQU07QUFBRSxhQUFLLFdBQVcsVUFBVTs7O0FBRTNDLGtCQUxNLFVBS04sV0FBVTtBQUVWLGtCQVBNLFVBT04scUJBQW9CO01BQ3pCLE1BQU07O0FBSVYsV0FBTyxPQUFPLFNBQVMsV0FBVyxPQUFBO0FBQ2xDLFdBQU8sT0FBTyxTQUFTLFdBQVcsT0FBQTs7OztBQ25CbEM7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBQU4saUNBQXVCLFNBQUEsUUFBTzs7QUFDcEMsa0JBRE0sVUFDTixXQUFVO0FBR25CLFdBQU8sT0FBTyxTQUFTLFdBQVcsT0FBQTtBQUNsQyxXQUFPLE9BQU8sU0FBUyxXQUFXLE9BQUE7QUFDbEMsV0FBTyxPQUFPLFNBQVMsV0FBVyxXQUFBOzs7O0FDYmxDOzs7Ozs7Ozs7Ozs7O1VBZ0JvQixPQUFBO2VBQUEsTUFBQTs7VUFiQSxTQUFBO2VBQUEsUUFBQTs7VUFnQkEsU0FBQTtlQUFBLFFBQUE7O1VBRUEsV0FBQTtlQUFBLFVBQUE7O1VBVEEsVUFBQTtlQUFBLFVBQUE7O1VBTUEsUUFBQTtlQUFBLFFBQUE7O1VBREEsT0FBQTtlQUFBLE1BQUE7O1VBYkEsU0FBQTtlQUFBLFFBQUE7O1VBRkEsUUFBQTtlQUFBLE9BQUE7O1VBa0JBLFNBQUE7ZUFBQSxRQUFBOztVQVBBLGNBQUE7ZUFBQSxhQUFBOztVQVNBLFdBQUE7ZUFBQSxVQUFBOztVQVhBLG9CQUFBO2VBQUEsYUFBQTs7VUFHQSxXQUFBO2VBQUEsVUFBQTs7VUFQQSxtQkFBQTtlQUFBLFNBQUE7O1VBRkEsYUFBQTtlQUFBLFlBQUE7O1VBSUEsY0FBQTtlQUFBLE9BQUE7O1VBREEsY0FBQTtlQUFBLE9BQUE7O1VBRkEsZUFBQTtlQUFBLGNBQUE7O1VBSUEsa0JBQUE7ZUFBQSxXQUFBOztVQUtBLFNBQUE7ZUFBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZwQjs7Ozs7O0FBSUEsV0FBTyxPQUFPLFlBQVk7TUFDeEIsT0FBQSxNQUFBOzs7OztBQ0xGOzs7Ozs7Ozs7QUNBQTs7Ozs7bUNBb0JBLFdBQUE7OztlQUFBOzs7QUFsQkEsUUFBTSxXQUFXO01BQ2Y7TUFBSztNQUFRO01BQVc7TUFBUztNQUNqQztNQUFLO01BQVE7TUFBTztNQUFPO01BQWM7TUFBUTtNQUFNO01BQ3ZEO01BQVU7TUFBVztNQUFRO01BQVE7TUFBTztNQUM1QztNQUFRO01BQVk7TUFBTTtNQUFPO01BQVc7TUFBTztNQUFVO01BQU87TUFBTTtNQUFNO01BQU07TUFBUztNQUFZO01BQWM7TUFBVTtNQUFVO01BQzdJO01BQU07TUFBTTtNQUFNO01BQU07TUFBTTtNQUFNO01BQVE7TUFBVTtNQUFNO01BQzVEO01BQUs7TUFBVTtNQUFPO01BQVM7TUFBTztNQUFPO01BQVM7TUFBVTtNQUFNO01BQ3RFO01BQVE7TUFBTztNQUFRO01BQVE7TUFBUztNQUFPO01BQy9DO01BQVU7TUFBTTtNQUFZO01BQVU7TUFDdEM7TUFBSztNQUFTO01BQVc7TUFBTztNQUNoQztNQUFLO01BQU07TUFBTTtNQUNqQjtNQUFLO01BQVE7TUFBVTtNQUFXO01BQVU7TUFBUztNQUFVO01BQVE7TUFBVTtNQUFTO01BQU87TUFBVztNQUFPO01BQ25IO01BQVM7TUFBUztNQUFNO01BQVk7TUFBWTtNQUFTO01BQU07TUFBUztNQUFRO01BQVM7TUFBTTtNQUMvRjtNQUFLO01BQ0w7TUFBTztNQUNQOztRQUdGLFdBQWU7Ozs7QUNwQmY7Ozs7Ozs7Ozs7Ozs7VUFHYSxjQUFBO2VBQUE7O1VBR0EsY0FBQTtlQUFBOztVQUNBLGNBQUE7ZUFBQTs7VUFIQSxhQUFBO2VBQUE7O1VBRkEsY0FBQTtlQUFBOztVQUdBLGdCQUFBO2VBQUE7O1VBSWIsVUFBQTtlQUFBOzs7QUFQTyxRQUFNLGNBQWM7QUFDcEIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sYUFBYTtBQUNuQixRQUFNLGdCQUFnQjtBQUN0QixRQUFNLGNBQWM7QUFDcEIsUUFBTSxjQUFjO1FBRTNCLFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDZkY7Ozs7Ozs7Ozs7Ozs7VUFLYSxnQkFBQTtlQUFBOztVQUhBLGFBQUE7ZUFBQTs7VUFJQSxpQkFBQTtlQUFBOztVQUZBLGVBQUE7ZUFBQTs7VUFEQSxjQUFBO2VBQUE7O1VBS2IsVUFBQTtlQUFBOzs7QUFOTyxRQUFNLGFBQWE7QUFDbkIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGdCQUFnQjtBQUN0QixRQUFNLGlCQUFpQjtRQUU5QixXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUNiRjs7Ozs7Ozs7Ozs7OztVQUdhLGdCQUFBO2VBQUE7O1VBV0Esc0NBQUE7ZUFBQTs7VUFEQSxzQ0FBQTtlQUFBOztVQURBLHFDQUFBO2VBQUE7O1VBR0EsdUNBQUE7ZUFBQTs7VUFSQSx1QkFBQTtlQUFBOztVQUNBLHVCQUFBO2VBQUE7O1VBR0EsNkJBQUE7ZUFBQTs7VUFGQSx3QkFBQTtlQUFBOztVQUhBLHNCQUFBO2VBQUE7O1VBRkEsa0JBQUE7ZUFBQTs7VUFGQSxnQkFBQTtlQUFBOztVQVFBLDJCQUFBO2VBQUE7O1VBTEEsb0JBQUE7ZUFBQTs7VUFZYixVQUFBO2VBQUE7OztBQWZPLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sMkJBQTJCO0FBQ2pDLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0scUNBQXFDO0FBQzNDLFFBQU0sc0NBQXNDO0FBQzVDLFFBQU0sc0NBQXNDO0FBQzVDLFFBQU0sdUNBQXVDO1FBRXBELFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQy9CRjs7Ozs7Ozs7Ozs7OztVQVNhLHNCQUFBO2VBQUE7O1VBQ0Esc0JBQUE7ZUFBQTs7VUFDQSx1QkFBQTtlQUFBOztVQUhBLG9CQUFBO2VBQUE7O1VBREEscUJBQUE7ZUFBQTs7VUFEQSxrQkFBQTtlQUFBOztVQUZBLGlCQUFBO2VBQUE7O1VBQ0Esa0JBQUE7ZUFBQTs7VUFGQSxpQkFBQTtlQUFBOztVQURBLGVBQUE7ZUFBQTs7VUFXYixVQUFBO2VBQUE7OztBQVhPLFFBQU0sZUFBZTtBQUNyQixRQUFNLGlCQUFpQjtBQUN2QixRQUFNLGlCQUFpQjtBQUN2QixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLG9CQUFvQjtBQUMxQixRQUFNLHNCQUFzQjtBQUM1QixRQUFNLHNCQUFzQjtBQUM1QixRQUFNLHVCQUF1QjtRQUVwQyxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDdkJGOzs7Ozs7Ozs7Ozs7O1VBSWEsa0JBQUE7ZUFBQTs7VUFGQSxnQkFBQTtlQUFBOztVQUNBLGlCQUFBO2VBQUE7O1VBR2IsVUFBQTtlQUFBOzs7QUFKTyxRQUFNLGdCQUFnQjtBQUN0QixRQUFNLGlCQUFpQjtBQUN2QixRQUFNLGtCQUFrQjtRQUUvQixXQUFlO01BQ2I7TUFDQTtNQUNBOzs7OztBQ1RGOzs7Ozs7Ozs7Ozs7O1VBc0JhLHNCQUFBO2VBQUE7O1VBSkEscUJBQUE7ZUFBQTs7VUFLQSxzQkFBQTtlQUFBOztVQUNBLHNCQUFBO2VBQUE7O1VBSkEscUJBQUE7ZUFBQTs7VUFoQkEsZ0JBQUE7ZUFBQTs7VUF5QkEsNEJBQUE7ZUFBQTs7VUFEQSw0QkFBQTtlQUFBOztVQUlBLGtDQUFBO2VBQUE7O1VBRUEsbUNBQUE7ZUFBQTs7VUFyQkEsa0JBQUE7ZUFBQTs7VUFEQSxrQkFBQTtlQUFBOztVQUlBLG1CQUFBO2VBQUE7O1VBVEEsaUJBQUE7ZUFBQTs7VUFRQSxtQkFBQTtlQUFBOztVQVBBLGlCQUFBO2VBQUE7O1VBU0EsbUJBQUE7ZUFBQTs7VUFkQSxnQkFBQTtlQUFBOztVQTJCQSw2QkFBQTtlQUFBOztVQUpBLDBCQUFBO2VBQUE7O1VBckJBLGdCQUFBO2VBQUE7O1VBSUEsaUJBQUE7ZUFBQTs7VUFZQSxxQkFBQTtlQUFBOztVQU1BLDRCQUFBO2VBQUE7O1VBSUEsa0NBQUE7ZUFBQTs7VUFFQSxtQ0FBQTtlQUFBOztVQW5CQSxtQkFBQTtlQUFBOztVQVJBLGlCQUFBO2VBQUE7O1VBbUJBLDBCQUFBO2VBQUE7O1VBZkEsa0JBQUE7ZUFBQTs7VUFDQSxrQkFBQTtlQUFBOztVQVRBLGVBQUE7ZUFBQTs7VUFpQkEscUJBQUE7ZUFBQTs7VUFpQmIsVUFBQTtlQUFBOzs7QUFsQ08sUUFBTSxlQUFlO0FBQ3JCLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCLE9BQU8sYUFBYTtBQUNoRCxRQUFNLDBCQUEwQjtBQUNoQyxRQUFNLDBCQUEwQjtBQUNoQyxRQUFNLDRCQUE0QjtBQUNsQyxRQUFNLDRCQUE0QjtBQUNsQyxRQUFNLDRCQUE0QjtBQUNsQyxRQUFNLDZCQUE2QjtBQUNuQyxRQUFNLGtDQUFrQztBQUN4QyxRQUFNLGtDQUFrQztBQUN4QyxRQUFNLG1DQUFtQztBQUN6QyxRQUFNLG1DQUFtQztRQUVoRCxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQ3JFRjs7Ozs7Ozs7Ozs7OztVQVdhLDhCQUFBO2VBQUE7O1VBQ0EsOEJBQUE7ZUFBQTs7VUFOQSwyQkFBQTtlQUFBOztVQURBLDBCQUFBO2VBQUE7O1VBR0EsNEJBQUE7ZUFBQTs7VUFKQSx3QkFBQTtlQUFBOztVQWdCQSx3Q0FBQTtlQUFBOztVQUhBLHFDQUFBO2VBQUE7O1VBSEEsaUNBQUE7ZUFBQTs7VUFMQSw0QkFBQTtlQUFBOztVQUNBLDZCQUFBO2VBQUE7O1VBUEEscUJBQUE7ZUFBQTs7VUFZQSxrQ0FBQTtlQUFBOztVQVJBLDRCQUFBO2VBQUE7O1VBV0Esc0NBQUE7ZUFBQTs7VUFGQSxvQ0FBQTtlQUFBOztVQUhBLCtCQUFBO2VBQUE7O1VBTUEsdUNBQUE7ZUFBQTs7VUFqQkEscUJBQUE7ZUFBQTs7VUFxQmIsVUFBQTtlQUFBOzs7QUFyQk8sUUFBTSxxQkFBcUI7QUFDM0IsUUFBTSxxQkFBcUI7QUFDM0IsUUFBTSx3QkFBd0I7QUFDOUIsUUFBTSwwQkFBMEI7QUFDaEMsUUFBTSwyQkFBMkI7QUFDakMsUUFBTSw0QkFBNEI7QUFDbEMsUUFBTSw0QkFBNEI7QUFDbEMsUUFBTSw0QkFBNEI7QUFDbEMsUUFBTSw2QkFBNkI7QUFDbkMsUUFBTSw4QkFBOEI7QUFDcEMsUUFBTSw4QkFBOEI7QUFDcEMsUUFBTSwrQkFBK0I7QUFDckMsUUFBTSxpQ0FBaUM7QUFDdkMsUUFBTSxrQ0FBa0M7QUFDeEMsUUFBTSxvQ0FBb0M7QUFDMUMsUUFBTSxxQ0FBcUM7QUFDM0MsUUFBTSxzQ0FBc0M7QUFDNUMsUUFBTSx1Q0FBdUM7QUFDN0MsUUFBTSx3Q0FBd0M7UUFHckQsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQzFDRjs7Ozs7Ozs7Ozs7OztVQVNhLDhDQUFBO2VBQUE7O1VBTEEsZ0NBQUE7ZUFBQTs7VUFHQSx3Q0FBQTtlQUFBOztVQUdBLDREQUFBO2VBQUE7O1VBRkEsOENBQUE7ZUFBQTs7VUFIQSx1Q0FBQTtlQUFBOztVQUhBLHlCQUFBO2VBQUE7O1VBSUEsd0NBQUE7ZUFBQTs7VUFIQSwwQkFBQTtlQUFBOztVQVNiLFVBQUE7ZUFBQTs7O0FBVk8sUUFBTSx5QkFBeUI7QUFDL0IsUUFBTSwwQkFBMEI7QUFDaEMsUUFBTSxnQ0FBZ0M7QUFDdEMsUUFBTSx1Q0FBdUM7QUFDN0MsUUFBTSx3Q0FBd0M7QUFDOUMsUUFBTSx3Q0FBd0M7QUFDOUMsUUFBTSw4Q0FBOEM7QUFDcEQsUUFBTSw4Q0FBOEM7QUFDcEQsUUFBTSw0REFBNEQ7UUFFekUsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUNyQkY7Ozs7Ozs7Ozs7Ozs7VUFXYSxpQ0FBQTtlQUFBOztVQUNBLGlDQUFBO2VBQUE7O1VBTkEsOEJBQUE7ZUFBQTs7VUFEQSw2QkFBQTtlQUFBOztVQUdBLCtCQUFBO2VBQUE7O1VBSkEsMkJBQUE7ZUFBQTs7VUFnQkEsMkNBQUE7ZUFBQTs7VUFIQSx3Q0FBQTtlQUFBOztVQUhBLG9DQUFBO2VBQUE7O1VBTEEsK0JBQUE7ZUFBQTs7VUFDQSxnQ0FBQTtlQUFBOztVQVBBLHdCQUFBO2VBQUE7O1VBWUEscUNBQUE7ZUFBQTs7VUFSQSwrQkFBQTtlQUFBOztVQVdBLHlDQUFBO2VBQUE7O1VBRkEsdUNBQUE7ZUFBQTs7VUFIQSxrQ0FBQTtlQUFBOztVQU1BLDBDQUFBO2VBQUE7O1VBakJBLHdCQUFBO2VBQUE7O1VBb0JiLFVBQUE7ZUFBQTs7O0FBcEJPLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sMkJBQTJCO0FBQ2pDLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sOEJBQThCO0FBQ3BDLFFBQU0sK0JBQStCO0FBQ3JDLFFBQU0sK0JBQStCO0FBQ3JDLFFBQU0sK0JBQStCO0FBQ3JDLFFBQU0sZ0NBQWdDO0FBQ3RDLFFBQU0saUNBQWlDO0FBQ3ZDLFFBQU0saUNBQWlDO0FBQ3ZDLFFBQU0sa0NBQWtDO0FBQ3hDLFFBQU0sb0NBQW9DO0FBQzFDLFFBQU0scUNBQXFDO0FBQzNDLFFBQU0sdUNBQXVDO0FBQzdDLFFBQU0sd0NBQXdDO0FBQzlDLFFBQU0seUNBQXlDO0FBQy9DLFFBQU0sMENBQTBDO0FBQ2hELFFBQU0sMkNBQTJDO1FBRXhELFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUN6Q0Y7Ozs7Ozs7Ozs7Ozs7VUFPYSxVQUFBO2VBQUE7O1VBSkEsT0FBQTtlQUFBOztVQUtBLFVBQUE7ZUFBQTs7VUFJQSxlQUFBO2VBQUE7O1VBREEsZUFBQTtlQUFBOztVQURBLGNBQUE7ZUFBQTs7VUFOQSxRQUFBO2VBQUE7O1VBS0EsV0FBQTtlQUFBOztVQUhBLFNBQUE7ZUFBQTs7VUFPQSxlQUFBO2VBQUE7O1VBUkEsU0FBQTtlQUFBOztVQUhBLE9BQUE7ZUFBQTs7O0FBQU4sUUFBTSxPQUFPO0FBQ2IsUUFBTSxPQUFPO0FBQ2IsUUFBTSxRQUFRO0FBQ2QsUUFBTSxTQUFTO0FBQ2YsUUFBTSxTQUFTO0FBQ2YsUUFBTSxVQUFVO0FBQ2hCLFFBQU0sVUFBVTtBQUNoQixRQUFNLFdBQVc7QUFDakIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGVBQWU7QUFDckIsUUFBTSxlQUFlOzs7O0FDYjVCOzs7Ozs7Ozs7Ozs7O1VBeVdnQixVQUFBO2VBQUE7O1VBM1RBLE9BQUE7ZUFBQTs7VUEwWkEsaUJBQUE7ZUFBQTs7VUE1REEsZ0JBQUE7ZUFBQTs7VUEwSUEscUJBQUE7ZUFBQTs7VUF6QkEsbUJBQUE7ZUFBQTs7VUF4QkEsa0JBQUE7ZUFBQTs7VUEzREEsZ0JBQUE7ZUFBQTs7VUE1V0EsUUFBQTtlQUFBOztVQXdSQSxVQUFBO2VBQUE7O1VBclBBLFVBQUE7ZUFBQTs7VUE0TkEsV0FBQTtlQUFBOztVQXZRQSxTQUFBO2VBQUE7O1VBY0EsT0FBQTtlQUFBOztVQTBEQSxZQUFBO2VBQUE7O1VBdWFoQixVQUFBO2VBQUE7O1VBcmhCZ0IsU0FBQTtlQUFBOztVQW9CQSxhQUFBO2VBQUE7O1VBbVBBLFVBQUE7ZUFBQTs7VUE3UUEsUUFBQTtlQUFBOztVQW9CQSxZQUFBO2VBQUE7O1VBaU5BLFNBQUE7ZUFBQTs7VUEzQ0EsT0FBQTtlQUFBOztVQWxNQSxRQUFBO2VBQUE7O1VBb0JBLFlBQUE7ZUFBQTs7VUFtYUEsZ0JBQUE7ZUFBQTs7VUE1REEsZUFBQTtlQUFBOztVQTBJQSxvQkFBQTtlQUFBOztVQXBCQSxrQkFBQTtlQUFBOztVQTVCQSxpQkFBQTtlQUFBOztVQTVEQSxlQUFBO2VBQUE7O1VBblpBLFNBQUE7ZUFBQTs7VUFvQkEsYUFBQTtlQUFBOztVQW9CQSxRQUFBO2VBQUE7O1VBTkEsT0FBQTtlQUFBOztVQUZBLE9BQUE7ZUFBQTs7VUFxQ0EsUUFBQTtlQUFBOztVQUZBLFFBQUE7ZUFBQTs7VUF6REEsUUFBQTtlQUFBOztVQW9CQSxZQUFBO2VBQUE7O1VBc1FBLFFBQUE7ZUFBQTs7VUExQ0EsUUFBQTtlQUFBOztVQWhOQSxPQUFBO2VBQUE7O1VBZ0tBLFVBQUE7ZUFBQTs7VUE5REEsVUFBQTtlQUFBOztVQTZNQSxVQUFBO2VBQUE7O1VBN1ZBLFNBQUE7ZUFBQTs7VUFvQkEsYUFBQTtlQUFBOztVQTJWQSxXQUFBO2VBQUE7O1VBcldBLFVBQUE7ZUFBQTs7VUFvQkEsY0FBQTtlQUFBOztVQXRCQSxRQUFBO2VBQUE7O1VBb0JBLFlBQUE7ZUFBQTs7VUF3TUEsU0FBQTtlQUFBOztVQTVMQSxPQUFBO2VBQUE7O1VBeEJBLFFBQUE7ZUFBQTs7VUFkQSxRQUFBO2VBQUE7O1VBb0JBLFlBQUE7ZUFBQTs7VUEwQkEsVUFBQTtlQUFBOzs7QUFsRFQsb0JBQWUsT0FBSztBQUFJLGFBQU8sTUFBTTs7QUFFckMsb0JBQWdCLE9BQUs7QUFBSSxhQUFPLE1BQU07O0FBRXRDLG1CQUFlLE9BQUs7QUFBSSxhQUFPLE1BQU07O0FBRXJDLG9CQUFnQixPQUFLO0FBQUksYUFBTyxNQUFNOztBQUV0QyxtQkFBZSxPQUFLO0FBQUksYUFBTyxNQUFNOztBQUVyQyxtQkFBZSxPQUFLO0FBQUksYUFBTyxNQUFNOztBQUVyQyxxQkFBaUIsT0FBSztBQUFJLGFBQU8sTUFBTTs7QUFFdkMsb0JBQWdCLE9BQUs7QUFBSSxhQUFPLE1BQU07O0FBRXRDLG1CQUFlLE9BQUs7QUFBSSxhQUFPLE1BQU07O0FBRXJDLG1CQUFlLE9BQUs7QUFBSSxhQUFPLE1BQU07O0FBRXJDLHVCQUFtQixPQUFLO0FBQUksYUFBTyxNQUFNLE1BQU0sU0FBUzs7QUFFeEQsd0JBQW9CLE9BQUs7QUFBSSxhQUFPLE1BQU0sTUFBTSxTQUFTOztBQUV6RCx1QkFBbUIsT0FBSztBQUFJLGFBQU8sTUFBTSxNQUFNLFNBQVM7O0FBRXhELHdCQUFvQixPQUFLO0FBQUksYUFBTyxNQUFNLE1BQU0sU0FBUzs7QUFFekQsdUJBQW1CLE9BQUs7QUFBSSxhQUFPLE1BQU0sTUFBTSxTQUFTOztBQUV4RCx1QkFBbUIsT0FBSztBQUFJLGFBQU8sTUFBTSxNQUFNLFNBQVM7O0FBRXhELHlCQUFxQixPQUFLO0FBQUksYUFBTyxNQUFNLE1BQU0sU0FBUzs7QUFFMUQsd0JBQW9CLE9BQUs7QUFBSSxhQUFPLE1BQU0sTUFBTSxTQUFTOztBQUV6RCx1QkFBbUIsT0FBSztBQUFJLGFBQU8sTUFBTSxNQUFNLFNBQVM7O0FBRXhELGtCQUFjLE9BQUs7QUFBSSxhQUFPLE1BQU0sTUFBTSxTQUFTOztBQUVuRCxrQkFBYyxPQUFLO0FBQUksYUFBTyxNQUFNLE1BQU0sR0FBRzs7QUFFN0Msa0JBQWMsT0FBSztBQUFJLGFBQU8sTUFBTSxNQUFNOztBQUUxQyxrQkFBYyxPQUFLO0FBQUksYUFBTyxNQUFNLE1BQU0sTUFBTSxTQUFTOztBQUV6RCxtQkFBZSxPQUFLO0FBQUksYUFBTyxNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksR0FBRyxNQUFNLFNBQVM7O0FBRXpFLGtCQUFjLFFBQVEsUUFBTTtBQUFJLFlBQU0sVUFBVSxLQUFLLE1BQU0sUUFBUTs7QUFFbkUscUJBQWlCLFFBQVEsUUFBTTtBQUFJLFlBQU0sVUFBVSxRQUFRLE1BQU0sUUFBUTs7QUFFekUsb0JBQWdCLFFBQVEsaUJBQWU7QUFDNUMsWUFBTSxTQUFVLDJCQUEyQixRQUN6QixrQkFDQztRQUFFOztBQUVyQixXQUFLLFFBQVE7O0FBR1IsbUJBQWUsT0FBSztBQUN6QixZQUFNLFFBQVE7QUFFZCxhQUFPLE1BQU0sT0FBTzs7QUFHZixrQkFBYyxRQUFRLFFBQU07QUFDakMsWUFBTSxRQUFRLEdBQ1IsY0FBYyxPQUFPO0FBRTNCLGFBQU8sUUFBUSxPQUFPLGFBQWE7O0FBRzlCLG1CQUFlLFFBQVEsUUFBTTtBQUFJLFlBQU0sVUFBVSxLQUFLLE1BQU0sUUFBUTs7QUFFcEUsbUJBQWUsUUFBUSxRQUFRLFVBQVE7QUFDNUMsVUFBSSxVQUFVO0FBRWQsWUFBTSxlQUFlLE9BQU8sUUFDdEIsZUFBZSxPQUFPO0FBRTVCLFVBQUksaUJBQWlCLGNBQWM7QUFDakMsa0JBQVUsT0FBTyxNQUFNLENBQUMsVUFBVSxVQUFBO0FBQ2hDLGdCQUFNLFdBQVcsT0FBTyxRQUNsQixTQUFTLFNBQVMsVUFBVSxVQUFVO0FBRTVDLGNBQUksUUFBUTtBQUNWLG1CQUFPOzs7O0FBS2IsYUFBTzs7QUFHRixxQkFBaUIsUUFBUSxRQUFRLFVBQVE7QUFDOUMsVUFBSSxVQUFVO0FBRWQsWUFBTSxlQUFlLE9BQU8sUUFDdEIsZUFBZSxPQUFPO0FBRTVCLFVBQUksaUJBQWlCLGNBQWM7QUFDakMsaUJBQVM7YUFDSjs7QUFHTCxrQkFBVSxPQUFPLE1BQU0sQ0FBQyxVQUFVLFVBQUE7QUFDaEMsZ0JBQU0sV0FBVyxRQUFRLFFBQVEsQ0FBQyxjQUFBO0FBQ2hDLGtCQUFNLFNBQVMsU0FBUyxVQUFVO0FBRWxDLGdCQUFJLFFBQVE7QUFDVixxQkFBTzs7Z0JBRUw7QUFFTixjQUFJLGFBQWEsTUFBTTtBQUNyQixtQkFBTzs7OztBQUtiLGFBQU87O0FBR0YsdUJBQW1CLFFBQVEsUUFBUSxVQUFRO0FBQ2hELGVBQVM7V0FDSjs7QUFHTCxZQUFNLGFBQWEsT0FBTyxNQUFNLENBQUMsYUFBQTtBQUMvQixjQUFNLFdBQVcsUUFBUSxRQUFRLENBQUMsY0FBQTtBQUNoQyxnQkFBTSxTQUFTLFNBQVMsVUFBVTtBQUVsQyxjQUFJLFFBQVE7QUFDVixtQkFBTzs7Y0FFTDtBQUVOLFlBQUksYUFBYSxNQUFNO0FBQ3JCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLHFCQUFpQixRQUFRLFFBQVEsVUFBUTtBQUM5QyxVQUFJO0FBRUosZUFBUztXQUNKOztBQUdMLGlCQUFTO0FBQ1AsY0FBTSxnQkFBZSxPQUFPO0FBRTVCLFlBQUksa0JBQWlCLEdBQUc7QUFDdEI7O0FBR0YsWUFBSSxZQUFXO0FBRWYsZUFBTyxRQUFRLENBQUMsYUFBQTtBQUNkLGdCQUFNLFNBQVMsU0FBUztBQUV4QixjQUFJLFFBQVE7QUFDVixrQkFBTSxXQUFXO0FBRWpCLG1CQUFPLEtBQUs7QUFFWix3QkFBVzs7O0FBSWYsWUFBSSxDQUFDLFdBQVU7QUFDYjs7QUFHRixlQUFPLFFBQVEsQ0FBQyxhQUFBO0FBQ2QsZ0JBQU0seUJBQXlCLE9BQU8sU0FBUztBQUUvQyxjQUFJLENBQUMsd0JBQXdCO0FBQzNCLG1CQUFPOzs7O0FBS2IsWUFBTSxlQUFlLE9BQU87QUFFNUIsaUJBQVksaUJBQWlCO0FBRTdCLGFBQU87O0FBR0Ysa0JBQWMsT0FBTyxVQUFRO0FBQ2xDLFlBQU0sV0FBVztBQUVqQixzQkFBZ0IsT0FBTyxDQUFDLFNBQVMsVUFBQTtBQUMvQixjQUFNLFNBQVMsU0FBUyxTQUFTO0FBRWpDLFlBQUksUUFBUTtBQUNWLG1CQUFTLEtBQUs7OztBQUlsQixhQUFPOztBQUdGLHFCQUFpQixPQUFPLFNBQVMsVUFBUTtBQUM5QyxVQUFJO0FBRUosWUFBTSxRQUFRLE1BQU0sS0FBSyxDQUFDLFVBQVMsVUFBQTtBQUNqQyxjQUFNLFNBQVMsU0FBUyxVQUFTO0FBRWpDLFlBQUksUUFBUTtBQUNWLGtCQUFRO0FBRVIsaUJBQU87OztBQUlYLFVBQUksT0FBTztBQUNULGNBQU0sY0FBYztBQUVwQixjQUFNLE9BQU8sT0FBTyxhQUFhOztBQUduQyxhQUFPOztBQUdGLG9CQUFnQixRQUFRLE9BQU8sY0FBYyxVQUFVLFNBQVMsSUFBRTtBQUN2RSxZQUFNLE9BQU87UUFBRTtRQUFPO1dBQWdCO1NBQ2hDLGtCQUFrQixNQUFNLFVBQVUsT0FBTyxNQUFNLFFBQVE7QUFFN0QsYUFBTzs7QUFHRixvQkFBZ0IsT0FBTyxVQUFRO0FBQ3BDLFlBQU0sa0JBQWtCO0FBRXhCLHVCQUFpQixPQUFPLENBQUMsU0FBUyxVQUFBO0FBQ2hDLGNBQU0sU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxRQUFRLE9BQ1IsY0FBYyxHQUNkLG1CQUFrQixNQUFNLE9BQU8sT0FBTyxjQUN0QyxzQkFBc0IsT0FBTTtBQUVsQywyQkFBZ0IsUUFBUTs7O0FBSTVCLGFBQU87O0FBR0YsbUJBQWUsT0FBTyxVQUFRO0FBQ25DLFVBQUksaUJBQWlCO0FBRXJCLFlBQU0sS0FBSyxDQUFDLFNBQVMsVUFBQTtBQUNuQixjQUFNLFNBQVMsU0FBUyxTQUFTO0FBRWpDLFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU0sUUFBUSxPQUNSLGNBQWMsR0FDZCxrQkFBa0IsTUFBTSxPQUFPLE9BQU8sY0FDdEMsc0JBQXNCLE9BQU07QUFFbEMsMkJBQWlCO0FBRWpCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLHFCQUFpQixPQUFPLFVBQVE7QUFDckMsVUFBSSxpQkFBaUI7QUFFckIsWUFBTSxLQUFLLENBQUMsU0FBUyxVQUFBO0FBQ25CLGNBQU0sU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxRQUFRO0FBQ1YsZ0JBQU0sUUFBUSxPQUNSLGNBQWMsR0FDZCxrQkFBa0IsTUFBTSxPQUFPLE9BQU8sY0FDdEMsc0JBQXNCLE9BQU07QUFFbEMsMkJBQWlCO0FBRWpCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLG1CQUFlLE9BQU8sU0FBUyxVQUFRO0FBQzVDLFlBQU0sUUFBUSxNQUFNLEtBQUssQ0FBQyxVQUFTLFVBQUE7QUFDakMsY0FBTSxTQUFTLFNBQVMsVUFBUztBQUVqQyxZQUFJLFFBQVE7QUFDVixpQkFBTzs7O0FBS1gsVUFBSSxPQUFPO0FBQ1QsY0FBTSxLQUFLOztBQUdiLGFBQU87O0FBR0Ysc0JBQWtCLE9BQU8sVUFBUTtBQUN0QyxVQUFJLFNBQVMsR0FDVCxTQUFTLE1BQU07QUFFbkIsYUFBTyxTQUFTLFFBQVE7QUFDdEIsY0FBTSxXQUFXLE1BQU07QUFFdkIsaUJBQVMsU0FBUyxTQUFTLEdBQUcsU0FBUyxRQUFRLFVBQVU7QUFDdkQsZ0JBQU0sV0FBVyxNQUFNLFNBQ2pCLFNBQVMsU0FBUyxVQUFVO0FBRWxDLGNBQUksQ0FBQyxRQUFRO0FBQ1gsa0JBQU0sUUFBUSxRQUNSLGNBQWM7QUFFcEIsa0JBQU0sT0FBTyxPQUFPOzs7QUFJeEI7QUFFQSxpQkFBUyxNQUFNOzs7QUFJWixxQkFBaUIsUUFBUSxRQUFRLFVBQVE7QUFDOUMsWUFBTSxRQUFRO1dBQ1Q7V0FDQTs7QUFHTCxlQUFTLE9BQU87QUFFaEIsYUFBTzs7QUFHRixxQkFBaUIsT0FBSztBQUMzQixjQUFRO1dBQ0g7UUFDSDtBQUVGLGFBQU87O0FBR0YscUJBQWlCLFFBQVEsUUFBUSxVQUFRO0FBQzlDLGFBQU8sUUFBUSxDQUFDLFNBQVMsVUFBQTtBQUN2QixjQUFNLFNBQVMsU0FBUyxTQUFTO0FBRWpDLFlBQUksUUFBUTtBQUNWLGlCQUFPLEtBQUs7Ozs7QUFLWCxzQkFBa0IsT0FBTyxRQUFRLFFBQVEsVUFBUTtBQUN0RCxZQUFNLFFBQVEsQ0FBQyxTQUFTLFVBQUE7QUFDdEIsY0FBTSxTQUFTLFNBQVMsU0FBUztBQUVqQyxpQkFDRSxPQUFPLEtBQUssV0FDVixPQUFPLEtBQUs7OztBQUliLDBCQUFzQixPQUFPLFVBQVE7QUFDMUMsWUFBTSxjQUFjLE1BQU07QUFFMUIsZUFBUyxRQUFRLEdBQUcsUUFBUSxhQUFhLFNBQVM7QUFDaEQsY0FBTSxVQUFVLE1BQU0sUUFDaEIsU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxRQUFRO0FBQ1YsaUJBQU87OztBQUlYLGFBQU87O0FBR0YsMkJBQXVCLE9BQU8sVUFBUTtBQUMzQyxZQUFNLGNBQWMsTUFBTTtBQUUxQixlQUFTLFFBQVEsY0FBYyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ3JELGNBQU0sVUFBVSxNQUFNLFFBQ2hCLFNBQVMsU0FBUyxTQUFTO0FBRWpDLFlBQUksUUFBUTtBQUNWLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLDBCQUFzQixPQUFPLFVBQVE7QUFDMUMsWUFBTSxjQUFjLE1BQU07QUFFMUIsZUFBUyxRQUFRLEdBQUcsUUFBUSxhQUFhLFNBQVM7QUFDaEQsY0FBTSxVQUFVLE1BQU0sUUFDaEIsU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxRQUFRO0FBQ1YsaUJBQU87OztBQUlYLGFBQU87O0FBR0YsMkJBQXVCLE9BQU8sVUFBUTtBQUMzQyxZQUFNLGNBQWMsTUFBTTtBQUUxQixlQUFTLFFBQVEsY0FBYyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ3JELGNBQU0sVUFBVSxNQUFNLFFBQ2hCLFNBQVMsU0FBUyxTQUFTO0FBRWpDLFlBQUksUUFBUTtBQUNWLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLDJCQUF1QixPQUFPLFVBQVE7QUFDM0MsWUFBTSxjQUFjLE1BQU07QUFFMUIsZUFBUyxRQUFRLEdBQUcsUUFBUSxhQUFhLFNBQVM7QUFDaEQsY0FBTSxVQUFVLE1BQU0sUUFDaEIsU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxDQUFDLFFBQVE7QUFDWCxpQkFBTzs7O0FBSVgsYUFBTzs7QUFHRiw0QkFBd0IsT0FBTyxVQUFRO0FBQzVDLFlBQU0sY0FBYyxNQUFNO0FBRTFCLGVBQVMsUUFBUSxjQUFjLEdBQUcsU0FBUyxHQUFHLFNBQVM7QUFDckQsY0FBTSxVQUFVLE1BQU0sUUFDaEIsU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxDQUFDLFFBQVE7QUFDWCxpQkFBTzs7O0FBSVgsYUFBTzs7QUFHRiw0QkFBd0IsT0FBTyxVQUFVLGNBQVk7QUFDMUQsVUFBSSxRQUFRO0FBRVosWUFBTSxjQUFjLE1BQU07QUFFMUIsZUFBUyxRQUFRLEdBQUcsUUFBUSxhQUFhLFNBQVM7QUFDaEQsY0FBTSxVQUFVLE1BQU07QUFFdEIsZ0JBQVEsU0FBUyxPQUFPLFNBQVM7O0FBR25DLGFBQU87O0FBR0YsNkJBQXlCLE9BQU8sVUFBVSxjQUFZO0FBQzNELFVBQUksUUFBUTtBQUVaLFlBQU0sY0FBYyxNQUFNO0FBRTFCLGVBQVMsUUFBUSxjQUFjLEdBQUcsU0FBUyxHQUFHLFNBQVM7QUFDckQsY0FBTSxVQUFVLE1BQU07QUFFdEIsZ0JBQVEsU0FBUyxPQUFPLFNBQVM7O0FBR25DLGFBQU87O0FBR0YsNkJBQXlCLE9BQU8sVUFBUTtBQUM3QyxZQUFNLGNBQWMsTUFBTTtBQUUxQixlQUFTLFFBQVEsR0FBRyxRQUFRLGFBQWEsU0FBUztBQUNoRCxjQUFNLFVBQVUsTUFBTTtBQUV0QixpQkFBUyxTQUFTOzs7QUFJZiw4QkFBMEIsT0FBTyxVQUFRO0FBQzlDLFlBQU0sY0FBYyxNQUFNO0FBRTFCLGVBQVMsUUFBUSxjQUFjLEdBQUcsU0FBUyxHQUFHLFNBQVM7QUFDckQsY0FBTSxVQUFVLE1BQU07QUFFdEIsaUJBQVMsU0FBUzs7O0FBSWYsK0JBQTJCLE9BQU8sVUFBUTtBQUMvQyxZQUFNLGNBQWMsTUFBTTtBQUUxQixlQUFTLFFBQVEsR0FBRyxRQUFRLGFBQWEsU0FBUztBQUNoRCxjQUFNLFVBQVUsTUFBTSxRQUNoQixTQUFTLFNBQVMsU0FBUztBQUVqQyxZQUFJLFFBQVE7QUFDVixpQkFBTzs7O0FBSVgsYUFBTzs7QUFHRixnQ0FBNEIsT0FBTyxVQUFRO0FBQ2hELFlBQU0sY0FBYyxNQUFNO0FBRTFCLGVBQVMsUUFBUSxjQUFjLEdBQUcsU0FBUyxHQUFHLFNBQVM7QUFDckQsY0FBTSxVQUFVLE1BQU0sUUFDaEIsU0FBUyxTQUFTLFNBQVM7QUFFakMsWUFBSSxRQUFRO0FBQ1YsaUJBQU87OztBQUlYLGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUM5bEJGOzs7Ozs7Ozs7Ozs7O1VBNEZnQix5QkFBQTtlQUFBOztVQXBEQSxlQUFBO2VBQUE7O1VBaUNBLG1CQUFBO2VBQUE7O1VBbUZoQixVQUFBO2VBQUE7O1VBaklnQixxQkFBQTtlQUFBOztVQXRCQSxhQUFBO2VBQUE7O1VBZ0JBLHFCQUFBO2VBQUE7O1VBUkEsb0JBQUE7ZUFBQTs7VUFvQkEsOEJBQUE7ZUFBQTs7VUErRkEsb0NBQUE7ZUFBQTs7VUFjQSwwQ0FBQTtlQUFBOztVQTVCQSwrQkFBQTtlQUFBOztVQVJBLCtCQUFBO2VBQUE7Ozs7O0FBckdULHdCQUFvQixNQUFJO0FBQzdCLGFBQU8sS0FBSyxRQUFRLE9BQU8sV0FBQSxjQUFjLFFBQVEsT0FBTyxXQUFBO0FBRXhELFlBQU0sV0FBWSxLQUFLLEtBQUssVUFBVTtBQUV0QyxhQUFPOztBQUdGLCtCQUEyQixNQUFJO0FBQ3BDLFlBQU0sV0FBVyxXQUFXLE9BQ3RCLG1CQUFtQixtQkFBbUIsT0FDdEMsa0JBQW1CLFlBQVk7QUFFckMsYUFBTzs7QUFHRixnQ0FBNEIsTUFBSTtBQUNyQyxZQUFNLG1CQUFtQixDQUFDLE1BQU0sS0FBSztBQUVyQyxhQUFPOztBQUdGLGdDQUE0QixNQUFJO0FBQ3JDLFlBQU0sbUJBQW1CLE1BQU0sS0FBSztBQUVwQyxhQUFPOztBQUdGLHlDQUFxQyxhQUFhLGNBQVk7QUFDbkUsWUFBTSxTQUFTLElBQUksT0FBTyxJQUFJLDJCQUN4Qiw0QkFBNEIsT0FBTyxLQUFLO0FBRTlDLGFBQU87O0FBR0YsMEJBQXNCLE1BQU0sY0FBWTtBQUM3QyxVQUFJLGVBQWU7QUFFbkIsWUFBTSxZQUFZLEtBQUssTUFBTSxPQUN2QixvQkFBb0IsYUFBYSxNQUFNO0FBRTdDLFVBQUksY0FDQSx3QkFBd0IsSUFBQSxPQUFBLE9BQU07QUFFbEMsVUFBSSwwQkFBMEIsS0FBSztBQUNqQywwQkFBa0I7O0FBR3BCLDhCQUF3QixJQUFBLE9BQUEsT0FBTTtBQUM5QixxQkFBZSxJQUFBLE9BQUEsTUFBSztBQUVwQixhQUFRLDBCQUEwQixRQUFVLGlCQUFpQixRQUFZO0FBQ3ZFLDBCQUFrQjtBQUNsQixrQkFBVTtBQUVWLGdDQUF3QixJQUFBLE9BQUEsT0FBTTtBQUM5Qix1QkFBZSxJQUFBLE9BQUEsTUFBSzs7QUFHdEIsVUFBSSxpQkFBaUIsUUFBVztBQUM5QixjQUFNLG9CQUFvQixHQUFHLE9BQU8sV0FBVyxPQUFPO0FBRXRELHVCQUFlLGtCQUFrQixLQUFLOztBQUd4QyxhQUFPOztBQUdGLDhCQUEwQixNQUFNLGlCQUFpQixvQkFBa0I7QUFDeEUsVUFBSTtBQUVKLGFBQU8sS0FBSyxRQUFRLE9BQU8sV0FBQTtBQUUzQix5QkFBbUIsR0FBRyxRQUFRO0FBRTlCLFlBQU0sNEJBQTRCLG1CQUFtQjtBQUVyRCxVQUFJLDRCQUE0QixHQUFHO0FBQ2pDLGNBQU0sUUFBTyxrQkFDUCxnQkFBZSxtQkFBbUI7QUFFeEMsMkJBQW1CLGlCQUFpQixPQUFNLGVBQUEsR0FBaUI7O0FBRzdELGFBQU87O0FBR0Ysb0NBQWdDLE1BQUk7QUFDekMsVUFBSSxpQkFBaUI7QUFFckIsWUFBTSxVQUFVLEtBQUssTUFBTTtBQUUzQixVQUFJLFlBQVksTUFBTTtBQUNwQixjQUFNLGNBQWMsSUFBQSxPQUFBLFFBQU87QUFFM0IseUJBQWlCOztBQUduQixhQUFPOztBQUdGLDBDQUFzQyxNQUFJO0FBQy9DLFlBQU0sVUFBVSxLQUFLLE1BQU0sc0JBQ3JCLGNBQWMsSUFBQSxPQUFBLFFBQU8sVUFDckIsdUJBQXVCO0FBRTdCLGFBQU87O0FBR0YsMENBQXNDLE1BQUk7QUFDL0MsVUFBSSx1QkFBdUI7QUFFM0IsWUFBTSxVQUFVLEtBQUssTUFBTTtBQUUzQixVQUFJLFlBQVksTUFBTTtBQUNwQixjQUFNLGNBQWMsSUFBQSxPQUFBLFFBQU87QUFFM0IsK0JBQXVCOztBQUd6QixhQUFPOztBQUdGLCtDQUEyQyxNQUFJO0FBQ3BELFVBQUksNEJBQTRCO0FBRWhDLFlBQU0sVUFBVSxLQUFLLE1BQU07QUFFM0IsVUFBSSxZQUFZLE1BQU07QUFDcEIsY0FBTSxjQUFjLElBQUEsT0FBQSxRQUFPO0FBRTNCLG9DQUE0Qjs7QUFHOUIsYUFBTzs7QUFHRixxREFBaUQsTUFBSTtBQUMxRCxVQUFJLGtDQUFrQztBQUV0QyxZQUFNLFVBQVUsS0FBSyxNQUFNO0FBRTNCLFVBQUksWUFBWSxNQUFNO0FBQ3BCLGNBQU0sY0FBYyxJQUFBLE9BQUEsUUFBTztBQUUzQiwwQ0FBa0M7O0FBR3BDLGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUN4S0Y7Ozs7Ozs7Ozs7Ozs7VUFzR0EsVUFBQTtlQUFBOztVQXJDZ0IsbUJBQUE7ZUFBQTs7VUEzREEsWUFBQTtlQUFBOztVQWdDQSxlQUFBO2VBQUE7O1VBbUNBLHVCQUFBO2VBQUE7O1VBZEEsaUJBQUE7ZUFBQTs7VUFyQ0EsYUFBQTtlQUFBOztVQXVFQSx5QkFBQTtlQUFBOzs7Ozs7QUF2RlQsdUJBQW1CLFNBQVMsTUFBTSxPQUFLO0FBQzVDLFlBQU0sZ0JBQWdCLEtBQUssZUFDckIsZ0JBQWdCLE9BQU8sb0JBQW9CLFVBQzNDLGVBQWUsY0FBYyxLQUFLLENBQUMsa0JBQUE7QUFDakMsY0FBTSx3QkFBd0IsY0FBYTtBQUUzQyxZQUFJLDBCQUEwQixlQUFlO0FBQzNDLGlCQUFPOztZQUVMO0FBRVosVUFBSSxpQkFBaUIsTUFBTTtBQUN6QixnQkFBUSxnQkFBZ0I7OztBQUlyQix3QkFBb0IsU0FBUyxNQUFNLE9BQUs7QUFDN0MsWUFBTSxnQkFBZ0IsS0FBSyxlQUNyQixnQkFBZ0IsT0FBTyxvQkFBb0IsVUFDM0MsZUFBZSxjQUFjLEtBQUssQ0FBQyxrQkFBQTtBQUNqQyxjQUFNLHdCQUF3QixjQUFhO0FBRTNDLFlBQUksMEJBQTBCLGVBQWU7QUFDM0MsaUJBQU87O1lBRUw7QUFFWixVQUFJLGlCQUFpQixNQUFNO0FBQ3pCLGdCQUFRLFFBQVE7OztBQUliLDBCQUFzQixNQUFJO0FBQy9CLFVBQUk7QUFFSixZQUFNLFVBQVUsS0FBSyxNQUFNLHlCQUNyQixjQUFjLElBQUEsT0FBQSxRQUFPLFVBQ3JCLFFBQVEsWUFBWSxRQUFRLFlBQUE7QUFFbEMsVUFBSSxVQUFVLElBQUk7QUFDaEIsY0FBTSxTQUFTLGVBQWU7QUFFOUIsZUFBTyxTQUFTLE1BQU07YUFDakI7QUFDTCxjQUFNLFFBQVEsUUFBUSxHQUNoQixhQUFhLFlBQVksVUFBVTtBQUV6QyxlQUFPLE9BQU87O0FBR2hCLGFBQU87O0FBR0YsNEJBQXdCLE1BQUk7QUFDakMsWUFBTSxTQUFTLGNBQWMsS0FBSztBQUVsQyxhQUFPOztBQUdGLDhCQUEwQixNQUFJO0FBQ25DLFlBQU0sVUFBVSxLQUFLLE1BQU0sMEJBQ3JCLGNBQWMsSUFBQSxPQUFBLFFBQU8sVUFDckIsV0FBVztBQUVqQixhQUFPOztBQUdGLGtDQUE4QixPQUFLO0FBQ3hDLFlBQU0sUUFBUSxPQUFPLEtBQUssUUFDcEIsY0FBYyxNQUFNLFFBQ3BCLFlBQVksY0FBYyxHQUMxQixjQUFjLE1BQU0sT0FBTyxDQUFDLGNBQWEsTUFBTSxVQUFBO0FBQzdDLGNBQU0sUUFBUSxNQUFNLE9BQ2QsY0FBYyxtQkFBbUIsT0FDakMsZUFBZSxtQkFBbUIsUUFDbEMscUJBQXNCLFVBQVUsWUFDVCxZQUFBLHNCQUNFLFdBQUE7QUFFL0Isd0JBQWUsR0FBRyxlQUFlLGVBQWU7QUFFaEQsZUFBTztTQUNOLFdBQUE7QUFFVCxhQUFPOztBQUdGLG9DQUFnQyxNQUFNLEtBQUssT0FBSztBQUNyRCxZQUFNLGNBQWMscUJBQXFCLFFBQ25DLE1BQU8sZ0JBQWdCLFdBQUEsZUFDZixHQUFHLE9BQU8sUUFDUixHQUFHLE9BQU8sT0FBTztBQUVqQyxhQUFPOztRQUdULFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUM3R0Y7Ozs7Ozs7Ozs7Ozs7VUErSEEsVUFBQTtlQUFBOztVQXZFZ0IsVUFBQTtlQUFBOztVQXBDQSxTQUFBO2VBQUE7O1VBaEJBLFNBQUE7ZUFBQTs7VUFnR0EsWUFBQTtlQUFBOzs7O0FBaEdULG9CQUFnQixRQUFNO0FBQzNCLFVBQUksU0FBUztBQUViLFlBQU0sV0FBVyxPQUFPLE9BQU87QUFFL0IsVUFBSSxZQUFZLFNBQVM7QUFFekIsYUFBTyxDQUFDLFVBQVUsTUFBTTtBQUN0QixvQkFBWSxTQUFTO0FBRXJCOztBQUdGLGFBQU87O0FBR0Ysb0JBQWdCLFNBQVMsU0FBTztBQUNyQyxVQUFJO0FBRUosWUFBTSxZQUFZLFFBQVEsT0FBTyxhQUMzQixZQUFZLFFBQVEsT0FBTztBQUVqQyxVQUFJLGFBQWEsVUFBVSxRQUN2QixhQUFhLFVBQVUsUUFDdkIsWUFDQTtBQUVKLGFBQU8sTUFBTTtBQUNYLHFCQUFhLFdBQVcsUUFDVCxXQUFXLE1BQU0sWUFBWSxLQUMzQjtBQUNqQixxQkFBYSxXQUFXLFFBQ1QsV0FBVyxNQUFNLFlBQVksS0FDM0I7QUFFakIscUJBQWEsYUFBYTtBQUUxQixZQUFJLGVBQWUsR0FBRztBQUNwQjs7QUFHRixZQUFJLFdBQVcsUUFBUSxXQUFXLE1BQU07QUFDdEM7O0FBR0YscUJBQWEsVUFBVTtBQUN2QixxQkFBYSxVQUFVOztBQUd6QixhQUFPOztBQUdGLHFCQUFpQixRQUFRLGNBQVk7QUFDMUMsVUFBSSxRQUFRLElBQ1IsUUFBUTtBQUVaLFlBQU0scUJBQXFCLE9BQU87QUFFbEMsVUFBSSxxQkFBcUIsR0FBRztBQUMxQixZQUFJO0FBRUosY0FBTSxXQUFXLE9BQU8sT0FBTyxhQUN6QixpQkFBaUIsYUFBYSxPQUFPLGFBQ3JDLGtCQUFrQixlQUFlO0FBRXZDLG9CQUFZLFNBQVM7QUFFckI7QUFFQSxlQUFPLENBQUMsVUFBVSxNQUFNO0FBQ3RCLGNBQUksVUFBVSxVQUFVLGdCQUFnQixPQUFPO0FBQzdDLGtCQUFNLFFBQVEsT0FDUixNQUFNLFFBQVEsb0JBQ2QsWUFBWSxVQUFVLFFBQVEsT0FBTyxNQUNyQyxhQUFhLE9BQU8sV0FBVztBQUVyQyxnQkFBSSxlQUFlLEdBQUc7QUFDcEIsc0JBQVE7QUFFUjs7O0FBSUosc0JBQVksU0FBUztBQUVyQjs7O0FBSUosVUFBSSxDQUFDLE9BQU87QUFDVixnQkFBUTs7QUFHVixhQUFPOztBQUdGLHVCQUFtQixRQUFRLE9BQU8sTUFBTSxVQUFRO0FBQ3JELFVBQUksUUFBUTtBQUVaLFlBQU0sV0FBVyxPQUFPLE9BQU8sYUFDekIsYUFBYTtBQUVuQixVQUFJLFlBQVksU0FBUztBQUV6QixhQUFPLENBQUMsVUFBVSxNQUFNO0FBQ3RCLFlBQUksVUFBVSxLQUFLO0FBQ2pCOztBQUdGLFlBQUksU0FBUyxPQUFPO0FBQ2xCLHFCQUFXLEtBQUssVUFBVTs7QUFHNUI7QUFFQSxvQkFBWSxTQUFTOztBQUd2QixZQUFNLGFBQVksV0FBVyxLQUFLLFdBQUE7QUFFbEMsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDbklGOzs7Ozs7Ozs7Ozs7O1VBZ0JBLFVBQUE7ZUFBQTs7VUFkZ0IsVUFBQTtlQUFBOzs7QUFBVCxxQkFBaUIsTUFBTSxjQUFjLGVBQWE7QUFDdkQsVUFBSSxDQUFFLFdBQVk7QUFFbEIsYUFBTyxZQUFZLGVBQWU7QUFDaEMsY0FBTSxrQkFBa0IsYUFBYTtBQUVyQyxlQUFPLGdCQUFnQjtBQUV0QixRQUFBLEVBQUUsV0FBWTs7QUFHakIsYUFBTzs7UUFHVCxXQUFlO01BQ2I7Ozs7O0FDakJGOzs7Ozs7Ozs7Ozs7O1VBdUlnQixtQkFBQTtlQUFBOztVQXVCaEIsVUFBQTtlQUFBOztVQWhHZ0IsYUFBQTtlQUFBOztVQTlDQSxVQUFBO2VBQUE7O1VBZ0dBLGtCQUFBO2VBQUE7O1VBeEJBLGFBQUE7ZUFBQTs7VUFqREEsV0FBQTtlQUFBOztVQXJDQSxTQUFBO2VBQUE7OztBQUFULG9CQUFnQixXQUFXLE1BQU0sVUFBTztBQUM3QyxVQUFJLFFBQVE7QUFFWixzQkFBUztBQUNQO0FBRUEsY0FBTSxRQUFRO0FBRWQsa0JBQVUsTUFBTSxNQUFNLFVBQVM7O0FBR2pDOztBQUdLLHFCQUFpQixPQUFPLFdBQVcsTUFBTSxVQUFPO0FBQ3JELFlBQU0sU0FBUyxNQUFNO0FBRXJCLFVBQUksUUFBUTtBQUVaLHNCQUFTO0FBQ1A7QUFFQSxjQUFNLFlBQWEsVUFBVTtBQUU3QixZQUFJLFdBQVc7QUFDYjtlQUNLO0FBQ0wsZ0JBQU0sUUFBUSxPQUNSLFVBQVUsTUFBTTtBQUV0QixvQkFBVSxTQUFTLE1BQU0sTUFBTSxVQUFTOzs7QUFJNUM7O0FBR0ssc0JBQWtCLFlBQVksTUFBTSxVQUFPO0FBQ2hELFlBQU0sU0FBUyxXQUFXO0FBRTFCLFVBQUksUUFBUTtBQUVaLHNCQUFTO0FBQ1A7QUFFQSxjQUFNLFlBQWEsVUFBVTtBQUU3QixZQUFJLFdBQVc7QUFDYjtlQUNLO0FBQ0wsZ0JBQU0sUUFBUSxPQUNSLFlBQVksV0FBVztBQUU3QixvQkFBVSxNQUFNLE1BQU0sVUFBUzs7O0FBSW5DOztBQUdLLHdCQUFvQixZQUFZLE1BQU0sVUFBTztBQUNsRCxZQUFNLFNBQVMsV0FBVztBQUUxQixVQUFJLFdBQVcsR0FBRztBQUNoQjtBQUVBOztBQUdGLFVBQUksUUFBUTtBQUVaLHNCQUFTO0FBQ1A7QUFFQSxjQUFNLFlBQWEsVUFBVTtBQUU3QixZQUFJLFdBQVc7QUFDYjs7O0FBSUosaUJBQVcsUUFBUSxDQUFDLFdBQVcsVUFBQTtBQUM3QixrQkFBVSxNQUFNLE1BQU0sVUFBUzs7O0FBSTVCLHdCQUFvQixXQUFXLFFBQVEsTUFBTSxVQUFPO0FBQ3pELFVBQUksV0FBVyxHQUFHO0FBQ2hCO0FBRUE7O0FBR0YsVUFBSSxRQUFRO0FBRVosc0JBQVM7QUFDUDtBQUVBLGNBQU0sWUFBYSxVQUFVO0FBRTdCLFlBQUksV0FBVztBQUNiOzs7QUFJSixlQUFTLFFBQVEsR0FBRyxRQUFRLFFBQVEsU0FBUztBQUMzQyxrQkFBVSxNQUFNLE1BQU0sVUFBUzs7O0FBSTVCLDZCQUF5QixPQUFPLFdBQVcsTUFBTSxVQUFPO0FBQzdELFlBQU0sU0FBUyxNQUFNO0FBRXJCLFVBQUksUUFBUTtBQUVaLHNCQUFTO0FBQ1A7QUFFQSxjQUFNLFlBQWEsVUFBVTtBQUU3QixZQUFJLFdBQVc7QUFDYjtlQUNLO0FBQ0wsZ0JBQU0sUUFBUSxPQUNSLFVBQVUsTUFBTTtBQUV0QixvQkFBVSxTQUFTLE1BQU0sTUFBTSxVQUFTOzs7QUFJNUM7O0FBR0ssOEJBQTBCLE9BQU8sV0FBVyxNQUFNLFVBQU87QUFDOUQsWUFBTSxTQUFTLE1BQU07QUFFckIsVUFBSSxRQUFRO0FBRVosc0JBQVM7QUFDUDtBQUVBLGNBQU0sWUFBYSxVQUFVO0FBRTdCLFlBQUksV0FBVztBQUNiO2VBQ0s7QUFDTCxnQkFBTSxRQUFRLE9BQ1IsVUFBVSxNQUFNO0FBRXRCLG9CQUFVLFNBQVMsTUFBTSxNQUFNLFVBQVM7OztBQUk1Qzs7UUFHRixXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDcktGOzs7Ozs7Ozs7Ozs7O1VBOEhBLFVBQUE7ZUFBQTs7VUF0SGdCLE1BQUE7ZUFBQTs7VUE4QkEsT0FBQTtlQUFBOztVQWdDQSxVQUFBO2VBQUE7Ozs7Ozs7O0FBOURULGlCQUFhLE1BQU0sS0FBSyxPQUFPLFNBQVMsY0FBYyxVQUFRO0FBQ25FLFVBQUksT0FBTyxZQUFZLFdBQUEsVUFBVTtBQUMvQixtQkFBVztBQUVYLHVCQUFlO0FBRWYsa0JBQVU7O0FBR1osVUFBSSxPQUFPLGlCQUFpQixXQUFBLFVBQVU7QUFDcEMsbUJBQVc7QUFFWCxZQUFJLE9BQU8sWUFBWSxXQUFBLFFBQVE7QUFDN0IseUJBQWU7QUFFZixvQkFBVTtlQUNMO0FBQ0wseUJBQWU7OztBQUluQixZQUFNLFNBQVMsU0FBQSxZQUNULFNBQVMsY0FBQSwrQkFDVCxVQUFVO0FBRWhCLDZCQUF1QixTQUFTO0FBRWhDLGNBQVEsTUFBTSxLQUFLLE9BQU8sUUFBUSxTQUFTLFNBQVMsY0FBYzs7QUFHN0Qsa0JBQWMsTUFBTSxLQUFLLE9BQU8sU0FBUyxTQUFTLGNBQWMsVUFBUTtBQUM3RSxVQUFJLE9BQU8sWUFBWSxXQUFBLFVBQVU7QUFDL0IsbUJBQVc7QUFFWCx1QkFBZTtBQUVmLGtCQUFVOztBQUdaLFVBQUksT0FBTyxpQkFBaUIsV0FBQSxVQUFVO0FBQ3BDLG1CQUFXO0FBRVgsWUFBSSxPQUFPLFlBQVksV0FBQSxRQUFRO0FBQzdCLHlCQUFlO0FBRWYsb0JBQVU7ZUFDTDtBQUNMLHlCQUFlOzs7QUFJbkIsWUFBTSxTQUFTLFNBQUEsYUFDVCxTQUFTLGNBQUEsK0JBQ1QsY0FBYyxjQUFBO0FBRXBCLDZCQUF1QixTQUFTO0FBRWhDLGtDQUE0QixTQUFTO0FBRXJDLGNBQVEsTUFBTSxLQUFLLE9BQU8sUUFBUSxTQUFTLFNBQVMsY0FBYzs7QUFHN0QscUJBQWlCLE1BQU0sS0FBSyxPQUFPLFFBQVEsU0FBUyxTQUFTLGNBQWMsVUFBUTtBQUN4RixZQUFNLE1BQU0sSUFBQSxNQUFBLHdCQUF1QixNQUFNLEtBQUssUUFDeEMsU0FBUyxRQUFRLFNBQUEsa0JBQWtCLE1BQ25DLGNBQWMsUUFBUSxTQUFBLHdCQUF3QixNQUM5QyxpQkFBaUIsSUFBSTtBQUUzQixVQUFJLGdCQUFnQixjQUFBLCtCQUErQjtBQUNqRCxjQUFNLE9BQU8sU0FDUCxhQUFhLEtBQUssVUFBVTtBQUVsQyxrQkFBVTs7QUFHWixVQUFJLGlCQUFpQixNQUFNO0FBQ3pCLGVBQU8sT0FBTyxnQkFBZ0I7VUFDNUI7OztBQUlKLHFCQUFlLHFCQUFxQixNQUFBO0FBQ2xDLGNBQU0sQ0FBRSxZQUFZLFFBQVEsWUFBYSxnQkFDbkMsYUFBYTtBQUVuQixZQUFJLGNBQWMsR0FBRztBQUNuQixjQUFJLFdBQVU7QUFFZCxjQUFJLFdBQVcsY0FBQSwrQkFBK0I7QUFDNUMsZ0JBQUk7QUFDRixvQkFBTSxhQUFhLFVBQ2IsT0FBTyxLQUFLLE1BQU07QUFFeEIseUJBQVU7cUJBQ0gsT0FBUDtBQUNBLHlCQUFVOzs7QUFJZCxtQkFBUyxVQUFTOzs7QUFJdEIscUJBQWUsS0FBSyxRQUFRO0FBRTVCLFVBQUksV0FBVyxNQUFNO0FBQ25CLHVCQUFlLGlCQUFpQixTQUFBLGVBQWU7O0FBR2pELFVBQUksZ0JBQWdCLE1BQU07QUFDeEIsdUJBQWUsaUJBQWlCLFNBQUEscUJBQXFCOztBQUd0RCxrQkFBWSxPQUNYLGVBQWUsS0FBSyxXQUNsQixlQUFlOztRQUdyQixXQUFlO01BQ2I7TUFDQTtNQUNBOztBQUdGLG9DQUFnQyxTQUFTLFFBQU07QUFDN0MsWUFBTSxPQUFPLFNBQUEsZUFDUCxRQUFRO0FBRWQsTUFBQSxJQUFBLE1BQUEsWUFBVyxTQUFTLE1BQU07O0FBRzVCLHlDQUFxQyxTQUFTLGFBQVc7QUFDdkQsWUFBTSxPQUFPLFNBQUEscUJBQ1AsUUFBUTtBQUVkLE1BQUEsSUFBQSxNQUFBLFlBQVcsU0FBUyxNQUFNOzs7OztBQy9JNUI7Ozs7Ozs7Ozs7Ozs7VUFtQm9CLGdCQUFBO2VBQUEsTUFBQTs7VUFMQSxpQkFBQTtlQUFBLE9BQUE7O1VBR0Esd0JBQUE7ZUFBQSxjQUFBOztVQVZBLGFBQUE7ZUFBQSxZQUFBOztVQUVBLGVBQUE7ZUFBQSxjQUFBOztVQUhBLFlBQUE7ZUFBQSxXQUFBOztVQUZBLFVBQUE7ZUFBQSxTQUFBOztVQVNBLGdCQUFBO2VBQUEsTUFBQTs7VUFSQSxXQUFBO2VBQUEsVUFBQTs7VUFIQSxTQUFBO2VBQUEsUUFBQTs7VUFDQSxVQUFBO2VBQUEsU0FBQTs7VUFTQSxnQkFBQTtlQUFBLE1BQUE7O1VBSkEsY0FBQTtlQUFBLGFBQUE7O1VBRUEsaUJBQUE7ZUFBQSxnQkFBQTs7VUFLQSxrQkFBQTtlQUFBLFFBQUE7O1VBQ0EsbUJBQUE7ZUFBQSxTQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQnBCOzs7Ozs7Ozs7Ozs7O1VBR2EsZUFBQTtlQUFBOztVQUNBLG9CQUFBO2VBQUE7O1VBRUEsdUJBQUE7ZUFBQTs7VUFEQSxvQkFBQTtlQUFBOztVQUhBLElBQUE7ZUFBQTs7O0FBQU4sUUFBTSxJQUFJO0FBQ1YsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sdUJBQXVCOzs7O0FDTnBDOzs7OzttQ0FJZ0IsbUJBQUE7OztlQUFBOzs7O0FBQVQsNkJBQXlCLFNBQU87QUFDckMsWUFBTSxtQkFBbUIsUUFDRyxRQUFRLE1BQU0sV0FBQSxtQkFDZCxRQUFRLE1BQU0sV0FBQSxtQkFDZCxRQUFRLE1BQU0sV0FBQTtBQUUxQyxhQUFPOzs7OztBQ1ZUOzs7Ozs7Ozs7Ozs7O1VBS2EsY0FBQTtlQUFBOztVQVdiLFVBQUE7ZUFBQTs7VUFQYSx1QkFBQTtlQUFBOztVQUhBLGdCQUFBO2VBQUE7O1VBTUEsNEJBQUE7ZUFBQTs7VUFFQSwrQkFBQTtlQUFBOztVQVhBLFdBQUE7ZUFBQTs7VUFDQSxhQUFBO2VBQUE7O1VBT0Esd0JBQUE7ZUFBQTs7VUFEQSx3QkFBQTtlQUFBOztVQUdBLDhCQUFBO2VBQUE7O1VBTEEsb0JBQUE7ZUFBQTs7VUFOQSxXQUFBO2VBQUE7O1VBS0EsaUJBQUE7ZUFBQTs7O0FBTE4sUUFBTSxXQUFXO0FBQ2pCLFFBQU0sV0FBVztBQUNqQixRQUFNLGFBQWE7QUFDbkIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sZ0JBQWdCO0FBQ3RCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sdUJBQXVCLEdBQUcsaUJBQWlCO0FBQ2pELFFBQU0sd0JBQXdCLGVBQWU7QUFDN0MsUUFBTSx3QkFBd0I7QUFDOUIsUUFBTSw0QkFBNEIscUJBQXFCO0FBQ3ZELFFBQU0sOEJBQThCLHVCQUF1QjtBQUMzRCxRQUFNLCtCQUErQix3QkFBd0I7UUFFcEUsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQzdCRjs7Ozs7bUNBVUEsV0FBQTs7O2VBQXFCOzs7Ozs7QUFIckIsUUFBTSxDQUFFLGlCQUFVLFdBQUE7QUFBbEIsUUFDTSxDQUFFLFVBQVcsV0FBQTtBQUVKLHNCQUFNO01BQ25CLFlBQVksTUFBTSxTQUFTLGFBQWE7QUFDdEMsYUFBSyxPQUFPO0FBQ1osYUFBSyxVQUFVO0FBQ2YsYUFBSyxjQUFjOztNQUdyQixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsaUJBQWlCLFFBQVEsT0FBTztBQUM5QixjQUFNLGdCQUFnQixRQUNFLEtBQUssUUFBUSxTQUNYLE9BQU8sS0FBSztBQUV0QyxlQUFPOztNQUdULGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxpQkFBaUI7QUFDZixjQUFNLDBCQUEwQixLQUFLLEtBQUssU0FBUyxPQUFBLGNBQzdDLGVBQWU7QUFFckIsZUFBTzs7TUFHVCxtQkFBbUI7QUFDakIsY0FBTSxvQkFBcUIsS0FBSyxLQUFLLFNBQVMsT0FBQSxnQkFDeEMsaUJBQWlCO0FBRXZCLGVBQU87O01BR1Qsb0JBQW9CO0FBQ2xCLGNBQU0scUJBQXNCLEtBQUssU0FBUyxPQUFBLGdCQUNwQyxrQkFBa0I7QUFFeEIsZUFBTzs7TUFHVCxNQUFNLE9BQU87QUFDWCxZQUFJLFVBQVU7QUFFZCxZQUFJLFVBQVUsTUFBTTtBQUNsQixnQkFBTSxPQUFPLE1BQU0sV0FDYixVQUFVLE1BQU0sY0FDaEIsY0FBYyxNQUFNO0FBRTFCLG9CQUFZLEtBQUssU0FBUyxRQUFVLEtBQUssWUFBWSxXQUFhLEtBQUssZ0JBQWdCOztBQUd6RixlQUFPOztNQUdULFNBQVM7QUFDUCxjQUFNLFlBQVksS0FBSyxNQUNqQixtQkFBbUIsSUFBQSxTQUFBLGlCQUFnQixLQUFLLFVBQ3hDLE9BQU8sZ0JBQWdCLGNBQWM7QUFFM0MsZUFBTzs7TUFHVCxTQUFTLG9CQUFvQjtBQUMzQixjQUFNLFFBQVEsS0FBSyxhQUNiLE9BQU8sS0FBSyxNQUNaLFVBQVUsS0FBSyxTQUNmLGNBQWMsS0FBSyxhQUNuQixRQUFRLElBQUksTUFBTSxNQUFNLFNBQVMsYUFBQSxHQUFnQjtBQUV2RCxlQUFPOzthQUdGLE1BQU0sT0FBTyxTQUFTLGdCQUFnQixvQkFBb0I7QUFDL0QsWUFBSSxRQUFRO0FBRVosY0FBTSxDQUFFLHFCQUFzQixPQUN4QixVQUFVLFFBQVEsTUFBTTtBQUU5QixZQUFJLFlBQVksTUFBTTtBQUNwQixnQkFBTSxDQUFFLFNBQVU7QUFFbEIsY0FBSSxVQUFVLEdBQUc7QUFDZixrQkFBTSxhQUFhLE9BQU07QUFFekIsc0JBQVU7QUFFVixrQkFBTSxnQkFBZ0IsUUFBUTtBQUU5QixnQkFBSSxnQkFBZ0IsR0FBRztBQUNyQixvQkFBTSxDQUFFLFFBQVM7QUFFakIsc0JBQVEsSUFBSSxNQUFNLE1BQU0sU0FBUyxhQUFBLEdBQWdCOzs7O0FBS3ZELGVBQU87O2FBR0YsWUFBWSxPQUFPLFNBQVMsZ0JBQWdCLG9CQUFvQjtBQUNyRSxjQUFNLENBQUUsUUFBUyxPQUNYLFFBQVEsSUFBSSxNQUFNLE1BQU0sU0FBUyxhQUFBLEdBQWdCO0FBRXZELGVBQU87O2FBR0YsbUJBQW1CLE9BQU8sU0FBUyxNQUFNLGdCQUFnQixvQkFBb0I7QUFBRSxlQUFPLElBQUksTUFBTSxNQUFNLFNBQVMsYUFBQSxHQUFnQjs7Ozs7O0FDNUh4STs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTix5Q0FBK0IsT0FBQSxRQUFLO2FBQzFDLE1BQU0sT0FBTyxZQUFZLG9CQUFvQjtBQUNsRCxZQUFJLFlBQVksUUFBVztBQUN6QixvQkFBVTtBQUVWLGtCQUFROztBQUdWLGNBQU0sY0FBYyxNQUNkLG1CQUFtQixPQUFBLFFBQU0sTUFBTSxPQUFPLFNBQVMsYUFBQSxHQUFnQjtBQUVyRSxlQUFPOzthQUdGLFlBQVksT0FBTyxZQUFZLG9CQUFvQjtBQUN4RCxZQUFJLFlBQVksUUFBVztBQUN6QixvQkFBVTtBQUVWLGtCQUFROztBQUdWLGNBQU0sY0FBYyxNQUNkLG1CQUFtQixPQUFBLFFBQU0sWUFBWSxPQUFPLFNBQVMsYUFBQSxHQUFnQjtBQUUzRSxlQUFPOzthQUdGLG1CQUFtQixPQUFPLFNBQVMsU0FBUyxvQkFBb0I7QUFDckUsWUFBSSxTQUFTLFFBQVc7QUFDdEIsaUJBQU87QUFFUCxvQkFBVTtBQUVWLGtCQUFROztBQUdWLGNBQU0sY0FBYyxNQUNkLG1CQUFtQixPQUFBLFFBQU0sbUJBQW1CLE9BQU8sU0FBUyxNQUFNLGFBQUEsR0FBZ0I7QUFFeEYsZUFBTzs7Ozs7O0FDM0NYOzs7OzttQ0FVQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRUgscUJBQU07TUFDbkIsWUFBWSxNQUFNLG1CQUFtQjtBQUNuQyxhQUFLLE9BQU87QUFDWixhQUFLLG9CQUFvQjs7TUFHM0IsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCx1QkFBdUI7QUFDckIsZUFBTyxLQUFLOztNQUdkLE1BQU0sU0FBUztBQUNiLFlBQUksbUJBQW1CO0FBRXZCLGNBQU0sVUFBVSxRQUFRLE1BQU0sS0FBSztBQUVuQyxZQUFJLFlBQVksTUFBTTtBQUNwQixnQkFBTSxDQUFFLFNBQVU7QUFFbEIsY0FBSSxVQUFVLEdBQUc7QUFDZixrQkFBTSxhQUFhLE9BQU07QUFFekIsc0JBQVU7QUFFVixrQkFBTSxnQkFBZ0IsUUFBUTtBQUU5QixnQkFBSSxnQkFBZ0IsR0FBRztBQUNyQixpQ0FBbUIsYUFBQSxRQUFpQixtQkFBbUIsU0FBUyxLQUFLOzs7O0FBSzNFLGVBQU87O2FBR0YsVUFBVSxPQUFPO0FBQ3RCLGNBQU0sQ0FBRSxNQUFNLHFCQUFzQixPQUM5QixPQUFPLElBQUksS0FBSyxNQUFNO0FBRTVCLGVBQU87O2FBR0YsVUFBVSxPQUFPO0FBQ3RCLGNBQU0sWUFBWSxPQUFPLEtBQUssUUFDeEIsZ0JBQWdCLE9BQU0sWUFDdEIsT0FBTyxlQUNQLDJCQUEyQixNQUFNLE9BQ2pDLG9CQUFvQiw4Q0FBOEMsMkJBQ2xFLE9BQU8sSUFBSSxLQUFLLE1BQU07QUFFNUIsZUFBTzs7YUFHRixvQ0FBb0MsTUFBTSwwQkFBMEI7QUFDekUsY0FBTSxvQkFBb0IsOENBQThDLDJCQUNsRSxPQUFPLElBQUksS0FBSyxNQUFNO0FBRTVCLGVBQU87OztBQUlYLDJEQUF1RCwwQkFBd0I7QUFDN0UsWUFBTSxRQUFRLFdBQUEsR0FDUixTQUFTLElBQUksT0FBTywwQkFBMEIsUUFDOUMsb0JBQW9CO0FBRTFCLGFBQU87Ozs7O0FDL0VUOzs7Ozs7Ozs7Ozs7O1VBTWEsV0FBQTtlQUFBOztVQU9BLGVBQUE7ZUFBQTs7VUFNYixVQUFBO2VBQUE7O1VBWmEsV0FBQTtlQUFBOztVQVFBLFlBQUE7ZUFBQTs7VUFYQSxVQUFBO2VBQUE7O1VBWUEsZUFBQTtlQUFBOztVQWJBLFNBQUE7ZUFBQTs7VUFTQSxjQUFBO2VBQUE7O1VBVkEsT0FBQTtlQUFBOztVQVlBLGVBQUE7ZUFBQTs7VUFMQSxhQUFBO2VBQUE7O1VBREEsWUFBQTtlQUFBOztVQVNBLGlCQUFBO2VBQUE7O1VBUEEsYUFBQTtlQUFBOztVQUNBLGNBQUE7ZUFBQTs7VUFOQSxXQUFBO2VBQUE7OztBQUhOLFFBQU0sT0FBTztBQUNiLFFBQU0sU0FBUztBQUNmLFFBQU0sVUFBVTtBQUNoQixRQUFNLFdBQVc7QUFDakIsUUFBTSxXQUFXO0FBQ2pCLFFBQU0sV0FBVztBQUNqQixRQUFNLFlBQVk7QUFDbEIsUUFBTSxhQUFhO0FBQ25CLFFBQU0sYUFBYTtBQUNuQixRQUFNLGNBQWM7QUFDcEIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGVBQWU7QUFDckIsUUFBTSxZQUFZO0FBQ2xCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGlCQUFpQjtRQUU5QixXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDbkNGOzs7Ozs7Ozs7Ozs7O1VBWUEsVUFBQTtlQUFBOztVQVZnQixpQkFBQTtlQUFBOzs7QUFBVCw0QkFBd0IsT0FBSztBQUNsQyxZQUFNLFVBQVUsTUFBTSxJQUFJLENBQUMsU0FBQTtBQUN6QixjQUFNLFFBQVEsWUFBWTtBQUUxQixlQUFPOztBQUdULGFBQU87O1FBR1QsV0FBZTtNQUNiOztBQUdGLHlCQUFxQixNQUFJO0FBQ3ZCLFlBQU0sT0FBTyxLQUFLLFdBQ1osb0JBQW9CLEtBQUssd0JBQ3pCLENBQUUsVUFBVyxtQkFDYixRQUFRO1NBQ0wsT0FBTzs7QUFHaEIsYUFBTzs7Ozs7QUN4QlQ7Ozs7Ozs7Ozs7Ozs7VUFzQkEsVUFBQTtlQUFBOztVQVJnQixpQkFBQTtlQUFBOztVQVZBLG1CQUFBO2VBQUE7Ozs7Ozs7OztBQUFULDhCQUEwQixTQUFPO0FBQ3RDLFlBQU0sUUFBUSxRQUFRLElBQUksQ0FBQyxVQUFBO0FBQ3pCLGNBQU0sT0FBTyxNQUFBLFFBQUssVUFBVTtBQUU1QixlQUFPOztBQUdULGFBQU87O0FBR0YsNEJBQXdCLE9BQU8sT0FBSztBQUN6QyxZQUFNLG1CQUFtQiwwQkFBMEIsUUFDN0Msc0JBQXNCLDZCQUE2QixRQUNuRCxRQUFRLElBQUksTUFBTSxPQUFPLGtCQUFrQjtBQUVqRCxhQUFPOztRQUdULFdBQWU7TUFDYjtNQUNBOztBQUdGLHVDQUFtQyxPQUFLO0FBQ3RDLFlBQU0sQ0FBRSx1QkFBdUIsNEJBQTRCLGlDQUFrQztBQUU3RixZQUFNLG1CQUFtQjtRQUN2QjtRQUNBO1FBQ0E7O0FBR0YsYUFBTzs7QUFHVCwwQ0FBc0MsT0FBSztBQUN6QyxZQUFNLENBQUUsZ0JBQ0EsaUJBQ0Esd0JBQ0Esd0JBQ0EsOEJBQ0EsZ0NBQ0Esa0NBQW1DO0FBRTNDLFlBQU0sc0JBQXNCO1FBQzFCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztBQUdGLGFBQU87Ozs7O0FDMURUOzs7OzttQ0FvQkEsV0FBQTs7O2VBQUE7OztBQWxCQSxRQUFNLFVBQVU7TUFDZDtRQUNFLFNBQVc7O01BRWI7UUFDRSxRQUFVOztNQUVaO1FBQ0UsTUFBUTs7TUFFVjtRQUNFLE1BQVE7O01BRVY7UUFDRSxZQUFjOzs7UUFJbEIsV0FBZTs7OztBQ3BCZjs7Ozs7bUNBRWdCLGtDQUFBOzs7ZUFBQTs7O0FBQVQsNENBQXdDLE9BQU8sV0FBUztBQUM3RCxZQUFNLG9CQUFvQixNQUFNO0FBRWhDLFVBQUksbUJBQW1CO0FBQ3JCLGNBQU0sZUFBZSxPQUNmLGtDQUFrQyxhQUFhO0FBRXJELG9CQUFZOztBQUdkLGFBQU87Ozs7O0FDWlQ7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7O0FBQU4sNEJBQU07TUFDbkIsWUFBWSxPQUFPLGtCQUFrQixxQkFBcUI7QUFDeEQsYUFBSyxRQUFRO0FBQ2IsYUFBSyxtQkFBbUI7QUFDeEIsYUFBSyxzQkFBc0I7O01BRzdCLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2Qsc0JBQXNCO0FBQ3BCLGVBQU8sS0FBSzs7TUFHZCx5QkFBeUI7QUFDdkIsZUFBTyxLQUFLOztNQUdkLFNBQVMsU0FBUyxZQUFZLE9BQU87QUFDbkMsY0FBTSxTQUFTO0FBRWYsZUFBTyxZQUFZLFdBQUEsY0FBYztBQUMvQixjQUFJLFFBQVE7QUFFWixnQkFBTSxVQUFVLFlBQ0UsS0FBSyxtQkFDSCxLQUFLO0FBRXpCLGtCQUFRLEtBQUssQ0FBQyxVQUFBO0FBQ1osZ0JBQUksVUFBVSxNQUFNO0FBQ2xCLHNCQUFRLE1BQU0sTUFBTTtBQUVwQixrQkFBSSxVQUFVLE1BQU07QUFDbEIsdUJBQU87Ozs7QUFLYixjQUFJLFVBQVUsTUFBTTtBQUNsQixnQkFBSSxtQkFBbUI7QUFFdkIsaUJBQUssTUFBTSxLQUFLLENBQUMsU0FBQTtBQUNmLGlDQUFtQixLQUFLLE1BQU07QUFFOUIsa0JBQUkscUJBQXFCLE1BQU07QUFDN0Isd0JBQVE7QUFFUix1QkFBTzs7OztBQUtiLGNBQUksVUFBVSxNQUFNO0FBQ2xCLGtCQUFNLElBQUksTUFBTSxnQkFBZ0I7O0FBR2xDLGlCQUFPLEtBQUs7QUFFWixzQkFBWSxJQUFBLE9BQUEsZ0NBQStCLE9BQU87QUFFbEQsZ0JBQU0sUUFBUSxNQUNSLHFCQUFxQixNQUFNLGlCQUFpQixRQUM1QyxRQUFRO0FBRWQsb0JBQVUsUUFBUSxVQUFVOztBQUc5QixlQUFPOzthQUdGLFlBQVksT0FBTztBQUN4QixjQUFNLENBQUUsV0FBWSxPQUNkLFFBQVEsSUFBQSxPQUFBLGtCQUFpQixVQUN6QixRQUFRLElBQUEsT0FBQSxnQkFBZSxPQUFPO0FBRXBDLGVBQU87O2FBR0YsVUFBVSxPQUFPLE9BQU87QUFDN0IsY0FBTSxRQUFRLElBQUEsT0FBQSxnQkFBZSxPQUFPO0FBRXBDLGVBQU87O2FBR0YsWUFBWSxPQUFPLFNBQVM7QUFDakMsY0FBTSxRQUFRLElBQUEsT0FBQSxrQkFBaUIsVUFDekIsUUFBUSxJQUFBLE9BQUEsZ0JBQWUsT0FBTztBQUVwQyxlQUFPOzs7Ozs7QUMvRlg7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4sNENBQWtDLE9BQUEsUUFBSzthQUM3QyxNQUFNLE9BQU8sU0FBUztBQUMzQixjQUFNLGNBQWMsT0FDZCxzQkFBc0IsT0FBQSxRQUFNLE1BQU0sT0FBTyxTQUFTO0FBRXhELGVBQU87O2FBR0YsWUFBWSxPQUFPLFNBQVM7QUFDakMsY0FBTSxjQUFjLE9BQ2Qsc0JBQXNCLE9BQUEsUUFBTSxZQUFZLE9BQU8sU0FBUztBQUU5RCxlQUFPOzthQUdGLG1CQUFtQixPQUFPLFNBQVMsTUFBTTtBQUM5QyxjQUFNLGNBQWMsT0FDZCxzQkFBc0IsT0FBQSxRQUFNLG1CQUFtQixPQUFPLFNBQVMsTUFBTTtBQUUzRSxlQUFPOzs7Ozs7QUN2Qlg7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHlDQUE4QixnQkFBQSxRQUFtQjthQUt2RCxNQUFNLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLE1BQU0sa0JBQWlCOzthQUVuRSxZQUFZLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLFlBQVksa0JBQWlCOzs7QUFQekU7QUFDTixrQkFETSxpQkFDTixRQUFPLE9BQUE7QUFFUCxrQkFITSxpQkFHTixxQkFBb0I7Ozs7QUNUN0I7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLGdEQUFxQyxhQUFBLFFBQWdCO2FBSzNELE1BQU0sU0FBUztBQUFFLGVBQU8sYUFBQSxRQUFpQixNQUFNLHlCQUF3Qjs7YUFFdkUsWUFBWSxTQUFTO0FBQUUsZUFBTyxhQUFBLFFBQWlCLFlBQVkseUJBQXdCOzs7QUFQN0U7QUFDTixrQkFETSx3QkFDTixRQUFPLE9BQUE7QUFFUCxrQkFITSx3QkFHTixxQkFBb0I7Ozs7QUNUN0I7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHNEQUEyQyxnQkFBQSxRQUFtQjtNQUMzRSxTQUFTO0FBQ1AsY0FBTSxVQUFVLEtBQUssY0FDZixPQUFPO0FBRWIsZUFBTzs7YUFPRixNQUFNLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLE1BQU0sK0JBQThCOzthQUVoRixZQUFZLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLFlBQVksK0JBQThCOzs7QUFkdEY7QUFRTixrQkFSTSw4QkFRTixRQUFPLE9BQUE7QUFFUCxrQkFWTSw4QkFVTixxQkFBb0I7Ozs7QUNoQjdCOzs7OzttQ0FVQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxhQUFjLFdBQUE7QUFFUCwyQ0FBaUMsYUFBQSxRQUFnQjtNQUM5RCxZQUFZO0FBQ1YsY0FBTSxVQUFVLEtBQUssY0FDZixnQkFBZ0IsS0FBSyxvQkFDckIsUUFBUSxHQUNSLE1BQU0sZ0JBQWdCLEdBQ3RCLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFFekMsZUFBTzs7YUFLRixNQUFNLE9BQU8sU0FBUztBQUFFLGVBQU8sYUFBQSxRQUFpQixNQUFNLE9BQU87O2FBRTdELFlBQVksT0FBTyxTQUFTO0FBQUUsZUFBTyxhQUFBLFFBQWlCLFlBQVksT0FBTzs7O0FBSnpFLGtCQVhNLG9CQVdOLFFBQU8sT0FBQTs7OztBQ3JCaEI7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4sd0RBQTZDLGVBQUEsUUFBa0I7YUFHckUsTUFBTSxTQUFTO0FBQUUsZUFBTyxlQUFBLFFBQW1CLE1BQU0saUNBQWdDOzthQUVqRixZQUFZLFNBQVM7QUFBRSxlQUFPLGVBQUEsUUFBbUIsWUFBWSxpQ0FBZ0M7OztBQUx2RjtBQUNOLGtCQURNLGdDQUNOLHFCQUFvQjs7OztBQ0w3Qjs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7OztBQUFOLGtDQUF1QixPQUFBLFFBQVc7TUFDL0MsY0FBYyxLQUFLO0FBQ2pCLGNBQU0sVUFBVSxLQUNWLFNBQVMsTUFBTSxTQUFTO0FBRTlCLGVBQU87O2FBeUJGLGNBQWM7QUFBRSxlQUFPLE9BQUEsUUFBWSxZQUFZOzthQUUvQyxVQUFVLE9BQU87QUFBRSxlQUFPLE9BQUEsUUFBWSxVQUFVLFdBQVU7O2FBRTFELFlBQVksU0FBUztBQUFFLGVBQU8sT0FBQSxRQUFZLFlBQVksV0FBVTs7O0FBbEMxRDtBQVFOLGtCQVJNLFVBUU4sV0FBVSxTQUFBO0FBRVYsa0JBVk0sVUFVTixrQkFBaUIsV0FBQTtBQUVqQixrQkFaTSxVQVlOLG1CQUFrQixZQUFBO0FBRWxCLGtCQWRNLFVBY04seUJBQXdCO0FBRXhCLGtCQWhCTSxVQWdCTiwwQkFBeUIsbUJBQUE7QUFFekIsa0JBbEJNLFVBa0JOLDBCQUF5QjtBQUV6QixrQkFwQk0sVUFvQk4sOEJBQTZCO0FBRTdCLGtCQXRCTSxVQXNCTixnQ0FBK0I7QUFFL0Isa0JBeEJNLFVBd0JOLGlDQUFnQztBQUVoQyxrQkExQk0sVUEwQk4sa0NBQWlDO0FBRWpDLGtCQTVCTSxVQTRCTixrQ0FBaUMsY0FBQTs7OztBQ3JDMUM7Ozs7O21DQWlCQSxXQUFBOzs7ZUFBQTs7O0FBZkEsUUFBTSxVQUFVO01BQ2Q7UUFDRSxPQUFTOztNQUVYO1FBQ0UsU0FBVzs7TUFFYjtRQUNFLFVBQVk7O01BRWQ7UUFDRSxZQUFjOzs7UUFJbEIsV0FBZTs7OztBQ2pCZjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTix3REFBNkMsZUFBQSxRQUFrQjthQUdyRSxNQUFNLFNBQVM7QUFBRSxlQUFPLGVBQUEsUUFBbUIsTUFBTSxpQ0FBZ0M7O2FBRWpGLFlBQVksU0FBUztBQUFFLGVBQU8sZUFBQSxRQUFtQixZQUFZLGlDQUFnQzs7O0FBTHZGO0FBQ04sa0JBRE0sZ0NBQ04scUJBQW9COzs7O0FDTDdCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiwrQ0FBcUMsZ0JBQUEsUUFBbUI7TUFDckUsd0JBQXdCO0FBQ3RCLGNBQU0sc0JBQXNCO0FBRTVCLGVBQU87O2FBS0YsTUFBTSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLE1BQU0sT0FBTzs7YUFFaEUsWUFBWSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLFlBQVksT0FBTzs7O0FBSjVFLGtCQVBNLHdCQU9OLFFBQU8sT0FBQTs7OztBQ2JoQjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTiwyREFBZ0QsWUFBQSxRQUFzQjthQUc1RSxNQUFNLFNBQVM7QUFBRSxlQUFPLFlBQUEsUUFBdUIsTUFBTSxvQ0FBbUM7O2FBRXhGLFlBQVksU0FBUztBQUFFLGVBQU8sWUFBQSxRQUF1QixZQUFZLG9DQUFtQzs7O0FBTDlGO0FBQ04sa0JBRE0sbUNBQ04scUJBQW9COzs7O0FDTDdCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiw2REFBa0QsZ0JBQUEsUUFBbUI7TUFDbEYsd0JBQXdCO0FBQ3RCLGNBQU0sc0JBQXNCO0FBRTVCLGVBQU87O2FBT0YsTUFBTSxTQUFTO0FBQUUsZUFBTyxnQkFBQSxRQUFvQixNQUFNLHNDQUFxQzs7YUFFdkYsWUFBWSxTQUFTO0FBQUUsZUFBTyxnQkFBQSxRQUFvQixZQUFZLHNDQUFxQzs7O0FBYjdGO0FBT04sa0JBUE0scUNBT04sUUFBTyxPQUFBO0FBRVAsa0JBVE0scUNBU04scUJBQW9COzs7O0FDZjdCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixtREFBeUMsZ0JBQUEsUUFBbUI7TUFDekUsd0JBQXdCO0FBQ3RCLGNBQU0sc0JBQXNCO0FBRTVCLGVBQU87O2FBS0YsTUFBTSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLE1BQU0sT0FBTzs7YUFFaEUsWUFBWSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLFlBQVksT0FBTzs7O0FBSjVFLGtCQVBNLDRCQU9OLFFBQU8sT0FBQTs7OztBQ2JoQjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTiwrREFBb0QsT0FBQSxRQUEwQjthQUdwRixNQUFNLFNBQVM7QUFBRSxlQUFPLE9BQUEsUUFBMkIsTUFBTSx3Q0FBdUM7O2FBRWhHLFlBQVksU0FBUztBQUFFLGVBQU8sT0FBQSxRQUEyQixZQUFZLHdDQUF1Qzs7O0FBTHRHO0FBQ04sa0JBRE0sdUNBQ04scUJBQW9COzs7O0FDTDdCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixxREFBMkMsZ0JBQUEsUUFBbUI7TUFDM0Usd0JBQXdCO0FBQ3RCLGNBQU0sc0JBQXNCO0FBRTVCLGVBQU87O2FBS0YsTUFBTSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLE1BQU0sT0FBTzs7YUFFaEUsWUFBWSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLFlBQVksT0FBTzs7O0FBSjVFLGtCQVBNLDhCQU9OLFFBQU8sT0FBQTs7OztBQ2JoQjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTixpRUFBc0QsU0FBQSxRQUE0QjthQUd4RixNQUFNLFNBQVM7QUFBRSxlQUFPLFNBQUEsUUFBNkIsTUFBTSwwQ0FBeUM7O2FBRXBHLFlBQVksU0FBUztBQUFFLGVBQU8sU0FBQSxRQUE2QixZQUFZLDBDQUF5Qzs7O0FBTDFHO0FBQ04sa0JBRE0seUNBQ04scUJBQW9COzs7O0FDTDdCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixzREFBNEMsZ0JBQUEsUUFBbUI7TUFDNUUsd0JBQXdCO0FBQ3RCLGNBQU0sc0JBQXNCO0FBRTVCLGVBQU87O2FBS0YsTUFBTSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLE1BQU0sT0FBTzs7YUFFaEUsWUFBWSxPQUFPLFNBQVM7QUFBRSxlQUFPLGdCQUFBLFFBQW9CLFlBQVksT0FBTzs7O0FBSjVFLGtCQVBNLCtCQU9OLFFBQU8sT0FBQTs7OztBQ2JoQjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTixrRUFBdUQsVUFBQSxRQUE2QjthQUcxRixNQUFNLFNBQVM7QUFBRSxlQUFPLFVBQUEsUUFBOEIsTUFBTSwyQ0FBMEM7O2FBRXRHLFlBQVksU0FBUztBQUFFLGVBQU8sVUFBQSxRQUE4QixZQUFZLDJDQUEwQzs7O0FBTDVHO0FBQ04sa0JBRE0sMENBQ04scUJBQW9COzs7O0FDTDdCOzs7OzttQ0FlQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU4sb0NBQXlCLE9BQUEsUUFBVzthQXVCMUMsY0FBYztBQUFFLGVBQU8sT0FBQSxRQUFZLFlBQVk7O2FBRS9DLFVBQVUsT0FBTztBQUFFLGVBQU8sT0FBQSxRQUFZLFVBQVUsYUFBWTs7YUFFNUQsWUFBWSxTQUFTO0FBQUUsZUFBTyxPQUFBLFFBQVksWUFBWSxhQUFZOzs7QUEzQjVEO0FBQ04sa0JBRE0sWUFDTixXQUFVLFNBQUE7QUFFVixrQkFITSxZQUdOLGtCQUFpQixXQUFBO0FBRWpCLGtCQUxNLFlBS04sbUJBQWtCLFlBQUE7QUFFbEIsa0JBUE0sWUFPTix5QkFBd0IsWUFBQTtBQUV4QixrQkFUTSxZQVNOLDBCQUF5QixtQkFBQTtBQUV6QixrQkFYTSxZQVdOLDBCQUF5QixhQUFBO0FBRXpCLGtCQWJNLFlBYU4sOEJBQTZCLGNBQUE7QUFFN0Isa0JBZk0sWUFlTixnQ0FBK0IsY0FBQTtBQUUvQixrQkFqQk0sWUFpQk4saUNBQWdDLGNBQUE7QUFFaEMsa0JBbkJNLFlBbUJOLGtDQUFpQyxjQUFBO0FBRWpDLGtCQXJCTSxZQXFCTixrQ0FBaUMsY0FBQTs7OztBQ3BDMUM7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLG1EQUF3QyxhQUFBLFFBQWdCO01BQ3JFLFNBQVM7QUFDUCxjQUFNLFVBQVUsS0FBSyxjQUNmLE9BQU87QUFFYixlQUFPOzthQU9GLE1BQU0sU0FBUztBQUFFLGVBQU8sYUFBQSxRQUFpQixNQUFNLDRCQUEyQjs7YUFFMUUsWUFBWSxTQUFTO0FBQUUsZUFBTyxhQUFBLFFBQWlCLFlBQVksNEJBQTJCOzs7QUFkaEY7QUFRTixrQkFSTSwyQkFRTixRQUFPLE9BQUE7QUFFUCxrQkFWTSwyQkFVTixxQkFBb0I7Ozs7QUNoQjdCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiwwREFBK0MsYUFBQSxRQUFnQjtNQUM1RSx3QkFBd0I7QUFDdEIsY0FBTSxzQkFBc0I7QUFFNUIsZUFBTzs7YUFPRixNQUFNLFNBQVM7QUFBRSxlQUFPLGFBQUEsUUFBaUIsTUFBTSxtQ0FBa0M7O2FBRWpGLFlBQVksU0FBUztBQUFFLGVBQU8sYUFBQSxRQUFpQixZQUFZLG1DQUFrQzs7O0FBYnZGO0FBT04sa0JBUE0sa0NBT04sUUFBTyxPQUFBO0FBRVAsa0JBVE0sa0NBU04scUJBQW9COzs7O0FDZjdCOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLHNEQUEyQyxZQUFBLFFBQXNCO2FBR3ZFLE1BQU0sU0FBUztBQUFFLGVBQU8sWUFBQSxRQUF1QixNQUFNLCtCQUE4Qjs7YUFFbkYsWUFBWSxTQUFTO0FBQUUsZUFBTyxZQUFBLFFBQXVCLFlBQVksK0JBQThCOzs7QUFMekY7QUFDTixrQkFETSw4QkFDTixxQkFBb0I7Ozs7QUNMN0I7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4sMERBQStDLE9BQUEsUUFBMEI7YUFHL0UsTUFBTSxTQUFTO0FBQUUsZUFBTyxPQUFBLFFBQTJCLE1BQU0sbUNBQWtDOzthQUUzRixZQUFZLFNBQVM7QUFBRSxlQUFPLE9BQUEsUUFBMkIsWUFBWSxtQ0FBa0M7OztBQUxqRztBQUNOLGtCQURNLGtDQUNOLHFCQUFvQjs7OztBQ0w3Qjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTiw0REFBaUQsU0FBQSxRQUE0QjthQUduRixNQUFNLFNBQVM7QUFBRSxlQUFPLFNBQUEsUUFBNkIsTUFBTSxxQ0FBb0M7O2FBRS9GLFlBQVksU0FBUztBQUFFLGVBQU8sU0FBQSxRQUE2QixZQUFZLHFDQUFvQzs7O0FBTHJHO0FBQ04sa0JBRE0sb0NBQ04scUJBQW9COzs7O0FDTDdCOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLDZEQUFrRCxVQUFBLFFBQTZCO2FBR3JGLE1BQU0sU0FBUztBQUFFLGVBQU8sVUFBQSxRQUE4QixNQUFNLHNDQUFxQzs7YUFFakcsWUFBWSxTQUFTO0FBQUUsZUFBTyxVQUFBLFFBQThCLFlBQVksc0NBQXFDOzs7QUFMdkc7QUFDTixrQkFETSxxQ0FDTixxQkFBb0I7Ozs7QUNMN0I7Ozs7Ozs7Ozs7Ozs7VUFTb0IsV0FBQTtlQUFBLFFBQUE7O1VBQ0EsYUFBQTtlQUFBLFFBQUE7O1VBc0JBLG1DQUFBO2VBQUEsU0FBQTs7VUFFQSxzQ0FBQTtlQUFBLFNBQUE7O1VBSEEsK0JBQUE7ZUFBQSxRQUFBOztVQUVBLHFDQUFBO2VBQUEsU0FBQTs7VUF0QkEsY0FBQTtlQUFBLFFBQUE7O1VBY0EsaUNBQUE7ZUFBQSxjQUFBOztVQVBBLHNDQUFBO2VBQUEsWUFBQTs7VUFEQSxtQ0FBQTtlQUFBLFlBQUE7O1VBREEsK0JBQUE7ZUFBQSxZQUFBOztVQURBLDRCQUFBO2VBQUEsV0FBQTs7VUFhQSw2QkFBQTtlQUFBLE9BQUE7O1VBRUEsZ0NBQUE7ZUFBQSxVQUFBOztVQWhCQSxzQkFBQTtlQUFBLGdCQUFBOztVQXNCQSx3Q0FBQTtlQUFBLGNBQUE7O1VBRUEsMkNBQUE7ZUFBQSxjQUFBOztVQUhBLG9DQUFBO2VBQUEsYUFBQTs7VUFFQSwwQ0FBQTtlQUFBLGNBQUE7O1VBZEEseUJBQUE7ZUFBQSxtQkFBQTs7VUFyQkEsT0FBQTtlQUFBLE1BQUE7O1VBV0EsbUJBQUE7ZUFBQSxhQUFBOztVQWNBLHlCQUFBO2VBQUEsWUFBQTs7VUFIQSxpQ0FBQTtlQUFBLGNBQUE7O1VBS0EsK0JBQUE7ZUFBQSxTQUFBOztVQVBBLHFCQUFBO2VBQUEsZUFBQTs7VUFGQSxrQkFBQTtlQUFBLFlBQUE7O1VBYkEsaUJBQUE7ZUFBQSxPQUFBOztVQURBLGlCQUFBO2VBQUEsT0FBQTs7VUFGQSxpQkFBQTtlQUFBLGdCQUFBOztVQURBLFFBQUE7ZUFBQSxPQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIcEI7Ozs7O21DQTJEQSxXQUFBOzs7ZUFBQTs7O0FBekRBLFFBQU0sVUFBVTtNQUNkO1FBQ0UsT0FBUzs7TUFFWDtRQUNFLFdBQWE7O01BRWY7UUFDRSxRQUFVOztNQUVaO1FBQ0UsV0FBYTs7TUFFZjtRQUNFLFlBQWM7O01BRWhCO1FBQ0UsV0FBYTs7TUFFZjtRQUNFLFVBQVk7O01BRWQ7UUFDRSxRQUFVOztNQUVaO1FBQ0UsT0FBUzs7TUFFWDtRQUNFLE1BQVE7O01BRVY7UUFDRSxNQUFROztNQUVWO1FBQ0UsS0FBTzs7TUFFVDtRQUNFLFFBQVU7O01BRVo7UUFDRSxTQUFXOztNQUViO1FBQ0UsWUFBYzs7TUFFaEI7UUFDRSxvQkFBb0I7O01BRXRCO1FBQ0UsaUJBQWlCOztNQUVuQjtRQUNFLFlBQWM7OztRQUlsQixXQUFlOzs7O0FDM0RmOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixrQ0FBdUIsYUFBQSxZQUFXO2FBdUJ4QyxjQUFjO0FBQUUsZUFBTyxhQUFBLFlBQVksWUFBWTs7YUFFL0MsVUFBVSxPQUFPO0FBQUUsZUFBTyxhQUFBLFlBQVksVUFBVSxXQUFVOzthQUUxRCxZQUFZLFNBQVM7QUFBRSxlQUFPLGFBQUEsWUFBWSxZQUFZLFdBQVU7OztBQTNCMUQ7QUFDTixrQkFETSxVQUNOLFdBQVUsU0FBQTtBQUVWLGtCQUhNLFVBR04sa0JBQWlCLGFBQUE7QUFFakIsa0JBTE0sVUFLTixtQkFBa0IsYUFBQTtBQUVsQixrQkFQTSxVQU9OLHlCQUF3QjtBQUV4QixrQkFUTSxVQVNOLDBCQUF5QjtBQUV6QixrQkFYTSxVQVdOLDBCQUF5QjtBQUV6QixrQkFiTSxVQWFOLDhCQUE2QjtBQUU3QixrQkFmTSxVQWVOLGdDQUErQjtBQUUvQixrQkFqQk0sVUFpQk4saUNBQWdDO0FBRWhDLGtCQW5CTSxVQW1CTixrQ0FBaUM7QUFFakMsa0JBckJNLFVBcUJOLGtDQUFpQyxhQUFBOzs7O0FDM0IxQzs7Ozs7bUNBOEZBLFdBQUE7OztlQUFBOzs7QUE1RkEsUUFBTSxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBNEZaLFdBQWU7Ozs7QUM5RmY7Ozs7Ozs7Ozs7Ozs7VUFFYSxlQUFBO2VBQUE7O1VBQ0Esb0JBQUE7ZUFBQTs7VUFDQSx1QkFBQTtlQUFBOzs7QUFGTixRQUFNLGVBQWU7QUFDckIsUUFBTSxvQkFBbUI7QUFDekIsUUFBTSx1QkFBdUI7Ozs7QUNKcEM7Ozs7O21DQVFnQiw0QkFBQTs7O2VBQUE7Ozs7O0FBRmhCLFFBQU0sQ0FBRSxtQkFBb0IsV0FBQTtBQUVyQixzQ0FBa0MsZUFBYTtBQUNwRCxVQUFJLFVBQVUsV0FBQTtBQUVkLGVBQVMsV0FBVyxHQUFHLFdBQVcsZUFBZSxZQUFZO0FBQzNELG1CQUFXOztBQUdiLGFBQU87Ozs7O0FDZlQ7Ozs7O21DQVdBLFdBQUE7OztlQUFxQjs7Ozs7OztBQUhyQixRQUFNLENBQUUsU0FBVSxXQUFBO0FBQWxCLFFBQ00sQ0FBRSxRQUFRLHFCQUFxQixZQUFZLDJCQUE0QixhQUFBO0FBRTlELHFCQUFNO01BQ25CLFlBQVksTUFBTSxTQUFTLGFBQWE7QUFDdEMsYUFBSyxPQUFPO0FBQ1osYUFBSyxVQUFVO0FBQ2YsYUFBSyxjQUFjOztNQUdyQixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLOztNQUdkLFFBQVEsTUFBTTtBQUNaLGFBQUssT0FBTzs7TUFHZCxXQUFXLFNBQVM7QUFDbEIsYUFBSyxVQUFVOztNQUdqQixlQUFlLGFBQWE7QUFDMUIsYUFBSyxjQUFjOztNQUdyQixXQUFXO0FBQ1QsY0FBTSxTQUFVLEtBQUssWUFBWTtBQUVqQyxlQUFPOztNQUdULGVBQWU7QUFDYixjQUFNLGFBQWMsS0FBSyxZQUFZO0FBRXJDLGVBQU87O01BR1QsZ0JBQWdCO0FBQ2QsY0FBTSxhQUFjLEtBQUssWUFBWTtBQUVyQyxlQUFPOztNQUdULE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosY0FBTSxVQUFVLEtBQUssU0FDZixXQUFXLEtBQUssTUFDaEIsYUFBYSxNQUNiLGFBQWEsSUFDYixrQkFBa0IsS0FBSyw0QkFBNEIsVUFBVSxRQUM3RCxrQkFBa0IsZ0JBQWdCLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxhQUM1RyxrQkFBa0IsTUFBTTtBQUU5QixZQUFJLE9BQU87QUFFWCxjQUFNLEtBQUs7QUFFWCxpQkFBUyxLQUFLLFlBQVksS0FBSyxDQUFDLGVBQUE7QUFDOUIsY0FBSTtBQUVKLGdCQUFNO0FBRU4sZ0JBQU0sY0FBYSxXQUFXO0FBRTlCLGdCQUFNLGNBQWM7QUFFcEIscUJBQVcsTUFBQTtBQUNULGdCQUFJO0FBRUosa0JBQU0sY0FBYSxNQUFNO0FBRXpCLDRCQUFnQixjQUFjO0FBRTlCLHNCQUFTO0FBRVQsZ0JBQUksU0FBUTtBQUNWLG1CQUFLOztBQUdQLGtCQUFNLDJCQUEyQixnQkFBZ0IsUUFBUTtBQUV6RCxnQkFBSSw2QkFBNkIsTUFBTTtBQUNyQyxrQkFBSSxTQUFRO0FBQ1Ysc0JBQU07QUFFTix1QkFBTztBQUVQLHNCQUFNLEtBQUs7OztBQUlmLGdCQUFJLFNBQVE7QUFDVixvQkFBTSxRQUFRLEtBQUs7QUFFbkIsa0JBQUksT0FBTztBQUNULDBCQUFTOzs7QUFJYixnQkFBSSxTQUFRO0FBQ1Ysb0JBQU0sZ0JBQWdCLEtBQUs7QUFFM0Isa0JBQUksZUFBZTtBQUNqQiwwQkFBUzs7O0FBSWIsZ0JBQUksU0FBUTtBQUNWLGtCQUFJLGNBQWMsTUFBTTtBQUN0QixzQkFBTSxnQkFBZ0I7QUFFdEIsMEJBQVM7OztBQUliLGdCQUFJLDZCQUE2QixNQUFNO0FBQ3JDLGtCQUFJLENBQUMsU0FBUTtBQUNYLHNCQUFNO0FBRU4sdUJBQU87QUFFUCxzQkFBTSxLQUFLOzs7QUFJZixnQkFBSSxDQUFDLFNBQVE7QUFDWCxtQkFBSzs7QUFHUCxtQkFBTzs7QUFHVCxvQkFBUyxXQUFXLE1BQU0sWUFBWSxPQUFPLFVBQVU7QUFFdkQsY0FBSSxDQUFDLFNBQVE7QUFDWCxrQkFBTSxnQkFBZ0I7O0FBR3hCLGlCQUFPOztBQUdULFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU07O0FBR1IsWUFBSSxjQUFjLE1BQU07QUFDdEIsZ0JBQU0sZ0JBQWdCOztBQUd4QixlQUFPOztNQUdULDRCQUE0QixVQUFVLE9BQU87QUFBRSxlQUFPLE1BQU0sNEJBQTRCOztNQUV4RixTQUFTLHVCQUF1QixZQUFZLE1BQU07QUFDaEQsY0FBTSxvQkFBb0IsS0FBSyxZQUFZO0FBRTNDLG9CQUFZLGFBQWMsb0JBQW9CO0FBRTlDLGNBQU0saUJBQWlCLElBQUEsUUFBQSwwQkFBeUIsd0JBQzFDLG9CQUFvQixLQUFLLFlBQVksT0FBTyxDQUFDLG9CQUFtQixlQUFBO0FBQzlELGdCQUFNLG1CQUFtQixXQUFXO0FBRXBDLGNBQUksdUJBQXNCLFdBQUEsY0FBYztBQUN0QyxpQ0FBb0I7aUJBQ2Y7QUFDTCxpQ0FBb0IsWUFDQyxHQUFHOztFQUVwQyxzQkFBc0IscUJBQ2EsR0FBRyx3QkFBdUI7O0FBR25ELGlCQUFPO1dBQ04sV0FBQSxlQUNILFdBQVcsS0FBSyxNQUNoQixpQkFBaUIsU0FBUyxRQUMxQixnQkFBaUIsS0FBSyxZQUFZLE9BQ2hCLFdBQUEsZUFDRSxLQUFLLFNBQ3pCLHNCQUFzQixjQUFjLFFBQ3BDLGdCQUFnQix3QkFBd0IsaUJBQWlCLHFCQUN6RCxVQUFVLElBQUEsUUFBQSwwQkFBeUI7QUFFekMsY0FBTSxrQkFBa0IsWUFDQzs7RUFFM0IsdUJBQzZCLE1BQ3JCLFNBQVM7O0VBRWpCLEtBQUssT0FBTyxnQkFBZ0IsZUFBZSxvQkFBb0I7QUFFN0QsZUFBTzs7YUFHRiw4QkFBOEIsT0FBTyxNQUFNLFNBQVMsYUFBYTtBQUN0RSxZQUFJLGdCQUFnQixRQUFXO0FBQzdCLHdCQUFjO0FBRWQsb0JBQVU7QUFFVixpQkFBTztBQUVQLGtCQUFROztBQUdWLGNBQU0sT0FBTyxJQUFJLE1BQU0sTUFBTSxTQUFTO0FBRXRDLGVBQU87Ozs7OztBQ25PWDs7Ozs7bUNBcWJBLFdBQUE7OztlQUFBOzs7O0FBamJBLFFBQU0sQ0FBRSxNQUFNLGVBQU8sY0FBYyxpQkFBa0IsV0FBQTtBQUVyRCwrQkFBUztBQUNQLFlBQU0sbUJBQW1CLEtBQUssV0FBVyxRQUNuQyxlQUFlO0FBRXJCLGFBQU87O0FBR1QsMEJBQXNCLFVBQVE7QUFBSSxhQUFPLEtBQUssV0FBVyxJQUFJOztBQUU3RCwyQkFBdUIsVUFBUTtBQUFJLGFBQU8sS0FBSyxXQUFXLEtBQUs7O0FBRS9ELDJCQUF1QixVQUFRO0FBQUksYUFBTyxLQUFLLFdBQVcsS0FBSzs7QUFFL0QsNEJBQXdCLFVBQVE7QUFBSSxhQUFPLEtBQUssV0FBVyxNQUFNOztBQUVqRSw2QkFBeUIsVUFBUTtBQUFJLGFBQU8sS0FBSyxXQUFXLE9BQU87O0FBRW5FLDZCQUF5QixVQUFVLGNBQVk7QUFBSSxhQUFPLEtBQUssV0FBVyxPQUFPLFVBQVU7O0FBRTNGLDhCQUEwQixVQUFRO0FBQUksV0FBSyxXQUFXLFFBQVE7O0FBRTlELG1DQUErQixVQUFRO0FBQUksYUFBTyxhQUFhLEtBQUssWUFBWTs7QUFFaEYsb0NBQWdDLFVBQVE7QUFBSSxhQUFPLGNBQWMsS0FBSyxZQUFZOztBQUVsRiw4QkFBMEIsV0FBUztBQUFJLGFBQU8sS0FBSyxXQUFXLFFBQVE7O0FBRXRFLHFDQUFpQyxZQUFVO0FBQ3pDLFVBQUksZUFBZSxRQUFXO0FBQzVCLHFCQUFhO2FBQ1IsS0FBSzs7O0FBSVosWUFBTSxhQUFhO0FBRW5CLGlCQUFXLFFBQVEsQ0FBQyxjQUFBO0FBQ2xCLGtCQUFVLGNBQWM7OztBQUk1Qix1Q0FBbUMsWUFBVTtBQUMzQyxVQUFJLGVBQWUsUUFBVztBQUM1QixxQkFBYTthQUNSLEtBQUs7OztBQUlaLFlBQU0sYUFBYTtBQUVuQixpQkFBVyxRQUFRLENBQUMsY0FBQTtBQUNsQixrQkFBVSxjQUFjOzs7QUFJNUIsMEJBQXNCLGdCQUFnQixZQUFVO0FBQzlDLFlBQU0sa0JBQWtCO1FBQ3RCOztBQUdGLFdBQUssY0FBYyxpQkFBaUI7O0FBR3RDLDJCQUF1QixpQkFBaUIsWUFBVTtBQUNoRCxZQUFNLGNBQWM7QUFFcEIsV0FBSyxpQkFBaUIsWUFBWSxhQUFhOztBQUdqRCw2QkFBeUIsa0JBQWdCO0FBQ3ZDLFVBQUk7QUFFSiwwQkFBb0I7UUFDbEI7O0FBR0YsMEJBQW9CLEtBQUssaUJBQWlCO0FBRTFDLGFBQU87O0FBR1QsOEJBQTBCLG1CQUFpQjtBQUN6QyxVQUFJLHNCQUFzQixRQUFXO0FBQ25DLDRCQUFvQjthQUNmLEtBQUs7OztBQUlaLFlBQU0sMEJBQTBCLGtCQUFrQjtBQUVsRCxVQUFJLDBCQUEwQixHQUFHO0FBQy9CLGNBQU0seUJBQXlCLE9BQU0sb0JBQy9CLGFBQWEsS0FBSyxXQUFXLFFBQVEseUJBQ3JDLGNBQWMseUJBQ2Qsa0JBQWtCO0FBRXhCLDRCQUFvQixLQUFLLGlCQUFpQixZQUFZLGFBQWE7O0FBR3JFLGFBQU87O0FBR1QsOEJBQTBCLG1CQUFtQix1QkFBcUI7QUFDaEUsWUFBTSxxQkFBcUI7UUFDekI7O0FBR0YsV0FBSyxrQkFBa0Isb0JBQW9COztBQUc3QywrQkFBMkIsb0JBQW9CLHVCQUFxQjtBQUNsRSxZQUFNLDJCQUEyQixtQkFBbUIsUUFDOUMseUJBQXlCLE9BQU0scUJBQy9CLGFBQWEsS0FBSyxXQUFXLFFBQVEseUJBQ3JDLGNBQWM7QUFFcEIsV0FBSyxpQkFBaUIsWUFBWSxhQUFhOztBQUdqRCw2QkFBeUIsbUJBQWlCO0FBQ3hDLFlBQU0scUJBQXFCO1FBQ3pCOztBQUdGLFdBQUssaUJBQWlCOztBQUd4Qiw4QkFBMEIsb0JBQWtCO0FBQzFDLFlBQU0sa0JBQWtCLG9CQUNsQixlQUFlLEtBQUssbUJBQ3BCLGFBQWE7QUFFbkIsV0FBSyxjQUFjLGlCQUFpQjs7QUFHdEMsOEJBQTBCLG9CQUFrQjtBQUMxQyxZQUFNLHNCQUFzQjtRQUMxQjs7QUFHRixXQUFLLGtCQUFrQjs7QUFHekIsK0JBQTJCLHFCQUFtQjtBQUM1QyxZQUFNLGtCQUFrQixxQkFDbEIsYUFBYTtBQUVuQixXQUFLLGNBQWMsaUJBQWlCOztBQUd0Qyw4QkFBMEIsWUFBWSxhQUFhLGtCQUFrQixJQUFFO0FBQ3JFLFlBQU0sb0JBQW9CLEtBQUssV0FBVyxPQUFPLFlBQVksYUFBQSxHQUFnQjtBQUU3RSxXQUFLLDBCQUEwQjtBQUUvQixXQUFLLHdCQUF3QjtBQUU3QixhQUFPOztBQUdULDZCQUF5QixZQUFZLFdBQVcsVUFBUTtBQUN0RCxZQUFNLGFBQWEsS0FBSyxXQUFXLE1BQU0sWUFBWTtBQUVyRCxhQUFPOztBQUdULGdDQUFTO0FBQ1AsWUFBTSxnQkFBZ0I7QUFFdEIsVUFBSSxlQUFlLEtBQUs7QUFFeEIsYUFBTyxpQkFBaUIsTUFBTTtBQUM1QixzQkFBYyxLQUFLO0FBRW5CLGNBQU0sYUFBYSxhQUFhO0FBRWhDLHVCQUFlOztBQUdqQixhQUFPOztBQUdULDZCQUF5QixVQUFRO0FBQy9CLFlBQU0sZ0JBQWdCLEtBQUs7QUFFM0IsYUFBTyxjQUFjLElBQUk7O0FBRzNCLDhCQUEwQixVQUFRO0FBQ2hDLFVBQUksU0FBUztBQUViLFVBQUksUUFBUSxHQUNSLGVBQWUsS0FBSztBQUV4QixhQUFPLGlCQUFpQixNQUFNO0FBQzVCLGlCQUFTLENBQUMsQ0FBQyxTQUFTLGNBQWM7QUFFbEMsWUFBSSxRQUFRO0FBQ1Y7O0FBR0YsY0FBTSxhQUFhLGFBQWE7QUFFaEMsdUJBQWU7QUFFZjs7QUFHRixhQUFPOztBQUdULDhCQUEwQixVQUFRO0FBQ2hDLFVBQUksUUFBUSxHQUNSLGVBQWUsS0FBSztBQUV4QixhQUFPLGlCQUFpQixNQUFNO0FBQzVCLGNBQU0sU0FBUyxTQUFTLGNBQWM7QUFFdEMsWUFBSSxRQUFRO0FBQ1YsaUJBQU87O0FBR1QsY0FBTSxhQUFhLGFBQWE7QUFFaEMsdUJBQWU7QUFFZjs7QUFHRixxQkFBZTtBQUVmLGFBQU87O0FBR1QsK0JBQTJCLFVBQVE7QUFDakMsVUFBSSxTQUFTO0FBRWIsVUFBSSxRQUFRLEdBQ1IsZUFBZSxLQUFLO0FBRXhCLGFBQU8saUJBQWlCLE1BQU07QUFDNUIsaUJBQVMsQ0FBQyxDQUFDLFNBQVMsY0FBYztBQUVsQyxZQUFJLENBQUMsUUFBUTtBQUNYOztBQUdGLGNBQU0sYUFBYSxhQUFhO0FBRWhDLHVCQUFlO0FBRWY7O0FBR0YsYUFBTzs7QUFHVCxnQ0FBNEIsVUFBUTtBQUNsQyxZQUFNLGdCQUFnQixLQUFLO0FBRTNCLGFBQU8sY0FBYyxPQUFPOztBQUc5QixnQ0FBNEIsVUFBVSxjQUFZO0FBQ2hELFlBQU0sZ0JBQWdCLEtBQUs7QUFFM0IsYUFBTyxjQUFjLE9BQU8sVUFBVTs7QUFHeEMsaUNBQTZCLFVBQVE7QUFDbkMsWUFBTSxnQkFBZ0IsS0FBSztBQUUzQixvQkFBYyxRQUFROztBQUd4QixnQ0FBNEIsa0JBQWtCLElBQUU7QUFDOUMsV0FBSyxpQkFBaUIsS0FBSztBQUUzQixXQUFLLGlCQUFpQixDQUFDLGNBQUE7QUFDckIsa0JBQVUsbUJBQW1COztBQUcvQixhQUFPOztBQUdULCtCQUEyQixVQUFRO0FBQ2pDLFlBQU0sa0JBQWtCLEtBQUs7QUFFN0IsYUFBTyxnQkFBZ0IsSUFBSTs7QUFHN0IsZ0NBQTRCLFVBQVE7QUFDbEMsVUFBSSxTQUFTO0FBRWIsWUFBTSxtQkFBbUIsS0FBSyxXQUFXO0FBRXpDLGVBQVMsUUFBUSxHQUFHLFFBQVEsa0JBQWtCLFNBQVM7QUFDckQsY0FBTSxZQUFZLEtBQUssV0FBVyxRQUM1QixpQkFBaUI7QUFFdkIsaUJBQVMsQ0FBQyxDQUFDLFNBQVM7QUFFcEIsWUFBSSxRQUFRO0FBQ1Y7O0FBR0YsaUJBQVMsVUFBVSxtQkFBbUI7QUFFdEMsWUFBSSxRQUFRO0FBQ1Y7OztBQUlKLGFBQU87O0FBR1QsZ0NBQTRCLFVBQVE7QUFDbEMsVUFBSSxpQkFBaUI7QUFFckIsWUFBTSxtQkFBbUIsS0FBSyxXQUFXO0FBRXpDLGVBQVMsUUFBUSxHQUFHLFFBQVEsa0JBQWtCLFNBQVM7QUFDckQsWUFBSTtBQUVKLGNBQU0sWUFBWSxLQUFLLFdBQVc7QUFFbEMseUJBQWlCO0FBRWpCLGlCQUFTLFNBQVM7QUFFbEIsWUFBSSxRQUFRO0FBQ1Y7O0FBR0YseUJBQWlCLFVBQVUsbUJBQW1CO0FBRTlDLFlBQUksbUJBQW1CLFFBQVc7QUFDaEM7OztBQUlKLGFBQU87O0FBR1QsaUNBQTZCLFVBQVE7QUFDbkMsVUFBSSxTQUFTO0FBRWIsWUFBTSxtQkFBbUIsS0FBSyxXQUFXO0FBRXpDLGVBQVMsUUFBUSxHQUFHLFFBQVEsa0JBQWtCLFNBQVM7QUFDckQsY0FBTSxZQUFZLEtBQUssV0FBVyxRQUM1QixpQkFBaUI7QUFFdkIsaUJBQVMsQ0FBQyxDQUFDLFNBQVM7QUFFcEIsWUFBSSxDQUFDLFFBQVE7QUFDWDs7QUFHRixpQkFBUyxVQUFVLG9CQUFvQjtBQUV2QyxZQUFJLENBQUMsUUFBUTtBQUNYOzs7QUFJSixhQUFPOztBQUdULGtDQUE4QixVQUFRO0FBQ3BDLFlBQU0sa0JBQWtCLEtBQUs7QUFFN0IsYUFBTyxnQkFBZ0IsT0FBTzs7QUFHaEMsa0NBQThCLFVBQVUsY0FBWTtBQUNsRCxZQUFNLGtCQUFrQixLQUFLO0FBRTdCLGFBQU8sZ0JBQWdCLE9BQU8sVUFBVTs7QUFHMUMsbUNBQStCLFVBQVE7QUFDckMsWUFBTSxrQkFBa0IsS0FBSztBQUU3QixzQkFBZ0IsUUFBUTs7QUFHMUIsUUFBTSxhQUFhO01BQ2pCO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ3JiZjs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7OztBQUhyQixRQUFNLENBQUUsUUFBUyxXQUFBO0FBQWpCLFFBQ00sQ0FBRSxvQkFBb0IsbUJBQW9CLFdBQUE7QUFFakMsMEJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixRQUFRO0FBQ04sY0FBTSxRQUFRLEtBQUssTUFBTSxTQUNuQixZQUFZLElBQUksVUFBVTtBQUVoQyxlQUFPOztNQUdULFdBQVc7QUFDVCxZQUFJO0FBRUosWUFBSSxjQUFjLEtBQUssTUFBTTtBQUU3QixZQUFJLGdCQUFnQixHQUFHO0FBQ3JCLGtCQUFRO2VBQ0g7QUFDTCxnQkFBTSxXQUFXLEtBQUssS0FBSyxRQUNyQixpQkFBaUIsU0FBUztBQUVoQyxrQkFBUTs7QUFHVixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLGNBQWMsS0FBSyxNQUFNLFFBQ3pCLFFBQVE7QUFFZCxlQUFPOztNQUdULFlBQVksVUFBVTtBQUNwQixhQUFLLE1BQU0sUUFBUTs7TUFHckIsWUFBWSxXQUFXO0FBQ3JCLGtCQUFVLFlBQVksQ0FBQyxTQUFBO0FBQ3JCLGVBQUssTUFBTSxRQUFROzs7TUFJdkIsYUFBYSxXQUFXO0FBQ3RCLGtCQUFVLFlBQVksQ0FBQyxNQUFNLFVBQUE7QUFDM0IsZUFBSyxNQUFNLFNBQVMsT0FBTyxLQUFLLE1BQU07OztNQUkxQyxjQUFjLFdBQVc7QUFDdkIsa0JBQVUsWUFBWSxDQUFDLE1BQU0sVUFBQTtBQUMzQixlQUFLLE1BQU0sU0FBUyxLQUFLLE1BQU0sU0FBUzs7O01BSTVDLGVBQWUsV0FBVztBQUN4QixrQkFBVSxZQUFZLENBQUMsU0FBQTtBQUNyQixlQUFLLE1BQU0sS0FBSzs7O01BSXBCLGFBQWEsZ0JBQWdCO0FBQzNCLGNBQU0sUUFBUSxLQUFLLFlBQ2IsaUJBQWlCLE9BQ2pCLGtCQUFrQiw0QkFBNEI7QUFFcEQsaUJBQVMsUUFBUSxHQUFHLFFBQVEsZ0JBQWdCLFNBQVM7QUFDbkQsZUFBSyxNQUFNLFFBQVE7OztNQUl2QixjQUFjLGlCQUFpQjtBQUM3QixjQUFNLG1CQUFtQiw0QkFBNEIsa0JBQy9DLGNBQWMsS0FBSyxNQUFNO0FBRS9CLGlCQUFTLFFBQVEsR0FBRyxRQUFRLGFBQWEsU0FBUztBQUNoRCxlQUFLLE1BQU0sU0FBUyxtQkFBbUIsS0FBSyxNQUFNOzs7TUFJdEQsZUFBZSxrQkFBa0I7QUFDL0IsY0FBTSxvQkFBb0IsNEJBQTRCLG1CQUNoRCxjQUFjLEtBQUssTUFBTTtBQUUvQixpQkFBUyxRQUFRLEdBQUcsUUFBUSxhQUFhLFNBQVM7QUFDaEQsZUFBSyxNQUFNLFNBQVMsS0FBSyxNQUFNLFNBQVM7OztNQUk1QyxnQkFBZ0IsbUJBQW1CO0FBQ2pDLGNBQU0sUUFBUSxLQUFLLFlBQ2Isb0JBQW9CLE9BQ3BCLHFCQUFxQiw0QkFBNEI7QUFFdkQsaUJBQVMsUUFBUSxHQUFHLFFBQVEsbUJBQW1CLFNBQVM7QUFDdEQsZUFBSyxNQUFNLEtBQUs7OztNQUlwQixVQUFVO0FBQUUsZUFBTyxLQUFLLE1BQU07O01BRTlCLFlBQVk7QUFBRSxlQUFPLEtBQUssTUFBTTs7TUFFaEMsU0FBUyxNQUFNO0FBQUUsYUFBSyxNQUFNLEtBQUs7O01BRWpDLFlBQVksTUFBTTtBQUFFLGFBQUssTUFBTSxRQUFROztNQUV2QyxXQUFXO0FBQ1QsY0FBTSxTQUFTLEtBQUssTUFBTSxPQUFPLENBQUMsU0FBUSxTQUFBO0FBQ3hDLHFCQUFVLE9BQU87QUFFakIsaUJBQU87V0FDTixXQUFBO0FBRUgsZUFBTzs7O0FBSVgseUNBQXFDLGFBQWEsZ0JBQWM7QUFDOUQsdUJBQWlCLGtCQUFrQjtBQUVuQyxVQUFJLGVBQWUsV0FBQTtBQUVuQixlQUFTLFFBQVEsR0FBRyxRQUFRLGFBQWEsU0FBUztBQUNoRCx3QkFBZ0I7O0FBR2xCLGFBQU87Ozs7O0FDM0lUOzs7OzttQ0FVQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxpQkFBa0IsV0FBQTtBQUVYLGdEQUFzQyxXQUFBLFFBQVM7TUFDNUQsWUFBWSxPQUFPLHdCQUF3QjtBQUN6QyxjQUFNO0FBRU4sYUFBSyx5QkFBeUI7O01BR2hDLDRCQUE0QjtBQUMxQixlQUFPLEtBQUs7O01BR2QsY0FBYyxpQkFBaUI7QUFDN0IsY0FBTSxjQUFjO0FBRXBCLGFBQUssMEJBQTBCOzthQUcxQixVQUFVLE9BQU87QUFDdEIsY0FBTSxTQUFTLGVBQ1QseUJBQXlCLEdBQ3pCLDBCQUEwQix3QkFBd0Isb0NBQW9DLHlCQUF5QixRQUFRLHlCQUN2SCxrQkFBa0IsS0FBSyxNQUFNLFFBQU0sSUFDbkMsbUJBQW1CLFFBQVEsa0JBQWtCO0FBRW5ELGdDQUF3QixjQUFjO0FBQ3RDLGdDQUF3QixlQUFlO0FBRXZDLGVBQU87O2FBR0YsbUNBQW1DLE9BQU8sT0FBTyx3QkFBd0I7QUFDOUUsY0FBTSxRQUFRLGVBQWUsUUFDdkIsMEJBQTBCLElBQUksTUFBTSxPQUFPO0FBRWpELGVBQU87O2FBR0Ysb0NBQW9DLE9BQU8sUUFBUSx3QkFBd0I7QUFDaEYsWUFBSSwyQkFBMkIsUUFBVztBQUN4QyxtQ0FBeUI7QUFFekIsbUJBQVM7QUFFVCxrQkFBUSxXQUFBOztBQUdWLGNBQU0sT0FBTyxRQUNQLFFBQVE7VUFDTjtXQUVGLDBCQUEwQixJQUFJLE1BQU0sT0FBTztBQUVqRCxlQUFPOzs7QUFJWCw0QkFBd0IsT0FBSztBQUMzQixZQUFNLFFBQVE7QUFFZCxVQUFJLFFBQVE7QUFFWixhQUFPLFFBQVEsT0FBTztBQUNwQixjQUFNLFdBQVcsV0FBQTs7QUFHbkIsYUFBTzs7Ozs7QUMzRVQ7Ozs7O21DQUVnQixvQ0FBQTs7O2VBQUE7OztBQUFULDhDQUEwQyxZQUFZLFFBQU07QUFDakUsVUFBSSxZQUFZO0FBRWhCLFVBQUksZUFBZSxNQUFNO0FBQ3ZCLG9CQUFZO0FBRVosY0FBTSxRQUFRLEdBQ1IsTUFBTTtBQUVaLGlCQUFTLE9BQU8sTUFBTSxPQUFPO0FBRTdCLGVBQU8sUUFBUSxDQUFDLFVBQUE7QUFDZCxnQkFBTSxzQkFBc0IsTUFBTTtBQUVsQyxjQUFJLHFCQUFxQjtBQUN2Qjs7OztBQUtOLGFBQU87Ozs7O0FDdEJUOzs7OzttQ0FXQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsbUJBQW9CLFdBQUE7QUFFYiwwQ0FBZ0MsZ0JBQUEsUUFBdUI7YUFDN0QsNkJBQTZCLGlCQUFpQixRQUFRO0FBQzNELGNBQU0sV0FBVyxnQkFBZ0IsZUFDM0IsVUFBVSxnQkFBZ0IsY0FDMUIsNkJBQTZCLGdCQUFnQiw4QkFBOEIsU0FDM0UsNEJBQTRCLGdCQUFnQiw2QkFBNkIsU0FDekUsaUJBQWlCLElBQUEsUUFBQSxrQ0FBaUMsNEJBQTRCLFNBQzlFLGdCQUFnQixJQUFBLFFBQUEsa0NBQWlDLDJCQUEyQjtBQUVsRixZQUFJO0FBRUosWUFBSSxtQkFBbUIsZUFBZTtBQUNwQyxnQkFBTSxZQUFZO0FBRWxCLGNBQUksY0FBYyxNQUFNO0FBQ3RCLDBCQUFjLFdBQUE7aUJBQ1Q7QUFDTCwwQkFBYyxLQUFLOztlQUVoQjtBQUNMLGNBQUksT0FBTztxQkFFQSxtQkFBbUIsTUFBTTtBQUNsQywwQkFBYyxLQUFLO3FCQUNWLGtCQUFrQixNQUFNO0FBQ2pDLDBCQUFjLEtBQUs7aUJBQ2Q7QUFDTCwwQkFBYyxLQUFLLGtCQUFrQjs7O0FBSXpDLFlBQUksU0FBUyxHQUFHO0FBRWhCLFlBQUksWUFBWSxNQUFNO0FBQ3BCLG1CQUFTLEdBQUcsU0FBUzs7QUFHdkIsaUJBQVMsR0FBRyxTQUFTO0FBRXJCLFlBQUksYUFBYSxnQkFBZ0I7QUFFakMsWUFBSSxlQUFlLE1BQU07QUFDdkIsY0FBSSxlQUFlLFVBQVU7QUFDM0IseUJBQWE7O0FBR2YsbUJBQVMsR0FBRyxXQUFXOztBQUd6QixjQUFNLGVBQWUsT0FBTyxRQUN0QiwrQkFBK0IsY0FDL0IsMEJBQTBCLGdCQUFBLFFBQXdCLFVBQVUsK0JBQzVELHlCQUF5Qix3QkFBd0IsNkJBQ2pELG9CQUFvQixnQkFBQSxRQUF3QixvQ0FBb0MsbUJBQW1CLFFBQVE7QUFFakgsMEJBQWtCLFlBQVk7QUFFOUIsZUFBTzs7Ozs7O0FDcEVYOzs7OzttQ0FVQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxrQkFBbUIsV0FBQTtBQUVaLGtEQUF3QyxXQUFBLFFBQVM7YUFDdkQsVUFBVSxPQUFPO0FBQ3RCLGNBQU0sU0FBUywwQkFBMEIsT0FBTyxpQkFDMUMsT0FBTyxRQUNQLFFBQVE7VUFDTjtXQUVGLDRCQUE0QixJQUFJLDBCQUEwQjtBQUVoRSxlQUFPOzs7QUFJWCx1Q0FBbUMsaUJBQWlCLFdBQVM7QUFDM0QsVUFBSSxTQUFTLFdBQUE7QUFFYixlQUFTLFFBQVEsR0FBRyxRQUFRLGlCQUFpQixTQUFTO0FBQ3BELGtCQUFVOztBQUdaLGFBQU87Ozs7O0FDOUJUOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRUgsNENBQWtDLGdCQUFBLFFBQXVCO2FBQy9ELHdCQUF3QixZQUFZLFFBQVE7QUFDakQsWUFBSSxzQkFBc0I7QUFFMUIsY0FBTSxtQkFBbUIsV0FBVztBQUVwQyxZQUFJLG1CQUFtQixHQUFHO0FBQ3hCLGdCQUFNLHNCQUFzQixXQUFXLE9BQU8sQ0FBQyxzQkFBcUIsY0FBQTtBQUM1RCxrQkFBTSxxQkFBcUIsVUFBVSxZQUFZO0FBRWpELGlDQUFvQixLQUFLO0FBRXpCLG1CQUFPO2FBQ04sS0FDSCw0QkFBNEIsb0JBQW9CO0FBRXRELGNBQUksOEJBQThCLEdBQUc7QUFDbkMsa0JBQU0sMEJBQTBCLE9BQU07QUFFdEMsa0NBQXNCO2lCQUNqQjtBQUNMLGdCQUFJLDZCQUNBLDZCQUE2QixHQUM3QiwyQkFBMkIsR0FDM0IsMkJBQTJCO0FBRS9CLGdDQUFvQixRQUFRLENBQUMsb0JBQW9CLFVBQUE7QUFDL0Msb0JBQU0sMEJBQTBCLG1CQUFtQixZQUM3QywwQkFBMEIsbUJBQW1CO0FBRW5ELGtCQUFJLFVBQVUsR0FBRztBQUNmLHNCQUFNLDBCQUEwQixvQkFDMUIsZ0RBQWdELHdCQUF3QjtBQUU5RSw4Q0FBOEI7O0FBR2hDLGtCQUFJLFVBQVUsNEJBQTRCLEdBQUc7QUFDM0Msc0JBQU0seUJBQXlCLG9CQUN6QiwrQ0FBK0MsdUJBQXVCO0FBRTVFLDhDQUE4Qjs7QUFHaEMsa0JBQUksUUFBUSw0QkFBNEIsR0FBRztBQUN6Qyw4Q0FBOEI7QUFDOUIsOENBQThCO0FBRTlCLDRDQUE0Qjs7QUFHOUIsMENBQTRCO0FBRTVCLHlDQUEyQixLQUFLLElBQUksMEJBQTBCOztBQUdoRSxrQkFBTSxRQUFRLDZCQUE2Qiw4QkFBOEIsR0FDbkUsMEJBQTBCLGdCQUFBLFFBQXdCLFVBQVUsUUFDNUQsNEJBQTRCLGtCQUFBLFFBQTBCLFVBQVUsUUFDaEUsa0JBQWtCLDZCQUNsQixtQkFBbUIsMkJBQTJCLFFBQVE7QUFFNUQsb0NBQXdCLGNBQWM7QUFDdEMsb0NBQXdCLGVBQWU7QUFDdkMsc0NBQTBCLGNBQWM7QUFDeEMsc0NBQTBCLGVBQWU7QUFFekMsa0JBQU0seUJBQXlCLHdCQUF3Qiw2QkFDakQsUUFBUTtBQUVkLGtDQUFzQixnQkFBQSxRQUF3QixtQ0FBbUMscUJBQXFCLE9BQU87QUFFN0csZ0NBQW9CLFFBQVEsQ0FBQyxvQkFBb0IsVUFBQTtBQUMvQyxvQkFBTSwwQkFBMEIsbUJBQW1CLFlBQzdDLDJCQUEyQixtQkFBbUI7QUFFcEQsa0JBQUksUUFBUSw0QkFBNEIsR0FBRztBQUN6QyxzQkFBTSxvQkFBbUI7QUFFekIseUNBQXlCLGVBQWU7O0FBRzFDLGtCQUFJLDBCQUEwQiwwQkFBMEI7QUFDdEQsc0JBQU0sb0JBQW9CLDJCQUEyQjtBQUVyRCx5Q0FBeUIsZ0JBQWdCOztBQUczQyxrQ0FBb0IsY0FBYzs7QUFHcEMsZ0NBQW9CLFlBQVk7QUFFaEMsZ0NBQW9CLFlBQVk7OztBQUlwQyxlQUFPOzs7Ozs7QUMxR1g7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTixpREFBdUMsZ0JBQUEsUUFBdUI7YUFDcEUsNkJBQTZCLGlCQUFpQixRQUFRO0FBQzNELFlBQUk7QUFFSixjQUFNLGFBQWEsZ0JBQWdCLGlCQUM3QixvQkFBb0IsVUFBQSxRQUFrQiw2QkFBNkIsaUJBQWlCLFNBQ3BGLHNCQUFzQixZQUFBLFFBQW9CLHdCQUF3QixZQUFZO0FBRXBGLFlBQUksd0JBQXdCLE1BQU07QUFDaEMsZ0JBQU0seUJBQXlCLGtCQUFrQixZQUMzQywwQ0FBMEMsa0JBQWtCLDZCQUM1RCx5QkFBeUIseUNBQ3pCLFFBQVE7QUFFZCxxQ0FBMkIsZ0JBQUEsUUFBd0IsbUNBQW1DLDBCQUEwQixPQUFPO0FBRXZILG1DQUF5QixjQUFjO2VBQ2xDO0FBQ0wsY0FBSSwwQ0FBMEMsa0JBQWtCO0FBRWhFLGdCQUFNLDRDQUE0QyxvQkFBb0IsNkJBQ2hFLG9DQUFvQywwQ0FBMEM7QUFFcEYsY0FBSTtBQUVKLGNBQUksT0FBTztxQkFFQSxvQ0FBb0MsR0FBRztBQUNoRCw4QkFBa0IsQ0FBQztBQUVuQiw4QkFBa0IsY0FBYztxQkFDdkIsb0NBQW9DLEdBQUc7QUFDaEQsOEJBQWtCLENBQUM7QUFFbkIsZ0NBQW9CLGNBQWM7O0FBR3BDLGdCQUFNLHlCQUF5QixrQkFBa0IsWUFDM0MsMkJBQTJCLG9CQUFvQixZQUMvQyxtQkFBbUIseUJBQXlCO0FBRWxELGNBQUk7QUFFSixjQUFJLE9BQU87cUJBRUEsbUJBQW1CLEdBQUc7QUFDL0IsK0JBQW1CLENBQUM7QUFFcEIsOEJBQWtCLGVBQWU7cUJBQ3hCLG1CQUFtQixHQUFHO0FBQy9CLCtCQUFtQixDQUFDO0FBRXBCLGdDQUFvQixlQUFlOztBQUdyQyxvREFBMEMsa0JBQWtCO0FBRTVELGdCQUFNLHlCQUF5QixrQkFBa0IsWUFDM0MseUJBQXlCLHlDQUN6QixRQUFRO0FBRWQscUNBQTJCLGdCQUFBLFFBQXdCLG1DQUFtQywwQkFBMEIsT0FBTztBQUV2SCxtQ0FBeUIsY0FBYztBQUV2QyxtQ0FBeUIsZUFBZTs7QUFHMUMsZUFBTzs7Ozs7O0FDMUVYOzs7OzttQ0FXQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUhyQixRQUFNLENBQUUsZUFBTyxTQUFVLFdBQUE7QUFBekIsUUFDTSxDQUFFLFFBQVEscUJBQXNCLFlBQVksMkJBQTRCLGFBQUE7QUFFL0QsZ0NBQU07TUFDbkIsWUFBWSxVQUFVLFlBQVksWUFBWSxTQUFTLFlBQVk7QUFDakUsYUFBSyxXQUFXO0FBQ2hCLGFBQUssYUFBYTtBQUNsQixhQUFLLGFBQWE7QUFDbEIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxhQUFhOztNQUdwQixjQUFjO0FBQ1osZUFBTyxLQUFLOztNQUdkLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsYUFBYTtBQUNYLGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsWUFBWSxVQUFVO0FBQ3BCLGFBQUssV0FBVzs7TUFHbEIsY0FBYyxZQUFZO0FBQ3hCLGFBQUssYUFBYTs7TUFHcEIsY0FBYyxZQUFZO0FBQ3hCLGNBQU0sYUFBYSxHQUNiLGNBQWMsVUFDZCxrQkFBa0I7QUFFeEIsYUFBSyxpQkFBaUIsWUFBWSxhQUFhOztNQUdqRCxXQUFXLFNBQVM7QUFDbEIsYUFBSyxVQUFVOztNQUdqQixjQUFjLFlBQVk7QUFDeEIsYUFBSyxhQUFhOztNQUdwQixXQUFXO0FBQ1QsY0FBTSxTQUFVLEtBQUssWUFBWTtBQUVqQyxlQUFPOztNQUdULGVBQWU7QUFDYixjQUFNLGFBQWMsS0FBSyxZQUFZO0FBRXJDLGVBQU87O01BR1QsZ0JBQWdCO0FBQ2QsY0FBTSxhQUFjLEtBQUssWUFBWTtBQUVyQyxlQUFPOztNQUdULGlCQUFpQjtBQUNmLGNBQU0sZUFBZTtBQUVyQixlQUFPOztNQUdULG9CQUFvQjtBQUNsQixjQUFNLGtCQUFrQjtBQUV4QixlQUFPOztNQUdULG1CQUFtQixpQkFBaUI7QUFDbEMsZUFBTzs7TUFHVCw4QkFBOEIsUUFBUTtBQUNwQyxZQUFJO0FBRUosYUFBSyxzQkFBc0IsQ0FBQyxjQUFBO0FBQzFCLGdCQUFNLE9BQU87QUFFYix1Q0FBNkIsS0FBSyw4QkFBOEI7QUFFaEUsY0FBSSwrQkFBK0IsTUFBTTtBQUN2QyxtQkFBTzs7O0FBSVgsZUFBTzs7TUFHVCw2QkFBNkIsUUFBUTtBQUNuQyxZQUFJO0FBRUosYUFBSyx1QkFBdUIsQ0FBQyxjQUFBO0FBQzNCLGdCQUFNLE9BQU87QUFFYixzQ0FBNEIsS0FBSyw2QkFBNkI7QUFFOUQsY0FBSSw4QkFBOEIsTUFBTTtBQUN0QyxtQkFBTzs7O0FBSVgsZUFBTzs7TUFHVCxxQkFBcUIsb0JBQW9CLElBQUk7QUFDM0MsYUFBSyxXQUFXLFFBQVEsQ0FBQyxjQUFBO0FBQ3ZCLG9CQUFVLHFCQUFxQjs7QUFHakMsZUFBTzs7TUFHVCxrQkFBa0I7QUFDaEIsY0FBTSxtQkFBbUIsS0FBSyxXQUFXLFFBQ25DLGVBQWU7QUFFckIsZUFBTzs7TUFHVCxVQUFVO0FBQ1IsY0FBTSxlQUFlLEtBQUssbUJBQ3BCLFFBQVMsaUJBQWlCO0FBRWhDLGVBQU87O01BR1QsYUFBYTtBQUNYLGNBQU0sZUFBZSxLQUFLLG1CQUNwQixXQUFZLGlCQUFpQjtBQUVuQyxlQUFPOztNQUdULGtCQUFrQixVQUFVLFlBQVk7QUFDdEMsWUFBSTtBQUVKLFlBQUksT0FBTzttQkFFQSxLQUFLLGVBQWUsTUFBTTtBQUNuQyw0QkFBa0I7bUJBQ1QsS0FBSyxlQUFlLFVBQVU7QUFDdkMsZ0JBQU0saUJBQWlCLE9BQU0sS0FBSztBQUVsQyw0QkFBa0IsZUFBZSxrQkFBa0IsVUFBVTtlQUN4RDtBQUNMLDRCQUFvQixLQUFLLGFBQWEsWUFBYyxLQUFLLGFBQWE7O0FBR3hFLGVBQU87O01BR1Qsa0JBQWtCO0FBQ2hCLFlBQUksZ0JBQWdCO0FBRXBCLFlBQUksS0FBSyxlQUFlLE1BQU07QUFDNUIsMEJBQWdCLEtBQUssV0FBVyxLQUFLLENBQUMsY0FBQTtBQUNwQyxrQkFBTSwyQkFBMkIsVUFBVSxrQkFBa0IsS0FBSyxVQUFVLEtBQUs7QUFFakYsZ0JBQUksMEJBQTBCO0FBQzVCLHFCQUFPOzs7O0FBS2IsZUFBTzs7TUFHVCxZQUFZLFFBQVE7QUFDbEIsY0FBTSxrQkFBa0IsTUFDbEIsMkJBQTJCLGlCQUFBLFFBQXlCLDZCQUE2QixpQkFBaUIsU0FDbEcsWUFBWTtBQUVsQixlQUFPOztNQUdULE1BQU0sTUFBTSxRQUFRLFVBQVUsVUFBVSxPQUFPO0FBQzdDLFlBQUksVUFBVTtBQUVkLGNBQU0sc0JBQXNCLEtBQUs7QUFFakMsWUFBSSxxQkFBcUI7QUFDdkIsZ0JBQU0sa0JBQWtCLE1BQ2xCLDBCQUEwQixnQkFBZ0I7QUFFaEQsY0FBSSxLQUFLLGFBQWEseUJBQXlCO0FBQzdDLGtCQUFNLHlCQUF5QixnQkFBZ0I7QUFFL0MsZ0JBQUksS0FBSyxZQUFZLHdCQUF3QjtBQUMzQyxvQkFBTSxhQUFhLEtBQUssaUJBQ2xCLDRCQUE0QixnQkFBZ0I7QUFFbEQsa0JBQUksZUFBZSwyQkFBMkI7QUFDNUM7QUFFQSxvQkFBSSxVQUFVLEdBQUc7QUFDZiw0QkFBVTt1QkFDTDtBQUNMLHdCQUFNLDRCQUE0QixnQkFBZ0I7QUFFbEQsNEJBQVUsTUFBTSxLQUFLLFlBQVksMkJBQTJCLENBQUMsV0FBVyw2QkFBQTtBQUN0RSwwQkFBTSwyQ0FBMkMsVUFBVSxNQUFNLDBCQUEwQixPQUFPO0FBRWxHLHdCQUFJLDBDQUEwQztBQUM1Qyw2QkFBTzs7Ozs7Ozs7QUFTckIsZUFBTzs7TUFHVCxRQUFRLE9BQU87QUFDYixjQUFNLDJCQUEyQjtBQUVqQyxlQUFPOztNQUdULFVBQVU7QUFDUixhQUFLLGlCQUFpQixDQUFDLGNBQUE7QUFDckIsb0JBQVU7O0FBR1osYUFBSyxhQUFhO0FBQ2xCLGFBQUssYUFBYTs7TUFHcEIsU0FBUyxvQkFBb0I7QUFDM0IsY0FBTSxRQUFRLEtBQUssYUFDYixhQUFhLE1BQ2IsV0FBVyxLQUFLLFVBQ2hCLGFBQWEsZ0JBQWdCLEtBQUssYUFDbEMsVUFBVSxLQUFLLFNBQ2YsYUFBYSxLQUFLLFlBQ2xCLGtCQUFrQixJQUFJLE1BQU0sVUFBVSxZQUFZLFlBQVksU0FBUyxZQUFBLEdBQWU7QUFFNUYsd0JBQWdCO0FBRWhCLGVBQU87O2FBR0YsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVMsZUFBZSxvQkFBb0I7QUFDekgsWUFBSSxlQUFlLFFBQVc7QUFDNUIsdUJBQWE7QUFFYixvQkFBVTtBQUVWLHVCQUFhO0FBRWIscUJBQVc7QUFFWCxrQkFBUTs7QUFHVixjQUFNLGFBQWEsTUFDYixrQkFBa0IsSUFBSSxNQUFNLFVBQVUsWUFBWSxZQUFZLFNBQVMsWUFBQSxHQUFlO0FBRTVGLHdCQUFnQjtBQUVoQixlQUFPOzs7QUFJWCxXQUFPLE9BQU8sZ0JBQWdCLFdBQVcsTUFBQTtBQUV6Qyw2QkFBeUIsWUFBVTtBQUNqQyxtQkFBYSxXQUFXLElBQUksQ0FBQyxjQUFBO0FBQzNCLG9CQUFZLFVBQVU7QUFFdEIsZUFBTzs7QUFHVCxhQUFPOzs7OztBQzdTVDs7Ozs7bUNBRUEsV0FBQTs7O2VBQXFCOzs7QUFBTixnQ0FBTTtNQUNuQixZQUFZLE1BQU0sV0FBVztBQUMzQixhQUFLLE9BQU87QUFDWixhQUFLLFlBQVk7O01BR25CLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxvQkFBb0I7QUFDbEIsY0FBTSxrQkFBa0I7QUFFeEIsZUFBTzs7TUFHVCxpQkFBaUI7QUFDZixjQUFNLGVBQWU7QUFFckIsZUFBTzs7TUFHVCxpQkFBaUI7QUFDZixjQUFNLGVBQWU7QUFFckIsZUFBTzs7Ozs7O0FDL0JYOzs7Ozs7Ozs7Ozs7O1VBSWEsd0JBQUE7ZUFBQTs7VUFDQSx5QkFBQTtlQUFBOztVQUZBLHVCQUFBO2VBQUE7O1VBREEsbUJBQUE7ZUFBQTs7VUFLQSwwQkFBQTtlQUFBOztVQURBLDBCQUFBO2VBQUE7O1VBR2IsVUFBQTtlQUFBOzs7QUFQTyxRQUFNLG1CQUFtQjtBQUN6QixRQUFNLHVCQUF1QjtBQUM3QixRQUFNLHdCQUF3QjtBQUM5QixRQUFNLHlCQUF5QjtBQUMvQixRQUFNLDBCQUEwQjtBQUNoQyxRQUFNLDBCQUEwQjtRQUV2QyxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQ2ZGOzs7Ozs7Ozs7Ozs7O1VBV0EsVUFBQTtlQUFxQjs7VUE4Q0wsb0JBQUE7ZUFBQTs7Ozs7Ozs7Ozs7QUFoRGhCLFFBQU0sQ0FBRSxnQkFBaUIsYUFBQTtBQUVWLHlDQUErQixhQUFBLFFBQWU7TUFDM0QsWUFBWSxNQUFNLFdBQVcsTUFBTTtBQUNqQyxjQUFNLE1BQU07QUFFWixhQUFLLE9BQU87O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLGNBQU0sYUFBYSxNQUFNLGlCQUNuQixjQUFjLE1BQU07QUFFMUIsaUJBQVMsa0JBQWtCLEtBQUssTUFBTSxPQUFPLE9BQU8sVUFBVTtBQUU5RCxZQUFJLENBQUMsUUFBUTtBQUNYLGdCQUFNLFFBQVE7QUFFZCxnQkFBTSxPQUFPO0FBRWIsZ0JBQU0sVUFBVTs7QUFHbEIsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxhQUFhLEtBQUssS0FBSyxZQUN2QixTQUFTLEdBQUcsYUFBYTtBQUUvQixlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixjQUFNLE9BQU8sV0FBQSxzQkFDUCxZQUFZLE9BQ1osbUJBQW1CLElBQUksaUJBQWlCLE1BQU0sV0FBVztBQUUvRCxlQUFPOzs7QUFJSiwrQkFBMkIsTUFBTSxPQUFPLE9BQU8sVUFBVSxXQUFTO0FBQ3ZFLFVBQUk7QUFFSixVQUFJLGNBQWMsTUFBTTtBQUN0QixpQkFBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFNNUMsaUJBQVM7YUFDSjtBQUNMLGlCQUFTO0FBRVQsWUFBSSxDQUFDLFFBQVE7QUFDWCxtQkFBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVU7OztBQVVoRCxhQUFPOzs7OztBQ2xGVDs7Ozs7Ozs7Ozs7OztVQVdBLFVBQUE7ZUFBcUI7O1VBOENMLDJCQUFBO2VBQUE7Ozs7Ozs7Ozs7O0FBaERoQixRQUFNLENBQUUsWUFBYSxhQUFBO0FBRU4sNENBQWtDLGFBQUEsUUFBZTtNQUM5RCxZQUFZLE1BQU0sV0FBVyxNQUFNO0FBQ2pDLGNBQU0sTUFBTTtBQUVaLGFBQUssT0FBTzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosY0FBTSxhQUFhLE1BQU0saUJBQ25CLGNBQWMsTUFBTTtBQUUxQixpQkFBUyx5QkFBeUIsS0FBSyxNQUFNLE9BQU8sT0FBTyxVQUFVO0FBRXJFLFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU0sUUFBUTtBQUVkLGdCQUFNLE9BQU87QUFFYixnQkFBTSxVQUFVOztBQUdsQixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLGFBQWEsS0FBSyxLQUFLLFlBQ3ZCLFNBQVMsR0FBRyxhQUFhO0FBRS9CLGVBQU87O2FBR0YsU0FBUyxNQUFNO0FBQ3BCLGNBQU0sT0FBTyxXQUFBLHlCQUNQLFlBQVksT0FDWixzQkFBc0IsSUFBSSxvQkFBb0IsTUFBTSxXQUFXO0FBRXJFLGVBQU87OztBQUlKLHNDQUFrQyxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVM7QUFDOUUsVUFBSTtBQUVKLFVBQUksY0FBYyxNQUFNO0FBQ3RCLGlCQUFTLEtBQUssTUFBTSxPQUFPLE9BQU8sVUFBVTtBQUU1QyxZQUFJLFFBQVE7QUFDVixtQ0FBeUIsTUFBTSxPQUFPLE9BQU8sVUFBVTs7QUFHekQsaUJBQVM7YUFDSjtBQUNMLGlCQUFTO0FBRVQsWUFBSSxDQUFDLFFBQVE7QUFDWCxtQkFBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVUsTUFBQTtBQUMxQyxnQkFBSTtBQUVKLHNCQUFTLHlCQUF5QixNQUFNLE9BQU8sT0FBTyxVQUFVO0FBRWhFLG1CQUFPOzs7O0FBS2IsYUFBTzs7Ozs7QUNsRlQ7Ozs7Ozs7Ozs7Ozs7VUFXQSxVQUFBO2VBQXFCOztVQThDTCwwQkFBQTtlQUFBOzs7Ozs7Ozs7Ozs7QUFoRGhCLFFBQU0sQ0FBRSxRQUFTLGFBQUE7QUFFRiwyQ0FBaUMsYUFBQSxRQUFlO01BQzdELFlBQVksTUFBTSxXQUFXLE1BQU07QUFDakMsY0FBTSxNQUFNO0FBRVosYUFBSyxPQUFPOztNQUdkLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsTUFBTSxPQUFPLE9BQU8sVUFBVSxXQUFXO0FBQ3ZDLFlBQUk7QUFFSixjQUFNLGFBQWEsTUFBTSxpQkFDbkIsY0FBYyxNQUFNO0FBRTFCLGlCQUFTLHdCQUF3QixLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFFcEUsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxRQUFRO0FBRWQsZ0JBQU0sT0FBTztBQUViLGdCQUFNLFVBQVU7O0FBR2xCLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0sYUFBYSxLQUFLLEtBQUssWUFDdkIsU0FBUyxHQUFHLGFBQWE7QUFFL0IsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsY0FBTSxPQUFPLFdBQUEsd0JBQ1AsWUFBWSxPQUNaLHFCQUFxQixJQUFJLG1CQUFtQixNQUFNLFdBQVc7QUFFbkUsZUFBTzs7O0FBSUoscUNBQWlDLE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBUztBQUM3RSxVQUFJO0FBRUosVUFBSSxjQUFjLE1BQU07QUFDdEIsaUJBQVMsS0FBSyxNQUFNLE9BQU8sT0FBTyxVQUFVO0FBRTVDLFlBQUksUUFBUTtBQUNWLFVBQUEsSUFBQSxpQkFBQSwwQkFBeUIsTUFBTSxPQUFPLE9BQU8sVUFBVTs7YUFJcEQ7QUFJSCxpQkFBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVUsTUFBQTtBQUMxQyxjQUFJO0FBRUosb0JBQVMsSUFBQSxpQkFBQSwwQkFBeUIsTUFBTSxPQUFPLE9BQU8sVUFBVTtBQUVoRSxpQkFBTzs7O0FBS2IsYUFBTzs7Ozs7QUNsRlQ7Ozs7Ozs7Ozs7Ozs7VUF3QmEsZ0NBQUE7ZUFBQTs7VUFOQSw0QkFBQTtlQUFBOztVQUhBLHdCQUFBO2VBQUE7O1VBTEEsdUJBQUE7ZUFBQTs7VUFIQSxxQkFBQTtlQUFBOztVQU1BLHdCQUFBO2VBQUE7O1VBUEEsb0JBQUE7ZUFBQTs7VUFEQSxrQkFBQTtlQUFBOztVQUhBLGlCQUFBO2VBQUE7O1VBa0JBLDhCQUFBO2VBQUE7O1VBRUEsK0JBQUE7ZUFBQTs7VUFNQSxtQ0FBQTtlQUFBOztVQVRBLDZCQUFBO2VBQUE7O1VBTUEsZ0NBQUE7ZUFBQTs7VUFYQSx3QkFBQTtlQUFBOztVQVhBLGlCQUFBO2VBQUE7O1VBUUEsdUJBQUE7ZUFBQTs7VUFDQSx1QkFBQTtlQUFBOztVQVdBLCtCQUFBO2VBQUE7O1VBZEEsc0JBQUE7ZUFBQTs7VUFMQSxpQkFBQTtlQUFBOztVQWlCQSw4QkFBQTtlQUFBOztVQU1BLG1DQUFBO2VBQUE7O1VBREEsa0NBQUE7ZUFBQTs7VUFUQSwyQkFBQTtlQUFBOztVQURBLDBCQUFBO2VBQUE7O1VBUkEscUJBQUE7ZUFBQTs7VUFxQkEsb0NBQUE7ZUFBQTs7O0FBM0JOLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sMEJBQTBCO0FBQ2hDLFFBQU0sMkJBQTJCO0FBQ2pDLFFBQU0sNEJBQTRCO0FBQ2xDLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sOEJBQThCO0FBQ3BDLFFBQU0sOEJBQThCO0FBQ3BDLFFBQU0sK0JBQStCO0FBQ3JDLFFBQU0sK0JBQStCO0FBQ3JDLFFBQU0sZ0NBQWdDO0FBQ3RDLFFBQU0sZ0NBQWdDO0FBQ3RDLFFBQU0sa0NBQWtDO0FBQ3hDLFFBQU0sbUNBQW1DO0FBQ3pDLFFBQU0sbUNBQW1DO0FBQ3pDLFFBQU0sb0NBQW9DOzs7O0FDN0JqRDs7Ozs7Ozs7Ozs7OztVQXVEZ0IsOEJBQUE7ZUFBQTs7VUEvQ0EsbUJBQUE7ZUFBQTs7VUErQkEsdUJBQUE7ZUFBQTs7VUFoQkEscUJBQUE7ZUFBQTs7VUFpREEsNkJBQUE7ZUFBQTs7Ozs7QUFsRWhCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRVgsOEJBQTBCLE1BQUk7QUFDbkMsVUFBSSxtQkFBbUI7QUFFdkIsWUFBTSxtQkFBbUIsS0FBSztBQUU5QixVQUFJLGtCQUFrQjtBQUNwQixjQUFNLGVBQWUsTUFDZixzQkFBc0IsYUFBYTtBQUV6QywyQkFBb0Isd0JBQXdCOztBQUc5QyxhQUFPOztBQUdGLGdDQUE0QixNQUFJO0FBQ3JDLFVBQUksbUJBQW1CO0FBRXZCLFlBQU0sbUJBQW1CLEtBQUssa0JBQ3hCLHNCQUFzQixDQUFDO0FBRTdCLFVBQUkscUJBQXFCO0FBQ3ZCLGNBQU0sa0JBQWtCLE1BQ2xCLDBCQUEwQixnQkFBZ0I7QUFFaEQsMkJBQW9CLDRCQUE0QixXQUFBOztBQUdsRCxhQUFPOztBQUdGLGtDQUE4QixNQUFJO0FBQ3ZDLFVBQUkscUJBQXFCO0FBRXpCLFlBQU0sc0JBQXNCLEtBQUs7QUFFakMsVUFBSSxxQkFBcUI7QUFDdkIsY0FBTSxrQkFBa0IsTUFDbEIsV0FBVyxnQkFBZ0IsZUFDM0IsNkJBQThCLGFBQWEsV0FBQTtBQUVqRCw2QkFBcUI7O0FBR3ZCLGFBQU87O0FBR0YseUNBQXFDLE1BQUk7QUFDOUMsVUFBSSw0QkFBNEI7QUFFaEMsWUFBTSxzQkFBc0IsS0FBSztBQUVqQyxVQUFJLHFCQUFxQjtBQUN2QixjQUFNLGtCQUFrQixNQUNsQixXQUFXLGdCQUFnQixlQUMzQixvQ0FBcUMsYUFBYSxXQUFBO0FBRXhELG9DQUE0Qjs7QUFHOUIsYUFBTzs7QUFJRix3Q0FBb0MsZ0JBQWM7QUFDdkQsVUFBSTtBQUVKLHdCQUFrQjtBQUVsQixZQUFNLGFBQWEsZ0JBQWdCLGlCQUM3QixpQkFBaUIsT0FBTTtBQUU3Qix3QkFBa0I7QUFFbEIsWUFBTSxXQUFXLGdCQUFnQjtBQUVqQyxhQUFPOzs7OztBQ3BGVDs7Ozs7bUNBY0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFFBQVMsV0FBQTtBQUVGLG9DQUEwQixhQUFBLFFBQWU7TUFDdEQsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sYUFBYSxLQUFLLGlCQUNsQixRQUFRLFdBQVcsU0FDbkIsT0FBTyxjQUFjO0FBRTNCLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLGFBQWEsVUFBVSxZQUFZLFNBQVM7OztBQUcvTSwyQkFBdUIsT0FBSztBQUMxQixVQUFJO0FBRUosWUFBTSxjQUFjLE1BQU07QUFFMUIsVUFBSSxnQkFBZ0IsR0FBRztBQUNyQixjQUFNLE9BQU8sTUFBTSxPQUNiLFlBQVk7QUFFbEIsZUFBTyxLQUFLLGFBQWE7YUFDcEI7QUFDTCxjQUFNLHlCQUF5Qix5QkFBeUI7QUFFeEQsWUFBSSx3QkFBd0I7QUFDMUIsZ0JBQU0sT0FBTyxNQUFNLE9BQ2IsaUJBQWlCO0FBRXZCLGlCQUFPLGNBQWM7QUFFckIsZ0JBQU0sV0FBVyxJQUFBLEtBQUEsNEJBQTJCLGlCQUN0Qyx3QkFBd0IseUNBQXlDLE1BQU07QUFFN0UsaUJBQU87ZUFDRjtBQUNMLGdCQUFNO0FBRU4saUJBQU8sY0FBYzs7O0FBSXpCLGFBQU87O0FBR1Qsc0NBQWtDLE9BQUs7QUFDckMsWUFBTSxXQUFXLEtBQUssUUFDaEIseUJBQXlCLElBQUEsS0FBQSxzQkFBcUI7QUFFcEQsYUFBTzs7QUFHVCxzREFBa0QsTUFBTSxVQUFRO0FBQzlELFVBQUk7QUFFSixjQUFRO2FBQ0QsV0FBQTtBQUNILGdCQUFNLG1CQUFtQixjQUFBLFFBQWlCLFNBQVM7QUFFbkQsa0NBQXdCO0FBQ3hCO2FBRUcsV0FBQTtBQUNILGdCQUFNLHFCQUFxQixnQkFBQSxRQUFtQixTQUFTO0FBRXZELGtDQUF3QjtBQUN4QjthQUVHLFdBQUE7QUFDSCxnQkFBTSxzQkFBc0IsaUJBQUEsUUFBb0IsU0FBUztBQUV6RCxrQ0FBd0I7QUFDeEI7O0FBR0osYUFBTzs7Ozs7QUN6RlQ7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsaUJBQVUsV0FBQTtBQUVILG9DQUEwQixhQUFBLFFBQWU7TUFDdEQsVUFBVTtBQUNSLGNBQU0sYUFBYSxLQUFLLGlCQUNsQixpQkFBaUIsT0FBTSxhQUN2QixlQUFlLGdCQUNmLHNCQUFzQixhQUFhLGNBQ25DLE9BQU87QUFFYixlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxhQUFBLFFBQWdCLDJDQUEyQyxhQUFhLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNuQi9NOzs7Ozs7Ozs7Ozs7O1VBRWdCLGdDQUFBO2VBQUE7O1VBc0JBLGlDQUFBO2VBQUE7OztBQXRCVCwyQ0FBdUMsWUFBWSxVQUFRO0FBQ2hFLFVBQUksT0FBTztBQUVYLGlCQUFXLEtBQUssQ0FBQyxjQUFBO0FBQ2YsY0FBTSwyQkFBMkIsVUFBVTtBQUUzQyxZQUFJLDBCQUEwQjtBQUM1QixnQkFBTSxrQkFBa0IsV0FDbEIsMEJBQTBCLGdCQUFnQixlQUMxQyxrQ0FBbUMsNEJBQTRCO0FBRXJFLGNBQUksaUNBQWlDO0FBQ25DLG1CQUFPO0FBRVAsbUJBQU87Ozs7QUFLYixhQUFPOztBQUdGLDRDQUF3QyxZQUFZLFVBQVE7QUFDakUsWUFBTSxRQUFRLFdBQVcsT0FBTyxDQUFDLGNBQUE7QUFDL0IsY0FBTSwyQkFBMkIsVUFBVTtBQUUzQyxZQUFJLDBCQUEwQjtBQUM1QixnQkFBTSxrQkFBa0IsV0FDbEIsMEJBQTBCLGdCQUFnQixlQUMxQyxrQ0FBbUMsNEJBQTRCO0FBRXJFLGNBQUksaUNBQWlDO0FBQ25DLG1CQUFPOzs7O0FBS2IsYUFBTzs7Ozs7QUN2Q1Q7Ozs7O21DQVdBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxlQUFPLGNBQWUsV0FBQTtBQUVmLG9DQUEwQixhQUFBLFFBQWU7TUFDdEQsYUFBYSxNQUFNO0FBQ2pCLGNBQU0sT0FBTyxLQUFLLFdBQ1osVUFBVSxLQUFLLGNBQ2YsY0FBYyxLQUFLLHVCQUNuQixPQUFPLEtBQUssOEJBQThCLE1BQU0sU0FBUztBQUUvRCxlQUFPOztNQUdULGFBQWE7QUFDWCxZQUFJLFVBQVU7QUFFZCxjQUFNLFdBQVcsV0FBQSw0QkFDWCxhQUFhLEtBQUssaUJBQ2xCLHlCQUF5QixJQUFBLE1BQUEsK0JBQThCLFlBQVk7QUFFekUsWUFBSSwyQkFBMkIsTUFBTTtBQUNuQyxvQkFBVSx1QkFBdUI7O0FBR25DLGVBQU87O01BR1QsVUFBVTtBQUNSLGNBQU0sYUFBYSxLQUFLLGlCQUNsQixpQkFBaUIsT0FBTSxhQUN2QixjQUFjLGdCQUNkLE9BQU8sWUFBWTtBQUV6QixlQUFPOztNQUdULHNCQUFzQjtBQUNwQixjQUFNLGFBQWEsS0FBSyxpQkFDbEIsc0JBQXNCLFdBQVcsYUFDakMscUJBQXFCLHFCQUNyQixjQUFjLG1CQUFtQjtBQUV2QyxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxhQUFBLFFBQWdCLDJDQUEyQyxhQUFhLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNyRC9NOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLHFDQUEyQixhQUFBLFFBQWU7YUFDaEQsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLGNBQWMsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ0xoTjs7Ozs7bUNBRUEsV0FBQTs7O2VBQXFCOzs7QUFBTiw2QkFBTTtNQUNuQixjQUFjO0FBQ1osY0FBTSxZQUFZO0FBRWxCLGVBQU87O01BR1Qsb0JBQW9CO0FBQ2xCLGNBQU0sa0JBQWtCO0FBRXhCLGVBQU87O01BR1QsaUJBQWlCO0FBQ2YsY0FBTSxlQUFlO0FBRXJCLGVBQU87O01BR1QscUJBQXFCO0FBQ25CLGNBQU0sbUJBQW1CO0FBRXpCLGVBQU87O01BR1QsdUJBQXVCO0FBQ3JCLGNBQU0scUJBQXFCO0FBRTNCLGVBQU87Ozs7OztBQzlCWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLG9CQUFvQiw2QkFBOEIsV0FBQTtBQUUzQyw4Q0FBb0MsZ0JBQUEsUUFBdUI7YUFDakUsMEJBQTBCLGNBQWMsUUFBUTtBQUNyRCxZQUFJO0FBRUosa0JBQVUsYUFBYTtBQUV2QixrQkFBVSxRQUFRLFFBQVEsV0FBVyxDQUFDLFVBQUE7QUFDcEMsa0JBQVE7aUJBQ0Q7QUFDSCxxQkFBTztpQkFFSjtBQUNILHFCQUFPOztBQUdQLHFCQUFPOzs7QUFJYixjQUFNLE9BQU8sYUFBYSxXQUNwQix3QkFBd0IsYUFBYSx5QkFBeUIsU0FDOUQsWUFBWSxJQUFBLFFBQUEsa0NBQWlDLHVCQUF1QjtBQUUxRSxZQUFJO0FBRUosWUFBSSxjQUFjLE1BQU07QUFDdEIsd0JBQWMsV0FBQTtlQUNUO0FBQ0wsd0JBQWMsS0FBSzs7QUFHckIsY0FBTSxTQUFTLElBQUksWUFBWSxRQUFRLGVBQ2pDLGVBQWUsT0FBTyxRQUN0QiwrQkFBK0IsY0FDL0IsMEJBQTBCLGdCQUFBLFFBQXdCLFVBQVUsK0JBQzVELHlCQUF5Qix3QkFBd0IsNkJBQ2pELHdCQUF3QixnQkFBQSxRQUF3QixvQ0FBb0MsdUJBQXVCLFFBQVE7QUFFekgsOEJBQXNCLFlBQVk7QUFFbEMsZUFBTzs7Ozs7O0FDbkRYOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLDZCQUFNO01BQ25CLFlBQVksWUFBWSxrQkFBa0I7QUFDeEMsYUFBSyxhQUFhO0FBQ2xCLGFBQUssbUJBQW1COztNQUcxQixnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2Qsc0JBQXNCO0FBQ3BCLGVBQU8sS0FBSzs7TUFHZCxjQUFjLFlBQVk7QUFDeEIsYUFBSyxhQUFhOztNQUdwQixvQkFBb0Isa0JBQWtCO0FBQ3BDLGFBQUssbUJBQW1COztNQUcxQix1QkFBdUI7QUFDckIsY0FBTSxxQkFBcUI7QUFFM0IsZUFBTzs7TUFHVCxxQkFBcUI7QUFDbkIsY0FBTSxtQkFBbUI7QUFFekIsZUFBTzs7TUFHVCxnQkFBZ0I7QUFDZCxjQUFNLGNBQWM7QUFFcEIsZUFBTzs7TUFHVCxpQkFBaUI7QUFDZixjQUFNLGVBQWU7QUFFckIsZUFBTzs7TUFHVCxvQkFBb0I7QUFDbEIsY0FBTSxrQkFBa0I7QUFFeEIsZUFBTzs7TUFHVCxVQUFVO0FBQUUsZUFBTyxLQUFLLGlCQUFpQjs7TUFFekMsYUFBYTtBQUFFLGVBQU8sS0FBSyxpQkFBaUI7O01BRTVDLGdCQUFpQjtBQUNmLGNBQU0sYUFBYTtBQUVuQixlQUFPOztNQUdULGtCQUFrQixnQkFBZ0Isa0JBQWtCO0FBQ2xELGNBQU0sa0JBQWtCO0FBRXhCLGVBQU87O01BR1QsOEJBQThCLFFBQVE7QUFDcEMsY0FBTSx3QkFBd0IsS0FBSyx5QkFBeUIsU0FDdEQsNkJBQTZCO0FBRW5DLGVBQU87O01BR1QsNkJBQTZCLFFBQVE7QUFDbkMsY0FBTSx3QkFBd0IsS0FBSyx5QkFBeUIsU0FDdEQsNEJBQTRCO0FBRWxDLGVBQU87O01BR1QseUJBQXlCLFFBQVE7QUFDL0IsWUFBSSx3QkFBd0I7QUFFNUIsWUFBSSxLQUFLLHFCQUFxQixNQUFNO0FBQ2xDLGtDQUF3QixPQUFPLFFBQVEsS0FBSzs7QUFHOUMsZUFBTzs7TUFHVCxxQkFBcUIsb0JBQW9CLElBQUk7QUFDM0MsWUFBSSxLQUFLLHFCQUFxQixNQUFNO0FBQ2xDLDRCQUFrQixLQUFLLEtBQUs7O0FBRzlCLGVBQU87O01BR1QsbUJBQW1CO0FBQ2pCLGNBQU0sZ0JBQWdCO0FBRXRCLFlBQUksZUFBZSxLQUFLO0FBRXhCLGVBQU8saUJBQWlCLE1BQU07QUFDNUIsd0JBQWMsS0FBSztBQUVuQixnQkFBTSxhQUFhLGFBQWE7QUFFaEMseUJBQWU7O0FBR2pCLGVBQU87O01BR1QsZ0JBQWdCLFVBQVU7QUFDeEIsY0FBTSxnQkFBZ0IsS0FBSztBQUUzQixlQUFPLGNBQWMsSUFBSTs7TUFHM0IsaUJBQWlCLFVBQVU7QUFDekIsWUFBSSxTQUFTO0FBRWIsWUFBSSxRQUFRLEdBQ1IsZUFBZSxLQUFLO0FBRXhCLGVBQU8saUJBQWlCLE1BQU07QUFDNUIsbUJBQVMsQ0FBQyxDQUFDLFNBQVMsY0FBYztBQUVsQyxjQUFJLFFBQVE7QUFDVjs7QUFHRixnQkFBTSxhQUFhLGFBQWE7QUFFaEMseUJBQWU7QUFFZjs7QUFHRixlQUFPOztNQUdULGlCQUFpQixVQUFVO0FBQ3pCLFlBQUksUUFBUSxHQUNSLGVBQWUsS0FBSztBQUV4QixlQUFPLGlCQUFpQixNQUFNO0FBQzVCLGdCQUFNLFNBQVMsU0FBUyxjQUFjO0FBRXRDLGNBQUksUUFBUTtBQUNWLG1CQUFPOztBQUdULGdCQUFNLGFBQWEsYUFBYTtBQUVoQyx5QkFBZTtBQUVmOztBQUdGLHVCQUFlO0FBRWYsZUFBTzs7TUFHVCxrQkFBa0IsVUFBVTtBQUMxQixZQUFJLFNBQVM7QUFFYixZQUFJLFFBQVEsR0FDUixlQUFlLEtBQUs7QUFFeEIsZUFBTyxpQkFBaUIsTUFBTTtBQUM1QixtQkFBUyxDQUFDLENBQUMsU0FBUyxjQUFjO0FBRWxDLGNBQUksQ0FBQyxRQUFRO0FBQ1g7O0FBR0YsZ0JBQU0sYUFBYSxhQUFhO0FBRWhDLHlCQUFlO0FBRWY7O0FBR0YsZUFBTzs7TUFHVCxtQkFBbUIsVUFBVTtBQUMzQixjQUFNLGdCQUFnQixLQUFLO0FBRTNCLGVBQU8sY0FBYyxPQUFPOztNQUc5QixtQkFBbUIsVUFBVSxjQUFjO0FBQ3pDLGNBQU0sZ0JBQWdCLEtBQUs7QUFFM0IsZUFBTyxjQUFjLE9BQU8sVUFBVTs7TUFHeEMsb0JBQW9CLFVBQVU7QUFDNUIsY0FBTSxnQkFBZ0IsS0FBSztBQUUzQixzQkFBYyxRQUFROztNQUd4QixtQkFBbUIsa0JBQWtCLElBQUk7QUFDdkMsZUFBTzs7TUFHVCxtQkFBbUIsVUFBVTtBQUMzQixjQUFNLFNBQVM7QUFFZixlQUFPOztNQUdULG1CQUFtQixVQUFVO0FBQzNCLFlBQUksaUJBQWlCO0FBRXJCLGVBQU87O01BR1Qsb0JBQW9CLFVBQVU7QUFDNUIsWUFBSSxTQUFTO0FBRWIsZUFBTzs7TUFHVCxZQUFZLFFBQVE7QUFDbEIsY0FBTSxlQUFlLE1BQ2Ysd0JBQXdCLGNBQUEsUUFBc0IsMEJBQTBCLGNBQWMsU0FDdEYsWUFBWTtBQUVsQixlQUFPOztNQUdULE1BQU0sTUFBTSxRQUFRLFVBQVUsVUFBVSxPQUFPO0FBQzdDLFlBQUksVUFBVTtBQUVkLGNBQU0sbUJBQW1CLEtBQUs7QUFFOUIsWUFBSSxrQkFBa0I7QUFDcEIsZ0JBQU0sZUFBZSxNQUNmLG1CQUFtQixhQUFhO0FBRXRDLG9CQUFVLFVBQ0csS0FBSyxxQkFBcUIsbUJBQ3hCLEtBQUssaUJBQWlCLE1BQU07O0FBRzdDLGVBQU87O01BR1QsU0FBUyxvQkFBb0I7QUFDM0IsY0FBTSxRQUFRLEtBQUssYUFDYixhQUFhLE1BQ2IsbUJBQW1CLEtBQUssa0JBQ3hCLGVBQWUsSUFBSSxNQUFNLFlBQVksa0JBQUEsR0FBcUI7QUFFaEUsZUFBTzs7TUFHVCxVQUFVO0FBQ1IsYUFBSyxhQUFhO0FBQ2xCLGFBQUssbUJBQW1COzthQUduQixZQUFZLFVBQVUsb0JBQW9CO0FBQy9DLFlBQUksVUFBVSxRQUFXO0FBQ3ZCLGtCQUFROztBQUdWLGNBQU0sYUFBYSxNQUNiLG1CQUFtQixNQUNuQixlQUFlLElBQUksTUFBTSxZQUFZLGtCQUFBLEdBQXFCO0FBRWhFLGVBQU87O2FBR0YscUJBQXFCLE9BQU8scUJBQXFCLG9CQUFvQjtBQUMxRSxZQUFJLHFCQUFxQixRQUFXO0FBQ2xDLDZCQUFtQjtBQUVuQixrQkFBUTs7QUFHVixjQUFNLGFBQWEsTUFDYixlQUFlLElBQUksTUFBTSxZQUFZLGtCQUFBLEdBQXFCO0FBRWhFLGVBQU87Ozs7OztBQ3hTWDs7Ozs7Ozs7Ozs7O0FBTUEsUUFBTSxDQUFFLFdBQVksYUFBQTtBQUVwQiw2Q0FBbUMsZ0JBQUEsUUFBdUI7YUFDakQsY0FBYztBQUNuQixjQUFNLFNBQVMsU0FDVCxlQUFlLE9BQU8sUUFDdEIsK0JBQStCLGNBQy9CLDBCQUEwQixnQkFBQSxRQUF3QixVQUFVLCtCQUM1RCx5QkFBeUIsd0JBQXdCLDZCQUNqRCx3QkFBd0IsZ0JBQUEsUUFBd0Isb0NBQW9DLHNCQUFzQixRQUFRO0FBRXhILDhCQUFzQixZQUFZO0FBRWxDLGNBQU0sdUJBQXVCO0FBRTdCLGVBQU87OztBQUlYLFdBQU8sVUFBVTs7OztBQ3pCakI7Ozs7O21DQVNBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFdBQVksYUFBQTtBQUVMLG9DQUEwQixVQUFBLFFBQVk7TUFDbkQsVUFBVTtBQUNSLGNBQU0sT0FBTztBQUViLGVBQU87O01BR1QsYUFBYTtBQUNYLGNBQU0sVUFBVTtBQUVoQixlQUFPOztNQUdULGdCQUFnQjtBQUNkLGNBQU0sY0FBYztBQUVwQixlQUFPOztNQUdULFlBQVksUUFBUTtBQUNsQixjQUFNLHVCQUF1QixhQUFBLFFBQXFCLGVBQzVDLFlBQVk7QUFFbEIsZUFBTzs7TUFHVCxNQUFNLE1BQU0sT0FBTztBQUNqQixZQUFJLFVBQVU7QUFFZCxjQUFNLG1CQUFtQixLQUFLO0FBRTlCLFlBQUksa0JBQWtCO0FBQ3BCLGdCQUFNLGVBQWUsTUFDZiwwQkFBMEIsYUFBYTtBQUU3QyxjQUFJLHlCQUF5QjtBQUMzQixzQkFBVTs7O0FBSWQsZUFBTzs7YUFHRixjQUFjO0FBQUUsZUFBTyxVQUFBLFFBQWEsWUFBWTs7Ozs7O0FDcER6RDs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsV0FBWSxhQUFBO0FBRUwsb0NBQTBCLFVBQUEsUUFBWTtNQUNuRCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLGNBQU0sYUFBYSxNQUFNLGlCQUNuQixpQkFBaUIsU0FBQSxRQUFlO0FBRXRDLGlCQUFVLG1CQUFtQjtBQUU3QixZQUFJLFFBQVE7QUFDVixnQkFBTSxLQUFLO0FBRVgsY0FBSSxRQUFRO0FBQ1YsZ0JBQUksY0FBYyxNQUFNO0FBQ3RCLHVCQUFTOzs7O0FBS2YsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxVQUFVOztBQUdsQixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFNBQVM7QUFFZixlQUFPOzthQUdGLGNBQWM7QUFDbkIsY0FBTSxjQUFjLElBQUk7QUFFeEIsZUFBTzs7Ozs7O0FDNUNYOzs7OzttQ0FLQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTix1Q0FBNkIsYUFBQSxRQUFlO01BQ3pELGFBQWEsV0FBVztBQUN0QixjQUFNLGNBQWMsU0FBQSxRQUFZO0FBRWhDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLGdCQUFnQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDWmxOOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sd0NBQThCLGFBQUEsUUFBZTtNQUMxRCxjQUFjLE1BQU07QUFDbEIsY0FBTSxXQUFXLFdBQUEsZ0JBQ1gsYUFBYSxLQUFLLGlCQUNsQixlQUFlLElBQUEsTUFBQSxnQ0FBK0IsWUFBWSxXQUMxRCxRQUFRLGFBQWEsSUFBSSxDQUFDLGdCQUFBO0FBQ3hCLGdCQUFNLE9BQU8sWUFBWSxhQUFhO0FBRXRDLGlCQUFPOztBQUdmLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLGlCQUFpQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDckJuTjs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFlBQWEsYUFBQTtBQUVOLHFDQUEyQixhQUFBLFFBQWU7TUFDdkQsWUFBWSxNQUFNLFlBQVksVUFBVTtBQUN0QyxjQUFNLE1BQU07QUFFWixhQUFLLFdBQVc7O01BR2xCLGNBQWM7QUFDWixlQUFPLEtBQUs7O01BR2QsaUJBQWlCO0FBQ2YsY0FBTSxlQUFlO0FBRXJCLGVBQU87O01BR1QsU0FBUyxPQUFPO0FBQ2QsY0FBTSxVQUFVLE1BQU0sY0FDaEIsT0FBTyxRQUFRLEtBQUssYUFBYTtBQUV2QyxlQUFPOztNQUdULE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosY0FBTSxPQUFPLEtBQUssU0FBUztBQUUzQixpQkFBVSxTQUFTLE9BQ1IsS0FBSyxNQUFNLE9BQU8sT0FBTyxVQUFVLGFBQ2pDO0FBRWIsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxhQUFhLEtBQUssZUFDbEIsbUJBQW1CLGFBQ0MsV0FDRSxXQUFBLGNBQ3RCLFNBQVMsR0FBRyxLQUFLLFdBQVc7QUFFbEMsZUFBTzs7YUFHRixhQUFhLFVBQVU7QUFDNUIsY0FBTSxPQUFPLFdBQUEsa0JBQ1AsYUFBYSxPQUNiLGVBQWUsSUFBSSxhQUFhLE1BQU0sWUFBWTtBQUV4RCxlQUFPOzthQUdGLHlCQUF5QixZQUFZLFVBQVU7QUFDcEQsY0FBTSxPQUFPLFdBQUEsa0JBQ1AsZUFBZSxJQUFJLGFBQWEsTUFBTSxZQUFZO0FBRXhELGVBQU87Ozs7OztBQ3JFWDs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsaUJBQVUsV0FBQTtBQUVILHdDQUE4QixhQUFBLFFBQWU7TUFDMUQsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sYUFBYSxLQUFLLGlCQUNsQixpQkFBaUIsT0FBTSxhQUN2QixlQUFlLGdCQUNmLHNCQUFzQixhQUFhLGNBQ25DLFdBQVcscUJBQ1gsZUFBZSxVQUFBLFFBQWEseUJBQXlCLFdBQVc7QUFFdEUsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsaUJBQWlCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNyQm5OOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxZQUFhLGFBQUE7QUFFTixxQ0FBMkIsVUFBQSxRQUFZO01BQ3BELE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosWUFBSSxlQUFlO0FBRW5CLGNBQU0sYUFBYSxNQUFNLGlCQUNuQix1QkFBdUIsTUFBTSwyQkFDbEMsbUJBQW1CO0FBRXBCLFlBQUkscUJBQXFCLE1BQU07QUFDN0IseUJBQWUsV0FBQSxRQUFhLHFCQUFxQjs7QUFHbkQsaUJBQVUsaUJBQWlCO0FBRTNCLFlBQUksUUFBUTtBQUNWLGdCQUFNLEtBQUs7QUFFWCxjQUFJLFFBQVE7QUFDVixnQkFBSSxjQUFjLE1BQU07QUFDdEIsdUJBQVM7Ozs7QUFLZixZQUFJLENBQUMsUUFBUTtBQUNYLGdCQUFNLFVBQVU7O0FBR2xCLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0sU0FBUztBQUVmLGVBQU87O2FBR0YsY0FBYztBQUNuQixjQUFNLGVBQWUsSUFBSTtBQUV6QixlQUFPOzs7Ozs7QUNuRFg7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHdDQUE4QixhQUFBLFFBQWU7TUFDMUQsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sZUFBZSxVQUFBLFFBQWE7QUFFbEMsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsaUJBQWlCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNabk47Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsYUFBYyxhQUFBO0FBRVAsK0NBQXFDLGdCQUFBLFFBQXVCO2FBQ2xFLGNBQWM7QUFDbkIsY0FBTSxTQUFTLFdBQ1QsZUFBZSxPQUFPLFFBQ3RCLCtCQUErQixjQUMvQiwwQkFBMEIsZ0JBQUEsUUFBd0IsVUFBVSwrQkFDNUQseUJBQXlCLHdCQUF3Qiw2QkFDakQsd0JBQXdCLGdCQUFBLFFBQXdCLG9DQUFvQyx3QkFBd0IsUUFBUTtBQUUxSCw4QkFBc0IsWUFBWTtBQUVsQyxjQUFNLHlCQUF5QjtBQUUvQixlQUFPOzs7Ozs7QUNyQlg7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTixzQ0FBNEIsVUFBQSxRQUFZO01BQ3JELFdBQVcsV0FBVyxPQUFPO0FBQzNCLGNBQU0sVUFBVSxXQUNFLE1BQU0sZUFDSixXQUFBO0FBRXBCLGVBQU87O01BR1QsWUFBWSxRQUFRO0FBQ2xCLGNBQU0seUJBQXlCLGVBQUEsUUFBdUIsZUFDaEQsWUFBWTtBQUVsQixlQUFPOzthQUdGLHFCQUFxQixrQkFBa0I7QUFBRSxlQUFPLFVBQUEsUUFBYSxxQkFBcUIsZUFBZTs7Ozs7O0FDdkIxRzs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsYUFBYyxhQUFBO0FBRVAsc0NBQTRCLFVBQUEsUUFBWTtNQUNyRCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLFlBQUksZ0JBQWdCO0FBRXBCLGNBQU0sYUFBYSxNQUFNLGlCQUNuQix1QkFBdUIsTUFBTSwyQkFDN0IsbUJBQW1CO0FBRXpCLFlBQUkscUJBQXFCLE1BQU07QUFDN0IsZ0JBQU0saUNBQWlDLGlCQUFpQjtBQUV4RCxjQUFJLGdDQUFnQztBQUNsQyw0QkFBZ0IsV0FBQSxRQUFjLHFCQUFxQjs7O0FBSXZELGlCQUFVLGtCQUFrQjtBQUU1QixZQUFJLFFBQVE7QUFDVixnQkFBTSxLQUFLO0FBRVgsY0FBSSxRQUFRO0FBQ1YsZ0JBQUksY0FBYyxNQUFNO0FBQ3RCLHVCQUFTOzs7O0FBS2YsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxVQUFVOztBQUdsQixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFNBQVM7QUFFZixlQUFPOzthQUdGLGNBQWM7QUFDbkIsY0FBTSxnQkFBZ0IsSUFBSTtBQUUxQixlQUFPOzs7Ozs7QUN2RFg7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHlDQUErQixhQUFBLFFBQWU7TUFDM0QsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sZ0JBQWdCLFdBQUEsUUFBYztBQUVwQyxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxhQUFBLFFBQWdCLDJDQUEyQyxrQkFBa0IsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ1pwTjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7O0FBRnJCLFFBQU0sQ0FBRSxtQkFBb0IsV0FBQTtBQUViLDJCQUFNO01BQ25CLFlBQVksTUFBTSxZQUFZO0FBQzVCLGFBQUssT0FBTztBQUNaLGFBQUssYUFBYTs7TUFHcEIsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsV0FBVztBQUNULFlBQUk7QUFFSixjQUFNLGFBQWEsS0FBSyxLQUFLO0FBRTdCLGlCQUFTO0FBRVQsWUFBSSxLQUFLLGVBQWUsTUFBTTtBQUM1QixnQkFBTSxhQUFjLEtBQUssZUFBZSxXQUNuQixrQkFDRSxLQUFLO0FBRTVCLG1CQUFTLEdBQUcsV0FBVzs7QUFHekIsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsY0FBTSxhQUFhLE1BQ2IsYUFBYSxJQUFJLFdBQVcsTUFBTTtBQUV4QyxlQUFPOzthQUdGLHNCQUFzQixNQUFNLFlBQVk7QUFDN0MsY0FBTSxhQUFhLElBQUksV0FBVyxNQUFNO0FBRXhDLGVBQU87Ozs7OztBQ2hEWDs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFBTiwwQ0FBZ0MsYUFBQSxRQUFlO01BQzVELG1CQUFtQixXQUFXO0FBQzVCLFlBQUk7QUFFSixjQUFNLGFBQWEsS0FBSztBQUV4QixtQkFBVyxXQUFBO0FBRVgsY0FBTSxjQUFjLElBQUEsTUFBQSwrQkFBOEIsWUFBWTtBQUU5RCxtQkFBVyxXQUFBO0FBRVgsY0FBTSxvQkFBb0IsSUFBQSxNQUFBLCtCQUE4QixZQUFZO0FBRXBFLG9CQUFZO0FBRVosY0FBTSxPQUFPLFlBQVksYUFBYSxZQUNoQyxhQUFjLHNCQUFzQixPQUNwQixPQUNFLGtCQUFrQixpQkFDcEMsYUFBYSxZQUFBLFFBQVcsc0JBQXNCLE1BQU07QUFFMUQsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsbUJBQW1CLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNqQ3JOOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFVBQVcsV0FBQTtBQUVKLDBDQUFnQyxhQUFBLFFBQWU7TUFDNUQsZ0JBQWdCO0FBQ2QsWUFBSSxhQUFhO0FBRWpCLGNBQU0sZUFBZSxLQUFLO0FBRTFCLFlBQUksaUJBQWlCLEdBQUc7QUFDdEIsZ0JBQU0sYUFBYSxLQUFLLGlCQUNsQixrQkFBa0IsT0FBTyxhQUN6QixlQUFlLGlCQUNmLFVBQVUsYUFBYTtBQUU3Qix1QkFBYSxPQUFPOztBQUd0QixlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxhQUFBLFFBQWdCLDJDQUEyQyxtQkFBbUIsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQzFCck47Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4sMENBQWdDLGFBQUEsUUFBZTthQUNyRCwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsbUJBQW1CLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNMck47Ozs7Ozs7Ozs7Ozs7VUFFZ0IsWUFBQTtlQUFBOztVQWFBLGFBQUE7ZUFBQTs7O0FBYlQsdUJBQW1CLE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBUztBQUMvRCxVQUFJO0FBRUosWUFBTSxRQUFRLEdBQ1IsUUFBUTtRQUNOOztBQUdSLGVBQVMsaUJBQWlCLE9BQU8sT0FBTyxPQUFPLE9BQU8sVUFBVTtBQUVoRSxhQUFPOztBQUdGLHdCQUFvQixPQUFPLE9BQU8sT0FBTyxVQUFVLFdBQVM7QUFDakUsVUFBSTtBQUVKLFlBQU0sUUFBUTtBQUVkLGVBQVMsaUJBQWlCLE9BQU8sT0FBTyxPQUFPLE9BQU8sVUFBVTtBQUVoRSxhQUFPOztBQUdULDhCQUEwQixPQUFPLE9BQU8sT0FBTyxPQUFPLFVBQVUsV0FBUztBQUN2RSxVQUFJO0FBRUosWUFBTSxjQUFjLE1BQU07QUFFMUIsVUFBSSxVQUFVLGFBQWE7QUFDekIsaUJBQVUsYUFBYSxPQUNaLGFBQ0U7YUFDUjtBQUNMLGNBQU0sT0FBTyxNQUFNLFFBQ2IsZ0JBQWlCLGNBQWMsT0FDYixLQUFLLGdCQUNIO0FBRTFCO0FBRUEsaUJBQVMsZ0JBQ0UsdUJBQXVCLE1BQU0sT0FBTyxPQUFPLE9BQU8sT0FBTyxVQUFVLGFBQ2pFLDBCQUEwQixNQUFNLE9BQU8sT0FBTyxPQUFPLE9BQU8sVUFBVTs7QUFHckYsYUFBTzs7QUFHVCxvQ0FBZ0MsTUFBTSxPQUFPLE9BQU8sT0FBTyxPQUFPLFVBQVUsV0FBUztBQUNuRixVQUFJO0FBRUosWUFBTSxjQUFjLE1BQU07QUFFMUIsa0JBQVksTUFBQTtBQUNWLFlBQUk7QUFFSixrQkFBUyxpQkFBaUIsT0FBTyxPQUFPLE9BQU8sT0FBTyxVQUFVO0FBRWhFLGVBQU87O0FBR1QsZUFBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFFNUMsVUFBSSxDQUFDLFFBQVE7QUFDWCxjQUFNLFFBQVE7QUFFZCxjQUFNLE9BQU87O0FBR2YsYUFBTzs7QUFHVCx1Q0FBbUMsTUFBTSxPQUFPLE9BQU8sT0FBTyxPQUFPLFVBQVUsV0FBUztBQUN0RixVQUFJO0FBRUosZUFBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFFNUMsVUFBSSxRQUFRO0FBQ1YsaUJBQVMsaUJBQWlCLE9BQU8sT0FBTyxPQUFPLE9BQU8sVUFBVTs7QUFHbEUsYUFBTzs7Ozs7QUNuRlQ7Ozs7O21DQVNBLFdBQUE7OztlQUFxQjs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxtQkFBb0IsV0FBQTtBQUViLDJCQUFNO01BQ25CLFlBQVksT0FBTyxZQUFZO0FBQzdCLGFBQUssUUFBUTtBQUNiLGFBQUssYUFBYTs7TUFHcEIsV0FBVztBQUNULGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsTUFBTSxZQUFZLE9BQU8sVUFBVSxXQUFXO0FBQzVDLFlBQUk7QUFFSixjQUFNLFFBQVEsWUFDUixhQUFhLE1BQU07QUFFekIsaUJBQVMsSUFBQSxPQUFBLFlBQVcsS0FBSyxPQUFPLE9BQU8sT0FBTyxVQUFVO0FBRXhELFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU0sVUFBVTs7QUFHbEIsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsWUFBSTtBQUVKLGNBQU0sY0FBYyxLQUFLLE1BQU0sT0FBTyxDQUFDLGNBQWEsU0FBQTtBQUM1QyxnQkFBTSxhQUFhLEtBQUs7QUFFeEIsY0FBSSxpQkFBZ0IsV0FBQSxjQUFjO0FBQ2hDLDJCQUFjO2lCQUNUO0FBQ0wsMkJBQWMsR0FBRyxnQkFBZTs7QUFHbEMsaUJBQU87V0FDTixXQUFBO0FBRVQsaUJBQVM7QUFFVCxZQUFJLEtBQUssZUFBZSxNQUFNO0FBQzVCLGdCQUFNLGFBQWMsS0FBSyxlQUFlLFdBQ25CLGtCQUNFLEtBQUs7QUFFNUIsbUJBQVMsR0FBRyxXQUFXOztBQUd6QixlQUFPOzthQUdGLFVBQVUsT0FBTyxPQUFPO0FBQzdCLFlBQUksVUFBVSxRQUFXO0FBQ3ZCLGtCQUFRO0FBRVIsa0JBQVE7O0FBR1YsY0FBTSxhQUFhLE1BQ2IsYUFBYSxJQUFJLE1BQU0sT0FBTztBQUVwQyxlQUFPOzthQUdGLHVCQUF1QixPQUFPLE9BQU8sWUFBWTtBQUN0RCxZQUFJLGVBQWUsUUFBVztBQUM1Qix1QkFBYTtBQUViLGtCQUFRO0FBRVIsa0JBQVE7O0FBR1YsY0FBTSxhQUFhLElBQUksTUFBTSxPQUFPO0FBRXBDLGVBQU87Ozs7OztBQzFGWDs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFBTiwwQ0FBZ0MsYUFBQSxRQUFlO01BQzVELHFCQUFxQjtBQUNuQixZQUFJO0FBRUosY0FBTSxhQUFhLEtBQUs7QUFFeEIsbUJBQVcsV0FBQTtBQUVYLGNBQU0sZUFBZSxJQUFBLE1BQUEsZ0NBQStCLFlBQVk7QUFFaEUsbUJBQVcsV0FBQTtBQUVYLGNBQU0sb0JBQW9CLElBQUEsTUFBQSwrQkFBOEIsWUFBWSxXQUM5RCxZQUFZLE9BQ1osUUFBUSxhQUFhLElBQUksQ0FBQyxnQkFBQTtBQUN4QixnQkFBTSxPQUFPLFlBQVksYUFBYTtBQUV0QyxpQkFBTztZQUVULGFBQWMsc0JBQXNCLE9BQ3BCLE9BQ0Usa0JBQWtCLGlCQUNwQyxhQUFhLFlBQUEsUUFBVyx1QkFBdUIsT0FBTztBQUU1RCxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxhQUFBLFFBQWdCLDJDQUEyQyxtQkFBbUIsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ25Dck47Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTiwyQ0FBaUMsYUFBQSxRQUFlO01BQzdELHNCQUFzQjtBQUNwQixjQUFNLFdBQVcsV0FBQSxzQkFDWCxhQUFhLEtBQUssaUJBQ2xCLHFCQUFxQixJQUFBLE1BQUEsZ0NBQStCLFlBQVksV0FDaEUsY0FBYyxtQkFBbUIsSUFBSSxDQUFDLHNCQUFBO0FBQ3BDLGdCQUFNLGFBQWEsa0JBQWtCO0FBRXJDLGlCQUFPOztBQUdmLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLG9CQUFvQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDckJ0Tjs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRUgsNENBQWtDLGFBQUEsUUFBZTtNQUM5RCxhQUFhLFdBQVc7QUFDdEIsY0FBTSxhQUFhLEtBQUssaUJBQ2xCLGlCQUFpQixPQUFNLGFBQ3ZCLE9BQU8sZ0JBQ1AsT0FBTyxLQUFLLGFBQWE7QUFFL0IsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMscUJBQXFCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNsQnZOOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sMENBQWdDLGFBQUEsUUFBZTtNQUM1RCxZQUFZLE1BQU0sV0FBVyxhQUFhO0FBQ3hDLGNBQU0sTUFBTTtBQUVaLGFBQUssY0FBYzs7TUFHckIsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxjQUFNLFFBQVEsS0FBSyxZQUFZLElBQUksQ0FBQyxlQUFBO0FBQ2xDLGdCQUFNLE9BQU8sV0FBVztBQUV4QixpQkFBTzs7QUFHVCxlQUFPOztNQUdULE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosY0FBTSxrQkFBa0IsTUFBTTtBQUU5QixpQkFBUyxLQUFLLFlBQVksS0FBSyxDQUFDLGVBQUE7QUFDOUIsY0FBSTtBQUVKLGdCQUFNLE9BQU8sV0FBVyxXQUNsQixhQUFhLE1BQU0saUJBQ25CLGFBQWEsV0FBVyxpQkFDeEIsY0FBYyxNQUFNO0FBRTFCLGNBQUksZUFBZSxNQUFNO0FBQ3ZCLGtCQUFNLGNBQWM7O0FBR3RCLHFCQUFZLGNBQWMsT0FDWixPQUNFLE1BQUE7QUFDRSxnQkFBSTtBQUVKLHNCQUFTO0FBRVQsbUJBQU87O0FBR3pCLG9CQUFTLElBQUEsT0FBQSxXQUFVLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFFakQsY0FBSSxDQUFDLFNBQVE7QUFDWCxrQkFBTSxRQUFRO0FBRWQsa0JBQU0sT0FBTztBQUViLGtCQUFNLFVBQVU7O0FBR2xCLGlCQUFPOztBQUdULFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU0sZ0JBQWdCOztBQUd4QixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLG9CQUFvQixLQUFLLFlBQVksT0FBTyxDQUFDLG9CQUFtQixlQUFBO0FBQzlELGdCQUFNLG1CQUFtQixXQUFXO0FBRXBDLGNBQUksdUJBQXNCLE1BQU07QUFDOUIsaUNBQW9CO2lCQUNmO0FBQ0wsaUNBQW9CLEdBQUcsd0JBQXVCOztBQUdoRCxpQkFBTztXQUNOLE9BQ0gsU0FBUyxLQUFLO0FBRXBCLGVBQU87O2FBR0YsZ0JBQWdCLGFBQWE7QUFDbEMsY0FBTSxPQUFPLFdBQUEsdUJBQ1AsWUFBWSxPQUNaLG9CQUFvQixJQUFJLGtCQUFrQixNQUFNLFdBQVc7QUFFakUsZUFBTzs7Ozs7O0FDakdYOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUFOLDZDQUFtQyxhQUFBLFFBQWU7TUFDL0QsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sV0FBVyxXQUFBLHVCQUNYLGFBQWEsS0FBSyxpQkFDbEIscUJBQXFCLElBQUEsTUFBQSxnQ0FBK0IsWUFBWTtBQUV0RSxvQkFBWTtBQUVaLGNBQU0sY0FBYyxtQkFBbUIsSUFBSSxDQUFDLHNCQUFBO0FBQ3BDLGdCQUFNLGFBQWEsa0JBQWtCLG1CQUFtQjtBQUV4RCxpQkFBTztZQUVULG9CQUFvQixlQUFBLFFBQWtCLGdCQUFnQixjQUN0RCxPQUFPO0FBRWIsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsc0JBQXNCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUMzQnhOOzs7OzttQ0FLQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiwwQ0FBZ0MsVUFBQSxRQUFZO01BQ3pELFlBQVksU0FBUztBQUNuQjtBQUVBLGFBQUssVUFBVTs7TUFHakIsYUFBYTtBQUNYLGVBQU8sS0FBSzs7TUFHZCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLFlBQUksZUFBZTtBQUVuQixjQUFNLGFBQWEsTUFBTSxpQkFDbkIsdUJBQXVCLE1BQU0sMkJBQ2xDLG1CQUFtQjtBQUVwQixZQUFJLHFCQUFxQixNQUFNO0FBQzdCLGdCQUFNLFVBQVUsaUJBQWlCO0FBRWpDLGNBQUksWUFBWSxLQUFLLFNBQVM7QUFDNUIsMkJBQWUsV0FBQSxRQUFhLHFCQUFxQjs7O0FBSXJELGlCQUFVLGlCQUFpQjtBQUUzQixZQUFJLFFBQVE7QUFDVixnQkFBTSxLQUFLO0FBRVgsY0FBSSxRQUFRO0FBQ1YsZ0JBQUksY0FBYyxNQUFNO0FBQ3RCLHVCQUFTOzs7O0FBS2YsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxVQUFVOztBQUdsQixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFVBQVUsS0FBSyxRQUFRLFFBQVEsTUFBTSxTQUNyQyxTQUFTLElBQUk7QUFFbkIsZUFBTzs7YUFHRixZQUFZLFNBQVM7QUFDMUIsY0FBTSxvQkFBb0IsSUFBSSxrQkFBa0I7QUFFaEQsZUFBTzs7Ozs7O0FDOURYOzs7OzttQ0FXQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsZUFBTyxVQUFXLFdBQUE7QUFFWCw2Q0FBbUMsYUFBQSxRQUFlO01BQy9ELG9CQUFvQjtNQUVwQixhQUFhLFdBQVc7QUFDdEIsY0FBTSxVQUFVLEtBQUssY0FDZixvQkFBb0IsZUFBQSxRQUFrQixZQUFZO0FBRXhELGVBQU87O01BR1QsYUFBYTtBQUNYLFlBQUk7QUFFSixjQUFNLGFBQWEsS0FBSyxpQkFDbEIsaUJBQWlCLE9BQU0sYUFDdkIsZUFBZSxnQkFDZixzQkFBc0IsYUFBYSxjQUNuQyxVQUFVLG9CQUFvQixNQUFNLEtBQUssb0JBQ3pDLGNBQWMsT0FBTztBQUUzQixrQkFBVTtBQUVWLGtCQUFVLGdCQUFnQjtBQUUxQixlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxhQUFBLFFBQWdCLDJDQUEyQyxzQkFBc0IsVUFBVSxZQUFZLFNBQVM7OztBQUd4Tiw2QkFBeUIsU0FBTztBQUM5QixnQkFBVSxRQUNHLFFBQVEsU0FBUyxXQUFBLG1CQUNqQixRQUFRLFFBQVEsV0FBQTtBQUU3QixhQUFPOzs7OztBQzlDVDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGlCQUFVLFdBQUE7QUFFSCwrQ0FBcUMsYUFBQSxRQUFlO01BQ2pFLGFBQWEsV0FBVztBQUN0QixjQUFNLGFBQWEsS0FBSztBQUV4QixZQUFJLENBQUMsV0FBVztBQUNkLGdCQUFNLFdBQVcsV0FBQSwrQkFDWCwyQkFBMkIsSUFBQSxNQUFBLCtCQUE4QixZQUFZO0FBRTNFLHNCQUFhLDZCQUE2Qjs7QUFHNUMsY0FBTSxpQkFBaUIsT0FBTSxhQUN2QixPQUFPLGdCQUNQLE9BQU8sS0FBSyxhQUFhO0FBRS9CLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLHdCQUF3QixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDN0IxTjs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDRDQUFrQyxhQUFBLFFBQWU7TUFDOUQsWUFBWSxNQUFNLFdBQVcsT0FBTztBQUNsQyxjQUFNLE1BQU07QUFFWixhQUFLLFFBQVE7O01BR2YsV0FBVztBQUNULGVBQU8sS0FBSzs7TUFHZCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLGNBQU0sYUFBYSxNQUFNLGlCQUNuQixjQUFjLE1BQU07QUFFMUIsbUJBQVksY0FBYyxPQUNaLE9BQ0UsTUFBQTtBQUNFLGNBQUk7QUFFSixvQkFBUztBQUVULGlCQUFPOztBQUd6QixpQkFBUyxJQUFBLE9BQUEsWUFBVyxLQUFLLE9BQU8sT0FBTyxPQUFPLFVBQVU7QUFFeEQsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxRQUFRO0FBRWQsZ0JBQU0sT0FBTztBQUViLGdCQUFNLFVBQVU7O0FBR2xCLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0sY0FBYyxLQUFLLE1BQU0sT0FBTyxDQUFDLGNBQWEsU0FBQTtBQUM1QyxnQkFBTSxhQUFhLEtBQUs7QUFFeEIsY0FBSSxpQkFBZ0IsTUFBTTtBQUN4QiwyQkFBYztpQkFDVDtBQUNMLDJCQUFjLEdBQUcsZ0JBQWU7O0FBR2xDLGlCQUFPO1dBQ04sT0FDSCxTQUFTLEtBQUs7QUFFcEIsZUFBTzs7YUFHRixVQUFVLE9BQU87QUFDdEIsY0FBTSxPQUFPLFdBQUEseUJBQ1AsWUFBWSxPQUNaLHNCQUFzQixJQUFJLG9CQUFvQixNQUFNLFdBQVc7QUFFckUsZUFBTzs7Ozs7O0FDckVYOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUFOLCtDQUFxQyxhQUFBLFFBQWU7TUFDakUsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sV0FBVyxXQUFBLGdCQUNYLGFBQWEsS0FBSyxpQkFDbEIsZUFBZSxJQUFBLE1BQUEsZ0NBQStCLFlBQVk7QUFFaEUsb0JBQVk7QUFFWixjQUFNLFFBQVEsYUFBYSxJQUFJLENBQUMsZ0JBQUE7QUFDeEIsZ0JBQU0sUUFBTyxZQUFZLGFBQWE7QUFFdEMsaUJBQU87WUFFVCxzQkFBc0IsaUJBQUEsUUFBb0IsVUFBVSxRQUNwRCxPQUFPO0FBRWIsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsd0JBQXdCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUMzQjFOOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFVBQVcsV0FBQTtBQUVKLCtDQUFxQyxhQUFBLFFBQWU7TUFDakUsYUFBYTtBQUNYLGNBQU0sYUFBYSxLQUFLLGlCQUNsQixrQkFBa0IsT0FBTyxhQUN6QixlQUFlLGlCQUNmLHNCQUFzQixhQUFhLGNBQ25DLFVBQVU7QUFFaEIsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsd0JBQXdCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNuQjFOOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGdCQUFpQixhQUFBO0FBRVYsa0RBQXdDLGdCQUFBLFFBQXVCO2FBQ3JFLGNBQWM7QUFDbkIsY0FBTSxTQUFTLGNBQ1QsZUFBZSxPQUFPLFFBQ3RCLCtCQUErQixjQUMvQiwwQkFBMEIsZ0JBQUEsUUFBd0IsVUFBVSwrQkFDNUQseUJBQXlCLHdCQUF3Qiw2QkFDakQsd0JBQXdCLGdCQUFBLFFBQXdCLG9DQUFvQywyQkFBMkIsUUFBUTtBQUU3SCw4QkFBc0IsWUFBWTtBQUVsQyxjQUFNLDRCQUE0QjtBQUVsQyxlQUFPOzs7Ozs7QUNyQlg7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTix5Q0FBK0IsVUFBQSxRQUFZO01BQ3hELFVBQVU7QUFDUixjQUFNLE9BQU87QUFFYixlQUFPOztNQUdULGFBQWE7QUFDWCxjQUFNLFVBQVUsV0FBQTtBQUVoQixlQUFPOztNQUdULHFCQUFxQjtBQUNuQixjQUFNLG1CQUFtQjtBQUV6QixlQUFPOztNQUdULFlBQVksUUFBUTtBQUNsQixjQUFNLDRCQUE0QixrQkFBQSxRQUEwQixlQUN0RCxZQUFZO0FBRWxCLGVBQU87O01BR1QsTUFBTSxNQUFNLE9BQU87QUFDakIsWUFBSSxVQUFVO0FBRWQsY0FBTSxtQkFBbUIsS0FBSztBQUU5QixZQUFJLGtCQUFrQjtBQUNwQixnQkFBTSxlQUFlLE1BQ2YsK0JBQStCLGFBQWE7QUFFbEQsY0FBSSw4QkFBOEI7QUFDaEMsc0JBQVU7OztBQUlkLGVBQU87O2FBR0YsY0FBYztBQUFFLGVBQU8sVUFBQSxRQUFhLFlBQVk7Ozs7OztBQ2xEekQ7Ozs7O21DQVNBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGdCQUFpQixhQUFBO0FBRVYseUNBQStCLFVBQUEsUUFBWTtNQUN4RCxxQkFBcUI7QUFDbkIsY0FBTSxtQkFBbUI7QUFFekIsZUFBTzs7TUFHVCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLFlBQUksbUJBQW1CO0FBRXZCLGNBQU0sYUFBYSxNQUFNLGlCQUNuQiwyQkFBMkIsTUFBTTtBQUV2QyxZQUFJLENBQUMsMEJBQTBCO0FBQzdCLDZCQUFtQixjQUFBLFFBQWlCOztBQUd0QyxpQkFBVSxxQkFBcUI7QUFFL0IsWUFBSSxRQUFRO0FBQ1YsZ0JBQU0sS0FBSztBQUVYLGNBQUksUUFBUTtBQUNWLGdCQUFJLGNBQWMsTUFBTTtBQUN0Qix1QkFBUzs7OztBQUtmLFlBQUksQ0FBQyxRQUFRO0FBQ1gsZ0JBQU0sVUFBVTs7QUFHbEIsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxTQUFTO0FBRWYsZUFBTzs7YUFHRixjQUFjO0FBQ25CLGNBQU0sbUJBQW1CLElBQUk7QUFFN0IsZUFBTzs7Ozs7O0FDeERYOzs7OzttQ0FLQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixnREFBc0MsYUFBQSxRQUFlO01BQ2xFLGFBQWEsV0FBVztBQUN0QixjQUFNLG1CQUFtQixjQUFBLFFBQWlCO0FBRTFDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLHlCQUF5QixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDWjNOOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLGlEQUF1QyxhQUFBLFFBQWU7YUFDNUQsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLDBCQUEwQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDTDVOOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRUgsOENBQW9DLFVBQUEsUUFBWTtNQUM3RCxZQUFZLG1CQUFtQjtBQUM3QjtBQUVBLGFBQUssb0JBQW9COztNQUczQix1QkFBdUI7QUFDckIsZUFBTyxLQUFLOztNQUdkLE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosWUFBSSxlQUFlO0FBRW5CLGNBQU0sYUFBYSxNQUFNLGlCQUNuQix1QkFBdUIsTUFBTSwyQkFDbEMsbUJBQW1CO0FBRXBCLFlBQUkscUJBQXFCLE1BQU07QUFDN0IsZ0JBQU0sVUFBVSxpQkFBaUIsY0FDM0IsVUFBVSxRQUFRLE1BQU0sS0FBSztBQUVuQyxjQUFJLFlBQVksTUFBTTtBQUNwQixrQkFBTSxhQUFhLE9BQU07QUFFekIsZ0JBQUksZUFBZSxTQUFTO0FBQzFCLDZCQUFlLFdBQUEsUUFBYSxxQkFBcUI7Ozs7QUFLdkQsaUJBQVUsaUJBQWlCO0FBRTNCLFlBQUksUUFBUTtBQUNWLGdCQUFNLEtBQUs7QUFFWCxjQUFJLFFBQVE7QUFDVixnQkFBSSxjQUFjLE1BQU07QUFDdEIsdUJBQVM7Ozs7QUFLZixZQUFJLENBQUMsUUFBUTtBQUNYLGdCQUFNLFVBQVU7O0FBR2xCLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0sMEJBQTBCLEtBQUssa0JBQWtCLFlBQ25ELFNBQVM7QUFFYixlQUFPOzthQUdGLHNCQUFzQixtQkFBbUI7QUFDOUMsY0FBTSx3QkFBd0IsSUFBSSxzQkFBc0I7QUFFeEQsZUFBTzs7Ozs7O0FDdkVYOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxlQUFPLFVBQVcsV0FBQTtBQUVYLGlEQUF1QyxhQUFBLFFBQWU7TUFDbkUsb0JBQW9CO01BRXBCLGFBQWEsV0FBVztBQUN0QixjQUFNLG9CQUFvQixLQUFLLHdCQUN6Qix3QkFBd0IsbUJBQUEsUUFBc0Isc0JBQXNCO0FBRTFFLGVBQU87O01BR1QsdUJBQXVCO0FBQ3JCLGNBQU0sYUFBYSxLQUFLLGlCQUNsQixpQkFBaUIsT0FBTSxhQUN2QixlQUFlLGdCQUNmLHNCQUFzQixhQUFhLGNBQ25DLFVBQVUsb0JBQW9CLE1BQU0sS0FBSyxvQkFDekMsY0FBYyxPQUFPLFVBQ3JCLFVBQVUsYUFDVixvQkFBb0IsSUFBSSxPQUFPO0FBRXJDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLDBCQUEwQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDaEM1Tjs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxrQkFBbUIsYUFBQTtBQUVaLG9EQUEwQyxnQkFBQSxRQUF1QjthQUN2RSxjQUFjO0FBQ25CLGNBQU0sU0FBUyxnQkFDVCxlQUFlLE9BQU8sUUFDdEIsK0JBQStCLGNBQy9CLDBCQUEwQixnQkFBQSxRQUF3QixVQUFVLCtCQUM1RCx5QkFBeUIsd0JBQXdCLDZCQUNqRCx3QkFBd0IsZ0JBQUEsUUFBd0Isb0NBQW9DLDZCQUE2QixRQUFRO0FBRS9ILDhCQUFzQixZQUFZO0FBRWxDLGNBQU0sOEJBQThCO0FBRXBDLGVBQU87Ozs7OztBQ3JCWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDJDQUFpQyxVQUFBLFFBQVk7TUFDMUQsVUFBVTtBQUNSLGNBQU0sT0FBTztBQUViLGVBQU87O01BR1QsYUFBYTtBQUNYLGNBQU0sVUFBVSxXQUFBO0FBRWhCLGVBQU87O01BR1QsdUJBQXVCO0FBQ3JCLGNBQU0scUJBQXFCO0FBRTNCLGVBQU87O01BR1QsWUFBWSxRQUFRO0FBQ2xCLGNBQU0sOEJBQThCLG9CQUFBLFFBQTRCLGVBQzFELFlBQVk7QUFFbEIsZUFBTzs7TUFHVCxNQUFNLE1BQU0sT0FBTztBQUNqQixZQUFJLFVBQVU7QUFFZCxjQUFNLG1CQUFtQixLQUFLO0FBRTlCLFlBQUksa0JBQWtCO0FBQ3BCLGdCQUFNLGVBQWUsTUFDZixpQ0FBaUMsYUFBYTtBQUVwRCxjQUFJLGdDQUFnQztBQUNsQyxzQkFBVTs7O0FBSWQsZUFBTzs7YUFHRixjQUFjO0FBQUUsZUFBTyxVQUFBLFFBQWEsWUFBWTs7Ozs7O0FDbER6RDs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsa0JBQW1CLGFBQUE7QUFFWiwyQ0FBaUMsVUFBQSxRQUFZO01BQzFELHVCQUF1QjtBQUNyQixjQUFNLHFCQUFxQjtBQUUzQixlQUFPOztNQUdULE1BQU0sT0FBTyxPQUFPLFVBQVUsV0FBVztBQUN2QyxZQUFJO0FBRUosWUFBSSxxQkFBcUI7QUFFekIsY0FBTSxhQUFhLE1BQU0saUJBQ25CLG1CQUFtQixNQUFNO0FBRS9CLFlBQUksa0JBQWtCO0FBQ3BCLCtCQUFxQixnQkFBQSxRQUFtQjs7QUFHMUMsaUJBQVUsdUJBQXVCO0FBRWpDLFlBQUksUUFBUTtBQUNWLGdCQUFNLEtBQUs7QUFFWCxjQUFJLFFBQVE7QUFDVixnQkFBSSxjQUFjLE1BQU07QUFDdEIsdUJBQVM7Ozs7QUFLZixZQUFJLENBQUMsUUFBUTtBQUNYLGdCQUFNLFVBQVU7O0FBR2xCLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0sU0FBUztBQUVmLGVBQU87O2FBR0YsY0FBYztBQUNuQixjQUFNLHFCQUFxQixJQUFJO0FBRS9CLGVBQU87Ozs7OztBQ3hEWDs7Ozs7bUNBS0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sa0RBQXdDLGFBQUEsUUFBZTtNQUNwRSxhQUFhLFdBQVc7QUFDdEIsY0FBTSxxQkFBcUIsZ0JBQUEsUUFBbUI7QUFFOUMsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsMkJBQTJCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNaN047Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4sa0RBQXdDLGFBQUEsUUFBZTthQUM3RCwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsMkJBQTJCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNMN047Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4sbURBQXlDLGFBQUEsUUFBZTthQUM5RCwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsNEJBQTRCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNMOU47Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLGlEQUF1QyxVQUFBLFFBQVk7TUFDaEUsWUFBWSxzQkFBc0I7QUFDaEM7QUFFQSxhQUFLLHVCQUF1Qjs7TUFHOUIsMEJBQTBCO0FBQ3hCLGVBQU8sS0FBSzs7TUFHZCxNQUFNLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFDdkMsWUFBSTtBQUVKLFlBQUksZUFBZTtBQUVuQixjQUFNLGFBQWEsTUFBTSxpQkFDbkIsdUJBQXVCLE1BQU0sMkJBQ2xDLG1CQUFtQjtBQUVwQixZQUFJLHFCQUFxQixNQUFNO0FBQzdCLGdCQUFNLHVCQUF1QixpQkFBaUI7QUFFOUMsY0FBSSx5QkFBeUIsS0FBSyxzQkFBc0I7QUFDdEQsMkJBQWUsV0FBQSxRQUFhLHFCQUFxQjs7O0FBSXJELGlCQUFVLGlCQUFpQjtBQUUzQixZQUFJLFFBQVE7QUFDVixnQkFBTSxLQUFLO0FBRVgsY0FBSSxRQUFRO0FBQ1YsZ0JBQUksY0FBYyxNQUFNO0FBQ3RCLHVCQUFTOzs7O0FBS2YsWUFBSSxDQUFDLFFBQVE7QUFDWCxnQkFBTSxVQUFVOztBQUdsQixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFNBQVMsSUFBSSxLQUFLO0FBRXhCLGVBQU87O2FBR0YseUJBQXlCLHNCQUFzQjtBQUNwRCxjQUFNLDJCQUEyQixJQUFJLHlCQUF5QjtBQUU5RCxlQUFPOzs7Ozs7QUM3RFg7Ozs7O21DQVNBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGVBQU8sVUFBVyxXQUFBO0FBRVgsb0RBQTBDLGFBQUEsUUFBZTtNQUN0RSxvQkFBb0I7TUFFcEIsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sdUJBQXVCLEtBQUssMkJBQzVCLDJCQUEyQixzQkFBQSxRQUF5Qix5QkFBeUI7QUFFbkYsZUFBTzs7TUFHVCwwQkFBMEI7QUFDeEIsY0FBTSxhQUFhLEtBQUssaUJBQ2xCLGlCQUFpQixPQUFNLGFBQ3ZCLGVBQWUsZ0JBQ2Ysc0JBQXNCLGFBQWEsY0FDbkMsVUFBVSxvQkFBb0IsTUFBTSxLQUFLLG9CQUN6QyxjQUFjLE9BQU8sVUFDckIsdUJBQXVCO0FBRTdCLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGFBQUEsUUFBZ0IsMkNBQTJDLDZCQUE2QixVQUFVLFlBQVksU0FBUzs7O0FBRy9OLFdBQU8sVUFBVTs7OztBQ2xDakI7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7O0FBQU4scURBQTJDLGFBQUEsUUFBZTthQUNoRSwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsOEJBQThCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNMaE87Ozs7O21DQTJGQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQS9CQSxRQUFNLHFCQUFxQjtPQUN4QixXQUFBLGlCQUFpQixNQUFBO09BQ2pCLFdBQUEsaUJBQWlCLE1BQUE7T0FDakIsV0FBQSxpQkFBaUIsTUFBQTtPQUNqQixXQUFBLGtCQUFrQixPQUFBO09BQ2xCLFdBQUEsb0JBQW9CLFNBQUE7T0FDcEIsV0FBQSxxQkFBcUIsVUFBQTtPQUNyQixXQUFBLHFCQUFxQixVQUFBO09BQ3JCLFdBQUEsc0JBQXNCLFVBQUE7T0FDdEIsV0FBQSx1QkFBdUIsWUFBQTtPQUN2QixXQUFBLHVCQUF1QixZQUFBO09BQ3ZCLFdBQUEsdUJBQXVCLFlBQUE7T0FDdkIsV0FBQSx3QkFBd0IsV0FBQTtPQUN4QixXQUFBLHdCQUF3QixZQUFBO09BQ3hCLFdBQUEsd0JBQXdCLGFBQUE7T0FDeEIsV0FBQSwwQkFBMEIsY0FBQTtPQUMxQixXQUFBLDJCQUEyQixlQUFBO09BQzNCLFdBQUEsNEJBQTRCLGVBQUE7T0FDNUIsV0FBQSw2QkFBNkIsaUJBQUE7T0FDN0IsV0FBQSw4QkFBOEIsaUJBQUE7T0FDOUIsV0FBQSw4QkFBOEIsaUJBQUE7T0FDOUIsV0FBQSwrQkFBK0Isa0JBQUE7T0FDL0IsV0FBQSwrQkFBK0IsbUJBQUE7T0FDL0IsV0FBQSxnQ0FBZ0MsbUJBQUE7T0FDaEMsV0FBQSxnQ0FBZ0Msb0JBQUE7T0FDaEMsV0FBQSxrQ0FBa0Msb0JBQUE7T0FDbEMsV0FBQSxtQ0FBbUMsc0JBQUE7T0FDbkMsV0FBQSxtQ0FBbUMsd0JBQUE7T0FDbkMsV0FBQSxvQ0FBb0MseUJBQUE7O1FBR3ZDLFdBQWU7Ozs7QUMzRmY7Ozs7O21DQUVBLFdBQUE7OztlQUFxQjs7O0FBQU4sc0JBQU07TUFDbkIsWUFBWSxPQUFPLFFBQVEsU0FBUyxZQUFZLGdCQUFnQixvQkFBb0Isd0JBQXdCO0FBQzVHLGFBQUssUUFBUTtBQUNYLGFBQUssU0FBUztBQUNkLGFBQUssVUFBVTtBQUNmLGFBQUssYUFBYTtBQUNsQixhQUFLLGlCQUFpQjtBQUN0QixhQUFLLHFCQUFxQjtBQUMxQixhQUFLLHlCQUF5Qjs7TUFHaEMsV0FBVztBQUNULGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLOztNQUdkLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7O01BR2QscUJBQXFCO0FBQ25CLGVBQU8sS0FBSzs7TUFHZCw0QkFBNEI7QUFDMUIsZUFBTyxLQUFLOztNQUdkLFNBQVMsT0FBTztBQUNkLGFBQUssUUFBUTs7TUFHZixVQUFVLFFBQVE7QUFDaEIsYUFBSyxTQUFTOztNQUdoQixXQUFXLFNBQVM7QUFDbEIsYUFBSyxVQUFVOztNQUdqQixjQUFjLFlBQVk7QUFDeEIsYUFBSyxhQUFhOztNQUdwQixrQkFBa0IsZ0JBQWdCO0FBQ2hDLGFBQUssaUJBQWlCOztNQUd4QixxQkFBcUI7QUFDbkIsY0FBTSxrQkFBa0IsS0FBSztBQUU3QixlQUFPOztNQUdULGdCQUFnQjtBQUNkLGNBQU0sYUFBYSxLQUFLO0FBRXhCLGVBQU87O01BR1QsZUFBZTtBQUNiLFlBQUksWUFBWTtBQUVoQixjQUFNLGVBQWUsS0FBSyxPQUFPO0FBRWpDLFlBQUksS0FBSyxRQUFRLGNBQWM7QUFDN0Isc0JBQVksS0FBSyxPQUFPLEtBQUs7O0FBRy9CLGVBQU87O01BR1QscUJBQXFCO0FBQ25CLGNBQU0sbUJBQW1CLEtBQUssaUJBQ0gsS0FBSyxVQUFVLElBQ2Q7QUFFNUIsZUFBTzs7TUFHVCwwQkFBMEI7QUFDMUIsWUFBSSx1QkFBdUI7QUFFMUIsY0FBTSxlQUFlLEtBQUssT0FBTztBQUVqQyxlQUFPLEtBQUssUUFBUSxjQUFjO0FBQ2pDLGdCQUFNLFFBQVEsS0FBSyxPQUFPLEtBQUssVUFDN0IsbUJBQW1CLE1BQU07QUFFM0IsY0FBSSxrQkFBa0I7QUFDcEIsa0JBQU0sbUJBQW1CO0FBRTNCLG1DQUF1QjtBQUV2Qjs7O0FBSUYsZUFBTzs7TUFHUCw2QkFBNkI7QUFDM0IsWUFBSSwyQkFBMkI7QUFFL0IsY0FBTSxlQUFlLEtBQUssT0FBTztBQUVqQyxZQUFJLEtBQUssUUFBUSxjQUFjO0FBQzdCLGdCQUFNLFlBQVksS0FBSyxPQUFPLEtBQUs7QUFFbkMscUNBQTJCLFVBQVU7O0FBR3ZDLGVBQU87O01BR1YsVUFBVSxZQUFZO0FBQ3JCLGFBQUssUUFBUTs7TUFHYixnQkFBZ0IsaUJBQWlCO0FBQy9CLGFBQUssYUFBYTs7TUFHcEIsNEJBQTRCLFVBQVU7QUFDcEMsY0FBTSxrQkFBa0IsT0FBTyxPQUFPLEtBQUssb0JBQW9CLFlBQ3JDLEtBQUssbUJBQW1CLFlBQ3RCLEtBQUs7QUFFakMsZUFBTzs7YUFHRiwyRUFBMkUsUUFBUSxTQUFTLGdCQUFnQixvQkFBb0Isd0JBQXdCO0FBQzdKLGNBQU0sUUFBUSxHQUNSLGFBQWEsTUFDbEIsUUFBUSxJQUFJLE1BQU0sT0FBTyxRQUFRLFNBQVMsWUFBWSxnQkFBZ0Isb0JBQW9CO0FBRTNGLGVBQU87Ozs7OztBQ3JKWDs7Ozs7bUNBK0JBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7O0FBekJBLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRWxCLG1CQUFlLFFBQVEsT0FBTyxLQUFLLFdBQVcsaUJBQWlCLE1BQUk7QUFDakUsVUFBSSxPQUFPO0FBRVgsWUFBTSxRQUFRLElBQ1IsQ0FBRSxvQkFBb0IsMEJBQTJCLEtBQUssYUFDdEQsUUFBUSxPQUFBLFFBQU0sMkVBQTJFLFFBQVEsS0FBSyxTQUFTLGdCQUFnQixvQkFBb0IseUJBQ25KLFdBQVcsTUFDWCxZQUFZLE1BQ1osU0FBUyxLQUFLLE1BQU0sT0FBTyxPQUFPLFVBQVU7QUFFbEQsVUFBSSxRQUFRO0FBQ1YsY0FBTSxZQUFZLE9BQU07QUFFeEIsZUFBTzs7QUFHVCxhQUFPOztBQUdULFFBQU0sZUFBZTtNQUNuQjs7UUFHRixXQUFlOzs7O0FDL0JmOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxZQUFhLGFBQUE7QUFFTix1Q0FBNkIsWUFBQSxRQUFVO2FBQzdDLGNBQWM7QUFDbkIsY0FBTSx1QkFBdUIsVUFDdkIsK0JBQStCLHNCQUFBLFFBQXlCLHlCQUF5Qix1QkFDakYsUUFBUTtVQUNOO1dBRUYsYUFBYSxNQUNiLGlCQUFpQixJQUFJLGVBQWUsT0FBTztBQUVqRCxlQUFPOzs7Ozs7QUNuQlg7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTixvQ0FBMEIsTUFBQSxRQUFJO2FBQ3BDLGNBQWM7QUFDbkIsY0FBTSxpQkFBaUIsTUFBQSxRQUFlLGVBQ2hDLE9BQU8sV0FBQSxnQkFDUCxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsV0FBVyxJQUFJLFlBQVksTUFBTSxTQUFTO0FBRWhELGVBQU87Ozs7OztBQ2pCWDs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFBTixtREFBeUMsWUFBQSxRQUFVO2FBQ3pELGNBQWM7QUFDbkIsWUFBSTtBQUVKLG1CQUFXLFdBQUE7QUFFWCxjQUFNLHlCQUF5QixVQUFBLFFBQWEsYUFBYTtBQUV6RCxtQkFBVyxXQUFBO0FBRVgsY0FBTSwyQkFBMkIsVUFBQSxRQUFhLGFBQWEsV0FDckQsd0NBQXdDLGlCQUFBLFFBQW9CLFNBQVMseUJBQ3JFLFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLDZCQUE2QixJQUFJLDJCQUEyQixPQUFPO0FBRXpFLGVBQU87Ozs7OztBQzNCWDs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFBTixzREFBNEMsWUFBQSxRQUFVO2FBQzVELGNBQWM7QUFDbkIsWUFBSTtBQUVKLG1CQUFXLFdBQUE7QUFFWCxjQUFNLHlCQUF5QixVQUFBLFFBQWEsYUFBYTtBQUV6RCxtQkFBVyxXQUFBO0FBRVgsY0FBTSw4QkFBOEIsVUFBQSxRQUFhLGFBQWEsV0FDeEQsd0NBQXdDLGlCQUFBLFFBQW9CLFNBQVMseUJBQ3JFLFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLGdDQUFnQyxJQUFJLDhCQUE4QixPQUFPO0FBRS9FLGVBQU87Ozs7OztBQzNCWDs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFBTixvQ0FBMEIsTUFBQSxRQUFJO2FBQ3BDLGNBQWM7QUFDbkIsY0FBTSxPQUFPLFdBQUEsZ0JBQ1AsNkJBQTZCLFVBQUEsUUFBMkIsZUFDeEQsZ0NBQWdDLGFBQUEsUUFBOEIsZUFDOUQsVUFBVSxNQUNWLGNBQWM7VUFDWjtVQUNBO1dBRUYsV0FBVyxJQUFJLFlBQVksTUFBTSxTQUFTO0FBRWhELGVBQU87Ozs7OztBQ3BCWDs7Ozs7bUNBYUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsV0FBVyxjQUFlLGFBQUE7QUFFbkIsdUNBQTZCLFlBQUEsUUFBVTthQUM3QyxjQUFjO0FBQ25CLFlBQUk7QUFFSixjQUFNLGdDQUFnQyxXQUNoQyxpQ0FBaUM7QUFFdkMsbUJBQVcsV0FBQTtBQUVYLGNBQU0sOEJBQThCLFVBQUEsUUFBYSxhQUFhO0FBRTlELG1CQUFXLFdBQUE7QUFFWCxjQUFNLG1CQUFtQixVQUFBLFFBQWEsYUFBYSxXQUM3QyxrQ0FBa0MsY0FBQSxRQUFpQixTQUFTLDhCQUM1RCw2QkFBNkIsZUFBQSxRQUFrQixZQUFZO0FBRWpFLG1CQUFXLFdBQUE7QUFFWCxjQUFNLDBCQUEwQixVQUFBLFFBQWEsYUFBYSxXQUNwRCw4QkFBOEIsZUFBQSxRQUFrQixZQUFZLGlDQUM1RCxRQUFRO1VBQ047VUFDQTtVQUNBO1VBQ0E7VUFDQTtXQUVGLGFBQWEsTUFDYixpQkFBaUIsSUFBSSxlQUFlLE9BQU87QUFFakQsZUFBTzs7Ozs7O0FDNUNYOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sb0NBQTBCLE1BQUEsUUFBSTthQUNwQyxjQUFjO0FBQ25CLGNBQU0saUJBQWlCLE9BQUEsUUFBZSxlQUNoQyxPQUFPLFdBQUEsZ0JBQ1AsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLFdBQVcsSUFBSSxZQUFZLE1BQU0sU0FBUztBQUVoRCxlQUFPOzs7Ozs7QUNqQlg7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHdDQUE4QixZQUFBLFFBQVU7YUFDOUMsY0FBYztBQUNuQixjQUFNLGVBQWUsVUFBQSxRQUFhLGVBQzVCLFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYixrQkFBa0IsSUFBSSxnQkFBZ0IsT0FBTztBQUVuRCxlQUFPOzs7Ozs7QUNkWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFVBQVcsYUFBQTtBQUVKLHFDQUEyQixNQUFBLFFBQUk7YUFDckMsY0FBYztBQUNuQixjQUFNLGtCQUFrQixPQUFBLFFBQWdCLGVBQ2xDLE9BQU8sV0FBQSxpQkFDUCxVQUFVLFFBQ1YsY0FBYztVQUNaO1dBRUYsWUFBWSxJQUFJLGFBQWEsTUFBTSxTQUFTO0FBRWxELGVBQU87Ozs7OztBQ3JCWDs7Ozs7bUNBS0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sZ0RBQXNDLFlBQUEsUUFBVTthQUN0RCxZQUFZLFNBQVM7QUFDMUIsY0FBTSxvQkFBb0IsZUFBQSxRQUFrQixZQUFZLFVBQ2xELFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYiwwQkFBMEIsSUFBSSx3QkFBd0IsT0FBTztBQUVuRSxlQUFPOzs7Ozs7QUNkWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFdBQVksYUFBQTtBQUVMLHVDQUE2QixNQUFBLFFBQUk7YUFDdkMsY0FBYztBQUNuQixjQUFNLFVBQVUsU0FDVixpQ0FBaUMsZUFBQSxRQUF3QixZQUFZLFVBQ3JFLE9BQU8sV0FBQSxtQkFDUCxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsY0FBYyxJQUFJLGVBQWUsTUFBTSxTQUFTO0FBRXRELGVBQU87Ozs7OztBQ3RCWDs7Ozs7bUNBVUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7OztBQUFOLDJDQUFpQyxZQUFBLFFBQVU7YUFDakQsY0FBYztBQUNuQixZQUFJO0FBRUosbUJBQVcsV0FBQTtBQUVYLGNBQU0sbUJBQW1CLFVBQUEsUUFBYSxhQUFhO0FBRW5ELG1CQUFXLFdBQUE7QUFFWCxjQUFNLG9CQUFvQixVQUFBLFFBQWEsYUFBYSxXQUM5Qyx5QkFBeUIsWUFBQSxRQUFXLFNBQVMsbUJBQzdDLDBCQUEwQixZQUFBLFFBQVcsU0FBUyxvQkFDOUMsY0FBYztVQUNaO1VBQ0E7V0FFRixnREFBZ0QsZUFBQSxRQUFrQixnQkFBZ0IsY0FDbEYsOERBQThELGdCQUFBLFFBQW1CLFNBQVMsZ0RBQzFGLFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYixxQkFBcUIsSUFBSSxtQkFBbUIsT0FBTztBQUV6RCxlQUFPOzs7Ozs7QUNuQ1g7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTix3Q0FBOEIsTUFBQSxRQUFJO2FBQ3hDLGNBQWM7QUFDbkIsY0FBTSxxQkFBcUIsVUFBQSxRQUFtQixlQUN4QyxPQUFPLFdBQUEsb0JBQ1AsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLGVBQWUsSUFBSSxnQkFBZ0IsTUFBTSxTQUFTO0FBRXhELGVBQU87Ozs7OztBQ2pCWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLHdDQUE4QixNQUFBLFFBQUk7YUFDeEMsY0FBYztBQUNuQixjQUFNLGlCQUFpQixNQUFBLFFBQWUsZUFDaEMsT0FBTyxXQUFBLHFCQUNQLFVBQVUsTUFDVixjQUFjO1VBQ1o7V0FFRixlQUFlLElBQUksZ0JBQWdCLE1BQU0sU0FBUztBQUV4RCxlQUFPOzs7Ozs7QUNqQlg7Ozs7O21DQVdBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxZQUFhLGFBQUE7QUFFTix3Q0FBOEIsTUFBQSxRQUFJO2FBQ3hDLGNBQWM7QUFDbkIsY0FBTSxVQUFVLFVBQ1Ysa0NBQWtDLGVBQUEsUUFBd0IsWUFBWSxVQUN0RSxPQUFPLFdBQUEsb0JBQ1AsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLGVBQWUsSUFBSSxnQkFBZ0IsTUFBTSxTQUFTO0FBRXhELGVBQU87Ozs7OztBQ3RCWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGFBQWMsYUFBQTtBQUVQLHlDQUErQixNQUFBLFFBQUk7YUFDekMsY0FBYztBQUNuQixjQUFNLFVBQVUsV0FDVixtQ0FBbUMsZUFBQSxRQUF3QixZQUFZLFVBQ3ZFLE9BQU8sV0FBQSx1QkFDUCxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsZ0JBQWdCLElBQUksaUJBQWlCLE1BQU0sU0FBUztBQUUxRCxlQUFPOzs7Ozs7QUN0Qlg7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBQU4sNkNBQW1DLFlBQUEsUUFBVTthQUNuRCxjQUFjO0FBQ25CLFlBQUk7QUFFSixtQkFBVyxXQUFBO0FBRVgsY0FBTSxtQkFBbUIsVUFBQSxRQUFhLGFBQWE7QUFFbkQsbUJBQVcsV0FBQTtBQUVYLGNBQU0seUJBQXlCLFVBQUEsUUFBYSxhQUFhLFdBQ25ELHFDQUFxQyxjQUFBLFFBQWlCLFNBQVMseUJBQy9ELFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLHVCQUF1QixJQUFJLHFCQUFxQixPQUFPO0FBRTdELGVBQU87Ozs7OztBQzNCWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDBDQUFnQyxNQUFBLFFBQUk7YUFDMUMsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSx1QkFDUCx1QkFBdUIsWUFBQSxRQUFxQixlQUM1QyxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsaUJBQWlCLElBQUksa0JBQWtCLE1BQU0sU0FBUztBQUU1RCxlQUFPOzs7Ozs7QUNqQlg7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLDJDQUFpQyxZQUFBLFFBQVU7YUFDakQsYUFBYSxVQUFVO0FBQzVCLGNBQU0sdUJBQXVCLFVBQUEsUUFBYSxhQUFhLFdBQ2pELFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYixxQkFBcUIsSUFBSSxtQkFBbUIsT0FBTztBQUV6RCxlQUFPOzs7Ozs7QUNkWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDBDQUFnQyxNQUFBLFFBQUk7YUFDMUMsY0FBYztBQUNuQixZQUFJO0FBQ0osY0FBTSxPQUFPLFdBQUE7QUFFYixtQkFBVyxXQUFBO0FBRVgsY0FBTSx1Q0FBdUMsVUFBQSxRQUFtQixhQUFhO0FBRTdFLG1CQUFXLFdBQUE7QUFFWCxjQUFNLHdDQUF3QyxVQUFBLFFBQW1CLGFBQWE7QUFFOUUsbUJBQVcsV0FBQTtBQUVYLGNBQU0seUNBQXlDLFVBQUEsUUFBbUIsYUFBYSxXQUN6RSxVQUFVLE1BQ1YsY0FBYztVQUNaO1VBQ0E7VUFDQTtXQUVGLGlCQUFpQixJQUFJLGtCQUFrQixNQUFNLFNBQVM7QUFFNUQsZUFBTzs7Ozs7O0FDL0JYOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7QUFBTiw2Q0FBbUMsWUFBQSxRQUFVO2FBQ25ELGNBQWM7QUFDbkIsWUFBSTtBQUVKLG1CQUFXLFdBQUE7QUFFWCxjQUFNLG1CQUFtQixVQUFBLFFBQWEsYUFBYTtBQUVuRCxtQkFBVyxXQUFBO0FBRVgsY0FBTSx5QkFBeUIsVUFBQSxRQUFhLGFBQWEsV0FDbkQsNkJBQTZCLGdCQUFBLFFBQW1CLFNBQVMsbUJBQ3pELHFDQUFxQyxjQUFBLFFBQWlCLFNBQVMseUJBQy9ELFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLHVCQUF1QixJQUFJLHFCQUFxQixPQUFPO0FBRTdELGVBQU87Ozs7OztBQzdCWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDBDQUFnQyxNQUFBLFFBQUk7YUFDMUMsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSxzQkFDUCx1QkFBdUIsWUFBQSxRQUFxQixlQUM1QyxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsaUJBQWlCLElBQUksa0JBQWtCLE1BQU0sU0FBUztBQUU1RCxlQUFPOzs7Ozs7QUNqQlg7Ozs7O21DQVlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7OztBQUhyQixRQUFNLENBQUUsY0FBZSxhQUFBO0FBQXZCLFFBQ00sQ0FBRSxhQUFhLGdCQUFpQixhQUFBO0FBRXZCLDZDQUFtQyxZQUFBLFFBQVU7YUFDbkQsY0FBYztBQUNuQixjQUFNLHVCQUF1QixZQUN2QixrQ0FBa0MsYUFDbEMsbUNBQW1DLGNBQ25DLCtCQUErQixlQUFBLFFBQWtCLFlBQVksa0NBQzdELGdDQUFnQyxlQUFBLFFBQWtCLFlBQVksbUNBQzlELGlDQUFpQyxzQkFBQSxRQUF5Qix5QkFBeUIsdUJBQ25GLDZDQUE2QyxjQUFBLFFBQWlCLFNBQVMsaUNBQ3ZFLFFBQVE7VUFDTjtVQUNBO1VBQ0E7V0FFRixhQUFhLE1BQ2IsdUJBQXVCLElBQUkscUJBQXFCLE9BQU87QUFFN0QsZUFBTzs7Ozs7O0FDN0JYOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sMENBQWdDLE1BQUEsUUFBSTthQUMxQyxjQUFjO0FBQ25CLGNBQU0sT0FBTyxXQUFBLHNCQUNQLHVCQUF1QixZQUFBLFFBQXFCLGVBQzVDLFVBQVUsTUFDVixjQUFjO1VBQ1o7V0FFRixpQkFBaUIsSUFBSSxrQkFBa0IsTUFBTSxTQUFTO0FBRTVELGVBQU87Ozs7OztBQ2pCWDs7Ozs7bUNBY0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGVBQWdCLGFBQUE7QUFFVCw4Q0FBb0MsWUFBQSxRQUFVO2FBQ3BELGNBQWM7QUFDbkIsWUFBSTtBQUVKLGNBQU0sVUFBVSxhQUNWLFdBQVcsV0FBQSxzQkFDWCx5QkFBeUIsVUFBQSxRQUFhLGFBQWEsV0FDbkQsK0JBQStCLGVBQUEsUUFBa0IsWUFBWTtBQUVuRSxnQkFBUTtVQUNOO1VBQ0E7O0FBR0YsY0FBTSxzQkFBc0IsaUJBQUEsUUFBb0IsVUFBVSxRQUNwRCxnQ0FBZ0MsaUJBQUEsUUFBb0IsU0FBUztBQUVuRSxnQkFBUTtVQUNOO1VBQ0E7O0FBR0YsY0FBTSxhQUFhLE1BQ2Isd0JBQXdCLElBQUksc0JBQXNCLE9BQU87QUFFL0QsZUFBTzs7Ozs7O0FDdkNYOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sMkNBQWlDLE1BQUEsUUFBSTthQUMzQyxjQUFjO0FBQ25CLGNBQU0sd0JBQXdCLGFBQUEsUUFBc0IsZUFDOUMsT0FBTyxXQUFBLHVCQUNQLFVBQVUsTUFDVixjQUFjO1VBQ1o7V0FFRixrQkFBa0IsSUFBSSxtQkFBbUIsTUFBTSxTQUFTO0FBRTlELGVBQU87Ozs7OztBQ2pCWDs7Ozs7bUNBZUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDRDQUFrQyxNQUFBLFFBQUk7YUFDNUMsY0FBYztBQUNuQixZQUFJO0FBRUosY0FBTSxPQUFPLFdBQUE7QUFFYixtQkFBVyxXQUFBO0FBRVgsY0FBTSw0QkFBNEIsVUFBQSxRQUFtQixhQUFhO0FBRWxFLG1CQUFXLFdBQUE7QUFFWCxjQUFNLDZCQUE2QixVQUFBLFFBQW1CLGFBQWE7QUFFbkUsbUJBQVcsV0FBQTtBQUVYLGNBQU0sOEJBQThCLFVBQUEsUUFBbUIsYUFBYTtBQUVwRSxtQkFBVyxXQUFBO0FBRVgsY0FBTSxrQ0FBa0MsVUFBQSxRQUFtQixhQUFhO0FBRXhFLG1CQUFXLFdBQUE7QUFFWCxjQUFNLHFDQUFxQyxVQUFBLFFBQW1CLGFBQWE7QUFFM0UsbUJBQVcsV0FBQTtBQUVYLGNBQU0sc0NBQXNDLFVBQUEsUUFBbUIsYUFBYTtBQUU1RSxtQkFBVyxXQUFBO0FBRVgsY0FBTSx1Q0FBdUMsVUFBQSxRQUFtQixhQUFhO0FBRTdFLG1CQUFXLFdBQUE7QUFFWCxjQUFNLHlDQUF5QyxVQUFBLFFBQW1CLGFBQWEsV0FDekUsVUFBVSxNQUNWLGNBQWM7VUFDWjtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1dBRUYsbUJBQW1CLElBQUksb0JBQW9CLE1BQU0sU0FBUztBQUVoRSxlQUFPOzs7Ozs7QUNqRVg7Ozs7O21DQWNBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxhQUFhLGFBQWEsZ0JBQWlCLGFBQUE7QUFFcEMsZ0RBQXNDLFlBQUEsUUFBVTthQUN0RCxjQUFjO0FBQ25CLFlBQUk7QUFFSixjQUFNLFdBQVcsV0FBQSx1QkFDWCxrQ0FBa0MsYUFDbEMsa0NBQWtDLGFBQ2xDLG1DQUFtQyxjQUNuQyx5QkFBeUIsVUFBQSxRQUFhLGFBQWEsV0FDbkQsK0JBQStCLGVBQUEsUUFBa0IsWUFBWSxrQ0FDN0QsK0JBQStCLGVBQUEsUUFBa0IsWUFBWSxrQ0FDN0QsZ0NBQWdDLGVBQUEsUUFBa0IsWUFBWTtBQUVwRSxnQkFBUTtVQUNOO1VBQ0E7O0FBR0YsY0FBTSxzQkFBc0IsaUJBQUEsUUFBb0IsVUFBVSxRQUNwRCwrQkFBK0IsZ0JBQUEsUUFBbUIsU0FBUztBQUVqRSxnQkFBUTtVQUNOO1VBQ0E7VUFDQTtVQUNBOztBQUdGLGNBQU0sYUFBYSxNQUNiLDBCQUEwQixJQUFJLHdCQUF3QixPQUFPO0FBRW5FLGVBQU87Ozs7OztBQzdDWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLDZDQUFtQyxNQUFBLFFBQUk7YUFDN0MsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSwyQkFDUCwwQkFBMEIsZUFBQSxRQUF3QixlQUNsRCxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsb0JBQW9CLElBQUkscUJBQXFCLE1BQU0sU0FBUztBQUVsRSxlQUFPOzs7Ozs7QUNqQlg7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHVEQUE2QyxZQUFBLFFBQVU7YUFDN0QseUJBQXlCLHNCQUFzQjtBQUNwRCxjQUFNLDJCQUEyQixzQkFBQSxRQUF5Qix5QkFBeUIsdUJBQzdFLFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYixpQ0FBaUMsSUFBSSwrQkFBK0IsT0FBTztBQUVqRixlQUFPOzs7Ozs7QUNkWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLHFCQUFzQixhQUFBO0FBRWYsNkNBQW1DLE1BQUEsUUFBSTthQUM3QyxjQUFjO0FBQ25CLGNBQU0sdUJBQXVCLG1CQUN2Qiw4Q0FBOEMsc0JBQUEsUUFBK0IseUJBQXlCLHVCQUN0RyxPQUFPLFdBQUEsMEJBQ1AsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLG9CQUFvQixJQUFJLHFCQUFxQixNQUFNLFNBQVM7QUFFbEUsZUFBTzs7Ozs7O0FDdEJYOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUFOLDhEQUFvRCxZQUFBLFFBQVU7YUFDcEUsY0FBYztBQUNuQixZQUFJO0FBRUosbUJBQVcsV0FBQTtBQUVYLGNBQU0sdUJBQXVCLFVBQUEsUUFBYSxhQUFhO0FBRXZELG1CQUFXLFdBQUE7QUFFWCxjQUFNLGdDQUFnQyxVQUFBLFFBQWEsYUFBYSxXQUMxRCxvQ0FBb0MsY0FBQSxRQUFpQixTQUFTLGdDQUM5RCxRQUFRO1VBQ047VUFDQTtXQUVGLGFBQWEsTUFDYix3Q0FBd0MsSUFBSSxzQ0FBc0MsT0FBTztBQUUvRixlQUFPOzs7Ozs7QUMzQlg7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBQU4sK0NBQXFDLE1BQUEsUUFBSTthQUMvQyxjQUFjO0FBQ25CLFlBQUk7QUFFSixjQUFNLE9BQU8sV0FBQTtBQUViLG1CQUFXLFdBQUE7QUFFWCxjQUFNLGtDQUFrQyxVQUFBLFFBQW1CLGFBQWE7QUFFeEUsbUJBQVcsV0FBQTtBQUVYLGNBQU0sb0NBQW9DLFVBQUEsUUFBbUIsYUFBYSxXQUNwRSx3Q0FBd0MsV0FBQSxRQUFzQyxlQUM5RSxVQUFVLE1BQ1YsY0FBYztVQUNaO1VBQ0E7VUFDQTtXQUVGLHNCQUFzQixJQUFJLHVCQUF1QixNQUFNLFNBQVM7QUFFdEUsZUFBTzs7Ozs7O0FDOUJYOzs7OzttQ0FhQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxhQUFhLGdCQUFpQixhQUFBO0FBRXZCLGtEQUF3QyxZQUFBLFFBQVU7YUFDeEQsY0FBYztBQUNuQixjQUFNLFdBQVcsV0FBQSxnQkFDWCxrQ0FBa0MsYUFDbEMsbUNBQW1DLGNBQ25DLG1CQUFtQixVQUFBLFFBQWEsYUFBYSxXQUM3QywrQkFBK0IsZUFBQSxRQUFrQixZQUFZLGtDQUM3RCxnQ0FBZ0MsZUFBQSxRQUFrQixZQUFZLG1DQUM5RCxpQ0FBaUMsZ0JBQUEsUUFBbUIsU0FBUyxtQkFDN0QsUUFBUTtVQUNOO1VBQ0E7VUFDQTtVQUNBO1dBRUYsYUFBYSxNQUNiLDRCQUE0QixJQUFJLDBCQUEwQixPQUFPO0FBRXZFLGVBQU87Ozs7OztBQy9CWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLCtDQUFxQyxNQUFBLFFBQUk7YUFDL0MsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSw2QkFDUCw0QkFBNEIsaUJBQUEsUUFBMEIsZUFDdEQsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLHNCQUFzQixJQUFJLHVCQUF1QixNQUFNLFNBQVM7QUFFdEUsZUFBTzs7Ozs7O0FDakJYOzs7OzttQ0FZQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxRQUFRLGNBQWUsYUFBQTtBQUVoQixzREFBNEMsWUFBQSxRQUFVO2FBQzVELGNBQWM7QUFDbkIsWUFBSTtBQUVKLGtCQUFVO0FBRVYsY0FBTSwwQkFBMEIsZUFBQSxRQUFrQixZQUFZO0FBRTlELGtCQUFVO0FBRVYsY0FBTSw4QkFBOEIsZUFBQSxRQUFrQixZQUFZO0FBRWxFLGNBQU0sZ0NBQWdDLFlBQUEsUUFBVyxTQUFTLDBCQUNwRCxvQ0FBb0MsWUFBQSxRQUFXLFNBQVMsOEJBQ3hELGNBQWM7VUFDWjtVQUNBO1dBRUYsaUVBQWlFLGVBQUEsUUFBa0IsZ0JBQWdCLGNBQ25HLG1CQUFtQixjQUFBLFFBQWlCLGVBQ3BDLFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLGdDQUFnQyxJQUFJLDhCQUE4QixPQUFPO0FBRS9FLGVBQU87Ozs7OztBQ3ZDWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLCtDQUFxQyxNQUFBLFFBQUk7YUFDL0MsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSw0QkFDUCxnQ0FBZ0MscUJBQUEsUUFBOEIsZUFDOUQsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLHNCQUFzQixJQUFJLHVCQUF1QixNQUFNLFNBQVM7QUFFdEUsZUFBTzs7Ozs7O0FDakJYOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxnQkFBaUIsYUFBQTtBQUVWLG1EQUF5QyxZQUFBLFFBQVU7YUFDekQsY0FBYztBQUNuQixjQUFNLFVBQVUsY0FDVixvQkFBb0IsZUFBQSxRQUFrQixZQUFZLFVBQ2xELFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYiw2QkFBNkIsSUFBSSwyQkFBMkIsT0FBTztBQUV6RSxlQUFPOzs7Ozs7QUNuQlg7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTixnREFBc0MsTUFBQSxRQUFJO2FBQ2hELGNBQWM7QUFDbkIsY0FBTSw2QkFBNkIsa0JBQUEsUUFBMkIsZUFDeEQsT0FBTyxXQUFBLDhCQUNQLFVBQVUsTUFDVixjQUFjO1VBQ1o7V0FFRix1QkFBdUIsSUFBSSx3QkFBd0IsTUFBTSxTQUFTO0FBRXhFLGVBQU87Ozs7OztBQ2pCWDs7Ozs7bUNBVUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFlBQWEsYUFBQTtBQUVOLHdEQUE4QyxZQUFBLFFBQVU7YUFDOUQsY0FBYztBQUNuQixjQUFNLFVBQVUsVUFDVixtQkFBbUIsY0FBQSxRQUFpQixlQUNwQyxvQkFBb0IsZUFBQSxRQUFrQixZQUFZLFVBQ2xELFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLGtDQUFrQyxJQUFJLGdDQUFnQyxPQUFPO0FBRW5GLGVBQU87Ozs7OztBQ3RCWDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLGlEQUF1QyxNQUFBLFFBQUk7YUFDakQsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSwrQkFDUCxrQ0FBa0MsdUJBQUEsUUFBZ0MsZUFDbEUsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLHdCQUF3QixJQUFJLHlCQUF5QixNQUFNLFNBQVM7QUFFMUUsZUFBTzs7Ozs7O0FDakJYOzs7OzttQ0FXQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUseUJBQTBCLGFBQUE7QUFFbkIsaURBQXVDLE1BQUEsUUFBSTthQUNqRCxjQUFjO0FBQ25CLGNBQU0sdUJBQXVCLHVCQUN2QixrREFBa0Qsc0JBQUEsUUFBK0IseUJBQXlCLHVCQUMxRyxPQUFPLFdBQUEsOEJBQ1AsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLHdCQUF3QixJQUFJLHlCQUF5QixNQUFNLFNBQVM7QUFFMUUsZUFBTzs7Ozs7O0FDdEJYOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4saURBQXVDLFlBQUEsUUFBVTthQUN2RCxrQkFBa0IsZUFBZTtBQUN0QyxjQUFNLFVBQVUsZUFDVixtQkFBbUIsY0FBQSxRQUFpQixlQUNwQyxvQkFBb0IsZUFBQSxRQUFrQixZQUFZLFVBQ2xELFFBQVE7VUFDTjtVQUNBO1dBRUYsYUFBYSxNQUNiLDJCQUEyQixJQUFJLHlCQUF5QixPQUFPO0FBRXJFLGVBQU87Ozs7OztBQ2xCWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGdCQUFpQixhQUFBO0FBRVYsa0RBQXdDLE1BQUEsUUFBSTthQUNsRCxjQUFjO0FBQ25CLGNBQU0sT0FBTyxXQUFBLCtCQUNQLGdCQUFnQixjQUNoQixtQ0FBbUMsZ0JBQUEsUUFBeUIsa0JBQWtCLGdCQUM5RSxVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYseUJBQXlCLElBQUksMEJBQTBCLE1BQU0sU0FBUztBQUU1RSxlQUFPOzs7Ozs7QUN0Qlg7Ozs7O21DQVNBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGtCQUFtQixhQUFBO0FBRVoscURBQTJDLFlBQUEsUUFBVTthQUMzRCxjQUFjO0FBQ25CLGNBQU0sVUFBVSxnQkFDVixvQkFBb0IsZUFBQSxRQUFrQixZQUFZLFVBQ2xELFFBQVE7VUFDTjtXQUVGLGFBQWEsTUFDYiwrQkFBK0IsSUFBSSw2QkFBNkIsT0FBTztBQUU3RSxlQUFPOzs7Ozs7QUNuQlg7Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTixrREFBd0MsTUFBQSxRQUFJO2FBQ2xELGNBQWM7QUFDbkIsY0FBTSwrQkFBK0Isb0JBQUEsUUFBNkIsZUFDNUQsT0FBTyxXQUFBLGlDQUNQLFVBQVUsTUFDVixjQUFjO1VBQ1o7V0FFRix5QkFBeUIsSUFBSSwwQkFBMEIsTUFBTSxTQUFTO0FBRTVFLGVBQU87Ozs7OztBQ2pCWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLFFBQVMsYUFBQTtBQUVGLG1EQUF5QyxNQUFBLFFBQUk7YUFDbkQsY0FBYztBQUNuQixjQUFNLE9BQU8sV0FBQSxrQ0FDUCxnQkFBZ0IsTUFDaEIsb0NBQW9DLGdCQUFBLFFBQXlCLGtCQUFrQixnQkFDL0UsVUFBVSxNQUNWLGNBQWM7VUFDWjtXQUVGLDBCQUEwQixJQUFJLDJCQUEyQixNQUFNLFNBQVM7QUFFOUUsZUFBTzs7Ozs7O0FDdEJYOzs7OzttQ0FXQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsWUFBYSxhQUFBO0FBRU4sb0RBQTBDLE1BQUEsUUFBSTthQUNwRCxjQUFjO0FBQ25CLGNBQU0sT0FBTyxXQUFBLG1DQUNQLGdCQUFnQixVQUNoQixxQ0FBcUMsZ0JBQUEsUUFBeUIsa0JBQWtCLGdCQUNoRixVQUFVLE1BQ1YsY0FBYztVQUNaO1dBRUYsMkJBQTJCLElBQUksNEJBQTRCLE1BQU0sU0FBUztBQUVoRixlQUFPOzs7Ozs7QUN0Qlg7Ozs7O21DQVdBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxZQUFhLGFBQUE7QUFFTixvREFBMEMsTUFBQSxRQUFJO2FBQ3BELGNBQWM7QUFDbkIsY0FBTSx1QkFBdUIsVUFDdkIscUNBQXFDLHNCQUFBLFFBQStCLHlCQUF5Qix1QkFDN0YsT0FBTyxXQUFBLGtDQUNQLFVBQVUsTUFDVixjQUFjO1VBQ1o7V0FFRiwyQkFBMkIsSUFBSSw0QkFBNEIsTUFBTSxTQUFTO0FBRWhGLGVBQU87Ozs7OztBQ3RCWDs7Ozs7Ozs7Ozs7OztVQXdGQSxVQUFBO2VBQUE7O1VBcERnQixtQkFBQTtlQUFBOztVQTVCQSxnQkFBQTtlQUFBOztVQStDQSwrQkFBQTtlQUFBOztVQVBBLHFCQUFBO2VBQUE7O1VBd0JBLHFDQUFBO2VBQUE7Ozs7O0FBcEVoQixRQUFNLENBQUUsZUFBTyxTQUFVLFdBQUE7QUFJbEIsMkJBQXVCLE9BQU8sV0FBUztBQUM1QyxZQUFNLHdCQUF3QixNQUFNLE9BQU8sQ0FBQyx3QkFBdUIsU0FBQTtBQUM3RCxjQUFNLFdBQVcsS0FBSyxXQUNoQixVQUFVLEtBQUs7QUFFckIsWUFBSSxpQkFBaUIsU0FBUztBQUU5QixZQUFJLFlBQVksTUFBTTtBQUNwQixnQkFBTSxnQkFBZ0IsUUFBUTtBQUU5Qiw0QkFBa0I7O0FBR3BCLGlDQUF3QixLQUFLLElBQUksd0JBQXVCO0FBRXhELGVBQU87U0FDTixJQUNILGNBQWMsTUFBTSxPQUFPLENBQUMsY0FBYSxTQUFBO0FBQ3ZDLGNBQU0sYUFBYSxLQUFLLFNBQVMsdUJBQXVCO0FBRXhELHdCQUFlO0FBRWYsZUFBTztTQUNOLFdBQUEsY0FBYyxRQUFRLFNBQVMsV0FBQTtBQUV0QyxhQUFPOztBQUdGLDhCQUEwQixPQUFLO0FBQ3BDLFlBQU0sVUFBVTtBQUVoQixZQUFNLFFBQVEsQ0FBQyxTQUFBO0FBQ2IsY0FBTSxXQUFXLEtBQUs7QUFFdEIsZ0JBQVEsWUFBWTs7QUFHdEIsYUFBTzs7QUFHRixnQ0FBNEIsT0FBSztBQUN0QyxZQUFNLFlBQVksT0FBTSxRQUNsQixZQUFZO0FBRWxCLGFBQU87O0FBR0YsMENBQXNDLFdBQVcsU0FBTztBQUM3RCxZQUFNLFFBQVEsT0FBTyxPQUFPLFVBQ3RCLGdCQUFnQixVQUFVO0FBRWhDLGtCQUFZLE1BQU0sT0FBTyxDQUFDLFNBQUE7QUFDeEIsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxhQUFhLGVBQWU7QUFDOUIsaUJBQU87OztBQUlYLFlBQU0sUUFBUTtBQUVkLGFBQU87O0FBR0YsZ0RBQTRDLE9BQU8sZUFBYTtBQUNyRSxVQUFJLFlBQVksTUFBTSxLQUFLLENBQUMsU0FBQTtBQUMxQixjQUFNLFdBQVcsS0FBSztBQUV0QixZQUFJLGFBQWEsZUFBZTtBQUM5QixpQkFBTzs7WUFFTDtBQUVOLFVBQUksY0FBYyxNQUFNO0FBQ3RCLG9CQUFZLG1CQUFtQjs7QUFHakMsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUM3RkY7Ozs7O21DQXFDQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU4sMkJBQU07TUFDbkIsWUFBWSxXQUFXLFNBQVM7QUFDOUIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssVUFBVTs7TUFHakIsZUFBZTtBQUNiLGVBQU8sS0FBSzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOztNQUdmLGdCQUFnQixRQUFRO0FBQ3RCLFlBQUk7QUFFSCxjQUFNLE9BQU8sS0FBSyxNQUFNO0FBRXhCLFlBQUksU0FBUyxNQUFNO0FBQ2pCLGdCQUFNLElBQUksTUFBTTs7QUFHbEIsZ0JBQVEsS0FBSyxjQUFjLE1BQUE7QUFFM0IsY0FBTSxjQUFjLE1BQU07QUFFMUIsWUFBSSxnQkFBZ0IsR0FBRztBQUNyQixnQkFBTSxJQUFJLE1BQU07O0FBR2xCLGVBQU87O2FBU0YsY0FBYztBQUNuQixjQUFNLGNBQWMsTUFBQSxRQUFZLGVBQzFCLGNBQWMsTUFBQSxRQUFZLGVBQzFCLGNBQWMsT0FBQSxRQUFZLGVBQzFCLGVBQWUsT0FBQSxRQUFhLGVBQzVCLGlCQUFpQixTQUFBLFFBQWUsZUFDaEMsa0JBQWtCLFVBQUEsUUFBZ0IsZUFDbEMsa0JBQWtCLFVBQUEsUUFBZ0IsZUFDbEMsa0JBQWtCLFVBQUEsUUFBZ0IsZUFDbEMsbUJBQW1CLFdBQUEsUUFBaUIsZUFDcEMsb0JBQW9CLFlBQUEsUUFBa0IsZUFDdEMsb0JBQW9CLFlBQUEsUUFBa0IsZUFDdEMsb0JBQW9CLFlBQUEsUUFBa0IsZUFDdEMsb0JBQW9CLFlBQUEsUUFBa0IsZUFDdEMscUJBQXFCLGFBQUEsUUFBbUIsZUFDeEMsc0JBQXNCLGNBQUEsUUFBb0IsZUFDMUMsdUJBQXVCLGVBQUEsUUFBcUIsZUFDNUMsdUJBQXVCLGVBQUEsUUFBcUIsZUFDNUMseUJBQXlCLGlCQUFBLFFBQXVCLGVBQ2hELHlCQUF5QixpQkFBQSxRQUF1QixlQUNoRCx5QkFBeUIsaUJBQUEsUUFBdUIsZUFDaEQsMEJBQTBCLGtCQUFBLFFBQXdCLGVBQ2xELDJCQUEyQixtQkFBQSxRQUF5QixlQUNwRCwyQkFBMkIsbUJBQUEsUUFBeUIsZUFDcEQsNEJBQTRCLG9CQUFBLFFBQTBCLGVBQ3RELDRCQUE0QixvQkFBQSxRQUEwQixlQUN0RCw2QkFBNkIscUJBQUEsUUFBMkIsZUFDeEQsOEJBQThCLHNCQUFBLFFBQTRCLGVBQzFELDhCQUE4QixzQkFBQSxRQUE0QixlQUMxRCxRQUFRO1VBQ047VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7V0FFRixZQUFZLElBQUEsT0FBQSxvQkFBbUIsUUFDL0IsVUFBVSxJQUFBLE9BQUEsa0JBQWlCLFFBQzNCLFlBQVksSUFBSSxXQUFVLFdBQVc7QUFFM0MsZUFBTzs7O0FBdkdJO0FBa0NOLGtCQWxDTSxXQWtDTixzQkFBcUIsb0JBQUE7QUFFckIsa0JBcENNLFdBb0NOLDBCQUF5QjtBQUV6QixrQkF0Q00sV0FzQ04sT0FBTSxLQUFBO0FBcUVmLFdBQU8sT0FBTyxVQUFVLFdBQVcsUUFBQTs7OztBQ2hKbkM7Ozs7O21DQWdDQSxXQUFBOzs7ZUFBQTs7O0FBOUJBLFFBQU0sTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUE4QlosV0FBZTs7OztBQ2hDZjs7Ozs7Ozs7Ozs7OztVQWtDQSxVQUFBO2VBQUE7O1VBaEJnQixrQkFBQTtlQUFBOztVQVFBLGtDQUFBO2VBQUE7O1VBZkEsZUFBQTtlQUFBOzs7Ozs7Ozs7OztBQUhoQixRQUFNLFdBQVcsYUFBQSxTQUFTO0FBQTFCLFFBQ00sWUFBWSxRQUFBLFFBQVU7QUFFckIsMEJBQXNCLEtBQUc7QUFDOUIsWUFBTSxTQUFTLFNBQVMsY0FBYyxNQUNoQyxRQUFRLFVBQVUsZ0JBQWdCO0FBRXhDLGFBQU87O0FBR0YsNkJBQXlCLE9BQU8sT0FBSztBQUMxQyxZQUFNLFlBQVksSUFBQSxPQUFBLG9CQUFtQixRQUMvQixVQUFVLElBQUEsT0FBQSxrQkFBaUIsUUFDM0IsU0FBUyxJQUFJLE1BQU0sV0FBVztBQUVwQyxhQUFPOztBQUdGLDZDQUF5QyxPQUFPLE9BQU8sZUFBYTtBQUN6RSxZQUFNLFlBQVksSUFBQSxPQUFBLG9DQUFtQyxPQUFPLGdCQUN0RCxVQUFVLElBQUEsT0FBQSxrQkFBaUIsUUFDM0IsU0FBUyxJQUFJLE1BQU0sV0FBVztBQUVwQyxhQUFPOztRQUdULFdBQWU7TUFDYjtNQUNBO01BQ0E7Ozs7O0FDckNGOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sNkJBQU07TUFDbkIsWUFBWSxXQUFXLFNBQVM7QUFDOUIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssVUFBVTs7TUFHakIsZUFBZTtBQUNiLGVBQU8sS0FBSzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOzthQU9QLFlBQVksT0FBTztBQUN4QixjQUFNLENBQUUsT0FBUSxPQUNWLFFBQVEsSUFBQSxTQUFBLGNBQWEsTUFDckIsU0FBUyxJQUFBLFNBQUEsaUJBQWdCLE9BQU87QUFFdEMsZUFBTzs7YUFHRixRQUFRLE9BQU8sS0FBSztBQUN6QixjQUFNLFFBQVEsSUFBQSxTQUFBLGNBQWEsTUFDckIsU0FBUyxJQUFBLFNBQUEsaUJBQWdCLE9BQU87QUFFdEMsZUFBTzs7YUFHRixVQUFVLE9BQU8sT0FBTztBQUM3QixjQUFNLFNBQVMsSUFBQSxTQUFBLGlCQUFnQixPQUFPO0FBRXRDLGVBQU87OztBQXRCRixrQkFkTSxjQWNOLHNCQUFxQjtBQUVyQixrQkFoQk0sY0FnQk4sMEJBQXlCLGFBQUE7QUF3QmxDLFdBQU8sT0FBTyxhQUFhLFdBQVcsUUFBQTs7OztBQy9DdEM7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHFDQUEwQixRQUFBLFFBQVk7YUFHNUMsY0FBYztBQUFFLGVBQU8sUUFBQSxRQUFhLFlBQVk7O2FBRWhELFFBQVEsS0FBSztBQUFFLGVBQU8sUUFBQSxRQUFhLFFBQVEsY0FBYTs7YUFFeEQsVUFBVSxPQUFPO0FBQUUsZUFBTyxRQUFBLFFBQWEsVUFBVSxjQUFhOzs7QUFQeEQ7QUFDTixrQkFETSxhQUNOLE9BQU0sS0FBQTs7OztBQ05mOzs7OzttQ0FlQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFBQSxXQUFlO01BQ2IsYUFBQSxTQUFBO01BQ0EsY0FBQSxVQUFBO01BQ0EsY0FBQSxVQUFBO01BQ0EsZUFBQSxXQUFBO01BQ0Esa0JBQUEsY0FBQTtNQUNBLG1CQUFBLGVBQUE7TUFDQSxtQkFBQSxlQUFBO01BQ0Esb0JBQUEsZ0JBQUE7TUFDQSxxQkFBQSxpQkFBQTtNQUNBLHFCQUFBLGlCQUFBO01BQ0EsdUJBQUEsbUJBQUE7TUFDQSwwQkFBQSxzQkFBQTs7Ozs7QUMzQkY7Ozs7Ozs7Ozs7Ozs7VUFFb0IsWUFBQTtlQUFBLFFBQUE7O1VBQ0EsY0FBQTtlQUFBLFNBQUE7O1VBQ0EsZUFBQTtlQUFBLFNBQUE7O1VBV0EsYUFBQTtlQUFBLFlBQUE7O1VBQ0EsY0FBQTtlQUFBLFNBQUE7O1VBRUEsa0JBQUE7ZUFBQSxhQUFBOztVQUpBLGFBQUE7ZUFBQSxZQUFBOztVQUZBLFFBQUE7ZUFBQSxPQUFBOztVQURBLE9BQUE7ZUFBQSxNQUFBOztVQU1BLGVBQUE7ZUFBQSxVQUFBOztVQVhBLGFBQUE7ZUFBQSxNQUFBOztVQUdBLGtCQUFBO2VBQUEsU0FBQTs7VUFJQSxZQUFBO2VBQUEsV0FBQTs7VUFMQSxpQkFBQTtlQUFBLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNScEI7Ozs7O21DQTJKQSxXQUFBOzs7ZUFBQTs7O0FBekpBLFFBQU0sTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUF5SlosV0FBZTs7OztBQzNKZjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sbUNBQXdCLGNBQUEsYUFBWTthQUcxQyxjQUFjO0FBQUUsZUFBTyxjQUFBLGFBQWEsWUFBWTs7YUFFaEQsUUFBUSxLQUFLO0FBQUUsZUFBTyxjQUFBLGFBQWEsUUFBUSxZQUFXOzthQUV0RCxVQUFVLE9BQU87QUFBRSxlQUFPLGNBQUEsYUFBYSxVQUFVLFlBQVc7OztBQVB0RDtBQUNOLGtCQURNLFdBQ04sT0FBTSxLQUFBOzs7O0FDUGY7Ozs7Ozs7Ozs7Ozs7VUFNYSxzQkFBQTtlQUFBOztVQUpBLGtCQUFBO2VBQUE7O1VBQ0Esa0JBQUE7ZUFBQTs7VUFRQSw2QkFBQTtlQUFBOztVQUpBLHNCQUFBO2VBQUE7O1VBRkEsbUJBQUE7ZUFBQTs7VUFJQSx3QkFBQTtlQUFBOztVQUNBLDJCQUFBO2VBQUE7O1VBRkEsdUJBQUE7ZUFBQTs7VUFKQSxtQkFBQTtlQUFBOzs7QUFGTixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLG1CQUFtQjtBQUN6QixRQUFNLG1CQUFtQjtBQUN6QixRQUFNLHNCQUFzQjtBQUM1QixRQUFNLHNCQUFzQjtBQUM1QixRQUFNLHVCQUF1QjtBQUM3QixRQUFNLHdCQUF3QjtBQUM5QixRQUFNLDJCQUEyQjtBQUNqQyxRQUFNLDZCQUE2Qjs7OztBQ1gxQzs7Ozs7Ozs7Ozs7OztVQWdNZ0IseUJBQUE7ZUFBQTs7VUFnRkEsK0JBQUE7ZUFBQTs7VUFuUUEscUJBQUE7ZUFBQTs7VUEwSkEsc0JBQUE7ZUFBQTs7VUFyQ0EsOEJBQUE7ZUFBQTs7VUFnSEEsNkJBQUE7ZUFBQTs7VUE4RUEsZ0NBQUE7ZUFBQTs7VUF0U0Esd0JBQUE7ZUFBQTs7VUFnRkEsNEJBQUE7ZUFBQTs7VUFtSkEsK0JBQUE7ZUFBQTs7VUE4RUEsa0NBQUE7ZUFBQTs7VUFsSEEsMkJBQUE7ZUFBQTs7VUE4RUEsc0NBQUE7ZUFBQTs7VUE2REEseUNBQUE7ZUFBQTs7VUFsU0EseUJBQUE7ZUFBQTs7VUE4RUEsdUJBQUE7ZUFBQTs7OztBQW5JVCxnQ0FBNEIsV0FBUztBQUMxQyxZQUFNLGtCQUFrQixXQUNsQixRQUFRLG1CQUFtQixpQkFBaUIsQ0FBQyxtQkFBQTtBQUMzQyxjQUFNLGVBQWUsZ0JBQ2YsVUFBVSxhQUFhLGNBQ3ZCLFNBQVEsT0FBTztBQUVyQixlQUFPOztBQUdmLGFBQU87O0FBR0YsbUNBQStCLFVBQVE7QUFDNUMsWUFBTSxnQkFBZ0IsMEJBQTBCLFdBQzFDLGdCQUFnQixjQUFjLE9BQU8sQ0FBQyxnQkFBZSxpQkFBQTtBQUNuRCxjQUFNLGtCQUFrQixjQUNsQixlQUFlLG1CQUFtQixpQkFBaUIsQ0FBQyxtQkFBQTtBQUNsRCxjQUFJLGdCQUFlO0FBRW5CLGdCQUFNLG1CQUFrQixnQkFDbEIsV0FBVyxpQkFBZ0IsZUFDM0IsMkJBQTRCLGFBQWEsV0FBQTtBQUUvQyxjQUFJLDBCQUEwQjtBQUM1Qiw0QkFBZTs7QUFHakIsaUJBQU87O0FBR2YsWUFBSSxpQkFBaUIsTUFBTTtBQUN6Qix5QkFBYyxLQUFLOztBQUdyQixlQUFPO1NBQ04sS0FDSCxZQUFZLGNBQWMsSUFBSSxDQUFDLGlCQUFBO0FBQzdCLGNBQU0sa0JBQWtCLGNBQ2xCLFdBQVcsbUJBQW1CLGlCQUFpQixDQUFDLG1CQUFBO0FBQzlDLGdCQUFNLGVBQWUsZ0JBQ2YsVUFBVSxhQUFhLGNBQ3ZCLFlBQVc7QUFFakIsaUJBQU87O0FBR2YsZUFBTzs7QUFHZixhQUFPOztBQUdGLG9DQUFnQyxVQUFRO0FBQzdDLFlBQU0sZ0JBQWdCLDBCQUEwQixXQUMxQyxpQkFBaUIsY0FBYyxPQUFPLENBQUMsaUJBQWdCLGlCQUFBO0FBQ3JELGNBQU0sa0JBQWtCLGNBQ2xCLGdCQUFnQixtQkFBbUIsaUJBQWlCLENBQUMsbUJBQUE7QUFDbkQsY0FBSSxpQkFBZ0I7QUFFcEIsZ0JBQU0sbUJBQWtCLGdCQUNsQixXQUFXLGlCQUFnQixlQUMzQiw0QkFBNkIsYUFBYSxXQUFBO0FBRWhELGNBQUksMkJBQTJCO0FBQzdCLDZCQUFnQjs7QUFHbEIsaUJBQU87O0FBR2YsWUFBSSxrQkFBa0IsTUFBTTtBQUMxQiwwQkFBZSxLQUFLOztBQUd0QixlQUFPO1NBQ04sS0FDSCxhQUFhLGVBQWUsSUFBSSxDQUFDLGtCQUFBO0FBQy9CLGNBQU0sa0JBQWtCLGVBQ2xCLFlBQVksbUJBQW1CLGlCQUFpQixDQUFDLG1CQUFBO0FBQy9DLGdCQUFNLGVBQWUsZ0JBQ2YsVUFBVSxhQUFhLGNBQ3ZCLGFBQVk7QUFFbEIsaUJBQU87O0FBR2YsZUFBTzs7QUFHZixhQUFPOztBQUdGLHVDQUFtQyxVQUFRO0FBQ2hELFVBQUk7QUFFSix3QkFBa0I7QUFFbEIsWUFBTSxnQkFBZ0Isa0JBQWtCLGlCQUFpQixDQUFDLGtCQUFBO0FBQ3hELGNBQU0saUJBQWdCO0FBRXRCLGVBQU87O0FBR1Qsd0JBQWtCO0FBRWxCLFlBQU0sZ0JBQWdCLGdCQUFnQixnQkFBZ0IsQ0FBQyxjQUFBO0FBQ3JELGNBQU0sMkJBQTJCLFVBQVU7QUFFM0MsWUFBSSwwQkFBMEI7QUFDNUIsaUJBQU87OztBQUlYLGFBQU87O0FBR0YseUNBQXFDLFVBQVE7QUFDbEQsWUFBTSxrQkFBa0IsVUFDbEIsa0JBQWtCLG9CQUFvQixpQkFBaUIsQ0FBQyxvQkFBQTtBQUN0RCxjQUFNLG1CQUFrQixpQkFDbEIsV0FBVyxpQkFBZ0IsZUFDM0Isa0NBQW1DLGFBQWEsV0FBQSw0QkFDaEQsbUJBQWtCO0FBRXhCLGVBQU87WUFDSDtBQUVaLGFBQU87O0FBR0Ysa0NBQThCLFlBQVU7QUFDN0MsWUFBTSxrQkFBa0IsWUFDbEIsU0FBUyxtQkFBbUIsaUJBQWlCLENBQUMsbUJBQUE7QUFDNUMsWUFBSSxVQUFTO0FBRWIsY0FBTSxnQ0FBZ0MsZUFBZTtBQUVyRCxZQUFJLCtCQUErQjtBQUNqQyxnQkFBTSxtQkFBa0IsZ0JBQ2xCLFdBQVcsaUJBQWdCLGVBQzNCLHlCQUEwQixhQUFhLFdBQUE7QUFFN0MsY0FBSSx3QkFBd0I7QUFDMUIsc0JBQVM7OztBQUliLGVBQU87O0FBR2YsYUFBTzs7QUFHRixpQ0FBNkIsWUFBVTtBQUM1QyxVQUFJLFFBQVE7QUFFWixZQUFNLGtCQUFrQixZQUNsQixZQUFZLGdCQUFnQixjQUFjLENBQUMsY0FBQTtBQUN6QyxjQUFNLDJCQUEyQixVQUFVO0FBRTNDLFlBQUksMEJBQTBCO0FBQzVCLGdCQUFNLG1CQUFrQixXQUNsQixXQUFXLGlCQUFnQixlQUMzQix3QkFBeUIsYUFBYSxXQUFBO0FBRTVDLGNBQUksdUJBQXVCO0FBQ3pCLG1CQUFPOzs7WUFHUDtBQUVaLFVBQUksY0FBYyxNQUFNO0FBQ3RCLGdCQUFRLG1CQUFtQjs7QUFHN0IsYUFBTzs7QUFHRixvQ0FBZ0MsWUFBVTtBQUMvQyxVQUFJLFdBQVc7QUFFZixZQUFNLGtCQUFrQixZQUNsQixlQUFlLGdCQUFnQixjQUFjLENBQUMsY0FBQTtBQUM1QyxjQUFNLDJCQUEyQixVQUFVO0FBRTNDLFlBQUksMEJBQTBCO0FBQzVCLGdCQUFNLG1CQUFrQixXQUNsQixXQUFXLGlCQUFnQixlQUMzQiwyQkFBNEIsYUFBYSxXQUFBO0FBRS9DLGNBQUksMEJBQTBCO0FBQzVCLG1CQUFPOzs7WUFHUDtBQUVaLFVBQUksaUJBQWlCLE1BQU07QUFDekIsbUJBQVcsbUJBQW1COztBQUdoQyxhQUFPOztBQUdGLHNDQUFrQyxZQUFVO0FBQ2pELFVBQUksYUFBYTtBQUVqQixZQUFNLGtCQUFrQixZQUNsQixpQkFBaUIsZ0JBQWdCLGNBQWMsQ0FBQyxjQUFBO0FBQzlDLGNBQU0sMkJBQTJCLFVBQVU7QUFFM0MsWUFBSSwwQkFBMEI7QUFDNUIsZ0JBQU0sbUJBQWtCLFdBQ2xCLFdBQVcsaUJBQWdCLGVBQzNCLDZCQUE4QixhQUFhLFdBQUE7QUFFakQsY0FBSSw0QkFBNEI7QUFDOUIsbUJBQU87OztZQUdQO0FBRVosVUFBSSxtQkFBbUIsTUFBTTtBQUMzQixxQkFBYSxtQkFBbUI7O0FBR2xDLGFBQU87O0FBR0Ysd0NBQW9DLGdCQUFjO0FBQ3ZELFlBQU0sa0JBQWtCLGdCQUNsQixXQUFXLG1CQUFtQixpQkFBaUIsQ0FBQyxtQkFBQTtBQUM5QyxjQUFNLFlBQVc7QUFFakIsZUFBTzs7QUFHZixhQUFPOztBQUdGLDBDQUFzQyxnQkFBYztBQUN6RCxZQUFNLGtCQUFrQixnQkFDbEIsYUFBYSxvQkFBb0IsaUJBQWlCLENBQUMsb0JBQUE7QUFDakQsWUFBSSxjQUFhO0FBRWpCLGNBQU0sbUJBQWtCLGlCQUNsQixXQUFXLGlCQUFnQixlQUMzQix5QkFBMEIsYUFBYSxXQUFBO0FBRTdDLFlBQUksd0JBQXdCO0FBQzFCLHdCQUFhOztBQUdmLGVBQU87WUFDSDtBQUVaLGFBQU87O0FBR0YsMENBQXNDLGdCQUFjO0FBQ3pELFlBQU0sa0JBQWtCLGdCQUNsQixhQUFhLGdCQUFnQixnQkFBZ0IsQ0FBQyxhQUFZLGNBQUE7QUFDeEQsY0FBTSwyQkFBMkIsVUFBVTtBQUUzQyxZQUFJLDBCQUEwQjtBQUM1QixnQkFBTSxtQkFBa0IsV0FDbEIsV0FBVyxpQkFBZ0IsZUFDM0Isd0JBQXlCLGFBQWEsV0FBQTtBQUU1QyxjQUFJLHVCQUF1QjtBQUN6QixrQkFBTSxZQUFZO0FBRWxCLHdCQUFXLEtBQUs7OztBQUlwQixlQUFPO1NBQ047QUFFVCxhQUFPOztBQUdGLGlEQUE2QyxnQkFBYztBQUNoRSxVQUFJLG9CQUFvQjtBQUV4QixZQUFNLGtCQUFrQixnQkFDbEIsZUFBZSxnQkFBZ0I7QUFFckMsVUFBSSxlQUFlLEdBQUc7QUFDcEIsNEJBQW9CLGtCQUFrQixpQkFBaUIsQ0FBQyxrQkFBQTtBQUN0RCxjQUFJLHFCQUFvQjtBQUV4QixnQkFBTSxtQkFBa0IsZUFDbEIsV0FBVyxpQkFBZ0IsZUFDM0IsZ0NBQWlDLGFBQWEsV0FBQTtBQUVwRCxjQUFJLCtCQUErQjtBQUNqQyxpQ0FBb0I7O0FBR3RCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLDJDQUF1QyxtQkFBaUI7QUFDN0QsWUFBTSxrQkFBa0IsbUJBQ2xCLFdBQVcsbUJBQW1CLGlCQUFpQixDQUFDLG1CQUFBO0FBQzlDLGNBQU0sWUFBVztBQUVqQixlQUFPOztBQUdmLGFBQU87O0FBR0YsNkNBQXlDLG1CQUFpQjtBQUMvRCxVQUFJLGFBQWE7QUFFakIsWUFBTSxrQkFBa0IsbUJBQ2xCLGVBQWUsZ0JBQWdCO0FBRXJDLFVBQUksZUFBZSxHQUFHO0FBQ3BCLHFCQUFhLG9CQUFvQixpQkFBaUIsQ0FBQyxvQkFBQTtBQUNqRCxjQUFJLGNBQWE7QUFFakIsZ0JBQU0sbUJBQWtCLGlCQUNsQixXQUFXLGlCQUFnQixlQUMzQix5QkFBMEIsYUFBYSxXQUFBO0FBRTdDLGNBQUksd0JBQXdCO0FBQzFCLDBCQUFhOztBQUdmLGlCQUFPO2NBQ0g7O0FBR1IsYUFBTzs7QUFHRixvREFBZ0QsbUJBQWlCO0FBQ3RFLFlBQU0sa0JBQWtCO0FBRXhCLDBCQUFvQjtBQUVwQixZQUFNLGVBQWUsZ0JBQWdCO0FBRXJDLFVBQUksZUFBZSxHQUFHO0FBQ3BCLDRCQUFvQixrQkFBa0IsaUJBQWlCLENBQUMsa0JBQUE7QUFDdEQsY0FBSSxxQkFBb0I7QUFFeEIsZ0JBQU0saUJBQWlCLGVBQ2pCLFdBQVcsZUFBZSxlQUMxQixnQ0FBaUMsYUFBYSxXQUFBO0FBRXBELGNBQUksK0JBQStCO0FBQ2pDLGlDQUFvQjs7QUFHdEIsaUJBQU87OztBQUlYLGFBQU87O0FBR1QsZ0NBQTRCLGlCQUFpQixVQUFRO0FBQ25ELFVBQUk7QUFFSixZQUFNLGFBQWE7QUFFbkIsc0JBQWdCLHNCQUFzQixDQUFDLFdBQVcsVUFBQTtBQUNoRCxZQUFJLFVBQVUsWUFBWTtBQUN4QixnQkFBTSxpQkFBaUI7QUFFdkIsbUJBQVMsU0FBUztBQUVsQixpQkFBTzs7O0FBSVgsYUFBTzs7QUFHVCxpQ0FBNkIsaUJBQWlCLFVBQVE7QUFDcEQsVUFBSTtBQUVKLFlBQU0sY0FBYztBQUVwQixzQkFBZ0Isc0JBQXNCLENBQUMsV0FBVyxVQUFBO0FBQ2hELFlBQUksVUFBVSxhQUFhO0FBQ3pCLGdCQUFNLGlCQUFpQjtBQUV2QixtQkFBUyxTQUFTO0FBRWxCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdULGdDQUE0QixpQkFBaUIsVUFBUTtBQUNuRCxVQUFJO0FBRUosWUFBTSxhQUFhO0FBRW5CLHNCQUFnQixzQkFBc0IsQ0FBQyxXQUFXLFVBQUE7QUFDaEQsWUFBSSxVQUFVLFlBQVk7QUFDeEIsZ0JBQU0saUJBQWlCO0FBRXZCLG1CQUFTLFNBQVM7QUFFbEIsaUJBQU87OztBQUlYLGFBQU87O0FBR1QsK0JBQTJCLGlCQUFpQixVQUFRO0FBQ2xELFVBQUk7QUFFSixZQUFNLGVBQWUsZ0JBQWdCLG1CQUMvQixZQUFZLGVBQWU7QUFFakMsc0JBQWdCLHVCQUF1QixDQUFDLFdBQVcsVUFBQTtBQUNqRCxZQUFJLFVBQVUsV0FBVztBQUN2QixnQkFBTSxpQkFBaUI7QUFFdkIsbUJBQVMsU0FBUztBQUVsQixpQkFBTzs7O0FBSVgsYUFBTzs7Ozs7QUNwY1Q7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLHFCQUFNO01BQ25CLFlBQVksV0FBVyxZQUFZLGlCQUFpQjtBQUNsRCxhQUFLLFlBQVk7QUFDakIsYUFBSyxhQUFhO0FBQ2xCLGFBQUssa0JBQWtCOztNQUd6QixlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxvQkFBb0I7QUFDbEIsZUFBTyxLQUFLOzthQUdQLGFBQWEsVUFBVTtBQUM1QixjQUFNLFlBQVksSUFBQSxNQUFBLHVCQUFzQixXQUNsQyxhQUFhLElBQUEsTUFBQSx3QkFBdUIsV0FDcEMsa0JBQWtCLElBQUEsTUFBQSw2QkFBNEIsV0FDOUMsT0FBTyxJQUFJLEtBQUssV0FBVyxZQUFZO0FBRTdDLGVBQU87Ozs7OztBQzdCWDs7Ozs7Ozs7Ozs7OztVQUllLFFBQUE7ZUFBQTs7VUFBMkMsUUFBQTtlQUFBOztVQUE5QixRQUFBO2VBQUE7O1VBQXNCLFNBQUE7ZUFBQTs7VUF1QmxDLFdBQUE7ZUFBQTs7VUF2QmlELE9BQUE7ZUFBQTs7VUFBM0MsT0FBQTtlQUFBOztVQUFhLFNBQUE7ZUFBQTs7VUFBUSxRQUFBO2VBQUE7O1VBRTNCLE9BQUE7ZUFBQTs7OztBQUZULFFBQU0sQ0FBRSxPQUFPLE1BQU0sZUFBTyxRQUFRLE9BQU8sUUFBUSxPQUFPLFFBQVMsV0FBQTtBQUVuRSxrQkFBYyxPQUFPLFlBQVksVUFBUTtBQUM5QyxVQUFJLGFBQWEsR0FBRztBQUNsQixjQUFNLFNBQVMsTUFBTTtBQUVyQixxQkFBYSxTQUFTO0FBRXRCLG1CQUFXLFNBQVM7O0FBR3RCLFVBQUksYUFBYSxVQUFVO0FBQ3pCLGNBQU0sU0FBUSxXQUFXO0FBRXpCLGNBQU0sT0FBTzs7QUFHZixZQUFNLFFBQVEsR0FDUixjQUFjO0FBRXBCLFlBQU0sT0FBTyxPQUFPOztBQUdmLHNCQUFrQixVQUFVLFVBQVE7QUFDekMsYUFBTyxTQUFTLEtBQUssQ0FBQyxZQUFZLE1BQU0sU0FBUzs7Ozs7QUM1Qm5EOzs7OzttQ0FZQSxXQUFBOzs7ZUFBcUI7Ozs7OztBQUZyQixRQUFNLENBQUUsOEJBQStCLFdBQUE7QUFFeEIsdUJBQU07TUFDbkIsWUFBWSxZQUFZLFVBQVUsUUFBUTtBQUN4QyxhQUFLLGFBQWE7QUFDbEIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssU0FBUzs7TUFHaEIsWUFBWSxPQUFPO0FBQ2pCLFlBQUksS0FBSyxRQUFRO0FBQ2YsZ0JBQU0sY0FBYyxNQUFNO0FBRTFCLGNBQUksY0FBYyxHQUFHO0FBQ25CLFlBQUEsSUFBQSxPQUFBLE9BQU07O2VBRUg7QUFDTCxVQUFBLElBQUEsT0FBQSxNQUFLLE9BQU8sS0FBSyxZQUFZLEtBQUs7OzthQUkvQixjQUFjO0FBQ25CLGNBQU0sYUFBYSxHQUNiLFdBQVcsVUFDWCxTQUFTLE9BQ1QsU0FBUyxJQUFJLE9BQU8sWUFBWSxVQUFVO0FBRWhELGVBQU87O2FBR0YsZUFBZSxZQUFZO0FBQ2hDLFlBQUksYUFBYSxHQUNiLFdBQVcsVUFDWCxTQUFTO0FBRWIsWUFBSSxlQUFlLE1BQU07QUFDdkIsZ0JBQU0sUUFBUSxJQUFBLE1BQUEscUJBQW9CO0FBRWxDLGNBQUksVUFBVSxNQUFNO0FBQ2xCLHlCQUFhO0FBRWIsdUJBQVc7aUJBQ047QUFDTCx5QkFBYSxJQUFBLE1BQUEsMEJBQXlCO0FBRXRDLHVCQUFXLElBQUEsTUFBQSx3QkFBdUI7O0FBR3BDLG1CQUFTLElBQUEsTUFBQSxzQkFBcUI7O0FBR2hDLGNBQU0sU0FBUyxJQUFJLE9BQU8sWUFBWSxVQUFVO0FBRWhELGVBQU87O2FBR0YscUJBQXFCLGtCQUFrQjtBQUM1QyxZQUFJLGFBQWEsR0FDYixXQUFXLFVBQ1gsU0FBUztBQUViLFlBQUkscUJBQXFCLE1BQU07QUFDN0IsY0FBSSxxQkFBcUIsNEJBQTRCO0FBQ25ELHFCQUFTO2lCQUNKO0FBQ0wsa0JBQU0sU0FBUyxnQ0FDVCxVQUFVLGlCQUFpQixNQUFNLFNBQ2pDLGNBQWMsSUFBQSxPQUFBLFFBQU8sWUFBWSxNQUNqQyxhQUFhLElBQUEsT0FBQSxPQUFNLFlBQVksTUFDL0IsY0FBYyxJQUFBLE9BQUEsUUFBTyxZQUFZO0FBRXZDLGdCQUFJLGdCQUFnQixNQUFNO0FBQ3hCLDJCQUFhLFNBQVM7QUFFdEIsa0JBQUksZUFBZSxNQUFNO0FBQ3ZCLDJCQUFXOzs7QUFJZixnQkFBSSxnQkFBZ0IsTUFBTTtBQUN4Qix5QkFBVyxTQUFTO0FBRXBCLGtCQUFJLGVBQWUsTUFBTTtBQUN2Qiw2QkFBYTs7Ozs7QUFNckIsY0FBTSxTQUFTLElBQUksT0FBTyxZQUFZLFVBQVU7QUFFaEQsZUFBTzs7Ozs7O0FDckdYOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sOEJBQU07TUFDbkIsWUFBWSxNQUFNLFFBQVEsZUFBZTtBQUN2QyxhQUFLLE9BQU87QUFDWixhQUFLLFNBQVM7QUFDZCxhQUFLLGdCQUFnQjs7TUFHdkIsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLG1CQUFtQjtBQUNqQixlQUFPLEtBQUs7O01BR2QsZUFBZTtBQUFFLGVBQU8sS0FBSyxLQUFLOztNQUVsQyxnQkFBZ0I7QUFBRSxlQUFPLEtBQUssS0FBSzs7TUFFbkMsb0JBQW9CO0FBQUUsZUFBTyxLQUFLLEtBQUs7O2FBRWhDLHNCQUFzQixtQkFBbUI7QUFDOUMsWUFBSSxnQkFBZ0I7QUFFcEIsWUFBSSxzQkFBc0IsTUFBTTtBQUM5QixnQkFBTSxXQUFXLElBQUEsTUFBQSwrQkFBOEIsb0JBQ3pDLGFBQWEsSUFBQSxNQUFBLGlDQUFnQztBQUVuRCw4QkFBb0IsSUFBQSxNQUFBLHdDQUF1QztBQUUzRCxnQkFBTSxPQUFPLE1BQUEsUUFBSyxhQUFhLFdBQ3pCLFNBQVMsUUFBQSxRQUFPLGVBQWU7QUFFckMsMEJBQWdCLGNBQWMsc0JBQXNCO0FBRXBELDBCQUFnQixJQUFJLGNBQWMsTUFBTSxRQUFROztBQUdsRCxlQUFPOzs7Ozs7QUNqRFg7Ozs7O21DQWlCQSxXQUFBOzs7ZUFBQTs7O0FBZkEsUUFBTSxVQUFVO01BQ2Q7UUFDRSxTQUFXOztNQUViO1FBQ0UsTUFBUTs7TUFFVjtRQUNFLFFBQVU7O01BRVo7UUFDRSxZQUFjOzs7UUFJbEIsV0FBZTs7OztBQ2pCZjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4seUNBQThCLGFBQUEsWUFBVzthQXVCL0MsY0FBYztBQUFFLGVBQU8sYUFBQSxZQUFZLFlBQVk7O2FBRS9DLFVBQVUsT0FBTztBQUFFLGVBQU8sYUFBQSxZQUFZLFVBQVUsa0JBQWlCOzthQUVqRSxZQUFZLFNBQVM7QUFBRSxlQUFPLGFBQUEsWUFBWSxZQUFZLGtCQUFpQjs7O0FBM0JqRTtBQUNOLGtCQURNLGlCQUNOLFdBQVUsU0FBQTtBQUVWLGtCQUhNLGlCQUdOLGtCQUFpQixhQUFBO0FBRWpCLGtCQUxNLGlCQUtOLG1CQUFrQixhQUFBO0FBRWxCLGtCQVBNLGlCQU9OLHlCQUF3QjtBQUV4QixrQkFUTSxpQkFTTiwwQkFBeUI7QUFFekIsa0JBWE0saUJBV04sMEJBQXlCO0FBRXpCLGtCQWJNLGlCQWFOLDhCQUE2QjtBQUU3QixrQkFmTSxpQkFlTixnQ0FBK0I7QUFFL0Isa0JBakJNLGlCQWlCTixpQ0FBZ0M7QUFFaEMsa0JBbkJNLGlCQW1CTixrQ0FBaUM7QUFFakMsa0JBckJNLGlCQXFCTixrQ0FBaUM7Ozs7QUMzQjFDOzs7OzttQ0E4REEsV0FBQTs7O2VBQUE7OztBQTVEQSxRQUFNLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBNERaLFdBQWU7Ozs7QUM5RGY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLDBDQUErQixjQUFBLGFBQVk7YUFHakQsY0FBYztBQUFFLGVBQU8sY0FBQSxhQUFhLFlBQVk7O2FBRWhELFFBQVEsS0FBSztBQUFFLGVBQU8sY0FBQSxhQUFhLFFBQVEsbUJBQWtCOzthQUU3RCxVQUFVLE9BQU87QUFBRSxlQUFPLGNBQUEsYUFBYSxVQUFVLG1CQUFrQjs7O0FBUDdEO0FBQ04sa0JBRE0sa0JBQ04sT0FBTSxLQUFBOzs7O0FDUGY7Ozs7O21DQWdCQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7O0FBSHJCLFFBQU0sa0JBQWtCLE9BQUEsUUFBZ0I7QUFBeEMsUUFDTSxtQkFBbUIsUUFBQSxRQUFpQjtBQUUzQiwyQkFBTTtNQUNuQixZQUFZLE1BQU0sUUFBUSxlQUFlO0FBQ3ZDLGFBQUssT0FBTztBQUNaLGFBQUssU0FBUztBQUNkLGFBQUssZ0JBQWdCOztNQUd2QixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFDVixlQUFPLEtBQUs7O01BR2QsbUJBQW1CO0FBQ2pCLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQUUsZUFBTyxLQUFLLEtBQUs7O01BRWxDLGdCQUFnQjtBQUFFLGVBQU8sS0FBSyxLQUFLOztNQUVuQyxvQkFBb0I7QUFBRSxlQUFPLEtBQUssS0FBSzs7YUFFaEMsbUJBQW1CLGdCQUFnQjtBQUN4QyxjQUFNLFdBQVcsSUFBQSxNQUFBLDRCQUEyQixpQkFDdEMsYUFBYSxJQUFBLE1BQUEsOEJBQTZCLGlCQUMxQyxvQkFBb0IsSUFBQSxNQUFBLHFDQUFvQyxpQkFDeEQsT0FBTyxNQUFBLFFBQUssYUFBYSxXQUN6QixTQUFTLFFBQUEsUUFBTyxlQUFlLGFBQy9CLGdCQUFnQixlQUFBLFFBQWMsc0JBQXNCLG9CQUNwRCxhQUFhLElBQUksV0FBVyxNQUFNLFFBQVE7QUFFaEQsZUFBTzs7YUFHRixxQkFBcUIsa0JBQWtCO0FBQzVDLFlBQUksYUFBYTtBQUVqQixjQUFNLFFBQVEsaUJBQ1IsU0FBUyxrQkFDVCxVQUFVLGtCQUNWLFNBQVMsTUFBTSxTQUFTLFVBQ3hCLE9BQU8sT0FBTyxNQUFNO0FBRTFCLFlBQUksU0FBUyxNQUFNO0FBQ2pCLGdCQUFNLGlCQUFpQixNQUNqQixhQUFhLElBQUEsTUFBQSw4QkFBNkIsaUJBQzFDLG1CQUFtQixXQUFXO0FBRXBDLGNBQUkscUJBQXFCLEdBQUc7QUFDMUIsa0JBQU0sV0FBVyxJQUFBLE1BQUEsNEJBQTJCLGlCQUN0QyxhQUFhLElBQUEsTUFBQSw4QkFBNkIsaUJBQzFDLG9CQUFvQixJQUFBLE1BQUEscUNBQW9DLGlCQUN4RCxPQUFPLE1BQUEsUUFBSyxhQUFhLFdBQ3pCLFNBQVMsUUFBQSxRQUFPLGVBQWUsYUFDL0IsZ0JBQWdCLGVBQUEsUUFBYyxzQkFBc0I7QUFFMUQseUJBQWEsSUFBSSxXQUFXLE1BQU0sUUFBUTs7O0FBSTlDLGVBQU87Ozs7OztBQy9FWDs7Ozs7bUNBVUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsc0JBQXVCLFdBQUE7QUFFaEIsc0JBQU07TUFDbkIsWUFBWSxRQUFRLFVBQVUsV0FBVyxZQUFZLGNBQWMsaUJBQWlCLG1CQUFtQjtBQUNyRyxhQUFLLFNBQVM7QUFDZCxhQUFLLFdBQVc7QUFDaEIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssYUFBYTtBQUNsQixhQUFLLGVBQWU7QUFDcEIsYUFBSyxrQkFBa0I7QUFDdkIsYUFBSyxvQkFBb0I7O01BRzNCLFlBQVk7QUFDVixlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxrQkFBa0I7QUFDaEIsZUFBTyxLQUFLOztNQUdkLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7O01BR2QsdUJBQXVCO0FBQ3JCLGVBQU8sS0FBSzs7TUFHZCxRQUFRLE1BQU0sUUFBUSxHQUFHLGVBQWUsS0FBSyxjQUFjO0FBQ3pELGNBQU0sUUFBUTtBQUVkLGFBQUs7QUFFTCxhQUFLLEtBQUssTUFBTSxPQUFPO0FBRXZCLGFBQUssTUFBTSxPQUFPLE9BQU87QUFFekIsZUFBTzs7TUFHVCxRQUFRO0FBQ04sUUFBQSxJQUFBLE9BQUEsT0FBTSxLQUFLOztNQUdiLEtBQUssTUFBTSxPQUFPLGNBQWM7QUFDOUIsWUFBSSxRQUFRLGNBQWM7QUFDeEI7O0FBR0YsY0FBTSxtQkFBbUIsS0FBSyxrQkFDeEIsc0JBQXNCLENBQUM7QUFFN0IsWUFBSTtBQUVKLFlBQUksa0JBQWtCO0FBQ3BCLGdCQUFNLGVBQWUsTUFDZixRQUFRLEtBQUssWUFDYixPQUFPLGFBQWE7QUFFMUIsa0JBQVEsSUFBQSxPQUFBLFVBQVMsT0FBTyxNQUFNOztBQUdoQyxZQUFJLHFCQUFxQjtBQUN2QixnQkFBTSxrQkFBa0IsTUFDbEIsV0FBVyxnQkFBZ0I7QUFFakMsa0JBQVEsSUFBQSxPQUFBLFVBQVMsS0FBSyxXQUFXLFVBQVU7O0FBRzdDLFlBQUksT0FBTztBQUNULGdCQUFNLG1CQUFtQjtBQUV6QixlQUFLLGtCQUFrQixLQUFLOztBQUc5QixZQUFJLEtBQUssaUJBQWlCO0FBQ3hCLGNBQUkscUJBQXFCO0FBQ3ZCO0FBRUEsa0JBQU0sa0JBQWtCO0FBRXhCLDRCQUFnQixpQkFBaUIsQ0FBQyxjQUFBO0FBQ2hDLG1CQUFLLEtBQUssV0FBVyxPQUFPOzs7OztNQU1wQyxNQUFNLE9BQU8sT0FBTyxjQUFjO0FBQ2hDLGFBQUssT0FBTyxZQUFZLEtBQUs7QUFFN0IsWUFBSSxLQUFLLGFBQWEsTUFBTTtBQUMxQixVQUFBLElBQUEsT0FBQSxNQUFLLE9BQU8sS0FBSztlQUNaO0FBQ0wsZUFBSyxrQkFBa0IsUUFBUSxDQUFDLHFCQUFBO0FBQzlCLGtCQUFNLGtDQUFrQyxpQkFBaUI7QUFFekQsZ0JBQUksaUNBQWlDO0FBQ25DO0FBRUEsb0JBQU0sa0JBQWtCO0FBRXhCLG1CQUFLLFNBQVM7QUFFZCw4QkFBZ0IsaUJBQWlCLENBQUMsY0FBQTtBQUNoQyxxQkFBSyxTQUFTLEtBQUssV0FBVyxPQUFPOztBQUd2QyxtQkFBSyxTQUFTLE1BQU0sT0FBTyxPQUFPOzs7OzthQU1uQyxlQUFlLFlBQVksZUFBZSxVQUFVO0FBQ3pELGNBQU0sU0FBUyxXQUFXLGFBQ3BCLFdBQVcsdUJBQXVCLGFBQ2xDLFlBQVksV0FBVyxnQkFDdkIsYUFBYSxXQUFXLGlCQUN4QixrQkFBa0IsV0FBVyxxQkFDN0Isb0JBQW9CLElBQ3BCLFFBQVEsSUFBSSxNQUFNLFFBQVEsVUFBVSxXQUFXLFlBQVksY0FBYyxpQkFBaUI7QUFFaEcsZUFBTzs7YUFHRixrQkFBa0IsZUFBZTtBQUN0QyxjQUFNLFNBQVMsY0FBYyxhQUN2QixXQUFXLDBCQUEwQixnQkFDckMsWUFBWSxjQUFjLGdCQUMxQixhQUFhLGNBQWMsaUJBQzNCLGVBQWUsVUFDZixrQkFBa0IsY0FBYyxxQkFDaEMsb0JBQW9CLElBQ3BCLFFBQVEsSUFBSSxNQUFNLFFBQVEsVUFBVSxXQUFXLFlBQVksY0FBYyxpQkFBaUI7QUFFaEcsZUFBTzs7YUFHRixxQkFBcUIsa0JBQWtCLGVBQWUsVUFBVTtBQUNyRSxZQUFJLFFBQVE7QUFFWixjQUFNLGFBQWEsWUFBQSxRQUFXLHFCQUFxQjtBQUVuRCxZQUFJLGVBQWUsTUFBTTtBQUN2QixnQkFBTSxTQUFTLFdBQVcsYUFDcEIsV0FBVyx1QkFBdUIsYUFDbEMsWUFBWSxXQUFXLGdCQUN2QixhQUFhLFdBQVcsaUJBQ3hCLGtCQUFrQixXQUFXLHFCQUM3QixvQkFBb0I7QUFFMUIsa0JBQVEsSUFBSSxNQUFNLFFBQVEsVUFBVSxXQUFXLFlBQVksY0FBYyxpQkFBaUI7O0FBRzVGLGVBQU87OztBQUlYLG9DQUFnQyxZQUFVO0FBQ3hDLFVBQUksV0FBVztBQUVmLFlBQU0sZ0JBQWdCLFdBQVc7QUFFakMsVUFBSSxrQkFBa0IsTUFBTTtBQUMxQixjQUFNLFFBQVEsTUFBTSxrQkFBa0I7QUFFdEMsbUJBQVc7O0FBR2IsYUFBTzs7QUFHVCx1Q0FBbUMsZUFBYTtBQUM5QyxVQUFJLFdBQVc7QUFFZixzQkFBZ0IsY0FBYztBQUU5QixVQUFJLGtCQUFrQixNQUFNO0FBQzFCLGNBQU0sUUFBUSxNQUFNLGtCQUFrQjtBQUV0QyxtQkFBVzs7QUFHYixhQUFPOzs7OztBQzdNVDs7Ozs7Ozs7Ozs7OztVQW1CQSxVQUFBO2VBQUE7O1VBZGdCLDBCQUFBO2VBQUE7Ozs7Ozs7Ozs7QUFBVCxxQ0FBaUMsTUFBTSxrQkFBa0IsY0FBWTtBQUMxRSxVQUFJLFFBQVE7QUFFWixZQUFNLGFBQWEsWUFBQSxRQUFXLHFCQUFxQjtBQUVuRCxVQUFJLGVBQWUsTUFBTTtBQUN2QixjQUFNLFFBQVEsT0FBQSxRQUFNLGVBQWUsWUFBWTtBQUUvQyxnQkFBUSxNQUFNLFFBQVE7O0FBR3hCLGFBQU87O1FBR1QsV0FBZTtNQUNiOzs7OztBQ3BCRjs7Ozs7Ozs7Ozs7OztVQUdvQixhQUFBO2VBQUEsWUFBQTs7VUFFQSxrQkFBQTtlQUFBLE9BQUE7O1VBQ0EsbUJBQUE7ZUFBQSxRQUFBOztVQUpBLFFBQUE7ZUFBQSxPQUFBOztVQUVBLGlCQUFBO2VBQUEsUUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0pwQjs7Ozs7Ozs7Ozs7OztVQUlhLGFBQUE7ZUFBQTs7VUFHQSxvQkFBQTtlQUFBOztVQURBLGVBQUE7ZUFBQTs7VUFKQSxPQUFBO2VBQUE7O1VBQ0EsUUFBQTtlQUFBOztVQUVBLGFBQUE7ZUFBQTs7O0FBSE4sUUFBTSxPQUFPO0FBQ2IsUUFBTSxRQUFRO0FBQ2QsUUFBTSxhQUFhO0FBQ25CLFFBQU0sYUFBYTtBQUNuQixRQUFNLGVBQWU7QUFDckIsUUFBTSxvQkFBb0I7Ozs7QUNQakM7Ozs7O21DQVFnQixpQ0FBQTs7O2VBQUE7Ozs7O0FBRmhCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRVgsMkNBQXVDLE9BQU8sTUFBTSxRQUFNO0FBQy9ELFVBQUksVUFBVTtBQUVkLFlBQU0sUUFBUSxNQUFNLFFBQVEsT0FDdEIsY0FBYyxNQUFNO0FBRTFCLFVBQUksY0FBYyxHQUFHO0FBQ25CLGNBQU0sWUFBWSxPQUFNO0FBRXhCLGVBQU87QUFFUCxrQkFBVSx5QkFBeUIsTUFBTTs7QUFHM0MsYUFBTzs7QUFHVCxzQ0FBa0MsTUFBTSxRQUFNO0FBQzVDLFlBQU0sNkJBQTZCLEtBQUssOEJBQThCLFNBQ2hFLDRCQUE0QixLQUFLLDZCQUE2QjtBQUVwRSxVQUFJLFVBQVUsV0FBQTtBQUVkLGVBQVMsUUFBUSw0QkFBNEIsU0FBUywyQkFBMkIsU0FBUztBQUN4RixjQUFNLFFBQVEsT0FBTyxRQUNmLGVBQWUsTUFBTTtBQUUzQixtQkFBVzs7QUFHYixhQUFPOzs7OztBQ3RDVDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7QUFKckIsUUFBTSxpQkFBaUIsWUFBQSxNQUFNLHFCQUFxQjtBQUFsRCxRQUNNLG9CQUFvQixZQUFBLE1BQU0scUJBQXFCO0FBRHJELFFBRU0sc0JBQXNCLFlBQUEsTUFBTSxxQkFBcUI7QUFFeEMsNEJBQU07TUFDbkIsWUFBWSxnQkFBZ0IsY0FBYyxXQUFXO0FBQ25ELGFBQUssaUJBQWlCO0FBQ3RCLGFBQUssZUFBZTtBQUNwQixhQUFLLFlBQVk7O01BR25CLG9CQUFvQjtBQUNsQixlQUFPLEtBQUs7O01BR2Qsa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLGtCQUFrQixjQUFjO0FBQzlCLGNBQU0sVUFBVyxLQUFLLGlCQUFpQjtBQUV2QyxlQUFPOztNQUdULGlCQUFpQixhQUFhO0FBQzVCLGNBQU0sZUFBZSxZQUFZLG1CQUMzQixVQUFVLEtBQUssa0JBQWtCO0FBRXZDLGVBQU87O01BR1Qsa0JBQWtCLGNBQWM7QUFDOUIsY0FBTSxVQUFVLGFBQWEsZ0JBQWdCLENBQUMsZ0JBQUE7QUFDNUMsZ0JBQU0sV0FBVSxLQUFLLGlCQUFpQjtBQUV0QyxjQUFJLFVBQVM7QUFDWCxtQkFBTzs7O0FBSVgsZUFBTzs7TUFHVCxNQUFNLFFBQVE7QUFDWixpQkFBUyxTQUFTLFdBQUE7QUFFbEIsY0FBTSxNQUFNLEdBQUcsU0FBUyxLQUFLLGlCQUFpQixLQUFLLGlCQUFpQixLQUFLOztBQUV6RSxlQUFPOzthQUdGLGtCQUFrQixNQUFNLFFBQVE7QUFDckMsY0FBTSx3QkFBd0IsSUFBQSxTQUFBLCtCQUE4QixxQkFBcUIsTUFBTSxTQUNqRixzQkFBc0IsSUFBQSxTQUFBLCtCQUE4QixtQkFBbUIsTUFBTSxTQUM3RSxtQkFBbUIsSUFBQSxTQUFBLCtCQUE4QixnQkFBZ0IsTUFBTSxTQUN2RSxpQkFBaUIsdUJBQ2pCLGVBQWUscUJBQ2YsWUFBYSxxQkFBcUIsT0FDcEIsV0FBQSxlQUNDLElBQUksb0JBQ25CLGNBQWMsSUFBSSxZQUFZLGdCQUFnQixjQUFjO0FBRWxFLGVBQU87Ozs7OztBQzFFWDs7Ozs7bUNBYUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFKckIsUUFBTSxDQUFFLGlCQUFpQixvQkFBcUIsV0FBQTtBQUU5QyxRQUFNLG1CQUFtQixZQUFBLE1BQU0scUJBQXFCO0FBRXJDLDZCQUFNO01BQ25CLFlBQVksT0FBTztBQUNqQixhQUFLLFFBQVE7O01BR2YsZ0JBQWdCLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxLQUFLOztNQUVuRCwyQkFBMkIsVUFBVTtBQUFFLHdCQUFnQixLQUFLLE9BQU87O01BRW5FLDRCQUE0QixVQUFVO0FBQUUseUJBQWlCLEtBQUssT0FBTzs7TUFFckUsUUFBUSxjQUFjO0FBQ3BCLHFCQUFhLDRCQUE0QixDQUFDLGdCQUFBO0FBQ3hDLGdCQUFNLFVBQVUsWUFBWSxrQkFBa0I7QUFFOUMsY0FBSSxDQUFDLFNBQVM7QUFDWixpQkFBSyxNQUFNLFFBQVE7Ozs7TUFLekIsTUFBTSxXQUFXLFFBQVE7QUFDdkIsY0FBTSxrQkFBa0IsS0FBSyxNQUFNLE9BQU8sQ0FBQyxrQkFBaUIsZ0JBQUE7QUFDcEQsZ0JBQU0saUJBQWlCLFlBQVksTUFBTTtBQUV6Qyw4QkFBbUI7QUFFbkIsaUJBQU87V0FDTixXQUFBLGVBQ0gsTUFBTyxjQUFjLE9BQ2Isa0JBQ0UsR0FBRyxVQUFVO0VBQy9CLGtCQUFrQjs7O0FBSWhCLGVBQU87O2FBR0Ysa0JBQWtCLE1BQU0sUUFBUTtBQUNyQyxjQUFNLG1CQUFtQixpQkFBaUIsUUFBUSxPQUM1QyxRQUFRLGlCQUFpQixJQUFJLENBQUMsb0JBQUE7QUFDNUIsZ0JBQU0sUUFBTyxpQkFDUCxjQUFjLGFBQUEsUUFBWSxrQkFBa0IsT0FBTTtBQUV4RCxpQkFBTztZQUVULGVBQWUsSUFBSSxhQUFhO0FBRXRDLGVBQU87Ozs7OztBQzlEWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxpQkFBaUIsWUFBQSxNQUFNLHFCQUFxQjtBQUVuQyx3QkFBTTtNQUNuQixZQUFZLFdBQVcsY0FBYztBQUNuQyxhQUFLLFlBQVk7QUFDakIsYUFBSyxlQUFlOztNQUd0QixlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLGtCQUFrQjtBQUNoQixlQUFPLEtBQUs7O01BR2QsUUFBUSxTQUFTO0FBQ2YsY0FBTSxlQUFlLFFBQVE7QUFFN0IsYUFBSyxhQUFhLFFBQVE7O01BRzVCLG9CQUFvQixVQUFVO0FBQzVCLGNBQU0sa0JBQWtCLFNBQVMsS0FBSyxDQUFDLFlBQUE7QUFDckMsZ0JBQU0sWUFBWSxRQUFRLGdCQUNwQixpQkFBa0IsY0FBYyxLQUFLLFdBQ3JDLGdCQUFnQjtBQUV0QixjQUFJLGVBQWU7QUFDakIsbUJBQU87O2NBRUw7QUFFTixlQUFPOztNQUdULE1BQU0sV0FBVyxRQUFRO0FBQ3ZCLFlBQUksTUFBTSxXQUFBO0FBRVYsY0FBTSxrQkFBa0IsS0FBSyxhQUFhLE1BQU0sTUFBTTtBQUV0RCxZQUFJLG9CQUFvQixXQUFBLGNBQWM7QUFDbkMsZ0JBQU0sR0FBRyxVQUFVLFlBQVksS0FBSztFQUN6QyxrQkFBa0I7Ozs7QUFLaEIsZUFBTzs7YUFHRixrQkFBa0IsTUFBTSxRQUFRO0FBQ3JDLGNBQU0sWUFBWSwyQkFBMkIsTUFBTSxTQUM3QyxlQUFlLGNBQUEsUUFBYSxrQkFBa0IsTUFBTSxTQUNwRCxVQUFVLElBQUksUUFBUSxXQUFXO0FBRXZDLGVBQU87OztBQUlYLHdDQUFvQyxNQUFNLFFBQU07QUFDOUMsWUFBTSx1QkFBdUIsSUFBQSxTQUFBLCtCQUE4QixnQkFBZ0IsTUFBTSxTQUMzRSxZQUFZLEdBQUc7QUFFckIsYUFBTzs7Ozs7QUN6RVQ7Ozs7O21DQVVBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxlQUFlLFlBQUEsTUFBTSxxQkFBcUI7QUFFakMseUJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixRQUFRLFVBQVU7QUFDaEIsaUJBQVMsUUFBUSxDQUFDLFlBQUE7QUFDaEIsZ0JBQU0sa0JBQWtCLFFBQVEsb0JBQW9CLEtBQUs7QUFFeEQsOEJBQW9CLE9BQ25CLEtBQUssTUFBTSxRQUFRLFdBQ2pCLGdCQUFnQixRQUFROzs7TUFJaEMsUUFBUSxVQUFVO0FBQ2hCLGFBQUssTUFBTSxRQUFROztNQUdyQixNQUFNLFdBQVcsUUFBUTtBQUN2QixjQUFNLE1BQU0sS0FBSyxNQUFNLE9BQU8sQ0FBQyxNQUFLLFlBQUE7QUFDbEMsZ0JBQU0sYUFBYSxRQUFRLE1BQU0sV0FBVztBQUU1QyxrQkFBTztBQUVQLGlCQUFPO1dBQ04sV0FBQTtBQUVILGVBQU87O2FBR0Ysa0JBQWtCLE1BQU0sUUFBUTtBQUNyQyxjQUFNLGVBQWUsYUFBYSxRQUFRLE9BQ3BDLFFBQVEsYUFBYSxJQUFJLENBQUMsZ0JBQUE7QUFDeEIsZ0JBQU0sUUFBTyxhQUNQLFVBQVUsU0FBQSxRQUFRLGtCQUFrQixPQUFNO0FBRWhELGlCQUFPO1lBRVQsV0FBVyxJQUFJLFNBQVM7QUFFOUIsZUFBTzs7Ozs7O0FDbkRYOzs7OzttQ0FJZ0IsUUFBQTs7O2VBQUE7Ozs7QUFBVCxrQkFBYyxRQUFNO0FBQ3pCLGVBQVMsT0FBTyxRQUFRLFlBQVksV0FBQTtBQUVwQyxhQUFPOzs7OztBQ1BUOzs7OzttQ0FhQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0sZUFBZSxZQUFBLE1BQU0scUJBQXFCO0FBRWpDLHNCQUFNO01BQ25CLFlBQVksY0FBYyxVQUFVLFNBQVM7QUFDM0MsYUFBSyxlQUFlO0FBQ3BCLGFBQUssV0FBVztBQUNoQixhQUFLLFVBQVU7O01BR2pCLGtCQUFrQjtBQUNoQixlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOztNQUdkLE1BQU0sV0FBVyxRQUFRO0FBQ3ZCLGlCQUFTLFNBQVMsV0FBQTtBQUVsQixZQUFJLE1BQU0sV0FBQTtBQUVWLGNBQU0sY0FBYyxLQUFLLFNBQVMsTUFBTSxXQUFXLFNBQzdDLGtCQUFrQixLQUFLLGFBQWEsTUFBTSxXQUFXO0FBRTNELFlBQUksMEJBQTBCLEdBQUcsa0JBQWtCO0FBRW5ELFlBQUksNEJBQTRCLFdBQUEsY0FBYztBQUM1QyxvQ0FBMEIsSUFBQSxRQUFBLE1BQUs7QUFFL0IsZ0JBQU0sVUFBVSxLQUFLO0VBQ3pCOzs7O0FBS0UsZUFBTzs7YUFHRixrQkFBa0IsTUFBTSxRQUFRO0FBQ3JDLGNBQU0sZUFBZSxjQUFBLFFBQWEsa0JBQWtCLE1BQU0sU0FDcEQsV0FBVyxVQUFBLFFBQVMsa0JBQWtCLE1BQU0sU0FDNUMsVUFBVSx5QkFBeUIsTUFBTSxTQUN6QyxRQUFRLElBQUksTUFBTSxjQUFjLFVBQVU7QUFFaEQsZUFBTzs7O0FBSVgsc0NBQWtDLE1BQU0sUUFBTTtBQUM1QyxZQUFNLHFCQUFxQixJQUFBLFNBQUEsK0JBQThCLGNBQWMsTUFBTSxTQUN2RSxVQUFVLEdBQUc7QUFFbkIsYUFBTzs7Ozs7QUNwRVQ7Ozs7O21DQVVBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxhQUFhLFlBQUEsTUFBTSxxQkFBcUI7QUFFL0IsdUJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixRQUFRLFFBQVE7QUFDZCxlQUFPLFFBQVEsQ0FBQyxVQUFBO0FBQ2QsZUFBSyxNQUFNLFFBQVE7OztNQUl2QixRQUFRLFVBQVU7QUFDaEIsYUFBSyxNQUFNLFFBQVE7O01BR3JCLE1BQU0sV0FBVyxRQUFRO0FBQ3ZCLGNBQU0sTUFBTSxLQUFLLE1BQU0sT0FBTyxDQUFDLE1BQUssVUFBQTtBQUNsQyxnQkFBTSxXQUFXLE1BQU0sTUFBTSxXQUFXO0FBRXhDLGtCQUFPO0FBRVAsaUJBQU87V0FDTixXQUFBO0FBRUgsZUFBTzs7YUFHRixrQkFBa0IsTUFBTSxRQUFRO0FBQ3JDLGNBQU0sYUFBYSxXQUFXLFFBQVEsT0FDaEMsUUFBUSxXQUFXLElBQUksQ0FBQyxjQUFBO0FBQ3RCLGdCQUFNLFFBQU8sV0FDUCxRQUFRLE9BQUEsUUFBTSxrQkFBa0IsT0FBTTtBQUU1QyxpQkFBTztZQUVULFNBQVMsSUFBSSxPQUFPO0FBRTFCLGVBQU87Ozs7OztBQy9DWDs7Ozs7bUNBY0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7QUFMckIsUUFBTSxrQkFBa0IsWUFBQSxNQUFNLHFCQUFxQjtBQUFuRCxRQUNNLG1CQUFtQixZQUFBLE1BQU0scUJBQXFCO0FBRXBELFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRUgseUJBQU07TUFDbkIsWUFBWSxZQUFZLGFBQWE7QUFDbkMsYUFBSyxhQUFhO0FBQ2xCLGFBQUssY0FBYzs7TUFHckIsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLOztNQUdkLGlCQUFpQjtBQUNmLGVBQU8sS0FBSzs7TUFHZCxNQUFNLFFBQVE7QUFDWixjQUFNLGlCQUFpQixLQUFLLFlBQVksTUFBTSxTQUN4QyxNQUFNLEdBQUcsU0FBUyxLQUFLO0VBQy9CLGlCQUFpQjs7QUFFZixlQUFPOzthQUdGLGtCQUFrQixNQUFNLFFBQVE7QUFDckMsY0FBTSxvQkFBb0IsSUFBQSxTQUFBLCtCQUE4QixpQkFBaUIsTUFBTSxTQUN6RSxhQUFhLG1CQUNiLG1CQUFtQixpQkFBaUIsUUFBUSxPQUM1Qyx1QkFBdUIsT0FBTSxtQkFDN0Isa0JBQWtCO0FBRXhCLGVBQU87QUFFUCxjQUFNLGNBQWMsYUFBQSxRQUFZLGtCQUFrQixNQUFNLFNBQ2xELFdBQVcsSUFBSSxTQUFTLFlBQVk7QUFFMUMsZUFBTzs7Ozs7O0FDaERYOzs7OzttQ0FZQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUhyQixRQUFNLGdCQUFnQixZQUFBLE1BQU0scUJBQXFCO0FBQWpELFFBQ00sa0JBQWtCLFlBQUEsTUFBTSxxQkFBcUI7QUFFcEMsMEJBQU07TUFDbkIsWUFBWSxPQUFPLFlBQVk7QUFDN0IsYUFBSyxRQUFRO0FBQ2IsYUFBSyxhQUFhOztNQUdwQixnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsTUFBTSxRQUFRO0FBQ1osaUJBQVMsU0FBUyxXQUFBO0FBRWxCLGNBQU0sZUFBZSxLQUFLLE1BQU0sT0FBTyxDQUFDLGVBQWMsYUFBQTtBQUM5QyxnQkFBTSxjQUFjLFNBQVMsTUFBTTtBQUVuQywyQkFBZ0I7QUFFaEIsaUJBQU87V0FDTixXQUFBLGVBQ0gsTUFBTSxjQUFjLEtBQUs7RUFDakM7OztBQUlFLGVBQU87O2FBR0Ysa0JBQWtCLE1BQU0sUUFBUTtBQUNyQyxjQUFNLGdCQUFnQixjQUFjLFFBQVEsT0FDdEMsUUFBUSxjQUFjLElBQUksQ0FBQyxpQkFBQTtBQUN6QixnQkFBTSxRQUFPLGNBQ1AsV0FBVyxVQUFBLFFBQVMsa0JBQWtCLE9BQU07QUFFbEQsaUJBQU87WUFFVCxvQkFBb0IsSUFBQSxTQUFBLCtCQUE4QixpQkFBaUIsTUFBTSxTQUN6RSxhQUFhLG1CQUNiLFlBQVksSUFBSSxVQUFVLE9BQU87QUFFdkMsZUFBTzs7Ozs7O0FDcERYOzs7OzttQ0FVQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBRnJCLFFBQU0saUJBQWlCLFlBQUEsTUFBTSxxQkFBcUI7QUFFbkMsMkJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixRQUFRLFlBQVk7O01BSXBCLFFBQVEsVUFBVTtBQUNoQixhQUFLLE1BQU0sUUFBUTs7TUFHckIsTUFBTSxXQUFXLFFBQVE7QUFDdkIsY0FBTSxNQUFNLEtBQUssTUFBTSxPQUFPLENBQUMsTUFBSyxjQUFBO0FBQ2xDLGdCQUFNLGVBQWUsVUFBVSxNQUFNO0FBRXJDLGtCQUFPO0FBRVAsaUJBQU87V0FDTixXQUFBO0FBRUgsZUFBTzs7YUFHRixrQkFBa0IsTUFBTSxRQUFRO0FBQ3JDLGNBQU0saUJBQWlCLGVBQWUsUUFBUSxPQUN4QyxRQUFRLGVBQWUsSUFBSSxDQUFDLGtCQUFBO0FBQzFCLGdCQUFNLFFBQU8sZUFDUCxZQUFZLFdBQUEsUUFBVSxrQkFBa0IsT0FBTTtBQUVwRCxpQkFBTztZQUVULGFBQWEsSUFBSSxXQUFXO0FBRWxDLGVBQU87Ozs7OztBQzdDWDs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7O0FBQU4sc0JBQU07TUFDbkIsWUFBWSxjQUFjLFlBQVksVUFBVSxRQUFRO0FBQ3RELGFBQUssZUFBZTtBQUNwQixhQUFLLGFBQWE7QUFDbEIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssU0FBUzs7TUFHaEIsa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLFFBQVEsWUFBWTtBQUNsQixjQUFNLGVBQWUsV0FBVyxtQkFDMUIsYUFBYSxXQUFXLGlCQUN4QixXQUFXLFdBQVcsZUFDdEIsU0FBUyxXQUFXO0FBRTFCLGFBQUssUUFBUSxjQUFjLFlBQVksVUFBVTs7TUFHbkQsUUFBUSxjQUFjLFlBQVksVUFBVSxRQUFRO0FBQ2xELGFBQUssYUFBYSxRQUFRO0FBQzFCLGFBQUssV0FBVyxRQUFRO0FBQ3hCLGFBQUssU0FBUyxRQUFRO0FBQ3RCLGFBQUssT0FBTyxRQUFROztNQUd0QixNQUFNLFdBQVc7QUFDZixjQUFNLFNBQVMsV0FBQSxjQUNULGtCQUFrQixLQUFLLGFBQWEsTUFBTSxXQUFXLFNBQ3JELGdCQUFnQixLQUFLLFdBQVcsTUFBTSxXQUFXLFNBQ2pELGNBQWMsS0FBSyxTQUFTLE1BQU0sV0FBVyxTQUM3QyxZQUFZLEtBQUssT0FBTyxNQUFNLFdBQVcsU0FDekMsTUFBTSxHQUFHLGtCQUFrQixnQkFBZ0IsY0FBYztBQUUvRCxlQUFPOzthQUdGLGtCQUFrQixNQUFNLFFBQVE7QUFDckMsY0FBTSxlQUFlLGNBQUEsUUFBYSxrQkFBa0IsTUFBTSxTQUNwRCxhQUFhLFlBQUEsUUFBVyxrQkFBa0IsTUFBTSxTQUNoRCxXQUFXLFVBQUEsUUFBUyxrQkFBa0IsTUFBTSxTQUM1QyxTQUFTLFFBQUEsUUFBTyxrQkFBa0IsTUFBTSxTQUN4QyxRQUFRLElBQUksTUFBTSxjQUFjLFlBQVksVUFBVTtBQUU1RCxlQUFPOzs7Ozs7QUNuRVg7Ozs7O21DQW9FQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7O0FBNURBLFFBQU0sV0FBVyxPQUFBLFFBQVM7QUFBMUIsUUFDTSxZQUFZLFFBQUEsUUFBVTtBQUU1QixRQUFJLENBQUMsV0FBVyxVQUFVO0FBQ3hCLGlCQUFXLFdBQVc7O0FBR3hCLFFBQU0sQ0FBRSxZQUFhO0FBRXJCLHlCQUFxQixPQUFLO0FBQ3hCLFlBQU0saUJBQWlCLFNBQVMsY0FBYyxXQUFBLE9BQ3hDLGtCQUFrQixTQUFTLGNBQWMsV0FBQSxRQUN6QyxZQUFZO0VBQ2xCOztBQUdBLGFBQU8sT0FBTyxpQkFBaUI7UUFDN0I7O0FBR0YscUJBQWUsWUFBWTtBQUUzQixhQUFPOztBQUdULDRCQUFTO0FBQ1AsWUFBTSxZQUFZLHFCQUNaLFFBQVE7QUFFZCxrQkFBWTs7QUFHZCwyQkFBdUIsTUFBTSxXQUFXLGFBQWEsTUFBSTtBQUN2RCxZQUFNLFVBQVUsS0FBSyxTQUNmLFVBQVUsUUFBUSxPQUFPLENBQUMsVUFBUyxRQUFRLFVBQUE7QUFDekMsY0FBTSxNQUFNLEtBQUssVUFBVTtBQUUzQixtQkFBVyxRQUFRLE9BQ1AsR0FBRyxXQUFVLFdBQ1gsR0FBRyxXQUFVLFNBQVM7QUFFcEMsZUFBTztTQUNOLFdBQUEsZUFDSCxTQUFTLFNBQVMsU0FBUyxVQUMzQixPQUFPLFVBQVUsTUFBTSxTQUN2QixRQUFRLE9BQUEsUUFBTSxrQkFBa0IsTUFBTTtBQUU1QyxVQUFJLGVBQWUsTUFBTTtBQUN2QixjQUFNLFFBQVE7O0FBR2hCLGVBQVMsYUFBYTs7QUFHeEIsMkJBQXVCLFdBQVM7QUFDOUIsWUFBTSxRQUFRLFNBQVMsY0FBYztBQUVyQyxhQUFPOztRQUdULFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTs7QUFHRixpQ0FBUztBQUNQLFlBQU0sYUFBYSxPQUFPLEtBQUssV0FDekIsWUFBWSxXQUFXLE9BQU8sQ0FBQyxZQUFXLGNBQUE7QUFDeEMsY0FBTSxRQUFRLGNBQWMsWUFDdEIsV0FBVyxNQUFNLE1BQU07QUFFN0Isc0JBQWE7QUFFYixlQUFPO1NBQ04sV0FBQTtBQUVULGFBQU87Ozs7O0FDdEZUOzs7Ozs7Ozs7Ozs7O1VBcUNBLFVBQUE7ZUFBQTs7VUEzQmdCLG9CQUFBO2VBQUE7O1VBcUJBLG9CQUFBO2VBQUE7Ozs7QUEzQmhCLFFBQU0sU0FBUyxXQUFBO0FBQWYsUUFDTSxhQUFhLFdBQUE7QUFEbkIsUUFFTSxtQkFBbUIsV0FBVztBQUVwQyxRQUFNLGFBQWE7QUFFWixpQ0FBUztBQUNkLFVBQUksWUFBWSxXQUFBO0FBRWhCLGVBQVMsUUFBUSxHQUFHLFFBQVEsUUFBUSxTQUFTO0FBQzNDLGNBQU0sUUFBUSxLQUFLLE1BQU0sS0FBSyxXQUFXLG1CQUNuQyxZQUFZLFdBQVc7QUFFN0IscUJBQWE7O0FBR2YsWUFBTSw4QkFBOEIsV0FBVyxTQUFTO0FBRXhELFVBQUksQ0FBQyw2QkFBNkI7QUFDaEMsbUJBQVcsS0FBSzthQUNYO0FBQ0wsb0JBQVk7O0FBR2QsYUFBTzs7QUFHRiwrQkFBMkIsU0FBTztBQUN2QyxZQUFNLENBQUUsYUFBYyxRQUFRLGlCQUFpQixRQUFRLGVBQWU7QUFFdEUsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTs7Ozs7QUN2Q0Y7Ozs7Ozs7Ozs7Ozs7VUFHb0IsV0FBQTtlQUFBLE9BQUE7O1VBQ0EsWUFBQTtlQUFBLFFBQUE7O1VBRUEscUJBQUE7ZUFBQSxXQUFBOztVQURBLGtCQUFBO2VBQUEsUUFBQTs7VUFIQSxXQUFBO2VBQUEsVUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZwQjs7Ozs7bUNBSWdCLFdBQUE7OztlQUFBOzs7O0FBQVQscUJBQWlCLFVBQVE7QUFBSSxhQUFPLGFBQWEsVUFBVSxNQUFBOztBQUVsRSwwQkFBc0IsVUFBVSxPQUFLO0FBQ25DLFlBQU0sYUFBYyxTQUFTLHFCQUFxQjtBQUVsRCxhQUFPOzs7OztBQ1RUOzs7OzttQ0FFYSxjQUFBOzs7ZUFBQTs7O0FBQU4sUUFBTSxhQUFhOzs7O0FDRjFCOzs7OzttQ0EyREEsV0FBQTs7O2VBQUE7Ozs7Ozs7QUFuREEsUUFBTSxDQUFFLHFCQUFzQixXQUFBO0FBQTlCLFFBQ00sQ0FBRSxhQUFhLGNBQWMsZUFBZSxpQkFBa0IsV0FBQTtBQUVwRSx1QkFBbUIsaUJBQWU7QUFDaEMsYUFBTyxXQUFBO0FBQ0wsY0FBTSxPQUFPO2FBQUs7O0FBRWxCLFlBQUksQ0FBRSxZQUFZLFFBQVM7QUFFM0IsY0FBTSxhQUFhLGNBQWM7QUFFakMsb0JBQVk7QUFFWixzQkFBYyxNQUFNLFdBQVc7QUFFL0IsY0FBTSx1QkFBdUIsSUFBQSxPQUFBLFNBQVE7QUFFckMsWUFBSSxzQkFBc0I7QUFDeEIsZ0JBQU0sUUFBUTtBQUVkLDRCQUFrQixjQUFjLE1BQUE7bUJBQ3ZCLFVBQVUsUUFBUSxlQUFlLG9CQUFvQjtBQUMxRCwyQkFBYSw0QkFBNEIsV0FBVztBQUVwRCxxQkFBTyxNQUFNLFVBQVUsUUFBUSxZQUFBLEdBQWU7OztlQUk3QztBQUNMLGdCQUFNLFlBQVc7QUFFakIsNEJBQWtCLENBQUMsZUFBQTtBQUNqQix5QkFBYSw0QkFBNEIsV0FBVztBQUVwRCxtQkFBTyxVQUFTOzs7QUFJcEIsZUFBTyxPQUFPLGlCQUFpQjtVQUM3Qjs7QUFHRixlQUFPOzs7QUFJWCxXQUFPLE9BQU8sV0FBVztNQUN2QjtNQUNBOztRQUdGLFdBQWU7QUFFZixlQUFBLFNBQVMsUUFBUSxDQUFDLFlBQUE7QUFDaEIsYUFBTyxlQUFlLFdBQVcsU0FBUztRQUN4QyxLQUFLLE1BQU0sV0FBQTtBQUNULGdCQUFNLE9BQU87ZUFBSTthQUNYLFlBQVk7QUFFbEIsd0JBQWMsTUFBTTtBQUVwQixnQkFBTSxZQUFXLENBQUMsZUFBQTtBQUNoQix5QkFBYSw0QkFBNEIsV0FBVztBQUVwRCxtQkFBTyxNQUFBLE1BQU0sY0FBYyxTQUFTOztBQUd0QyxpQkFBTyxPQUFPLFdBQVU7WUFDdEI7O0FBR0YsaUJBQU87Ozs7QUFLYix5Q0FBcUMsV0FBVyxZQUFVO0FBQ3hELG1CQUFhLFdBQVcsZUFBZSxXQUFBLGNBQWMsYUFBYTtXQUFLO1FBQVk7O0FBRW5GLGFBQU87Ozs7O0FDdkZUOzs7OzttQ0FJQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7O1FBQUEsV0FBZSxXQUFBOzs7O0FDSmY7Ozs7O21DQUVhLFVBQUE7OztlQUFBOzs7QUFBTixRQUFNLFNBQVM7Ozs7QUNGdEI7Ozs7Ozs7Ozs7Ozs7VUFFYSxjQUFBO2VBQUE7O1VBRUEsb0JBQUE7ZUFBQTs7VUFEQSxpQkFBQTtlQUFBOztVQUVBLG9CQUFBO2VBQUE7OztBQUhOLFFBQU0sY0FBYztBQUNwQixRQUFNLGlCQUFpQjtBQUN2QixRQUFNLG9CQUFvQjtBQUMxQixRQUFNLG9CQUFvQjs7OztBQ0xqQzs7Ozs7Ozs7Ozs7OztVQVdnQixhQUFBO2VBQUE7O1VBc0JBLHFCQUFBO2VBQUE7O1VBTWhCLFVBQUE7ZUFBQTs7VUFsQmdCLGdCQUFBO2VBQUE7O1VBSkEsY0FBQTtlQUFBOztVQVVBLGtCQUFBO2VBQUE7Ozs7OztBQXBCaEIsUUFBTSxPQUFPLElBQUksTUFBQTtBQUVqQixRQUFJO0FBRUcsMEJBQVM7QUFDZCxZQUFNLFNBQVMsU0FBQTtBQUVmLG1CQUFhOztBQUdSLDJCQUFTO0FBQ2QsZ0JBQVU7O0FBR0wsNkJBQVM7QUFDZCxZQUFNLFNBQVMsU0FBQTtBQUVmLG1CQUFhOztBQUdSLCtCQUFTO0FBQ2QsWUFBTSxTQUFTLFNBQUE7QUFFZixtQkFBYTs7QUFHUixrQ0FBUztBQUNkLFlBQU0sU0FBUyxTQUFBO0FBRWYsbUJBQWE7O1FBR2YsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7O0FBR0YsdUJBQW1CLFFBQU07QUFDdkIsWUFBTSxNQUFNO1FBQ1Y7O0FBR0YsV0FBSyxJQUFJOztBQUdYLDBCQUFzQixRQUFNO0FBQzFCLFlBQU0sZ0JBQWdCO0FBRXRCLFVBQUksa0JBQWtCLFFBQVE7QUFDNUIseUJBQWlCO0FBRWpCLGtCQUFVOzs7QUFJZCxnQ0FBUztBQUNQLFlBQU0sZ0JBQWdCLEtBQUssSUFBSSxXQUFBLFdBQVcsU0FBQTtBQUUxQyxhQUFPOzs7OztBQ3BFVDs7Ozs7bUNBY0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7QUFSQSwrQkFBcUIsTUFBQSxRQUFPOztBQUNuQixrQkFEVCxRQUNTLFdBQVU7QUFFVixrQkFIVCxRQUdTLHFCQUFvQjtNQUN6QixXQUFXOztRQUlmLFdBQWUsSUFBQSxlQUFBLFNBQVU7Ozs7Ozs7OztBQ2R6Qjs7Ozs7bUNBY0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7QUFSQSxnQ0FBc0IsTUFBQSxRQUFPOztBQUNwQixrQkFEVCxTQUNTLFdBQVU7QUFFVixrQkFIVCxTQUdTLHFCQUFvQjtNQUN6QixXQUFXOztRQUlmLFdBQWUsSUFBQSxlQUFBLFNBQVU7Ozs7Ozs7Ozs7QUNkekI7Ozs7O21DQWNBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7O0FBUkEsa0NBQXdCLE1BQUEsUUFBTzs7QUFDdEIsa0JBRFQsV0FDUyxXQUFVO0FBRVYsa0JBSFQsV0FHUyxxQkFBb0I7TUFDekIsV0FBVzs7UUFJZixXQUFlLElBQUEsZUFBQSxTQUFVOzs7Ozs7Ozs7QUNkekI7Ozs7O21DQWNBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7O0FBUkEsbUNBQXlCLE1BQUEsUUFBTzs7QUFDdkIsa0JBRFQsWUFDUyxXQUFVO0FBRVYsa0JBSFQsWUFHUyxxQkFBb0I7TUFDekIsV0FBVzs7UUFJZixXQUFlLElBQUEsZUFBQSxTQUFVOzs7Ozs7Ozs7O0FDZHpCOzs7OzttQ0FFYSx3QkFBQTs7O2VBQUE7OztBQUFOLFFBQU0sdUJBQXVCOzs7O0FDRnBDOzs7OzttQ0FFZ0Isc0NBQUE7OztlQUFBOzs7QUFBVCxnREFBNEMsYUFBYSxhQUFXO0FBQ3pFLFlBQU0sWUFBWSxZQUFZLGdCQUN4QixhQUFhLFlBQVksaUJBQ3pCLDhCQUE4QixXQUFXLFNBQVMsWUFDbEQsZ0NBQWdDLENBQUM7QUFFdkMsYUFBTzs7Ozs7QUNSVDs7Ozs7Ozs7Ozs7OztVQVNnQixxQkFBQTtlQUFBOztVQVBBLG9CQUFBO2VBQUE7OztBQUFULCtCQUEyQixPQUFLO0FBQ3JDLFlBQU0sQ0FBRSxTQUFVLE9BQ1osV0FBVztBQUVqQixhQUFPOztBQUdGLGdDQUE0QixPQUFLO0FBQ3RDLFlBQU0sQ0FBRSxTQUFVLE9BQ1osWUFBWTtBQUVsQixhQUFPOzs7OztBQ2JUOzs7Ozs7Ozs7Ozs7O1VBRWEseUJBQUE7ZUFBQTs7VUFFQSw2QkFBQTtlQUFBOztVQUNBLDhCQUFBO2VBQUE7O1VBRkEseUJBQUE7ZUFBQTs7VUFJQSwrQkFBQTtlQUFBOztVQURBLDhCQUFBO2VBQUE7O1VBR2IsVUFBQTtlQUFBOzs7QUFQTyxRQUFNLHlCQUF5QjtBQUMvQixRQUFNLHlCQUF5QjtBQUMvQixRQUFNLDZCQUE2QjtBQUNuQyxRQUFNLDhCQUE4QjtBQUNwQyxRQUFNLDhCQUE4QjtBQUNwQyxRQUFNLCtCQUErQjtRQUU1QyxXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQ2ZGOzs7OzttQ0FtVEEsV0FBQTs7O2VBQUE7Ozs7Ozs7OztBQXpTQSxRQUFNLENBQUUsbUJBQW9CLFdBQUE7QUFBNUIsUUFDTSxDQUFFLHFCQUFzQixNQUFBO0FBRTlCLCtCQUFTO0FBQ1AsWUFBTSxDQUFFLGVBQWdCO0FBRXhCLGFBQU87O0FBR1QsNEJBQXdCLGFBQVc7QUFDakMsYUFBTyxPQUFPLFlBQVk7UUFDeEI7OztBQUlKLGdDQUFTO0FBQ1AsWUFBTSxjQUFjO0FBRXBCLHFCQUFlOztBQUdqQixXQUFPLE9BQU8sWUFBWTtNQUN4QjtNQUNBO01BQ0E7O0FBR0Y7QUFFQSwwQkFBUztBQUNQLFlBQU0sVUFBVSxNQUNWLFlBQVksTUFDWixhQUFhLE1BQ2IsY0FBYyxNQUNkLGdCQUFnQixNQUNoQixpQkFBaUI7QUFFdkIsV0FBSyxZQUFZLGtCQUFrQjtBQUVuQyxXQUFLLFlBQVk7UUFDZjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7OztBQUlKLDJCQUFTO0FBQ1AsWUFBTSxjQUFjO0FBRXBCLFdBQUssWUFBWTtRQUNmOztBQUdGLFdBQUssYUFBYSxrQkFBa0I7O0FBR3RDLDBCQUFzQixtQkFBbUIsU0FBTztBQUM5QyxZQUFNLGtCQUFrQixrQkFBQSx3QkFDbEIsZ0JBQWdCO0FBRXRCLFdBQUssY0FBYyxpQkFBaUIsZUFBZTs7QUFHckQsMkJBQXVCLG1CQUFtQixTQUFPO0FBQy9DLFlBQU0sa0JBQWtCLGtCQUFBLHdCQUNsQixnQkFBZ0I7QUFFdEIsV0FBSyxlQUFlLGlCQUFpQixlQUFlOztBQUd0RCw4QkFBMEIsdUJBQXVCLFNBQU87QUFDdEQsWUFBTSxrQkFBa0Isa0JBQUEsNkJBQ2xCLGdCQUFnQjtBQUV0QixXQUFLLGNBQWMsaUJBQWlCLGVBQWU7O0FBR3JELCtCQUEyQix1QkFBdUIsU0FBTztBQUN2RCxZQUFNLGtCQUFrQixrQkFBQSw2QkFDbEIsZ0JBQWdCO0FBRXRCLFdBQUssZUFBZSxpQkFBaUIsZUFBZTs7QUFHdEQsK0JBQTJCLHdCQUF3QixTQUFPO0FBQ3hELFlBQU0sa0JBQWtCLGtCQUFBLDhCQUNsQixnQkFBZ0I7QUFFdEIsV0FBSyxjQUFjLGlCQUFpQixlQUFlOztBQUdyRCxnQ0FBNEIsd0JBQXdCLFNBQU87QUFDekQsWUFBTSxrQkFBa0Isa0JBQUEsOEJBQ2xCLGdCQUFnQjtBQUV0QixXQUFLLGVBQWUsaUJBQWlCLGVBQWU7O0FBR3RELDZCQUFTO0FBQ1AsWUFBTSxDQUFFLGNBQWMsU0FBVSxLQUFLO0FBRXJDLGFBQU87O0FBR1QsMEJBQVM7QUFDUCxZQUFNLFdBQVcsS0FBSyxTQUFTO0FBRS9CLGFBQU87O0FBR1QsdUJBQW1CLE9BQU8sU0FBUyxVQUFVLFdBQVM7QUFDcEQsWUFBTSxTQUFTLEtBQUssYUFDZCxZQUFZLE9BQU8sVUFDbkIsYUFBYSxPQUFPLFdBQ3BCLGNBQWMsT0FBTyxZQUNyQixlQUFlLE9BQU8sYUFDdEIsY0FBYyxjQUFjLFlBQzVCLGVBQWUsZUFBZSxXQUM5QixZQUFZLEtBQUssTUFBTSxlQUFlLElBQ3RDLGFBQWEsS0FBSyxNQUFNLGNBQWMsSUFDdEMsY0FBYyxNQUNkLGdCQUFnQixVQUNoQixpQkFBaUIsV0FDakIsa0JBQWtCLGtCQUFBO0FBRXhCLFlBQUEsT0FBTyxVQUFVLGdCQUFnQjtBQUVqQyxZQUFBLE9BQU8sWUFBWSxrQkFBa0I7QUFFckMsV0FBSyxTQUFTO0FBRWQscUJBQWU7QUFFZixXQUFLLGFBQWE7QUFFbEIsV0FBSyxjQUFjO0FBRW5CLFdBQUssaUJBQWlCO0FBRXRCLFdBQUssa0JBQWtCO0FBRXZCLFdBQUssbUJBQW1CLGlCQUFpQixPQUFPO0FBRWhELFdBQUssS0FBSyxPQUFPLFNBQVMsVUFBVTs7QUFHdEMsc0JBQWtCLE9BQU8sU0FBUyxTQUFPO0FBQ3ZDLFlBQU0sY0FBYyxrQkFDZCxrQkFBa0Isa0JBQUE7QUFFeEIsV0FBSyxZQUFZO0FBRWpCLFlBQUEsT0FBTyxXQUFXLGdCQUFnQjtBQUVsQyxZQUFBLE9BQU8sYUFBYSxrQkFBa0I7QUFFdEMsWUFBTSxPQUFPLE1BQUE7QUFDWCxhQUFLLHdCQUF3QixpQkFBaUIsT0FBTyxTQUFTLGFBQWEsU0FBUyxNQUFBO0FBQ2xGOzs7QUFJSixVQUFJLGdCQUFnQixNQUFNO0FBQ3hCLFlBQUksY0FBYztBQUVsQixjQUFNLGdDQUFnQyxJQUFBLFdBQUEsb0NBQW1DLGFBQWE7QUFFdEYsWUFBSSwrQkFBK0I7QUFDakMsd0JBQWM7O0FBR2hCLG9CQUFZLEtBQUssT0FBTyxTQUFTLGFBQWEsU0FBUzthQUNsRDtBQUNMOzs7QUFJSixrQkFBYyxPQUFPLFNBQVMsVUFBVSxXQUFTO0FBQy9DLFlBQU0sWUFBWSxNQUFBLE9BQU8sZ0JBQ25CLGFBQWEsTUFBQSxPQUFPLGlCQUNwQixZQUFZLEtBQUssZ0JBQ2pCLGFBQWEsS0FBSyxpQkFDbEIsZ0JBQWdCLEtBQUssb0JBQ3JCLGlCQUFpQixLQUFLLHFCQUN0QixrQkFBa0Isa0JBQUEsd0JBQ2xCLG1CQUFtQixXQUFXLGVBQzlCLG9CQUFvQixZQUFZO0FBRXRDLFVBQUksTUFBTSxnQkFBZ0IsbUJBQW1CLFlBQVksV0FDckQsT0FBTyxpQkFBaUIsb0JBQW9CLGFBQWE7QUFFN0QsWUFBTSxHQUFHO0FBQ1QsYUFBTyxHQUFHO0FBRVYsWUFBTSxNQUFNO1FBQ1Y7UUFDQTs7QUFHRixXQUFLLElBQUk7QUFFVCxXQUFLLG1CQUFtQixpQkFBaUIsT0FBTyxTQUFTLGtCQUFrQjs7QUFHN0UsZ0NBQTRCLE9BQU8sU0FBUyxVQUFVLFdBQVM7QUFDN0QsVUFBSSxVQUFVLEtBQUs7QUFFbkIsVUFBSSxZQUFZLE1BQU07QUFDcEIsa0JBQVUsV0FBVyxNQUFBO0FBQ25CLGVBQUs7QUFFTCxlQUFLLFVBQVUsT0FBTyxTQUFTLFVBQVU7V0FDeEMsV0FBQTtBQUVILGFBQUssY0FBYzs7O0FBSXZCLGlDQUFTO0FBQ1AsWUFBTSxVQUFVLEtBQUs7QUFFckIsVUFBSSxZQUFZLE1BQU07QUFDcEIscUJBQWE7QUFFYixhQUFLOzs7QUFJVCwwQkFBUztBQUNQLFlBQU0sQ0FBRSxXQUFZLEtBQUs7QUFFekIsYUFBTzs7QUFHVCw0QkFBUztBQUNQLFlBQU0sVUFBVTtBQUVoQixXQUFLLGNBQWM7O0FBR3JCLDJCQUF1QixTQUFPO0FBQzVCLFdBQUssWUFBWTtRQUNmOzs7QUFJSiw0QkFBUztBQUNQLFlBQU0sQ0FBRSxhQUFjLEtBQUs7QUFFM0IsYUFBTzs7QUFHVCw2QkFBUztBQUNQLFlBQU0sQ0FBRSxjQUFlLEtBQUs7QUFFNUIsYUFBTzs7QUFHVCxnQ0FBUztBQUNQLFlBQU0sQ0FBRSxpQkFBa0IsS0FBSztBQUUvQixhQUFPOztBQUdULGlDQUFTO0FBQ1AsWUFBTSxDQUFFLGtCQUFtQixLQUFLO0FBRWhDLGFBQU87O0FBR1QsMEJBQXNCLFdBQVM7QUFDN0IsV0FBSyxZQUFZO1FBQ2Y7OztBQUlKLDJCQUF1QixZQUFVO0FBQy9CLFdBQUssWUFBWTtRQUNmOzs7QUFJSiw4QkFBMEIsZUFBYTtBQUNyQyxXQUFLLFlBQVk7UUFDZjs7O0FBSUosK0JBQTJCLGdCQUFjO0FBQ3ZDLFdBQUssWUFBWTtRQUNmOzs7UUFJSixXQUFlO01BQ2I7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7QUFHRiw0QkFBd0IsT0FBTyxTQUFPO0FBQ3BDLFlBQU0sQ0FBRSxXQUFZLE9BQ2QsWUFBYSxZQUFZLGlCQUN6QixVQUFVO0FBRWhCLFVBQUksV0FBVztBQUNiLGFBQUssU0FBUyxPQUFPLFNBQVM7QUFFOUIsY0FBTTs7O0FBSVYsNEJBQXdCLE9BQU8sU0FBTztBQUNwQyxZQUFNLFdBQVcsS0FBSyxjQUNoQixVQUFVO0FBRWhCLGlCQUNFLEtBQUssU0FBUyxPQUFPLFNBQVMsV0FDNUIsS0FBSztBQUVULFlBQU07QUFFTixZQUFBLE9BQU8sUUFBUSxnQkFBZ0I7QUFFL0IsWUFBQSxPQUFPLFdBQVcsZ0JBQWdCOztBQUdwQyw4QkFBMEIsT0FBTyxTQUFPO0FBQ3RDLFlBQU0sQ0FBRSxVQUFXO0FBRW5CLFVBQUksV0FBVyxtQkFBbUI7QUFDaEMsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxDQUFDLFVBQVU7QUFDYixnQkFBTSxXQUFXLElBQUEsT0FBQSxtQkFBa0IsUUFDN0IsWUFBWSxJQUFBLE9BQUEsb0JBQW1CO0FBRXJDLGVBQUssbUJBQW1CLE9BQU8sU0FBUyxVQUFVOzs7QUFJdEQsWUFBTTtBQUVOLFlBQUEsT0FBTyxPQUFPLGdCQUFnQjtBQUU5QixZQUFBLE9BQU8sVUFBVSxnQkFBZ0I7O0FBR25DLDhCQUEwQixPQUFPLFNBQU87QUFDdEMsWUFBTSxXQUFXLEtBQUs7QUFFdEIsVUFBSSxVQUFVO0FBQ1osY0FBTSxXQUFXLElBQUEsT0FBQSxtQkFBa0IsUUFDN0IsWUFBWSxJQUFBLE9BQUEsb0JBQW1CO0FBRXJDLGFBQUssS0FBSyxPQUFPLFNBQVMsVUFBVTs7QUFHdEMsWUFBTTs7Ozs7QUMxWVI7Ozs7O21DQXFHQSxXQUFBOzs7ZUFBQTs7Ozs7QUFoR0EsK0JBQVM7QUFDUCxZQUFNLENBQUUsZUFBZ0I7QUFFeEIsYUFBTzs7QUFHVCw0QkFBd0IsYUFBVztBQUNqQyxhQUFPLE9BQU8sWUFBWTtRQUN4Qjs7O0FBSUosZ0NBQVM7QUFDUCxZQUFNLGNBQWM7QUFFcEIscUJBQWU7O0FBR2pCLFdBQU8sT0FBTyxZQUFZO01BQ3hCO01BQ0E7TUFDQTs7QUFHRjtBQUVBLGtCQUFjLE9BQU8sU0FBUyxhQUFhLFNBQVMsTUFBSTtBQUN0RCxZQUFNLGtCQUFrQixrQkFBQTtBQUV4QixXQUFLLHdCQUF3QixpQkFBaUIsT0FBTyxTQUFTLGFBQWEsU0FBUzs7QUFHdEYscUJBQWlCLE9BQU8sU0FBUyxhQUFXO0FBQzFDLFlBQU0sa0JBQWtCLGtCQUFBO0FBRXhCLFdBQUssbUJBQW1CLGlCQUFpQixPQUFPLFNBQVM7O0FBRzNELHNCQUFrQixPQUFPLFNBQVMsYUFBVztBQUMzQyxZQUFNLGtCQUFrQixrQkFBQTtBQUV4QixXQUFLLG1CQUFtQixpQkFBaUIsT0FBTyxTQUFTOztBQUczRCwwQkFBUztBQUNQLFdBQUssV0FBVyxpQkFBaUI7QUFDakMsV0FBSyxZQUFZLGtCQUFrQjs7QUFHckMsMkJBQVM7QUFDUCxXQUFLLFlBQVksaUJBQWlCO0FBQ2xDLFdBQUssYUFBYSxrQkFBa0I7O0FBR3RDLDBCQUFzQixtQkFBbUIsU0FBTztBQUM5QyxZQUFNLGtCQUFrQixrQkFBQSx3QkFDbEIsZ0JBQWdCO0FBRXRCLFdBQUssY0FBYyxpQkFBaUIsZUFBZTs7QUFHckQsMkJBQXVCLG1CQUFtQixTQUFPO0FBQy9DLFlBQU0sa0JBQWtCLGtCQUFBLHdCQUNsQixnQkFBZ0I7QUFFdEIsV0FBSyxlQUFlLGlCQUFpQixlQUFlOztBQUd0RCw2QkFBeUIsc0JBQXNCLFNBQU87QUFDcEQsWUFBTSxrQkFBa0Isa0JBQUEsNEJBQ2xCLGdCQUFnQjtBQUV0QixXQUFLLGNBQWMsaUJBQWlCLGVBQWU7O0FBR3JELDhCQUEwQixzQkFBc0IsU0FBTztBQUNyRCxZQUFNLGtCQUFrQixrQkFBQSw0QkFDbEIsZ0JBQWdCO0FBRXRCLFdBQUssZUFBZSxpQkFBaUIsZUFBZTs7QUFHdEQsOEJBQTBCLHVCQUF1QixTQUFPO0FBQ3RELFlBQU0sa0JBQWtCLGtCQUFBLDZCQUNsQixnQkFBZ0I7QUFFdEIsV0FBSyxjQUFjLGlCQUFpQixlQUFlOztBQUdyRCwrQkFBMkIsdUJBQXVCLFNBQU87QUFDdkQsWUFBTSxrQkFBa0Isa0JBQUEsNkJBQ2xCLGdCQUFnQjtBQUV0QixXQUFLLGVBQWUsaUJBQWlCLGVBQWU7O1FBR3RELFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOztBQUdGLDZCQUF5QixPQUFPLFNBQU87QUFDckMsWUFBTSxjQUFjO0FBRXBCLFVBQUksZ0JBQWdCLE1BQU07QUFDeEI7QUFFQSxhQUFLLFFBQVEsT0FBTyxTQUFTOztBQUcvQixZQUFNOztBQUdSLDhCQUEwQixPQUFPLFNBQU87QUFDdEMsWUFBTSxjQUFjO0FBRXBCLFVBQUksZ0JBQWdCLE1BQU07QUFDeEIsY0FBTSxjQUFjLE1BQ2QsZ0NBQWdDLElBQUEsV0FBQSxvQ0FBbUMsYUFBYTtBQUV0RixZQUFJLCtCQUErQjtBQUNqQzs7QUFHRix1QkFBZTtBQUVmLGFBQUssU0FBUyxPQUFPLFNBQVM7O0FBR2hDLFlBQU07Ozs7O0FDL0lSOzs7OzttQ0E4QkEsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7O0FBdEJBLG9DQUEwQixNQUFBLFFBQU87TUFDL0IsZ0JBQWdCO0FBQ2QsY0FBTSxDQUFFLGFBQWEsTUFBTyxLQUFLO0FBRWpDLGVBQU87O01BR1QsV0FBVztBQUNULGFBQUs7O01BR1AsY0FBYztBQUNaLGFBQUs7OztBQUdBLGtCQWZULGFBZVMscUJBQW9CO01BQ3pCOztBQUlKLFdBQU8sT0FBTyxZQUFZLFdBQVcsTUFBQTtRQUVyQyxXQUFlLElBQUEsZUFBQSxTQUFVOzs7Ozs7Ozs7Ozs7QUM5QnpCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixvQ0FBMEIsTUFBQSxRQUFPO01BQzlDLGVBQWU7QUFDYixjQUFNLENBQUUsWUFBWSxRQUFTLEtBQUs7QUFFbEMsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsYUFBSzs7TUFHUCxjQUFjO0FBQ1osYUFBSzs7O0FBR0Esa0JBZk0sYUFlTixxQkFBb0I7TUFDekI7O0FBSUosV0FBTyxPQUFPLFlBQVksV0FBVyxNQUFBOzs7O0FDMUJyQzs7Ozs7Ozs7Ozs7OztVQUlvQixjQUFBO2VBQUEsT0FBQTs7VUFDQSxjQUFBO2VBQUEsT0FBQTs7VUFDQSxtQkFBQTtlQUFBLGtCQUFBOztVQUpBLGFBQUE7ZUFBQSxNQUFBOztVQUNBLGFBQUE7ZUFBQSxNQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FDSHBCOzs7OzttQ0FjQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7OztBQVJBLG9DQUEwQixNQUFBLFFBQU87O0FBQ3hCLGtCQURULGFBQ1MsV0FBVTtBQUVWLGtCQUhULGFBR1MscUJBQW9CO01BQ3pCLFdBQVc7O1FBSWYsV0FBZSxJQUFBLGVBQUEsU0FBVTs7Ozs7Ozs7QUNkekI7Ozs7O21DQThJQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7OztBQW5JQSxvQ0FBMEIsTUFBQSxRQUFPO01BQy9CLHdCQUF3QixDQUFDLE9BQU8sU0FBUyxhQUFhLFNBQVMsU0FBQTtBQUM3RCxRQUFBLElBQUEsUUFBQTtBQUVBOztNQUdGLGtCQUFrQixDQUFDLE9BQU8sWUFBQTtBQUN4QixRQUFBLElBQUEsUUFBQTs7TUFHRixpQkFBaUI7QUFDZixZQUFJO0FBRUosY0FBTSxxQkFBcUIsS0FBSyx5QkFDMUIseUJBQXlCLEtBQUssNkJBQzlCLGdDQUFpQyw4QkFBOEIsVUFBQSxTQUMvRCxvQ0FBcUMsa0NBQWtDLFVBQUE7QUFFN0UsWUFBSSwrQkFBK0I7QUFDakMsd0JBQWM7O0FBR2hCLFlBQUksbUNBQW1DO0FBQ3JDLHdCQUFjOztBQUdoQixlQUFPOztNQUdULGVBQWU7QUFDYixZQUFJO0FBRUosY0FBTSxxQkFBcUIsS0FBSyx5QkFDMUIseUJBQXlCLEtBQUssNkJBQzlCLGdDQUFpQyw4QkFBOEIsVUFBQSxTQUMvRCxvQ0FBcUMsa0NBQWtDLFVBQUE7QUFFN0UsWUFBSSwrQkFBK0I7QUFDakMsc0JBQVk7O0FBR2QsWUFBSSxtQ0FBbUM7QUFDckMsc0JBQVk7O0FBR2QsZUFBTzs7TUFHVCxnQkFBZ0I7QUFDZCxjQUFNLGFBQWE7QUFFbkIsZUFBTzs7TUFHVCxTQUFTO0FBQ1AsY0FBTSxjQUFjLEtBQUs7QUFFekIsWUFBSSxDQUFDLGFBQWE7QUFDaEIsZUFBSztBQUVMLGVBQUssYUFBYSxLQUFLO0FBRXZCLGVBQUssaUJBQWlCLEtBQUs7QUFFM0IsZUFBSyxrQkFBa0IsS0FBSzs7O01BSWhDLFVBQVU7QUFDUixjQUFNLGNBQWMsS0FBSztBQUV6QixZQUFJLGFBQWE7QUFDZixlQUFLLG1CQUFtQixLQUFLO0FBRTdCLGVBQUssa0JBQWtCLEtBQUs7QUFFNUIsZUFBSyxjQUFjLEtBQUs7QUFFeEIsZUFBSzs7O01BSVQsYUFBYTtBQUNYLGNBQU0sY0FBYyxLQUFLLGlCQUNuQixXQUFXLENBQUM7QUFFbEIsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxDQUFFLFdBQVcsU0FBVSxLQUFLO0FBRWxDLFlBQUksQ0FBQyxVQUFVO0FBQ2IsZUFBSzs7QUFHUCxhQUFLLFlBQVksS0FBSztBQUV0QixhQUFLLFdBQVcsS0FBSzs7TUFHdkIsY0FBYztBQUNaLGNBQU0sV0FBVyxLQUFLO0FBRXRCLGFBQUssWUFBWSxLQUFLO0FBRXRCLGFBQUssYUFBYSxLQUFLO0FBRXZCLFlBQUksQ0FBQyxVQUFVO0FBQ2IsZUFBSzs7O01BSVQsYUFBYTtBQUNYLGFBQUs7OztBQUdBLGtCQXRIVCxhQXNIUyxXQUFVO0FBRVYsa0JBeEhULGFBd0hTLHFCQUFvQjtNQUN6Qjs7QUFHSyxrQkE1SFQsYUE0SFMscUJBQW9CO01BQ3pCLFdBQVc7O0FBSWYsV0FBTyxPQUFPLFlBQVksV0FBVyxpQkFBQTtRQUVyQyxXQUFlLElBQUEsZUFBQSxTQUFVOzs7Ozs7OztBQzlJekI7Ozs7O21DQWtFQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7QUExREEseUNBQStCLFVBQUEsUUFBUTtNQUNyQyx5QkFBeUIsQ0FBQyxPQUFPLFlBQUE7QUFDL0IsY0FBTSxjQUFjLEtBQUssa0JBQ25CLG1CQUFtQixZQUFZLFlBQy9CLDJCQUEyQjtBQUVqQyxhQUFLLDRCQUE0QjtBQUVqQyxhQUFLOztNQUdQLG9CQUFvQixDQUFDLE9BQU8sU0FBUyxrQkFBa0Isc0JBQUE7QUFDckQsY0FBTSxZQUFZLEtBQUssZ0JBQ2pCLGNBQWMsS0FBSyxrQkFDbkIsMkJBQTJCLEtBQUssK0JBQ2hDLG1CQUFtQiwyQkFBMkIsWUFBWSxtQkFDMUQsUUFBUTtBQUVkLG9CQUFZLFNBQVM7O01BR3ZCLG1CQUFtQixDQUFDLE9BQU8sWUFBQTtBQUN6QixhQUFLOztNQUdQLFlBQVk7QUFDVixjQUFNLFdBQVcsS0FBSztBQUV0QixZQUFJLENBQUMsVUFBVTtBQUNiLFVBQUEsSUFBQSxRQUFBOzs7TUFJSiw4QkFBOEI7QUFDNUIsY0FBTSxDQUFFLDRCQUE2QixLQUFLO0FBRTFDLGVBQU87O01BR1QsNEJBQTRCLDBCQUEwQjtBQUNwRCxhQUFLLFlBQVk7VUFDZjs7O01BSUosa0JBQWtCO0FBQ2hCLGNBQU0sMkJBQTJCO0FBRWpDLGFBQUssU0FBUztVQUNaOzs7O0FBSUcsa0JBckRULGtCQXFEUyxxQkFBb0I7TUFDekIsV0FBVzs7UUFJZixXQUFlLElBQUEsZUFBQSxTQUFVOzs7Ozs7OztBQ2xFekI7Ozs7O21DQWtFQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7QUExREEsMkNBQWlDLFVBQUEsUUFBUTtNQUN2Qyx5QkFBeUIsQ0FBQyxPQUFPLFlBQUE7QUFDL0IsY0FBTSxjQUFjLEtBQUssa0JBQ25CLG9CQUFvQixZQUFZLGFBQ2hDLDRCQUE0QjtBQUVsQyxhQUFLLDZCQUE2QjtBQUVsQyxhQUFLOztNQUdQLG9CQUFvQixDQUFDLE9BQU8sU0FBUyxrQkFBa0Isc0JBQUE7QUFDckQsY0FBTSxZQUFZLEtBQUssZ0JBQ2pCLGNBQWMsS0FBSyxrQkFDbkIsNEJBQTRCLEtBQUssZ0NBQ2pDLG9CQUFvQiw0QkFBNEIsWUFBWSxrQkFDNUQsU0FBUztBQUVmLG9CQUFZLFVBQVU7O01BR3hCLG1CQUFtQixDQUFDLE9BQU8sWUFBQTtBQUN6QixhQUFLOztNQUdQLFlBQVk7QUFDVixjQUFNLFdBQVcsS0FBSztBQUV0QixZQUFJLENBQUMsVUFBVTtBQUNiLFVBQUEsSUFBQSxRQUFBOzs7TUFJSiwrQkFBK0I7QUFDN0IsY0FBTSxDQUFFLDZCQUE4QixLQUFLO0FBRTNDLGVBQU87O01BR1QsNkJBQTZCLDJCQUEyQjtBQUN0RCxhQUFLLFlBQVk7VUFDZjs7O01BSUosa0JBQWtCO0FBQ2hCLGNBQU0sNEJBQTRCO0FBRWxDLGFBQUssU0FBUztVQUNaOzs7O0FBSUcsa0JBckRULG9CQXFEUyxxQkFBb0I7TUFDekIsV0FBVzs7UUFJZixXQUFlLElBQUEsZUFBQSxTQUFVOzs7Ozs7OztBQ2xFekI7Ozs7Ozs7Ozs7Ozs7VUFNb0IsWUFBQTtlQUFBLFFBQUE7O1VBQ0EsYUFBQTtlQUFBLFNBQUE7O1VBSUEsd0JBQUE7ZUFBQSxZQUFBOztVQVBBLFNBQUE7ZUFBQSxLQUFBOztVQUNBLFVBQUE7ZUFBQSxNQUFBOztVQUlBLGNBQUE7ZUFBQSxVQUFBOztVQURBLGNBQUE7ZUFBQSxVQUFBOztVQUVBLHNCQUFBO2VBQUEsVUFBQTs7VUFSQSxTQUFBO2VBQUEsUUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGcEI7Ozs7Ozs7Ozs7Ozs7VUFpQmEsZ0JBQUE7ZUFBQTs7VUFiZSxjQUFBO2VBQUE7O1VBWWYsZUFBQTtlQUFBOztVQUZBLGVBQUE7ZUFBQTs7VUFWdUQsY0FBQTtlQUFBOztVQUEzQixhQUFBO2VBQUE7O1VBRTVCLFNBQUE7ZUFBQTs7VUFZQSx1QkFBQTtlQUFBOztVQUhBLGVBQUE7ZUFBQTs7VUFYRSxjQUFBO2VBQUE7O1VBQXNDLGdCQUFBO2VBQUE7Ozs7QUFBOUMsUUFBTSxDQUFFLGFBQWEsYUFBYSxZQUFZLGVBQWUsZUFBZ0IsV0FBQTtBQUU3RSxRQUFNLFNBQVM7TUFDcEI7TUFDQTtNQUNBO01BQ0E7TUFDQTs7QUFHSyxRQUFNLGVBQWU7QUFDckIsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGdCQUFnQjtBQUN0QixRQUFNLHVCQUF1Qjs7OztBQ2xCcEM7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7OztBQUZyQixRQUFNLENBQUUsYUFBYSxhQUFhLFlBQVksZUFBZSxlQUFnQixXQUFBO0FBRTlELG9CQUFNO01BQ25CLFlBQVksVUFBVSxVQUFVLFFBQVE7QUFDdEMsYUFBSyxXQUFXO0FBQ2hCLGFBQUssV0FBVztBQUNoQixhQUFLLFNBQVM7O01BR2hCLGNBQWM7QUFDWixlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLE1BQU0sU0FBUztBQUNiLGNBQU0sUUFBUTtBQUVkLGFBQUssTUFBTSxPQUFPOztNQUdwQixNQUFNLFNBQVM7QUFDYixjQUFNLFFBQVE7QUFFZCxhQUFLLE1BQU0sT0FBTzs7TUFHcEIsS0FBSyxTQUFTO0FBQ1osY0FBTSxRQUFRO0FBRWQsYUFBSyxNQUFNLE9BQU87O01BR3BCLFFBQVEsU0FBUztBQUNmLGNBQU0sUUFBUTtBQUVkLGFBQUssTUFBTSxPQUFPOztNQUdwQixNQUFNLFNBQVM7QUFDYixjQUFNLFFBQVE7QUFFZCxhQUFLLE1BQU0sT0FBTzs7TUFHcEIsTUFBTSxPQUFPLFNBQVMsV0FBVyxNQUFNLFlBQVksTUFBTTtBQUN2RCxjQUFNLGFBQWEsV0FBQSxPQUFPLFFBQVEsUUFDNUIsZ0JBQWdCLFdBQUEsT0FBTyxRQUFRLEtBQUs7QUFFMUMsWUFBSSxhQUFhLGVBQWU7QUFDOUI7O0FBR0Ysa0JBQVUsY0FBYyxPQUFPLFNBQVMsVUFBVTtBQUVsRCxhQUFLLFNBQ0gsUUFBUSxJQUFJLFdBQ1YsS0FBSyxTQUFTLEtBQUs7O2FBR2xCLGNBQWM7QUFDbkIsY0FBTSxXQUFXLE1BQ1gsV0FBVyxhQUNYLFNBQVMsTUFDVCxNQUFNLElBQUksSUFBSSxVQUFVLFVBQVU7QUFFeEMsZUFBTzs7YUFHRixzQkFBc0IsUUFBUSxVQUFVO0FBQzdDLGNBQU0sV0FBVyxTQUNFLE9BQ0UsSUFDZixNQUFNLElBQUksSUFBSSxVQUFVLFVBQVU7QUFFeEMsZUFBTzs7O0FBSVgsMkJBQXVCLE9BQU8sU0FBUyxVQUFVLFdBQVM7QUFDeEQsVUFBSSxtQkFBbUIsV0FBQTtBQUV2QixZQUFNLGtCQUFrQixhQUFhLFFBQy9CLDJCQUEyQixnQkFBZ0I7QUFFakQsMEJBQW9CLEdBQUc7QUFFdkIsVUFBSSxhQUFhLE1BQU07QUFDckIsNEJBQW9CLEdBQUc7O0FBR3pCLFVBQUksY0FBYyxNQUFNO0FBQ3RCLDRCQUFvQixJQUFJOztBQUcxQixVQUFLLGFBQWEsUUFBVSxjQUFjLE1BQU87QUFDL0MsNEJBQW9COztBQUd0QiwwQkFBb0I7QUFFcEIsZ0JBQVU7QUFFVixhQUFPOztBQUdULDBCQUFzQixPQUFLO0FBQ3pCLFlBQU0sZ0JBQWdCLFdBQUEsc0JBQ2hCLGtCQUFrQixRQUFRLE9BQU87QUFFdkMsYUFBTzs7QUFHVCxxQkFBaUIsUUFBUSxlQUFhO0FBQ3BDLFlBQU0sZUFBZSxPQUFPLFFBQ3RCLFNBQVMsZ0JBQWdCLGNBQ3pCLFNBQVMsV0FBQSxhQUFhLE9BQU8sU0FDN0IsbUJBQW1CLEdBQUcsU0FBUztBQUVyQyxhQUFPOzs7OztBQ2pJVDs7Ozs7bUNBRUEsV0FBQTs7O2VBQXFCOzs7QUFBTix3QkFBTTtNQUNuQixZQUFZLFVBQVMsUUFBUSxNQUFNO0FBQ2pDLGFBQUssVUFBVTtBQUNmLGFBQUssU0FBUztBQUNkLGFBQUssT0FBTzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFDVixlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxXQUFXLFVBQVM7QUFDbEIsYUFBSyxVQUFVOztNQUdqQixVQUFVLFFBQVE7QUFDaEIsYUFBSyxTQUFTOztNQUdoQixRQUFRLE1BQU07QUFDWixhQUFLLE9BQU87O1lBR1IsTUFBTSxVQUFTO0FBQ25CLGNBQU0sU0FBUSxNQUFNLEtBQUs7O01BRzNCLFVBQVUsTUFBTTtBQUFFLGVBQU8sS0FBSyxLQUFLLE1BQU07Ozs7OztBQ3JDM0M7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLHdCQUFNO01BQ25CLFlBQVksVUFBUztBQUNuQixhQUFLLFVBQVU7O01BR2pCLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsV0FBVztBQUNULFlBQUksUUFBUSxLQUFLLFFBQVE7QUFFekI7QUFFQSxlQUFPOztNQUdULG9CQUFvQjtBQUFFLGVBQU8sS0FBSyxRQUFROztNQUUxQyxjQUFjLE1BQU07QUFBRSxlQUFPLEtBQUssUUFBUSxjQUFjOztNQUV4RCxhQUFhLE1BQU07QUFBRSxlQUFPLEtBQUssUUFBUSxhQUFhOztNQUV0RCxNQUFNLFNBQVM7QUFDYixjQUFNLFFBQVEsV0FBQTtBQUVkLGFBQUssV0FBVyxPQUFPOztNQUd6QixNQUFNLFNBQVM7QUFDYixjQUFNLFFBQVEsV0FBQTtBQUVkLGFBQUssV0FBVyxPQUFPOztNQUd6QixLQUFLLFNBQVM7QUFDWixjQUFNLFFBQVEsV0FBQTtBQUVkLGFBQUssV0FBVyxPQUFPOztNQUd6QixRQUFRLFNBQVM7QUFDZixjQUFNLFFBQVEsV0FBQTtBQUVkLGFBQUssV0FBVyxPQUFPOztNQUd6QixNQUFNLFNBQVM7QUFDYixjQUFNLFFBQVEsV0FBQTtBQUVkLGFBQUssV0FBVyxPQUFPOztNQUd6QixXQUFXLE9BQU8sU0FBUztBQUN6QixjQUFNLFFBQVEsS0FBSyxZQUNiLFNBQVMsV0FBQSxhQUFhLE9BQU87QUFFbkMsa0JBQVUsR0FBRyxTQUFTO0FBRXRCLGNBQU0saUJBQWlCLEtBQUs7QUFFNUIsdUJBQWUsV0FBVyxPQUFPOztZQUc3QixNQUFNLE1BQU07QUFBRSxjQUFNLEtBQUssUUFBUSxNQUFNOzthQUV0QyxZQUFZLFVBQVUsb0JBQW9CO0FBQy9DLFlBQUksV0FBVSxtQkFBbUI7QUFFakMsbUJBQVUsSUFBSSxNQUFNLFVBQUEsR0FBWTtBQUVoQyxlQUFPOzs7Ozs7QUMzRVg7Ozs7O21DQUVnQiw4QkFBQTs7O2VBQUE7OztBQUFULHdDQUFvQyxNQUFNLFFBQU07QUFDckQsVUFBSSxZQUFZO0FBRWhCLFlBQU0sNkJBQTZCLEtBQUssOEJBQThCO0FBRXRFLGFBQU8sS0FBSyxDQUFDLE9BQU8sZUFBQTtBQUNsQixjQUFNLHNCQUFzQixNQUFNO0FBRWxDLFlBQUkscUJBQXFCO0FBQ3ZCLHVCQUFhOztBQUdmLFlBQUksZUFBZSw0QkFBNEI7QUFDN0MsaUJBQU87OztBQUlYLGFBQU87Ozs7O0FDbkJUOzs7Ozs7Ozs7Ozs7O1VBOEJBLFVBQUE7ZUFBQTs7VUExQmdCLGVBQUE7ZUFBQTs7VUFZQSxnQkFBQTtlQUFBOzs7O0FBWlQsMEJBQXNCLE1BQU0sUUFBTTtBQUN2QyxVQUFJO0FBRUosZUFBUyxhQUFhLE1BQU07QUFFNUIsZUFBUyxlQUFlO0FBRXhCLGVBQVMsV0FBVztBQUVwQixhQUFPOztBQUdGLDJCQUF1QixPQUFPLFFBQU07QUFDekMsWUFBTSxTQUFTLE1BQU0sT0FBTyxDQUFDLFNBQVEsU0FBQTtBQUNuQyxjQUFNLGFBQWEsYUFBYSxNQUFNO0FBRXRDLGtCQUFVLFlBQVcsT0FDbkIsYUFDQSxHQUFHLFlBQVc7QUFFaEIsZUFBTztTQUNOO0FBRUgsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTs7QUFHRix3QkFBb0IsUUFBTTtBQUN4QixlQUFTLE9BQU8sUUFBUSxRQUFRLFdBQUE7QUFFaEMsYUFBTzs7QUFHVCw0QkFBd0IsUUFBTTtBQUM1QixZQUFNLFNBQVMsT0FBTyxPQUFPLENBQUMsU0FBUSxVQUFBO0FBQ3BDLGNBQU0sVUFBVSxNQUFNO0FBRXRCLGtCQUFTLEdBQUcsVUFBUztBQUVyQixlQUFPO1NBQ04sV0FBQTtBQUVILGFBQU87O0FBR1QsMEJBQXNCLE1BQU0sUUFBTTtBQUNoQyxZQUFNLG1CQUFtQixLQUFLO0FBRTlCLFVBQUksa0JBQWtCO0FBQ3BCLGNBQU0sZUFBZTtBQUVyQixpQkFBUyxxQkFBcUIsY0FBYzthQUN2QztBQUNMLGNBQU0sa0JBQWtCO0FBRXhCLGlCQUFTLHdCQUF3QixpQkFBaUI7O0FBR3BELGFBQU87O0FBR1Qsa0NBQThCLGNBQWMsUUFBTTtBQUNoRCxZQUFNLG1CQUFtQixhQUFhLHVCQUNoQyxRQUFRO0FBRWQsZUFBUztRQUNQOztBQUdGLGFBQU87O0FBR1QscUNBQWlDLGlCQUFpQixRQUFNO0FBQ3RELFlBQU0sNEJBQTRCLGdCQUFnQiw2QkFBNkIsU0FDekUsNkJBQTZCLGdCQUFnQiw4QkFBOEIsU0FDM0UsUUFBUSw0QkFDUixNQUFNLDRCQUE0QjtBQUV4QyxlQUFTLE9BQU8sTUFBTSxPQUFPO0FBRTdCLGFBQU87Ozs7O0FDeEZUOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4sb0NBQTBCLFNBQUEsUUFBTztNQUM5QyxZQUFZLFVBQVMsVUFBVSxRQUFRLE1BQU07QUFDM0MsY0FBTTtBQUVOLGFBQUssV0FBVztBQUNoQixhQUFLLFNBQVM7QUFDZCxhQUFLLE9BQU87O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsV0FBVztBQUNULGNBQU0sUUFBUTtBQUVkLGVBQU87O01BR1QsWUFBWTtBQUNWLGNBQU0sU0FBUztBQUVmLGVBQU87O01BR1QsZ0JBQWdCO0FBQ2QsY0FBTSxXQUFVLEtBQUssY0FDZixhQUFhLFNBQVE7QUFFM0IsZUFBTzs7TUFHVCxjQUFjLFVBQVU7QUFDdEIsY0FBTSxrQkFBbUIsS0FBSyxhQUFhO0FBRTNDLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0saUJBQWlCLEtBQUsscUJBQ3RCLE9BQU8sZUFBZSxTQUFTLEtBQUs7QUFFMUMsZUFBTzs7TUFHVCxhQUFhLE1BQU07QUFDakIsY0FBTSxTQUFTLElBQUEsTUFBQSxjQUFhLE1BQU0sS0FBSztBQUV2QyxlQUFPOztNQUdULGNBQWMsT0FBTztBQUNuQixjQUFNLFNBQVMsSUFBQSxNQUFBLGVBQWMsT0FBTyxLQUFLO0FBRXpDLGVBQU87O01BR1QsVUFBVTtBQUNSLFlBQUksS0FBSyxXQUFXLE1BQU07QUFDeEI7O0FBR0YsY0FBTSxPQUFPLEtBQUssWUFDWixRQUFRLEtBQUssWUFDYixTQUFTLEtBQUssYUFDZCxVQUFVLEtBQUs7QUFFckIsYUFBSyxTQUFTLE1BQU0sU0FBUztBQUU3QixhQUFLLE9BQU8sT0FBTyxNQUFNLEtBQUs7O01BR2hDLFdBQVcsTUFBTTtBQUNmLGNBQU0sQ0FBRSxXQUFZLE1BQ2QsUUFBUSxLQUFLLFlBQ2IsU0FBUyxLQUFLO0FBRXBCLGFBQUssU0FBUyxNQUFNLFNBQVM7QUFFN0IsYUFBSyxPQUFPLE9BQU8sTUFBTSxLQUFLO0FBRTlCLGFBQUs7QUFFTCxhQUFLOztZQUdELE1BQU0sTUFBTTtBQUNoQixjQUFNLFdBQVcsS0FBSyxVQUNoQixZQUFZLElBQUEsV0FBQSw0QkFBMkIsTUFBTSxLQUFLLFNBQ2xELGlCQUFpQixLQUFLO0FBRTVCLGNBQU0sZUFBZSxNQUFNLFVBQVU7O1lBR2pDLFNBQVM7QUFDYixZQUFJLFdBQVc7QUFFZixhQUFLO0FBRUwsWUFBSSxLQUFLLFNBQVMsTUFBTTtBQUN0QixlQUFLLFFBQVEseUJBQXlCLEtBQUs7ZUFDdEM7QUFDTCxlQUFLLE1BQU0sa0JBQWtCLEtBQUs7QUFFbEMsZ0JBQU0sZUFBZSxNQUFNLEtBQUs7QUFFaEMsY0FBSSxjQUFjO0FBQ2hCLHVCQUFXOztBQUdiLHFCQUNFLEtBQUssYUFDSCxLQUFLO0FBRVQsY0FBSSxVQUFVO0FBQ1osaUJBQUssS0FBSyxvQkFBb0IsS0FBSzs7O0FBSXZDLGVBQU87O2FBR0YsU0FBUyxPQUFPLFNBQVMsb0JBQW9CO0FBQ2xELGNBQU0sV0FBVyxLQUFLLFdBQ2hCLFNBQVMsTUFDVCxPQUFPLE1BQ1AsV0FBVSxtQkFBbUIsT0FDN0IsY0FBYyxJQUFJLE1BQU0sVUFBUyxVQUFVLFFBQVEsTUFBQSxHQUFTO0FBRWxFLGVBQU87O2FBR0YsU0FBUyxPQUFPLFNBQVMsb0JBQW9CO0FBQ2xELGNBQU0sQ0FBRSxZQUFhLE1BQ2YsU0FBUyxNQUNULE9BQU8sTUFDUCxXQUFVLG1CQUFtQixPQUM3QixjQUFjLElBQUksTUFBTSxVQUFTLFVBQVUsUUFBUSxNQUFBLEdBQVM7QUFFbEUsZUFBTzs7Ozs7O0FDMUpYOzs7Ozs7Ozs7Ozs7O1VBaUlzQixzQkFBQTtlQUFBOztVQXpHQSxhQUFBO2VBQUE7O1VBZ0NBLGVBQUE7ZUFBQTs7VUEwREEscUJBQUE7ZUFBQTs7VUF4RUEsY0FBQTtlQUFBOztVQXdCQSxlQUFBO2VBQUE7O1VBNURBLFlBQUE7ZUFBQTs7VUEwSXRCLFVBQUE7ZUFBQTs7OztBQTVJQSxRQUFNLENBQUUsVUFBVyxXQUFBO0FBRVosNkJBQXlCLE9BQU8sVUFBUTtBQUM3QyxVQUFJLFNBQVM7QUFFYixZQUFNLFNBQVMsTUFBTTtBQUVyQixlQUFTLFFBQVEsR0FBRyxRQUFRLFFBQVEsU0FBUyxHQUFHO0FBQzlDLGNBQU0sVUFBVSxNQUFNO0FBRXRCLGlCQUFTLE1BQU0sU0FBUyxTQUFTLE9BQU87QUFFeEMsWUFBSSxRQUFRO0FBQ1Y7OztBQUlKLGFBQU87O0FBR0YsOEJBQTBCLE9BQU8sVUFBUTtBQUM5QyxVQUFJLFNBQVM7QUFFYixZQUFNLFNBQVMsTUFBTTtBQUVyQixlQUFTLFFBQVEsR0FBRyxRQUFRLFFBQVEsU0FBUyxHQUFHO0FBQzlDLGNBQU0sVUFBVSxNQUFNO0FBRXRCLGlCQUFTLE1BQU0sU0FBUyxTQUFTLE9BQU87QUFFeEMsWUFBSSxDQUFDLFFBQVE7QUFDWDs7O0FBSUosYUFBTzs7QUFHRiwrQkFBMkIsT0FBTyxVQUFVLGNBQVk7QUFDN0QsVUFBSSxRQUFRO0FBRVosWUFBTSxTQUFTLE1BQU07QUFFckIsZUFBUyxRQUFRLEdBQUcsUUFBUSxRQUFRLFNBQVMsR0FBRztBQUM5QyxjQUFNLFVBQVUsTUFBTTtBQUV0QixnQkFBUSxNQUFNLFNBQVMsT0FBTyxTQUFTLE9BQU87O0FBR2hELGFBQU87O0FBR0YsZ0NBQTRCLE9BQU8sVUFBUTtBQUNoRCxZQUFNLFNBQVMsTUFBTTtBQUVyQixlQUFTLFFBQVEsR0FBRyxRQUFRLFFBQVEsU0FBUyxHQUFHO0FBQzlDLGNBQU0sVUFBVSxNQUFNO0FBRXRCLGNBQU0sU0FBUyxTQUFTLE9BQU87OztBQUk1QixnQ0FBNEIsUUFBUSxRQUFRLFVBQVE7QUFDekQsVUFBSTtBQUVKLGVBQVM7V0FDSjs7QUFHTCxpQkFBUztBQUNQLGNBQU0sZ0JBQWUsT0FBTztBQUU1QixZQUFJLGtCQUFpQixHQUFHO0FBQ3RCOztBQUdGLFlBQUksWUFBVztBQUVmLGNBQU0sYUFBYSxRQUFRLE9BQU8sVUFBVSxVQUFBO0FBQzFDLGdCQUFNLFNBQVMsTUFBTSxTQUFTLFVBQVUsT0FBTztBQUUvQyxjQUFJLFFBQVE7QUFDVixrQkFBTSxXQUFXO0FBRWpCLG1CQUFPLEtBQUs7QUFFWix3QkFBVzs7O0FBSWYsWUFBSSxDQUFDLFdBQVU7QUFDYjs7QUFHRixlQUFPLFFBQVEsQ0FBQyxhQUFBO0FBQ2QsZ0JBQU0seUJBQXlCLE9BQU8sU0FBUztBQUUvQyxjQUFJLENBQUMsd0JBQXdCO0FBQzNCLG1CQUFPOzs7O0FBS2IsWUFBTSxlQUFlLE9BQU87QUFFNUIsaUJBQVksaUJBQWlCO0FBRTdCLGFBQU87O0FBR0Ysc0NBQWtDLE9BQU8sVUFBUTtBQUN0RCxZQUFNLFNBQVMsTUFBTTtBQUVyQixlQUFTLFFBQVEsR0FBRyxRQUFRLFFBQVEsU0FBUztBQUMzQyxjQUFNLFVBQVUsTUFBTSxRQUNoQixTQUFTLE1BQU0sU0FBUyxTQUFTLE9BQU87QUFFOUMsWUFBSSxDQUFDLFFBQVE7QUFDWCxpQkFBTzs7O0FBSVgsYUFBTzs7QUFHRix1Q0FBbUMsT0FBTyxVQUFRO0FBQ3ZELFlBQU0sU0FBUyxNQUFNO0FBRXJCLGVBQVMsUUFBUSxTQUFTLEdBQUcsU0FBUyxHQUFHLFNBQVM7QUFDaEQsY0FBTSxVQUFVLE1BQU0sUUFDaEIsU0FBUyxNQUFNLFNBQVMsU0FBUyxPQUFPO0FBRTlDLFlBQUksQ0FBQyxRQUFRO0FBQ1gsaUJBQU87OztBQUlYLGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBOzs7OztBQ3ZKRjs7Ozs7Ozs7Ozs7OztVQVFzQixxQkFBQTtlQUFBOztVQWFOLHFCQUFBO2VBQUE7Ozs7O0FBZmhCLFFBQU0sQ0FBRSxlQUFPLFFBQVEsWUFBYSxXQUFBO0FBRTdCLHNDQUFrQyxjQUFjLHNCQUFvQjtBQUN6RSxZQUFNLFdBQVcsTUFBTSxJQUFBLGNBQUEsY0FBYSxjQUFjLHNCQUFzQixPQUFPLGdCQUFBO0FBQ3ZFLGNBQU0sc0JBQXNCLE1BQU0sWUFBWTtBQUU5QyxZQUFJLHFCQUFxQjtBQUN2QixpQkFBTzs7VUFHWCxxQkFBcUI7QUFFM0IsYUFBTzs7QUFHRixnQ0FBNEIsY0FBYyxnQkFBYztBQUM3RCxVQUFJLHFCQUFxQjtBQUV6QixZQUFNLHFCQUFxQixhQUFhLFFBQ2xDLHlCQUF5QjtXQUNwQjs7QUFHWCxlQUFTLHdCQUF3QixDQUFDLGFBQWEsZ0JBQUE7QUFDN0MsY0FBTSxrQkFBa0IsWUFBWSxXQUM5QixrQkFBa0IsWUFBWTtBQUVwQyxZQUFJLG9CQUFvQixpQkFBaUI7QUFDdkMsaUJBQU87OztBQUlYLFlBQU0sNkJBQTZCLHVCQUF1QjtBQUUxRCxVQUFJLHFCQUFxQiw0QkFBNEI7QUFDbkQsZUFBTyx3QkFBd0IsQ0FBQyxnQkFBQTtBQUM5QixnQkFBTSxpQ0FBaUMsYUFBYSxTQUFTO0FBRTdELGNBQUksQ0FBQyxnQ0FBZ0M7QUFDbkMsbUJBQU87OztBQUlYLGNBQU0sa0JBQWtCLE9BQU0sZUFDeEIsYUFBYSxpQkFDYixtQkFBbUIsV0FBVztBQUVwQyx1QkFBZSxLQUFLLFFBQVE7QUFFNUIsNkJBQXFCOztBQUd2QixhQUFPOzs7OztBQzFEVDs7Ozs7bUNBRWEsK0JBQUE7OztlQUFBOzs7QUFBTixRQUFNLDhCQUE4Qjs7OztBQ0YzQzs7Ozs7Ozs7Ozs7OztVQUdhLHNCQUFBO2VBQUE7O1VBREEsaUJBQUE7ZUFBQTs7VUFHYixVQUFBO2VBQUE7OztBQUhPLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0sc0JBQXNCO1FBRW5DLFdBQWU7TUFDYjtNQUNBOzs7OztBQ1BGOzs7Ozs7Ozs7Ozs7O1VBR2EseUJBQUE7ZUFBQTs7VUFEQSx1QkFBQTtlQUFBOztVQUdiLFVBQUE7ZUFBQTs7O0FBSE8sUUFBTSx1QkFBdUI7QUFDN0IsUUFBTSx5QkFBeUI7UUFFdEMsV0FBZTtNQUNiO01BQ0E7Ozs7O0FDUEY7Ozs7Ozs7Ozs7Ozs7VUFTYSxtQkFBQTtlQUFBOztVQVBBLGVBQUE7ZUFBQTs7VUFRQSxxQkFBQTtlQUFBOztVQUZBLGtCQUFBO2VBQUE7O1VBREEsa0JBQUE7ZUFBQTs7VUFKQSxlQUFBO2VBQUE7O1VBQ0EsaUJBQUE7ZUFBQTs7O0FBRk4sUUFBTSxlQUFlO0FBQ3JCLFFBQU0sZUFBZTtBQUNyQixRQUFNLGlCQUFpQjs7O0FBR3ZCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0scUJBQXFCOzs7O0FDVmxDOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7QUFBTiw4QkFBTTtNQUNuQixZQUFZLE1BQU0sU0FBUyxjQUFjLGdCQUFnQixrQkFBa0I7QUFDekUsYUFBSyxPQUFPO0FBQ1osYUFBSyxVQUFVO0FBQ2YsYUFBSyxlQUFlO0FBQ3BCLGFBQUssaUJBQWlCO0FBQ3RCLGFBQUssbUJBQW1COztNQUcxQixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2Qsa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSzs7TUFHZCxvQkFBb0I7QUFDbEIsZUFBTyxLQUFLOztNQUdkLHNCQUFzQjtBQUNwQixlQUFPLEtBQUs7O01BR2QsT0FBTyxVQUFVO0FBQ2YsWUFBSTtBQUVKLGdCQUFRO2VBQ0QsV0FBQTtBQUFnQixrQkFBTSxLQUFLO0FBQVM7ZUFDcEMsV0FBQTtBQUFxQixrQkFBTSxLQUFLO0FBQWM7O0FBR3JELGVBQU87O01BR1QsY0FBYyxnQkFBZ0I7QUFDNUIsWUFBSTtBQUVKLGdCQUFRO2VBQ0QsaUJBQUE7QUFBc0IseUJBQWEsS0FBSztBQUFnQjtlQUN4RCxpQkFBQTtBQUF3Qix5QkFBYSxLQUFLO0FBQWtCOztBQUduRSxlQUFPOztNQUdULGtCQUFrQjtBQUNoQixjQUFNLGVBQWU7VUFDbkIsS0FBSztVQUNMLEtBQUs7O0FBR1AsZUFBTzs7TUFHVCx5QkFBeUI7QUFDdkIsY0FBTSx1QkFBd0IsS0FBSyxTQUFTLGNBQUE7QUFFNUMsZUFBTzs7TUFHVCxRQUFRLE1BQU07QUFDWixhQUFLLE9BQU87O01BR2QsT0FBTyxVQUFVLEtBQUs7QUFDcEIsZ0JBQVE7ZUFDRCxXQUFBO0FBQ0gsaUJBQUssVUFBVTtBQUVmO2VBRUcsV0FBQTtBQUNILGlCQUFLLGVBQWU7QUFFcEI7OztNQUlOLGNBQWMsZ0JBQWdCLFlBQVk7QUFDeEMsZ0JBQVE7ZUFDRCxpQkFBQTtBQUNILGlCQUFLLGlCQUFpQjtBQUV0QjtlQUVHLGlCQUFBO0FBQ0gsaUJBQUssbUJBQW1CO0FBRXhCOzs7TUFJTixTQUFTLFVBQVU7QUFDakIsY0FBTSxNQUFNLFdBQUE7QUFFWixhQUFLLE9BQU8sVUFBVTs7TUFHeEIsZ0JBQWdCLGdCQUFnQjtBQUM5QixjQUFNLGFBQWEsV0FBQTtBQUVuQixhQUFLLGNBQWMsZ0JBQWdCOztNQUdyQyxPQUFPLFVBQVUsS0FBSyxnQkFBZ0IsWUFBWTtBQUNoRCxhQUFLLE9BQU8sVUFBVTtBQUV0QixhQUFLLGNBQWMsZ0JBQWdCOztNQUdyQyxTQUFTO0FBQ1AsY0FBTSxPQUFPLEtBQUssTUFDWixVQUFVLEtBQUssU0FDZixlQUFlLEtBQUssY0FDcEIsaUJBQWlCLEtBQUssZ0JBQ3RCLG1CQUFtQixLQUFLLGtCQUN4QixPQUFPO1VBQ0w7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7QUFHUixlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixjQUFNLENBQUUsTUFBTSxTQUFTLGNBQWMsZ0JBQWdCLG9CQUFxQixNQUNwRSxnQkFBZ0IsSUFBSSxjQUFjLE1BQU0sU0FBUyxjQUFjLGdCQUFnQjtBQUVyRixlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixjQUFNLFVBQVUsV0FBQSxjQUNWLGVBQWUsV0FBQSxjQUNmLGlCQUFpQixXQUFBLGNBQ2pCLG1CQUFtQixXQUFBLGNBQ25CLGdCQUFnQixJQUFJLGNBQWMsTUFBTSxTQUFTLGNBQWMsZ0JBQWdCO0FBRXJGLGVBQU87O2FBR0YsNkRBQTZELE1BQU0sU0FBUyxjQUFjLGdCQUFnQixrQkFBa0I7QUFDakksY0FBTSxnQkFBZ0IsSUFBSSxjQUFjLE1BQU0sU0FBUyxjQUFjLGdCQUFnQjtBQUVyRixlQUFPOzs7Ozs7QUNoS1g7Ozs7Ozs7Ozs7Ozs7VUErRUEsVUFBQTtlQUFBOztVQW5FYSxlQUFBO2VBQUE7O1VBc0RBLG1CQUFBO2VBQUE7O1VBNURBLFVBQUE7ZUFBQTs7VUEwREEsaUJBQUE7ZUFBQTs7Ozs7Ozs7OztBQTFETixRQUFNLFVBQVU7Ozs7O0FBTWhCLFFBQU0sZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0RyQixRQUFNLGlCQUFpQjtBQUV2QixRQUFNLG1CQUFtQjtBQUVoQyxRQUFNLE9BQU8sY0FBQTtBQUFiLFFBQ00sT0FBTztNQUNMO01BQ0E7TUFDQTtNQUNBO01BQ0E7O0FBR1IsUUFBTSx1QkFBdUIsZUFBQSxRQUFjLFNBQVM7UUFFcEQsV0FBZTs7OztBQy9FZjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4sc0NBQTJCLGFBQUEsWUFBVzthQXFCNUMsWUFBWSxTQUFTO0FBQUUsZUFBTyxhQUFBLFlBQVksWUFBWSxlQUFjOzs7QUFyQjlEO0FBQ04sa0JBRE0sY0FDTixrQkFBaUIsYUFBQTtBQUVqQixrQkFITSxjQUdOLG1CQUFrQixhQUFBO0FBRWxCLGtCQUxNLGNBS04sMEJBQXlCO0FBRXpCLGtCQVBNLGNBT04seUJBQXdCO0FBRXhCLGtCQVRNLGNBU04sMEJBQXlCO0FBRXpCLGtCQVhNLGNBV04sOEJBQTZCO0FBRTdCLGtCQWJNLGNBYU4sZ0NBQStCO0FBRS9CLGtCQWZNLGNBZU4saUNBQWdDO0FBRWhDLGtCQWpCTSxjQWlCTixrQ0FBaUM7QUFFakMsa0JBbkJNLGNBbUJOLGtDQUFpQzs7OztBQ3ZCMUM7Ozs7O21DQW9EQSxXQUFBOzs7ZUFBQTs7OztBQWhEQSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSwwQkFBZ0IsY0FBQSxnQkFBZTthQUN0QiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLEdBQUcsVUFBVSxZQUFZLFNBQVM7OztBQUdyTSxRQUFNLHFCQUFxQjtNQUN6QjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ3BEZjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sc0NBQTRCLGNBQUEsYUFBWTs7QUFDOUMsa0JBRE0sZUFDTixzQkFBcUIsb0JBQUE7Ozs7QUNQOUI7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7OztBQUZyQixRQUFNLENBQUUsbUJBQW9CLFdBQUE7QUFFYixzQkFBTTtNQUNuQixZQUFZLE9BQU87QUFDakIsYUFBSyxRQUFROztNQUdmLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsWUFBWTtBQUNWLGNBQU0sU0FBUyxLQUFLLE1BQU07QUFFMUIsZUFBTzs7TUFHVCxRQUFRLE9BQU87QUFDYixjQUFNLE9BQU8sS0FBSyxNQUFNO0FBRXhCLGVBQU87O01BR1QsY0FBYztBQUNaLGNBQU0sV0FBVyxLQUFLLFFBQVEsQ0FBQyxTQUFBO0FBQzdCLGdCQUFNLGVBQWUsS0FBSyxtQkFDcEIsU0FBUztBQUVmLGlCQUFPOztBQUdULGVBQU87O01BR1QsUUFBUSxVQUFVO0FBQUUsZUFBTyxLQUFLLE1BQU0sSUFBSTs7TUFFMUMsVUFBVSxVQUFVO0FBQUUsZUFBTyxLQUFLLE1BQU0sTUFBTTs7TUFFOUMsWUFBWSxVQUFVO0FBQUUsZUFBTyxLQUFLLE1BQU0sUUFBUTs7TUFFbEQsVUFBVSxPQUFPO0FBQ2YsWUFBSSxVQUFVO0FBRWQsY0FBTSxTQUFTLE1BQ1QsU0FBUyxPQUNULGVBQWUsT0FBTyxhQUN0QixlQUFlLE9BQU87QUFFNUIsWUFBSSxpQkFBaUIsY0FBYztBQUNqQyxvQkFBVSxPQUFPLFVBQVUsQ0FBQyxPQUFPLFVBQUE7QUFDakMsa0JBQU0sUUFBUSxPQUFPLFFBQVEsUUFDdkIsVUFBVSxNQUFNLE1BQU07QUFFNUIsZ0JBQUksU0FBUztBQUNYLHFCQUFPOzs7O0FBS2IsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxRQUFRLEtBQUssTUFBTSxTQUNuQixPQUFPLE1BQU07QUFFbkIsY0FBTSxRQUFRO0FBRWQsY0FBTSxRQUFRLElBQUksTUFBTTtBQUV4QixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFdBQVcsS0FBSyxlQUNoQixTQUFTLFNBQVMsS0FBSztBQUU3QixlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixjQUFNLFFBQVE7VUFDTjtXQUVGLFFBQVEsSUFBSSxNQUFNO0FBRXhCLGVBQU87O2FBR0YsVUFBVSxPQUFPO0FBQ3RCLGNBQU0sUUFBUSxJQUFJLE1BQU07QUFFeEIsZUFBTzs7Ozs7O0FDaEdYOzs7Ozs7Ozs7Ozs7O1VBUUEsVUFBQTtlQUFxQjs7VUE4S0wsaUJBQUE7ZUFBQTs7Ozs7Ozs7OztBQWhMaEIsUUFBTSxDQUFFLE1BQU0sTUFBTSxZQUFhLFdBQUE7QUFFbEIsOEJBQU07TUFDbkIsWUFBWSxPQUFPLGFBQWE7QUFDOUIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxjQUFjOztNQUdyQixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLGlCQUFpQjtBQUNmLGVBQU8sS0FBSzs7TUFHZCxRQUFRLE1BQU07QUFDWixjQUFNLFVBQVUsZUFBZSxLQUFLLE9BQU87QUFFM0MsWUFBSSxDQUFDLFNBQVM7QUFDWixlQUFLLE1BQU0sS0FBSzs7O01BSXBCLFNBQVMsT0FBTztBQUNkLGNBQU0sUUFBUSxDQUFDLFNBQUE7QUFDYixlQUFLLFFBQVE7OztNQUlqQixXQUFXLE1BQU07QUFDZixjQUFNLFFBQVEsS0FBSyxNQUFNLFFBQVEsT0FDM0IsUUFBUSxPQUNSLGNBQWM7QUFFcEIsYUFBSyxNQUFNLE9BQU8sT0FBTzs7TUFHM0IsaUJBQWlCLFFBQVEsVUFBVSxVQUFVO0FBQzNDLGNBQU0sbUJBQW1CLFVBQ25CLG9CQUFvQixLQUFLLHNCQUFzQjtBQUVyRCwwQkFBa0IsUUFBUSxDQUFDLG9CQUFBO0FBQ3pCLGdCQUFNLDBDQUEwQyxpQkFBaUIsU0FBUyxrQkFDcEUsWUFBVztlQUNOO1lBQ0g7YUFFRixVQUFTO0FBRWYsY0FBSSx5Q0FBeUM7QUFDM0MscUJBQVM7aUJBQ0o7QUFDTCxpQkFBSyxpQkFBaUIsU0FBUSxXQUFVOzs7O01BSzlDLGFBQWE7QUFDWCxjQUFNLGdCQUFnQixLQUFLLHFCQUNyQixtQkFBbUIsS0FBSyx3QkFDeEIsU0FBUzthQUNKO2FBQ0E7O0FBR1gsaUJBQVMsUUFBUSxDQUFDLFFBQVEsV0FBQTtBQUN4QixnQkFBTSxtQkFBbUIsb0JBQW9CLFFBQVE7QUFFckQsY0FBSSxDQUFDLGtCQUFrQjtBQUNyQixtQkFBTzs7O0FBSVgsZUFBTzs7TUFHVCxvQkFBb0I7QUFDbEIsY0FBTSx1QkFBdUIsS0FBSyw0QkFDNUIsZ0JBQWdCLHFCQUFxQixJQUFJLENBQUMsd0JBQUE7QUFDeEMsZ0JBQU0sT0FBTyxxQkFDUCxRQUFRLE9BQUEsUUFBTSxTQUFTLE9BQ3ZCLGVBQWU7QUFFckIsaUJBQU87O0FBR2YsZUFBTzs7TUFHVCx1QkFBdUI7QUFDckIsY0FBTSxtQkFBbUIsSUFDbkIsZ0JBQWdCLE1BQ2hCLFNBQVMsS0FBSyxhQUNkLFdBQVc7VUFDVDs7QUFHUixhQUFLLGlCQUFpQixRQUFRLFVBQVUsQ0FBQyxjQUFBO0FBQ3ZDLGdCQUFNLGtCQUFrQiw0QkFBNEIsV0FBVTtBQUU5RCwyQkFBaUIsS0FBSzs7QUFHeEIsZUFBTzs7TUFHVCxtQkFBbUIsUUFBUTtBQUN6QixjQUFNLGVBQWUsUUFDZixRQUFRLEtBQUssd0JBQXdCLGVBQ3JDLGlCQUFpQixNQUFNLE9BQU8sQ0FBQyxTQUFBO0FBQzdCLGdCQUFNLGVBQWUsS0FBSztBQUUxQixjQUFJLGlCQUFpQixjQUFjO0FBQ2pDLG1CQUFPOzs7QUFJakIsZUFBTzs7TUFHVCxzQkFBc0IsUUFBUTtBQUM1QixjQUFNLGlCQUFpQixLQUFLLG1CQUFtQixTQUN6QyxvQkFBb0IsZUFBZSxJQUFJLENBQUMsa0JBQUE7QUFDdEMsZ0JBQU0sNEJBQTRCLGNBQWMsbUJBQzFDLGtCQUFrQjtBQUV4QixpQkFBTzs7QUFHZixlQUFPOztNQUdULHdCQUF3QixjQUFjO0FBQ3BDLGNBQU0sUUFBUSxLQUFLLEtBQUssT0FBTyxDQUFDLFNBQUE7QUFDOUIsZ0JBQU0sMEJBQTBCLEtBQUssa0JBQWtCO0FBRXZELGNBQUkseUJBQXlCO0FBQzNCLG1CQUFPOzs7QUFJWCxlQUFPOztNQUdULDJCQUEyQjtBQUN6QixjQUFNLHVCQUF1QixLQUFLLEtBQUssT0FBTyxDQUFDLFNBQUE7QUFDN0MsZ0JBQU0sc0JBQXNCLEtBQUs7QUFFakMsY0FBSSxxQkFBcUI7QUFDdkIsbUJBQU87OztBQUlYLGVBQU87O01BR1Qsc0NBQXNDLGNBQWMsY0FBYztBQUNoRSxjQUFNLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxVQUFBO0FBQzVCLGdCQUFNLFVBQVUsTUFBSyxpQ0FBaUMsY0FBYztBQUVwRSxjQUFJLFNBQVM7QUFDWCxtQkFBTzs7Y0FFTDtBQUVOLGVBQU87O2FBR0Ysd0JBQXdCLE9BQU8sYUFBYTtBQUNqRCxjQUFNLGdCQUFnQixJQUFJLGNBQWMsT0FBTztBQUUvQyxlQUFPOzs7QUFJSiw0QkFBd0IsT0FBTyxNQUFJO0FBQ3hDLFlBQU0sUUFBUSxNQUNSLFVBQVUsTUFBTSxLQUFLLENBQUMsVUFBQTtBQUNwQixjQUFNLFFBQVEsT0FDUixvQkFBb0IsTUFBTSxNQUFNO0FBRXRDLFlBQUksbUJBQW1CO0FBQ3JCLGlCQUFPOzs7QUFJakIsYUFBTzs7QUFHVCx5Q0FBcUMsVUFBVSxlQUFhO0FBQzFELFlBQU0sYUFBYSxLQUFLLFdBQ2xCLFFBQVEsU0FBUyxRQUFRLGFBQ3pCLFFBQVE7QUFFZCxpQkFBVyxTQUFTLE1BQU07QUFFMUIsZUFBUztBQUVULFlBQU0sU0FBUyxTQUFTLFFBQ2xCLFFBQVEsU0FBUyxJQUFJLENBQUMsUUFBUSxXQUFBO0FBQzVCLGNBQU0sWUFBYSxVQUFRLEtBQUssUUFDMUIsYUFBYSxTQUFTLFlBQ3RCLGVBQWUsUUFDZixlQUFlLFlBQ2YsT0FBTyxjQUFjLHNDQUFzQyxjQUFjO0FBRS9FLGVBQU87VUFFVCxRQUFRLE9BQUEsUUFBTSxVQUFVO0FBRTlCLGFBQU87O0FBR1Qsa0NBQThCLE9BQU8sVUFBUTtBQUMzQyxVQUFJLFNBQVM7QUFFYixZQUFNLFNBQVMsTUFBTTtBQUVyQixlQUFTLFNBQVMsR0FBRyxTQUFTLFFBQVEsVUFBVTtBQUM5QyxpQkFBUyxTQUFTO0FBRWxCLFlBQUksUUFBUTtBQUNWOztBQUdGLGdCQUFRLE1BQU07O0FBR2hCLGFBQU87O0FBR1QsaUNBQTZCLFFBQVEsUUFBTTtBQUN6QyxVQUFJLG1CQUFtQjtBQUV2QixZQUFNLGVBQWUsT0FBTyxhQUN0QixlQUFlLE9BQU87QUFFNUIsVUFBSSxpQkFBaUIsY0FBYztBQUNqQywyQkFBbUIscUJBQXFCLFFBQVEsQ0FBQyxZQUFBO0FBQy9DLGdCQUFNLGdCQUFnQixRQUFPLFVBQVU7QUFFdkMsY0FBSSxlQUFlO0FBQ2pCLG1CQUFPOzs7O0FBS2IsYUFBTzs7Ozs7QUM5UFQ7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLG9DQUEwQixjQUFBLGdCQUFlO2FBQy9DLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxjQUFBLGdCQUFnQiwyQ0FBMkMsYUFBYSxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDTC9NOzs7OzttQ0FFYSxnQkFBQTs7O2VBQUE7OztBQUFOLFFBQU0sZUFBZTs7OztBQ0Y1Qjs7Ozs7Ozs7Ozs7OztVQWdCZ0IsdUNBQUE7ZUFBQTs7VUFrQkEsaUVBQUE7ZUFBQTs7VUFOQSxzREFBQTtlQUFBOztVQXhCQSw4QkFBQTtlQUFBOztVQWtCQSx5Q0FBQTtlQUFBOztVQVpBLDhCQUFBO2VBQUE7Ozs7QUFOVCx5Q0FBcUMsVUFBUTtBQUNsRCxZQUFNLGtCQUFrQixHQUFHO0FBRTNCLGFBQU87O0FBR0YseUNBQXFDLGlCQUFlO0FBQ3pELFlBQU0sV0FBVyxnQkFBZ0IsUUFBUSxPQUFPLFdBQUE7QUFFaEQsYUFBTzs7QUFHRixrREFBOEMsVUFBUTtBQUMzRCxZQUFNLDJCQUEyQixHQUFHO0FBRXBDLGFBQU87O0FBR0Ysb0RBQWdELDRCQUEwQjtBQUMvRSxZQUFNLFdBQVcsMkJBQTJCLFFBQVEsU0FBUyxXQUFBO0FBRTdELGFBQU87O0FBR0YsaUVBQTZELDRCQUEwQjtBQUM1RixZQUFNLHdCQUF3QiwyQkFBMkIsUUFBUSxZQUFZLFdBQUE7QUFFN0UsYUFBTzs7QUFHRiw0RUFBd0UsVUFBVSx1QkFBcUI7QUFDNUcsWUFBTSw2QkFBNkIsR0FBRyxZQUFZO0FBRWxELGFBQU87Ozs7O0FDckNUOzs7Ozs7Ozs7Ozs7O1VBUWdCLHFCQUFBO2VBQUE7O1VBeUNBLGtDQUFBO2VBQUE7O1VBdkJBLHFCQUFBO2VBQUE7O1VBU0Esc0JBQUE7ZUFBQTs7Ozs7QUEvQmhCLFFBQU0sQ0FBRSxNQUFNLFlBQWEsV0FBQTtBQUlwQixnQ0FBNEIsT0FBTyxTQUFPO0FBQy9DLFlBQU0sWUFBWSxtQkFBbUIsUUFDL0IsZUFBZSxVQUFVLE9BQU8sQ0FBQyxlQUFjLGFBQUE7QUFDN0MsY0FBTSxrQkFBa0IsSUFBQSxVQUFBLDZCQUE0QixXQUM5QyxjQUFjLFFBQVEsb0JBQW9CO0FBRWhELFlBQUksZ0JBQWdCLE1BQU07QUFDeEIsd0JBQWEsS0FBSzs7QUFHcEIsZUFBTztTQUNOLEtBQ0gscUJBQXFCLGFBQWEsUUFDbEMsbUJBQW9CLHVCQUF1QjtBQUVqRCxhQUFPOztBQUdGLGdDQUE0QixPQUFPLFlBQVksSUFBRTtBQUN0RCxZQUFNLGdCQUFnQixNQUFNLGVBQ3RCLGlCQUFpQjtBQUV2QixXQUFLLFdBQVc7QUFFaEIsYUFBTzs7QUFHRixpQ0FBNkIsUUFBUSxZQUFZLElBQUU7QUFDeEQsYUFBTyxRQUFRLENBQUMsVUFBQTtBQUNkLDJCQUFtQixPQUFPOztBQUc1QixlQUFTLFdBQVcsQ0FBQyxXQUFXLGNBQUE7QUFDOUIsWUFBSSxjQUFjLFdBQVc7QUFDM0IsaUJBQU87OztBQUlYLGFBQU87O0FBR0YsNkNBQXlDLFVBQVUsUUFBTTtBQUM5RCxZQUFNLGFBQWEsT0FBTyxPQUFPLENBQUMsYUFBWSxVQUFBO0FBQzVDLGNBQU0sWUFBWSxtQkFBbUIsUUFDL0IsMkJBQTJCLFVBQVUsU0FBUztBQUVwRCxZQUFJLDBCQUEwQjtBQUM1QixnQkFBTSxZQUFZO0FBRWxCLHNCQUFXLEtBQUs7O0FBR2xCLGVBQU87U0FDTjtBQUVILGFBQU87Ozs7O0FDL0RUOzs7Ozs7Ozs7Ozs7O1VBa0NnQixxQkFBQTtlQUFBOztVQXJCQSxxQkFBQTtlQUFBOzs7OztBQVJoQixRQUFNLENBQUUsU0FBUyxjQUFjLGtCQUFtQixhQUFBO0FBQWxELFFBQ00sQ0FBRSxrQkFDQSxzQkFDQSx1QkFDQSx3QkFDQSx5QkFDQSwyQkFBNEIsY0FBQTtBQUU3QixnQ0FBNEIsTUFBTSxTQUFTLFlBQVksSUFBRTtBQUM5RCxVQUFJLG1CQUFtQjtBQUV2QixZQUFNLFdBQVcsS0FBSyxXQUNoQiw0QkFBNEIsVUFBVSxTQUFTO0FBRXJELFVBQUksQ0FBQywyQkFBMkI7QUFDOUIsb0JBQVk7YUFDUDtVQUNIOztBQUdGLGNBQU0sY0FBYyxLQUFLLGtCQUNuQiwwQkFBMEIsMkJBQTJCLGFBQWEsU0FBUztBQUVqRiwyQkFBbUI7O0FBR3JCLGFBQU87O0FBR0YsZ0NBQTRCLE1BQU0sU0FBUyxZQUFZLElBQUU7QUFDOUQsVUFBSTtBQUVKLFlBQU0sa0JBQWtCLEtBQUs7QUFFN0IsVUFBSSxpQkFBaUI7QUFDbkIsY0FBTSxlQUFlLE1BQ2YsMkJBQTJCLDJCQUEyQjtBQUU1RCwyQkFBbUI7YUFDZDtBQUNMLGNBQU0sbUJBQW1CLE1BQ25CLDhCQUE4Qiw4QkFBOEIsa0JBQWtCLFNBQVM7QUFFN0YsMkJBQW1COztBQUdyQixhQUFPOztBQUdULHdDQUFvQyxhQUFhLFNBQVMsV0FBUztBQUNqRSxZQUFNLDBCQUEwQixZQUFZLEtBQUssQ0FBQyxlQUFBO0FBQ2hELGNBQU0seUJBQXlCLHlCQUF5QixZQUFZLFNBQVM7QUFFN0UsWUFBSSx3QkFBd0I7QUFDMUIsaUJBQU87OztBQUlYLGFBQU87O0FBR1Qsc0NBQWtDLFlBQVksU0FBUyxXQUFTO0FBQzlELFlBQU0sUUFBUSxXQUFXLFlBQ25CLG9CQUFvQixxQkFBcUIsT0FBTyxTQUFTLFlBQ3pELHlCQUF5QjtBQUUvQixhQUFPOztBQUdULGtDQUE4QixPQUFPLFNBQVMsV0FBUztBQUNyRCxZQUFNLG9CQUFvQixNQUFNLE1BQU0sQ0FBQyxTQUFBO0FBQ3JDLGNBQU0sbUJBQW1CLG1CQUFtQixNQUFNLFNBQVM7QUFFM0QsWUFBSSxrQkFBa0I7QUFDcEIsaUJBQU87OztBQUlYLGFBQU87O0FBR1Qsd0NBQW9DLGNBQVk7QUFDOUMsVUFBSTtBQUVKLFlBQU0scUJBQXFCLGFBQWE7QUFFeEMsY0FBUTthQUNEO2FBQ0E7YUFDQSxnQkFBZ0I7QUFDbkIscUNBQTJCO0FBRTNCOztpQkFHTztBQUNQLHFDQUEyQjtBQUUzQjs7O0FBSUosYUFBTzs7QUFHVCwyQ0FBdUMsaUJBQWlCLFNBQVMsV0FBUztBQUN4RSxVQUFJLG1CQUFtQjtBQUV2QixZQUFNLE9BQU8sZ0JBQWdCO0FBRTdCLGNBQVE7YUFDRCxrQkFBa0I7QUFDckIsZ0JBQU0sZUFBZSxpQkFDZixXQUFXLGFBQWEsZUFDeEIsT0FBTyxRQUFRLGFBQWE7QUFFbEMsY0FBSSxTQUFTLE1BQU07QUFDakIsa0JBQU0sbUJBQW1CLG1CQUFtQixNQUFNLFNBQVM7QUFFM0QsK0JBQW1COztBQUdyQjs7YUFHRyxzQkFBc0I7QUFDekIsNkJBQW1CO0FBRW5COzthQUdHLHdCQUF3QjtBQUMzQixnQkFBTSxxQkFBcUIsaUJBQ3JCLE9BQU8sbUJBQW1CO0FBRWhDLDZCQUFtQixtQkFBbUIsTUFBTSxTQUFTO0FBRXJEOzthQUdHLHlCQUF5QjtBQUM1Qiw2QkFBbUI7QUFFbkI7O2FBR0cseUJBQXlCO0FBQzVCLGdCQUFNLHNCQUFzQixpQkFDdEIsUUFBUSxvQkFBb0IsWUFDNUIsb0JBQW9CLHFCQUFxQixPQUFPLFNBQVM7QUFFL0QsNkJBQW1CO0FBRW5COzthQUdHLHVCQUF1QjtBQUMxQixnQkFBTSxvQkFBb0IsaUJBQ3BCLFFBQVEsa0JBQWtCLFlBQzFCLG9CQUFvQixNQUFNLEtBQUssQ0FBQyxTQUFBO0FBQzlCLGtCQUFNLG9CQUFtQixtQkFBbUIsTUFBTSxTQUFTO0FBRTNELG1CQUFPOztBQUdmLDZCQUFtQjtBQUVuQjs7O0FBSUosYUFBTzs7Ozs7QUNoTFQ7Ozs7Ozs7Ozs7Ozs7VUFlZ0IsNEJBQUE7ZUFBQTs7VUFrQkEsdUNBQUE7ZUFBQTs7VUFWQSxpQ0FBQTtlQUFBOzs7Ozs7QUFoQmhCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBQWxCLFFBQ00sQ0FBRSxrQkFDQSxzQkFDQSx1QkFDQSx3QkFDQSx5QkFDQSwyQkFBNEIsY0FBQTtBQUU3Qix1Q0FBbUMsWUFBWSxTQUFPO0FBQzNELFlBQU0sUUFBUSxXQUFXLFlBQ25CLHFCQUFxQixzQkFBc0IsT0FBTyxVQUNsRCwwQkFBMEI7QUFFaEMsYUFBTzs7QUFHRiw0Q0FBd0MsTUFBTSxTQUFTLHlCQUF5QixJQUFFO0FBQ3ZGLFlBQU0sY0FBYyxLQUFLO0FBRXpCLGtCQUFZLFFBQVEsQ0FBQyxlQUFBO0FBQ25CLDZDQUFxQyxZQUFZLFNBQVM7O0FBRzVELGFBQU87O0FBR0Ysa0RBQThDLFlBQVksU0FBUyx5QkFBeUIsSUFBRTtBQUNuRyxZQUFNLFFBQVEsV0FBVztBQUV6QixzQ0FBZ0MsT0FBTyxTQUFTO0FBRWhELGFBQU87O0FBR1QsbUNBQStCLE9BQU8sU0FBTztBQUMzQyxZQUFNLHlCQUF5QixnQ0FBZ0MsT0FBTyxVQUNoRSwrQkFBK0IsdUJBQXVCLFFBQ3RELHFCQUFzQiwrQkFBK0I7QUFFM0QsYUFBTzs7QUFHVCw0Q0FBd0MsTUFBTSxTQUFTLHdCQUFzQjtBQUMzRSxZQUFNLHNCQUFzQixLQUFLO0FBRWpDLFVBQUkscUJBQXFCO0FBQ3ZCLGNBQU0sa0JBQWtCLE1BQ2xCLE9BQU8sZ0JBQWdCO0FBRTdCLGdCQUFRO2VBQ0Qsa0JBQWtCO0FBQ3JCLGtCQUFNLGVBQWUsaUJBQ2YsV0FBVyxhQUFhLGVBQ3hCLHlDQUF5Qyx1QkFBdUIsU0FBUztBQUUvRSxnQkFBSSxDQUFDLHdDQUF3QztBQUMzQyxvQkFBTSx3QkFBd0I7QUFFOUIscUNBQXVCLEtBQUs7O0FBRzlCOztlQUdHLHNCQUFzQjtBQUN6QixrQkFBTSxtQkFBbUIsaUJBQ25CLFFBQU8saUJBQWlCO0FBRTlCLDJDQUErQixPQUFNLFNBQVM7QUFFOUM7O2VBR0csd0JBQXdCO0FBQzNCLGtCQUFNLHFCQUFxQixpQkFDckIsUUFBTyxtQkFBbUI7QUFFaEMsMkNBQStCLE9BQU0sU0FBUztBQUU5Qzs7ZUFHRyx5QkFBeUI7QUFDNUIsa0JBQU0sc0JBQXNCLGlCQUN0QixRQUFPLG9CQUFvQjtBQUVqQywyQ0FBK0IsT0FBTSxTQUFTO0FBRTlDOztlQUdHLHlCQUF5QjtBQUM1QixrQkFBTSxzQkFBc0IsaUJBQ3RCLFFBQVEsb0JBQW9CLFlBQzVCLFlBQVksT0FBTSxRQUNsQixRQUFPO0FBRWIsMkNBQStCLE9BQU0sU0FBUztBQUU5Qzs7ZUFHRyx1QkFBdUI7QUFDMUIsa0JBQU0sb0JBQW9CLGlCQUNwQixRQUFRLGtCQUFrQjtBQUVoQyxrQkFBTSxRQUFRLENBQUMsVUFBQTtBQUNiLDZDQUErQixPQUFNLFNBQVM7O0FBR2hEOzs7OztBQU1SLDZDQUF5QyxPQUFPLFNBQVMseUJBQXlCLElBQUU7QUFDbEYsWUFBTSxNQUFNLENBQUMsU0FBQTtBQUNYLGNBQU0sbUJBQW1CLElBQUEsY0FBQSxvQkFBbUIsTUFBTTtBQUVsRCxZQUFJLENBQUMsa0JBQWtCO0FBQ3JCLHlDQUErQixNQUFNLFNBQVM7ZUFDekM7QUFDTCxpQkFBTzs7O0FBSVgsYUFBTzs7Ozs7QUN0SVQ7Ozs7O21DQUVBLFdBQUE7OztlQUFxQjs7O0FBQU4scUJBQU07TUFDbkIsWUFBWSxPQUFNLGNBQWMsY0FBYztBQUM1QyxhQUFLLFFBQVE7QUFDYixhQUFLLGVBQWU7QUFDcEIsYUFBSyxlQUFlOztNQUd0QixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLGtCQUFrQjtBQUNoQixlQUFPLEtBQUs7O01BR2Qsa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSzs7TUFHZCxvQkFBb0I7QUFDbEIsY0FBTSxrQkFBbUIsS0FBSyxpQkFBaUIsS0FBSztBQUVwRCxlQUFPOztNQUdULE1BQU0sTUFBTTtBQUNWLGNBQU0sUUFBUSxLQUFLLFlBQ2IsZUFBZSxLQUFLLG1CQUNwQixlQUFlLEtBQUssbUJBQ3BCLFVBQVUsS0FBSyxzQ0FBc0MsT0FBTyxjQUFjO0FBRWhGLGVBQU87O01BR1Qsa0JBQWtCLGNBQWM7QUFDOUIsY0FBTSxzQkFBdUIsS0FBSyxpQkFBaUI7QUFFbkQsZUFBTzs7TUFHVCxrQkFBa0IsY0FBYztBQUM5QixjQUFNLHNCQUF1QixLQUFLLGlCQUFpQjtBQUVuRCxlQUFPOztNQUdULGlDQUFpQyxjQUFjLGNBQWM7QUFDM0QsY0FBTSxVQUFZLEtBQUssaUJBQWlCLGdCQUFrQixLQUFLLGlCQUFpQjtBQUVoRixlQUFPOztNQUdULHNDQUFzQyxPQUFPLGNBQWMsY0FBYztBQUN2RSxjQUFNLFVBQVksS0FBSyxVQUFVLFNBQVcsS0FBSyxpQkFBaUIsZ0JBQWtCLEtBQUssaUJBQWlCO0FBRTFHLGVBQU87O2FBR0YscUNBQXFDLE9BQU8sY0FBYyxjQUFjO0FBQzdFLGNBQU0sT0FBTyxJQUFJLEtBQUssT0FBTyxjQUFjO0FBRTNDLGVBQU87Ozs7OztBQy9EWDs7Ozs7bUNBV2dCLDhCQUFBOzs7ZUFBQTs7OztBQVBoQixRQUFNLENBQUUsa0JBQ0Esc0JBQ0EsdUJBQ0Esd0JBQ0EseUJBQ0EsMkJBQTRCLGNBQUE7QUFFN0Isd0NBQW9DLE1BQU0scUJBQXFCLElBQUU7QUFDdEUsWUFBTSxjQUFjLEtBQUs7QUFFekIsa0JBQVksUUFBUSxDQUFDLGVBQUE7QUFDbkIseUNBQWlDLFlBQVk7O0FBRy9DLGFBQU87O0FBR1QsOENBQTBDLFlBQVkscUJBQXFCLElBQUU7QUFDM0UsWUFBTSxRQUFRLFdBQVc7QUFFekIsa0NBQTRCLE9BQU87QUFFbkMsYUFBTzs7QUFHVCx5Q0FBcUMsT0FBTyxxQkFBcUIsSUFBRTtBQUNqRSxZQUFNLFFBQVEsQ0FBQyxTQUFBO0FBQ2IsbUNBQTJCLE1BQU07O0FBR25DLGFBQU87O0FBR1Qsd0NBQW9DLE1BQU0sb0JBQWtCO0FBQzFELFlBQU0sc0JBQXNCLEtBQUs7QUFFakMsVUFBSSxxQkFBcUI7QUFDdkIsY0FBTSxrQkFBa0IsTUFDbEIsT0FBTyxnQkFBZ0I7QUFFN0IsZ0JBQVE7ZUFDRCxrQkFBa0I7QUFDckIsa0JBQU0sZUFBZSxpQkFDZixXQUFXLGFBQWEsZUFDeEIscUNBQXFDLG1CQUFtQixTQUFTO0FBRXZFLGdCQUFJLENBQUMsb0NBQW9DO0FBQ3ZDLG9CQUFNLG9CQUFvQjtBQUUxQixpQ0FBbUIsS0FBSzs7QUFHMUI7O2VBR0csc0JBQXNCO0FBQ3pCLGtCQUFNLG1CQUFtQixpQkFDbkIsUUFBTyxpQkFBaUI7QUFFOUIsdUNBQTJCLE9BQU07QUFFakM7O2VBR0csd0JBQXdCO0FBQzNCLGtCQUFNLHFCQUFxQixpQkFDckIsUUFBTyxtQkFBbUI7QUFFaEMsdUNBQTJCLE9BQU07QUFFakM7O2VBR0cseUJBQXlCO0FBQzVCLGtCQUFNLHNCQUFzQixpQkFDdEIsUUFBTyxvQkFBb0I7QUFFakMsdUNBQTJCLE9BQU07QUFFakM7O2VBR0cseUJBQXlCO0FBQzVCLGtCQUFNLHNCQUFzQixpQkFDdEIsUUFBUSxvQkFBb0I7QUFFbEMsa0JBQU0sUUFBUSxDQUFDLFVBQUE7QUFDYix5Q0FBMkIsT0FBTTs7QUFHbkM7O2VBR0csdUJBQXVCO0FBQzFCLGtCQUFNLG9CQUFvQixpQkFDcEIsUUFBUSxrQkFBa0I7QUFFaEMsa0JBQU0sUUFBUSxDQUFDLFVBQUE7QUFDYix5Q0FBMkIsT0FBTTs7QUFHbkM7Ozs7Ozs7O0FDekdSOzs7Ozs7Ozs7Ozs7O1VBR2EsdUJBQUE7ZUFBQTs7VUFEQSxrQkFBQTtlQUFBOzs7QUFBTixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLHVCQUF1Qjs7OztBQ0hwQzs7Ozs7Ozs7Ozs7OztVQWdDZ0IsMkNBQUE7ZUFBQTs7VUF4QkEscUJBQUE7ZUFBQTs7VUFjQSxxQkFBQTtlQUFBOzs7Ozs7Ozs7Ozs7QUFkVCxnQ0FBNEIsV0FBUztBQUMxQyxZQUFNLFNBQVMsVUFBVSxRQUNuQixRQUFRLFVBQVUsSUFBSSxDQUFDLFVBQVUsVUFBQTtBQUMvQixjQUFNLFlBQWEsU0FBUSxLQUFLLFFBQzFCLGVBQWUsVUFBVSxZQUN6Qix3QkFBd0IsY0FDeEIsT0FBTyx5Q0FBeUMsVUFBVTtBQUVoRSxlQUFPOztBQUdmLGFBQU87O0FBR0YsZ0NBQTRCLFdBQVcsU0FBUyxjQUFZO0FBQ2pFLFlBQU0sT0FBTyxXQUNQLFFBQVEsSUFDUixXQUFXO0FBRWpCLG9CQUFjLE1BQU0sT0FBTyxVQUFVLFNBQVM7QUFFOUMsYUFBTzs7QUFHRixzREFBa0QsVUFBVSx1QkFBcUI7QUFDdEYsWUFBTSxRQUFRLFFBQUEsc0JBQ1IsZUFBZSxVQUNmLGVBQWUsdUJBQ2YsT0FBTyxNQUFBLFFBQUsscUNBQXFDLE9BQU8sY0FBYztBQUU1RSxhQUFPOztBQUdULDJCQUF1QixNQUFNLE9BQU8sVUFBVSxTQUFTLGNBQVk7QUFDakUsWUFBTSxXQUFXLEtBQUssV0FDaEIsU0FBUyxVQUNULHlCQUF5QixTQUFTLFNBQVM7QUFFakQsVUFBSSx3QkFBd0I7QUFDMUI7O0FBR0YsaUJBQVc7V0FDTjtRQUNIOztBQUdGLFlBQU0sWUFBWSxhQUFhLFdBQ3pCLHFCQUFxQixJQUFBLFdBQUEsNEJBQTJCLE9BQ2hELHlCQUF5QjtBQUUvQix5QkFBbUIsUUFBUSxDQUFDLHNCQUFBO0FBQzFCLGNBQU0sa0RBQWtELHVCQUF1QixTQUFTLG9CQUNsRix3QkFBd0IsbUJBQ3hCLFFBQVEsa0RBQ0UsUUFBQSx1QkFDRSxRQUFBLGlCQUNaLGVBQWUsVUFDZixlQUFlLHVCQUNmLE9BQU8sTUFBQSxRQUFLLHFDQUFxQyxPQUFPLGNBQWMsZUFDdEUsVUFBVSxJQUFBLGVBQUEsZ0JBQWUsT0FBTztBQUV0QyxZQUFJLENBQUMsU0FBUztBQUNaLGdCQUFNLEtBQUs7O0FBR2IsY0FBTSxnQkFBZ0IsUUFBUSxzQkFBc0I7QUFFcEQsWUFBSSxrQkFBa0IsTUFBTTtBQUMxQixnQkFBTSxRQUFPO0FBRWIsd0JBQWMsT0FBTSxPQUFPLFVBQVUsU0FBUzs7Ozs7OztBQy9FcEQ7Ozs7O21DQVlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7Ozs7O0FBQU4sb0NBQTBCLGNBQUEsS0FBSTtNQUMzQyw0QkFBNEIsVUFBVSxPQUFPO0FBQzNDLGNBQU0sa0JBQWtCLFNBQUE7QUFFeEIsZUFBTzs7YUFHRixrQkFBa0IsTUFBTSxRQUFRLFNBQVM7QUFDOUMsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxjQUFjLE1BQ2QsY0FBYyxLQUFLO0FBRXZCLHNCQUFjLFlBQVksT0FBTyxDQUFDLGVBQUE7QUFDaEMsZ0JBQU0sMEJBQTBCLHNCQUFzQixZQUFZLFVBQVUsUUFBUTtBQUVwRixjQUFJLHlCQUF5QjtBQUMzQixtQkFBTzs7O0FBSVgsY0FBTSxvQkFBb0IsWUFBWTtBQUV0QyxZQUFJLG9CQUFvQixHQUFHO0FBQ3pCLGdCQUFNLFlBQVcsS0FBSyxXQUNoQixrQkFBa0IsSUFBQSxVQUFBLDZCQUE0QixZQUM5QyxPQUFPLGlCQUNQLFVBQVUsS0FBSztBQUVyQix3QkFBYyxJQUFJLFlBQVksTUFBTSxTQUFTOztBQUcvQyxlQUFPOzs7QUFJWCxtQ0FBK0IsWUFBWSxVQUFVLFFBQVEsU0FBTztBQUNsRSxZQUFNLHlCQUF5QixJQUFBLGVBQUEsc0NBQXFDLFlBQVksVUFDMUUsc0JBQXNCLHVCQUF1QixNQUFNLENBQUMsMEJBQUE7QUFDbEQsY0FBTSxnREFBZ0QsT0FBTyxLQUFLLENBQUMsVUFBQTtBQUNqRSxnQkFBTSxnREFBZ0QsaURBQWlELE9BQU8sVUFBVTtBQUV4SCxjQUFJLCtDQUErQztBQUNqRCxtQkFBTzs7O0FBSVgsWUFBSSxDQUFDLCtDQUErQztBQUNsRCxpQkFBTzs7O0FBSWpCLGFBQU87O0FBR1QsOERBQTBELE9BQU8sVUFBVSx1QkFBcUI7QUFDOUYsWUFBTSxZQUFZLElBQUEsT0FBQSxvQkFBbUIsUUFDL0IsT0FBTyxJQUFBLGdCQUFBLDBDQUF5QyxVQUFVLHdCQUMxRCxRQUFRLElBQUEsZ0JBQUEsb0JBQW1CLFlBQzNCLFVBQVUsSUFBQSxlQUFBLGdCQUFlLE9BQU8sT0FDaEMsZ0RBQWdEO0FBRXRELGFBQU87Ozs7O0FDMUVUOzs7OzttQ0FNQSxXQUFBOzs7ZUFBd0I7Ozs7Ozs7Ozs7QUFBVCxnQ0FBNEIsUUFBUSxTQUFPO0FBQ3hELFlBQU0sWUFBWSxJQUFBLE9BQUEscUJBQW9CO0FBRXRDLGdCQUFVLFFBQVEsQ0FBQyxhQUFBO0FBQ2pCLGNBQU0sT0FBTyxRQUFRLFdBQ2YsY0FBYyxTQUFBLFFBQVksa0JBQWtCLE1BQU0sUUFBUTtBQUVoRSxZQUFJLGdCQUFnQixNQUFNO0FBQ3hCLGdCQUFNLGtCQUFrQixZQUFZO0FBRXBDLGtCQUFRLG1CQUFtQjs7Ozs7OztBQ2hCakM7Ozs7O21DQUVnQixrQ0FBQTs7O2VBQUE7OztBQUFULDRDQUF3QyxpQkFBZTtBQUM1RCxVQUFJO0FBRUosWUFBTSxvQ0FBb0MsZ0JBQWdCLGNBQWMsQ0FBQyxjQUFBO0FBQ2pFLGNBQU0sMkJBQTJCLFVBQVU7QUFFM0MsWUFBSSwwQkFBMEI7QUFDNUIsZ0JBQU0sdUJBQXVCLFdBQ3ZCLHFDQUFvQywrQkFBK0I7QUFFekUsY0FBSSxvQ0FBbUM7QUFDckMsbUJBQU87Ozs7QUFLbkIsVUFBSSxtQ0FBbUM7QUFDckMsdUNBQStCO2FBQzFCO0FBQ0wsY0FBTSxhQUFhLGdCQUFnQjtBQUVuQyxZQUFJLGVBQWUsTUFBTTtBQUN2QixnQkFBTSxXQUFXLGdCQUFnQjtBQUVqQyx5Q0FBK0IsZ0JBQWdCLGNBQWMsQ0FBQyxjQUFBO0FBQzVELGtCQUFNLDJCQUEyQixVQUFVLGtCQUFrQixVQUFVO0FBRXZFLGdCQUFJLDBCQUEwQjtBQUM1QixxQkFBTzs7Ozs7QUFNZixhQUFPOzs7OztBQ3BDVDs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLDZDQUFtQyxjQUFBLGdCQUFlO01BQy9ELFFBQVEsT0FBTztBQUNiLGNBQU0sa0JBQWtCLEtBQUs7QUFFN0IsUUFBQSxJQUFBLFNBQUEsOEJBQTZCLGlCQUFpQjtBQUU5QyxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxjQUFBLGdCQUFnQiwyQ0FBMkMsc0JBQXNCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNmeE47Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLCtDQUFxQyxjQUFBLGdCQUFlO01BQ2pFLFlBQVk7QUFDVixZQUFJLFVBQVU7QUFFZCxjQUFNLFdBQVcsS0FBSztBQUV0QixZQUFJLFVBQVU7QUFDWixvQkFBVSxLQUFLLGVBQWUsQ0FBQyxjQUFBO0FBQzdCLGdCQUFJLHFCQUFxQixjQUFBLGFBQWE7QUFDcEMscUJBQU87Ozs7QUFLYixlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxjQUFBLGdCQUFnQiwyQ0FBMkMsd0JBQXdCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNyQjFOOzs7Ozs7Ozs7Ozs7O1VBOERnQiwrQkFBQTtlQUFBOztVQVVBLGlDQUFBO2VBQUE7O1VBNURBLHNCQUFBO2VBQUE7Ozs7Ozs7Ozs7Ozs7QUFGaEIsUUFBTSxDQUFFLFFBQVMsV0FBQTtBQUVWLGlDQUE2QixpQkFBaUIsT0FBSztBQUN4RCxVQUFJO0FBRUosWUFBTSw0QkFBNEIsZ0JBQWdCLGNBQWMsQ0FBQyxXQUFXLFVBQUE7QUFDMUUsWUFBSSxVQUFVLEdBQUc7QUFDZixjQUFJLHFCQUFxQixTQUFBLFNBQWE7QUFDcEMsK0JBQW1CO0FBRW5CLG1CQUFPOzs7O0FBS2IsVUFBSSxDQUFDLDJCQUEyQjtBQUM5Qjs7QUFHRixZQUFNLGFBQWEsaUJBQ2Isb0JBQW9CLGtCQUNwQiwyQkFBMkIsa0JBQWtCLGNBQzdDLDRCQUE0QixrQkFBa0IsZUFDOUMsOEJBQThCLGtCQUFrQixpQkFDaEQsOEJBQThCLGtCQUFrQixvQkFDaEQscUJBQXFCLFdBQVcsZUFDaEMsa0JBQWtCLDJCQUNsQixpQkFBaUIsb0JBQ2pCLGFBQWEsNkJBQ2IsVUFBVSwwQkFDVixXQUFXLElBQUEsVUFBQSw2QkFBNEI7QUFFN0MsVUFBSTtBQUVKLFVBQUksYUFBYSxnQkFBZ0I7QUFDL0IsZ0NBQXdCO0FBRXhCLG1CQUFXLGNBQWM7YUFDcEI7QUFDTCxjQUFNLGFBQWEsNkJBQ2Isa0JBQWtCLE1BQU0sNEJBQTRCLFdBQ3BELG1CQUFrQixnQkFBZ0IsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLGFBQzVHLHVCQUF1QjtBQUU3QixnQ0FBd0I7VUFDdEI7OztBQUlKLGlCQUFXLGlCQUFpQixtQkFBbUI7O0FBRzFDLDBDQUFzQyxpQkFBaUIsT0FBSztBQUNqRSxVQUFJO0FBRUosc0NBQWdDLDZCQUE2QjtBQUU3RCxhQUFPLCtCQUErQjtBQUNwQyx3Q0FBZ0MsNkJBQTZCOzs7QUFJMUQsNENBQXdDLGlCQUFpQixPQUFLO0FBQ25FLFVBQUksYUFBYTtBQUVqQixZQUFNLDBCQUEwQiw0QkFBNEI7QUFFNUQsOEJBQXdCLFFBQVEsQ0FBQywyQkFBQTtBQUMvQixjQUFNLG9CQUFvQix5REFBeUQsWUFBWSx3QkFBd0IsUUFDakgsYUFBYSw2REFBNkQsbUJBQW1CO0FBRW5HLG1DQUEyQixZQUFZO0FBRXZDLG1CQUFXLGNBQWM7QUFFekIscUJBQWE7O0FBR2YsYUFBTzs7QUFHVCwrQkFBMkIsaUJBQWlCLGNBQVk7QUFDdEQsVUFBSTtBQUVKLFVBQUksV0FBVztBQUVmLHNCQUFnQix1QkFBdUIsQ0FBQyxXQUFXLFVBQUE7QUFDakQsY0FBTSx3QkFBeUIscUJBQXFCO0FBRXBELFlBQUksdUJBQXVCO0FBQ3pCLHFCQUFXLFFBQVE7QUFFbkIsaUJBQU87OztBQUlYLFVBQUksYUFBYSxJQUFJO0FBQ25CLHdCQUFnQjthQUNYO0FBQ0wsWUFBSTtBQUVKLHdCQUFnQix1QkFBdUIsQ0FBQyxXQUFXLFVBQUE7QUFDakQsZ0JBQU0sd0JBQXlCLHFCQUFxQjtBQUVwRCxjQUFJLENBQUMsdUJBQXVCO0FBQzFCLGdCQUFJLFFBQVEsVUFBVTtBQUNwQixxQkFBTzs7O0FBSVgsdUJBQWE7O0FBR2YsY0FBTSxhQUFhLGdCQUFnQixnQkFBZ0IsWUFBWTtBQUUvRCx3QkFBZ0I7O0FBR2xCLGFBQU87O0FBR1QsbUNBQStCLFlBQVU7QUFDdkMsWUFBTSxlQUFlLFdBQVcsbUJBQzFCLGNBQWMsZUFBZSxHQUM3QixRQUFRLEdBQ1IseUJBQXlCLFdBQVcsaUJBQWlCLE9BQU87QUFFbEUsYUFBTzs7QUFHVCx1Q0FBbUMsaUJBQWU7QUFDaEQsWUFBTSx3QkFBd0Isa0JBQWtCLGlCQUFpQixVQUFBO0FBRWpFLGFBQU87O0FBR1QseUNBQXFDLGlCQUFlO0FBQ2xELFlBQU0sMEJBQTBCLGtCQUFrQixpQkFBaUIsWUFBQTtBQUVuRSw4QkFBd0I7QUFFeEIsYUFBTzs7QUFHVCwwQ0FBc0MsaUJBQWU7QUFDbkQsVUFBSSxnQ0FBZ0M7QUFFcEMsWUFBTSx3QkFBd0IsMEJBQTBCLGtCQUNsRCw4QkFBOEIsc0JBQXNCO0FBRTFELFVBQUksOEJBQThCLEdBQUc7QUFDbkMsY0FBTSxhQUFhLGlCQUNiLHFCQUFxQix1QkFDckIsd0JBQXdCO0FBRTlCLDhCQUFzQixRQUFRLENBQUMseUJBQUE7QUFDN0IsZ0JBQU0sa0NBQWtDLHFCQUFxQjtBQUU3RCxlQUFLLHVCQUF1Qjs7QUFHOUIsbUJBQVcsa0JBQWtCLG9CQUFvQjtBQUVqRCx3Q0FBZ0M7O0FBR2xDLGFBQU87O0FBR1Qsd0NBQW9DLFlBQVksd0JBQXNCO0FBQ3BFLFlBQU0saUNBQWlDLHVCQUF1QixlQUN4RCw2QkFBNkIsZ0NBQzdCLHlCQUF5QixXQUFXLGVBQ3BDLFdBQVcsSUFBQSxVQUFBLHdDQUF1QztBQUV4RCxVQUFJLDJCQUEyQixVQUFVO0FBQ3ZDLGNBQU0sYUFBYSx1QkFBdUI7QUFFMUMsbUJBQVcsY0FBYzs7O0FBSTdCLHNFQUFrRSxZQUFZLHdCQUF3QixPQUFLO0FBQ3pHLFlBQU0saUNBQWlDLHVCQUF1QixlQUN4RCxnQ0FBZ0MsdUJBQXVCLGNBQ3ZELDZCQUE2QixnQ0FDN0IseUJBQXlCLHNCQUFzQixhQUMvQyx3QkFBd0IsSUFBQSxVQUFBLHFEQUFvRCw2QkFDNUUsV0FBVyx1QkFDWCxhQUFhLHdCQUNiLFVBQVUsK0JBQ1YsYUFBYSxNQUNiLGtCQUFrQixNQUFNLDRCQUE0QixXQUNwRCxrQkFBa0IsZ0JBQWdCLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxhQUM1RyxvQkFBb0I7QUFFMUIsYUFBTzs7QUFHVCwwRUFBc0UsbUJBQW1CLHdCQUFzQjtBQUM3RyxZQUFNLGFBQWE7UUFDWDtTQUVGLGdDQUFnQyx1QkFBdUI7QUFFN0QsVUFBSSxDQUFDLCtCQUErQjtBQUNsQyxjQUFNLG9CQUFvQix1QkFBdUI7QUFFakQsYUFBSyxZQUFZOztBQUduQixhQUFPOzs7OztBQzdOVDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7QUFBTixzQ0FBNEIsY0FBQSxnQkFBZTtNQUN4RCxRQUFRLE9BQU87QUFDYixZQUFJO0FBRUosY0FBTSxXQUFXLEtBQUssZUFDaEIsa0JBQWtCLE1BQU0sNEJBQTRCO0FBRTFELDBCQUFrQixLQUFLO0FBRXZCLGNBQU0sVUFBVSxnQkFBZ0IsY0FDMUIsYUFBYSxnQkFBZ0IsaUJBQzdCLGFBQWEsZ0JBQWdCO0FBRW5DLDBCQUFrQixnQkFBZ0IsMkNBQTJDLFVBQVUsWUFBWSxTQUFTO0FBRTVHLFFBQUEsSUFBQSxTQUFBLDhCQUE2QixpQkFBaUI7QUFFOUMsY0FBTSxhQUFhLElBQUEsU0FBQSxnQ0FBK0IsaUJBQWlCO0FBRW5FO0FBQ0UsZ0JBQU0sbUJBQWtCO0FBRXhCLFVBQUEsSUFBQSxTQUFBLHFCQUFvQixrQkFBaUI7O0FBR3ZDLGVBQU87O01BR1Qsa0JBQWtCO0FBQ2hCLGNBQU0sa0JBQWtCLE1BQ2xCLCtCQUErQixJQUFBLFlBQUEsZ0NBQStCLGtCQUM5RCxnQkFBZ0I7QUFFdEIsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sY0FBQSxnQkFBZ0IsMkNBQTJDLGVBQWUsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQzNDak47Ozs7Ozs7Ozs7Ozs7VUF5QmdCLDBDQUFBO2VBQUE7O1VBdkJBLG1CQUFBO2VBQUE7OztBQUFULDhCQUEwQixXQUFXLFVBQVE7QUFDbEQsVUFBSSxPQUNFO0FBRU4sWUFBTSxRQUFRLFVBQVUsUUFBUTtBQUVoQyxjQUFRO0FBRVIsWUFBTTtBQUVOLFlBQU0sbUJBQW1CLFVBQVUsTUFBTSxPQUFPO0FBRWhELGNBQVE7QUFFUixZQUFNLG9CQUFvQixVQUFVLE1BQU0sUUFDcEMsb0JBQW9CO1dBQ2Y7V0FDQTs7QUFHWCxhQUFPOztBQUdGLHFEQUFpRCxXQUFXLFVBQVE7QUFDekUsWUFBTSxrQkFBa0IsVUFBVSxRQUM1QixZQUFZLGtCQUFrQjtBQUVwQyxnQkFBVSxRQUFRLENBQUMsVUFBVSxVQUFBO0FBQzNCLGNBQU0sWUFBYSxVQUFVLFlBQ1QsSUFDRSxRQUFRLEdBQ1osd0JBQXdCLFVBQVU7QUFFcEQsaUJBQVMsVUFBVSx1QkFBdUI7Ozs7OztBQ25DOUM7Ozs7Ozs7Ozs7Ozs7VUFNZ0IsMkJBQUE7ZUFBQTs7VUFNQSw4QkFBQTtlQUFBOzs7O0FBUmhCLFFBQU0sQ0FBRSxjQUFjLHVCQUF3QixjQUFBO0FBRXZDLHNDQUFrQyxVQUFRO0FBQy9DLFlBQU0sZUFBZSxhQUFhLGFBQWE7QUFFL0MsYUFBTzs7QUFHRix5Q0FBcUMsTUFBSTtBQUM5QyxZQUFNLHNCQUFzQixvQkFBb0IsU0FBUztBQUV6RCxhQUFPOzs7OztBQ2ZUOzs7Ozs7Ozs7Ozs7O1VBV2dCLGdCQUFBO2VBQUE7O1VBYUEsc0JBQUE7ZUFBQTs7VUFxREEsNkJBQUE7ZUFBQTs7VUFUQSwwQkFBQTtlQUFBOztVQTJEQSw4QkFBQTtlQUFBOzs7Ozs7OztBQXRIaEIsUUFBTSxDQUFFLE1BQU0sT0FBTyxZQUFhLFdBQUE7QUFFM0IsMkJBQXVCLE9BQU8sT0FBSztBQUN4QyxZQUFNLGFBQWEsT0FDYixhQUFhLE9BQ2IsaUJBQWlCLE1BQU0sWUFBWSxZQUFZLENBQUMsV0FBVyxjQUFBO0FBQ3pELFlBQUksY0FBYyxXQUFXO0FBQzNCLGlCQUFPOztVQUdYLGFBQWE7QUFFbkIsYUFBTzs7QUFHRixpQ0FBNkIsT0FBTyxPQUFPLFVBQVUsU0FBUyxjQUFZO0FBQy9FLFVBQUk7QUFFSixZQUFNLGNBQWMsTUFBTSxRQUNwQixjQUFjLE1BQU07QUFFMUIsVUFBSSxPQUFPO2lCQUVDLGdCQUFnQixHQUFJO0FBQzlCLHFCQUFhO2lCQUNILGdCQUFnQixHQUFJO0FBQzlCLHFCQUFhO2lCQUNILGdCQUFnQixLQUFPLGdCQUFnQixHQUFJO0FBQ3JELHFCQUFhO2lCQUNILGdCQUFnQixHQUFJO0FBQzlCLHFCQUFhO2lCQUNILGdCQUFnQixHQUFJO0FBQzlCLHFCQUFhO2FBQ1I7QUFDTCxjQUFNLGFBQWEsTUFBTSxTQUNuQixhQUFhLE1BQU0sU0FDbkIsWUFBWSxXQUFXLFNBQ3ZCLFlBQVksV0FBVztBQUU3QixZQUFJLGNBQWMsV0FBVztBQUMzQixrQkFBUTtBQUVSLGtCQUFRO0FBRVIscUJBQVc7QUFFWCx1QkFBYSxvQkFBb0IsT0FBTyxPQUFPLFVBQVUsU0FBUztlQUM3RDtBQUNMLGdCQUFNLFlBQVksYUFBYSxXQUN6QixTQUFTLFVBQVUsUUFBUSxZQUMzQixTQUFTLFVBQVUsUUFBUTtBQUVqQyx1QkFBYyxTQUFTOzs7QUFJM0IsYUFBTzs7QUFHRixxQ0FBaUMsTUFBSTtBQUMxQyxZQUFNLFlBQVksTUFDWixlQUFlLEtBQUssWUFDcEIsV0FBVyxjQUNYLGtCQUFrQixJQUFBLFVBQUEsNkJBQTRCO0FBRXBELGFBQU87O0FBR0Ysd0NBQW9DLFVBQVUsUUFBUSxTQUFTLGNBQVk7QUFDaEYsWUFBTSxRQUFRLE9BQU8sT0FBTyxDQUFDLFFBQU8sVUFBQTtBQUNsQyxjQUFNLFlBQVksSUFBQSxPQUFBLG9CQUFtQixRQUMvQiw0QkFBNEIsVUFBVSxTQUFTO0FBRXJELFlBQUksMkJBQTJCO0FBQzdCLGdCQUFNLG9CQUFvQixJQUFBLFdBQUEsa0JBQWlCLFdBQVcsV0FDaEQsT0FBTztBQUViLGlCQUFNLEtBQUs7O0FBR2IsZUFBTztTQUNOO0FBRUgsVUFBSTtBQUVKLFlBQU0sUUFBUSxDQUFDLFNBQUE7QUFDYixpQkFBUyxLQUFLO0FBRWQsZUFBTyxTQUFTLEdBQUc7QUFDakIsaUJBQU8sS0FBSztBQUVaLGVBQUs7QUFFTCxnQkFBTSxLQUFLO0FBRVgsbUJBQVMsS0FBSzs7O0FBSWxCLGVBQVMsT0FBTyxDQUFDLE9BQU8sVUFBQTtBQUN0QixjQUFNLGFBQWEsY0FBYyxPQUFPO0FBRXhDLFlBQUksQ0FBQyxZQUFZO0FBQ2YsaUJBQU87OztBQUlYLGlCQUFXO0FBRVgsWUFBTSxLQUFLLENBQUMsT0FBTyxVQUFBO0FBQ2pCLGNBQU0sYUFBYSxvQkFBb0IsT0FBTyxPQUFPLFVBQVUsU0FBUztBQUV4RSxlQUFPOztBQUdULGFBQU87O0FBR0YseUNBQXFDLE1BQUk7QUFDOUMsWUFBTSxrQkFBa0Isd0JBQXdCLE9BQzFDLHNCQUFzQixJQUFBLE1BQUEsMEJBQXlCO0FBRXJELGFBQU87Ozs7O0FDbklUOzs7OzttQ0FZQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsaUJBQVUsV0FBQTtBQUVILDRDQUFrQyxjQUFBLFdBQVU7YUFDbEQsU0FBUyxNQUFNLFNBQVM7QUFDN0IsWUFBSSxzQkFBc0I7QUFFMUIsY0FBTSxrQkFBa0IsSUFBQSxNQUFBLHlCQUF3QixPQUMxQyxjQUFjLFFBQVEsb0JBQW9CO0FBRWhELFlBQUksZ0JBQWdCLE1BQU07QUFDeEIsZ0NBQXNCLDRCQUE0Qjs7QUFHcEQsZUFBTzs7O0FBSVgseUJBQXFCLE1BQUk7QUFDdkIsWUFBTSxlQUFlLEtBQUs7QUFFMUIsbUJBQWE7QUFFYixhQUFPOztBQUdULHlDQUFxQyxNQUFJO0FBQ3ZDLFlBQU0sc0JBQXNCLElBQUEsTUFBQSw2QkFBNEIsT0FDbEQsZUFBZSxZQUFZLE9BQzNCLFlBQVksY0FDWixrQkFBa0IsVUFBVSxRQUM1QixZQUFZLGtCQUFrQixHQUM5QixRQUFRO0FBRWQsWUFBTSxLQUFLO0FBRVgsTUFBQSxJQUFBLFdBQUEseUNBQXdDLFdBQVcsQ0FBQyxVQUFVLHVCQUF1QixVQUFBO0FBQ25GLFlBQUksUUFBUSxXQUFXO0FBQ3JCLGdCQUFNLHVCQUF1QixpQ0FBaUM7QUFFOUQsZ0JBQU0sS0FBSztBQUVYLGdCQUFNLG9CQUFvQjtBQUUxQixrQ0FBd0I7QUFFeEIscUJBQVc7QUFFWCxnQkFBTSx5QkFBeUIsMkRBQTJELFVBQVU7QUFFcEcsZ0JBQU0sS0FBSzs7O0FBSWYsVUFBSSxvQkFBb0IsR0FBRztBQUN6QixjQUFNLGdCQUFnQixPQUFNLFlBQ3RCLFdBQVcsZUFDWCx1QkFBdUIsaUNBQWlDO0FBRTlELGNBQU0sS0FBSzs7QUFHYixZQUFNLGFBQWEsTUFDYixzQkFBc0IsSUFBSSxvQkFBb0IsT0FBTztBQUUzRCxhQUFPOztBQUdULDhDQUEwQyxVQUFRO0FBQ2hELFlBQU0sMkJBQTJCLElBQUEsVUFBQSxzQ0FBcUMsV0FDaEUsK0JBQStCLElBQUEsTUFBQSwwQkFBeUIsMkJBQ3hELDhDQUE4QyxJQUFBLE1BQUEsNkJBQTRCLCtCQUMxRSx1QkFBdUI7QUFFN0IsYUFBTzs7QUFHVCx3RUFBb0UsVUFBVSx1QkFBcUI7QUFDakcsWUFBTSw2QkFBNkIsSUFBQSxVQUFBLGdFQUErRCxVQUFVLHdCQUN0RyxpQ0FBaUMsSUFBQSxNQUFBLDBCQUF5Qiw2QkFDMUQseUJBQXlCO0FBRS9CLGFBQU87Ozs7O0FDM0ZUOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUFOLHNDQUE0QixjQUFBLEtBQUk7TUFDN0MsNEJBQTRCLFVBQVUsT0FBTztBQUMzQyxjQUFNLGtCQUFrQixXQUFBO0FBRXhCLGVBQU87O2FBR0Ysa0JBQWtCLE1BQU0sUUFBUSxTQUFTLGNBQWM7QUFDNUQsY0FBTSxjQUFjLElBQ2QsV0FBVyxLQUFLLFdBQ2hCLFFBQVEsSUFBQSxNQUFBLDRCQUEyQixVQUFVLFFBQVEsU0FBUztBQUVwRSxjQUFNLFFBQVEsQ0FBQyxTQUFBO0FBQ2IsZ0JBQU0sc0JBQXNCLFlBQUEsUUFBb0IsU0FBUyxNQUFNO0FBRS9ELGNBQUksd0JBQXdCLE1BQU07QUFDaEMsa0JBQU0sYUFBYTtBQUVuQix3QkFBWSxLQUFLOzs7QUFJckIsY0FBTSxPQUFPLFVBQ1AsVUFBVSxLQUFLLGNBQ2YsZ0JBQWdCLElBQUksY0FBYyxNQUFNLFNBQVM7QUFFdkQsZUFBTzs7Ozs7O0FDbkNYOzs7OzttQ0FRQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7O0FBQU4sbURBQXlDLGNBQUEsV0FBVTthQUN6RCxpQkFBaUIsTUFBTSxPQUFPO0FBQ25DLFlBQUksNkJBQTZCO0FBRWpDLGNBQU0sV0FBVyxLQUFLLFdBQ2hCLFlBQVksSUFBQSxPQUFBLG9CQUFtQixRQUMvQiwyQkFBMkIsVUFBVSxTQUFTO0FBRXBELFlBQUksMEJBQTBCO0FBQzVCLGdCQUFNLG9CQUFvQixJQUFBLFdBQUEsa0JBQWlCLFdBQVcsV0FDaEQsT0FBTyxtQkFDUCxRQUFRLGNBQWMsT0FDdEIsYUFBYTtBQUVuQix1Q0FBNkIsSUFBSSwyQkFBMkIsT0FBTzs7QUFHckUsZUFBTzs7O0FBSVgseUJBQXFCLE1BQUk7QUFDdkIsWUFBTSxlQUFlLEtBQUs7QUFFMUIsbUJBQWE7QUFFYixZQUFNLFdBQVcsYUFBYTtBQUU5QixtQkFBYSxRQUFRO0FBRXJCLGFBQU87O0FBR1QsMkJBQXVCLE1BQUk7QUFDekIsWUFBTSxlQUFlLFlBQVksT0FDM0IsWUFBWSxjQUNaLFFBQVE7QUFFZCxNQUFBLElBQUEsV0FBQSx5Q0FBd0MsV0FBVyxDQUFDLFVBQVUsMEJBQUE7QUFDNUQsY0FBTSxvQkFBb0I7QUFFMUIsZ0NBQXdCO0FBRXhCLG1CQUFXO0FBRVgsY0FBTSx5QkFBeUIsMkRBQTJELFVBQVUsd0JBQzlGLHVCQUF1QixpQ0FBaUM7QUFFOUQsY0FBTSxLQUFLO0FBRVgsY0FBTSxLQUFLOztBQUdiLFlBQU07QUFFTixhQUFPOztBQUdULDhDQUEwQyxVQUFRO0FBQ2hELFlBQU0sMkJBQTJCLElBQUEsVUFBQSxzQ0FBcUMsV0FDaEUsK0JBQStCLElBQUEsTUFBQSwwQkFBeUIsMkJBQ3hELDhDQUE4QyxJQUFBLE1BQUEsNkJBQTRCLCtCQUMxRSx1QkFBdUI7QUFFN0IsYUFBTzs7QUFHVCx3RUFBb0UsVUFBVSx1QkFBcUI7QUFDakcsWUFBTSw2QkFBNkIsSUFBQSxVQUFBLGdFQUErRCxVQUFVLHdCQUN0RyxpQ0FBaUMsSUFBQSxNQUFBLDBCQUF5Qiw2QkFDMUQseUJBQXlCO0FBRS9CLGFBQU87Ozs7O0FDaEZUOzs7OzttQ0FTQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7OztBQUFOLDZDQUFtQyxjQUFBLEtBQUk7TUFDcEQsNEJBQTRCLFVBQVUsT0FBTztBQUMzQyxjQUFNLGtCQUFrQixVQUFBO0FBRXhCLGVBQU87O2FBR0Ysa0JBQWtCLE1BQU0sUUFBUTtBQUNyQyxjQUFNLFdBQVcsS0FBSyxXQUNoQixjQUFjO0FBRXBCLGVBQU8sSUFBSSxDQUFDLFVBQUE7QUFDVixnQkFBTSw2QkFBNkIsV0FBQSxRQUEyQixpQkFBaUIsTUFBTTtBQUVyRixjQUFJLCtCQUErQixNQUFNO0FBQ3ZDLGtCQUFNLGFBQWE7QUFFbkIsd0JBQVksS0FBSzs7O0FBSXJCLGNBQU0sMkJBQTJCLElBQUEsVUFBQSxzQ0FBcUMsV0FDaEUsT0FBTywwQkFDUCxVQUFVLEtBQUssY0FDZix1QkFBdUIsSUFBSSxxQkFBcUIsTUFBTSxTQUFTO0FBRXJFLGVBQU87Ozs7OztBQ25DWDs7Ozs7bUNBYUEsV0FBQTs7O2VBQXdCOzs7Ozs7Ozs7Ozs7O0FBRnhCLFFBQU0sQ0FBRSxVQUFXLFdBQUE7QUFFSix1Q0FBbUMsUUFBUSxTQUFTLGNBQVk7QUFDN0UsWUFBTSxZQUFZLElBQUEsT0FBQSxxQkFBb0I7QUFFdEMsZ0JBQVUsUUFBUSxDQUFDLGFBQUE7QUFDakIsWUFBSSxPQUFPLFFBQVE7QUFFbkIsY0FBTSxnQkFBZ0IsV0FBQSxRQUFjLGtCQUFrQixNQUFNLFFBQVEsU0FBUztBQUU3RSxlQUFPO0FBRVAsZ0JBQVEsWUFBWTs7QUFHdEIsWUFBTSx3QkFBd0IsY0FBYyxVQUFBLFNBQXNCO0FBRWxFLDRCQUFzQixRQUFRLENBQUMseUJBQUE7QUFDN0IsY0FBTSxtQ0FBbUMsSUFBQSxjQUFBLG9CQUFtQixzQkFBc0I7QUFFbEYsWUFBSSxrQ0FBa0M7QUFDcEMsZ0JBQU0sMkJBQTJCLHFCQUFxQjtBQUV0RCxnQkFBTSxJQUFJLE1BQU0sMEJBQTBCOzs7QUFJOUMsZ0JBQVUsUUFBUSxDQUFDLGFBQUE7QUFDakIsY0FBTSxhQUFhLElBQUEsT0FBQSxpQ0FBZ0MsVUFBVSxTQUN2RCx3QkFBd0IsV0FBVyxNQUFNLENBQUMsY0FBQTtBQUN4QyxnQkFBTSx1QkFBdUIsSUFBQSxPQUFBLG9CQUFtQixXQUFXO0FBRTNELGNBQUksc0JBQXNCO0FBQ3hCLG1CQUFPOzs7QUFJakIsWUFBSSx1QkFBdUI7QUFDekIsZ0JBQU0sSUFBSSxNQUFNLHFDQUFxQzs7OztBQUszRCwyQkFBdUIsTUFBTSxTQUFPO0FBQ2xDLFlBQU0sUUFBUSxPQUFPLE9BQU87QUFFNUIsYUFBTyxPQUFPLENBQUMsU0FBQTtBQUNiLGNBQU0sV0FBWSxnQkFBZ0I7QUFFbEMsWUFBSSxVQUFVO0FBQ1osaUJBQU87OztBQUlYLGFBQU87Ozs7O0FDakVUOzs7OzttQ0FNQSxXQUFBOzs7ZUFBd0I7Ozs7Ozs7Ozs7QUFBVCx5Q0FBcUMsUUFBUSxTQUFPO0FBQ2pFLFlBQU0sWUFBWSxJQUFBLE9BQUEscUJBQW9CO0FBRXRDLGdCQUFVLFFBQVEsQ0FBQyxhQUFBO0FBQ2pCLGNBQU0sT0FBTyxRQUFRLFdBQ2YsdUJBQXVCLFVBQUEsUUFBcUIsa0JBQWtCLE1BQU0sUUFBUSxVQUM1RSwyQkFBMkIscUJBQXFCO0FBRXRELGdCQUFRLDRCQUE0Qjs7Ozs7O0FDZHhDOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7QUFGckIsUUFBTSxDQUFFLGVBQWdCLGNBQUE7QUFFVCwwQ0FBZ0MsY0FBQSxXQUFVO2FBQ2hELGVBQWUsWUFBWTtBQUNoQyxjQUFNLGNBQWMsWUFBWSxlQUMxQixRQUFRO1VBQ047V0FFRixvQkFBb0Isa0JBQWtCLHVCQUF1QixPQUFPO0FBRTFFLGVBQU87Ozs7OztBQ2RYOzs7OzttQ0FNZ0IsaUJBQUE7OztlQUFBOzs7O0FBRmhCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRVgsMkJBQXVCLE9BQUs7QUFDakMsWUFBTSxZQUFZLE9BQU0sUUFDbEIsa0JBQWtCLFVBQVUsWUFDNUIsYUFBYSxNQUFNLE1BQU0sQ0FBQyxTQUFBO0FBQ3hCLGNBQU0sYUFBYSxLQUFLLFlBQ2xCLDRCQUE2QixlQUFlO0FBRWxELFlBQUksMkJBQTJCO0FBQzdCLGlCQUFPOzs7QUFJakIsYUFBTzs7Ozs7QUNsQlQ7Ozs7O21DQVdnQixzQkFBQTs7O2VBQUE7Ozs7QUFQaEIsUUFBTSxDQUFFLGtCQUNBLHNCQUNBLHVCQUNBLHdCQUNBLHlCQUNBLDJCQUE0QixjQUFBO0FBRTdCLGdDQUE0QixNQUFNLFNBQVMsWUFBWSxJQUFFO0FBQzlELFVBQUksbUJBQW1CO0FBRXZCLFlBQU0sV0FBVyxLQUFLLFdBQ2hCLDRCQUE0QixVQUFVLFNBQVM7QUFFckQsVUFBSSxDQUFDLDJCQUEyQjtBQUM5QixvQkFBWTthQUNQO1VBQ0g7O0FBR0YsY0FBTSxjQUFjLEtBQUssa0JBQ25CLDBCQUEwQiwyQkFBMkIsYUFBYSxTQUFTO0FBRWpGLDJCQUFtQjs7QUFHckIsYUFBTzs7QUFHVCx3Q0FBb0MsYUFBYSxTQUFTLFdBQVM7QUFDakUsWUFBTSwwQkFBMEIsWUFBWSxNQUFNLENBQUMsZUFBQTtBQUNqRCxjQUFNLHlCQUF5Qix5QkFBeUIsWUFBWSxTQUFTO0FBRTdFLFlBQUksd0JBQXdCO0FBQzFCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdULHNDQUFrQyxZQUFZLFNBQVMsV0FBUztBQUM5RCxZQUFNLFFBQVEsV0FBVyxZQUNuQixvQkFBb0IscUJBQXFCLE9BQU8sU0FBUyxZQUN6RCx5QkFBeUI7QUFFL0IsYUFBTzs7QUFHVCxrQ0FBOEIsT0FBTyxTQUFTLFdBQVM7QUFDckQsWUFBTSxvQkFBb0IsTUFBTSxNQUFNLENBQUMsU0FBQTtBQUNyQyxjQUFNLG1CQUFtQixtQkFBbUIsTUFBTSxTQUFTO0FBRTNELFlBQUksa0JBQWtCO0FBQ3BCLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdULGdDQUE0QixNQUFNLFNBQVMsV0FBUztBQUNsRCxVQUFJO0FBRUosWUFBTSxrQkFBa0IsS0FBSztBQUU3QixVQUFJLGlCQUFpQjtBQUNuQixjQUFNLGVBQWUsTUFDZixzQkFBc0IsMkJBQTJCO0FBRXZELDJCQUFtQjthQUNkO0FBQ0wsY0FBTSxtQkFBbUIsTUFDbkIsOEJBQThCLDhCQUE4QixrQkFBa0IsU0FBUztBQUU3RiwyQkFBbUI7O0FBR3JCLGFBQU87O0FBR1Qsd0NBQW9DLGNBQVk7QUFDOUMsWUFBTSwyQkFBMkI7QUFFakMsYUFBTzs7QUFHVCwyQ0FBdUMsaUJBQWlCLFNBQVMsV0FBUztBQUN4RSxVQUFJLG1CQUFtQjtBQUV2QixZQUFNLE9BQU8sZ0JBQWdCO0FBRTdCLGNBQVE7YUFDRCxrQkFBa0I7QUFDckIsZ0JBQU0sZUFBZSxpQkFDZixXQUFXLGFBQWEsZUFDeEIsT0FBTyxRQUFRLGFBQWE7QUFFbEMsY0FBSSxTQUFTLE1BQU07QUFDakIsa0JBQU0sbUJBQW1CLG1CQUFtQixNQUFNLFNBQVM7QUFFM0QsK0JBQW1COztBQUdyQjs7YUFHRyxzQkFBc0I7QUFDekIsNkJBQW1CO0FBRW5COzthQUdHLHdCQUF3QjtBQUMzQixnQkFBTSxxQkFBcUIsaUJBQ3JCLE9BQU8sbUJBQW1CO0FBRWhDLDZCQUFtQixtQkFBbUIsTUFBTSxTQUFTO0FBRXJEOzthQUdHLHlCQUF5QjtBQUM1Qiw2QkFBbUI7QUFFbkI7O2FBR0cseUJBQXlCO0FBQzVCLGdCQUFNLHNCQUFzQixpQkFDdEIsUUFBUSxvQkFBb0IsWUFDNUIsb0JBQW9CLHFCQUFxQixPQUFPLFNBQVM7QUFFL0QsNkJBQW1CO0FBRW5COzthQUdHLHVCQUF1QjtBQUMxQixnQkFBTSxvQkFBb0IsaUJBQ3BCLFFBQVEsa0JBQWtCLFlBQzFCLG9CQUFvQixNQUFNLE1BQU0sQ0FBQyxTQUFBO0FBQy9CLGtCQUFNLG9CQUFtQixtQkFBbUIsTUFBTSxTQUFTO0FBRTNELG1CQUFPOztBQUdmLDZCQUFtQjtBQUVuQjs7O0FBSUosYUFBTzs7Ozs7QUM1SlQ7Ozs7O21DQWFnQix1QkFBQTs7O2VBQUE7Ozs7O0FBUmhCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBQWxCLFFBQ00sQ0FBRSxrQkFDQSxzQkFDQSx1QkFDQSx3QkFDQSx5QkFDQSwyQkFBNEIsY0FBQTtBQUU3QixpQ0FBNkIsWUFBVTtBQUM1QyxZQUFNLFFBQVEsV0FBVyxZQUNuQixZQUFZLE9BQU0sUUFDbEIsbUJBQW1CLGNBQWMsWUFDakMsb0JBQW9CO0FBRTFCLGFBQU87O0FBR1QsMkJBQXVCLE1BQUk7QUFDekIsVUFBSSxjQUFjO0FBRWxCLFlBQU0sc0JBQXNCLEtBQUs7QUFFakMsVUFBSSxxQkFBcUI7QUFDdkIsY0FBTSxrQkFBa0IsTUFDbEIsT0FBTyxnQkFBZ0I7QUFFN0IsZ0JBQVE7ZUFDRCxrQkFBa0I7QUFDckIsMEJBQWM7QUFFZDs7ZUFHRyxzQkFBc0I7QUFDekIsa0JBQU0sbUJBQW1CLGlCQUNuQixRQUFPLGlCQUFpQjtBQUU5QiwwQkFBYyxjQUFjO0FBRTVCOztlQUdHLHdCQUF3QjtBQUMzQixrQkFBTSxxQkFBcUIsaUJBQ3JCLFFBQU8sbUJBQW1CO0FBRWhDLDBCQUFjLGNBQWM7QUFFNUI7O2VBR0cseUJBQXlCO0FBQzVCLGtCQUFNLHNCQUFzQixpQkFDdEIsUUFBTyxvQkFBb0I7QUFFakMsMEJBQWMsY0FBYztBQUU1Qjs7ZUFHRztlQUNBLHVCQUF1QjtBQUMxQiwwQkFBYztBQUVkOzs7O0FBS04sYUFBTzs7Ozs7QUMxRVQ7Ozs7O21DQU9nQix3QkFBQTs7O2VBQUE7Ozs7O0FBRmhCLFFBQU0sQ0FBRSxpQkFBVSxXQUFBO0FBRVgsa0NBQThCLFlBQVksU0FBUyxZQUFZLElBQUU7QUFDdEUsWUFBTSxRQUFRLFdBQVcsWUFDbkIsWUFBWSxPQUFNLFFBQ2xCLHdCQUF3QixJQUFBLGNBQUEsb0JBQW1CLFdBQVcsU0FBUyxZQUMvRCxxQkFBcUI7QUFFM0IsYUFBTzs7Ozs7QUNiVDs7Ozs7bUNBTWdCLHlCQUFBOzs7ZUFBQTs7OztBQUZoQixRQUFNLENBQUUsaUJBQVUsV0FBQTtBQUVYLG1DQUErQixZQUFVO0FBQzlDLFlBQU0sUUFBUSxXQUFXLFlBQ25CLFlBQVksT0FBTSxRQUNsQixxQkFBcUIsZ0JBQWdCLFlBQ3JDLHNCQUFzQjtBQUU1QixhQUFPOztBQUdULDZCQUF5QixNQUFJO0FBQzNCLFVBQUksZ0JBQWdCO0FBRXBCLFlBQU0sc0JBQXNCLEtBQUs7QUFFakMsVUFBSSxxQkFBcUI7QUFDdkIsY0FBTSxrQkFBa0IsTUFDbEIsOEJBQThCLGdCQUFnQjtBQUVwRCxZQUFJLDZCQUE2QjtBQUMvQixnQkFBTSxlQUFlLGlCQUNmLFlBQVksYUFBYTtBQUUvQiwwQkFBZ0I7OztBQUlwQixhQUFPOzs7OztBQ2hDVDs7Ozs7Ozs7Ozs7OztVQWlDZ0Isd0JBQUE7ZUFBQTs7VUF4QkEsa0JBQUE7ZUFBQTs7Ozs7QUFKaEIsUUFBTSxDQUFFLHNCQUFzQix3QkFBd0IsMkJBQTRCLGNBQUE7QUFFbEYsUUFBTSxDQUFFLGlCQUFVLFdBQUE7QUFFWCw2QkFBeUIsTUFBSTtBQUNsQyxVQUFJLGdCQUFnQjtBQUVwQixZQUFNLHNCQUFzQixLQUFLO0FBRWpDLFVBQUkscUJBQXFCO0FBQ3ZCLGNBQU0sa0JBQWtCLE1BQ2xCLE9BQU8sZ0JBQWdCO0FBRTdCLGdCQUFRO2VBQ0Q7ZUFDQTtlQUNBLHlCQUF5QjtBQUM1Qiw0QkFBZ0I7QUFFaEI7Ozs7QUFLTixhQUFPOztBQUlGLG1DQUErQixZQUFVO0FBQzlDLFlBQU0sUUFBUSxXQUFXLFlBQ25CLFlBQVksT0FBTSxRQUNsQixxQkFBcUIsZ0JBQWdCLFlBQ3JDLHNCQUFzQjtBQUU1QixhQUFPOzs7OztBQ3ZDVDs7Ozs7bUNBbUJBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFGckIsUUFBTSxDQUFFLGlCQUFVLFdBQUE7QUFFSCwrQ0FBcUMsY0FBQSxLQUFJO01BQ3RELDRCQUE0QixVQUFVLE9BQU87QUFDM0MsY0FBTSxrQkFBa0IsWUFBQTtBQUV4QixlQUFPOzthQUdGLDZCQUE2QixNQUFNLG1CQUFtQixTQUFTO0FBQ3BFLFlBQUksY0FBYyxLQUFLO0FBRXZCLGNBQU0sd0JBQXdCLGtCQUFrQjtBQUVoRCxZQUFJLDJCQUEyQixZQUFZLE9BQU8sQ0FBQyxlQUFBO0FBQ2pELGdCQUFNLDBCQUEwQixJQUFBLGVBQUEsMkJBQTBCLFlBQVk7QUFFdEUsY0FBSSx5QkFBeUI7QUFDM0Isa0JBQU0seUJBQXlCLElBQUEsZUFBQSxzQ0FBcUMsWUFBWSxVQUMxRSw2QkFBNkIsT0FBTTtBQUV6QyxnQkFBSSwrQkFBK0IsdUJBQXVCO0FBQ3hELG9CQUFNLFlBQVcsS0FBSyxXQUNoQixtQkFBbUIsV0FBVztBQUVwQyxvQkFBTSxvQkFBb0IsSUFBQSxTQUFBLHFCQUFvQjtBQUU5QyxrQkFBSSxtQkFBbUI7QUFDckIsc0JBQU0sSUFBSSxNQUFNLFFBQVEsdURBQXVEOztBQUdqRixvQkFBTSxxQkFBcUIsSUFBQSxVQUFBLHNCQUFxQixZQUFZO0FBRTVELGtCQUFJLG9CQUFvQjtBQUN0QixzQkFBTSxvQkFBbUIsV0FBVztBQUVwQyxzQkFBTSxJQUFJLE1BQU0sUUFBUSx3REFBdUQ7O0FBR2pGLG9CQUFNLHNCQUFzQixJQUFBLFdBQUEsdUJBQXNCO0FBRWxELGtCQUFJLHFCQUFxQjtBQUN2QixzQkFBTSxJQUFJLE1BQU0sMEJBQTBCLHVEQUF1RDs7QUFHbkcsb0JBQU0sc0JBQXNCLElBQUEsV0FBQSx1QkFBc0I7QUFFbEQsa0JBQUkscUJBQXFCO0FBQ3ZCLHNCQUFNLElBQUksTUFBTSwwQkFBMEIsdURBQXVEOztBQUduRyxxQkFBTzs7OztBQUtiLGNBQU0sa0JBQWtCLG1CQUFtQjtBQUUzQyxZQUFJLENBQUMsaUJBQWlCO0FBQ3BCLGdCQUFNLFlBQVcsS0FBSztBQUV0QixnQkFBTSxJQUFJLE1BQU0sMkJBQTJCLDZEQUE2RDs7QUFHMUcsWUFBSSxhQUFhO0FBRWpCLG1DQUEyQix5QkFBeUIsT0FBTyxDQUFDLDRCQUFBO0FBQzFELGdCQUFNLFFBQVEsd0JBQXdCLFlBQ2hDLGNBQWMsTUFBTTtBQUUxQixjQUFJLGdCQUFnQixHQUFHO0FBQ3JCLHlCQUFhLHdCQUF3QjtpQkFDL0I7QUFDTixtQkFBTzs7O0FBSVgsY0FBTSxXQUFXLEtBQUssV0FDaEIsMkJBQTJCLGtCQUFrQixjQUM3Qyw2QkFBNkIsSUFBQSxVQUFBLGdFQUErRCxVQUFVLHdCQUN0RyxPQUFPLDRCQUNQLFVBQVU7QUFFaEIsc0JBQWMsd0NBQXdDO0FBRXRELGNBQU0seUJBQXlCLElBQUksdUJBQXVCLE1BQU0sU0FBUyxjQUNuRSxxQ0FBcUMsSUFBQSxjQUFBLG9CQUFtQix3QkFBd0I7QUFFdEYsWUFBSSxvQ0FBb0M7QUFDdEMsZ0JBQU0sb0JBQW9CLFNBQUEsUUFBa0IsZUFBZTtBQUUzRCxzQkFBWSxLQUFLOztBQUduQixlQUFPOzs7QUFJWCxnQ0FBNEIsYUFBVztBQUNyQyxZQUFNLGFBQWEsWUFBWSxJQUFJLENBQUMsZUFBQTtBQUM1QixjQUFNLFFBQVEsV0FBVyxZQUNuQixZQUFZLE9BQU07QUFFeEIsZUFBTztVQUVULGtCQUFrQixJQUFBLE9BQUEsZUFBYztBQUV0QyxhQUFPOztBQUdULHFEQUFpRCwwQkFBd0I7QUFDdkUsWUFBTSxjQUFjLHlCQUF5QixJQUFJLENBQUMsNEJBQUE7QUFDMUMsWUFBSSxRQUFRLHdCQUF3QjtBQUVwQyxnQkFBUTthQUNIOztBQUdMLGNBQU07QUFFTixjQUFNLGFBQWEsd0JBQXdCLGlCQUNyQyxhQUFhLGNBQUEsV0FBVyx1QkFBdUIsT0FBTztBQUU1RCxlQUFPOztBQUdmLGFBQU87Ozs7O0FDL0lUOzs7OzttQ0FRQSxXQUFBOzs7ZUFBd0I7Ozs7Ozs7Ozs7OztBQUFULDJDQUF1QyxRQUFRLFNBQU87QUFDbkUsYUFBTyxRQUFRLENBQUMsVUFBQTtBQUNkLGNBQU0sWUFBWSxJQUFBLE9BQUEsb0JBQW1CO0FBRXJDLFFBQUEsSUFBQSxXQUFBLHlDQUF3QyxXQUFXLENBQUMsVUFBVSwwQkFBQTtBQUM1RCxnQkFBTSw2QkFBNkIsSUFBQSxVQUFBLGdFQUErRCxVQUFVO0FBRTVHLGNBQUkseUJBQXlCLFFBQVEsK0JBQStCO0FBRXBFLGNBQUksMkJBQTJCLE1BQU07QUFDbkMsa0JBQU0sT0FBTyxRQUFRLFdBQ2Ysb0JBQW9CLFFBQVE7QUFFbEMscUNBQXlCLFlBQUEsUUFBdUIsNkJBQTZCLE1BQU0sbUJBQW1CO0FBRXRHLG9CQUFRLDhCQUE4Qjs7Ozs7Ozs7QUN2QjlDOzs7OzttQ0FrQkEsV0FBQTs7O2VBQXdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFIeEIsUUFBTSxDQUFFLFVBQVcsV0FBQTtBQUFuQixRQUNNLENBQUUsa0JBQWtCLG9CQUFvQixnQ0FBaUMsY0FBQTtBQUVoRSxvQ0FBZ0MsT0FBSztBQUNsRCxZQUFNLFVBQVUsaUJBQWlCLFFBQzNCLFlBQVksbUJBQW1CLFFBQy9CLGVBQWUsd0JBQXdCLFVBQ3ZDLFNBQVMsb0JBQW9CLFdBQVcsU0FBUztBQUV2RCxNQUFBLElBQUEsb0JBQUEsU0FBbUIsUUFBUTtBQUUzQixNQUFBLElBQUEsK0JBQUEsU0FBOEIsUUFBUTtBQUV0QyxNQUFBLElBQUEsNkJBQUEsU0FBNEIsUUFBUTtBQUVwQyxNQUFBLElBQUEsMkJBQUEsU0FBMEIsUUFBUSxTQUFTO0FBRTNDLGNBQVEsNkJBQTZCLFdBQVc7QUFFaEQsYUFBTzs7QUFHVCx3Q0FBb0MsV0FBVyxTQUFTLGNBQVk7QUFDbEUsWUFBTSxnQkFBZ0IsVUFBVSxXQUMxQixRQUFRLElBQUEsZ0JBQUEsb0JBQW1CLFdBQVcsU0FBUyxlQUMvQyxjQUFjLGVBQ2QsZ0JBQWdCLGVBQUEsUUFBYyx3QkFBd0IsT0FBTztBQUVuRSxhQUFPOztBQUdULHFDQUFpQyxTQUFPO0FBQ3RDLFlBQU0sZUFBZSxJQUNmLFlBQVksT0FBTyxLQUFLO0FBRTlCLGdCQUFVLFFBQVEsQ0FBQyxhQUFBO0FBQ2pCLGNBQU0sT0FBTyxRQUFRLFdBQ2YseUJBQXlCLElBQUEsZUFBQSxnQ0FBK0IsTUFBTSxVQUM5RCxhQUFZO0FBRWxCLHFCQUFhLFlBQVk7O0FBRzNCLGFBQU87O0FBR1Qsa0NBQThCLE9BQUs7QUFDakMsWUFBTSxxQkFBcUIsTUFBTSxVQUFVLENBQUMsU0FBQTtBQUMxQyxjQUFNLFFBQVEsS0FBSyxZQUNiLDBCQUEyQixVQUFVLFFBQUEsc0JBQ3JDLG9CQUFvQjtBQUUxQixZQUFJLG1CQUFtQjtBQUNyQixpQkFBTzs7O0FBSVgsYUFBTzs7QUFHVCxpQ0FBNkIsV0FBVyxTQUFTLGNBQVk7QUFDM0QsWUFBTSxnQkFBZ0IsMkJBQTJCLFdBQVcsU0FBUyxlQUMvRCxTQUFTLGNBQWM7QUFFN0IsYUFBTyxRQUFRLENBQUMsVUFBQTtBQUNkLGNBQU0scUJBQXFCLHFCQUFxQjtBQUVoRCxZQUFJLG9CQUFvQjtBQUN0QixpQkFBTzs7O0FBSVgsYUFBTzs7Ozs7QUN2RlQ7Ozs7Ozs7Ozs7Ozs7VUFFb0IsZUFBQTtlQUFBLFNBQUE7O1VBQ0EsZ0JBQUE7ZUFBQSxVQUFBOztVQUVBLHlCQUFBO2VBQUEsd0JBQUE7Ozs7Ozs7Ozs7Ozs7O0FDTHBCOzs7Ozs7Ozs7Ozs7O1VBSWdCLFlBQUE7ZUFBQTs7VUFZQSxhQUFBO2VBQUE7Ozs7QUFaVCx1QkFBbUIsa0JBQWdCO0FBQ3hDLFlBQU0sUUFBUSxZQUFBLE1BQU0scUJBQXFCO0FBRXpDLGFBQU8sU0FBUyxNQUFJO0FBQ2xCLGNBQU0sUUFBUSxNQUFNLFFBQVE7QUFFNUIsZUFBTyxNQUFNLFdBQVc7QUFFeEIsZUFBTzs7O0FBSUosd0JBQW9CLGtCQUFnQjtBQUN6QyxZQUFNLFFBQVEsWUFBQSxNQUFNLHFCQUFxQjtBQUV6QyxhQUFPLFNBQVMsTUFBSTtBQUNsQixjQUFNLFFBQVEsTUFBTSxRQUFRO0FBRTVCLGVBQU87Ozs7OztBQ3RCWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQUE7OztBQVRBLFFBQU0sVUFBVTtNQUNkO1FBQ0UsU0FBVzs7TUFFYjtRQUNFLFlBQWM7OztRQUlsQixXQUFlOzs7O0FDWGY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLGtDQUF1QixhQUFBLFlBQVc7YUF1QnhDLGNBQWM7QUFBRSxlQUFPLGFBQUEsWUFBWSxZQUFZOzthQUUvQyxVQUFVLE9BQU87QUFBRSxlQUFPLGFBQUEsWUFBWSxVQUFVLFdBQVU7O2FBRTFELFlBQVksU0FBUztBQUFFLGVBQU8sYUFBQSxZQUFZLFlBQVksV0FBVTs7O0FBM0IxRDtBQUNOLGtCQURNLFVBQ04sV0FBVSxTQUFBO0FBRVYsa0JBSE0sVUFHTixrQkFBaUIsYUFBQTtBQUVqQixrQkFMTSxVQUtOLG1CQUFrQixhQUFBO0FBRWxCLGtCQVBNLFVBT04seUJBQXdCO0FBRXhCLGtCQVRNLFVBU04sMEJBQXlCO0FBRXpCLGtCQVhNLFVBV04sMEJBQXlCO0FBRXpCLGtCQWJNLFVBYU4sOEJBQTZCO0FBRTdCLGtCQWZNLFVBZU4sZ0NBQStCO0FBRS9CLGtCQWpCTSxVQWlCTixpQ0FBZ0M7QUFFaEMsa0JBbkJNLFVBbUJOLGtDQUFpQztBQUVqQyxrQkFyQk0sVUFxQk4sa0NBQWlDOzs7O0FDM0IxQzs7Ozs7bUNBb0JBLFdBQUE7OztlQUFBOzs7QUFsQkEsUUFBTSxVQUFVO01BQ2Q7UUFDRSxTQUFXOztNQUViO1FBQ0UsUUFBVTs7TUFFWjtRQUNFLFNBQVc7O01BRWI7UUFDRSxNQUFROztNQUVWO1FBQ0UsWUFBYzs7O1FBSWxCLFdBQWU7Ozs7QUNwQmY7Ozs7O21DQVNBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLG1DQUF3QixhQUFBLFlBQVc7YUF1QnpDLGNBQWM7QUFBRSxlQUFPLGFBQUEsWUFBWSxZQUFZOzthQUUvQyxVQUFVLE9BQU87QUFBRSxlQUFPLGFBQUEsWUFBWSxVQUFVLFlBQVc7O2FBRTNELFlBQVksU0FBUztBQUFFLGVBQU8sYUFBQSxZQUFZLFlBQVksWUFBVzs7O0FBM0IzRDtBQUNOLGtCQURNLFdBQ04sV0FBVSxTQUFBO0FBRVYsa0JBSE0sV0FHTixrQkFBaUIsYUFBQTtBQUVqQixrQkFMTSxXQUtOLG1CQUFrQixhQUFBO0FBRWxCLGtCQVBNLFdBT04seUJBQXdCO0FBRXhCLGtCQVRNLFdBU04sMEJBQXlCO0FBRXpCLGtCQVhNLFdBV04sMEJBQXlCO0FBRXpCLGtCQWJNLFdBYU4sOEJBQTZCO0FBRTdCLGtCQWZNLFdBZU4sZ0NBQStCO0FBRS9CLGtCQWpCTSxXQWlCTixpQ0FBZ0M7QUFFaEMsa0JBbkJNLFdBbUJOLGtDQUFpQztBQUVqQyxrQkFyQk0sV0FxQk4sa0NBQWlDLGFBQUE7Ozs7QUM5QjFDOzs7OzttQ0F5Q0EsV0FBQTs7O2VBQUE7OztBQXZDQSxRQUFNLFFBQVE7QUFBZCxRQUNNLFVBQVU7QUFFaEIsUUFBTSxVQUFVO01BQ2Q7UUFDRSxNQUFROztNQUVWO1FBQ0UsT0FBUzs7TUFFWDtRQUNFLG1CQUFtQjs7TUFFckI7UUFDRSxxQkFBcUI7O01BRXZCO1FBQ0UsTUFBUTs7TUFFVjtRQUNFLFNBQVc7O01BRWI7UUFDRSxTQUFXOztNQUViO1FBQ0UsU0FBVzs7TUFFYjtRQUNFLE1BQVEsSUFBSSxTQUFTOztNQUV2QjtRQUNFLFFBQVUsSUFBSTs7TUFFaEI7UUFDRSxZQUFjOzs7UUFJbEIsV0FBZTs7OztBQ3pDZjs7Ozs7bUNBY0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4scUNBQTBCLGFBQUEsWUFBVzthQXVCM0MsY0FBYztBQUFFLGVBQU8sYUFBQSxZQUFZLFlBQVk7O2FBRS9DLFVBQVUsT0FBTztBQUFFLGVBQU8sYUFBQSxZQUFZLFVBQVUsY0FBYTs7YUFFN0QsWUFBWSxTQUFTO0FBQUUsZUFBTyxhQUFBLFlBQVksWUFBWSxjQUFhOzs7QUEzQjdEO0FBQ04sa0JBRE0sYUFDTixXQUFVLFNBQUE7QUFFVixrQkFITSxhQUdOLGtCQUFpQixhQUFBO0FBRWpCLGtCQUxNLGFBS04sbUJBQWtCLGFBQUE7QUFFbEIsa0JBUE0sYUFPTiwwQkFBeUI7QUFFekIsa0JBVE0sYUFTTix5QkFBd0IsYUFBQTtBQUV4QixrQkFYTSxhQVdOLDBCQUF5QixhQUFBO0FBRXpCLGtCQWJNLGFBYU4sOEJBQTZCLGFBQUE7QUFFN0Isa0JBZk0sYUFlTixnQ0FBK0IsYUFBQTtBQUUvQixrQkFqQk0sYUFpQk4saUNBQWdDLGFBQUE7QUFFaEMsa0JBbkJNLGFBbUJOLGtDQUFpQztBQUVqQyxrQkFyQk0sYUFxQk4sa0NBQWlDLGFBQUE7Ozs7QUNuQzFDOzs7OzttQ0F1Q0EsV0FBQTs7O2VBQUE7OztBQXJDQSxRQUFNLFFBQVE7QUFBZCxRQUNNLFFBQVE7QUFEZCxRQUVNLFVBQVU7QUFGaEIsUUFHTSxtQkFBbUI7QUFIekIsUUFJTSxtQkFBbUI7QUFKekIsUUFLTSwrQkFBK0I7QUFMckMsUUFNTSxpQ0FBaUM7QUFOdkMsUUFPTSxpQ0FBaUM7QUFQdkMsUUFRTSxrQ0FBa0M7QUFFeEMsUUFBTSxVQUFVO01BQ2Q7UUFDRSxtQkFBbUI7O01BRXJCO1FBQ0UscUJBQXFCOztNQUV2QjtRQUNFLGFBQWE7O01BRWY7UUFDRSxNQUFRLE9BQU8sbUJBQW1CLFNBQVMsWUFBWSxtQkFBbUIsU0FBUzs7TUFFckY7UUFDRSxZQUFjLE9BQU8sbUJBQW1CLFlBQVksVUFBVSxpQ0FBaUMsbUNBQW1DLG1DQUFtQzs7TUFFdks7UUFDRSxXQUFhOztNQUVmO1FBQ0UsU0FBVzs7TUFFYjtRQUNFLFlBQWM7OztRQUlsQixXQUFlOzs7O0FDdkNmOzs7OzttQ0FjQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixxQ0FBMkIsYUFBQSxZQUFXOztBQUM1QyxrQkFETSxjQUNOLFdBQVUsU0FBQTtBQUVWLGtCQUhNLGNBR04sa0JBQWlCLGFBQUE7QUFFakIsa0JBTE0sY0FLTixtQkFBa0IsYUFBQTtBQUVsQixrQkFQTSxjQU9OLDBCQUF5QjtBQUV6QixrQkFUTSxjQVNOLHlCQUF3QixhQUFBO0FBRXhCLGtCQVhNLGNBV04sMEJBQXlCLGFBQUE7QUFFekIsa0JBYk0sY0FhTiw4QkFBNkIsYUFBQTtBQUU3QixrQkFmTSxjQWVOLGdDQUErQixhQUFBO0FBRS9CLGtCQWpCTSxjQWlCTixpQ0FBZ0MsYUFBQTtBQUVoQyxrQkFuQk0sY0FtQk4sa0NBQWlDO0FBRWpDLGtCQXJCTSxjQXFCTixrQ0FBaUMsYUFBQTs7OztBQ25DMUM7Ozs7O21DQWNBLFdBQUE7OztlQUFBOzs7QUFaQSxRQUFNLFVBQVU7TUFDZDtRQUNFLGlCQUFpQjs7TUFFbkI7UUFDRSxhQUFlOztNQUVqQjtRQUNFLFlBQWM7OztRQUlsQixXQUFlOzs7O0FDZGY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHdDQUE2QixhQUFBLFlBQVc7YUF1QjlDLGNBQWM7QUFBRSxlQUFPLGFBQUEsWUFBWSxZQUFZOzthQUUvQyxVQUFVLE9BQU87QUFBRSxlQUFPLGFBQUEsWUFBWSxVQUFVLGlCQUFnQjs7YUFFaEUsWUFBWSxTQUFTO0FBQUUsZUFBTyxhQUFBLFlBQVksWUFBWSxpQkFBZ0I7OztBQTNCaEU7QUFDTixrQkFETSxnQkFDTixXQUFVLFNBQUE7QUFFVixrQkFITSxnQkFHTixrQkFBaUIsYUFBQTtBQUVqQixrQkFMTSxnQkFLTixtQkFBa0IsYUFBQTtBQUVsQixrQkFQTSxnQkFPTix5QkFBd0I7QUFFeEIsa0JBVE0sZ0JBU04sMEJBQXlCO0FBRXpCLGtCQVhNLGdCQVdOLDBCQUF5QjtBQUV6QixrQkFiTSxnQkFhTiw4QkFBNkI7QUFFN0Isa0JBZk0sZ0JBZU4sZ0NBQStCO0FBRS9CLGtCQWpCTSxnQkFpQk4saUNBQWdDO0FBRWhDLGtCQW5CTSxnQkFtQk4sa0NBQWlDO0FBRWpDLGtCQXJCTSxnQkFxQk4sa0NBQWlDOzs7O0FDM0IxQzs7Ozs7bUNBb0JBLFdBQUE7OztlQUFBOzs7QUFsQkEsUUFBTSxVQUFVO01BQ2Q7UUFDRSxTQUFXOztNQUViO1FBQ0UsUUFBVTs7TUFFWjtRQUNFLE1BQVE7O01BRVY7UUFDRSxNQUFROztNQUVWO1FBQ0UsWUFBYzs7O1FBSWxCLFdBQWU7Ozs7QUNwQmY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLGdEQUFxQyxhQUFBLFlBQVc7YUF1QnRELGNBQWM7QUFBRSxlQUFPLGFBQUEsWUFBWSxZQUFZOzthQUUvQyxVQUFVLE9BQU87QUFBRSxlQUFPLGFBQUEsWUFBWSxVQUFVLHlCQUF3Qjs7YUFFeEUsWUFBWSxTQUFTO0FBQUUsZUFBTyxhQUFBLFlBQVksWUFBWSx5QkFBd0I7OztBQTNCeEU7QUFDTixrQkFETSx3QkFDTixXQUFVLFNBQUE7QUFFVixrQkFITSx3QkFHTixrQkFBaUIsYUFBQTtBQUVqQixrQkFMTSx3QkFLTixtQkFBa0IsYUFBQTtBQUVsQixrQkFQTSx3QkFPTix5QkFBd0I7QUFFeEIsa0JBVE0sd0JBU04sMEJBQXlCO0FBRXpCLGtCQVhNLHdCQVdOLDBCQUF5QjtBQUV6QixrQkFiTSx3QkFhTiw4QkFBNkI7QUFFN0Isa0JBZk0sd0JBZU4sZ0NBQStCO0FBRS9CLGtCQWpCTSx3QkFpQk4saUNBQWdDO0FBRWhDLGtCQW5CTSx3QkFtQk4sa0NBQWlDO0FBRWpDLGtCQXJCTSx3QkFxQk4sa0NBQWlDLGFBQUE7Ozs7QUMzQjFDOzs7OzttQ0FRQSxXQUFBOzs7ZUFBQTs7O0FBTkEsUUFBTSxVQUFVO01BQ2Q7UUFDRSxZQUFjOzs7UUFJbEIsV0FBZTs7OztBQ1JmOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixzREFBMkMsYUFBQSxZQUFXO2FBdUI1RCxjQUFjO0FBQUUsZUFBTyxhQUFBLFlBQVksWUFBWTs7YUFFL0MsVUFBVSxPQUFPO0FBQUUsZUFBTyxhQUFBLFlBQVksVUFBVSwrQkFBOEI7O2FBRTlFLFlBQVksU0FBUztBQUFFLGVBQU8sYUFBQSxZQUFZLFlBQVksK0JBQThCOzs7QUEzQjlFO0FBQ04sa0JBRE0sOEJBQ04sV0FBVSxTQUFBO0FBRVYsa0JBSE0sOEJBR04sa0JBQWlCLGFBQUE7QUFFakIsa0JBTE0sOEJBS04sbUJBQWtCLGFBQUE7QUFFbEIsa0JBUE0sOEJBT04seUJBQXdCO0FBRXhCLGtCQVRNLDhCQVNOLDBCQUF5QjtBQUV6QixrQkFYTSw4QkFXTiwwQkFBeUI7QUFFekIsa0JBYk0sOEJBYU4sOEJBQTZCO0FBRTdCLGtCQWZNLDhCQWVOLGdDQUErQjtBQUUvQixrQkFqQk0sOEJBaUJOLGlDQUFnQztBQUVoQyxrQkFuQk0sOEJBbUJOLGtDQUFpQztBQUVqQyxrQkFyQk0sOEJBcUJOLGtDQUFpQzs7OztBQzNCMUM7Ozs7O21DQStDQSxXQUFBOzs7ZUFBQTs7O0FBN0NBLFFBQU0sTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUE2Q1osV0FBZTs7OztBQy9DZjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sbUNBQXdCLGNBQUEsYUFBWTthQUcxQyxjQUFjO0FBQUUsZUFBTyxjQUFBLGFBQWEsWUFBWTs7YUFFaEQsUUFBUSxLQUFLO0FBQUUsZUFBTyxjQUFBLGFBQWEsUUFBUSxZQUFXOzthQUV0RCxVQUFVLE9BQU87QUFBRSxlQUFPLGNBQUEsYUFBYSxVQUFVLFlBQVc7OztBQVB0RDtBQUNOLGtCQURNLFdBQ04sT0FBTSxLQUFBOzs7O0FDUGY7Ozs7O21DQW9EQSxXQUFBOzs7ZUFBQTs7O0FBbERBLFFBQU0sTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWtEWixXQUFlOzs7O0FDcERmOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixvQ0FBeUIsY0FBQSxhQUFZO2FBRzNDLGNBQWM7QUFBRSxlQUFPLGNBQUEsYUFBYSxZQUFZOzthQUVoRCxRQUFRLEtBQUs7QUFBRSxlQUFPLGNBQUEsYUFBYSxRQUFRLGFBQVk7O2FBRXZELFVBQVUsT0FBTztBQUFFLGVBQU8sY0FBQSxhQUFhLFVBQVUsYUFBWTs7O0FBUHZEO0FBQ04sa0JBRE0sWUFDTixPQUFNLEtBQUE7Ozs7QUNQZjs7Ozs7bUNBb0pBLFdBQUE7OztlQUFBOzs7QUFsSkEsUUFBTSxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBa0paLFdBQWU7Ozs7QUNwSmY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHNDQUEyQixjQUFBLGFBQVk7YUFHN0MsY0FBYztBQUFFLGVBQU8sY0FBQSxhQUFhLFlBQVk7O2FBRWhELFFBQVEsS0FBSztBQUFFLGVBQU8sY0FBQSxhQUFhLFFBQVEsZUFBYzs7YUFFekQsVUFBVSxPQUFPO0FBQUUsZUFBTyxjQUFBLGFBQWEsVUFBVSxlQUFjOzs7QUFQekQ7QUFDTixrQkFETSxjQUNOLE9BQU0sS0FBQTs7OztBQ1BmOzs7OzttQ0E2WEEsV0FBQTs7O2VBQUE7OztBQTNYQSxRQUFNLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQTJYWixXQUFlOzs7O0FDN1hmOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTixzQ0FBNEIsY0FBQSxhQUFZOztBQUM5QyxrQkFETSxlQUNOLE9BQU0sS0FBQTs7OztBQ1BmOzs7OzttQ0FvQkEsV0FBQTs7O2VBQUE7OztBQWxCQSxRQUFNLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7O1FBa0JaLFdBQWU7Ozs7QUNwQmY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHlDQUE4QixjQUFBLGFBQVk7YUFHaEQsY0FBYztBQUFFLGVBQU8sY0FBQSxhQUFhLFlBQVk7O2FBRWhELFFBQVEsS0FBSztBQUFFLGVBQU8sY0FBQSxhQUFhLFFBQVEsa0JBQWlCOzthQUU1RCxVQUFVLE9BQU87QUFBRSxlQUFPLGNBQUEsYUFBYSxVQUFVLGtCQUFpQjs7O0FBUDVEO0FBQ04sa0JBRE0saUJBQ04sT0FBTSxLQUFBOzs7O0FDUGY7Ozs7O21DQTBFQSxXQUFBOzs7ZUFBQTs7O0FBeEVBLFFBQU0sTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUF3RVosV0FBZTs7OztBQzFFZjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sZ0RBQXFDLGNBQUEsYUFBWTthQUd2RCxjQUFjO0FBQUUsZUFBTyxjQUFBLGFBQWEsWUFBWTs7YUFFaEQsUUFBUSxLQUFLO0FBQUUsZUFBTyxjQUFBLGFBQWEsUUFBUSx5QkFBd0I7O2FBRW5FLFVBQVUsT0FBTztBQUFFLGVBQU8sY0FBQSxhQUFhLFVBQVUseUJBQXdCOzs7QUFQbkU7QUFDTixrQkFETSx3QkFDTixPQUFNLEtBQUE7Ozs7QUNQZjs7Ozs7bUNBY0EsV0FBQTs7O2VBQUE7OztBQVpBLFFBQU0sTUFBTTs7Ozs7Ozs7Ozs7UUFZWixXQUFlOzs7O0FDZGY7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLHVEQUE0QyxjQUFBLGFBQVk7YUFHOUQsY0FBYztBQUFFLGVBQU8sY0FBQSxhQUFhLFlBQVk7O2FBRWhELFFBQVEsS0FBSztBQUFFLGVBQU8sY0FBQSxhQUFhLFFBQVEsZ0NBQStCOzthQUUxRSxVQUFVLE9BQU87QUFBRSxlQUFPLGNBQUEsYUFBYSxVQUFVLGdDQUErQjs7O0FBUDFFO0FBQ04sa0JBRE0sK0JBQ04sT0FBTSxLQUFBOzs7O0FDUGY7Ozs7Ozs7Ozs7Ozs7VUFPb0Isd0JBQUE7ZUFBQSxRQUFBOztVQVFBLHlCQUFBO2VBQUEsU0FBQTs7VUFQQSwrQkFBQTtlQUFBLFFBQUE7O1VBUUEsZ0NBQUE7ZUFBQSxTQUFBOztVQVpBLGNBQUE7ZUFBQSxRQUFBOztVQVFBLGVBQUE7ZUFBQSxTQUFBOztVQVRBLFlBQUE7ZUFBQSxRQUFBOztVQVFBLGFBQUE7ZUFBQSxTQUFBOztVQU5BLGVBQUE7ZUFBQSxRQUFBOztVQVFBLGdCQUFBO2VBQUEsU0FBQTs7VUFQQSxpQkFBQTtlQUFBLFFBQUE7O1VBUUEsa0JBQUE7ZUFBQSxTQUFBOztVQVpBLFdBQUE7ZUFBQSxPQUFBOztVQVFBLFlBQUE7ZUFBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVnBCOzs7Ozs7Ozs7Ozs7O1VBS2Esd0JBQUE7ZUFBQTs7VUFFQSx5QkFBQTtlQUFBOztVQUVBLCtCQUFBO2VBQUE7O1VBRUEsZ0NBQUE7ZUFBQTs7OztBQU5OLFFBQU0sd0JBQXdCLGVBQUEsc0JBQXNCO0FBRXBELFFBQU0seUJBQXlCLGVBQUEsdUJBQXVCO0FBRXRELFFBQU0sK0JBQStCLGVBQUEsNkJBQTZCO0FBRWxFLFFBQU0sZ0NBQWdDLGVBQUEsOEJBQThCOzs7O0FDWDNFOzs7OzttQ0FXZ0IsNkJBQUE7OztlQUFBOzs7Ozs7QUFKaEIsUUFBTSxDQUFFLFVBQVcsV0FBQTtBQUVuQixRQUFNLHVCQUF1QixJQUFBLE9BQUEsWUFBVztBQUVqQyx1Q0FBbUMsWUFBWSxhQUFXO0FBQy9ELFlBQU0sVUFBVSxZQUNWLFNBQVMsU0FBQSw2QkFBNkIsU0FBUyxVQUMvQyxPQUFPLFNBQUEsOEJBQThCLE1BQU07QUFFakQsVUFBSSxTQUFTLE1BQU07QUFDakI7O0FBR0YsWUFBTSxrQkFBa0IscUJBQXFCO0FBRTdDLHNCQUFnQixRQUFRLENBQUMsbUJBQUE7QUFDdkIsY0FBTSxXQUFVLDBCQUEwQixpQkFDcEMsYUFBYSxPQUFPO0FBRTFCLG9CQUFZLEtBQUs7OztBQUlyQix1Q0FBbUMsZ0JBQWM7QUFDL0MsWUFBTSxrQkFBa0IsZ0JBQ2xCLGFBQWEsZ0JBQWdCLGlCQUM3QixrQkFBa0IsT0FBTyxhQUN6Qix5QkFBeUIsaUJBQ3pCLFVBQVUsdUJBQXVCO0FBRXZDLGFBQU87O0FBR1Qsb0JBQWdCLFFBQU07QUFDcEIsYUFBTyxPQUFPLFFBQVEsdUJBQXVCOzs7OztBQ3pDL0M7Ozs7Ozs7Ozs7Ozs7VUFNYSxlQUFBO2VBQUE7O1VBRUEsZ0JBQUE7ZUFBQTs7Ozs7O0FBRk4sUUFBTSxlQUFlLGFBQUEsWUFBWSxZQUFZLGVBQUE7QUFFN0MsUUFBTSxnQkFBZ0IsY0FBQSxhQUFhLFlBQVksZUFBQTs7OztBQ1J0RDs7Ozs7bUNBc0JBLFdBQUE7OztlQUFBOzs7Ozs7O0FBZEEsUUFBTSxDQUFFLGlCQUFVLFdBQUE7QUFFbEIsUUFBTSxVQUFVLFNBQUEsY0FBYztBQUE5QixRQUNNLFlBQVksUUFBUSxXQUFBO0FBRDFCLFFBRU0sZUFBZSxRQUFRLFdBQUE7QUFGN0IsUUFHTSxhQUFhLGNBQWM7QUFIakMsUUFJTSxnQkFBZ0IsY0FBYztBQUpwQyxRQUtNLFlBQVk7QUFMbEIsUUFNTSxpQkFBaUI7QUFOdkIsUUFPTSxXQUFXO09BQ1IsV0FBQSxpQkFBaUI7T0FDakIsV0FBQSxzQkFBc0I7O1FBRy9CLFdBQWU7QUFFZiwyQkFBdUIsTUFBSTtBQUN6QixVQUFJO0FBRUosWUFBTSxjQUFjLEtBQUssa0JBQ25CLG1CQUFtQixPQUFNLGNBQ3pCLGFBQWE7QUFFbkIsY0FBUSxXQUFXO0FBRW5CLFlBQU0sWUFBWSxPQUFNLFFBQ2xCLHFCQUFxQixXQUNyQixPQUFPLG1CQUFtQixXQUMxQixvQkFBb0I7QUFFMUIsY0FBUSxrQkFBa0I7QUFFMUIsWUFBTSxRQUFRLE1BQU0sSUFBSSxDQUFDLFVBQUE7QUFDdkIsY0FBTSwyQkFBMkIsT0FDM0IsdUJBQXVCLHlCQUF5QiwyQkFDaEQsT0FBTztBQUViLGVBQU87O0FBR1QsYUFBTzs7Ozs7QUNoRFQ7Ozs7Ozs7Ozs7Ozs7VUFtQmdCLGNBQUE7ZUFBQTs7VUEwREEscUJBQUE7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFsRWhCLFFBQU0sQ0FBRSxlQUFPLFVBQVcsV0FBQTtBQUUxQixRQUFNLHVCQUF1QixJQUFBLE9BQUEsWUFBVztBQUF4QyxRQUNNLDRCQUE0QixJQUFBLE9BQUEsV0FBVTtBQUQ1QyxRQUVNLDhCQUE4QixJQUFBLE9BQUEsV0FBVTtBQUY5QyxRQUdNLGtDQUFrQyxJQUFBLE9BQUEsWUFBVztBQUhuRCxRQUlNLHlDQUF5QyxJQUFBLE9BQUEsWUFBVztBQUVuRCx5QkFBcUIsS0FBSyxVQUFRO0FBQ3ZDLFlBQU0sVUFBVSxLQUNWLFNBQVMsU0FBQSxzQkFBc0IsU0FBUyxVQUN4QyxPQUFPLFNBQUEsdUJBQXVCLE1BQU07QUFFMUMsVUFBSSxTQUFTLE1BQU07QUFDakI7O0FBR0YsWUFBTSx1QkFBdUIsMEJBQTBCO0FBRXZELFVBQUkseUJBQXlCLE1BQU07QUFDakMsY0FBTSxPQUFPLDZCQUE2QjtBQUUxQyxZQUFJLFNBQVMsVUFBVTtBQUNyQixnQkFBTSxJQUFJLE1BQU0sUUFBUSwrQkFBK0I7OztBQUkzRCxZQUFNLFFBQVEsVUFBQSxRQUFTLFdBQ2pCLG9DQUFvQyx1Q0FBdUM7QUFFakYsd0NBQWtDLFFBQVEsQ0FBQyxxQ0FBQTtBQUN6QyxjQUFNLE9BQU8seUNBQXlDLG1DQUNoRCxtQkFBbUIsTUFBTSxTQUFTO0FBRXhDLFlBQUksQ0FBQyxrQkFBa0I7QUFDckIsZ0JBQU0sSUFBSSxNQUFNLFFBQVEsc0NBQXNDOzs7QUFJbEUsWUFBTSw2QkFBNkIsZ0NBQWdDO0FBRW5FLGlDQUEyQixRQUFRLENBQUMsOEJBQUE7QUFDbEMsY0FBTSxXQUFVLHFDQUFxQztBQUVyRCxZQUFJLGFBQVksV0FBQSxrQkFBa0I7QUFDaEMsZ0JBQU0sSUFBSSxNQUFNLFFBQVE7O0FBRzFCLGNBQU0sVUFBUyxTQUFBLGFBQWEsU0FBUyxXQUMvQixlQUFlLFFBQU87QUFFNUIsWUFBSSxpQkFBaUIsR0FBRztBQUN0QixnQkFBTSxJQUFJLE1BQU0sbUJBQW1COztBQUdyQyxjQUFNLGFBQWEsT0FBTSxVQUNuQixRQUFRLFlBQ1IsT0FBTyxNQUFNLFdBQ2IsbUJBQW1CLE1BQU0sU0FBUztBQUV4QyxZQUFJLENBQUMsa0JBQWtCO0FBQ3JCLGdCQUFNLElBQUksTUFBTSxRQUFRLHVDQUFzQyxzQ0FBc0M7Ozs7QUFLbkcsZ0NBQTRCLFlBQVU7QUFDM0MsWUFBTSxVQUFVLFlBQ1YsU0FBUyxTQUFBLDZCQUE2QixTQUFTLFVBQy9DLE9BQU8sU0FBQSw4QkFBOEIsTUFBTTtBQUVqRCxVQUFJLFNBQVMsTUFBTTtBQUNqQjs7QUFHRixZQUFNLGtCQUFrQixxQkFBcUI7QUFFN0Msc0JBQWdCLFFBQVEsQ0FBQyxtQkFBQTtBQUN2QixjQUFNLFdBQVUsMEJBQTBCLGlCQUNwQyxVQUFTLFNBQUEsYUFBYSxTQUFTLFdBQy9CLGVBQWUsUUFBTztBQUU1QixZQUFJLGVBQWUsR0FBRztBQUNwQixnQkFBTSxJQUFJLE1BQU0sbUJBQW1COztBQUdyQyxjQUFNLGFBQWEsT0FBTSxVQUNuQixRQUFRLFlBQ1IsT0FBTyxNQUFNO0FBRW5CLFlBQUksU0FBUyxXQUFBLGlCQUFpQjtBQUM1QixnQkFBTSxJQUFJLE1BQU0sUUFBUSxzQkFBc0I7O0FBR2hELFlBQUksYUFBWSxXQUFBLGtCQUFrQjtBQUNoQyxnQkFBTSxJQUFJLE1BQU0sUUFBUTs7OztBQUs5Qix1Q0FBbUMsZ0JBQWM7QUFDL0MsVUFBSTtBQUVKLFlBQU0seUJBQXlCLDRCQUE0QjtBQUUzRCxnQkFBVSx1QkFBdUI7QUFFakMsYUFBTzs7O0FBR1QsMENBQXNDLHNCQUFvQjtBQUN4RCxVQUFJO0FBRUosWUFBTSxVQUFVLHFCQUFxQjtBQUVyQyxhQUFPO0FBRVAsYUFBTzs7QUFHVCxrREFBOEMsMkJBQXlCO0FBQ3JFLFVBQUk7QUFFSixnQkFBVSwwQkFBMEI7QUFFcEMsWUFBTSxVQUFVLFFBQVEsTUFBTSxjQUN4QixjQUFjLE9BQU87QUFFM0IsZ0JBQVU7QUFFVixhQUFPOztBQUdULHNEQUFrRCxrQ0FBZ0M7QUFDaEYsVUFBSTtBQUVKLFlBQU0sVUFBVSxpQ0FBaUMsY0FDM0MsVUFBVSxRQUFRLE1BQU0saUJBQ3hCLGNBQWMsT0FBTztBQUUzQixhQUFPO0FBRVAsYUFBTzs7Ozs7QUN6SlQ7Ozs7O21DQW1CQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUpyQixRQUFNLENBQUUsVUFBWSxhQUFBO0FBQXBCLFFBQ00sQ0FBRSxnQkFBaUIsY0FBQTtBQUR6QixRQUVNLENBQUUsU0FBUyxpQkFBaUIsb0JBQXFCLFdBQUE7QUFFeEMsc0NBQU07TUFDbkIsWUFBWSxPQUFPLFNBQVM7QUFDMUIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxVQUFVOztNQUdqQixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsWUFBWSxPQUFPO0FBQ2pCLGdCQUFRO2FBQ0g7YUFDQSxLQUFLOztBQUdWLGdCQUFRLElBQUEsdUJBQUEsd0JBQXVCO0FBRS9CLGVBQU87O2FBR0YsWUFBWSxpQkFBaUIsTUFBTTtBQUN4QyxZQUFJLGlCQUFpQjtBQUVyQixZQUFJLGdCQUFnQjtBQUNsQiwyQkFBaUI7WUFBRSxTQUFBO2VBQXlCOzs7QUFHOUMsY0FBTSxRQUFRLHdCQUF3QixpQkFDaEMsVUFBVSwwQkFBMEIsaUJBQ3BDLHdCQUF3QixJQUFJLHNCQUFzQixPQUFPO0FBRS9ELGVBQU87O2FBR0YsbUJBQW1CLGdCQUFnQixpQkFBaUIsTUFBTTtBQUMvRCxZQUFJLGdCQUFnQjtBQUNsQiwyQkFBaUI7WUFBRSxTQUFBO2VBQXlCOzs7QUFHOUMsY0FBTSxRQUFRLHdCQUF3QixpQkFDaEMsVUFBVSwwQkFBMEIsaUJBQ3BDLHdCQUF3QixJQUFJLHNCQUFzQixPQUFPO0FBRS9ELGVBQU87OztBQUlYLHFDQUFpQyxnQkFBYztBQUM3QyxZQUFNLFlBQVk7UUFDVixXQUFBO1FBQ0EsV0FBQTtTQUVGLE9BQU8sVUFBVSxJQUFJLENBQUMsYUFBQTtBQUNwQixjQUFNLE9BQU0sc0JBQXNCLGdCQUFnQjtBQUVsRCxlQUFPO1VBRVQsTUFBTSxLQUFLLEtBQUssV0FBQSxpQkFDaEIsUUFBUSxhQUFhO0FBRTNCLG1CQUFhO0FBRWIsWUFBTSxVQUFVO0FBRWhCLGdCQUFVLFFBQVEsQ0FBQyxhQUFBO0FBQ2pCLGNBQU0sT0FBTyxNQUFNLEtBQUssQ0FBQyxVQUFBO0FBQ3ZCLGdCQUFNLE9BQU8sTUFBSztBQUVsQixjQUFJLFNBQVMsVUFBVTtBQUNyQixtQkFBTzs7O0FBSVgsYUFBSyxXQUFXOztBQUdsQixhQUFPOztBQUdULHVDQUFtQyxnQkFBYztBQUMvQyxZQUFNLGtCQUFrQjtRQUNoQixpQkFBQTtRQUNBLGlCQUFBO1NBRUYsVUFBVSxnQkFBZ0IsSUFBSSxDQUFDLG1CQUFBO0FBQzdCLGNBQU0sUUFBUSx3QkFBd0IsZ0JBQWdCO0FBRXRELGVBQU87O0FBR2YsYUFBTzs7QUFHVCxxQ0FBaUMsZ0JBQWdCLGdCQUFjO0FBQzdELFlBQU0sY0FBYztBQUVwQix1QkFBaUIsZ0JBQWdCLENBQUMsa0JBQUE7QUFDaEMsY0FBTSxhQUFhLGNBQWMsY0FBYyxpQkFDekMsb0NBQW9DLGNBQWM7QUFFeEQsWUFBSSxDQUFDLG1DQUFtQztBQUN0QyxVQUFBLElBQUEsVUFBQSxvQkFBbUI7O0FBR3JCLFFBQUEsSUFBQSxZQUFBLDJCQUEwQixZQUFZOztBQUd4QyxZQUFNLFVBQVUsWUFBWSxLQUFLLFdBQUEsZUFDM0IsWUFBWSxnQkFDWixhQUFhLE9BQU8sWUFDcEIsUUFBUTtTQUNMLFlBQVk7O0FBR3JCLGFBQU87O0FBR1QsbUNBQStCLGdCQUFnQixVQUFRO0FBQ3JELFlBQU0sT0FBTztBQUViLHNCQUFnQixnQkFBZ0IsQ0FBQyxrQkFBQTtBQUMvQixjQUFNLE9BQU0sY0FBYyxPQUFPLFdBQzNCLG9DQUFvQyxjQUFjO0FBRXhELFlBQUksQ0FBQyxtQ0FBbUM7QUFDdEMsVUFBQSxJQUFBLFVBQUEsYUFBWSxNQUFLOztBQUduQixhQUFLLEtBQUs7O0FBR1osWUFBTSxNQUFNLEtBQUssS0FBSyxXQUFBO0FBRXRCLGFBQU87O0FBR1QsMEJBQXNCLE9BQUs7QUFDekIsVUFBSSxhQUFhLEdBQ2IsU0FBUyxNQUFNO0FBRW5CLGFBQU8sYUFBYSxRQUFRO0FBQzFCLGNBQU0sWUFBWSxNQUFNLGFBQ2xCLGdCQUFnQixVQUFVO0FBRWhDLFlBQUksYUFBYSxhQUFhO0FBRTlCLGVBQU8sYUFBYSxRQUFRO0FBQzFCLGdCQUFNLFlBQVksTUFBTSxhQUNsQixnQkFBZ0IsVUFBVTtBQUVoQyxjQUFJLGtCQUFrQixlQUFlO0FBQ25DLGtCQUFNLHVCQUF1QixVQUFVLGtCQUNqQyx1QkFBdUIsVUFBVTtBQUV2QyxvQkFBUSxzQkFBc0I7QUFFOUIsa0JBQU0sUUFBUSxZQUNSLGNBQWM7QUFFcEIsa0JBQU0sT0FBTyxPQUFPO0FBRXBCLHFCQUFTLE1BQU07aUJBQ1Y7QUFDTDs7O0FBSUo7QUFFQSxpQkFBUyxNQUFNOzs7Ozs7QUNqTW5COzs7Ozs7Ozs7Ozs7O1VBZ0NBLFVBQUE7ZUFBQTs7VUFmZ0IsaUNBQUE7ZUFBQTs7VUFRQSwyQ0FBQTtlQUFBOztVQWpCQSxtQkFBQTtlQUFBOzs7Ozs7Ozs7O0FBRmhCLFFBQU0sQ0FBRSxnQkFBZ0Isb0JBQXFCLGFBQUE7QUFFdEMsOEJBQTBCLE9BQUs7QUFDcEMsWUFBTSxDQUFFLFdBQVksT0FDZCx3QkFBd0IsVUFBQSxRQUFzQixlQUM5QyxRQUFRLHlDQUF5QyxTQUFTLHdCQUMxRCxRQUFRLGVBQWUsT0FBTztBQUVwQyxhQUFPOztBQUdGLDRDQUF3QyxPQUFPLHVCQUFxQjtBQUN6RSxZQUFNLENBQUUsV0FBWSxPQUNkLFFBQVEseUNBQXlDLFNBQVMsd0JBQzFELFFBQVEsZUFBZSxPQUFPO0FBRXBDLGFBQU87O0FBR0Ysc0RBQWtELE9BQU8sU0FBUyx1QkFBcUI7QUFDNUYsWUFBTSxRQUFRLHlDQUF5QyxTQUFTLHdCQUMxRCxRQUFRLGVBQWUsT0FBTztBQUVwQyxhQUFPOztRQUdULFdBQWU7TUFDYjtNQUNBO01BQ0E7O0FBR0Ysc0RBQWtELFNBQVMsdUJBQXFCO0FBQzlFLFlBQU0sdUJBQXVCLHNCQUFzQjtBQUVuRCxnQkFBVTtXQUNMO1dBQ0E7O0FBR0wsWUFBTSxRQUFRLGlCQUFpQjtBQUUvQixhQUFPOzs7OztBQ2hEVDs7Ozs7Ozs7Ozs7OztVQXdEQSxVQUFBO2VBQUE7O1VBdEJnQix3Q0FBQTtlQUFBOztVQWVBLHFEQUFBO2VBQUE7O1VBdkJBLGtDQUFBO2VBQUE7O1VBbEJBLG9CQUFBO2VBQUE7O1VBU0EsMEJBQUE7ZUFBQTs7VUF3QkEsa0RBQUE7ZUFBQTs7Ozs7Ozs7OztBQW5DaEIsUUFBTSxDQUFFLGNBQWMsaUJBQWlCLG1DQUFvQyxjQUFBO0FBRXBFLCtCQUEyQixPQUFLO0FBQ3JDLFlBQU0sQ0FBRSxPQUFRLE9BQ1Ysd0JBQXdCLFVBQUEsUUFBc0IsZUFDOUMsUUFBUSxxQ0FBcUMsS0FBSyx3QkFDbEQsU0FBUyxnQkFBZ0IsT0FBTztBQUV0QyxhQUFPOztBQUdGLHFDQUFpQyxPQUFPLGVBQWE7QUFDMUQsWUFBTSxDQUFFLE9BQVEsT0FDVix3QkFBd0IsVUFBQSxRQUFzQixlQUM5QyxRQUFRLHFDQUFxQyxLQUFLLHdCQUNsRCxTQUFTLGdDQUFnQyxPQUFPLE9BQU87QUFFN0QsYUFBTzs7QUFHRiw2Q0FBeUMsT0FBTyx1QkFBcUI7QUFDMUUsWUFBTSxDQUFFLE9BQVEsT0FDVixRQUFRLHFDQUFxQyxLQUFLLHdCQUNsRCxTQUFTLGdCQUFnQixPQUFPO0FBRXRDLGFBQU87O0FBR0YsbURBQStDLE9BQU8sS0FBSyx1QkFBcUI7QUFDckYsWUFBTSxRQUFRLHFDQUFxQyxLQUFLLHdCQUNsRCxTQUFTLGdCQUFnQixPQUFPO0FBRXRDLGFBQU87O0FBR0YsNkRBQXlELE9BQU8sZUFBZSx1QkFBcUI7QUFDekcsWUFBTSxDQUFFLE9BQVEsT0FDVixRQUFRLHFDQUFxQyxLQUFLLHdCQUNsRCxTQUFTLGdDQUFnQyxPQUFPLE9BQU87QUFFN0QsYUFBTzs7QUFHRixnRUFBNEQsT0FBTyxLQUFLLGVBQWUsdUJBQXFCO0FBQ2pILFlBQU0sUUFBUSxxQ0FBcUMsS0FBSyx3QkFDbEQsU0FBUyxnQ0FBZ0MsT0FBTyxPQUFPO0FBRTdELGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7QUFHRixrREFBOEMsS0FBSyx1QkFBcUI7QUFDdEUsVUFBSSxRQUFRLGFBQWE7QUFFekIsY0FBUSxzQkFBc0IsWUFBWTtBQUUxQyxhQUFPOzs7OztBQ3RFVDs7Ozs7Ozs7Ozs7OztVQTRCZ0IsMENBQUE7ZUFBQTs7VUF2QkEsZ0NBQUE7ZUFBQTs7VUFnQkEsbUNBQUE7ZUFBQTs7VUFtQmhCLFVBQUE7ZUFBQTs7Ozs7Ozs7OztBQW5DTywyQ0FBdUMsTUFBSTtBQUNoRCxZQUFNLHFCQUFxQixNQUNyQixpQkFBaUIsbUJBQW1CLElBQUksQ0FBQyxzQkFBQTtBQUN2QyxjQUFNLFFBQU8sbUJBQ1AsZ0JBQWdCLGVBQUEsUUFBYyxTQUFTO0FBRTdDLGVBQU87O0FBR2YscUJBQWU7QUFFZixZQUFNLHdCQUF3QixVQUFBLFFBQXNCLG1CQUFtQjtBQUV2RSxhQUFPOztBQUdGLGdEQUFTO0FBQ2QsWUFBTSxpQkFBaUIsSUFDakIsd0JBQXdCLFVBQUEsUUFBc0IsbUJBQW1CO0FBRXZFLGFBQU87O0FBR0YscURBQWlELGdCQUFjO0FBQ3BFLHVCQUFpQjtXQUNaOztBQUdMLHFCQUFlO0FBRWYsWUFBTSx3QkFBd0IsVUFBQSxRQUFzQixtQkFBbUI7QUFFdkUsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTtNQUNBOzs7OztBQzNDRjs7Ozs7Ozs7Ozs7OztVQVNvQix3QkFBQTtlQUFBLFVBQUE7O1VBRkEsZ0JBQUE7ZUFBQSxlQUFBOztVQUxYLDhCQUFBO2VBQUEsY0FBQTs7VUFXVyx5QkFBQTtlQUFBLGdCQUFBOztVQUxBLHVCQUFBO2VBQUEsU0FBQTs7VUFHQSxrQkFBQTtlQUFBLFFBQUE7O1VBQ0EsbUJBQUE7ZUFBQSxTQUFBOztVQVJBLFlBQUE7ZUFBQSxXQUFBOztVQUNBLGtCQUFBO2VBQUEsaUJBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTHBCOzs7Ozs7Ozs7Ozs7O1VBZ0JnQiwyQ0FBQTtlQUFBOztVQVZBLGtDQUFBO2VBQUE7Ozs7QUFGaEIsUUFBTSxDQUFFLDJDQUE0QyxxQkFBQTtBQUU3Qyw2Q0FBeUMsTUFBTSxTQUFPO0FBQzNELFlBQU0sVUFBVSxRQUFRLGNBQ2xCLGVBQWUsUUFBUSxtQkFDdkIsaUJBQWlCLFFBQVEscUJBQ3pCLG1CQUFtQixRQUFRLHVCQUMzQixnQkFBZ0IscUJBQUEsY0FBYyw2REFBNkQsTUFBTSxTQUFTLGNBQWMsZ0JBQWdCO0FBRTlJLGFBQU87O0FBR0Ysc0RBQWtELGlCQUFlO0FBQ3RFLFlBQU0saUJBQWlCLGdCQUFnQixJQUFJLENBQUMsbUJBQUE7QUFDMUMsY0FBTSxnQkFBZ0IsZUFBZTtBQUVyQyxlQUFPOztBQUdULFlBQU0sd0JBQXdCLHdDQUF3QztBQUV0RSxhQUFPOzs7OztBQ3pCVDs7Ozs7Ozs7Ozs7OztVQStCQSxVQUFBO2VBQUE7O1VBYmdCLDBCQUFBO2VBQUE7O1VBaEJBLHVCQUFBO2VBQUE7OztBQUFULGtDQUE4QixNQUFNLGNBQWMsZ0JBQWdCLHlCQUF1QjtBQUM5RixZQUFNLG1CQUFtQjtBQUV6Qix1QkFBaUIsUUFBUSxDQUFDLG9CQUFBO0FBQ3hCLGNBQU0sQ0FBRSxZQUFhLGlCQUNmLGNBQWMsd0JBQXdCO0FBRTVDLFlBQUksZ0JBQWdCLE1BQU07QUFDeEIsZ0JBQU0sUUFBTyxpQkFDUCxjQUFjLFlBQVksU0FBUyxPQUFNO0FBRS9DLHVCQUFhLEtBQUs7Ozs7QUFLakIscUNBQWlDLFNBQVMsY0FBYyxnQkFBZ0IseUJBQXVCO0FBQ3BHLGNBQVEsWUFBWSxDQUFDLFNBQUE7QUFDbkIsY0FBTSxXQUFXLEtBQUssV0FDaEIsY0FBYyx3QkFBd0I7QUFFNUMsWUFBSSxnQkFBZ0IsTUFBTTtBQUN4QixnQkFBTSxjQUFjLFlBQVksU0FBUyxNQUFNO0FBRS9DLHVCQUFhLEtBQUs7Ozs7UUFLeEIsV0FBZTtNQUNiO01BQ0E7Ozs7O0FDakNGOzs7OzttQ0FXQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7O0FBRnJCLFFBQU0sQ0FBRSxNQUFNLE1BQU0saUJBQVUsV0FBQTtBQUVmLCtCQUFNO01BQ25CLFlBQVksS0FBSyxNQUFNLE1BQU0sU0FBUyxVQUFVLGVBQWUsVUFBVSxhQUFhLGNBQWMsdUJBQXVCLDJCQUEyQjtBQUNwSixhQUFLLE1BQU07QUFDWCxhQUFLLE9BQU87QUFDWixhQUFLLE9BQU87QUFDWixhQUFLLFVBQVU7QUFDZixhQUFLLFdBQVc7QUFDaEIsYUFBSyxnQkFBZ0I7QUFDckIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssY0FBYztBQUNuQixhQUFLLGVBQWU7QUFDcEIsYUFBSyx3QkFBd0I7QUFDN0IsYUFBSyw0QkFBNEI7O01BR25DLFNBQVM7QUFDUCxlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxtQkFBbUI7QUFDakIsZUFBTyxLQUFLOztNQUdkLGNBQWM7QUFDWixlQUFPLEtBQUs7O01BR2QsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLOztNQUdkLGtCQUFrQjtBQUNoQixlQUFPLEtBQUs7O01BR2QsMkJBQTJCO0FBQ3pCLGVBQU8sS0FBSzs7TUFHZCwrQkFBK0I7QUFDN0IsZUFBTyxLQUFLOztNQUdkLG9CQUFvQjtBQUNsQixjQUFNLGlCQUFpQjtBQUV2QixlQUFPOztNQUdULFdBQVc7QUFDVCxjQUFNLFFBQVE7QUFFZCxlQUFPOztNQUdULGNBQWM7QUFDWixjQUFNLFdBQVcsS0FBSztBQUV0QixlQUFPOztNQUdULGFBQWE7QUFDWCxjQUFNLFdBQVksS0FBSyxTQUFTO0FBRWhDLGVBQU87O01BR1QsZ0JBQWdCO0FBQ2QsWUFBSSxhQUFhO0FBRWpCLGNBQU0sc0JBQXNCLE9BQ3RCLGVBQWUsS0FBSyxnQkFBZ0Isc0JBQ3BDLHFCQUFxQixhQUFhO0FBRXhDLFlBQUksdUJBQXVCLEdBQUc7QUFDNUIsZ0JBQU0sa0JBQWtCLE9BQU07QUFFOUIsdUJBQWE7O0FBR2YsZUFBTzs7TUFHVCxVQUFVLHNCQUFzQixNQUFNO0FBQ3BDLGNBQU0sU0FBUztBQUVmLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLG9CQUFvQixZQUFZLFVBQVU7QUFFaEQsZUFBSyxRQUFROztBQUdmLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIsdUJBQXVCLGVBQWUsVUFBVTtBQUV0RCxpQkFBSyxRQUFROzs7QUFJakIsZUFBTzs7TUFHVCxTQUFTLHNCQUFzQixNQUFNO0FBQ25DLGNBQU0sUUFBUTtBQUVkLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLG1CQUFtQixZQUFZLFNBQVM7QUFFOUMsZUFBSyxPQUFPOztBQUdkLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIsc0JBQXNCLGVBQWUsU0FBUztBQUVwRCxpQkFBSyxPQUFPOzs7QUFJaEIsZUFBTzs7TUFHVCxTQUFTLHNCQUFzQixNQUFNO0FBQ25DLGNBQU0sUUFBUTtBQUVkLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLG1CQUFtQixZQUFZLFNBQVM7QUFFOUMsZUFBSyxPQUFPOztBQUdkLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIsc0JBQXNCLGVBQWUsU0FBUztBQUVwRCxpQkFBSyxPQUFPOzs7QUFJaEIsZUFBTzs7TUFHVCxVQUFVLHNCQUFzQixNQUFNO0FBQ3BDLGNBQU0sU0FBUztBQUVmLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLG9CQUFvQixZQUFZLFVBQVU7QUFFaEQsZUFBSyxRQUFROztBQUdmLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIsdUJBQXVCLGVBQWUsVUFBVTtBQUV0RCxpQkFBSyxRQUFROzs7QUFJakIsZUFBTzs7TUFHVCxVQUFVLHNCQUFzQixNQUFNO0FBQ3BDLGNBQU0sU0FBUztBQUVmLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLG9CQUFvQixZQUFZLFVBQVU7QUFFaEQsZUFBSyxRQUFROztBQUdmLGVBQU87O01BR1QsWUFBWSxzQkFBc0IsTUFBTTtBQUN0QyxjQUFNLFdBQVc7QUFFakIsYUFBSyxhQUFhLFFBQVEsQ0FBQyxnQkFBQTtBQUN6QixnQkFBTSxpQkFBaUIsT0FDakIsc0JBQXNCLFlBQVksWUFBWTtBQUVwRCxlQUFLLFVBQVU7O0FBR2pCLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIseUJBQXlCLGVBQWUsWUFBWTtBQUUxRCxpQkFBSyxVQUFVOzs7QUFJbkIsZUFBTzs7TUFHVCxjQUFjLHNCQUFzQixNQUFNO0FBQ3hDLGNBQU0sYUFBYTtBQUVuQixhQUFLLGFBQWEsUUFBUSxDQUFDLGdCQUFBO0FBQ3pCLGdCQUFNLGlCQUFpQixPQUNqQix3QkFBd0IsWUFBWSxjQUFjO0FBRXhELGVBQUssWUFBWTs7QUFHbkIsWUFBSSxxQkFBcUI7QUFDdkIsZUFBSywwQkFBMEIsUUFBUSxDQUFDLG1CQUFBO0FBQ3RDLGtCQUFNLHVCQUFzQixPQUN0QiwyQkFBMkIsZUFBZSxjQUFjO0FBRTlELGlCQUFLLFlBQVk7OztBQUlyQixlQUFPOztNQUdULGNBQWMsc0JBQXNCLE1BQU07QUFDeEMsY0FBTSxhQUFhO0FBRW5CLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLHdCQUF3QixZQUFZLGNBQWM7QUFFeEQsZUFBSyxZQUFZOztBQUduQixlQUFPOztNQUdULGVBQWUsc0JBQXNCLE1BQU07QUFDekMsY0FBTSxjQUFjO0FBRXBCLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLHlCQUF5QixZQUFZLGVBQWU7QUFFMUQsZUFBSyxhQUFhOztBQUdwQixZQUFJLHFCQUFxQjtBQUN2QixlQUFLLDBCQUEwQixRQUFRLENBQUMsbUJBQUE7QUFDdEMsa0JBQU0sdUJBQXNCLE9BQ3RCLDRCQUE0QixlQUFlLGVBQWU7QUFFaEUsaUJBQUssYUFBYTs7O0FBSXRCLGVBQU87O01BR1QsZUFBZSxzQkFBc0IsTUFBTTtBQUN6QyxjQUFNLGNBQWM7QUFFcEIsYUFBSyxhQUFhLFFBQVEsQ0FBQyxnQkFBQTtBQUN6QixnQkFBTSxpQkFBaUIsT0FDakIseUJBQXlCLFlBQVksZUFBZTtBQUUxRCxlQUFLLGFBQWE7O0FBR3BCLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIsNEJBQTRCLGVBQWUsZUFBZTtBQUVoRSxpQkFBSyxhQUFhOzs7QUFJdEIsZUFBTzs7TUFHVCxnQkFBZ0Isc0JBQXNCLE1BQU07QUFDMUMsY0FBTSxlQUFlO0FBRXJCLGFBQUssYUFBYSxRQUFRLENBQUMsZ0JBQUE7QUFDekIsZ0JBQU0saUJBQWlCLE9BQ2pCLDBCQUEwQixZQUFZLGdCQUFnQjtBQUU1RCxlQUFLLGNBQWM7O0FBR3JCLFlBQUkscUJBQXFCO0FBQ3ZCLGVBQUssMEJBQTBCLFFBQVEsQ0FBQyxtQkFBQTtBQUN0QyxrQkFBTSx1QkFBc0IsT0FDdEIsNkJBQTZCLGVBQWUsZ0JBQWdCO0FBRWxFLGlCQUFLLGNBQWM7OztBQUl2QixlQUFPOztNQUdULGdCQUFnQixzQkFBc0IsTUFBTTtBQUMxQyxjQUFNLGVBQWU7QUFFckIsYUFBSyxhQUFhLFFBQVEsQ0FBQyxnQkFBQTtBQUN6QixnQkFBTSxpQkFBaUIsT0FDakIsMEJBQTBCLFlBQVksZ0JBQWdCO0FBRTVELGVBQUssY0FBYzs7QUFHckIsWUFBSSxxQkFBcUI7QUFDdkIsZUFBSywwQkFBMEIsUUFBUSxDQUFDLG1CQUFBO0FBQ3RDLGtCQUFNLHVCQUFzQixPQUN0Qiw2QkFBNkIsZUFBZSxnQkFBZ0I7QUFFbEUsaUJBQUssY0FBYzs7O0FBSXZCLGVBQU87O01BR1QsZ0JBQWdCLHNCQUFzQixNQUFNO0FBQzFDLGNBQU0sZUFBZTtBQUVyQixhQUFLLGFBQWEsUUFBUSxDQUFDLGdCQUFBO0FBQ3pCLGdCQUFNLGlCQUFpQixPQUNqQiwwQkFBMEIsWUFBWSxnQkFBZ0I7QUFFNUQsZUFBSyxjQUFjOztBQUdyQixZQUFJLHFCQUFxQjtBQUN2QixlQUFLLDBCQUEwQixRQUFRLENBQUMsbUJBQUE7QUFDdEMsa0JBQU0sdUJBQXNCLE9BQ3RCLDZCQUE2QixlQUFlLGdCQUFnQjtBQUVsRSxpQkFBSyxjQUFjOzs7QUFJdkIsZUFBTzs7TUFHVCxrQkFBa0I7QUFBRSxlQUFPLEtBQUssUUFBUTs7TUFFeEMsc0JBQXNCLGtCQUFrQjtBQUFFLGVBQU8sS0FBSyxRQUFRLHNCQUFzQjs7TUFFcEYsU0FBUyxVQUFVO0FBQUUsZUFBTyxLQUFLLFFBQVEsU0FBUzs7TUFFbEQsZ0JBQWdCLFVBQVU7QUFDeEIsY0FBTSxjQUFjLEtBQUssYUFBYSxLQUFLLENBQUMsaUJBQUE7QUFDMUMsZ0JBQU0sa0JBQWtCLGFBQVksY0FBYztBQUVsRCxjQUFJLGlCQUFpQjtBQUNuQixtQkFBTzs7Y0FFTDtBQUVOLGVBQU87O01BR1QsTUFBTSxTQUFTO0FBQ2IsY0FBTSxRQUFRLFdBQUE7QUFFZCxhQUFLLFdBQVcsT0FBTzs7TUFHekIsTUFBTSxTQUFTO0FBQ2IsY0FBTSxRQUFRLFdBQUE7QUFFZCxhQUFLLFdBQVcsT0FBTzs7TUFHekIsS0FBSyxTQUFTO0FBQ1osY0FBTSxRQUFRLFdBQUE7QUFFZCxhQUFLLFdBQVcsT0FBTzs7TUFHekIsUUFBUSxTQUFTO0FBQ2YsY0FBTSxRQUFRLFdBQUE7QUFFZCxhQUFLLFdBQVcsT0FBTzs7TUFHekIsTUFBTSxTQUFTO0FBQ2IsY0FBTSxRQUFRLFdBQUE7QUFFZCxhQUFLLFdBQVcsT0FBTzs7TUFHekIsV0FBVyxPQUFPLFNBQVMsV0FBVyxNQUFNLFlBQVksTUFBTTtBQUM1RCxhQUFLLElBQUksTUFBTSxPQUFPLFNBQVMsVUFBVTs7TUFHM0MsV0FBVyxpQkFBaUIseUJBQXlCO0FBQ25ELGNBQU0sV0FBVyxLQUFLLGNBQ2hCLGlCQUFpQixNQUNqQixzQkFBc0IsS0FBSztBQUVqQyxhQUFLLDRCQUE0QjtBQUVqQyxhQUFLLHdCQUF3QixJQUFBLGVBQUEsMENBQXlDO0FBRXRFLG1CQUNFLElBQUEsYUFBQSxzQkFBcUIsS0FBSyxNQUFNLEtBQUssY0FBYyxnQkFBZ0IsMkJBQ2pFLElBQUEsYUFBQSx5QkFBd0IsS0FBSyxTQUFTLEtBQUssY0FBYyxnQkFBZ0I7QUFFN0UsYUFBSyxjQUFjOztZQUdmLE1BQU0sVUFBVSxXQUFXO0FBQy9CLGNBQU0sUUFBUSxXQUFBLGFBQ1IsVUFBVSxXQUFBO0FBRWhCLGFBQUssV0FBVyxPQUFPLFNBQVMsVUFBVTtBQUUxQyxjQUFNLFdBQVU7QUFFaEIsY0FBTSxLQUFLLFNBQVMsVUFBUyxVQUFVOztZQUduQyxTQUFTO0FBQ2IsWUFBSSxXQUFXO0FBRWYsY0FBTSxlQUFlLEtBQUssbUJBQ3BCLGlCQUFpQixNQUNqQixxQkFBcUIsSUFBQSxRQUFBLG9CQUFtQixjQUFjO0FBRTVELFlBQUksb0JBQW9CO0FBQ3RCLGdCQUFNLHVCQUF1QixJQUN2QixxQkFBcUIsTUFBTSxJQUFBLFFBQUEsb0JBQW1CLEtBQUssY0FBYztBQUV2RSxjQUFJLG9CQUFvQjtBQUN0Qix1QkFBVztBQUVYLGlCQUFLLFdBQVc7QUFFaEIsaUJBQUssZUFBZTs7O0FBSXhCLGVBQU87O01BR1QsU0FBUztBQUNQLGNBQU0sbUJBQW1CLEtBQUssYUFBYSxJQUFJLENBQUMsZ0JBQUE7QUFDeEMsZ0JBQU0sa0JBQWtCLFlBQVk7QUFFcEMsaUJBQU87WUFFVCxPQUFPO0FBRWIsZUFBTzs7YUFHRiwrQ0FBK0MsS0FBSyxNQUFNLE1BQU0sU0FBUyxVQUFVLGVBQWU7QUFDdkcsY0FBTSxXQUFXLE9BQ1gsY0FBYyxPQUNkLGVBQWUsSUFDZix3QkFBd0IsTUFDeEIsNEJBQTRCLE1BQzVCLGlCQUFpQixJQUFJLGVBQWUsS0FBSyxNQUFNLE1BQU0sU0FBUyxVQUFVLGVBQWUsVUFBVSxhQUFhLGNBQWMsdUJBQXVCO0FBRXpKLGVBQU87Ozs7OztBQ25mWDs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7OztBQUZyQixRQUFNLENBQUUsaUJBQVUsV0FBQTtBQUVILHdDQUE4QixjQUFBLGdCQUFtQjtNQUM5RCxpQkFBaUIsVUFBVSxXQUFXO0FBQ3BDLGVBQU8sS0FBSyxjQUFjLENBQUMsV0FBVyxVQUFBO0FBQ3BDLGdCQUFNLHdCQUF3QixVQUFVO0FBRXhDLGNBQUksdUJBQXVCO0FBQ3pCLGtCQUFNLGVBQWUsV0FDZixtQkFBbUIsYUFBYTtBQUV0QyxnQkFBSSxxQkFBcUIsV0FBVztBQUNsQyxxQkFBTyxTQUFTLGNBQWM7Ozs7O01BTXRDLHFCQUFxQixXQUFXO0FBQzlCLGNBQU0sT0FBTyxLQUFLLGNBQWMsQ0FBQyxjQUFBO0FBQy9CLGdCQUFNLDJCQUEyQixVQUFVO0FBRTNDLGNBQUksMEJBQTBCO0FBQzVCLGtCQUFNLGtCQUFrQixXQUNsQixXQUFXLGdCQUFnQixlQUMzQiw0QkFBNEIsVUFBVSxTQUFTO0FBRXJELGdCQUFJLDJCQUEyQjtBQUM3QixxQkFBTzs7O2NBR1A7QUFFTixlQUFPOztNQUdULHNCQUFzQixXQUFXO0FBQy9CLGNBQU0sUUFBUSxLQUFLLGdCQUFnQixDQUFDLGNBQUE7QUFDbEMsZ0JBQU0sMkJBQTJCLFVBQVU7QUFFM0MsY0FBSSwwQkFBMEI7QUFDNUIsa0JBQU0sa0JBQWtCLFdBQ2xCLFdBQVcsZ0JBQWdCLGVBQzNCLDRCQUE0QixVQUFVLFNBQVM7QUFFckQsZ0JBQUksMkJBQTJCO0FBQzdCLHFCQUFPOzs7O0FBS2IsZUFBTzs7TUFHVCx5QkFBeUIsV0FBVztBQUNsQyxZQUFJLFdBQVc7QUFFZixhQUFLLHVCQUF1QixDQUFDLGNBQUE7QUFDM0IsZ0JBQU0sMkJBQTJCLFVBQVU7QUFFM0MsY0FBSSwwQkFBMEI7QUFDNUIsa0JBQU0sa0JBQWtCLFdBQ2xCLFdBQVcsZ0JBQWdCLGVBQzNCLDRCQUE0QixVQUFVLFNBQVM7QUFFckQsZ0JBQUksMkJBQTJCO0FBQzdCLHlCQUFXO0FBRVgscUJBQU87Ozs7QUFLYixlQUFPOztNQUdULDBCQUEwQixXQUFXO0FBQ25DLFlBQUksWUFBWTtBQUVoQixhQUFLLHNCQUFzQixDQUFDLGNBQUE7QUFDMUIsZ0JBQU0sMkJBQTJCLFVBQVU7QUFFM0MsY0FBSSwwQkFBMEI7QUFDNUIsa0JBQU0sa0JBQWtCLFdBQ2xCLFdBQVcsZ0JBQWdCLGVBQzNCLDRCQUE0QixVQUFVLFNBQVM7QUFFckQsZ0JBQUksMkJBQTJCO0FBQzdCLDBCQUFZO0FBRVoscUJBQU87Ozs7QUFLYixlQUFPOztNQUdULDZCQUE2QixXQUFXO0FBQ3RDLFlBQUksZUFBZTtBQUVuQixjQUFNLFFBQVEsS0FBSyxnQkFBZ0IsQ0FBQyxjQUFBO0FBQzVCLGdCQUFNLDJCQUEyQixVQUFVO0FBRTNDLGNBQUksMEJBQTBCO0FBQzVCLGtCQUFNLGtCQUFrQixXQUNsQixXQUFXLGdCQUFnQixlQUMzQiw0QkFBNEIsVUFBVSxTQUFTO0FBRXJELGdCQUFJLDJCQUEyQjtBQUM3QixxQkFBTzs7O1lBSWIsY0FBYyxNQUFNO0FBRTFCLFlBQUksZ0JBQWdCLEdBQUc7QUFDckIsZ0JBQU0sWUFBWSxPQUFNO0FBRXhCLHlCQUFlOztBQUdqQixlQUFPOztNQUdULGdDQUFnQyxXQUFXO0FBQ3pDLGNBQU0sUUFBUSxLQUFLLHFCQUFxQixDQUFDLG1CQUFBO0FBQ3ZDLGdCQUFNLGdDQUFnQyxlQUFlO0FBRXJELGNBQUksK0JBQStCO0FBQ2pDLGtCQUFNLGtCQUFrQixnQkFDbEIsV0FBVyxnQkFBZ0IsZUFDM0IsNEJBQTRCLFVBQVUsU0FBUztBQUVyRCxnQkFBSSwyQkFBMkI7QUFDN0IscUJBQU87Ozs7QUFLYixlQUFPOzthQUdGLDJDQUEyQyxPQUFPLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGNBQUEsZ0JBQW9CLDJDQUEyQyxPQUFPLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNySnBOOzs7Ozs7Ozs7Ozs7O1VBMEJBLFVBQUE7ZUFBQTs7VUF0QmdCLFlBQUE7ZUFBQTs7VUFZQSxhQUFBO2VBQUE7Ozs7QUFaVCx1QkFBbUIsa0JBQWdCO0FBQ3hDLFlBQU0sUUFBUSxZQUFBLE1BQU0scUJBQXFCO0FBRXpDLGFBQU8sU0FBUyxNQUFJO0FBQ2xCLGNBQU0sUUFBUSxNQUFNLFFBQVE7QUFFNUIsZUFBTyxNQUFNLFdBQVc7QUFFeEIsZUFBTzs7O0FBSUosd0JBQW9CLGtCQUFnQjtBQUN6QyxZQUFNLFFBQVEsWUFBQSxNQUFNLHFCQUFxQjtBQUV6QyxhQUFPLFNBQVMsTUFBSTtBQUNsQixjQUFNLFFBQVEsTUFBTSxRQUFRO0FBRTVCLGVBQU87OztRQUlYLFdBQWU7TUFDYjtNQUNBOzs7OztBQzVCRjs7Ozs7Ozs7Ozs7OztVQTBCZ0IsMkJBQUE7ZUFBQTs7VUFsQkgsdUJBQUE7ZUFBQTs7VUFFRywyQkFBQTtlQUFBOzs7OztBQUpoQixRQUFNLENBQUUsU0FBVSxXQUFBO0FBRVgsUUFBTSx1QkFBdUIsSUFBQSxPQUFBLFdBQVU7QUFFdkMsc0NBQWtDLE9BQUs7QUFDNUMsWUFBTSxrQkFBa0I7QUFFeEIsWUFBTSxRQUFRLENBQUMsTUFBTSxVQUFBO0FBQ25CLGNBQU0sbUJBQW1CLEtBQUs7QUFFOUIsWUFBSSxrQkFBa0I7QUFDcEIsZ0JBQU0sZUFBZTtBQUVyQiwwQkFBZ0IsU0FBUzs7O0FBSTdCLGFBQU87O0FBR0Ysc0NBQWtDLHdCQUF3Qix5QkFBdUI7QUFDdEYsVUFBSSx3QkFBd0I7QUFFNUIsWUFBTSxpQkFBaUIsT0FBTyxLQUFLLHlCQUM3QixrQkFBa0IsT0FBTyxLQUFLLDBCQUM5QiwyQkFBMkIsTUFBTSxnQkFBZ0IsaUJBQWlCLENBQUMsY0FBYyxrQkFBQTtBQUMvRSxZQUFJLGlCQUFpQixlQUFlO0FBQ2xDLGlCQUFPOzs7QUFJakIsVUFBSSwwQkFBMEI7QUFDNUIsY0FBTSx1QkFBdUIsT0FBTyxPQUFPLHlCQUNyQyx3QkFBd0IsT0FBTyxPQUFPLDBCQUN0Qyw2QkFBNkIsTUFBTSxzQkFBc0IsdUJBQXVCLENBQUMscUJBQXFCLHlCQUFBO0FBQ3BHLGdCQUFNLGlEQUFpRCxvQkFBb0IsTUFBTTtBQUVqRixjQUFJLGdEQUFnRDtBQUNsRCxtQkFBTzs7O0FBSWpCLGdDQUF3Qjs7QUFHMUIsYUFBTzs7Ozs7QUNuRFQ7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLHdCQUFNO01BQ25CLElBQUksYUFBYSxpQkFBaUIsb0JBQW9CO0FBQ3BELFlBQUk7QUFFSixjQUFNLFVBQVUsS0FBSyxVQUFVLGFBQWEsY0FBQSxHQUFpQjtBQUU3RCxrQkFBVTtBQUVWLGVBQU87O01BR1QsUUFBUSxtQkFBbUIsdUJBQXVCLG9CQUFvQjtBQUNwRSxZQUFJLFlBQVk7QUFFaEIsY0FBTSwwQkFBMEIsa0JBQWtCLFFBQzVDLDJCQUEyQixtQkFBbUI7QUFFcEQsWUFBSSw0QkFBNEIsMEJBQTBCO0FBQ3hELGdCQUFNLDBCQUEwQixJQUFBLE1BQUEsMEJBQXlCLHFCQUNuRCx5QkFBeUIsSUFBQSxNQUFBLDBCQUF5QixvQkFDbEQsd0JBQXdCLElBQUEsTUFBQSwwQkFBeUIsd0JBQXdCO0FBRS9FLGNBQUksdUJBQXVCO0FBQ3pCLGtCQUFNLFVBQVUsa0JBQWtCLE1BQU0sQ0FBQyxrQkFBa0IsVUFBQTtBQUN6RCxvQkFBTSxvQkFBb0IsbUJBQW1CLFFBQ3ZDLGVBQWUsbUJBQ2YsY0FBYyxrQkFDZCxXQUFVLEtBQUssVUFBVSxhQUFhLGNBQUEsR0FBaUI7QUFFN0Qsa0JBQUksVUFBUztBQUNYLHVCQUFPOzs7QUFJWCxnQkFBSSxTQUFTO0FBQ1gsMEJBQVk7Ozs7QUFLbEIsZUFBTzs7TUFHVCxVQUFVLGFBQWEsaUJBQWlCLG9CQUFvQjtBQUMxRCxZQUFJLFVBQVU7QUFFZCxjQUFNLDBCQUEwQixZQUFZLGtCQUN0QywyQkFBMkIsYUFBYSxrQkFDeEMsNkJBQTZCLFlBQVkscUJBQ3pDLDhCQUE4QixhQUFhO0FBRWpELFlBQUksT0FBTzttQkFFQSwyQkFBMkIsMEJBQTBCO0FBQzlELGdCQUFNLHNCQUFzQixhQUN0Qix1QkFBdUI7QUFFN0Isb0JBQVUsS0FBSyxrQkFBa0IscUJBQXFCLHNCQUFBLEdBQXlCO21CQUN0RSw4QkFBOEIsNkJBQTZCO0FBQ3BFLGdCQUFNLHlCQUF5QixhQUN6QiwwQkFBMEI7QUFFaEMsb0JBQVUsS0FBSyxxQkFBcUIsd0JBQXdCLHlCQUFBLEdBQTRCOztBQUcxRixlQUFPOztNQUdULGtCQUFrQixxQkFBcUIseUJBQXlCLG9CQUFvQjtBQUNsRixZQUFJO0FBRUosa0JBQVU7QUFFVixlQUFPOztNQUdULHFCQUFxQix3QkFBd0IsNEJBQTRCLG9CQUFvQjtBQUMzRixZQUFJLFVBQVU7QUFFZCxZQUFJLENBQUUsUUFBUyxLQUFLO0FBRXBCLGVBQU87YUFDRjtVQUNIO1lBQ0Usa0JBQWtCLE1BQUE7WUFDbEIsbUJBQW1CLE1BQUE7WUFDbkIsS0FBSyxDQUFDLGFBQWEsaUJBQWlCLHdCQUFBO0FBQ2xDLGtCQUFJLFdBQVU7QUFFZCxvQkFBTSxpQ0FBaUMsdUJBQXVCLGVBQ3hELGtDQUFrQyx3QkFBd0I7QUFFaEUsa0JBQUksbUNBQW1DLGlDQUFpQztBQUN0RSxzQkFBTSxtQ0FBbUMsdUJBQXVCLGlCQUMxRCxvQ0FBb0Msd0JBQXdCLGlCQUM1RCxvQkFBb0Isa0NBQ3BCLHFCQUFxQixtQ0FDckIsWUFBWSxLQUFLLFFBQVEsbUJBQW1CLG9CQUFBLEdBQXVCO0FBRXpFLG9CQUFJLFdBQVc7QUFDYiw2QkFBVTs7O0FBSWQscUJBQU87Ozs7QUFLYixhQUFLLEtBQUssQ0FBQyxRQUFBO0FBQ1QsZ0JBQU0sQ0FBRSxrQkFBa0IsbUJBQW1CLE9BQVE7QUFFckQsZ0JBQU0sY0FBYyxpQkFBaUIseUJBQy9CLGVBQWUsa0JBQWtCO0FBRXZDLGNBQUssZ0JBQWdCLFFBQVUsaUJBQWlCLE1BQU87QUFDckQsa0JBQU0sVUFBVyxJQUFJLGFBQWEsY0FBQSxHQUFpQjtBQUVuRCxzQkFBVTtBQUVWLG1CQUFPOzs7QUFJWCxlQUFPOzs7Ozs7QUNoSVg7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7QUFBTiwwQkFBTTtZQUNiLElBQUksU0FBUyxvQkFBb0I7QUFDckMsWUFBSTtBQUVKLGNBQU0sVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFBLEdBQVM7QUFFOUMsa0JBQVU7QUFFVixlQUFPOztZQUdILFFBQVEsZUFBZSxvQkFBb0I7QUFDL0MsWUFBSSxZQUFZO0FBRWhCLGNBQU0sVUFBVSxNQUFNLElBQUEsY0FBQSxZQUFXLFlBQVksT0FBTyxjQUFBO0FBQ2xELGdCQUFNLE9BQU8sV0FDUCxXQUFVLE1BQU0sS0FBSyxVQUFVLE1BQUEsR0FBUztBQUU5QyxjQUFJLFVBQVM7QUFDWCxtQkFBTzs7O0FBSVgsWUFBSSxTQUFTO0FBQ1gsc0JBQVk7O0FBR2QsZUFBTzs7WUFHSCxVQUFVLFNBQVMsb0JBQW9CO0FBQzNDLFlBQUk7QUFFSixjQUFNLG1CQUFtQixLQUFLO0FBRTlCLFlBQUksa0JBQWtCO0FBQ3BCLGdCQUFNLGVBQWU7QUFFckIsb0JBQVUsTUFBTSxLQUFLLGtCQUFrQixjQUFBLEdBQWlCO2VBQ25EO0FBQ0wsZ0JBQU0sa0JBQWtCO0FBRXhCLG9CQUFVLE1BQU0sS0FBSyxxQkFBcUIsaUJBQUEsR0FBb0I7O0FBR2hFLGVBQU87O1lBR0gsa0JBQWtCLGlCQUFpQixvQkFBb0I7QUFDM0QsY0FBTSxVQUFVO0FBRWhCLGVBQU87O1lBR0gscUJBQXFCLG9CQUFvQixvQkFBb0I7QUFDakUsWUFBSSxVQUFVO0FBRWQsWUFBSSxDQUFFLFFBQVMsS0FBSztBQUVwQixlQUFPO2FBQ0Y7VUFDSDtZQUNFLFdBQVcsTUFBQTtZQUNYLEtBQUssT0FBTyxTQUFTLHdCQUFBO0FBQ25CLGtCQUFJLFdBQVU7QUFFZCxvQkFBTSxhQUFhLGdCQUFnQixpQkFDN0IsWUFBWSxNQUFNLEtBQUssUUFBUSxZQUFBLEdBQWU7QUFFcEQsa0JBQUksV0FBVztBQUNiLDJCQUFVOztBQUdaLHFCQUFPOzs7O0FBS2IsY0FBTSxJQUFBLGNBQUEsV0FBVSxNQUFNLE9BQU8sUUFBQTtBQUMzQixnQkFBTSxDQUFFLFdBQVcsT0FBUTtBQUUzQixnQkFBTSxPQUFPLFVBQVU7QUFFdkIsY0FBSSxTQUFTLE1BQU07QUFDakIsa0JBQU0sVUFBVSxNQUFNLElBQUksTUFBQSxHQUFTO0FBRW5DLHNCQUFVO0FBRVYsbUJBQU87OztBQUlYLGVBQU87Ozs7OztBQ2pHWDs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4sMkJBQU07TUFDbkIsSUFBSSxTQUFTLG9CQUFvQjtBQUMvQixZQUFJO0FBRUosY0FBTSxVQUFVLEtBQUssVUFBVSxNQUFBLEdBQVM7QUFFeEMsa0JBQVU7QUFFVixlQUFPOztNQUdULFFBQVEsZUFBZSxvQkFBb0I7QUFDekMsWUFBSSxZQUFZO0FBRWhCLGNBQU0sVUFBVSxXQUFXLE1BQU0sQ0FBQyxjQUFBO0FBQ2hDLGdCQUFNLE9BQU8sV0FDUCxXQUFVLEtBQUssVUFBVSxNQUFBLEdBQVM7QUFFeEMsY0FBSSxVQUFTO0FBQ1gsbUJBQU87OztBQUlYLFlBQUksU0FBUztBQUNYLHNCQUFZOztBQUdkLGVBQU87O01BR1QsVUFBVSxTQUFTLG9CQUFvQjtBQUNyQyxZQUFJO0FBRUosY0FBTSxtQkFBbUIsS0FBSztBQUU5QixZQUFJLGtCQUFrQjtBQUNwQixnQkFBTSxlQUFlO0FBRXJCLG9CQUFVLEtBQUssa0JBQWtCLGNBQUEsR0FBaUI7ZUFDN0M7QUFDTCxnQkFBTSxrQkFBa0I7QUFFeEIsb0JBQVUsS0FBSyxxQkFBcUIsaUJBQUEsR0FBb0I7O0FBRzFELGVBQU87O01BR1Qsa0JBQWtCLGlCQUFpQixvQkFBb0I7QUFDckQsY0FBTSxVQUFVO0FBRWhCLGVBQU87O01BR1QscUJBQXFCLG9CQUFvQixvQkFBb0I7QUFDM0QsWUFBSSxVQUFVO0FBRWQsWUFBSSxDQUFFLFFBQVMsS0FBSztBQUVwQixlQUFPO2FBQ0Y7VUFDSDtZQUNFLFdBQVcsTUFBQTtZQUNYLEtBQUssQ0FBQyxTQUFTLHdCQUFBO0FBQ2Isa0JBQUksV0FBVTtBQUVkLG9CQUFNLGFBQWEsZ0JBQWdCLGlCQUM3QixZQUFZLEtBQUssUUFBUSxZQUFBLEdBQWU7QUFFOUMsa0JBQUksV0FBVztBQUNiLDJCQUFVOztBQUdaLHFCQUFPOzs7O0FBS2IsYUFBSyxLQUFLLENBQUMsUUFBQTtBQUNULGdCQUFNLENBQUUsV0FBVyxPQUFRO0FBRTNCLGdCQUFNLE9BQU8sVUFBVTtBQUV2QixjQUFJLFNBQVMsTUFBTTtBQUNqQixrQkFBTSxVQUFVLElBQUksTUFBQSxHQUFTO0FBRTdCLHNCQUFVO0FBRVYsbUJBQU87OztBQUlYLGVBQU87Ozs7OztBQ2hHWDs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4sNEJBQU07TUFDbkIsSUFBSSxTQUFTLG9CQUFvQjtBQUMvQixZQUFJO0FBRUosY0FBTSxVQUFVLEtBQUssVUFBVSxNQUFBLEdBQVM7QUFFeEMsa0JBQVU7QUFFVixlQUFPOztNQUdULFFBQVEsT0FBTyxlQUFlLG9CQUFvQjtBQUNoRCxZQUFJLG1CQUFtQjtBQUV2QixjQUFNLGlCQUFpQixtQkFBbUIsT0FDcEMsbUJBQW1CLFdBQVc7QUFFcEMsWUFBSSxVQUFVLGtCQUFrQjtBQUM5Qiw2QkFBbUI7ZUFDZDtBQUNMLGdCQUFNLFlBQVksV0FBVyxRQUN2QixPQUFPLFdBQ1AsVUFBVSxLQUFLLFVBQVUsTUFBQSxHQUFTLG9CQUFvQixNQUFBO0FBQ3BELCtCQUFtQixLQUFLO0FBRXhCLGtCQUFNLGFBQWEsUUFBUSxHQUNyQixvQkFBbUIsS0FBSyxRQUFRLFlBQVksWUFBQSxHQUFlO0FBRWpFLG1CQUFPOztBQUdmLGNBQUksU0FBUztBQUNYLCtCQUFtQjs7O0FBSXZCLGVBQU87O01BR1QsVUFBVSxTQUFTLG9CQUFvQjtBQUNyQyxZQUFJO0FBRUosY0FBTSxtQkFBbUIsS0FBSztBQUU5QixZQUFJLGtCQUFrQjtBQUNwQixnQkFBTSxlQUFlO0FBRXJCLG9CQUFVLEtBQUssa0JBQWtCLGNBQUEsR0FBaUI7ZUFDN0M7QUFDTCxnQkFBTSxrQkFBa0I7QUFFeEIsb0JBQVUsS0FBSyxxQkFBcUIsaUJBQUEsR0FBb0I7O0FBRzFELGVBQU87O01BR1Qsa0JBQWtCLGlCQUFpQixvQkFBb0I7QUFDckQsWUFBSSxVQUFVO0FBRWQsY0FBTSxpQkFBaUIsbUJBQW1CLE9BQ3BDLG1CQUFtQjtBQUV6QixZQUFJLGtCQUFrQjtBQUNwQixvQkFBVTs7QUFHWiwyQkFBbUIsS0FBSztBQUV4QixlQUFPOztNQUdULHFCQUFxQixvQkFBb0Isb0JBQW9CO0FBQzNELFlBQUksVUFBVTtBQUVkLFlBQUksQ0FBRSxRQUFTLEtBQUs7QUFFcEIsZUFBTzthQUNGO1VBQ0g7WUFDRSxXQUFXLE1BQUE7WUFDWCxLQUFLLENBQUMsU0FBUyx3QkFBQTtBQUNiLGtCQUFJLFdBQVU7QUFFZCxvQkFBTSxRQUFRLEdBQ1IsYUFBYSxnQkFBZ0IsaUJBQzdCLFlBQVksS0FBSyxRQUFRLE9BQU8sWUFBQSxHQUFlO0FBRXJELGtCQUFJLFdBQVc7QUFDYiwyQkFBVTs7QUFHWixxQkFBTzs7OztBQUtiLGFBQUssS0FBSyxDQUFDLFFBQUE7QUFDVCxnQkFBTSxDQUFFLFdBQVcsT0FBUTtBQUUzQixnQkFBTSxPQUFPLFVBQVU7QUFFdkIsY0FBSSxTQUFTLE1BQU07QUFDakIsa0JBQU0sVUFBVSxJQUFJLE1BQUEsR0FBUztBQUU3QixzQkFBVTtBQUVWLG1CQUFPOzs7QUFJWCxlQUFPOzs7Ozs7QUNuSFg7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLGdDQUFNO01BQ25CLElBQUksVUFBVSxjQUFjLG9CQUFvQjtBQUM5QyxZQUFJO0FBRUosY0FBTSxVQUFVLEtBQUssVUFBVSxVQUFVLFdBQUEsR0FBYztBQUV2RCxrQkFBVTtBQUVWLGVBQU87O01BR1QsUUFBUSxnQkFBZ0Isb0JBQW9CLG9CQUFvQjtBQUM5RCxZQUFJLFlBQVk7QUFFaEIsY0FBTSx1QkFBdUIsZUFBZSxRQUMxQyx3QkFBd0IsZ0JBQWdCO0FBRTFDLFlBQUkseUJBQXlCLHVCQUF1QjtBQUNsRCxnQkFBTSxzQkFBc0IsSUFBQSxNQUFBLDBCQUF5QixpQkFDL0MsdUJBQXVCLElBQUEsTUFBQSwwQkFBeUIsa0JBQ2hELHdCQUF3QixJQUFBLE1BQUEsMEJBQXlCLHFCQUFxQjtBQUU1RSxjQUFJLHVCQUF1QjtBQUN6Qix3QkFBWSxlQUFlLE1BQU0sQ0FBQyxlQUFlLFVBQUE7QUFDL0Msb0JBQU0saUJBQWlCLGdCQUFnQixRQUNqQyxXQUFXLGVBQ1gsWUFBWSxnQkFDWixVQUFVLEtBQUssVUFBVSxVQUFVLFdBQUEsR0FBYztBQUV2RCxrQkFBSSxTQUFTO0FBQ1gsdUJBQU87Ozs7O0FBTWYsZUFBTzs7TUFHVCxVQUFVLFVBQVUsY0FBYyxvQkFBb0I7QUFDcEQsWUFBSSxVQUFVO0FBRWQsY0FBTSx1QkFBdUIsU0FBUyxrQkFDaEMsd0JBQXdCLFVBQVUsa0JBQ2xDLDBCQUEwQixTQUFTLHFCQUNuQywyQkFBMkIsVUFBVTtBQUUzQyxZQUFJLE9BQU87bUJBRUEsd0JBQXdCLHVCQUF1QjtBQUN4RCxnQkFBTSxtQkFBbUIsVUFDbkIsb0JBQW9CO0FBRTFCLG9CQUFVLEtBQUssa0JBQWtCLGtCQUFrQixtQkFBQSxHQUFzQjttQkFDaEUsMkJBQTJCLDBCQUEwQjtBQUM5RCxnQkFBTSxzQkFBc0IsVUFDdEIsdUJBQXVCO0FBRTdCLG9CQUFVLEtBQUsscUJBQXFCLHFCQUFxQixzQkFBQSxHQUF5Qjs7QUFHcEYsZUFBTzs7TUFHVCxrQkFBa0Isa0JBQWtCLHNCQUFzQixvQkFBb0I7QUFDNUUsWUFBSTtBQUVKLGtCQUFVO0FBRVYsZUFBTzs7TUFHVCxxQkFBcUIscUJBQXFCLHlCQUF5QixvQkFBb0I7QUFDckYsWUFBSSxVQUFVO0FBRWQsWUFBSSxDQUFFLFFBQVMsS0FBSztBQUVwQixlQUFPO2FBQ0Y7VUFDSDtZQUNFLGVBQWUsTUFBQTtZQUNmLGdCQUFnQixNQUFBO1lBQ2hCLEtBQUssQ0FBQyxVQUFVLGNBQWMsd0JBQUE7QUFDNUIsa0JBQUksV0FBVTtBQUVkLG9CQUFNLDhCQUE4QixvQkFBb0IsZUFDbEQsK0JBQStCLHFCQUFxQjtBQUUxRCxrQkFBSSxnQ0FBZ0MsOEJBQThCO0FBQ2hFLHNCQUFNLGdDQUFnQyxvQkFBb0IsaUJBQ3BELGlDQUFpQyxxQkFBcUIsaUJBQ3RELGlCQUFpQiwrQkFDakIsa0JBQWtCLGdDQUNsQixZQUFZLEtBQUssUUFBUSxnQkFBZ0IsaUJBQUEsR0FBb0I7QUFFbkUsb0JBQUksV0FBVztBQUNiLDZCQUFVOzs7QUFJZCxxQkFBTzs7OztBQUtiLGFBQUssS0FBSyxDQUFDLFFBQUE7QUFDVCxnQkFBTSxDQUFFLGVBQWUsZ0JBQWdCLE9BQVE7QUFFL0MsZ0JBQU0sV0FBVyxjQUFjLHNCQUN6QixZQUFZLGVBQWU7QUFFakMsY0FBSyxhQUFhLFFBQVUsY0FBYyxNQUFPO0FBQy9DLGtCQUFNLFVBQVUsSUFBSSxVQUFVLFdBQUEsR0FBYztBQUU1QyxzQkFBVTtBQUVWLG1CQUFPOzs7QUFJWCxlQUFPOzs7Ozs7QUM1SFg7Ozs7O21DQUlzQix3QkFBQTs7O2VBQUE7Ozs7QUFBZix3Q0FBb0MsY0FBYyxVQUFRO0FBQy9ELFlBQU0sUUFBUSxhQUFhO0FBRTNCLGFBQU8sTUFBTSxJQUFBLGNBQUEsWUFBVyxPQUFPOzs7OztBQ1BqQzs7Ozs7Ozs7Ozs7OztVQW1Dc0IsdUJBQUE7ZUFBQTs7VUFxR3RCLFVBQUE7ZUFBQTs7VUFoSWdCLDJCQUFBO2VBQUE7O1VBc0ZNLHVCQUFBO2VBQUE7Ozs7O0FBeEZ0QixRQUFNLENBQUUsUUFBUyxXQUFBO0FBRVYsc0NBQWtDLFlBQVksVUFBTztBQUMxRCxZQUFNLENBQUUsS0FBSyxxQkFBc0IsVUFDN0IsaUJBQWlCLFdBQVcsV0FDNUIsY0FBYyxnQkFDZCxpQkFBaUIsa0JBQWtCLGdCQUFnQjtBQUV6RCxVQUFJLG1CQUFtQixNQUFNO0FBQzNCLFlBQUksUUFBUSw2QkFBNkI7YUFDcEM7QUFDTCxjQUFNLDRCQUE0QixlQUFlO0FBRWpELFlBQUksQ0FBQywyQkFBMkI7QUFDOUIsOENBQW9DLFlBQVksZ0JBQWdCO0FBRWhFLGdCQUFNLGtCQUFrQix3QkFBd0IsZ0JBQWdCO0FBRWhFLGNBQUksS0FBSyxxQkFBcUI7QUFFOUIsZ0JBQU0sQ0FBRSwyQkFBNEI7QUFFcEMseUJBQWUsV0FBVyxpQkFBaUI7QUFFM0MsY0FBSSxNQUFNLHVCQUF1Qjs7OztBQUtoQyx3Q0FBb0MsWUFBWSxnQkFBZ0IsVUFBTztBQUM1RSxVQUFJLHdCQUF3QjtBQUU1QixZQUFNLENBQUUsS0FBSyxxQkFBc0IsVUFDN0IsaUJBQWlCLFdBQVcsV0FDNUIsY0FBYyxnQkFDZCxpQkFBaUIsa0JBQWtCLGdCQUFnQjtBQUV6RCxVQUFJLG1CQUFtQixNQUFNO0FBQzNCLGNBQU0sMkJBQTJCLDhCQUE4QixnQkFBZ0IsWUFBWSxnQkFBZ0I7QUFFM0csWUFBSSwwQkFBMEI7QUFDNUIsY0FBSSxNQUFNLFFBQVE7QUFFbEIsa0NBQXdCOzthQUVyQjtBQUNMLGNBQU0sbUJBQW1CLFdBQVcsWUFDOUIsdUJBQXVCLGVBQWU7QUFFNUMsWUFBSSx5QkFBeUIsR0FBRztBQUM5QixjQUFJLEtBQUssaUJBQWlCO2VBQ3JCO0FBQ0wsZ0JBQU0sb0JBQW9CLEtBQUssaUJBQ3pCLGdCQUFnQjtBQUV0QixjQUFJLEtBQUssaUJBQWlCLG1DQUFtQywrQkFBK0I7O0FBRzlGLGNBQU0sQ0FBRSxnQ0FBaUMsVUFDbkMsa0JBQWlCLE1BQU0sNkJBQTZCLFlBQVk7QUFFdEUsWUFBSSxvQkFBbUIsTUFBTTtBQUMzQixnQkFBTSwyQkFBMkIsOEJBQThCLGlCQUFnQixZQUFZLGdCQUFnQjtBQUUzRyxjQUFJLDBCQUEwQjtBQUM1Qiw4QkFBa0IsZUFBZTtBQUVqQyxrQkFBTSxtQ0FBbUMsTUFBTSxnQ0FBZ0MsWUFBWSxpQkFBZ0IsZ0JBQWdCO0FBRTNILGdCQUFJLGtDQUFrQztBQUNwQyxzQ0FBd0I7OztlQUd2QjtBQUNMLGdCQUFNLGtCQUFpQixXQUFXLFdBQzVCLGVBQWM7QUFFcEIsY0FBSSxRQUFRLFFBQVE7O0FBR3RCLGdDQUNFLElBQUksTUFBTSxtQkFBbUIsMkJBQzNCLElBQUksUUFBUSw0QkFBNEI7O0FBRzlDLGFBQU87O0FBR0Ysd0NBQW9DLGFBQWEsZUFBZSxtQkFBbUIsbUJBQWlCO0FBQ3pHLFVBQUkseUJBQXlCO0FBRTdCLFlBQU0saUJBQWlCLGtCQUFrQjtBQUV6QyxVQUFJLG1CQUFtQixNQUFNO0FBQzNCLGNBQU0sV0FBVyxlQUFlO0FBRWhDLFlBQUksVUFBVTtBQUNaLG1DQUF5QjtlQUNwQjtBQUNMLGNBQUksbUJBQW1CO0FBQ3JCLDJCQUFlLFFBQVEsUUFBUSx3REFBd0Q7aUJBQ2xGO0FBQ0wsa0JBQU0saUJBQWdCLGFBQ2hCLHFCQUFvQixVQUNwQixrQ0FBa0MsTUFBTSxnQ0FBZ0MsZ0JBQWdCLGdCQUFlLG9CQUFtQjtBQUVoSSxnQkFBSSxpQ0FBaUM7QUFDbkMsb0JBQU0seUJBQXlCLGVBQWU7QUFFOUMsa0JBQUksd0JBQXdCO0FBQzFCLHlDQUF5QjtxQkFDcEI7QUFDTCwrQkFBZSxLQUFLLGtCQUFrQjtBQUV0QyxzQkFBTSxXQUFXLE1BQU0sZUFBZTtBQUV0QyxvQkFBSSxVQUFVO0FBQ1osaUNBQWUsS0FBSyxvQkFBb0I7QUFFeEMsMkNBQXlCOzs7Ozs7O0FBUXJDLGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTs7QUFHRixtREFBK0MsWUFBWSxnQkFBZ0IsZ0JBQWdCLFVBQU87QUFDaEcsVUFBSTtBQUVKLFlBQU0saUJBQWlCLFdBQVcsV0FDNUIsZUFBZSxlQUFlO0FBRXBDLHVCQUFpQjtXQUFLO1FBQWdCOztBQUV0Qyx5Q0FBbUMsTUFBTSxJQUFBLFlBQUEsc0JBQXFCLGNBQWMsT0FBTyxnQkFBQTtBQUNqRixjQUFNLHlCQUF5Qiw0QkFBNEIsYUFBWSxnQkFBZ0I7QUFFdkYsWUFBSSxDQUFDLHdCQUF3QjtBQUMzQixnQkFBTSx3QkFBd0IsTUFBTSxxQkFBcUIsYUFBWSxnQkFBZ0I7QUFFckYsY0FBSSx1QkFBdUI7QUFDekIsbUJBQU87Ozs7QUFLYixhQUFPOztBQUdULG1EQUErQyxnQkFBZ0IsZUFBZSxtQkFBbUIsbUJBQWlCO0FBQ2hILFlBQU0sZUFBZSxlQUFlLG1CQUM5QixrQ0FBa0MsTUFBTSxJQUFBLFlBQUEsc0JBQXFCLGNBQWMsT0FBTyxlQUFBO0FBQ2hGLGNBQU0sT0FBTyxXQUFXLFdBQ2xCLGNBQWMsTUFDZCx5QkFBeUIsTUFBTSxxQkFBcUIsYUFBYSxlQUFlLG1CQUFtQjtBQUV6RyxZQUFJLHdCQUF3QjtBQUMxQixpQkFBTzs7O0FBSWpCLGFBQU87O0FBR1QscUNBQWlDLGdCQUFnQixtQkFBaUI7QUFDaEUsWUFBTSxrQkFBa0IsSUFDbEIsMEJBQTBCLGdCQUMxQiwyQkFBMkI7UUFDekI7O0FBR1IsVUFBSSxpQ0FBaUMseUJBQXlCO0FBRTlELGFBQU8saUNBQWlDLEdBQUc7QUFDekMsY0FBTSwyQkFBMEIseUJBQXlCLFNBQ25ELGtCQUFpQjtBQUV2Qix3QkFBZ0IsS0FBSztBQUVyQixjQUFNLGVBQWUsZ0JBQWU7QUFFcEMscUJBQWEsa0JBQWtCLENBQUMsZUFBQTtBQUM5QixnQkFBTSxpQkFBaUIsV0FBVyxXQUM1QixjQUFjLGdCQUNkLGtCQUFpQixrQkFBa0IsY0FDbkMsd0NBQXdDLGdCQUFnQixTQUFTLGtCQUNqRSxpREFBaUQseUJBQXlCLFNBQVM7QUFFekYsY0FBSSxDQUFDLHlDQUF5QyxDQUFDLGdEQUFnRDtBQUM3RixrQkFBTSwyQkFBMEI7QUFFaEMscUNBQXlCLEtBQUs7OztBQUlsQyx5Q0FBaUMseUJBQXlCOztBQUc1RCxhQUFPOztBQUdULHlDQUFxQyxZQUFZLGdCQUFnQixVQUFPO0FBQ3RFLFlBQU0saUJBQWlCLFdBQVcsV0FDNUIsdUNBQXVDLGVBQWUsU0FBUyxpQkFDL0QseUJBQXlCO0FBRS9CLFVBQUksd0JBQXdCO0FBQzFCLGNBQU0sQ0FBRSxPQUFRLFVBQ1YscUJBQXFCLE1BQU0saUJBQzNCLGtCQUFrQjthQUNiO1VBQ0g7V0FFRix3QkFBd0IsZ0JBQWdCLEtBQUs7QUFFbkQsWUFBSSxRQUFRLGtDQUFrQzs7QUFHaEQsYUFBTzs7QUFHVCwyQ0FBdUMsZ0JBQWdCLFlBQVksZ0JBQWdCLFVBQU87QUFDeEYsVUFBSSwyQkFBMkI7QUFFL0IsWUFBTSxtQkFBbUIsV0FBVztBQUVwQyxVQUFJLHFCQUFxQixNQUFNO0FBQzdCLGNBQU0sK0JBQStCLGVBQWUsc0JBQXNCO0FBRTFFLFlBQUksQ0FBQyw4QkFBOEI7QUFDakMsZ0JBQU0sQ0FBRSxPQUFRLFVBQ1YsVUFBVSxlQUFlLGNBQ3pCLG9CQUFvQixLQUFLLGlCQUN6QixnQkFBZ0IsbUJBQ2hCLGdCQUFnQixRQUFRLFlBQ3hCLG1CQUFtQixXQUFXO0FBRXBDLGNBQUksUUFBUSxRQUFRLDBDQUEwQyw0REFBNEQ7QUFFMUgscUNBQTJCOzs7QUFJL0IsYUFBTzs7QUFHVCxpREFBNkMsWUFBWSxnQkFBZ0IsVUFBTztBQUM5RSxZQUFNLGVBQWUsZUFBZTtBQUVwQyxtQkFBYSxrQkFBa0IsQ0FBQyxnQkFBQTtBQUM5QixpQ0FBeUIsYUFBWTs7Ozs7O0FDMVF6Qzs7Ozs7Ozs7Ozs7OztVQUdhLGlCQUFBO2VBQUE7O1VBREEsWUFBQTtlQUFBOzs7QUFBTixRQUFNLFlBQVk7QUFDbEIsUUFBTSxpQkFBaUI7Ozs7QUNIOUI7Ozs7Ozs7Ozs7Ozs7VUFHYSxlQUFBO2VBQUE7O1VBREEsZUFBQTtlQUFBOztVQUVBLG9CQUFBO2VBQUE7O1VBRUEsdUJBQUE7ZUFBQTs7VUFEQSxvQkFBQTtlQUFBOzs7QUFITixRQUFNLGVBQWU7QUFDckIsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0sdUJBQXVCOzs7O0FDTnBDOzs7Ozs7Ozs7Ozs7O1VBZWdCLGlDQUFBO2VBQUE7O1VBRWhCLFVBQUE7ZUFBQTs7VUFiZ0Isa0JBQUE7ZUFBQTs7VUFTQSxtQkFBQTtlQUFBOzs7O0FBVFQsNkJBQXlCLFNBQU87QUFDckMsWUFBTSxtQkFBbUIsUUFDRyxRQUFRLE1BQU0sV0FBQSxtQkFDZCxRQUFRLE1BQU0sV0FBQSxtQkFDZCxRQUFRLE1BQU0sV0FBQTtBQUUxQyxhQUFPOztBQUdGLDhCQUEwQixTQUFPO0FBQUksYUFBTyxRQUFRLFFBQVEsWUFBWSxXQUFBOztBQUV4RSw0Q0FBd0MsU0FBTztBQUFJLGFBQU8sUUFBUSxRQUFRLE9BQU8sV0FBQTs7UUFFeEYsV0FBZTtNQUNiO01BQ0E7TUFDQTs7Ozs7QUNwQkY7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7QUFBTixzQkFBTTtNQUNuQixZQUFZLE1BQU0sU0FBUyxVQUFVO0FBQ25DLGFBQUssT0FBTztBQUNaLGFBQUssVUFBVTtBQUNmLGFBQUssV0FBVzs7TUFHbEIsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsU0FBUztBQUNQLGNBQU0sT0FBTztBQUViLGVBQU87O01BR1QsY0FBYztBQUNaLGNBQU0sWUFBWTtBQUVsQixlQUFPOztNQUdULFFBQVEsTUFBTTtBQUNaLGFBQUssT0FBTzs7TUFHZCxXQUFXLFNBQVM7QUFDbEIsYUFBSyxVQUFVOztNQUdqQixZQUFZLFVBQVU7QUFDcEIsYUFBSyxXQUFXOztNQUdsQixjQUFjLFVBQVU7QUFDdEIsY0FBTSxrQkFBbUIsS0FBSyxTQUFTO0FBRXZDLGVBQU87O01BR1QsU0FBUztBQUNQLGNBQU0sQ0FBRSxRQUFTLE9BQ1gsT0FBTyxLQUFLLE1BQ1osVUFBVSxLQUFLLFNBQ2YsV0FBVyxLQUFLLFVBQ2hCLE9BQU87VUFDTDtVQUNBO1VBQ0E7VUFDQTs7QUFHUixlQUFPOzthQUtGLFNBQVMsTUFBTTtBQUNwQixZQUFJLE9BQU87QUFFWCxZQUFJLFNBQVMsTUFBTTtBQUNqQixnQkFBTSxDQUFFLFFBQVM7QUFFakIsY0FBSSxTQUFTLE9BQUEsV0FBVztBQUN0QixnQkFBSSxDQUFFLFdBQVk7QUFFbEIsa0JBQU0sQ0FBRSxNQUFNLFlBQWE7QUFFM0Isc0JBQVUsSUFBQSxTQUFBLGdDQUErQjtBQUV6QyxtQkFBTyxJQUFJLE1BQUssTUFBTSxTQUFTOzs7QUFJbkMsZUFBTzs7YUFHRixhQUFhLFdBQVU7QUFDNUIsY0FBTSxXQUFXLFVBQVMsZUFDcEIsV0FBVyxVQUFTLGNBQ3BCLE9BQU87QUFFYixZQUFJLFVBQVUsVUFBUztBQUV2QixrQkFBVSxJQUFBLFNBQUEsZ0NBQStCO0FBRXpDLGNBQU0sT0FBTyxJQUFJLE1BQUssTUFBTSxTQUFTO0FBRXJDLGVBQU87O2FBR0YsMkJBQTJCLE1BQU0sU0FBUyxVQUFVO0FBQ3pELGtCQUFVLElBQUEsU0FBQSxnQ0FBK0I7QUFFekMsY0FBTSxPQUFPLElBQUksTUFBSyxNQUFNLFNBQVM7QUFFckMsZUFBTzs7O0FBekdJO0FBZ0VOLGtCQWhFTSxNQWdFTixRQUFPLE9BQUE7Ozs7QUNyRWhCOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLHNCQUFNO01BQ25CLFlBQVksT0FBTztBQUNqQixhQUFLLFFBQVE7O01BR2YsV0FBVztBQUNULGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQ2IsY0FBTSxZQUFZLEtBQUssUUFBUSxDQUFDLFNBQUE7QUFDOUIsZ0JBQU0sV0FBVyxLQUFLO0FBRXRCLGlCQUFPOztBQUdULGVBQU87O01BR1QsUUFBUSxNQUFNO0FBQUUsYUFBSyxNQUFNLEtBQUs7O01BRWhDLFFBQVEsVUFBVTtBQUFFLGVBQU8sS0FBSyxNQUFNLElBQUk7O01BRTFDLFNBQVMsVUFBVTtBQUFFLGVBQU8sS0FBSyxNQUFNLEtBQUs7O01BRTVDLFdBQVcsVUFBVSxjQUFjO0FBQUUsZUFBTyxLQUFLLE1BQU0sT0FBTyxVQUFVOztNQUV4RSxZQUFZLFVBQVU7QUFBRSxhQUFLLE1BQU0sUUFBUTs7TUFFM0MsU0FBUyxVQUFVO0FBQUUsZUFBTyxLQUFLLE1BQU0sS0FBSyxhQUFhOztNQUV6RCxTQUFTO0FBQ1AsY0FBTSxZQUFZLEtBQUssTUFBTSxJQUFJLENBQUMsU0FBQTtBQUMxQixnQkFBTSxXQUFZLFNBQVMsT0FDUCxLQUFLLFdBQ0g7QUFFdEIsaUJBQU87WUFFVCxPQUFPO0FBRWIsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsY0FBTSxZQUFZLE1BQ1osUUFBUSxJQUNSLFFBQVEsSUFBSSxNQUFNO0FBRXhCLGtCQUFVLFFBQVEsQ0FBQyxhQUFBO0FBQ2pCLGdCQUFNLFFBQU8sVUFDUCxPQUFPLE1BQUEsUUFBSyxTQUFTO0FBRTNCLGdCQUFNLFFBQVE7O0FBR2hCLGVBQU87O2FBR0YsY0FBYztBQUNuQixjQUFNLFFBQVEsSUFDUixRQUFRLElBQUksTUFBTTtBQUV4QixlQUFPOzs7Ozs7QUNuRVg7Ozs7Ozs7Ozs7Ozs7VUFFYSwwQkFBQTtlQUFBOztVQUNBLDBCQUFBO2VBQUE7O1VBQ0EsMEJBQUE7ZUFBQTs7O0FBRk4sUUFBTSwwQkFBMEI7QUFDaEMsUUFBTSwwQkFBMEI7QUFDaEMsUUFBTSwwQkFBMEI7Ozs7QUNKdkM7Ozs7Ozs7Ozs7Ozs7VUFRZ0Isd0JBQUE7ZUFBQTs7VUF3QkEsd0JBQUE7ZUFBQTs7VUFoQkEsd0JBQUE7ZUFBQTs7VUE2QkEsd0JBQUE7ZUFBQTs7VUFyQkEsd0JBQUE7ZUFBQTs7VUFrQ0Esd0JBQUE7ZUFBQTs7Ozs7QUFwRGhCLFFBQU0sQ0FBRSxVQUFXLFdBQUE7QUFFWixtQ0FBK0IsUUFBTTtBQUMxQyxZQUFNLGNBQWUsV0FBVyxPQUNWLEtBQUssTUFBTSxTQUFTLFlBQUEsMkJBQ2xCO0FBRXhCLGFBQU87O0FBR0YsbUNBQStCLFFBQU07QUFDMUMsWUFBTSxjQUFlLFdBQVcsT0FDVixLQUFLLE1BQU8sU0FBUyxZQUFBLDBCQUEyQixZQUFBLDJCQUM5QztBQUV4QixhQUFPOztBQUdGLG1DQUErQixRQUFNO0FBQzFDLFlBQU0sY0FBZSxXQUFXLE9BQ1YsS0FBSyxNQUFPLFNBQVMsWUFBQSwwQkFBMkIsWUFBQSwyQkFDOUM7QUFFeEIsYUFBTzs7QUFHRixtQ0FBK0IsUUFBTTtBQUMxQyxVQUFJLGNBQWM7QUFFbEIsVUFBSSxRQUFRO0FBQ1YsY0FBTSxVQUFVLE9BQU8sTUFBTSxXQUN2QixjQUFjLE9BQU87QUFFM0Isc0JBQWMsT0FBTzs7QUFHdkIsYUFBTzs7QUFHRixtQ0FBK0IsUUFBTTtBQUMxQyxVQUFJLGNBQWM7QUFFbEIsVUFBSSxRQUFRO0FBQ1YsY0FBTSxVQUFVLE9BQU8sTUFBTSxnQkFDdkIsY0FBYyxPQUFPO0FBRTNCLHNCQUFjLE9BQU87O0FBR3ZCLGFBQU87O0FBR0YsbUNBQStCLFFBQU07QUFDMUMsVUFBSSxjQUFjO0FBRWxCLFVBQUksUUFBUTtBQUNWLGNBQU0sVUFBVSxPQUFPLE1BQU0scUJBQ3ZCLGNBQWMsT0FBTztBQUUzQixzQkFBYyxPQUFPOztBQUd2QixhQUFPOzs7OztBQ3BFVDs7Ozs7bUNBVUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLHdCQUFNO01BQ25CLFlBQVksYUFBYSxhQUFhLGFBQWE7QUFDakQsYUFBSyxjQUFjO0FBQ25CLGFBQUssY0FBYztBQUNuQixhQUFLLGNBQWM7O01BR3JCLGlCQUFpQjtBQUNmLGVBQU8sS0FBSzs7TUFHZCxpQkFBaUI7QUFDZixlQUFPLEtBQUs7O01BR2QsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLOztNQUdkLGtCQUFrQjtBQUNoQixhQUFLLGVBQWU7O01BR3RCLGtCQUFrQjtBQUNoQixhQUFLLGVBQWU7O01BR3RCLGtCQUFrQjtBQUNoQixhQUFLLGVBQWU7O01BR3RCLG1CQUFtQjtBQUNqQixhQUFLLGNBQWM7O01BR3JCLG1CQUFtQjtBQUNqQixhQUFLLGNBQWM7O01BR3JCLG1CQUFtQjtBQUNqQixhQUFLLGNBQWM7O01BR3JCLHNCQUFzQixrQkFBa0I7QUFDdEMsWUFBSSwwQkFBMEI7QUFFOUIsWUFBSSxxQkFBcUIsTUFBTTtBQUM3QixvQ0FBMEI7ZUFDckI7QUFDTCxnQkFBTSxjQUFjLGlCQUFpQjtBQUVyQyxjQUFJLEtBQUssZ0JBQWdCLGFBQWE7QUFDcEMsa0JBQU0sY0FBYyxpQkFBaUI7QUFFckMsZ0JBQUksS0FBSyxlQUFlLGFBQWE7QUFDbkMsd0NBQTBCOzs7O0FBS2hDLGVBQU87O01BR1QsV0FBVztBQUNULGNBQU0sU0FBUyxHQUFHLEtBQUssZUFBZSxLQUFLLGVBQWUsS0FBSztBQUUvRCxlQUFPOztNQUdULGtCQUFrQjtBQUNoQixjQUFNLGdCQUFnQixLQUFLLGNBQWMsWUFBQSwwQkFBMEIsS0FBSyxjQUFjLFlBQUEsMEJBQTBCLEtBQUssY0FBYyxZQUFBO0FBRW5JLGVBQU87O2FBR0YsV0FBVyxRQUFRO0FBQ3hCLGNBQU0sY0FBYyxJQUFBLFNBQUEsdUJBQXNCLFNBQ3BDLGNBQWMsSUFBQSxTQUFBLHVCQUFzQixTQUNwQyxjQUFjLElBQUEsU0FBQSx1QkFBc0IsU0FDcEMsVUFBVSxJQUFJLFFBQVEsYUFBYSxhQUFhO0FBRXRELGVBQU87O2FBR0YsY0FBYztBQUNuQixjQUFNLGNBQWMsR0FDZCxjQUFjLEdBQ2QsY0FBYyxHQUNkLFVBQVUsSUFBSSxRQUFRLGFBQWEsYUFBYTtBQUV0RCxlQUFPOzthQUdGLFlBQVksU0FBUztBQUMxQixjQUFNLGNBQWMsUUFBUSxrQkFDdEIsY0FBYyxRQUFRLGtCQUN0QixjQUFjLFFBQVE7QUFFNUIsa0JBQVUsSUFBSSxRQUFRLGFBQWEsYUFBYTtBQUVoRCxlQUFPOzthQUdGLGtCQUFrQixlQUFlO0FBQ3RDLGNBQU0sU0FBUyxlQUNULGNBQWMsSUFBQSxTQUFBLHVCQUFzQixTQUNwQyxjQUFjLElBQUEsU0FBQSx1QkFBc0IsU0FDcEMsY0FBYyxJQUFBLFNBQUEsdUJBQXNCLFNBQ3BDLFVBQVUsSUFBSSxRQUFRLGFBQWEsYUFBYTtBQUV0RCxlQUFPOzs7Ozs7QUN4SFg7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLDJCQUFNO01BQ25CLFlBQVksTUFBTTtBQUNoQixhQUFLLE9BQU87O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxTQUFTO0FBQ1AsY0FBTSxPQUFPO0FBRWIsZUFBTzs7TUFHVCxjQUFjO0FBQ1osY0FBTSxZQUFZO0FBRWxCLGVBQU87O01BR1QsU0FBUztBQUNQLGNBQU0sQ0FBRSxRQUFTLFlBQ1gsT0FBTyxLQUFLLE1BQ1osT0FBTztVQUNMO1VBQ0E7O0FBR1IsZUFBTzs7YUFLRixTQUFTLE1BQU07QUFDcEIsY0FBTSxZQUFZLElBQUksV0FBVTtBQUVoQyxlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixZQUFJLFlBQVk7QUFFaEIsWUFBSSxTQUFTLE1BQU07QUFDakIsZ0JBQU0sQ0FBRSxRQUFTO0FBRWpCLGNBQUksU0FBUyxPQUFBLGdCQUFnQjtBQUMzQixrQkFBTSxDQUFFLFFBQVM7QUFFakIsd0JBQVksSUFBSSxXQUFVOzs7QUFJOUIsZUFBTzs7O0FBckRJO0FBZ0NOLGtCQWhDTSxXQWdDTixRQUFPLE9BQUE7Ozs7QUNwQ2hCOzs7OzttQ0FNZ0Isd0JBQUE7OztlQUFBOzs7O0FBRmhCLFFBQU0sQ0FBRSwwQkFBMkIsV0FBQTtBQUU1QixrQ0FBOEIsVUFBUTtBQUMzQyxZQUFNLE9BQU8sVUFDUCxpQkFBaUIsdUJBQXVCLE9BQ3hDLFdBQVc7QUFFakIsYUFBTzs7Ozs7QUNYVDs7Ozs7Ozs7Ozs7OztVQUdhLHNCQUFBO2VBQUE7O1VBREEsc0JBQUE7ZUFBQTs7VUFJQSwwQkFBQTtlQUFBOztVQUVBLDhCQUFBO2VBQUE7O1VBSEEscUJBQUE7ZUFBQTs7VUFFQSw0QkFBQTtlQUFBOztVQUdiLFVBQUE7ZUFBQTs7O0FBUk8sUUFBTSxzQkFBc0I7QUFDNUIsUUFBTSxzQkFBc0I7QUFFNUIsUUFBTSxxQkFBcUI7QUFDM0IsUUFBTSwwQkFBMEI7QUFDaEMsUUFBTSw0QkFBNEI7QUFDbEMsUUFBTSw4QkFBOEI7UUFFM0MsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7Ozs7QUNoQkY7Ozs7O21DQWtEQSxXQUFBOzs7ZUFBQTs7Ozs7O0FBNUNBLG9CQUFnQixhQUFXO0FBQ3pCLFVBQUksTUFBTSxXQUFBO0FBRVYsWUFBTSx3QkFBd0IsS0FBSyw0QkFDN0IsdUJBQXVCLHNCQUFzQixLQUFLLENBQUMsMEJBQUE7QUFDakQsY0FBTSwyQkFBMkIsc0JBQXFCLFdBQ2hELDJCQUEyQixJQUFBLE1BQUEsc0JBQXFCO0FBRXRELFlBQUksNkJBQTZCLGFBQWE7QUFDNUMsaUJBQU87O1lBRUw7QUFFWixVQUFJLHlCQUF5QixNQUFNO0FBQ2pDLGNBQU0sOEJBQThCLHFCQUFxQjtBQUV6RCxjQUFNOztBQUdSLGFBQU87O0FBR1QsMEJBQVM7QUFDUCxZQUFNLFdBQVcsV0FBQSxvQkFDWCxNQUFNLEtBQUssT0FBTyxXQUNsQixVQUFVO0FBRWhCLGFBQU87O0FBR1QsK0JBQVM7QUFDUCxZQUFNLFdBQVcsV0FBQSx5QkFDWCxNQUFNLEtBQUssT0FBTyxXQUNsQixlQUFlO0FBRXJCLGFBQU87O0FBR1QsUUFBTSxZQUFZO01BQ2hCO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDbERmOzs7Ozs7Ozs7Ozs7O1VBb0RBLFVBQUE7ZUFBQTs7VUFOZ0IscUNBQUE7ZUFBQTs7VUFJQSw0Q0FBQTtlQUFBOztVQUZBLHlDQUFBO2VBQUE7O1VBbEJBLDJCQUFBO2VBQUE7O1VBVUEsOEJBQUE7ZUFBQTs7VUFKQSw2QkFBQTtlQUFBOztVQVFBLGtDQUFBO2VBQUE7O1VBTkEsNkJBQUE7ZUFBQTs7VUFKQSw0QkFBQTtlQUFBOztVQU5BLDJCQUFBO2VBQUE7O1VBY0EsK0JBQUE7ZUFBQTs7VUFWQSw0QkFBQTtlQUFBOzs7QUE5QmhCLFFBQU0sd0JBQXdCO0FBQTlCLFFBQ00sd0JBQXdCO0FBRDlCLFFBRU0seUJBQXlCO0FBRi9CLFFBR00sMEJBQTBCO0FBSGhDLFFBSU0sMEJBQTBCO0FBSmhDLFFBS00sMkJBQTJCO0FBTGpDLFFBTU0sK0JBQStCO0FBTnJDLFFBT00sa0NBQWtDO0FBUHhDLFFBUU0sc0NBQXNDO0FBUjVDLFFBU00seUNBQXlDO0FBVC9DLFFBVU0seUJBQXlCLEdBQUcseUJBQXlCLHlCQUF5QiwwQkFBMEIsMkJBQTJCLG1DQUFtQztBQVY1SyxRQVdNLDRCQUE0QixHQUFHLDBCQUEwQiw0QkFBNEIsMkJBQTJCO0FBRXRILFFBQU0sa0NBQWtDLElBQUksT0FBTztBQUFuRCxRQUNNLGtDQUFrQyxJQUFJLE9BQU87QUFEbkQsUUFFTSxtQ0FBbUMsSUFBSSxPQUFPO0FBRnBELFFBR00sbUNBQW1DLElBQUksT0FBTztBQUhwRCxRQUlNLG9DQUFvQyxJQUFJLE9BQU87QUFKckQsUUFLTSxvQ0FBb0MsSUFBSSxPQUFPO0FBTHJELFFBTU0scUNBQXFDLElBQUksT0FBTztBQU50RCxRQU9NLHNDQUFzQyxJQUFJLE9BQU87QUFQdkQsUUFRTSx5Q0FBeUMsSUFBSSxPQUFPO0FBUjFELFFBU00sNENBQTRDLElBQUksT0FBTztBQVQ3RCxRQVVNLGdEQUFnRCxJQUFJLE9BQU87QUFWakUsUUFXTSxtREFBbUQsSUFBSSxPQUFPO0FBRTdELHNDQUFrQyxVQUFRO0FBQUksYUFBTyxnQ0FBZ0MsS0FBSzs7QUFFMUYsc0NBQWtDLFVBQVE7QUFBSSxhQUFPLGdDQUFnQyxLQUFLOztBQUUxRix1Q0FBbUMsVUFBUTtBQUFJLGFBQU8saUNBQWlDLEtBQUs7O0FBRTVGLHVDQUFtQyxVQUFRO0FBQUksYUFBTyxpQ0FBaUMsS0FBSzs7QUFFNUYsd0NBQW9DLFVBQVE7QUFBSSxhQUFPLGtDQUFrQyxLQUFLOztBQUU5Rix3Q0FBb0MsVUFBUTtBQUFJLGFBQU8sa0NBQWtDLEtBQUs7O0FBRTlGLHlDQUFxQyxVQUFRO0FBQUksYUFBTyxtQ0FBbUMsS0FBSzs7QUFFaEcsMENBQXNDLFVBQVE7QUFBSSxhQUFPLG9DQUFvQyxLQUFLOztBQUVsRyw2Q0FBeUMsVUFBUTtBQUFJLGFBQU8sdUNBQXVDLEtBQUs7O0FBRXhHLGdEQUE0QyxVQUFRO0FBQUksYUFBTywwQ0FBMEMsS0FBSzs7QUFFOUcsb0RBQWdELFVBQVE7QUFBSSxhQUFPLDhDQUE4QyxLQUFLOztBQUV0SCx1REFBbUQsVUFBUTtBQUFJLGFBQU8saURBQWlELEtBQUs7O1FBRW5JLFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDaEVGOzs7Ozs7Ozs7Ozs7O1VBK0VnQixpQ0FBQTtlQUFBOztVQWtCQSx3Q0FBQTtlQUFBOztVQXZFQSx1QkFBQTtlQUFBOztVQW9DQSx3QkFBQTtlQUFBOztVQWxCQSx3QkFBQTtlQUFBOztVQW5DQSxzQkFBQTtlQUFBOzs7O0FBQVQsaUNBQTZCLE9BQUs7QUFDdkMsVUFBSSxhQUFhO0FBRWpCLFlBQU0sU0FBUyxDQUFDLFNBQUE7QUFDZCxjQUFNLFdBQVcsS0FBSyxXQUNoQix5QkFBeUIsSUFBQSxVQUFBLDBCQUF5QjtBQUV4RCxZQUFJLHdCQUF3QjtBQUMxQix1QkFBYTtBQUViLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLGtDQUE4QixPQUFLO0FBQ3hDLFlBQU0sY0FBYyxNQUFNLFdBQVcsQ0FBQyxjQUFhLFNBQUE7QUFDakQsY0FBTSxXQUFXLEtBQUssV0FDaEIseUJBQXlCLElBQUEsVUFBQSwwQkFBeUIsV0FDbEQsaUJBQWlCO0FBRXZCLFlBQUksZ0JBQWdCO0FBQ2xCLGdCQUFNLGFBQWE7QUFFbkIsdUJBQVksS0FBSzs7QUFHbkIsZUFBTztTQUNOO0FBRUgsYUFBTzs7QUFHRixtQ0FBK0IsT0FBSztBQUN6QyxZQUFNLGVBQWUsTUFBTSxXQUFXLENBQUMsZUFBYyxTQUFBO0FBQ25ELGNBQU0sV0FBVyxLQUFLLFdBQ3BCLDBCQUEwQixJQUFBLFVBQUEsMkJBQTBCLFdBQ3BELGtCQUFrQjtBQUVwQixZQUFJLGlCQUFpQjtBQUNuQixnQkFBTSxjQUFjO0FBRXBCLHdCQUFhLEtBQUs7O0FBR3BCLGVBQU87U0FDTjtBQUVILGFBQU87O0FBR0YsbUNBQStCLE9BQUs7QUFDekMsVUFBSSxlQUFlO0FBRW5CLFlBQU0sU0FBUyxDQUFDLFNBQUE7QUFDZCxjQUFNLFdBQVcsS0FBSyxXQUNoQiwyQkFBMkIsSUFBQSxVQUFBLDRCQUEyQjtBQUU1RCxZQUFJLDBCQUEwQjtBQUM1Qix5QkFBZTtBQUVmLGlCQUFPOzs7QUFJWCxhQUFPOztBQUdGLDRDQUF3QyxPQUFLO0FBQ2xELFlBQU0sd0JBQXdCLE1BQU0sV0FBVyxDQUFDLHdCQUF1QixTQUFBO0FBQy9ELGNBQU0sV0FBVyxLQUFLLFdBQ2hCLG1DQUFtQyxJQUFBLFVBQUEsb0NBQW1DLFdBQ3RFLDJCQUEyQjtBQUVqQyxZQUFJLDBCQUEwQjtBQUM1QixnQkFBTSx1QkFBdUI7QUFFN0IsaUNBQXNCLEtBQUs7O0FBRzdCLGVBQU87U0FDTjtBQUVULGFBQU87O0FBR0YsbURBQStDLE9BQUs7QUFDekQsWUFBTSwrQkFBK0IsTUFBTSxXQUFXLENBQUMsK0JBQThCLFNBQUE7QUFDN0UsY0FBTSxXQUFXLEtBQUssV0FDaEIsMENBQTBDLElBQUEsVUFBQSwyQ0FBMEMsV0FDcEYsa0NBQWtDO0FBRXhDLFlBQUksaUNBQWlDO0FBQ25DLGdCQUFNLDhCQUE4QjtBQUVwQyx3Q0FBNkIsS0FBSzs7QUFHcEMsZUFBTztTQUNOO0FBRVQsYUFBTzs7Ozs7QUNoSFQ7Ozs7O21DQTREQSxXQUFBOzs7ZUFBQTs7OztBQW5EQSw2QkFBUztBQUNQLFlBQU0sUUFBUSxLQUFLLFlBQ2IsYUFBYSxJQUFBLE9BQUEscUJBQW9CO0FBRXZDLGFBQU87O0FBR1QsOEJBQVM7QUFDUCxZQUFNLFFBQVEsS0FBSyxZQUNiLGNBQWMsSUFBQSxPQUFBLHNCQUFxQjtBQUV6QyxhQUFPOztBQUdULCtCQUFTO0FBQ1AsWUFBTSxRQUFRLEtBQUssWUFDYixlQUFlLElBQUEsT0FBQSx1QkFBc0I7QUFFM0MsYUFBTzs7QUFHVCwrQkFBUztBQUNQLFlBQU0sUUFBUSxLQUFLLFlBQ2IsZUFBZSxJQUFBLE9BQUEsdUJBQXNCO0FBRTNDLGFBQU87O0FBR1Qsd0NBQVM7QUFDUCxZQUFNLFFBQVEsS0FBSyxZQUNiLHdCQUF3QixJQUFBLE9BQUEsZ0NBQStCO0FBRTdELGFBQU87O0FBR1QsK0NBQVM7QUFDUCxZQUFNLFFBQVEsS0FBSyxZQUNiLCtCQUErQixJQUFBLE9BQUEsdUNBQXNDO0FBRTNFLGFBQU87O0FBR1QsUUFBTSxjQUFjO01BQ2xCO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDNURmOzs7OzttQ0FFQSxXQUFBOzs7ZUFBcUI7OztBQUFOLDJCQUFNO01BQ25CLFlBQVksTUFBTSxrQkFBa0I7QUFDbEMsYUFBSyxPQUFPO0FBQ1osYUFBSyxtQkFBbUI7O01BRzFCLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2Qsb0JBQW9CO0FBQ2xCLGVBQU8sS0FBSzs7TUFHZCxXQUFXO0FBQ1QsWUFBSTtBQUVKLFlBQUksS0FBSyxxQkFBcUIsTUFBTTtBQUNsQyxnQkFBTSx5QkFBeUIsS0FBSyxpQkFBaUI7QUFFckQsbUJBQVMsR0FBRyxLQUFLLFFBQVE7ZUFDcEI7QUFDTCxtQkFBUyxLQUFLOztBQUdoQixlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixjQUFNLG1CQUFtQixNQUNuQixhQUFhLElBQUksV0FBVyxNQUFNO0FBRXhDLGVBQU87O2FBR0YsNEJBQTRCLE1BQU0sa0JBQWtCO0FBQ3pELGNBQU0sYUFBYSxJQUFJLFdBQVcsTUFBTTtBQUV4QyxlQUFPOzs7Ozs7QUN4Q1g7Ozs7O21DQUtBLFdBQUE7OztlQUFxQjs7Ozs7QUFBTixpQ0FBTTtNQUNuQixZQUFZLGFBQWEsYUFBYTtBQUNwQyxhQUFLLGNBQWM7QUFDbkIsYUFBSyxjQUFjOztNQUdyQixpQkFBaUI7QUFDZixlQUFPLEtBQUs7O01BR2QsaUJBQWlCO0FBQ2YsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxjQUFNLFNBQVMsR0FBRyxLQUFLLGVBQWUsS0FBSztBQUUzQyxlQUFPOztNQUdULGtCQUFrQjtBQUNoQixjQUFNLGdCQUFnQixLQUFLLGNBQWMsWUFBQSwwQkFBMEIsS0FBSyxjQUFjLFlBQUE7QUFFdEYsZUFBTzs7TUFHVCxnQ0FBZ0M7QUFDOUIsY0FBTSxnQkFBZ0IsS0FBSyxtQkFDckIsNkJBQTZCO0FBRW5DLGVBQU87O01BR1QsbUNBQW1DO0FBQ2pDLGNBQU0sY0FBYyxLQUFLLGNBQWMsR0FDakMsY0FBYyxHQUNkLG1CQUFtQixpQkFBaUIsOEJBQThCLGFBQWEsY0FDL0UseUJBQXlCLGlCQUFpQixtQkFDMUMsZ0NBQWdDLHlCQUF5QjtBQUUvRCxlQUFPOzthQUdGLFdBQVcsUUFBUTtBQUN4QixjQUFNLGNBQWMsSUFBQSxTQUFBLHVCQUFzQixTQUNwQyxjQUFjLElBQUEsU0FBQSx1QkFBc0IsU0FDcEMsbUJBQW1CLElBQUksaUJBQWlCLGFBQWE7QUFFM0QsZUFBTzs7YUFHRixrQkFBa0IsZUFBZTtBQUN0QyxjQUFNLFNBQVMsZUFDVCxjQUFjLElBQUEsU0FBQSx1QkFBc0IsU0FDcEMsY0FBYyxJQUFBLFNBQUEsdUJBQXNCLFNBQ3BDLG1CQUFtQixJQUFJLGlCQUFpQixhQUFhO0FBRTNELGVBQU87O2FBR0YsOEJBQThCLGFBQWEsYUFBYTtBQUM3RCxjQUFNLG1CQUFtQixJQUFJLGlCQUFpQixhQUFhO0FBRTNELGVBQU87Ozs7OztBQ3BFWDs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsV0FBWSxXQUFBO0FBRUwsNkJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLGNBQWMsWUFBWTtBQUFFLGFBQUssTUFBTSxLQUFLOztNQUU1QyxjQUFjLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxJQUFJOztNQUVoRCxnQkFBZ0IsVUFBVTtBQUFFLGVBQU8sS0FBSyxNQUFNLE1BQU07O01BRXBELGlCQUFpQixVQUFVLGNBQWM7QUFBRSxlQUFPLEtBQUssTUFBTSxPQUFPLFVBQVU7O01BRTlFLGtCQUFrQixVQUFVO0FBQUUsYUFBSyxNQUFNLFFBQVE7O01BRWpELDhCQUE4QixXQUFXLE1BQU07QUFBRSxnQkFBUSxLQUFLLE9BQU8sV0FBVzs7TUFFaEYsU0FBUztBQUNQLGNBQU0sbUJBQW1CLEtBQUssTUFBTSxPQUFPLENBQUMsbUJBQWtCLGVBQUE7QUFDdEQsZ0JBQU0sT0FBTyxXQUFXLFdBQ2xCLG1CQUFtQixXQUFXLHFCQUM5Qix5QkFBeUIsaUJBQWlCO0FBRWhELDRCQUFpQixRQUFRO0FBRXpCLGlCQUFPO1dBQ04sS0FDSCxPQUFPO0FBRWIsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsY0FBTSxtQkFBbUIsTUFDbkIsdUJBQXVCLE9BQU8sS0FBSyxtQkFDbkMsUUFBUSxzQkFDUixRQUFRLE1BQU0sSUFBSSxDQUFDLFNBQUE7QUFDakIsZ0JBQU0seUJBQXlCLGlCQUFpQixPQUMxQyxTQUFTLHdCQUNULG1CQUFtQixrQkFBQSxRQUFpQixXQUFXLFNBQy9DLGFBQWEsWUFBQSxRQUFXLDRCQUE0QixNQUFNO0FBRWhFLGlCQUFPO1lBRVQsZUFBZSxJQUFJLGFBQWE7QUFFdEMsZUFBTzs7YUFHRixjQUFjO0FBQ25CLGNBQU0sUUFBUSxJQUNSLGVBQWUsSUFBSSxhQUFhO0FBRXRDLGVBQU87Ozs7OztBQ2xFWDs7Ozs7Ozs7Ozs7OztVQUlnQixZQUFBO2VBQUE7O1VBWUEsYUFBQTtlQUFBOzs7O0FBWlQsdUJBQW1CLGtCQUFnQjtBQUN4QyxZQUFNLFFBQVEsWUFBQSxNQUFNLHFCQUFxQjtBQUV6QyxhQUFPLFNBQVMsTUFBSTtBQUNsQixjQUFNLFFBQVEsTUFBTSxRQUFRO0FBRTVCLGVBQU8sTUFBTSxXQUFXO0FBRXhCLGVBQU87OztBQUlKLHdCQUFvQixrQkFBZ0I7QUFDekMsWUFBTSxRQUFRLFlBQUEsTUFBTSxxQkFBcUI7QUFFekMsYUFBTyxTQUFTLE1BQUk7QUFDbEIsY0FBTSxRQUFRLE1BQU0sUUFBUTtBQUU1QixlQUFPOzs7Ozs7QUN0Qlg7Ozs7Ozs7Ozs7Ozs7VUFJZ0IsaUNBQUE7ZUFBQTs7VUFGQSx3QkFBQTtlQUFBOzs7QUFBVCxtQ0FBK0IsUUFBTTtBQUFJLGFBQU8sdURBQXVELEtBQUs7O0FBRTVHLDRDQUF3QyxRQUFNO0FBQUksYUFBTyxxQ0FBcUMsS0FBSzs7Ozs7QUNKMUc7Ozs7Ozs7Ozs7Ozs7VUFJYSw2QkFBQTtlQUFBOztVQURBLDJCQUFBO2VBQUE7O1VBREEsd0JBQUE7ZUFBQTs7O0FBQU4sUUFBTSx3QkFBd0I7QUFDOUIsUUFBTSwyQkFBMkI7QUFDakMsUUFBTSw2QkFBNkI7Ozs7QUNKMUM7Ozs7Ozs7Ozs7Ozs7VUFzTUEsVUFBQTtlQUFBOztVQWhFZ0IsK0JBQUE7ZUFBQTs7VUFpQ0Esa0NBQUE7ZUFBQTs7VUFsR0EsK0JBQUE7ZUFBQTs7VUE3Q0Esc0JBQUE7ZUFBQTs7VUF1RkEsNkJBQUE7ZUFBQTs7VUFsRUEsNEJBQUE7ZUFBQTs7VUFzQ0EsMEJBQUE7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcEVoQixRQUFNLFlBQVksZUFBQSxVQUFVO0FBQTVCLFFBQ00sYUFBYSxlQUFBLFdBQVc7QUFFOUIsUUFBTSxrQkFBa0IsSUFBQSxPQUFBLFlBQVc7QUFBbkMsUUFDTSxxQkFBcUIsSUFBQSxPQUFBLFlBQVc7QUFEdEMsUUFFTSw2QkFBNkIsSUFBQSxPQUFBLFlBQVc7QUFGOUMsUUFHTSx5Q0FBeUMsSUFBQSxPQUFBLFdBQVU7QUFIekQsUUFJTSw2Q0FBNkMsSUFBQSxPQUFBLFdBQVU7QUFFdEQsaUNBQTZCLGNBQVk7QUFDOUMsVUFBSSxvQkFBb0I7QUFFeEIsWUFBTSxlQUFlLDZCQUE2QjtBQUVsRCxVQUFJLGlCQUFpQixNQUFNO0FBQ3pCLGNBQU0sYUFBYSxnQkFBZ0IsZUFDN0IsbUJBQW1CLFdBQVc7QUFFcEMsWUFBSSxxQkFBcUIsR0FBRztBQUMxQixnQkFBTSxVQUFVLHdCQUF3QixlQUNsQyxhQUFhLDJCQUEyQixlQUN4QyxlQUFlLDZCQUE2QjtBQUVsRCw4QkFBc0IsWUFBWSxRQUFVLGVBQWUsUUFBVSxpQkFBaUI7OztBQUkxRixhQUFPOztBQUdGLHVDQUFtQyxjQUFjLFNBQU87QUFDN0QsWUFBTSxlQUFlLDZCQUE2QixlQUM1QyxhQUFhLDJCQUEyQjtBQUU5QyxVQUFJLGVBQWUsNkJBQTZCO0FBRWhELFlBQU0sU0FBUyxRQUFRLFlBQ2pCLG1CQUFtQixhQUFhO0FBRXRDLGdCQUFVO0FBRVYscUJBQWU7QUFFZixZQUFNLFdBQVc7UUFDVDtRQUNBO1FBQ0E7U0FFRixpQkFBaUIsS0FBSyxVQUFVLFVBQVUsTUFBTSxXQUFBLGVBQ2hELHNCQUFzQjtBQUU1QixtQkFBYSxXQUFXOztBQUduQiwwQ0FBc0MsY0FBWTtBQUN2RCxVQUFJLGVBQWU7QUFFbkIsVUFBSSxpQkFBaUIsTUFBTTtBQUN6QixjQUFNLFVBQVUsYUFBYSxjQUN2QixTQUFTLFVBQVUsU0FBUyxVQUM1QixPQUFPLFdBQVcsTUFBTTtBQUU5Qix1QkFBZTs7QUFHakIsYUFBTzs7QUFHRixxQ0FBaUMsY0FBWTtBQUNsRCxVQUFJLFVBQVU7QUFFZCxZQUFNLHdCQUF3QixzQ0FBc0M7QUFFcEUsNEJBQXNCLEtBQUssQ0FBQyx5QkFBQTtBQUMxQixjQUFNLGVBQWUsc0JBQ2YsZUFBZSw2QkFBNkI7QUFFbEQsWUFBSSxpQkFBaUIsZUFBQSx1QkFBdUI7QUFDMUMsZ0JBQU0sc0JBQXNCLG9DQUFvQztBQUVoRSxjQUFJLHdCQUF3QixNQUFNO0FBQ2hDLGtCQUFNLFNBQVMscUJBQ1Qsc0JBQXNCLElBQUEsVUFBQSx1QkFBc0I7QUFFbEQsZ0JBQUkscUJBQXFCO0FBQ3ZCLHdCQUFVLFNBQUEsUUFBUSxXQUFXOztBQUcvQixtQkFBTzs7OztBQUtiLGFBQU87O0FBR0Ysd0NBQW9DLGNBQVk7QUFDckQsVUFBSSxhQUFhO0FBRWpCLFlBQU0sd0JBQXdCLHNDQUFzQztBQUVwRSw0QkFBc0IsS0FBSyxDQUFDLHlCQUFBO0FBQzFCLGNBQU0sZUFBZSxzQkFDZixlQUFlLDZCQUE2QjtBQUVsRCxZQUFJLGlCQUFpQixlQUFBLDBCQUEwQjtBQUM3QyxnQkFBTSxzQkFBc0Isb0NBQW9DO0FBRWhFLGNBQUksd0JBQXdCLE1BQU07QUFDaEMseUJBQWE7QUFFYixtQkFBTzs7OztBQUtiLGFBQU87O0FBR0YsMENBQXNDLGNBQVk7QUFDdkQsVUFBSSxlQUFlO0FBRW5CLFlBQU0sMkJBQTJCLHlDQUF5QztBQUUxRSxVQUFJLDZCQUE2QixNQUFNO0FBQ3JDLHVCQUFlLGNBQUEsUUFBYTtBQUU1QixjQUFNLGVBQWUsMEJBQ2YsZ0JBQWdCLG1CQUFtQjtBQUV6QyxzQkFBYyxRQUFRLENBQUMsa0JBQUE7QUFDckIsZ0JBQU0sc0JBQXNCLG9DQUFvQztBQUVoRSxjQUFJLHdCQUF3QixNQUFNO0FBQ2hDLGtCQUFNLFNBQVMscUJBQ1QsK0JBQStCLElBQUEsVUFBQSxnQ0FBK0I7QUFFcEUsZ0JBQUksOEJBQThCO0FBQ2hDLG9CQUFNLGVBQWUsNkJBQTZCLGdCQUM1QyxPQUFPLGNBQ1AsbUJBQW1CLGtCQUFBLFFBQWlCLFdBQVcsU0FDL0MsYUFBYSxZQUFBLFFBQVcsNEJBQTRCLE1BQU07QUFFaEUsMkJBQWEsY0FBYzs7Ozs7QUFNbkMsYUFBTzs7QUFHRiw2Q0FBeUMsY0FBWTtBQUMxRCxVQUFJLGtCQUFrQjtBQUV0QixZQUFNLDJCQUEyQix5Q0FBeUM7QUFFMUUsVUFBSSw2QkFBNkIsTUFBTTtBQUNyQywwQkFBa0I7QUFFbEIsY0FBTSxlQUFlLDBCQUNmLGdCQUFnQixtQkFBbUI7QUFFekMsc0JBQWMsUUFBUSxDQUFDLGtCQUFBO0FBQ3JCLGdCQUFNLHNCQUFzQixvQ0FBb0M7QUFFaEUsY0FBSSx3QkFBd0IsTUFBTTtBQUNoQyxrQkFBTSxTQUFTLHFCQUNULCtCQUErQixJQUFBLFVBQUEsZ0NBQStCO0FBRXBFLGdCQUFJLDhCQUE4QjtBQUNoQyxvQkFBTSxlQUFlLDZCQUE2QixnQkFDNUMsaUJBQWlCO0FBRXZCLDhCQUFnQixLQUFLOzs7OztBQU03QixhQUFPOztRQUdULFdBQWU7TUFDYjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTs7QUFHRiwwQ0FBc0MsY0FBWTtBQUNoRCxZQUFNLG9DQUFvQyx1Q0FBdUMsZUFDM0UsMkNBQTJDLGtDQUFrQyxjQUM3RSxlQUFlLElBQUEsU0FBQSxrQkFBaUI7QUFFdEMsYUFBTzs7QUFHVCxpREFBNkMsY0FBWTtBQUN2RCxVQUFJLHNCQUFzQjtBQUUxQixZQUFNLHdDQUF3QywyQ0FBMkM7QUFFekYsVUFBSSwwQ0FBMEMsTUFBTTtBQUNsRCxjQUFNLCtDQUErQyxzQ0FBc0M7QUFFM0YsOEJBQXNCLElBQUEsU0FBQSxrQkFBaUI7O0FBR3pDLGFBQU87O0FBR1QsbURBQStDLGNBQVk7QUFDekQsWUFBTSx3QkFBd0IsMkJBQTJCO0FBRXpELGFBQU87O0FBR1Qsc0RBQWtELGNBQVk7QUFDNUQsVUFBSSwyQkFBMkI7QUFFL0IsWUFBTSx3QkFBd0Isc0NBQXNDO0FBRXBFLDRCQUFzQixLQUFLLENBQUMseUJBQUE7QUFDMUIsY0FBTSxlQUFlLHNCQUNmLGVBQWUsNkJBQTZCO0FBRWxELFlBQUksaUJBQWlCLGVBQUEsNEJBQTRCO0FBQy9DLHFDQUEyQjtBQUUzQixpQkFBTzs7O0FBSVgsYUFBTzs7Ozs7QUM1UFQ7Ozs7O21DQTJDQSxXQUFBOzs7ZUFBQTs7OztBQXZDQSwwQkFBUztBQUNQLFlBQU0sZUFBZSxLQUFLLG1CQUNwQixlQUFlLElBQUEsVUFBQSw4QkFBNkIsZUFDNUMsVUFBVSxJQUFBLFVBQUEseUJBQXdCO0FBRXhDLGFBQU87O0FBR1QsNkJBQVM7QUFDUCxZQUFNLGVBQWUsS0FBSyxtQkFDcEIsZUFBZSxJQUFBLFVBQUEsOEJBQTZCLGVBQzVDLGFBQWEsSUFBQSxVQUFBLDRCQUEyQjtBQUU5QyxhQUFPOztBQUdULCtCQUFTO0FBQ1AsWUFBTSxlQUFlLEtBQUssbUJBQ3BCLGVBQWUsSUFBQSxVQUFBLDhCQUE2QixlQUM1QyxlQUFlLElBQUEsVUFBQSw4QkFBNkI7QUFFbEQsYUFBTzs7QUFHVCxrQ0FBUztBQUNQLFlBQU0sZUFBZSxLQUFLLG1CQUNwQixlQUFlLElBQUEsVUFBQSw4QkFBNkIsZUFDNUMsa0JBQWtCLElBQUEsVUFBQSxpQ0FBZ0M7QUFFeEQsYUFBTzs7QUFHVCxRQUFNLGlCQUFpQjtNQUNyQjtNQUNBO01BQ0E7TUFDQTs7UUFHRixXQUFlOzs7O0FDM0NmOzs7OzttQ0FrREEsV0FBQTs7O2VBQUE7Ozs7OztBQTVDQSwyQkFBdUIsb0JBQWtCO0FBQ3ZDLFVBQUksYUFBYSxXQUFBO0FBRWpCLFlBQU0sK0JBQStCLEtBQUssbUNBQ3BDLDhCQUE4Qiw2QkFBNkIsS0FBSyxDQUFDLGlDQUFBO0FBQ2pFLGNBQU0sa0NBQWtDLDZCQUE0QixXQUM5RCxrQ0FBa0MsSUFBQSxNQUFBLHNCQUFxQjtBQUU3RCxZQUFJLG9DQUFvQyxvQkFBb0I7QUFDMUQsaUJBQU87O1lBRUw7QUFFVixVQUFJLGdDQUFnQyxNQUFNO0FBQ3hDLGNBQU0scUNBQXFDLDRCQUE0QjtBQUV2RSxxQkFBYTs7QUFHZixhQUFPOztBQUdULGlDQUFTO0FBQ1AsWUFBTSxXQUFXLFdBQUEsMkJBQ1gsYUFBYSxLQUFLLGNBQWMsV0FDaEMsaUJBQWlCO0FBRXZCLGFBQU87O0FBR1QsbUNBQVM7QUFDUCxZQUFNLFdBQVcsV0FBQSw2QkFDWCxhQUFhLEtBQUssY0FBYyxXQUNoQyxtQkFBbUI7QUFFekIsYUFBTzs7QUFHVCxRQUFNLG1CQUFvQjtNQUN4QjtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ2xEZjs7Ozs7bUNBaU5BLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBck1BLFFBQU0sQ0FBRSxlQUFPLFVBQVcsV0FBQTtBQUExQixRQUNNLENBQUUsZ0NBQWlDLFdBQUE7QUFFekMsd0JBQU07TUFDSixZQUFZLE9BQU87QUFDakIsYUFBSyxRQUFROztNQUdmLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsMEJBQTBCO0FBQ3hCLFlBQUksdUJBQXVCO0FBRTNCLGNBQU0sYUFBYSxPQUFNLEtBQUs7QUFFOUIsWUFBSSxZQUFZO0FBQ2QsZ0JBQU0saUJBQWlCLFdBQVc7QUFFbEMsaUNBQXVCLDZCQUE2QjtBQUVwRCxjQUFJLHlCQUF5QixNQUFNO0FBQ2pDLG1DQUF1Qjs7O0FBSTNCLGVBQU87O01BR1QsaUJBQWlCLE1BQU07QUFDckIsZUFBTyxLQUFLLE9BQU8sQ0FBQyxVQUFBO0FBQ2xCLGdCQUFNLFlBQVksTUFBTTtBQUV4QixjQUFJLFdBQVc7QUFDYixrQkFBTSxPQUFPLE9BQ1AsV0FBVyxLQUFLO0FBRXRCLGdCQUFJLGFBQWEsTUFBTTtBQUNyQixxQkFBTzs7O0FBSVgsaUJBQU87OztNQUlYLFNBQVMsVUFBVTtBQUNqQixjQUFNLFFBQVEsS0FBSyxZQUNiLE9BQU8sTUFBTSxTQUFTLENBQUMsVUFBQTtBQUNyQixnQkFBTSxrQkFBa0IsTUFBSyxjQUFjO0FBRTNDLGNBQUksaUJBQWlCO0FBQ25CLG1CQUFPOztjQUVMO0FBRVosZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxRQUFRLE9BQUEsUUFBTTtBQUVwQixhQUFLLFNBQVMsQ0FBQyxVQUFBO0FBQ2IsZ0JBQU0sWUFBWSxNQUFNO0FBRXhCLGNBQUksV0FBVztBQUNiLGtCQUFNLE9BQU87QUFFYixrQkFBTSxRQUFROzs7QUFJbEIsZUFBTzs7TUFHVCxlQUFlO0FBQ2IsY0FBTSxZQUFZLEtBQUssWUFBWSxDQUFDLFlBQVcsVUFBQTtBQUM3QyxnQkFBTSxZQUFZLE1BQU07QUFFeEIsY0FBSSxXQUFXO0FBQ2Isa0JBQU0sT0FBTyxPQUNQLFdBQVcsS0FBSztBQUV0Qix1QkFBVSxLQUFLOztBQUdqQixpQkFBTztXQUNOO0FBRUgsZUFBTzs7TUFHVCxvQkFBb0I7QUFDbEIsY0FBTSxpQkFBaUIsS0FBSyxZQUFZLENBQUMsaUJBQWdCLFVBQUE7QUFDdkQsZ0JBQU0saUJBQWlCLE1BQU07QUFFN0IsY0FBSSxnQkFBZ0I7QUFDbEIsa0JBQU0sWUFBWSxPQUNaLGdCQUFnQixVQUFVO0FBRWhDLDRCQUFlLEtBQUs7O0FBR3RCLGlCQUFPO1dBQ047QUFFSCxlQUFPOztNQUdULHNCQUFzQixrQkFBa0I7QUFDdEMsY0FBTSxVQUFVLEtBQUssY0FDZixpQ0FBaUMsUUFBUSxzQkFBc0I7QUFFckUsZUFBTzs7TUFHVCxRQUFRLE1BQU07QUFDWixjQUFNLFFBQVE7QUFFZCxhQUFLLFNBQVM7O01BR2hCLFNBQVMsT0FBTztBQUFFLGFBQUssTUFBTSxLQUFLOztNQUVsQyxhQUFhLFdBQVc7QUFDdEIsY0FBTSxRQUFRO0FBRWQsYUFBSyxTQUFTOztNQUdoQixZQUFZLFVBQVU7QUFDcEIsY0FBTSxRQUFRLEtBQUs7QUFFbkIsY0FBTSxZQUFZOztNQUdwQixTQUFTLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxJQUFJOztNQUUzQyxVQUFVLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxLQUFLOztNQUU3QyxXQUFXLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxNQUFNOztNQUUvQyxhQUFhLFVBQVU7QUFBRSxhQUFLLE1BQU0sUUFBUTs7TUFFNUMsWUFBWSxVQUFVLGNBQWM7QUFBRSxlQUFPLEtBQUssTUFBTSxPQUFPLFVBQVU7O01BRXpFLFNBQVM7QUFDUCxjQUFNLGNBQWMsS0FBSyxNQUFNLElBQUksQ0FBQyxVQUFBO0FBQzVCLGdCQUFNLFlBQVksTUFBTTtBQUV4QixpQkFBTztZQUVULE9BQU87QUFFYixlQUFPOzthQUdGLFNBQVMsTUFBTTtBQUNwQixjQUFNLFFBQVEsSUFDUixVQUFVLElBQUksUUFBUSxRQUN0QixjQUFjO0FBRXBCLG9CQUFZLElBQUksQ0FBQyxjQUFBO0FBQ2YsZ0JBQU0sUUFBTyxXQUNQLE9BQU8sTUFBQSxRQUFLLFNBQVMsUUFDckIsWUFBWSxXQUFBLFFBQVUsU0FBUyxRQUMvQixRQUFRLFFBQVE7QUFFdEIsa0JBQVEsU0FBUzs7QUFHbkIsZUFBTzs7YUFHRixVQUFVLE9BQU87QUFDdEIsY0FBTSxRQUFRO1VBQ047V0FFRixVQUFVLElBQUksUUFBUTtBQUU1QixlQUFPOzthQUdGLGNBQWM7QUFDbkIsY0FBTSxRQUFRLElBQ1IsVUFBVSxJQUFJLFFBQVE7QUFFNUIsZUFBTzs7O0FBSVgsV0FBTyxPQUFPLFFBQVEsV0FBVyxLQUFBO0FBQ2pDLFdBQU8sT0FBTyxRQUFRLFdBQVcsUUFBQTtBQUNqQyxXQUFPLE9BQU8sUUFBUSxXQUFXLFVBQUE7QUFDakMsV0FBTyxPQUFPLFFBQVEsV0FBVyxZQUFBO1FBRWpDLFdBQWU7Ozs7QUNqTmY7Ozs7O21DQW9FQSxXQUFBOzs7ZUFBQTs7O0FBbEVBLHlCQUFxQixVQUFRO0FBQUksYUFBTyxLQUFLLFFBQVEsWUFBWTs7QUFFakUsc0JBQWtCLFVBQVE7QUFBSSxhQUFPLEtBQUssUUFBUSxTQUFTOztBQUUzRCxzQkFBUztBQUFXLGFBQU8sS0FBSyxRQUFROztBQUV4Qyx3QkFBUztBQUFhLGFBQU8sS0FBSyxRQUFROztBQUUxQywwQkFBUztBQUFlLGFBQU8sS0FBSyxRQUFROztBQUU1QywwQkFBUztBQUFlLGFBQU8sS0FBSyxRQUFROztBQUU1Qyw0QkFBUztBQUFpQixhQUFPLEtBQUssUUFBUTs7QUFFOUMsNkJBQVM7QUFBa0IsYUFBTyxLQUFLLFFBQVE7O0FBRS9DLDZCQUFTO0FBQWtCLGFBQU8sS0FBSyxRQUFROztBQUUvQyw2QkFBUztBQUFrQixhQUFPLEtBQUssUUFBUTs7QUFFL0MsK0JBQVM7QUFBb0IsYUFBTyxLQUFLLFFBQVE7O0FBRWpELCtCQUFTO0FBQW9CLGFBQU8sS0FBSyxRQUFROztBQUVqRCxpQ0FBUztBQUFzQixhQUFPLEtBQUssUUFBUTs7QUFFbkQsbUNBQVM7QUFBd0IsYUFBTyxLQUFLLFFBQVE7O0FBRXJELCtCQUFTO0FBQW9CLGFBQU8sS0FBSyxRQUFROztBQUVqRCw4QkFBUztBQUFtQixhQUFPLEtBQUssUUFBUTs7QUFFaEQsK0JBQVM7QUFBb0IsYUFBTyxLQUFLLFFBQVE7O0FBRWpELGlDQUFTO0FBQXNCLGFBQU8sS0FBSyxRQUFROztBQUVuRCxrQ0FBUztBQUF1QixhQUFPLEtBQUssUUFBUTs7QUFFcEQsd0NBQVM7QUFBNkIsYUFBTyxLQUFLLFFBQVE7O0FBRTFELCtDQUFTO0FBQW9DLGFBQU8sS0FBSyxRQUFROztBQUVqRSxRQUFNLGdCQUFnQjtNQUNwQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7O1FBR0YsV0FBZTs7OztBQ3BFZjs7Ozs7bUNBOERBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7O0FBekRBLHdCQUFNO01BQ0osWUFBWSxNQUFNLFNBQVM7QUFDekIsYUFBSyxPQUFPO0FBQ1osYUFBSyxVQUFVOztNQUdqQixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLGFBQWE7QUFDWCxlQUFPLEtBQUs7O01BR2QsU0FBUztBQUNQLGNBQU0sY0FBYyxLQUFLLFFBQVEsVUFDM0IsT0FBTyxLQUFLLE1BQ1osVUFBVSxhQUNWLE9BQU87VUFDTDtVQUNBOztBQUdSLGVBQU87O2FBR0YsU0FBUyxNQUFNO0FBQ3BCLFlBQUksQ0FBRSxXQUFZO0FBRWxCLGNBQU0sQ0FBRSxRQUFTLE1BQ1gsY0FBYztBQUVwQixlQUFPO0FBRVAsa0JBQVUsU0FBQSxRQUFRLFNBQVM7QUFFM0IsY0FBTSxVQUFVLElBQUksUUFBUSxNQUFNO0FBRWxDLGVBQU87O2FBR0YsU0FBUyxNQUFNO0FBQ3BCLGNBQU0sVUFBVSxTQUFBLFFBQVEsZUFDbEIsVUFBVSxJQUFJLFFBQVEsTUFBTTtBQUVsQyxlQUFPOzthQUdGLG1CQUFtQixNQUFNLFNBQVM7QUFDdkMsY0FBTSxVQUFVLElBQUksUUFBUSxNQUFNO0FBRWxDLGVBQU87OztBQUlYLFdBQU8sT0FBTyxRQUFRLFdBQVcsVUFBQTtRQUVqQyxXQUFlOzs7O0FDOURmOzs7OzttQ0E4R0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7Ozs7OztBQW5HQSx3QkFBTTtNQUNKLFlBQVksTUFBTSxTQUFTO0FBQ3pCLGFBQUssT0FBTztBQUNaLGFBQUssVUFBVTs7TUFHakIsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOztNQUdkLGNBQWMsU0FBUztBQUNyQixZQUFJLGFBQWEsS0FBSyxpQkFDbEIsZUFBZSxLQUFLO0FBRXhCLGNBQU0sZ0JBQWdCLFFBQVEsWUFDeEIsaUJBQWlCLFlBQ2pCLG1CQUFtQixhQUFhO0FBRXRDLGtCQUFVO0FBQ1YscUJBQWE7QUFDYix1QkFBZTtBQUVmLGNBQU0sZUFBZSxLQUFLLG1CQUNwQixPQUFPO1VBQ0w7VUFDQTtVQUNBO1dBRUYsYUFBYSxLQUFLLFVBQVUsTUFBTSxNQUFNLFdBQUEsZUFDeEMsT0FBTyxjQUNQLFVBQVU7QUFFaEIsYUFBSyxXQUFXOztNQUdsQixTQUFTO0FBQ1AsY0FBTSxjQUFjLEtBQUssUUFBUSxVQUMzQixPQUFPLEtBQUssTUFDWixVQUFVLGFBQ1YsT0FBTztVQUNMO1VBQ0E7O0FBR1IsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsWUFBSSxDQUFFLFdBQVk7QUFFbEIsY0FBTSxDQUFFLFFBQVMsTUFDWCxjQUFjO0FBRXBCLGVBQU87QUFFUCxrQkFBVSxTQUFBLFFBQVEsU0FBUztBQUUzQixjQUFNLFVBQVUsSUFBSSxRQUFRLE1BQU07QUFFbEMsZUFBTzs7YUFHRixZQUFZLFNBQVM7QUFDMUIsWUFBSSxVQUFVLE1BQ1YsVUFBVSxRQUFRO0FBRXRCLGNBQU0sb0JBQW9CLHFCQUFxQjtBQUUvQyxZQUFJLG1CQUFtQjtBQUNyQixnQkFBTSxPQUFPLFFBQVEsV0FDZixrQkFBa0IsMEJBQTBCO0FBRWxELG9CQUFVO0FBRVYsb0JBQVUsSUFBSSxRQUFRLE1BQU07O0FBRzlCLGVBQU87O2FBR0YsbUJBQW1CLE1BQU0sU0FBUztBQUN2QyxZQUFJLFVBQVU7QUFFZCxjQUFNLG9CQUFvQixxQkFBcUI7QUFFL0MsWUFBSSxtQkFBbUI7QUFDckIsb0JBQVUsSUFBSSxRQUFRLE1BQU07O0FBRzlCLGVBQU87OztBQUlYLFdBQU8sT0FBTyxRQUFRLFdBQVcsVUFBQTtRQUVqQyxXQUFlO0FBRWYsdUNBQW1DLFNBQU87QUFDeEMsWUFBTSxrQkFBa0IsU0FBQSxRQUFRLGVBQzFCLFFBQVEsUUFBUTtBQUV0QixZQUFNLFlBQVksQ0FBQyxTQUFBO0FBQ2pCLGNBQU0sV0FBVyxLQUFLLFdBQ2hCLDBCQUEwQixJQUFBLFVBQUEsMkJBQTBCO0FBRTFELFlBQUkseUJBQXlCO0FBQzNCLGdCQUFNLE9BQU8sVUFDUCxVQUFVLEtBQUssY0FDZixXQUFXO0FBRWpCLGlCQUFPLE1BQUEsUUFBSywyQkFBMkIsTUFBTSxTQUFTO0FBRXRELDBCQUFnQixRQUFROzs7QUFJNUIsYUFBTzs7QUFHVCxrQ0FBOEIsU0FBTztBQUNuQyxVQUFJLG9CQUFvQjtBQUV4QixZQUFNLFFBQVEsUUFBUSxZQUNoQixhQUFhLElBQUEsT0FBQSxxQkFBb0IsUUFDakMsZUFBZSxJQUFBLE9BQUEsdUJBQXNCO0FBRTNDLFVBQUssZUFBZSxRQUFVLGlCQUFpQixNQUFPO0FBQ3BELGNBQU0sb0JBQW9CLElBQUEsVUFBQSxxQkFBb0I7QUFFOUMsWUFBSSxtQkFBbUI7QUFDckIsOEJBQW9COzs7QUFJeEIsYUFBTzs7Ozs7QUNySlQ7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsV0FBWSxXQUFBO0FBRUwseUJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFBRSxlQUFPLEtBQUssTUFBTTs7TUFFaEMsV0FBVyxTQUFTO0FBQUUsYUFBSyxNQUFNLEtBQUs7O01BRXRDLFdBQVcsVUFBVTtBQUFFLGVBQU8sS0FBSyxNQUFNLElBQUk7O01BRTdDLGNBQWMsVUFBVSxjQUFjO0FBQUUsZUFBTyxLQUFLLE1BQU0sT0FBTyxVQUFVOztNQUUzRSxlQUFlLFVBQVU7QUFBRSxhQUFLLE1BQU0sUUFBUTs7TUFFOUMsMkJBQTJCLFVBQVUsTUFBTTtBQUFFLGdCQUFRLEtBQUssT0FBTyxVQUFVOztNQUUzRSxTQUFTO0FBQ1AsY0FBTSxPQUFPLEtBQUssTUFBTSxJQUFJLENBQUMsWUFBQTtBQUMzQixnQkFBTSxjQUFjLFFBQVE7QUFFNUIsaUJBQU87O0FBR1QsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsY0FBTSxRQUFRLEtBQUssSUFBSSxDQUFDLFVBQUE7QUFDaEIsZ0JBQU0sVUFBVSxTQUFBLFFBQVEsU0FBUztBQUVqQyxpQkFBTztZQUVULFdBQVcsSUFBSSxTQUFTO0FBRTlCLGVBQU87O2FBR0YsY0FBYztBQUNuQixjQUFNLFFBQVEsSUFDUixXQUFXLElBQUksU0FBUztBQUU5QixlQUFPOzs7Ozs7QUN0RFg7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsV0FBWSxXQUFBO0FBRUwseUJBQU07TUFDbkIsWUFBWSxPQUFPO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFBRSxlQUFPLEtBQUssTUFBTTs7TUFFaEMsV0FBVyxTQUFTO0FBQUUsYUFBSyxNQUFNLEtBQUs7O01BRXRDLFdBQVcsVUFBVTtBQUFFLGVBQU8sS0FBSyxNQUFNLElBQUk7O01BRTdDLGNBQWMsVUFBVSxjQUFjO0FBQUUsZUFBTyxLQUFLLE1BQU0sT0FBTyxVQUFVOztNQUUzRSxlQUFlLFVBQVU7QUFBRSxhQUFLLE1BQU0sUUFBUTs7TUFFOUMsMkJBQTJCLFVBQVUsTUFBTTtBQUFFLGdCQUFRLEtBQUssT0FBTyxVQUFVOztNQUUzRSxTQUFTO0FBQ1AsY0FBTSxPQUFPLEtBQUssTUFBTSxJQUFJLENBQUMsWUFBQTtBQUMzQixnQkFBTSxjQUFjLFFBQVE7QUFFNUIsaUJBQU87O0FBR1QsZUFBTzs7YUFHRixTQUFTLE1BQU07QUFDcEIsY0FBTSxRQUFRLEtBQUssSUFBSSxDQUFDLFVBQUE7QUFDaEIsZ0JBQU0sVUFBVSxTQUFBLFFBQVEsU0FBUztBQUVqQyxpQkFBTztZQUVULFdBQVcsSUFBSSxTQUFTO0FBRTlCLGVBQU87O2FBR0YsY0FBYztBQUNuQixjQUFNLFFBQVEsSUFDUixXQUFXLElBQUksU0FBUztBQUU5QixlQUFPOzs7Ozs7QUN0RFg7Ozs7Ozs7Ozs7Ozs7VUFhb0IsZUFBQTtlQUFBLGNBQUE7O1VBREEsYUFBQTtlQUFBLFlBQUE7O1VBRkEsWUFBQTtlQUFBLFdBQUE7O1VBTEEsVUFBQTtlQUFBLFNBQUE7O1VBSEEsT0FBQTtlQUFBLE1BQUE7O1VBQ0EsUUFBQTtlQUFBLE9BQUE7O1VBR0EsVUFBQTtlQUFBLFNBQUE7O1VBRUEsV0FBQTtlQUFBLFVBQUE7O1VBREEsVUFBQTtlQUFBLFNBQUE7O1VBRUEsV0FBQTtlQUFBLFVBQUE7O1VBS0EsbUJBQUE7ZUFBQSxrQkFBQTs7VUFWQSxVQUFBO2VBQUEsU0FBQTs7VUFXQSxtQkFBQTtlQUFBLFNBQUE7O1VBSkEsWUFBQTtlQUFBLFdBQUE7O1VBS0Esb0JBQUE7ZUFBQSxVQUFBOztVQUNBLG9CQUFBO2VBQUEsVUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJwQjs7Ozs7Ozs7Ozs7OztVQXdFQSxVQUFBO2VBQUE7O1VBOURnQix5QkFBQTtlQUFBOztVQXNCQSw0QkFBQTtlQUFBOztVQXdCQSw0QkFBQTtlQUFBOzs7Ozs7Ozs7OztBQWhEaEIsUUFBTSxDQUFFLHVCQUF3QixZQUFBO0FBRXpCLG9DQUFnQyxNQUFNLFVBQU87QUFDbEQsWUFBTSxDQUFFLEtBQUssWUFBYSxVQUNwQixDQUFFLFFBQVM7QUFFakIsVUFBSSxDQUFFLFdBQVk7QUFFakIsTUFBQSxFQUFDLHFCQUFXO0FBRWIsYUFBTztBQUVQLGdCQUFVLFlBQUEsUUFBUSxTQUFTO0FBRTNCLFlBQU0sY0FBYztBQUVwQixhQUFPO0FBRVAsWUFBTSxnQkFBZ0IsSUFBQSxlQUFBLGlDQUFnQyxNQUFNLFVBQ3RELGlCQUFpQixTQUFBLFFBQWUsK0NBQStDLEtBQUssTUFBTSxNQUFNLFNBQVMsVUFBVTtBQUV6SCxhQUFPOztBQUdGLHVDQUFtQyxTQUFTLFVBQU87QUFDeEQsVUFBSSxpQkFBaUI7QUFFckIsVUFBSSxZQUFZLE1BQU07QUFDcEIsY0FBTSxlQUFlLFFBQVE7QUFFN0IsWUFBSSxpQkFBaUIsTUFBTTtBQUN6QixnQkFBTSxvQkFBb0Isb0JBQW9CO0FBRTlDLGNBQUksbUJBQW1CO0FBQ3JCLGtCQUFNLENBQUUsS0FBSyxZQUFhLFVBQ3BCLE9BQU8sUUFBUSxXQUNmLE9BQU8sTUFDUCxVQUFVLFFBQVEsY0FDbEIsZ0JBQWdCLElBQUEsZUFBQSxpQ0FBZ0MsTUFBTTtBQUU1RCw2QkFBaUIsU0FBQSxRQUFlLCtDQUErQyxLQUFLLE1BQU0sTUFBTSxTQUFTLFVBQVU7Ozs7QUFLekgsYUFBTzs7QUFHRix1Q0FBbUMsU0FBUyxVQUFPO0FBQ3hELFVBQUksaUJBQWlCO0FBRXJCLFVBQUksWUFBWSxNQUFNO0FBQ3BCLGNBQU0sQ0FBRSxLQUFLLFlBQWEsVUFDcEIsT0FBTyxRQUFRLFdBQ2YsT0FBTyxNQUNQLFVBQVUsUUFBUSxjQUNsQixnQkFBZ0IsSUFBQSxlQUFBLGlDQUFnQyxNQUFNO0FBRTVELHlCQUFpQixTQUFBLFFBQWUsK0NBQStDLEtBQUssTUFBTSxNQUFNLFNBQVMsVUFBVTs7QUFHckgsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTtNQUNBOzs7OztBQzNFRjs7Ozs7Ozs7Ozs7OztVQVVvQixZQUFBO2VBQUEsT0FBQTs7VUFOQSxVQUFBO2VBQUEsU0FBQTs7VUFEQSxVQUFBO2VBQUEsU0FBQTs7VUFVQSxrQkFBQTtlQUFBLGFBQUE7O1VBUkEsY0FBQTtlQUFBLE1BQUE7O1VBT0EsY0FBQTtlQUFBLFNBQUE7O1VBVkEsTUFBQTtlQUFBLEtBQUE7O1VBS0Esa0JBQUE7ZUFBQSxpQkFBQTs7VUFEQSxpQkFBQTtlQUFBLFNBQUE7O1VBS0EsYUFBQTtlQUFBLFFBQUE7O1VBRkEsVUFBQTtlQUFBLEtBQUE7O1VBVUEsd0JBQUE7ZUFBQSxjQUFBOztVQUZBLHVCQUFBO2VBQUEsYUFBQTs7VUFGQSxnQkFBQTtlQUFBLE1BQUE7O1VBQ0EsaUJBQUE7ZUFBQSxPQUFBOztVQUlBLDBCQUFBO2VBQUEsZ0JBQUE7O1VBRkEsd0JBQUE7ZUFBQSxjQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJwQjs7Ozs7Ozs7Ozs7OztVQVlBLFVBQUE7ZUFBQTs7VUFSZ0IsU0FBQTtlQUFBOzs7QUFGaEIsUUFBTSxXQUFXO0FBRVYsb0JBQWdCLFNBQU87QUFDNUIsWUFBTSxDQUFFLFFBQVM7QUFFakIsZUFBUyxRQUFRO0FBRWpCLGFBQU87O1FBR1QsV0FBZTs7OztBQ1pmOzs7OzttQ0FNQSxXQUFBOzs7ZUFBQTs7Ozs7QUFOQTtRQU1BLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQW1CLGdCQUFBLFFBQU87TUFDOUMsWUFBWSxVQUFTLFFBQVEsTUFBTSxpQkFBaUIsaUJBQWlCLHNCQUFzQjtBQUN6RixjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLGtCQUFrQjtBQUN2QixhQUFLLGtCQUFrQjtBQUN2QixhQUFLLHVCQUF1Qjs7TUFHOUIscUJBQXFCO0FBQ25CLGVBQU8sS0FBSzs7TUFHZCxxQkFBcUI7QUFDbkIsZUFBTyxLQUFLOztNQUdkLDBCQUEwQjtBQUN4QixlQUFPLEtBQUs7O1lBR1IsU0FBUyxVQUFTO0FBQ3RCLFlBQUksT0FBTzttQkFFQSxLQUFLLG9CQUFvQixNQUFNO0FBQ3hDLGVBQUssZ0JBQWdCLFNBQVM7bUJBQ3JCLEtBQUssb0JBQW9CLE1BQU07QUFDeEMsZUFBSyxnQkFBZ0IsU0FBUzttQkFDckIsS0FBSyx5QkFBeUIsTUFBTTtBQUM3QyxnQkFBTSxLQUFLLHFCQUFxQixTQUFTOzs7T0FJdEMsY0FqQ2EsSUFpQ2IsUUFBTyxTQWpDTTs7OztBQ050Qjs7Ozs7bUNBRUEsV0FBQTs7O2VBQXFCOzs7QUFBTiwwQkFBTTtNQUNuQixZQUFZLFNBQVM7QUFDbkIsYUFBSyxVQUFVOztNQUdqQixhQUFhO0FBQ1gsZUFBTyxLQUFLOzthQUdQLFlBQVksU0FBUztBQUMxQixjQUFNLFlBQVksSUFBSSxVQUFVO0FBRWhDLGVBQU87Ozs7OztBQ2RYOzs7Ozs7Ozs7Ozs7O1VBTWEsZUFBQTtlQUFBOztVQUhBLGFBQUE7ZUFBQTs7VUFEQSxZQUFBO2VBQUE7O1VBR0EsY0FBQTtlQUFBOztVQURBLGNBQUE7ZUFBQTs7O0FBRk4sUUFBTSxZQUFZO0FBQ2xCLFFBQU0sYUFBYTtBQUNuQixRQUFNLGNBQWM7QUFDcEIsUUFBTSxjQUFjO0FBQ3BCLFFBQU0sZUFBZTs7OztBQ041Qjs7Ozs7bUNBWUEsV0FBQTs7O2VBQUE7OztBQVZBLHlCQUFNO2FBQ0csY0FBYztBQUNuQixjQUFNLFlBQVcsSUFBSTtBQUVyQixlQUFPOzs7QUFJWCxRQUFNLFdBQVcsU0FBUztRQUUxQixXQUFlOzs7O0FDWmY7Ozs7Ozs7Ozs7Ozs7VUFPYSx1QkFBQTtlQUFBOztVQUNBLHVCQUFBO2VBQUE7O1VBSEEsZUFBQTtlQUFBOztVQURBLFFBQUE7ZUFBQTs7VUFFQSxlQUFBO2VBQUE7O1VBSkEsT0FBQTtlQUFBOztVQUNBLE9BQUE7ZUFBQTs7O0FBRE4sUUFBTSxPQUFPO0FBQ2IsUUFBTSxPQUFPO0FBQ2IsUUFBTSxRQUFRO0FBQ2QsUUFBTSxlQUFlO0FBQ3JCLFFBQU0sZUFBZTtBQUNyQixRQUFNLHVCQUF1QjtBQUM3QixRQUFNLHVCQUF1Qjs7OztBQ1JwQzs7Ozs7Ozs7Ozs7OztVQUlnQiwwQkFBQTtlQUFBOztVQU1BLDBCQUFBO2VBQUE7Ozs7QUFOVCxxQ0FBaUMsZUFBYTtBQUNuRCxZQUFNLFNBQVMsY0FBYyxRQUFRLFlBQVksV0FBQTtBQUVqRCxhQUFPOztBQUdGLHFDQUFpQyxRQUFNO0FBQzVDLFlBQU0sZ0JBQWdCLElBQUk7QUFFMUIsYUFBTzs7Ozs7QUNiVDs7Ozs7Ozs7Ozs7OztVQTZLZ0IsMkRBQUE7ZUFBQTs7VUExQkEsK0NBQUE7ZUFBQTs7VUE5RUEsaUNBQUE7ZUFBQTs7VUFpREEsOENBQUE7ZUFBQTs7VUE1QkEsb0NBQUE7ZUFBQTs7VUF6Q0EsNEJBQUE7ZUFBQTs7VUE3QkEseUJBQUE7ZUFBQTs7VUFRQSwwQkFBQTtlQUFBOztVQXVEQSxrQ0FBQTtlQUFBOztVQWVBLDBDQUFBO2VBQUE7O1VBaUVBLHVEQUFBO2VBQUE7O1VBbUNBLGlFQUFBO2VBQUE7O1VBdkZBLDJDQUFBO2VBQUE7O1VBNEJBLDhDQUFBO2VBQUE7O1VBeEdBLDJCQUFBO2VBQUE7O1VBb0JBLDRCQUFBO2VBQUE7O1VBaERBLHdCQUFBO2VBQUE7O1VBNkhBLDhDQUFBO2VBQUE7O1VBa0RBLDhEQUFBO2VBQUE7O1VBM0JBLGlEQUFBO2VBQUE7O1VBN0lBLHlCQUFBO2VBQUE7Ozs7Ozs7Ozs7O0FBUFQsbUNBQStCLE1BQUk7QUFDeEMsWUFBTSxhQUFhLEtBQUssYUFDbEIsZ0JBQWdCLE9BQU87QUFFN0IsYUFBTzs7QUFHRixvQ0FBZ0MsTUFBSTtBQUN6QyxZQUFNLGlCQUFpQjtBQUV2QixhQUFPOztBQUdGLG9DQUFnQyxNQUFNLFVBQU87QUFDbEQsWUFBTSxpQkFBa0IsU0FBUyxVQUFBLFVBQ04sV0FBQSxPQUNFLFNBQVEsYUFBYTtBQUVsRCxhQUFPOztBQUdGLHFDQUFpQyxPQUFPLFVBQU87QUFDcEQsWUFBTSxTQUFTLFNBQVEsY0FBYyxRQUMvQixpQkFBaUI7QUFFdkIsYUFBTzs7QUFHRixzQ0FBa0MsWUFBVTtBQUNqRCxVQUFJO0FBRUosaUJBQVcsUUFBUSxDQUFDLGFBQUE7QUFDbEIsWUFBSSxhQUFhLE1BQU07QUFDckIsZ0JBQU0saUJBQWlCLFNBQVM7QUFFaEMsdUJBQWE7OztBQUlqQixhQUFPOztBQUdGLHVDQUFtQyxTQUFPO0FBQy9DLFlBQU0sb0JBQW9CLEdBQUc7QUFFN0IsYUFBTzs7QUFHRix1Q0FBbUMsWUFBVTtBQUNsRCxZQUFNLGNBQWMsV0FBVyxPQUFPLENBQUMsY0FBYSxTQUFBO0FBQ2xELGNBQU0sYUFBYSxLQUFLO0FBRXhCLHVCQUFlLGlCQUFnQixPQUNmLGFBQ0MsR0FBRyxpQkFBZ0I7QUFFcEMsZUFBTztTQUNOO0FBRUgsYUFBTzs7QUFHRiw0Q0FBd0MsWUFBVTtBQUN2RCxVQUFJO0FBRUosaUJBQVcsUUFBUSxDQUFDLGFBQUE7QUFDbEIsWUFBSSxhQUFhLE1BQU07QUFDckIsZ0JBQU0saUJBQWlCLFNBQVM7QUFFaEMsNkJBQW1COzs7QUFJdkIsYUFBTzs7QUFHRiw2Q0FBeUMsZUFBYTtBQUMzRCxZQUFNLFNBQVMsSUFBQSxlQUFBLHlCQUF3QixnQkFDakMsaUJBQWlCO0FBRXZCLGFBQU87O0FBR0YsK0NBQTJDLE1BQU0sTUFBSTtBQUMxRCxZQUFNLGFBQWEsTUFDYixhQUFhLE1BQ2IscUJBQXFCLEdBQUcsY0FBYztBQUU1QyxhQUFPOztBQUdGLHFEQUFpRCxXQUFTO0FBQy9ELFlBQU0sT0FBTyxVQUFVLFdBQ2pCLFFBQVEsVUFBVSxZQUNsQixhQUFhLFVBQVUsaUJBQ3ZCLGtCQUFrQixVQUFVLHNCQUM1QixjQUFjLE1BQU0sYUFDcEIsbUJBQW1CLFdBQVcsYUFDOUIsd0JBQXdCLGdCQUFnQixhQUN4Qyw2QkFBNkIsR0FBRyxRQUFRLGVBQWdCLDJCQUEyQjtBQUV6RixhQUFPOztBQUdGLHNEQUFrRCxpQkFBZTtBQUN0RSxZQUFNLHdCQUF3QixnQkFBZ0IsYUFDeEMsb0JBQW9CLFNBQVM7QUFFbkMsYUFBTzs7QUFHRix5REFBcUQscUJBQW1CO0FBQzdFLFlBQU0sdUJBQXVCLG9CQUFvQixPQUFPLENBQUMsdUJBQXNCLGlCQUFBO0FBQzNFLGNBQU0scUJBQXFCLGFBQWE7QUFFeEMsZ0NBQXdCLDBCQUF5QixPQUN4QixxQkFDQyxHQUFHLDBCQUF5QjtBQUV0RCxlQUFPO1NBQ047QUFFTCxhQUFPOztBQUdGLHlEQUFxRCxNQUFNLFVBQVE7QUFDeEUsWUFBTSxpQkFBaUIsU0FBUyxhQUMxQiwyQkFBMkIsR0FBRyxRQUFRO0FBRTVDLGFBQU87O0FBR0YseURBQXFELFVBQVUsb0JBQWtCO0FBQ3RGLFlBQU0saUJBQWlCLFNBQVMsYUFDMUIsMkJBQTJCLG1CQUFtQixhQUM5QyxhQUFhLFFBQVEsbUJBQW1CO0FBRTlDLGFBQU87O0FBR0YsMERBQXNELFVBQVUsb0JBQWtCO0FBQ3ZGLFlBQU0saUJBQWlCLFNBQVMsYUFDMUIsMkJBQTJCLG1CQUFtQixhQUM5QyxjQUFjLFNBQVMsbUJBQW1CO0FBRWhELGFBQU87O0FBR0YsNERBQXdELG9CQUFrQjtBQUMvRSxZQUFNLFdBQVcsbUJBQW1CLGVBQzlCLGlCQUFpQixTQUFTLGFBQzFCLDJCQUEyQixHQUFHO0FBRXBDLGFBQU87O0FBR0Ysa0VBQThELE1BQU0sT0FBTyxZQUFZLGFBQVc7QUFDdkcsWUFBTSxhQUFhLE1BQ2IsY0FBYyxNQUFNLGFBQ3BCLG1CQUFtQixXQUFXLGFBQzlCLG9CQUFvQixZQUFZLGFBQ2hDLGtCQUFrQixHQUFHLGNBQWMsZUFBZSxxQkFBcUI7QUFFN0UsYUFBTzs7QUFHRixzRUFBa0UsTUFBTSxZQUFZLGFBQVc7QUFDcEcsWUFBTSxhQUFhLE1BQ2IsbUJBQW1CLFdBQVcsYUFDOUIsb0JBQW9CLFlBQVksYUFDaEMsMkJBQTJCLEdBQUcsZUFBZSxxQkFBcUI7QUFFeEUsYUFBTzs7QUFHRix5RUFBcUUsTUFBTSwwQkFBd0I7QUFDeEcsVUFBSSw0QkFBNEIseUJBQXlCLE9BQU8sQ0FBQyw0QkFBMkIsdUJBQUE7QUFDMUYsY0FBTSwyQkFBMkIsK0NBQStDO0FBRWhGLHFDQUE2QiwrQkFBOEIsT0FDekQsMkJBQ0EsR0FBRywrQkFBOEI7QUFFbkMsZUFBTztTQUNOO0FBRUgsa0NBQTRCLEdBQUcsUUFBUTtBQUV2QyxhQUFPOztBQUdGLDRFQUF3RSxVQUFVLG1CQUFtQixvQkFBa0I7QUFDNUgsWUFBTSxpQkFBaUIsU0FBUyxhQUMxQiwwQkFBMEIsa0JBQWtCLGFBQzVDLDJCQUEyQixtQkFBbUIsYUFDOUMsZUFBZSxVQUFVLG1CQUFtQiw2QkFBNkI7QUFFL0UsYUFBTzs7Ozs7QUM1TVQ7Ozs7Ozs7Ozs7Ozs7VUFvRUEsVUFBQTtlQUFBOztVQTlCZ0IsdUJBQUE7ZUFBQTs7VUEvQkEsb0JBQUE7ZUFBQTs7VUFnQkEscUJBQUE7ZUFBQTs7VUE4QkEsNkJBQUE7ZUFBQTs7Ozs7Ozs7Ozs7QUE5Q1QsK0JBQTJCLE1BQU0sVUFBTztBQUM3QyxZQUFNLENBQUUsYUFBYyxVQUFBLFNBQ2hCLGtCQUFrQixJQUFBLFFBQUEsd0JBQXVCLE1BQU0sV0FDL0MsU0FBUyxpQkFDVCxPQUFPLE9BQUEsV0FDUCxRQUFRO0FBRWQsYUFBTztBQUVQLGlCQUFVO0FBRVYsWUFBTSxZQUFZLElBQUksVUFBVSxVQUFTLFFBQVEsTUFBTSxNQUFNO0FBRTdELGFBQU87O0FBR0YsZ0NBQTRCLE9BQU8sVUFBTztBQUMvQyxZQUFNLENBQUUsYUFBYyxVQUFBLFNBQ2hCLGtCQUFrQixJQUFBLFFBQUEseUJBQXdCLE9BQU8sV0FDakQsU0FBUyxpQkFDVCxPQUFPLE9BQUEsWUFDUCxRQUFRLE9BQ1IsT0FBTztBQUViLGlCQUFVO0FBRVYsWUFBTSxZQUFZLElBQUksVUFBVSxVQUFTLFFBQVEsTUFBTSxNQUFNO0FBRTdELGFBQU87O0FBR0Ysa0NBQThCLFNBQVMsVUFBTztBQUNuRCxZQUFNLENBQUUsYUFBYyxVQUFBLFNBQ2hCLGtCQUFrQixJQUFBLFFBQUEsMkJBQTBCLFVBQzVDLFNBQVMsaUJBQ1QsT0FBTyxPQUFBLGNBQ1AsUUFBUSxTQUNSLE9BQU87QUFFYixpQkFBVTtBQUVWLFlBQU0sWUFBWSxJQUFJLFVBQVUsVUFBUyxRQUFRLE1BQU0sTUFBTTtBQUU3RCxhQUFPOztBQUdGLHdDQUFvQyxlQUFlLFVBQU87QUFDL0QsWUFBTSxDQUFFLGFBQWMsVUFBQSxTQUNoQixrQkFBa0IsSUFBQSxRQUFBLGlDQUFnQyxnQkFDbEQsU0FBUyxpQkFDVCxPQUFPLE9BQUEsYUFDUCxRQUFRLGVBQ1IsT0FBTztBQUViLGlCQUFVO0FBRVYsWUFBTSxZQUFZLElBQUksVUFBVSxVQUFTLFFBQVEsTUFBTSxNQUFNO0FBRTdELGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBOzs7OztBQ3hFRjs7Ozs7Ozs7Ozs7OztVQTBFQSxVQUFBO2VBQUE7O1VBdkNnQixrQkFBQTtlQUFBOztVQTdCQSxlQUFBO2VBQUE7O1VBZUEsZ0JBQUE7ZUFBQTs7VUEwQ0Esb0JBQUE7ZUFBQTs7VUFkQSx3QkFBQTtlQUFBOzs7Ozs7Ozs7O0FBM0NULDBCQUFzQixNQUFNLFVBQU87QUFDeEMsWUFBTSxDQUFFLFFBQVMsVUFBQSxTQUNYLFdBQVcsTUFDWCxZQUFZLElBQUEsV0FBQSxtQkFBa0IsTUFBTSxXQUNwQyxTQUFTLFVBQVU7QUFFekIsYUFBTztBQUVQLGlCQUFVO0FBRVYsWUFBTSxPQUFPLElBQUksS0FBSyxVQUFTLFFBQVEsTUFBTSxVQUFVO0FBRXZELGFBQU87O0FBR0YsMkJBQXVCLE9BQU8sVUFBTztBQUMxQyxZQUFNLENBQUUsUUFBUyxVQUFBLFNBQ1gsV0FBVyxNQUNYLFlBQVksSUFBQSxXQUFBLG9CQUFtQixPQUFPLFdBQ3RDLFNBQVMsVUFBVSxhQUNuQixPQUFPO0FBRWIsaUJBQVU7QUFFVixZQUFNLE9BQU8sSUFBSSxLQUFLLFVBQVMsUUFBUSxNQUFNLFVBQVU7QUFFdkQsYUFBTzs7QUFHRiw2QkFBeUIsU0FBUyxVQUFPO0FBQzlDLFlBQU0sQ0FBRSxRQUFTLFVBQUEsU0FDWCxXQUFXLE1BQ1gsWUFBWSxJQUFBLFdBQUEsc0JBQXFCLFNBQVMsV0FDMUMsU0FBUyxVQUFVLGFBQ25CLE9BQU87QUFFYixpQkFBVTtBQUVWLFlBQU0sT0FBTyxJQUFJLEtBQUssVUFBUyxRQUFRLE1BQU0sVUFBVTtBQUV2RCxhQUFPOztBQUdGLG1DQUErQixlQUFlLFVBQU87QUFDMUQsWUFBTSxDQUFFLFFBQVMsVUFBQSxTQUNYLFdBQVcsTUFDWCxZQUFZLElBQUEsV0FBQSw0QkFBMkIsZUFBZSxXQUN0RCxTQUFTLFVBQVUsYUFDbkIsT0FBTztBQUViLGlCQUFVO0FBRVYsWUFBTSxPQUFPLElBQUksS0FBSyxVQUFTLFFBQVEsTUFBTSxVQUFVO0FBRXZELGFBQU87O0FBR0YsK0JBQTJCLFdBQVM7QUFDekMsWUFBTSxDQUFFLFFBQVMsVUFBQSxTQUNYLFdBQVUsTUFDVixTQUFTLFVBQVUsYUFDbkIsT0FBTyxNQUNQLFdBQVcsTUFDWCxPQUFPLElBQUksS0FBSyxVQUFTLFFBQVEsTUFBTSxVQUFVO0FBRXZELGFBQU87O1FBR1QsV0FBZTtNQUNiO01BQ0E7TUFDQTtNQUNBO01BQ0E7Ozs7O0FDL0VGOzs7OzttQ0FhQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZBLFFBQU0sQ0FBRSxhQUFjLGdCQUFBO0FBWHRCO1FBYUEsV0FBZSxJQUFBLFVBQUEsUUFBTyxvQkFBbUIsZ0JBQUEsUUFBTztNQUM5QyxZQUFZLFVBQVMsUUFBUSxNQUFNLFVBQVUsb0JBQW9CO0FBQy9ELGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssV0FBVztBQUNoQixhQUFLLHFCQUFxQjs7TUFHNUIsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCx3QkFBd0I7QUFDdEIsZUFBTyxLQUFLOztZQUdSLFNBQVMsVUFBUztBQUN0QixZQUFJO0FBRUosY0FBTSxLQUFLLE1BQU07QUFFakIsY0FBTSxhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxtQkFBbUI7QUFFakMsZUFBTyxLQUFLLFNBQVMsU0FBUztBQUU5QixjQUFNLFdBQVcsS0FBSztBQUV0QixZQUFJLGFBQWEsT0FBQSxZQUFZO0FBQzNCLGdCQUFNLGNBQWEsS0FBSyxhQUNsQixVQUFVLFFBQVEsd0JBQXVCLDZCQUE2QixPQUFBLGdCQUN0RSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0saUJBQWlCLEtBQUsscUJBQ3RCLFFBQVEsZ0JBQ1IsVUFBVSxNQUFNLFVBQVUsT0FBTyxPQUFPLFNBQUE7QUFDdEMsY0FBSTtBQUVKLGtCQUFPLElBQUEsTUFBQSxjQUFhLE1BQU07QUFFMUIsZ0JBQU0sQ0FBRSxTQUFVLFVBQUEsU0FDWixRQUFRLE1BQU0sU0FBUyxPQUFNO0FBRW5DLGtCQUFPLE1BQU0sS0FBSyxtQkFBbUIsS0FBSyxPQUFPO0FBRWpELGdCQUFNLFlBQVcsTUFBSztBQUV0QixjQUFJLGNBQWEsT0FBQSxjQUFjO0FBQzdCLGtCQUFNLGNBQWEsTUFBSyxhQUNsQixVQUFVLFFBQVEsZ0NBQStCLHlDQUF3QyxPQUFBLGtCQUN6RixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGtCQUFNOztBQUdSLGdCQUFNLGtCQUFpQixNQUFLLHFCQUN0QixXQUFVO0FBRWhCLGlCQUFPOztBQUdmLGVBQU8sSUFBQSxNQUFBLGlCQUFnQixTQUFTO0FBRWhDLGNBQU0sYUFBYSxLQUFLO0FBRXhCLGlCQUFRLE1BQU0scUJBQXFCLHdCQUF3QjtBQUUzRCxlQUFPOztPQUdGLGNBMUVhLElBMEViLFFBQU8sU0ExRU07Ozs7QUNidEI7Ozs7O21DQU9BLFdBQUE7OztlQUFBOzs7Ozs7QUFQQTtRQU9BLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQW1CLGdCQUFBLFFBQU87TUFDOUMsWUFBWSxVQUFTLFFBQVEsTUFBTSxVQUFVLFdBQVcsYUFBYSxhQUFhLGVBQWUsZ0JBQWdCO0FBQy9HLGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssV0FBVztBQUNoQixhQUFLLFlBQVk7QUFDakIsYUFBSyxjQUFjO0FBQ25CLGFBQUssY0FBYztBQUNuQixhQUFLLGdCQUFnQjtBQUNyQixhQUFLLGlCQUFpQjs7TUFHeEIsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLGlCQUFpQjtBQUNmLGVBQU8sS0FBSzs7TUFHZCxpQkFBaUI7QUFDZixlQUFPLEtBQUs7O01BR2Qsa0JBQWtCO0FBQ2hCLGVBQU8sS0FBSzs7TUFHZCxvQkFBb0I7QUFDbEIsZUFBTyxLQUFLOztNQUdkLG9CQUFvQjtBQUNsQixjQUFNLGlCQUFpQixLQUFLLFVBQVU7QUFFdEMsZUFBTzs7TUFHVCxVQUFVO0FBQ1IsWUFBSTtBQUVKLFlBQUksT0FBTzttQkFFQSxLQUFLLGFBQWEsTUFBTTtBQUNqQyxpQkFBTyxLQUFLLFNBQVM7bUJBQ1osS0FBSyxjQUFjLE1BQU07QUFDbEMsaUJBQU8sS0FBSyxVQUFVO21CQUNiLEtBQUssZ0JBQWdCLE1BQU07QUFDcEMsaUJBQU8sS0FBSyxZQUFZO21CQUNmLEtBQUssZ0JBQWdCLE1BQU07QUFDcEMsaUJBQU8sS0FBSyxZQUFZO21CQUNmLEtBQUssa0JBQWtCLE1BQU07QUFDdEMsaUJBQU8sS0FBSyxjQUFjO21CQUNqQixLQUFLLG1CQUFtQixNQUFNO0FBQ3ZDLGlCQUFPLEtBQUssZUFBZTs7QUFHN0IsZUFBTzs7TUFHVCxZQUFZO0FBQ1YsY0FBTSxPQUFPLEtBQUssV0FDWixVQUFXLFNBQVMsT0FBQTtBQUUxQixlQUFPOztNQUdULFNBQVMsVUFBUztBQUNoQixZQUFJO0FBRUosWUFBSSxPQUFPO21CQUVBLEtBQUssYUFBYSxNQUFNO0FBQ2pDLGlCQUFPLEtBQUssU0FBUyxTQUFTO21CQUNyQixLQUFLLGNBQWMsTUFBTTtBQUNsQyxpQkFBTyxLQUFLLFVBQVUsU0FBUzttQkFDdEIsS0FBSyxnQkFBZ0IsTUFBTTtBQUNwQyxpQkFBTyxLQUFLLFlBQVksU0FBUzttQkFDeEIsS0FBSyxnQkFBZ0IsTUFBTTtBQUNwQyxpQkFBTyxLQUFLLFlBQVksU0FBUzttQkFDeEIsS0FBSyxrQkFBa0IsTUFBTTtBQUN0QyxpQkFBTyxLQUFLLGNBQWMsU0FBUzttQkFDMUIsS0FBSyxtQkFBbUIsTUFBTTtBQUN2QyxpQkFBTyxLQUFLLGVBQWUsU0FBUzs7QUFHdEMsZUFBTzs7TUFHVCxVQUFVLE1BQU07QUFDZCxZQUFJLFVBQVU7QUFFZCxZQUFJLE9BQU87bUJBRUEsS0FBSyxhQUFhLE1BQU07QUFDakMsZ0JBQU0sV0FBVyxLQUFLO0FBRXRCLGNBQUksYUFBYSxNQUFNO0FBQ3JCLHNCQUFVLEtBQUssU0FBUyxVQUFVOzttQkFFM0IsS0FBSyxjQUFjLE1BQU07QUFDbEMsZ0JBQU0sWUFBWSxLQUFLO0FBRXZCLGNBQUksY0FBYyxNQUFNO0FBQ3RCLHNCQUFVLEtBQUssVUFBVSxVQUFVOzs7QUFJdkMsZUFBTzs7YUFLRixjQUFjLFdBQVcsVUFBUztBQUN2QyxjQUFNLGtCQUFrQixVQUFVLGFBQzVCLFNBQVMsaUJBQ1QsT0FBTyxNQUNQLFdBQVcsTUFDWCxjQUFjLE1BQ2QsY0FBYyxNQUNkLGdCQUFnQixNQUNoQixpQkFBaUI7QUFFdkIsbUJBQVU7QUFFVixjQUFNLE9BQU8sSUFBSSxHQUFLLFVBQVMsUUFBUSxNQUFNLFVBQVUsV0FBVyxhQUFhLGFBQWEsZUFBZTtBQUUzRyxlQUFPOztPQWhCRixjQW5IYSxJQW1IYixRQUFPLFNBbkhNOzs7O0FDUHRCOzs7OzttQ0FPQSxXQUFBOzs7ZUFBQTs7Ozs7O0FBUEE7UUFPQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUFvQixnQkFBQSxRQUFPO01BQy9DLFlBQVksVUFBUyxRQUFRLE1BQU0sT0FBTztBQUN4QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLFFBQVE7O01BR2YsV0FBVztBQUNULGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsY0FBTSxTQUFTLEtBQUssTUFBTTtBQUUxQixlQUFPOztNQUdULFFBQVEsT0FBTztBQUNiLGNBQU0sT0FBTyxLQUFLLE1BQU0sVUFBVTtBQUVsQyxlQUFPOztNQUdULFFBQVEsTUFBTTtBQUNaLGFBQUssTUFBTSxLQUFLOztNQUdsQixRQUFRLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxJQUFJOztNQUUxQyxZQUFZLFVBQVU7QUFBRSxhQUFLLE1BQU0sUUFBUTs7TUFFM0MsU0FBUyxVQUFTO0FBQ2hCLGNBQU0sYUFBYSxLQUFLLFFBQVEsQ0FBQyxTQUFBO0FBQ3pCLGlCQUFPLEtBQUssU0FBUztBQUVyQixpQkFBTztZQUVULGNBQWMsSUFBQSxRQUFBLDJCQUEwQixZQUFZLFdBQ3BELFNBQVMsYUFDVCxRQUFRLFlBQ1IsT0FBTztBQUViLG1CQUFVO0FBRVYsY0FBTSxRQUFRLElBQUksR0FBTSxVQUFTLFFBQVEsTUFBTTtBQUUvQyxlQUFPOzthQUtGLFNBQVMsTUFBTSxVQUFTO0FBQzdCLGNBQU0sYUFBYTtVQUNYO1dBRUYsY0FBYyxJQUFBLFFBQUEsMkJBQTBCLFlBQVksV0FDcEQsU0FBUyxhQUNULFFBQVEsWUFDUixPQUFPO0FBRWIsbUJBQVU7QUFFVixjQUFNLFFBQVEsSUFBSSxHQUFNLFVBQVMsUUFBUSxNQUFNO0FBRS9DLGVBQU87O09BZkYsY0FqRGEsSUFpRGIsUUFBTyxVQWpETTs7OztBQ1B0Qjs7Ozs7bUNBTUEsV0FBQTs7O2VBQUE7Ozs7O0FBTkE7UUFNQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUFvQixnQkFBQSxRQUFPO01BQy9DLFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTTtBQUN2QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxxQkFBcUIsZUFBZTtBQUNsQyxjQUFNLHdCQUF5QixLQUFLLFNBQVM7QUFFN0MsZUFBTzs7T0FHRixjQWpCYSxJQWlCYixRQUFPLFVBakJNOzs7O0FDTnRCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBQTs7Ozs7QUFOQTtRQU1BLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQW9CLGdCQUFBLFFBQU87TUFDL0MsWUFBWSxVQUFVLFFBQVEsTUFBTTtBQUNsQyxjQUFNLFNBQVMsUUFBUTs7TUFHekIsT0FBTyxVQUFTO0FBQ2QsY0FBTSxXQUFXLE9BQ1gsY0FBYyxLQUFLO0FBRXpCLGlCQUFRLFFBQVEsUUFBUTtBQUV4QixlQUFPOztPQUdGLGNBZGEsSUFjYixRQUFPLFVBZE07Ozs7QUNOdEI7Ozs7O21DQWFBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRkEsUUFBTSxDQUFFLGNBQWUsZ0JBQUE7QUFYdkI7UUFhQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUFvQixnQkFBQSxRQUFPO01BQy9DLFlBQVksVUFBUyxRQUFRLE1BQU0sVUFBVSxvQkFBb0I7QUFDL0QsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxTQUFTO0FBQ2QsYUFBSyxXQUFXO0FBQ2hCLGFBQUsscUJBQXFCOztNQUc1QixjQUFjO0FBQ1osZUFBTyxLQUFLOztNQUdkLHdCQUF3QjtBQUN0QixlQUFPLEtBQUs7O1lBR1IsU0FBUyxVQUFTO0FBQ3RCLFlBQUk7QUFFSixjQUFNLEtBQUssTUFBTTtBQUVqQixjQUFNLGNBQWMsS0FBSztBQUV6QixpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxlQUFPLEtBQUssU0FBUyxTQUFTO0FBRTlCLGNBQU0sV0FBVyxLQUFLO0FBRXRCLFlBQUksYUFBYSxPQUFBLFlBQVk7QUFDM0IsZ0JBQU0sY0FBYSxLQUFLLGFBQ2xCLFVBQVUsUUFBUSx3QkFBdUIsNkJBQTZCLE9BQUEsZ0JBQ3RFLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsY0FBTSxRQUFRLEtBQUssWUFDYixVQUFVLE1BQU0sV0FBVyxPQUFPLE9BQU8sU0FBQTtBQUN2QyxjQUFJO0FBRUosZ0JBQU0sQ0FBRSxTQUFVLFVBQUE7QUFFbEIsa0JBQU8sSUFBQSxNQUFBLGNBQWEsTUFBTTtBQUUxQixnQkFBTSxRQUFRLE1BQU0sU0FBUyxPQUFNO0FBRW5DLGtCQUFPLE1BQU0sS0FBSyxtQkFBbUIsS0FBSyxPQUFPO0FBRWpELGdCQUFNLFlBQVcsTUFBSztBQUV0QixjQUFJLGNBQWEsT0FBQSxjQUFjO0FBQzdCLGtCQUFNLGNBQWEsTUFBSyxhQUNsQixVQUFVLFFBQVEsZ0NBQStCLHlDQUF3QyxPQUFBLGtCQUN6RixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGtCQUFNOztBQUdSLGdCQUFNLFdBQVUsTUFBSztBQUVyQixpQkFBTzs7QUFHZixlQUFPLElBQUEsTUFBQSxpQkFBZ0IsU0FBUztBQUVoQyxjQUFNLGFBQWEsS0FBSztBQUV4QixpQkFBUSxNQUFNLHFCQUFxQiwwQkFBMEI7QUFFN0QsZUFBTzs7T0FHRixjQTFFYSxJQTBFYixRQUFPLFVBMUVNOzs7O0FDYnRCOzs7OzttQ0FhQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZBLFFBQU0sQ0FBRSxlQUFnQixnQkFBQTtBQVh4QjtRQWFBLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQXFCLGdCQUFBLFFBQU87TUFDaEQsWUFBWSxVQUFTLFFBQVEsTUFBTSxVQUFVLG1CQUFtQixvQkFBb0I7QUFDbEYsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssb0JBQW9CO0FBQ3pCLGFBQUsscUJBQXFCOztNQUc1QixjQUFjO0FBQ1osZUFBTyxLQUFLOztNQUdkLHVCQUF1QjtBQUNyQixlQUFPLEtBQUs7O01BR2Qsd0JBQXdCO0FBQ3RCLGVBQU8sS0FBSzs7WUFHUixTQUFTLFVBQVM7QUFDdEIsWUFBSTtBQUVKLGNBQU0sS0FBSyxNQUFNO0FBRWpCLGNBQU0sZUFBZSxLQUFLO0FBRTFCLGlCQUFRLE1BQU0sbUJBQW1CO0FBRWpDLGVBQU8sS0FBSyxTQUFTLFNBQVM7QUFFOUIsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxhQUFhLE9BQUEsWUFBWTtBQUMzQixnQkFBTSxjQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLHdCQUF1Qiw2QkFBNkIsT0FBQSxnQkFDdEUsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLFFBQVEsS0FBSyxZQUNiLG9CQUFvQixNQUFNLEtBQUssa0JBQWtCLFNBQVM7QUFFaEUsZUFBTyxNQUFNLFlBQVksT0FBTyxPQUFPLG1CQUFtQixTQUFBO0FBQ3hELGNBQUk7QUFFSixnQkFBTSxDQUFFLFNBQVUsVUFBQTtBQUVsQixrQkFBTztBQUVQLGdCQUFNLFFBQVEsTUFBTSxTQUFTLE9BQU07QUFFbkMsa0JBQU8sSUFBQSxNQUFBLGNBQWEsTUFBTTtBQUUxQixnQkFBTSxRQUFRO0FBRWQsa0JBQU8sTUFBTSxLQUFLLG1CQUFtQixLQUFLLE9BQU87QUFFakQsaUJBQU87V0FDTjtBQUVILGNBQU0sYUFBYSxLQUFLO0FBRXhCLGlCQUFRLE1BQU0scUJBQXFCLDRCQUE0QjtBQUUvRCxlQUFPOztPQUdGLGNBdEVhLElBc0ViLFFBQU8sV0F0RU07Ozs7QUNidEI7Ozs7O21DQVNBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7QUFUQTtRQVNBLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQXNCLGdCQUFBLFFBQU87TUFDakQsWUFBWSxVQUFTLFFBQVEsTUFBTSxNQUFNLGNBQWMsZ0JBQWdCO0FBQ3JFLGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssT0FBTztBQUNaLGFBQUssZUFBZTtBQUNwQixhQUFLLGlCQUFpQjs7TUFHeEIsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxhQUFhO0FBQ1gsZUFBTyxLQUFLOztNQUdkLGVBQWU7QUFDYixlQUFPLEtBQUs7O1lBR1IsU0FBUyxVQUFTO0FBQ3RCLFlBQUk7QUFFSixjQUFNLGdCQUFnQixLQUFLO0FBRTNCLGlCQUFRLE1BQU0sbUJBQW1CO0FBRWpDLGVBQU8sS0FBSyxLQUFLLFNBQVM7QUFFMUIsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxhQUFhLE9BQUEsY0FBYztBQUM3QixnQkFBTSxjQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLGdDQUErQix3Q0FBd0MsT0FBQSxrQkFDekYsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLGlCQUFpQixLQUFLLHFCQUN0QixVQUFVO0FBRWhCLGVBQU8sVUFDRyxNQUFNLEtBQUssYUFBYSxTQUFTLFlBQy9CLE1BQU0sS0FBSyxlQUFlLFNBQVM7QUFFL0MsY0FBTSxhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxxQkFBcUIsOEJBQThCO0FBRWpFLGVBQU87O09BR0YsY0F0RGEsSUFzRGIsUUFBTyxZQXRETTs7OztBQ1R0Qjs7Ozs7bUNBU0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7OztBQVRBO1FBU0EsV0FBZSxJQUFBLFVBQUEsUUFBTyxvQkFBdUIsZ0JBQUEsUUFBTztNQUNsRCxZQUFZLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTSxNQUFNO0FBQ25ELGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssT0FBTztBQUNaLGFBQUssT0FBTztBQUNaLGFBQUssT0FBTzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxvQkFBb0IsY0FBYztBQUNoQyxjQUFNLHlCQUEwQixLQUFLLFNBQVM7QUFFOUMsZUFBTzs7TUFHVCxTQUFTLFVBQVM7QUFDaEIsY0FBTSxpQkFBaUIsS0FBSztBQUU1QixpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxjQUFNLFNBQVMsTUFDVCxlQUFlLEtBQUssTUFDcEIsa0JBQWtCLFNBQVEsZ0NBQWdDLGNBQWM7QUFFOUUsWUFBSSxDQUFDLGlCQUFpQjtBQUNwQixnQkFBTSxVQUFVLFFBQVEsNkNBQ2xCLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsY0FBTSxXQUFXLFNBQVEsMkJBQTJCLGVBQzlDLE9BQU8sU0FBUyxXQUNoQixhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxxQkFBcUIsb0NBQW9DO0FBRXZFLGVBQU87O01BR1QsT0FBTyxNQUFNLFVBQVM7QUFDcEIsY0FBTSxTQUFTLE9BQ1QsYUFBYSxLQUFLLGFBQ2xCLGVBQWUsS0FBSyxNQUNwQixpQkFBaUIsS0FBSyxhQUN0QixrQkFBa0IsU0FBUSxnQ0FBZ0MsY0FBYztBQUU5RSxpQkFBUSxNQUFNLGtCQUFrQiw0QkFBNEI7QUFFNUQsWUFBSSxpQkFBaUI7QUFDbkIsZ0JBQU0sVUFBVSxRQUFRLGdEQUNsQixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0sV0FBVyxLQUFLLFdBQ2hCLGVBQWUsS0FBSztBQUUxQixZQUFJLGFBQWEsY0FBYztBQUM3QixnQkFBTSxVQUFVLFFBQVEsOEJBQThCLHNEQUFzRCxvQkFDdEcsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixhQUFLLE9BQU87QUFFWixjQUFNLFdBQVc7QUFFakIsaUJBQVEsWUFBWTtBQUVwQixpQkFBUSxNQUFNLG9CQUFvQiw0QkFBNEI7O2FBS3pELGNBQWMsV0FBVyxVQUFTO0FBQ3ZDLGNBQU0sT0FBTyxVQUFVLFdBQ2pCLE9BQU8sVUFBVSxXQUNqQixPQUFPLE1BQ1AsaUJBQWlCLElBQUEsUUFBQSx3QkFBdUIsT0FDeEMsU0FBUyxnQkFDVCxPQUFPO0FBRWIsbUJBQVU7QUFFVixjQUFNLFdBQVcsSUFBSSxHQUFTLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUVqRSxlQUFPOzthQUdGLG1CQUFtQixnQkFBZ0IsVUFBUztBQUNqRCxjQUFNLGNBQWMsZUFBZSxrQkFDN0IsT0FBTyxlQUFlLFdBQ3RCLE9BQU8sYUFDUCxPQUFPLE1BQ1AsaUJBQWlCLElBQUEsUUFBQSx3QkFBdUIsT0FDeEMsU0FBUyxnQkFDVCxPQUFPO0FBRWIsbUJBQVU7QUFFVixjQUFNLFdBQVcsSUFBSSxHQUFTLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUVqRSxlQUFPOzthQUdGLHFCQUFxQixNQUFNLFdBQVcsVUFBUztBQUNwRCxjQUFNLE9BQU8sVUFBVSxXQUNqQixPQUFPLFVBQVUsV0FDakIsaUJBQWlCLElBQUEsUUFBQSx3QkFBdUIsT0FDeEMsU0FBUyxnQkFDVCxPQUFPO0FBRWIsbUJBQVU7QUFFVixjQUFNLFdBQVcsSUFBSSxHQUFTLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUVqRSxlQUFPOztPQTVDRixjQXZGYSxJQXVGYixRQUFPLGFBdkZNOzs7O0FDVHRCOzs7OzttQ0FhQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZBLFFBQU0sQ0FBRSxTQUFVLFdBQUE7QUFYbEI7UUFhQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUF3QixnQkFBQSxRQUFPO01BQ25ELFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTSxPQUFPO0FBQzlDLGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssT0FBTztBQUNaLGFBQUssUUFBUTs7TUFHZixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsU0FBUyxVQUFTO0FBQ2hCLGNBQU0sQ0FBRSxRQUFTLFVBQUEsU0FDWCxZQUFZLE1BQ1osT0FBTyxLQUFLLGNBQWMsV0FBVztBQUUzQyxlQUFPOztNQUdULFVBQVUsV0FBVztBQUNuQixZQUFJLFVBQVU7QUFFZCxjQUFNLE9BQU8sVUFBVTtBQUV2QixZQUFJLEtBQUssU0FBUyxNQUFNO0FBQ3RCLGdCQUFNLFFBQVEsVUFBVTtBQUV4QixrQkFBUTtpQkFDRCxPQUFBLFdBQVc7QUFDZCxvQkFBTSxRQUFRLEtBQUssT0FDYixRQUFRLE9BQ1IsY0FBYyxVQUFVLE9BQU87QUFFckMsa0JBQUksYUFBYTtBQUNmLDBCQUFVOztBQUdaOztpQkFHRyxPQUFBLFlBQVk7QUFDZixvQkFBTSxTQUFTLEtBQUssT0FDZCxTQUFTLE9BQ1QsYUFBYSxXQUFXLFFBQVE7QUFFdEMsa0JBQUksWUFBWTtBQUNkLDBCQUFVOztBQUdaOztpQkFHRyxPQUFBLGFBQWE7QUFDaEIsb0JBQU0saUJBQWlCLEtBQUssT0FDdEIsaUJBQWlCO0FBRXZCLGtCQUFJLG1CQUFtQixnQkFBZ0I7QUFDckMsMEJBQVU7O0FBR1o7O2lCQUdHLE9BQUEsYUFBYTtBQUNoQixvQkFBTSxVQUFVLEtBQUssT0FDZixVQUFVO0FBRWhCLGtCQUFJLFlBQVksU0FBUztBQUN2QiwwQkFBVTs7QUFHWjs7aUJBR0csT0FBQSxjQUFjO0FBQ2pCLG9CQUFNLFdBQVcsS0FBSyxPQUNoQixXQUFXO0FBRWpCLGtCQUFJLGFBQWEsVUFBVTtBQUN6QiwwQkFBVTs7QUFHWjs7OztBQUtOLGVBQU87O09BR0YsY0EvRmEsSUErRmIsUUFBTyxjQS9GTTtBQWtHdEIsdUJBQW1CLE9BQU8sT0FBSztBQUM3QixVQUFJO0FBRUosVUFBSyxVQUFVLFVBQUEsV0FBYyxVQUFVLFVBQUEsU0FBVztBQUNoRCxzQkFBZSxVQUFVO2lCQUNoQixVQUFVLFVBQUEsU0FBVTtBQUM3QixzQkFBYztpQkFDTCxVQUFVLFVBQUEsU0FBVTtBQUM3QixzQkFBYzthQUNUO0FBQ0wsY0FBTSxvQkFBb0IsTUFBTSxNQUFNO0FBRXRDLHNCQUFjOztBQUdoQixhQUFPOztBQUdULHdCQUFvQixRQUFRLFFBQU07QUFDaEMsWUFBTSxhQUFhLE1BQU0sUUFBUSxRQUFRLENBQUMsT0FBTyxVQUFBO0FBQy9DLGNBQU0sY0FBYyxVQUFVLE9BQU87QUFFckMsWUFBSSxhQUFhO0FBQ2YsaUJBQU87OztBQUlYLGFBQU87Ozs7O0FDMUlUOzs7OzttQ0FNQSxXQUFBOzs7ZUFBQTs7Ozs7QUFOQTtRQU1BLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQXdCLGdCQUFBLFFBQU87TUFDbkQsWUFBWSxVQUFTLFFBQVEsTUFBTSxNQUFNO0FBQ3ZDLGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssT0FBTzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLG1CQUFtQjtBQUNqQixjQUFNLGdCQUFnQixLQUFLO0FBRTNCLGVBQU87O09BR0YsY0FqQmEsSUFpQmIsUUFBTyxjQWpCTTs7OztBQ050Qjs7Ozs7Ozs7Ozs7OztVQVVBLFVBQUE7ZUFBQTs7VUFvRWdCLGtDQUFBO2VBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTlFaEI7UUFVQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUF3QixnQkFBQSxRQUFPO01BQ25ELFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTSxPQUFPLFlBQVksYUFBYTtBQUN2RSxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87QUFDWixhQUFLLFFBQVE7QUFDYixhQUFLLGFBQWE7QUFDbEIsYUFBSyxjQUFjOztNQUdyQixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLOztNQUdkLGlCQUFpQjtBQUNmLGVBQU8sS0FBSzs7TUFHZCxZQUFZO0FBQ1YsY0FBTSxrQkFBbUIsS0FBSyxTQUFTLE9BQUEsY0FDakMsVUFBVTtBQUVoQixlQUFPOztNQUdULFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTTs7TUFFOUIscUJBQXFCO0FBQUUsZUFBTyxLQUFLLFlBQVk7O01BRS9DLHFCQUFxQixlQUFlO0FBQUUsZUFBTyxLQUFLLE1BQU0scUJBQXFCOztZQUV2RSxLQUFLLE9BQU8sVUFBUztBQUN6QixjQUFNLEtBQUssTUFBTTtBQUVqQixjQUFNLGtCQUFrQixLQUFLO0FBRTdCLGlCQUFRLE1BQU0sZ0JBQWdCO0FBRTlCLGFBQUssV0FBVyxhQUFhLE9BQU87QUFFcEMsY0FBTSxZQUFZLGdDQUFnQyxPQUFPLEtBQUssWUFBWSxXQUNwRSxPQUFPLE1BQU0sS0FBSyxZQUFZLFNBQVMsV0FBVyxXQUNsRCxXQUFXLEtBQUs7QUFFdEIsWUFBSSxLQUFLLFNBQVMsVUFBVTtBQUMxQixnQkFBTSxhQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLHVCQUF1Qix1Q0FBdUMsaUNBQWlDLEtBQUssZUFDdEgsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixpQkFBUSxNQUFNLGtCQUFrQjtBQUVoQyxlQUFPOztPQUdGLGNBakVhLElBaUViLFFBQU8sY0FqRU07QUFvRWYsNkNBQXlDLE9BQU8sWUFBWSxVQUFPO0FBQ3hFLFlBQU0sWUFBWTtBQUVsQixZQUFNLFlBQVksQ0FBQyxNQUFNLFVBQUE7QUFDdkIsY0FBTSxZQUFZLFdBQVcsYUFBYTtBQUUxQyxZQUFJLGNBQWMsTUFBTTtBQUN0QixnQkFBTSxDQUFFLFlBQWEsVUFBQSxTQUNmLFdBQVcsU0FBUyxxQkFBcUIsTUFBTSxXQUFXO0FBRWhFLG9CQUFVLEtBQUs7OztBQUluQixhQUFPOzs7OztBQzVGVDs7Ozs7bUNBYUEsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7Ozs7O0FBRkEsUUFBTSxDQUFFLGlCQUFVLFdBQUE7QUFYbEI7UUFhQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUF3QixnQkFBQSxRQUFPO01BQ25ELFlBQVksVUFBUyxRQUFRLE1BQU0sVUFBVSxPQUFPO0FBQ2xELGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssV0FBVztBQUNoQixhQUFLLFFBQVE7O01BR2YsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFNBQVMsVUFBUztBQUNoQixZQUFJO0FBRUosY0FBTSxrQkFBa0IsS0FBSztBQUU3QixpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxZQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLGdCQUFNLFVBQVUsd0JBQXdCLG9FQUNsQyxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGVBQU8sS0FBSyxTQUFTLFNBQVM7QUFFOUIsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxhQUFhLE9BQUEsV0FBVztBQUMxQixnQkFBTSxjQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLHdCQUF1Qiw2QkFBNkIsT0FBQSxlQUN0RSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLFlBQUk7QUFFSixjQUFNLGlCQUFpQixLQUFLO0FBRTVCLGVBQU87QUFFUCxZQUFJLFNBQVMsTUFBTTtBQUNqQixnQkFBTSxjQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLHFDQUNsQixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0sUUFBUSxLQUFLLE1BQU0sUUFBUSxPQUMzQixjQUFjLE1BQU07QUFFMUIsWUFBSSxnQkFBZ0IsR0FBRztBQUNyQixnQkFBTSxVQUFVLHVDQUF1QyxvQ0FDakQsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLFlBQVksT0FBTTtBQUV4QixlQUFPO0FBRVAsZUFBTyxJQUFBLE1BQUEsY0FBYSxNQUFNO0FBRTFCLGNBQU0sYUFBYSxLQUFLO0FBRXhCLGlCQUFRLE1BQU0scUJBQXFCLG1DQUFtQztBQUV0RSxlQUFPOztPQUdGLGNBL0VhLElBK0ViLFFBQU8sY0EvRU07Ozs7QUNidEI7Ozs7O21DQVFBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7OztBQVJBO1FBUUEsV0FBZSxJQUFBLFVBQUEsUUFBTyxvQkFBd0IsZ0JBQUEsUUFBTztNQUNuRCxZQUFZLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUM3QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87QUFDWixhQUFLLE9BQU87O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLFlBQVksTUFBTSxVQUFTO0FBQ3pCLGNBQU0sYUFBYSxLQUFLLGFBQ2xCLGtCQUFrQixLQUFLO0FBRTdCLGlCQUFRLE1BQU0sa0JBQWtCLGlDQUFpQztBQUVqRSxjQUFNLFdBQVcsS0FBSztBQUV0QixZQUFJLEtBQUssU0FBUyxVQUFVO0FBQzFCLGdCQUFNLFVBQVUsUUFBUSx1QkFBdUIsdUNBQXVDLGlDQUFpQyxLQUFLLGVBQ3RILFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsaUJBQVEsTUFBTSxxQkFBcUIsaUNBQWlDOztPQUcvRCxjQWxDYSxJQWtDYixRQUFPLGNBbENNOzs7O0FDUnRCOzs7OzttQ0FRQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7QUFSQTtRQVFBLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQXlCLGdCQUFBLFFBQU87TUFDcEQsWUFBWSxVQUFTLFFBQVEsTUFBTSxPQUFPO0FBQ3hDLGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssUUFBUTs7TUFHZixXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFDVixjQUFNLFNBQVMsS0FBSyxNQUFNO0FBRTFCLGVBQU87O01BR1QsYUFBYSxPQUFPO0FBQ2xCLGNBQU0sWUFBWSxLQUFLLE1BQU0sVUFBVTtBQUV2QyxlQUFPOztNQUdULGlCQUFpQixVQUFVO0FBQUUsYUFBSyxNQUFNLFFBQVE7O01BRWhELGFBQWEsT0FBTyxVQUFTO0FBQzNCLGNBQU0sY0FBYyxNQUFNLGFBQ3BCLG1CQUFtQixLQUFLO0FBRTlCLGlCQUFRLE1BQU0sa0JBQWtCLG1DQUFtQztBQUVuRSxjQUFNLGNBQWMsTUFBTSxhQUNwQixtQkFBbUIsS0FBSztBQUU5QixZQUFJLGdCQUFnQixrQkFBa0I7QUFDcEMsZ0JBQU0sVUFBVSxRQUFRLGlDQUFpQyw0REFDbkQsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixhQUFLLGlCQUFpQixDQUFDLFdBQVcsVUFBQTtBQUNoQyxjQUFJLGNBQWMsTUFBTTtBQUN0QixrQkFBTSxPQUFPLE1BQU0sUUFBUTtBQUUzQixzQkFBVSxZQUFZLE1BQU07OztBQUloQyxpQkFBUSxNQUFNLG9CQUFvQixtQ0FBbUM7O09BR2hFLGNBcERhLElBb0RiLFFBQU8sZUFwRE07Ozs7QUNSdEI7Ozs7O21DQVVBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7O0FBVkE7UUFVQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUF5QixnQkFBQSxRQUFPO01BQ3BELFlBQVksVUFBUyxRQUFRLE1BQU0sVUFBVSxPQUFPO0FBQ2xELGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssV0FBVztBQUNoQixhQUFLLFFBQVE7O01BR2YsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFNBQVMsVUFBUztBQUNoQixZQUFJO0FBRUosY0FBTSxtQkFBbUIsS0FBSztBQUU5QixpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxZQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLGdCQUFNLFVBQVUsd0JBQXdCLHNFQUNsQyxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGVBQU8sS0FBSyxTQUFTLFNBQVM7QUFFOUIsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxhQUFhLE9BQUEsV0FBVztBQUMxQixnQkFBTSxjQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLHdCQUF1Qiw2QkFBNkIsT0FBQSxlQUN0RSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLFlBQUk7QUFFSixjQUFNLGlCQUFpQixLQUFLO0FBRTVCLGVBQU87QUFFUCxZQUFJLFNBQVMsTUFBTTtBQUNqQixnQkFBTSxjQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLHFDQUNsQixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0sUUFBUSxLQUFLLE1BQU0sUUFBUTtBQUVqQyxlQUFPLElBQUEsTUFBQSxlQUFjLE9BQU87QUFFNUIsY0FBTSxhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxxQkFBcUIscUNBQXFDO0FBRXhFLGVBQU87O09BR0YsY0FuRWEsSUFtRWIsUUFBTyxlQW5FTTs7OztBQ1Z0Qjs7Ozs7bUNBTUEsV0FBQTs7O2VBQUE7Ozs7O0FBTkE7UUFNQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUF5QixnQkFBQSxRQUFPO01BQ3BELFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTSxNQUFNLE9BQU8sUUFBUSxTQUFTLFdBQVcsWUFBWSxhQUFhLGVBQWU7QUFDeEgsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxPQUFPO0FBQ1osYUFBSyxPQUFPO0FBQ1osYUFBSyxRQUFRO0FBQ2IsYUFBSyxTQUFTO0FBQ2QsYUFBSyxVQUFVO0FBQ2YsYUFBSyxZQUFZO0FBQ2pCLGFBQUssYUFBYTtBQUNsQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxnQkFBZ0I7O01BR3ZCLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFDVixlQUFPLEtBQUs7O01BR2QsYUFBYTtBQUNYLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxpQkFBaUI7QUFDZixlQUFPLEtBQUs7O01BR2QsbUJBQW1CO0FBQ2pCLGVBQU8sS0FBSzs7TUFHZCxVQUFVO0FBQ1IsWUFBSTtBQUVKLFlBQUksT0FBTzttQkFFQSxLQUFLLFNBQVMsTUFBTTtBQUM3QixpQkFBTyxLQUFLLEtBQUs7bUJBQ1IsS0FBSyxTQUFTLE1BQU07QUFDN0IsaUJBQU8sS0FBSyxLQUFLO21CQUNSLEtBQUssVUFBVSxNQUFNO0FBQzlCLGlCQUFPLEtBQUssTUFBTTttQkFDVCxLQUFLLFdBQVcsTUFBTTtBQUMvQixpQkFBTyxLQUFLLE9BQU87bUJBQ1YsS0FBSyxZQUFZLE1BQU07QUFDaEMsaUJBQU8sS0FBSyxRQUFRO21CQUNYLEtBQUssY0FBYyxNQUFNO0FBQ2xDLGlCQUFPLEtBQUssVUFBVTttQkFDYixLQUFLLGVBQWUsTUFBTTtBQUNuQyxpQkFBTyxLQUFLLFdBQVc7bUJBQ2QsS0FBSyxnQkFBZ0IsTUFBTTtBQUNwQyxpQkFBTyxLQUFLLFlBQVk7bUJBQ2YsS0FBSyxrQkFBa0IsTUFBTTtBQUN0QyxpQkFBTyxLQUFLLGNBQWM7O0FBRzVCLGVBQU87O1lBR0gsU0FBUyxVQUFTO0FBQ3RCLFlBQUk7QUFFSixZQUFJLE9BQU87bUJBRUEsS0FBSyxTQUFTLE1BQU07QUFDN0IsaUJBQU8sS0FBSyxLQUFLLFNBQVM7bUJBQ2pCLEtBQUssY0FBYyxNQUFNO0FBQ2xDLGlCQUFPLEtBQUssVUFBVSxTQUFTO21CQUN0QixLQUFLLGVBQWUsTUFBTTtBQUNuQyxpQkFBTyxLQUFLLFdBQVcsU0FBUzttQkFDdkIsS0FBSyxTQUFTLE1BQU07QUFDN0IsaUJBQU8sTUFBTSxLQUFLLEtBQUssU0FBUzttQkFDdkIsS0FBSyxVQUFVLE1BQU07QUFDOUIsaUJBQU8sTUFBTyxLQUFLLE1BQU0sU0FBUzttQkFDekIsS0FBSyxXQUFXLE1BQU07QUFDL0IsaUJBQU8sTUFBTSxLQUFLLE9BQU8sU0FBUzttQkFDekIsS0FBSyxZQUFZLE1BQU07QUFDaEMsaUJBQU8sTUFBTSxLQUFLLFFBQVEsU0FBUzttQkFDMUIsS0FBSyxnQkFBZ0IsTUFBTTtBQUNwQyxpQkFBTyxNQUFNLEtBQUssWUFBWSxTQUFTO21CQUM5QixLQUFLLGtCQUFrQixNQUFNO0FBQ3RDLGlCQUFPLE1BQU0sS0FBSyxjQUFjLFNBQVM7O0FBRzNDLGVBQU87O09BR0YsY0EzR2EsSUEyR2IsUUFBTyxlQTNHTTs7OztBQ050Qjs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsUUFBUyxXQUFBO0FBRUYscUNBQTJCLGdCQUFBLFFBQU87TUFDL0MsWUFBWSxVQUFTLFdBQVc7QUFDOUIsY0FBTTtBQUVOLGFBQUssWUFBWTs7TUFHbkIsYUFBYSxTQUFTLE1BQU07QUFDMUIsY0FBTSxZQUFZO0FBRWxCLGFBQUssV0FBVyxLQUFLO0FBRXJCLFlBQUksUUFBUTtBQUNWLGdCQUFNLFdBQVUsS0FBSyxjQUNmLG1CQUFtQixTQUFRO0FBRWpDLGVBQUssV0FBVzs7QUFHbEIsZUFBTzs7TUFHVCxZQUFZLFVBQVU7QUFDcEIsY0FBTSxTQUFTLE9BQ1QsZUFBZSxTQUFTLFdBQ3hCLGlCQUFpQixTQUFTLGFBQzFCLGtCQUFrQixLQUFLLGdDQUFnQyxjQUFjO0FBRTNFLFlBQUksaUJBQWlCO0FBQ25CLGdCQUFNLFVBQVUsUUFBUSxpREFDbEIsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLFdBQVU7QUFFaEIsaUJBQVEsTUFBTSxjQUFjO0FBRTVCLGFBQUssVUFBVSxLQUFLOztNQUd0Qiw2QkFBNkIsZUFBZTtBQUMxQyxjQUFNLFdBQVUsS0FBSyxjQUNmLFlBQVksU0FBUSw2QkFBNkI7QUFFdkQsZUFBTzs7TUFHVCxrQ0FBa0MsZUFBZTtBQUMvQyxjQUFNLFdBQVUsS0FBSyxjQUNmLG1CQUFtQixTQUFRLGtDQUFrQztBQUVuRSxlQUFPOztNQUdULDJCQUEyQixjQUFjLFNBQVMsTUFBTTtBQUN0RCxjQUFNLFlBQVksS0FBSyxhQUFhLFNBQzlCLFdBQVcsVUFBVSxLQUFLLENBQUMsY0FBQTtBQUN6QixnQkFBTSxpQ0FBaUMsVUFBUyxvQkFBb0I7QUFFcEUsY0FBSSxnQ0FBZ0M7QUFDbEMsbUJBQU87O2NBRUw7QUFFWixlQUFPOztNQUdULGdDQUFnQyxjQUFjLFNBQVMsTUFBTTtBQUMzRCxjQUFNLFdBQVcsS0FBSywyQkFBMkIsY0FBYyxTQUN6RCxrQkFBbUIsYUFBYTtBQUV0QyxlQUFPOzthQUdGLGNBQWMsV0FBVyxVQUFTO0FBQ3ZDLGNBQU0sZUFBZSxnQkFBQSxRQUFRLFlBQVksY0FBYyxXQUFXO0FBRWxFLGVBQU87Ozs7OztBQ3hGWDs7Ozs7bUNBV0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7OztBQUZBLFFBQU0sQ0FBRSxnQkFBaUIsZ0JBQUE7QUFUekI7UUFXQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUEwQixnQkFBQSxRQUFPO01BQ3JELFlBQVksVUFBUyxRQUFRLE1BQU0sT0FBTyxhQUFhLGlCQUFpQjtBQUN0RSxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLFFBQVE7QUFDYixhQUFLLGNBQWM7QUFDbkIsYUFBSyxrQkFBa0I7O01BR3pCLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsZ0JBQWdCO0FBQ2QsZUFBTyxLQUFLOztNQUdkLHFCQUFxQjtBQUNuQixlQUFPLEtBQUs7O1lBR1IsU0FBUyxXQUFXLFVBQVM7QUFDakMsWUFBSSxhQUFZLFFBQVc7QUFDekIscUJBQVU7QUFFVixzQkFBWTs7QUFHZCxjQUFNLG9CQUFvQixLQUFLO0FBRS9CLGlCQUFRLE1BQU0sbUJBQW1CO0FBRWpDLFlBQUksS0FBSyxhQUFhO0FBQ3BCLGdCQUFNLFVBQVUsb0NBQ1YsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLGVBQWUsT0FBQSxRQUFhLGNBQWMsV0FBVztBQUUzRCxtQkFBVTtBQUVWLGNBQU0sYUFBYSxLQUFLLE9BQU8sT0FBTyxTQUFBO0FBQ3BDLGdCQUFNLEtBQUssU0FBUzs7QUFHdEIsY0FBTSxPQUFPLEtBQUssZ0JBQWdCLFNBQVMsV0FDckMsYUFBYSxLQUFLO0FBRXhCLGlCQUFRLE1BQU0scUJBQXFCLHVDQUF1QztBQUUxRSxlQUFPOztPQUdGLGNBdkRhLElBdURiLFFBQU8sZ0JBdkRNOzs7O0FDWHRCOzs7OzttQ0FVQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7OztBQVZBO1FBVUEsV0FBZSxJQUFBLFVBQUEsUUFBTyxvQkFBMEIsZ0JBQUEsUUFBTztNQUNyRCxZQUFZLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUM3QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87QUFDWixhQUFLLE9BQU87O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLFNBQVMsVUFBUztBQUNoQixZQUFJO0FBRUosY0FBTSxvQkFBb0IsS0FBSztBQUUvQixpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxlQUFPLEtBQUssS0FBSyxTQUFTO0FBRTFCLGNBQU0sV0FBVyxLQUFLO0FBRXRCLFlBQUksYUFBYSxPQUFBLGNBQWM7QUFDN0IsZ0JBQU0sY0FBYSxLQUFLLGFBQ2xCLFVBQVUsUUFBUSxxQ0FBb0Msd0NBQXdDLE9BQUEsa0JBQzlGLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsWUFBSTtBQUVKLGNBQU0saUJBQWlCLEtBQUs7QUFFNUIsa0JBQVU7QUFFVixrQkFBVSxDQUFDO0FBRVgsZUFBTyxJQUFBLE1BQUEsaUJBQWdCLFNBQVM7QUFFaEMsY0FBTSxhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxxQkFBcUIsdUNBQXVDO0FBRTFFLGVBQU87O09BR0YsY0FwRGEsSUFvRGIsUUFBTyxnQkFwRE07Ozs7QUNWdEI7Ozs7O21DQVVBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7O0FBVkE7UUFVQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUEwQixnQkFBQSxRQUFPO01BQ3JELFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTSxhQUFhLFVBQVUsV0FBVztBQUN6RSxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87QUFDWixhQUFLLGNBQWM7QUFDbkIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssWUFBWTs7TUFHbkIsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLFNBQVMsVUFBUztBQUNoQixZQUFJO0FBRUosY0FBTSxvQkFBb0IsS0FBSztBQUUvQixpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxjQUFNLFdBQVcsS0FBSyxTQUFTLFNBQVMsV0FDbEMsWUFBWSxLQUFLLFVBQVUsU0FBUyxXQUNwQyxlQUFlLFNBQVMsV0FDeEIsZ0JBQWdCLFVBQVU7QUFFaEMsWUFBSSxpQkFBaUIsT0FBQSxjQUFjO0FBQ2pDLGdCQUFNLGlCQUFpQixTQUFTLGFBQzFCLFVBQVUsUUFBUSx3Q0FBd0MsNENBQTRDLE9BQUEsa0JBQ3RHLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsWUFBSSxrQkFBa0IsT0FBQSxjQUFjO0FBQ2xDLGdCQUFNLGtCQUFrQixVQUFVLGFBQzVCLFVBQVUsUUFBUSwwQ0FBMEMsNkNBQTZDLE9BQUEsa0JBQ3pHLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsY0FBTSx5QkFBeUIsU0FBUyxxQkFDbEMsMEJBQTBCLFVBQVUscUJBQ3BDLGNBQWEsd0JBQ2IsZUFBZSx5QkFDZixVQUFVLEtBQUssY0FDRixlQUFlLGVBQ2IsZUFBZTtBQUVwQyxlQUFPLElBQUEsTUFBQSxpQkFBZ0IsU0FBUztBQUVoQyxjQUFNLGFBQWEsS0FBSztBQUV4QixpQkFBUSxNQUFNLHFCQUFxQix1Q0FBdUM7QUFFMUUsZUFBTzs7T0FHRixjQXZFYSxJQXVFYixRQUFPLGdCQXZFTTs7OztBQ1Z0Qjs7Ozs7bUNBTUEsV0FBQTs7O2VBQUE7Ozs7O0FBTkE7UUFNQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUE0QixnQkFBQSxRQUFPO01BQ3ZELFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTTtBQUN2QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxVQUFVO0FBQUUsZUFBTyxLQUFLLEtBQUs7O01BRTdCLFNBQVMsVUFBUztBQUNoQixZQUFJO0FBRUosY0FBTSxzQkFBc0IsS0FBSztBQUVqQyxpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxlQUFPLEtBQUssS0FBSyxTQUFTO0FBRTFCLGNBQU0sYUFBYSxLQUFLO0FBRXhCLGlCQUFRLE1BQU0scUJBQXFCLDJDQUEyQztBQUU5RSxlQUFPOztPQUdGLGNBN0JhLElBNkJiLFFBQU8sa0JBN0JNOzs7O0FDTnRCOzs7OzttQ0FRQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7QUFSQTtRQVFBLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQTRCLGdCQUFBLFFBQU87TUFDdkQsWUFBWSxVQUFTLFFBQVEsTUFBTSxXQUFXLE9BQU87QUFDbkQsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssUUFBUTs7TUFHZixlQUFlO0FBQ2IsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsbUJBQW1CO0FBQUUsZUFBTyxLQUFLLFVBQVU7O1lBRXJDLFNBQVMsVUFBUztBQUN0QixjQUFNLEtBQUssTUFBTTtBQUVqQixjQUFNLHNCQUFzQixLQUFLO0FBRWpDLGlCQUFRLE1BQU0sbUJBQW1CO0FBRWpDLGNBQU0sZ0JBQWdCLEtBQUssb0JBQ3JCLG1CQUFtQixTQUFRLGtDQUFrQztBQUVuRSxZQUFJLENBQUMsa0JBQWtCO0FBQ3JCLGdCQUFNLFVBQVUsUUFBUSxrREFDbEIsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLFlBQVksU0FBUSw2QkFBNkIsZ0JBQ2pELFFBQVEsS0FBSyxNQUFNLFNBQVMsV0FDNUIsT0FBTyxNQUFNLFVBQVUsS0FBSyxPQUFPO0FBRXpDLGNBQU0sYUFBYSxLQUFLO0FBRXhCLGlCQUFRLE1BQU0scUJBQXFCLDJDQUEyQztBQUU5RSxlQUFPOztPQUdGLGNBOUNhLElBOENiLFFBQU8sa0JBOUNNOzs7O0FDUnRCOzs7OzttQ0FTQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7O0FBVEE7UUFTQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUE2QixnQkFBQSxRQUFPO01BQ3hELFlBQVksVUFBUyxRQUFRLE1BQU0sU0FBUyxVQUFVLFdBQVc7QUFDL0QsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxXQUFXO0FBQ2hCLGFBQUssWUFBWTs7TUFHbkIsWUFBWTtBQUNWLGVBQU8sS0FBSzs7TUFHZCxjQUFjO0FBQ1osZUFBTyxLQUFLOztNQUdkLGVBQWU7QUFDYixlQUFPLEtBQUs7O01BR2QsU0FBUyxVQUFTO0FBQ2hCLFlBQUk7QUFFSixjQUFNLHVCQUF1QixLQUFLO0FBRWxDLGlCQUFRLE1BQU0sbUJBQW1CO0FBRWpDLGNBQU0sV0FBVyxLQUFLLFNBQVMsU0FBUyxXQUNsQyxZQUFZLEtBQUssVUFBVSxTQUFTLFdBQ3BDLGVBQWUsU0FBUyxXQUN4QixnQkFBZ0IsVUFBVTtBQUVoQyxZQUFJLGlCQUFpQixlQUFlO0FBQ2xDLGdCQUFNLGlCQUFpQixTQUFTLGFBQzFCLGtCQUFrQixVQUFVLGFBQzVCLFVBQVUsUUFBUSx3Q0FBd0MsOEJBQThCLDBDQUEwQyxtQkFDbEksWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixjQUFNLDJCQUEyQixTQUFTLFVBQVU7QUFFcEQsWUFBSSxVQUFVO0FBRWQsWUFBSSxLQUFLLFNBQVM7QUFDaEIsb0JBQVUsQ0FBQzs7QUFHYixlQUFPLElBQUEsTUFBQSxpQkFBZ0IsU0FBUztBQUVoQyxjQUFNLGFBQWEsS0FBSztBQUV4QixpQkFBUSxNQUFNLHFCQUFxQiw2Q0FBNkM7QUFFaEYsZUFBTzs7T0FHRixjQTNEYSxJQTJEYixRQUFPLG1CQTNETTs7OztBQ1R0Qjs7Ozs7bUNBUUEsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7O0FBUkE7UUFRQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUE2QixnQkFBQSxRQUFPO01BQ3hELFlBQVksVUFBUyxRQUFRLE1BQU0sTUFBTSxNQUFNLE9BQU87QUFDcEQsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxPQUFPO0FBQ1osYUFBSyxPQUFPO0FBQ1osYUFBSyxRQUFROztNQUdmLFVBQVU7QUFDUixlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFDVixjQUFNLFVBQVcsS0FBSyxVQUFVO0FBRWhDLGVBQU87O01BR1QsaUJBQWlCO0FBQ2YsY0FBTSxVQUFVLEtBQUssYUFDZixjQUFjLFVBQ0UsS0FBSyxRQUNILEtBQUs7QUFFN0IsZUFBTzs7TUFHVCxZQUFZLE1BQU0sVUFBUztBQUN6QixjQUFNLGFBQWEsS0FBSyxhQUNsQix1QkFBdUIsS0FBSztBQUVsQyxpQkFBUSxNQUFNLGtCQUFrQiw4QkFBOEI7QUFFOUQsY0FBTSxXQUFXLEtBQUs7QUFFdEIsWUFBSSxLQUFLLFNBQVMsVUFBVTtBQUMxQixnQkFBTSxVQUFVLFFBQVEsdUJBQXVCLG1DQUFtQyw0Q0FBNEMsS0FBSyxlQUM3SCxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGlCQUFRLE1BQU0sb0JBQW9CLDhCQUE4Qjs7TUFHbEUsc0JBQXNCLGdCQUFnQixVQUFTO0FBQzdDLFlBQUk7QUFFSixjQUFNLGtCQUFrQixNQUNsQixrQkFBa0I7QUFFeEIsY0FBTSx3QkFBd0IsZ0JBQWdCLGFBQ3hDLHdCQUF3QixnQkFBZ0I7QUFFOUMsaUJBQVEsTUFBTSxrQkFBa0Isb0RBQW9EO0FBRXBGLGNBQU0sT0FBTyxlQUFlLFdBQ3RCLE9BQU8sZUFBZTtBQUU1QixpQ0FBMkIsS0FBSyxTQUFTLFFBQVUsS0FBSyxTQUFTO0FBRWpFLFlBQUksd0JBQXdCO0FBQzFCLG1CQUFRLE1BQU0sb0JBQW9CLG9EQUFvRDs7QUFHeEYsZUFBTzs7T0FHRixjQTdFYSxJQTZFYixRQUFPLG1CQTdFTTs7OztBQ1J0Qjs7Ozs7bUNBV0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFYQTtRQVdBLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQTZCLGdCQUFBLFFBQU87TUFDeEQsWUFBWSxVQUFTLFFBQVEsTUFBTSxVQUFVLFlBQVk7QUFDdkQsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssYUFBYTs7TUFHcEIsY0FBYztBQUNaLGVBQU8sS0FBSzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsU0FBUyxVQUFTO0FBQ2hCLGNBQU0sd0JBQXdCLEtBQUs7QUFFbkMsaUJBQVEsTUFBTSxtQkFBbUI7QUFFakMsY0FBTSxPQUFPLEtBQUssU0FBUyxTQUFTLFdBQzlCLFdBQVcsS0FBSztBQUV0QixZQUFJLGFBQWEsT0FBQSxZQUFZO0FBQzNCLGdCQUFNLGFBQWEsS0FBSyxhQUNsQixVQUFVLFFBQVEsdUJBQXVCLDZCQUE2QixPQUFBLGdCQUN0RSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0saUJBQWlCLEtBQUsscUJBQ3RCLFFBQVEsZ0JBQ1IsY0FBYyxNQUFNLFFBQ3BCLG1CQUFtQixLQUFLLFdBQVc7QUFFekMsWUFBSSxtQkFBbUIsYUFBYTtBQUNsQyxnQkFBTSxtQkFBbUIsS0FBSyxXQUFXLGFBQ25DLGNBQWMsU0FBUSxjQUFjLFFBQ3BDLFVBQVUsc0JBQXNCLG1FQUFtRSx1QkFDbkcsWUFBWSxXQUFBLFFBQVUsWUFBWTtBQUV4QyxnQkFBTTs7QUFHUixhQUFLLFdBQVcsaUJBQWlCLENBQUMsV0FBVyxVQUFBO0FBQzNDLGNBQUksY0FBYyxNQUFNO0FBQ3RCLGtCQUFNLE9BQU8sTUFBTSxRQUNiLFFBQU8sSUFBQSxNQUFBLGNBQWEsTUFBTTtBQUVoQyxpQkFBSyxrQkFBa0IsV0FBVyxPQUFNOzs7QUFJNUMsaUJBQVEsTUFBTSxxQkFBcUI7O01BR3JDLGtCQUFrQixXQUFXLFlBQVksVUFBUztBQUNoRCxjQUFNLG1CQUFtQixXQUFXLGFBQzlCLGtCQUFrQixVQUFVO0FBRWxDLGlCQUFRLE1BQU0sbUJBQW1CLDJDQUEyQztBQUU1RSxjQUFNLGdCQUFnQixVQUFVO0FBRWhDLFlBQUksa0JBQWtCLE9BQUEsV0FBVztBQUMvQixnQkFBTSxVQUFVLG9CQUFvQix5Q0FBeUMsT0FBQSxlQUN2RSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0sQ0FBRSxZQUFhLFVBQUEsU0FDZixXQUFXLFNBQVMsY0FBYyxXQUFXO0FBRW5ELGlCQUFTLE9BQU8sWUFBWTtBQUU1QixpQkFBUSxNQUFNLHFCQUFxQiwyQ0FBMkM7O09BR3pFLGNBakZhLElBaUZiLFFBQU8sb0JBakZNOzs7O0FDWHRCOzs7OzttQ0FNQSxXQUFBOzs7ZUFBQTs7Ozs7QUFOQTtRQU1BLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQThCLGdCQUFBLFFBQU87TUFDekQsWUFBWSxVQUFTLFFBQVEsTUFBTSxNQUFNO0FBQ3ZDLGNBQU0sVUFBUyxRQUFRO0FBRXZCLGFBQUssT0FBTzs7TUFHZCxnQkFBZ0I7QUFDZCxlQUFPLEtBQUs7O01BR2QsU0FBUyxVQUFTO0FBQ2hCLFlBQUk7QUFFSixjQUFNLHdCQUF3QixLQUFLO0FBRW5DLGlCQUFRLE1BQU0sbUJBQW1CO0FBRWpDLGVBQU8sS0FBSyxLQUFLLFNBQVM7QUFFMUIsY0FBTSxhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxxQkFBcUIsK0NBQStDO0FBRWxGLGVBQU87O09BR0YsY0EzQmEsSUEyQmIsUUFBTyxvQkEzQk07Ozs7QUNOdEI7Ozs7O21DQVFBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7OztBQVJBO1FBUUEsV0FBZSxJQUFBLFVBQUEsUUFBTyxvQkFBOEIsZ0JBQUEsUUFBTztNQUN6RCxZQUFZLFVBQVMsUUFBUSxNQUFNLE9BQU87QUFDeEMsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxRQUFROztNQUdmLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsWUFBWTtBQUNWLGNBQU0sU0FBUyxLQUFLLE1BQU07QUFFMUIsZUFBTzs7TUFHVCxrQkFBa0IsT0FBTztBQUN2QixjQUFNLGlCQUFpQixLQUFLLE1BQU0sVUFBVTtBQUU1QyxlQUFPOztNQUdULG1CQUFtQixVQUFVO0FBQUUsZUFBTyxLQUFLLE1BQU0sS0FBSzs7TUFFdEQsc0JBQXNCLFVBQVU7QUFBRSxhQUFLLE1BQU0sUUFBUTs7TUFFckQsYUFBYSxPQUFPLFVBQVM7QUFDM0IsY0FBTSxjQUFjLE1BQU0sYUFDcEIsd0JBQXdCLEtBQUs7QUFFbkMsaUJBQVEsTUFBTSxrQkFBa0IsZ0NBQWdDO0FBRWhFLGNBQU0sY0FBYyxNQUFNLGFBQ3BCLHdCQUF3QixLQUFLO0FBRW5DLFlBQUksZ0JBQWdCLHVCQUF1QjtBQUN6QyxnQkFBTSxVQUFVLFFBQVEsMkJBQTJCLHVFQUM3QyxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGFBQUssc0JBQXNCLENBQUMsZ0JBQWdCLFVBQUE7QUFDMUMsY0FBSSxtQkFBbUIsTUFBTTtBQUMzQixrQkFBTSxPQUFPLE1BQU0sUUFBUTtBQUUzQiwyQkFBZSxZQUFZLE1BQU07OztBQUlyQyxpQkFBUSxNQUFNLG9CQUFvQixnQ0FBZ0M7O01BR3BFLHNCQUFzQixnQkFBZ0IsVUFBUztBQUM3QyxjQUFNLHVCQUF1QixlQUFlLGFBQ3RDLHdCQUF3QixLQUFLO0FBRW5DLGlCQUFRLE1BQU0sa0JBQWtCLGtEQUFrRDtBQUVsRixjQUFNLGtCQUFrQixnQkFDbEIseUJBQXlCLEtBQUssbUJBQW1CLENBQUMsb0JBQUE7QUFDaEQsY0FBSSxvQkFBbUIsTUFBTTtBQUMzQixrQkFBTSxrQkFBa0IsaUJBQ2xCLDJDQUEyQyxnQkFBZ0Isc0JBQXNCLGlCQUFpQjtBQUV4RyxnQkFBSSwwQ0FBMEM7QUFDNUMscUJBQU87Ozs7QUFLbkIsWUFBSSxDQUFDLHdCQUF3QjtBQUMzQixnQkFBTSxVQUFVLFFBQVEsd0VBQXdFLDRDQUMxRixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGlCQUFRLE1BQU0sb0JBQW9CLGtEQUFrRDs7TUFHdEYsdUJBQXVCLGlCQUFpQixVQUFTO0FBQy9DLHdCQUFnQixzQkFBc0IsQ0FBQyxtQkFBQTtBQUNyQyxjQUFJLG1CQUFtQixNQUFNO0FBQzNCLGlCQUFLLHNCQUFzQixnQkFBZ0I7Ozs7T0FLMUMsY0ExRmEsSUEwRmIsUUFBTyxvQkExRk07Ozs7QUNSdEI7Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLDhCQUFNO01BQ25CLFlBQVksUUFBUSxNQUFNLE1BQU07QUFDOUIsYUFBSyxTQUFTO0FBQ2QsYUFBSyxPQUFPO0FBQ1osYUFBSyxPQUFPOztNQUdkLFlBQVk7QUFDVixlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLHNCQUFzQixnQkFBZ0IsVUFBUztBQUM3QyxZQUFJO0FBRUosY0FBTSxxQkFBcUIsS0FBSyxRQUMxQix1QkFBdUIsZUFBZTtBQUU1QyxpQkFBUSxNQUFNLGtCQUFrQiwrQ0FBK0M7QUFFL0UsY0FBTSxPQUFPLGVBQWUsV0FDdEIsT0FBTyxlQUFlO0FBRTVCLGlDQUEyQixLQUFLLFNBQVMsUUFBVSxLQUFLLFNBQVM7QUFFakUsWUFBSSx3QkFBd0I7QUFDMUIsbUJBQVEsTUFBTSxvQkFBb0IsK0NBQStDOztBQUduRixlQUFPOzthQUtGLGdCQUFnQixNQUFNLE1BQU07QUFDakMsY0FBTSxxQkFBcUIsSUFBQSxRQUFBLG1DQUFrQyxNQUFNLE9BQzdELFNBQVMsb0JBQ1QsZUFBZSxJQUFJLGNBQWEsUUFBUSxNQUFNO0FBRXBELGVBQU87OztBQTlDSTtBQXVDTixrQkF2Q00sY0F1Q04sUUFBTzs7OztBQzNDaEI7Ozs7Ozs7Ozs7Ozs7VUFJYSw2QkFBQTtlQUFBOztVQUZBLHlCQUFBO2VBQUE7O1VBQ0EsMEJBQUE7ZUFBQTs7O0FBRE4sUUFBTSx5QkFBeUI7QUFDL0IsUUFBTSwwQkFBMEI7QUFDaEMsUUFBTSw2QkFBNkI7Ozs7QUNKMUM7Ozs7O21DQW1FQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7Ozs7OztBQTFEQSwrQkFBTTtNQUNKLFlBQVksUUFBUSxPQUFPO0FBQ3pCLGFBQUssU0FBUztBQUNkLGFBQUssUUFBUTs7TUFHZixZQUFZO0FBQ1YsZUFBTyxLQUFLOztNQUdkLFdBQVc7QUFDVCxlQUFPLEtBQUs7O01BR2QsaUJBQWlCLFVBQVU7QUFBRSxlQUFPLEtBQUssTUFBTSxLQUFLOztNQUVwRCxzQkFBc0IsZ0JBQWdCLFVBQVM7QUFDN0MsY0FBTSx1QkFBdUIsS0FBSyxRQUM1Qix1QkFBdUIsZUFBZTtBQUU1QyxpQkFBUSxNQUFNLGtCQUFrQixtREFBbUQ7QUFFbkYsY0FBTSx5QkFBeUIsS0FBSyxpQkFBaUIsQ0FBQyxpQkFBQTtBQUNwRCxnQkFBTSx1Q0FBdUMsYUFBYSxzQkFBc0IsZ0JBQWdCO0FBRWhHLGNBQUksc0NBQXNDO0FBQ3hDLG1CQUFPOzs7QUFJWCxZQUFJLENBQUMsd0JBQXdCO0FBQzNCLGdCQUFNLFVBQVUsUUFBUSwwRUFBMEUsMENBQzVGLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsaUJBQVEsTUFBTSxvQkFBb0IsbURBQW1EOztNQUd2Rix1QkFBdUIsaUJBQWlCLFVBQVM7QUFDL0Msd0JBQWdCLHNCQUFzQixDQUFDLG1CQUFBO0FBQ3JDLGVBQUssc0JBQXNCLGdCQUFnQjs7O2FBSXhDLGNBQWM7QUFDbkIsY0FBTSxzQkFBc0Isa0NBQ3RCLFNBQVMsSUFBQSxRQUFBLDZDQUE0QyxzQkFDckQsUUFBUSxxQkFDUixrQkFBaUIsSUFBSSxlQUFlLFFBQVE7QUFFbEQsZUFBTzs7O0FBSVgsUUFBTSxpQkFBaUIsZUFBZTtRQUV0QyxXQUFlO0FBRWYsOENBQVM7QUFDUCxZQUFNLFFBQVE7UUFDTixPQUFBO1FBQ0EsT0FBQTtRQUNBLE9BQUE7U0FFRixRQUFRO1FBQ04sZ0JBQUE7UUFDQSxnQkFBQTtRQUNBLGdCQUFBO1NBRUYsc0JBQXNCLE1BQU0sSUFBSSxDQUFDLE1BQU0sVUFBQTtBQUNyQyxjQUFNLE9BQU8sTUFBTSxRQUNiLGVBQWUsY0FBQSxRQUFhLGdCQUFnQixNQUFNO0FBRXhELGVBQU87O0FBR2YsYUFBTzs7Ozs7QUN2RlQ7Ozs7O21DQWNBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZEE7UUFjQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUE4QixnQkFBQSxRQUFPO01BQ3pELFlBQVksVUFBUyxRQUFRLE1BQU0sVUFBVSxpQkFBaUI7QUFDNUQsY0FBTSxVQUFTLFFBQVE7QUFFdkIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssa0JBQWtCOztNQUd6QixjQUFjO0FBQ1osZUFBTyxLQUFLOztNQUdkLHFCQUFxQjtBQUNuQixlQUFPLEtBQUs7O01BR2QsU0FBUyxVQUFTO0FBQ2hCLGNBQU0seUJBQXlCLEtBQUs7QUFFcEMsaUJBQVEsTUFBTSxtQkFBbUI7QUFFakMsY0FBTSxPQUFPLEtBQUssU0FBUyxTQUFTLFdBQzlCLFdBQVcsS0FBSztBQUV0QixZQUFJLGFBQWEsT0FBQSxXQUFXO0FBQzFCLGdCQUFNLGFBQWEsS0FBSyxhQUNsQixVQUFVLFFBQVEsdUJBQXVCLDZCQUE2QixPQUFBLGVBQ3RFLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1Isd0JBQUEsUUFBZSx1QkFBdUIsS0FBSyxpQkFBaUI7QUFFNUQsYUFBSyxnQkFBZ0Isc0JBQXNCLENBQUMsbUJBQUE7QUFDMUMsZUFBSyx1QkFBdUIsZ0JBQWdCLE1BQU07O0FBR3BELGlCQUFRLE1BQU0scUJBQXFCOztNQUdyQyx1QkFBdUIsZ0JBQWdCLE1BQU0sVUFBUztBQUNwRCxjQUFNLGFBQWEsS0FBSyxhQUNsQix1QkFBdUIsZUFBZTtBQUU1QyxpQkFBUSxNQUFNLG1CQUFtQixzREFBc0Q7QUFFdkYsY0FBTSxPQUFPLGVBQWU7QUFFNUIsZ0JBQVE7ZUFDRCxnQkFBQSx3QkFBd0I7QUFDM0IsbUJBQU8sS0FBSyw4QkFBOEIsZ0JBQWdCLE1BQU07QUFFaEU7O2VBR0csZ0JBQUEseUJBQXlCO0FBQzVCLG1CQUFPLEtBQUssK0JBQStCLGdCQUFnQixNQUFNO0FBRWpFOztlQUdHLGdCQUFBLDRCQUE0QjtBQUMvQixtQkFBTyxLQUFLLGlDQUFpQyxnQkFBZ0IsTUFBTTtBQUVuRTs7O0FBSUosY0FBTSxDQUFFLFlBQWEsVUFBQSxTQUNmLFdBQVcsU0FBUyxtQkFBbUIsZ0JBQWdCO0FBRTdELGlCQUFTLE9BQU8sTUFBTTtBQUV0QixpQkFBUSxNQUFNLHFCQUFxQixzREFBc0Q7O01BRzNGLDhCQUE4QixnQkFBZ0IsTUFBTSxVQUFTO0FBQzNELGNBQU0sT0FBTyxlQUFlLFdBQ3RCLHVCQUF1QixlQUFlO0FBRTVDLGlCQUFRLE1BQU0sMkJBQTJCO0FBRXpDLFlBQUksU0FBUyxPQUFBLGFBQWE7QUFDeEIsZ0JBQU0sd0JBQXVCLGVBQWUsYUFDdEMsVUFBVSxRQUFRLDREQUEyRCxPQUFBLGlCQUM3RSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0saUJBQWlCLEtBQUsscUJBQ3RCLE9BQU8sZ0JBQ1AsbUJBQW1CLEtBQUs7QUFFOUIsWUFBSSxDQUFDLGtCQUFrQjtBQUNyQixnQkFBTSxhQUFhLEtBQUssYUFDbEIsVUFBVSxRQUFRLDZDQUNsQixZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGNBQU0sZUFBZSxNQUNmLFVBQVUsYUFBYSxjQUN2QixTQUFTLFNBQ1QsZ0JBQWdCLElBQUEsZUFBQSx5QkFBd0I7QUFFOUMsZUFBTyxJQUFBLE1BQUEsdUJBQXNCLGVBQWU7QUFFNUMsY0FBTSxjQUFjLEtBQUs7QUFFekIsaUJBQVEsTUFBTSw2QkFBNkIsNkNBQTZDO0FBRXhGLGVBQU87O01BR1QsK0JBQStCLGdCQUFnQixNQUFNLFVBQVM7QUFDNUQsY0FBTSxPQUFPLGVBQWUsV0FDdEIsdUJBQXVCLGVBQWU7QUFFNUMsaUJBQVEsTUFBTSw0QkFBNEI7QUFFMUMsWUFBSSxTQUFTLE9BQUEsY0FBYztBQUN6QixnQkFBTSx3QkFBdUIsZUFBZSxhQUN0QyxVQUFVLFFBQVEsNERBQTJELE9BQUEsa0JBQzdFLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsY0FBTSxpQkFBaUIsS0FBSyxxQkFDdEIsT0FBTyxnQkFDUCxtQkFBbUIsS0FBSyxrQkFDeEIsV0FBVztBQUVqQixjQUFNLFVBQVU7QUFFaEIsZUFBTyxJQUFBLE1BQUEsaUJBQWdCLFNBQVM7QUFFaEMsY0FBTSxjQUFjLEtBQUs7QUFFekIsaUJBQVEsTUFBTSw4QkFBOEIsNkNBQTZDO0FBRXpGLGVBQU87O01BR1QsaUNBQWlDLGdCQUFnQixNQUFNLFVBQVM7QUFDOUQsY0FBTSxPQUFPLGVBQWUsV0FDdEIsdUJBQXVCLGVBQWU7QUFFNUMsaUJBQVEsTUFBTSwrQkFBK0I7QUFFN0MsWUFBSSxTQUFTLE9BQUEsWUFBWTtBQUN2QixnQkFBTSx3QkFBdUIsZUFBZSxhQUN0QyxVQUFVLFFBQVEsNERBQTJELE9BQUEsZ0JBQzdFLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsY0FBTSxpQkFBaUIsS0FBSyxxQkFDdEIsT0FBTyxnQkFDUCxzQkFBc0IsS0FBSztBQUVqQyxZQUFJLENBQUMscUJBQXFCO0FBQ3hCLGdCQUFNLGFBQWEsS0FBSyxhQUNsQixVQUFVLFFBQVEsaURBQ2xCLFlBQVksV0FBQSxRQUFVLFlBQVk7QUFFeEMsZ0JBQU07O0FBR1IsY0FBTSxrQkFBa0IsTUFDbEIsYUFBYSxnQkFBZ0IsaUJBQzdCLFFBQVE7QUFFZCxlQUFPLElBQUEsTUFBQSxlQUFjLE9BQU87QUFFNUIsY0FBTSxjQUFjLEtBQUs7QUFFekIsaUJBQVEsTUFBTSxnQ0FBZ0MsNkNBQTZDO0FBRTNGLGVBQU87O09BR0YsY0ExTGEsSUEwTGIsUUFBTyxvQkExTE07Ozs7QUNkdEI7Ozs7O21DQVNBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7Ozs7QUFUQTtRQVNBLFdBQWUsSUFBQSxVQUFBLFFBQU8sb0JBQWlDLGdCQUFBLFFBQU87TUFDNUQsWUFBWSxVQUFTLFFBQVEsTUFBTSxNQUFNLFlBQVksYUFBYTtBQUNoRSxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLE9BQU87QUFDWixhQUFLLGFBQWE7QUFDbEIsYUFBSyxjQUFjOztNQUdyQixVQUFVO0FBQ1IsZUFBTyxLQUFLOztNQUdkLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7TUFHZCxpQkFBaUI7QUFDZixlQUFPLEtBQUs7O1lBR1IsS0FBSyxPQUFPLFVBQVM7QUFDekIsY0FBTSwyQkFBMkIsS0FBSztBQUV0QyxpQkFBUSxNQUFNLGdCQUFnQjtBQUU5QixhQUFLLFdBQVcsYUFBYSxPQUFPO0FBRXBDLGNBQU0sWUFBWSxJQUFBLFdBQUEsaUNBQWdDLE9BQU8sS0FBSyxZQUFZLFdBQ3BFLE9BQU8sTUFBTSxLQUFLLFlBQVksU0FBUyxXQUFXLFdBQ2xELFdBQVcsS0FBSztBQUV0QixZQUFJLEtBQUssU0FBUyxVQUFVO0FBQzFCLGdCQUFNLGFBQWEsS0FBSyxhQUNsQixVQUFVLFFBQVEsdUJBQXVCLHVDQUF1QyxvREFBb0QsS0FBSyxlQUN6SSxZQUFZLFdBQUEsUUFBVSxZQUFZO0FBRXhDLGdCQUFNOztBQUdSLGlCQUFRLE1BQU0sa0JBQWtCO0FBRWhDLGVBQU87O09BR0YsY0E3Q2EsSUE2Q2IsUUFBTyx1QkE3Q007Ozs7QUNUdEI7Ozs7O21DQU1BLFdBQUE7OztlQUFBOzs7OztBQU5BO1FBTUEsV0FBZSxJQUFBLFVBQUEsUUFBTyxvQkFBaUMsZ0JBQUEsUUFBTztNQUM1RCxZQUFZLFVBQVMsUUFBUSxNQUFNLFVBQVUsWUFBWTtBQUN2RCxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLFdBQVc7QUFDaEIsYUFBSyxhQUFhOztNQUdwQixjQUFjO0FBQ1osZUFBTyxLQUFLOztNQUdkLGdCQUFnQjtBQUNkLGVBQU8sS0FBSzs7WUFHUixTQUFTLFVBQVM7QUFDdEIsWUFBSTtBQUVKLGNBQU0sMkJBQTJCLEtBQUs7QUFFdEMsaUJBQVEsTUFBTSxtQkFBbUI7QUFFakMsZUFBTyxNQUFNLEtBQUssV0FBVyxTQUFTO0FBRXRDLGFBQUssU0FBUyxPQUFPLE1BQU07QUFFM0IsY0FBTSxhQUFhLEtBQUs7QUFFeEIsaUJBQVEsTUFBTSxxQkFBcUIscURBQXFEO0FBRXhGLGVBQU87O09BR0YsY0FsQ2EsSUFrQ2IsUUFBTyx1QkFsQ007Ozs7QUNOdEI7Ozs7O21DQVFBLFdBQUE7OztlQUFBOzs7OztBQUZBLFFBQU0sQ0FBRSxnQkFBaUIsZ0JBQUE7QUFOekI7UUFRQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUFrQyxnQkFBQSxRQUFPO01BQzdELFlBQVksVUFBUyxRQUFRLE1BQU0sT0FBTztBQUN4QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLFFBQVE7O01BR2YsV0FBVztBQUNULGVBQU8sS0FBSzs7WUFHUixTQUFTLFVBQVM7QUFDdEIsY0FBTSxLQUFLLE1BQU07QUFFakIsY0FBTSw0QkFBNEIsS0FBSztBQUV2QyxpQkFBUSxNQUFNLG1CQUFtQjtBQUVqQyxjQUFNLGFBQWEsS0FBSyxPQUFPLE9BQU8sdUJBQUE7QUFDcEMsZ0JBQU0sbUJBQW1CLFNBQVM7O0FBR3BDLGlCQUFRLE1BQU0scUJBQXFCOztPQUc5QixjQXpCYSxJQXlCYixRQUFPLHdCQXpCTTs7OztBQ1J0Qjs7Ozs7bUNBTUEsV0FBQTs7O2VBQUE7Ozs7O0FBTkE7UUFNQSxXQUFlLElBQUEsVUFBQSxRQUFPLG9CQUFtQyxnQkFBQSxRQUFPO01BQzlELFlBQVksVUFBUyxRQUFRLE1BQU0sV0FBVztBQUM1QyxjQUFNLFVBQVMsUUFBUTtBQUV2QixhQUFLLFNBQVM7QUFDZCxhQUFLLFlBQVk7O01BR25CLGVBQWU7QUFDYixlQUFPLEtBQUs7O01BR2QsT0FBTyxVQUFTO0FBQ2QsY0FBTSxXQUFXO0FBRWpCLGNBQU0sNkJBQTZCLEtBQUs7QUFFeEMsaUJBQVEsTUFBTSxrQkFBa0I7QUFFaEMsY0FBTSxZQUFZLEtBQUs7QUFFdkIsaUJBQVEsYUFBYTtBQUVyQixZQUFJLFVBQVU7QUFDWixtQkFBUSxNQUFNLG9CQUFvQjs7QUFHcEMsZUFBTzs7T0FHRixjQTlCYSxJQThCYixRQUFPLHlCQTlCTTs7OztBQ050Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7QUFBTixvQ0FBMEIsZUFBQSxZQUFlOzs7OztBQ0p4RDs7Ozs7Ozs7Ozs7OztVQWlDYSxnQ0FBQTtlQUFBOztVQUhBLDZCQUFBO2VBQUE7O1VBTkEsMkJBQUE7ZUFBQTs7VUFFQSw0QkFBQTtlQUFBOztVQWJBLHFCQUFBO2VBQUE7O1VBTEEsa0JBQUE7ZUFBQTs7VUFGQSxrQkFBQTtlQUFBOztVQVlBLHVCQUFBO2VBQUE7O1VBWEEsa0JBQUE7ZUFBQTs7VUFlQSx5QkFBQTtlQUFBOztVQU1BLDZCQUFBO2VBQUE7O1VBREEsNEJBQUE7ZUFBQTs7VUFKQSx5QkFBQTtlQUFBOztVQUhBLHdCQUFBO2VBQUE7O1VBSEEsdUJBQUE7ZUFBQTs7VUFMQSxxQkFBQTtlQUFBOztVQW1CQSw4QkFBQTtlQUFBOztVQVpBLHVCQUFBO2VBQUE7O1VBSEEsc0JBQUE7ZUFBQTs7VUFGQSxzQkFBQTtlQUFBOztVQVdBLDJCQUFBO2VBQUE7O1VBVUEsa0NBQUE7ZUFBQTs7VUExQkEsbUJBQUE7ZUFBQTs7VUFNQSxzQkFBQTtlQUFBOztVQU1BLHlCQUFBO2VBQUE7O1VBUUEsNkJBQUE7ZUFBQTs7VUExQkEsaUJBQUE7ZUFBQTs7VUFEQSxpQkFBQTtlQUFBOztVQUdBLGtCQUFBO2VBQUE7O1VBREEsaUJBQUE7ZUFBQTs7VUFNQSxvQkFBQTtlQUFBOztVQXdCQSxpQ0FBQTtlQUFBOztVQUZBLGdDQUFBO2VBQUE7O1VBckJBLHFCQUFBO2VBQUE7OztBQVROLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0saUJBQWlCO0FBQ3ZCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sbUJBQW1CO0FBQ3pCLFFBQU0sb0JBQW9CO0FBQzFCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0scUJBQXFCO0FBQzNCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sc0JBQXNCO0FBQzVCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sdUJBQXVCO0FBQzdCLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0seUJBQXlCO0FBQy9CLFFBQU0seUJBQXlCO0FBQy9CLFFBQU0seUJBQXlCO0FBQy9CLFFBQU0sMkJBQTJCO0FBQ2pDLFFBQU0sMkJBQTJCO0FBQ2pDLFFBQU0sNEJBQTRCO0FBQ2xDLFFBQU0sNEJBQTRCO0FBQ2xDLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sNkJBQTZCO0FBQ25DLFFBQU0sOEJBQThCO0FBQ3BDLFFBQU0sZ0NBQWdDO0FBQ3RDLFFBQU0sZ0NBQWdDO0FBQ3RDLFFBQU0saUNBQWlDO0FBQ3ZDLFFBQU0sa0NBQWtDOzs7O0FDbkMvQzs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLGlDQUF1QixnQkFBQSxnQkFBZTtNQUNuRCx5QkFBeUI7QUFDdkIsY0FBTSxXQUFXLFdBQUEsNEJBQ1gsc0JBQXNCLEtBQUssa0JBQWtCO0FBRW5ELGVBQU87O01BR1QsMEJBQTBCO0FBQ3hCLGNBQU0sV0FBVyxXQUFBLDZCQUNYLHVCQUF1QixLQUFLLGtCQUFrQjtBQUVwRCxlQUFPOztNQUdULDZCQUE2QjtBQUMzQixjQUFNLFdBQVcsV0FBQSxnQ0FDWCwwQkFBMEIsS0FBSyxrQkFBa0I7QUFFdkQsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sZ0JBQUEsZ0JBQWdCLDJDQUEyQyxVQUFVLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUM1QjVNOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7O0FBQU4saUNBQXVCLGdCQUFBLGdCQUFlO01BQ25ELGtCQUFrQjtBQUNoQixjQUFNLFdBQVcsV0FBQSxvQkFDWCxnQkFBZ0IsS0FBSyxrQkFBa0I7QUFFN0MsZUFBTzs7TUFHVCw0QkFBNEI7QUFDMUIsY0FBTSxXQUFXLFdBQUEsK0JBQ1gseUJBQXlCLEtBQUssa0JBQWtCO0FBRXRELGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsVUFBVSxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDckI1TTs7Ozs7bUNBV0EsV0FBQTs7O2VBQXFCOzs7OztBQUFOLGlDQUF1QixnQkFBQSxnQkFBZTtNQUNuRCxrQkFBa0I7QUFDaEIsY0FBTSxXQUFXLFdBQUEsb0JBQ1gsZUFBZSxLQUFLLGtCQUFrQjtBQUU1QyxlQUFPOztNQUdULG1CQUFtQjtBQUNqQixjQUFNLFdBQVcsV0FBQSxxQkFDWCxnQkFBZ0IsS0FBSyxrQkFBa0I7QUFFN0MsZUFBTzs7TUFHVCxxQkFBcUI7QUFDbkIsY0FBTSxXQUFXLFdBQUEsd0JBQ1gsa0JBQWtCLEtBQUssa0JBQWtCO0FBRS9DLGVBQU87O01BR1QscUJBQXFCO0FBQ25CLGNBQU0sV0FBVyxXQUFBLHdCQUNYLHNCQUFzQixLQUFLLGtCQUFrQjtBQUVuRCxlQUFPOztNQUdULHVCQUF1QjtBQUNyQixjQUFNLFdBQVcsV0FBQSwwQkFDWCx3QkFBd0IsS0FBSyxrQkFBa0I7QUFFckQsZUFBTzs7TUFHVCx3QkFBd0I7QUFDdEIsY0FBTSxXQUFXLFdBQUEsMkJBQ1gsaUJBQWlCLEtBQUssa0JBQWtCO0FBRTlDLGVBQU87O2FBR0YsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUNsRyxZQUFJLGVBQWUsUUFBVztBQUM1Qix1QkFBYTtBQUViLG9CQUFVO0FBRVYsdUJBQWE7QUFFYixxQkFBVztBQUVYLGtCQUFROztBQUdWLGNBQU0sV0FBVyxnQkFBQSxnQkFBZ0IsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVM7QUFFbEgsZUFBTzs7Ozs7O0FDckVYOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7O0FBQU4saUNBQXVCLGdCQUFBLGdCQUFlO01BQ25ELGVBQWU7QUFDYixjQUFNLFdBQVcsV0FBQSxnQkFDWCxZQUFZLEtBQUssbUJBQW1CO0FBRTFDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsVUFBVSxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDZDVNOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7O0FBQU4sa0NBQXdCLGdCQUFBLGdCQUFlO01BQ3BELGtCQUFrQjtBQUNoQixjQUFNLFdBQVcsV0FBQSxvQkFDWCxlQUFlLEtBQUssa0JBQWtCO0FBRTVDLGVBQU87O01BR1QsNEJBQTRCO0FBQzFCLGNBQU0sV0FBVyxXQUFBLCtCQUNYLHlCQUF5QixLQUFLLGtCQUFrQjtBQUV0RCxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLFdBQVcsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ3JCN007Ozs7Ozs7Ozs7Ozs7VUFPYSxxQkFBQTtlQUFBOztVQUpBLGtCQUFBO2VBQUE7O1VBQ0Esa0JBQUE7ZUFBQTs7VUFDQSxvQkFBQTtlQUFBOztVQUNBLHFCQUFBO2VBQUE7O1VBRUEsNEJBQUE7ZUFBQTs7VUFOQSxrQkFBQTtlQUFBOzs7QUFBTixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLGtCQUFrQjtBQUN4QixRQUFNLG9CQUFvQjtBQUMxQixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLHFCQUFxQjtBQUMzQixRQUFNLDRCQUE0Qjs7OztBQ1J6Qzs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLGtDQUF3QixnQkFBQSxnQkFBZTtNQUNwRCxVQUFVO0FBQ1IsWUFBSTtBQUVKLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsaUJBQUE7QUFDckIsZ0JBQU0sVUFBVSxhQUFhO0FBRTdCLGlCQUFPO0FBRVAsaUJBQU87V0FDTjtBQUVILGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsV0FBVyxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDdkI3TTs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4sa0NBQXdCLGdCQUFBLGdCQUFlO2FBQzdDLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLFdBQVcsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ0w3TTs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLG1DQUF5QixnQkFBQSxnQkFBZTtNQUNyRCxrQkFBa0I7QUFDaEIsY0FBTSxXQUFXLFdBQUEsb0JBQ1gsZUFBZSxLQUFLLGtCQUFrQjtBQUU1QyxlQUFPOztNQUdULG9CQUFvQjtBQUNsQixjQUFNLFdBQVcsV0FBQSxzQkFDWCxpQkFBaUIsS0FBSyxrQkFBa0I7QUFFOUMsZUFBTzs7TUFHVCw0QkFBNEI7QUFDMUIsY0FBTSxXQUFXLFdBQUEsK0JBQ1gseUJBQXlCLEtBQUssa0JBQWtCO0FBRXRELGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsWUFBWSxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDNUI5TTs7Ozs7bUNBU0EsV0FBQTs7O2VBQXFCOzs7Ozs7QUFGckIsUUFBTSxDQUFFLGVBQU8sVUFBVyxXQUFBO0FBRVgsb0NBQTBCLGdCQUFBLGdCQUFlO01BQ3RELGNBQWM7QUFDWixjQUFNLFdBQVcsV0FBQSxnQkFDWCxXQUFXLEtBQUssa0JBQWtCO0FBRXhDLGVBQU87O01BR1QscUJBQXFCO0FBQ25CLGNBQU0sV0FBVyxXQUFBLHNCQUNYLGtCQUFrQixLQUFLLG1CQUFtQjtBQUVoRCxlQUFPOztNQUdULHNCQUFzQjtBQUNwQixjQUFNLHNCQUFzQixLQUFLLDBCQUMzQixtQkFBbUI7QUFFekIsZUFBTzs7TUFHVCx3QkFBd0I7QUFDdEIsY0FBTSx1QkFBdUIsS0FBSywyQkFDNUIscUJBQXFCO0FBRTNCLGVBQU87O01BR1QseUJBQXlCO0FBQ3ZCLGNBQU0sa0JBQWtCLEtBQUssc0JBQ3ZCLHNCQUFzQixPQUFNO0FBRWxDLGVBQU87O01BR1QsMEJBQTBCO0FBQ3hCLGNBQU0sa0JBQWtCLEtBQUssc0JBQ3ZCLHVCQUF1QixPQUFPO0FBRXBDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsYUFBYSxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDcEQvTTs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4scUNBQTJCLGdCQUFBLGdCQUFlO2FBQ2hELDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLGNBQWMsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ0xoTjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLHFDQUEyQixnQkFBQSxnQkFBZTtNQUN2RCxVQUFVO0FBQ1IsWUFBSTtBQUVKLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsaUJBQUE7QUFDckIsZ0JBQU0sVUFBVSxhQUFhO0FBRTdCLGlCQUFPO0FBRVAsaUJBQU87V0FDTjtBQUVILGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsY0FBYyxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDdkJoTjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4scUNBQTJCLGdCQUFBLGdCQUFlO2FBQ2hELDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLGNBQWMsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ0xoTjs7Ozs7bUNBVUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7Ozs7O0FBQU4sc0NBQTRCLGdCQUFBLGdCQUFlO01BQ3hELFVBQVU7QUFDUixZQUFJO0FBRUosY0FBTSxPQUFPLEtBQUssV0FDWixTQUFTLEtBQUssYUFDZCxVQUFVLEtBQUssY0FDZixnQkFBZ0IsS0FBSztBQUUzQixZQUFJLE9BQU87bUJBRUEsU0FBUyxNQUFNO0FBQ3hCLGlCQUFPLE9BQUE7bUJBQ0UsV0FBVyxNQUFNO0FBQzFCLGlCQUFPLE9BQUE7bUJBQ0UsWUFBWSxNQUFNO0FBQzNCLGlCQUFPLE9BQUE7bUJBQ0Usa0JBQWtCLE1BQU07QUFDakMsaUJBQU8sT0FBQTs7QUFHVCxlQUFPOztNQUdULFdBQVc7QUFDVCxZQUFJO0FBRUosY0FBTSxPQUFPLEtBQUssV0FDWixTQUFTLEtBQUssYUFDZCxVQUFVLEtBQUssY0FDZixnQkFBZ0IsS0FBSztBQUUzQixZQUFJLE9BQU87bUJBRUEsU0FBUyxNQUFNO0FBQ3hCLGtCQUFRO21CQUNDLFdBQVcsTUFBTTtBQUMxQixrQkFBUTttQkFDQyxZQUFZLE1BQU07QUFDM0Isa0JBQVE7bUJBQ0Msa0JBQWtCLE1BQU07QUFDakMsa0JBQVE7O0FBR1YsZUFBTzs7TUFHVCxVQUFVO0FBQ1IsWUFBSSxPQUFPO0FBRVgsY0FBTSxZQUFZLFlBQUE7QUFFbEIsYUFBSyxpQkFBaUIsQ0FBQyxpQkFBQTtBQUNyQixnQkFBTSxVQUFVLGFBQWE7QUFFN0IsY0FBSSxZQUFZLFdBQUEsTUFBTTtBQUNwQixtQkFBTyxVQUFBO0FBRVAsbUJBQU87O1dBRVI7QUFFSCxlQUFPOztNQUdULFlBQVk7QUFDVixZQUFJLFNBQVM7QUFFYixjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QixjQUFJLFlBQVksV0FBQSxNQUFNO0FBQ3BCLHFCQUFTLE9BQU87QUFFaEIsbUJBQU87O1dBRVI7QUFFSCxlQUFPOztNQUdULGFBQWE7QUFDWCxZQUFJLFVBQVU7QUFFZCxjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QixjQUFJLFlBQVksV0FBQSxNQUFNO0FBQ3BCLHNCQUFVO0FBRVYsbUJBQU87O0FBR1QsY0FBSSxZQUFZLFdBQUEsT0FBTztBQUNyQixzQkFBVTtBQUVWLG1CQUFPOztXQUVSO0FBRUgsZUFBTzs7TUFHVCxtQkFBbUI7QUFDakIsWUFBSSxnQkFBZ0I7QUFFcEIsY0FBTSxZQUFZLFlBQUE7QUFFbEIsYUFBSyxpQkFBaUIsQ0FBQyxpQkFBQTtBQUNyQixnQkFBTSxVQUFVLGFBQWE7QUFFN0IsMEJBQWdCO0FBRWhCLGlCQUFPO1dBQ047QUFFSCxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLGVBQWUsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ3JJak47Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7QUFBTixzQ0FBNEIsZ0JBQUEsZ0JBQWU7TUFDeEQsVUFBVTtBQUNSLFlBQUk7QUFFSixjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QixpQkFBTztBQUVQLGlCQUFPO1dBQ047QUFFSCxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLGVBQWUsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ3ZCak47Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7QUFBTixxQ0FBMkIsZ0JBQUEsZ0JBQWU7TUFDdkQsVUFBVTtBQUNSLFlBQUksT0FBTztBQUVYLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsaUJBQUE7QUFDckIsZ0JBQU0sVUFBVSxhQUFhO0FBRTdCLGlCQUFPO0FBRVAsaUJBQU87V0FDTjtBQUVILGVBQU87O01BR1QsVUFBVTtBQUNSLFlBQUksT0FBTztBQUVYLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsaUJBQUE7QUFDckIsZ0JBQU0sVUFBVSxhQUFhO0FBRTdCLGlCQUFPO0FBRVAsaUJBQU87V0FDTjtBQUVILGVBQU87O2FBR0YsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUNsRyxZQUFJLGVBQWUsUUFBVztBQUM1Qix1QkFBYTtBQUViLG9CQUFVO0FBRVYsdUJBQWE7QUFFYixxQkFBVztBQUVYLGtCQUFROztBQUdWLGNBQU0sZ0JBQWdCLGdCQUFBLGdCQUFnQiwyQ0FBMkMsT0FBTyxVQUFVLFlBQVksU0FBUztBQUV2SCxlQUFPOzs7Ozs7QUN0RFg7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7OztBQUFOLHNDQUE0QixnQkFBQSxnQkFBZTtNQUN4RCxZQUFZO0FBQ1YsY0FBTSxnQkFBZ0IsS0FBSyxvQkFDckIsU0FBUyxJQUFBLGVBQUEseUJBQXdCO0FBRXZDLGVBQU87O01BR1QsbUJBQW1CO0FBQ2pCLFlBQUk7QUFFSixjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QiwwQkFBZ0I7QUFFaEIsaUJBQU87V0FDTjtBQUVILGVBQU87O01BR1Qsa0JBQWtCO0FBQ2hCLGNBQU0sV0FBVyxXQUFBLG9CQUNYLGVBQWUsS0FBSyxrQkFBa0I7QUFFNUMsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sZ0JBQUEsZ0JBQWdCLDJDQUEyQyxlQUFlLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUN2Q2pOOzs7OzttQ0FjQSxXQUFBOzs7ZUFBcUI7Ozs7O0FBQU4sdUNBQTZCLGdCQUFBLGdCQUFlO01BQ3pELGNBQWM7QUFDWixjQUFNLFdBQVcsV0FBQSxnQkFDWCxXQUFXLEtBQUssa0JBQWtCO0FBRXhDLGVBQU87O01BR1QsY0FBYztBQUNaLGNBQU0sV0FBVyxXQUFBLGdCQUNYLFdBQVcsS0FBSyxrQkFBa0I7QUFFeEMsZUFBTzs7TUFHVCxlQUFlO0FBQ2IsY0FBTSxXQUFXLFdBQUEsaUJBQ1gsWUFBWSxLQUFLLGtCQUFrQjtBQUV6QyxlQUFPOztNQUdULGdCQUFnQjtBQUNkLGNBQU0sV0FBVyxXQUFBLGtCQUNYLGFBQWEsS0FBSyxrQkFBa0I7QUFFMUMsZUFBTzs7TUFHVCxpQkFBaUI7QUFDZixjQUFNLFdBQVcsV0FBQSxtQkFDWCxjQUFjLEtBQUssa0JBQWtCO0FBRTNDLGVBQU87O01BR1QsbUJBQW1CO0FBQ2pCLGNBQU0sV0FBVyxXQUFBLHNCQUNYLGdCQUFnQixLQUFLLGtCQUFrQjtBQUU3QyxlQUFPOztNQUdULG9CQUFvQjtBQUNsQixjQUFNLFdBQVcsV0FBQSx1QkFDWCxpQkFBaUIsS0FBSyxrQkFBa0I7QUFFOUMsZUFBTzs7TUFHVCxxQkFBcUI7QUFDbkIsY0FBTSxXQUFXLFdBQUEsd0JBQ1gsa0JBQWtCLEtBQUssa0JBQWtCO0FBRS9DLGVBQU87O01BR1QsdUJBQXVCO0FBQ3JCLGNBQU0sV0FBVyxXQUFBLDBCQUNYLG9CQUFvQixLQUFLLGtCQUFrQjtBQUVqRCxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLGdCQUFnQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDOUVsTjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLHNDQUE0QixnQkFBQSxnQkFBZTtNQUN4RCxvQkFBb0I7QUFDbEIsY0FBTSxXQUFXLFdBQUEscUJBQ1gsaUJBQWlCLEtBQUssbUJBQW1CO0FBRS9DLGVBQU87O2FBR0YsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUNsRyxZQUFJLGVBQWUsUUFBVztBQUM1Qix1QkFBYTtBQUViLG9CQUFVO0FBRVYsdUJBQWE7QUFFYixxQkFBVztBQUVYLGtCQUFROztBQUdWLGNBQU0saUJBQWlCLGdCQUFBLGdCQUFnQiwyQ0FBMkMsT0FBTyxVQUFVLFlBQVksU0FBUztBQUV4SCxlQUFPOzs7Ozs7QUM3Qlg7Ozs7O21DQVFBLFdBQUE7OztlQUFxQjs7Ozs7OztBQUFOLHVDQUE2QixnQkFBQSxnQkFBZTtNQUN6RCxZQUFZO0FBQ1YsY0FBTSxnQkFBZ0IsS0FBSyxvQkFDckIsU0FBUyxJQUFBLGVBQUEseUJBQXdCO0FBRXZDLGVBQU87O01BR1QsbUJBQW1CO0FBQ2pCLFlBQUksZ0JBQWdCO0FBRXBCLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsaUJBQUE7QUFDckIsZ0JBQU0sVUFBVSxhQUFhO0FBRTdCLDBCQUFnQjtBQUVoQixpQkFBTztXQUNOO0FBRUgsZUFBTzs7TUFHVCxrQkFBa0I7QUFDaEIsY0FBTSxXQUFXLFdBQUEsb0JBQ1gsZUFBZSxLQUFLLGtCQUFrQjtBQUU1QyxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLGdCQUFnQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDdkNsTjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7OztBQUFOLHdDQUE4QixnQkFBQSxnQkFBZTtNQUMxRCxnQkFBZ0I7QUFDZCxjQUFNLGdCQUFnQixLQUFLLG9CQUNyQixzQkFBc0IsY0FBYyxRQUNwQyxjQUFlLHNCQUFzQjtBQUUzQyxlQUFPOztNQUdULGVBQWU7QUFDYixjQUFNLFdBQVcsV0FBQSxnQkFDWCxZQUFZLEtBQUssbUJBQW1CO0FBRTFDLGVBQU87O01BR1QsbUJBQW1CO0FBQ2pCLGNBQU0sV0FBVyxXQUFBLG9CQUNYLGdCQUFnQixLQUFLLG1CQUFtQjtBQUU1QyxlQUFPOztNQUdYLHlCQUF5QjtBQUN2QixjQUFNLFdBQVcsV0FBQSw0QkFDWCxrQkFBa0IsS0FBSyxrQkFBa0I7QUFFL0MsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sZ0JBQUEsZ0JBQWdCLDJDQUEyQyxpQkFBaUIsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ3BDbk47Ozs7O21DQVlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsZUFBTyxRQUFTLFdBQUE7QUFFVCx3Q0FBOEIsTUFBQSxRQUFRO01BQ25ELGNBQWM7QUFDWixZQUFJLFdBQVc7QUFFZixjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QixxQkFBVztBQUVYLGlCQUFPO1dBQ047QUFFSCxlQUFPOztNQUdULGVBQWU7QUFDYixjQUFNLFdBQVcsS0FBSyxlQUNoQixhQUFjLGFBQWEsV0FBQTtBQUVqQyxlQUFPOztNQUdULGdCQUFnQjtBQUNkLGNBQU0sV0FBVyxLQUFLLGVBQ2hCLGNBQWUsYUFBYSxXQUFBO0FBRWxDLGVBQU87O01BR1QsZUFBZTtBQUNiLGNBQU0sV0FBVyxXQUFBLGdCQUNYLFlBQVksS0FBSyxtQkFBbUI7QUFFMUMsZUFBTzs7TUFHVCxrQkFBa0I7QUFDaEIsY0FBTSxxQkFBcUIsS0FBSyxvQkFDMUIsZUFBZTtBQUVyQixlQUFPOztNQUdULG1CQUFtQjtBQUNqQixjQUFNLGVBQWUsS0FBSyxtQkFDcEIsZ0JBQWdCO0FBRXRCLGVBQU87O01BR1Qsa0JBQWtCO0FBQ2hCLGNBQU0sWUFBWSxLQUFLLGdCQUNqQixlQUFlLEtBQUs7QUFFMUIsZUFBTzs7TUFHVCxtQkFBbUI7QUFDakIsY0FBTSxZQUFZLEtBQUssZ0JBQ2pCLGdCQUFnQixPQUFNO0FBRTVCLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLE1BQUEsUUFBUywyQ0FBMkMsaUJBQWlCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUM5RTVNOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTix3Q0FBOEIsTUFBQSxRQUFRO01BQ25ELGNBQWM7QUFDWixjQUFNLFdBQVcsV0FBQSxnQkFDWCxXQUFXLEtBQUssa0JBQWtCO0FBRXhDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLE1BQUEsUUFBUywyQ0FBMkMsaUJBQWlCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNkNU07Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7QUFBTiwwQ0FBZ0MsZ0JBQUEsZ0JBQWU7TUFDNUQsZUFBZTtBQUNiLGNBQU0sV0FBVyxXQUFBLGlCQUNYLFlBQVksS0FBSyxrQkFBa0I7QUFFekMsZUFBTzs7TUFHVCxtQkFBbUI7QUFDakIsY0FBTSxXQUFXLFdBQUEscUJBQ1gsZ0JBQWdCLEtBQUssa0JBQWtCO0FBRTdDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsbUJBQW1CLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNyQnJOOzs7OzttQ0FNQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7QUFBTiwwQ0FBZ0MsTUFBQSxRQUFRO01BQ3JELGNBQWM7QUFDWixjQUFNLFdBQVcsV0FBQSxnQkFDWCxXQUFXLEtBQUssa0JBQWtCO0FBRXhDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLE1BQUEsUUFBUywyQ0FBMkMsbUJBQW1CLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNkOU07Ozs7O21DQVlBLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7OztBQUZyQixRQUFNLENBQUUsZUFBTyxVQUFXLFdBQUE7QUFFWCwyQ0FBaUMsTUFBQSxRQUFRO01BQ3RELFlBQVk7QUFDVixZQUFJLFVBQVU7QUFFZCxjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QixjQUFJLFlBQVksV0FBQSxjQUFjO0FBQzVCLHNCQUFVOztBQUdaLGlCQUFPO1dBQ047QUFFSCxlQUFPOztNQUdULGVBQWU7QUFDYixjQUFNLFdBQVcsV0FBQSxnQkFDWCxZQUFZLEtBQUssbUJBQW1CO0FBRTFDLGVBQU87O01BR1Qsa0JBQWtCO0FBQ2hCLGNBQU0sZ0JBQWdCLEtBQUssb0JBQ3JCLGVBQWU7QUFFckIsZUFBTzs7TUFHVCxtQkFBbUI7QUFDakIsY0FBTSxpQkFBaUIsS0FBSyxxQkFDdEIsZ0JBQWdCO0FBRXRCLGVBQU87O01BR1QsbUJBQW1CO0FBQ2pCLGNBQU0sWUFBWSxLQUFLLGdCQUNqQixnQkFBZ0IsT0FBTTtBQUU1QixlQUFPOztNQUdULG9CQUFvQjtBQUNsQixjQUFNLFlBQVksS0FBSyxnQkFDakIsaUJBQWlCLE9BQU87QUFFOUIsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sTUFBQSxRQUFTLDJDQUEyQyxvQkFBb0IsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ2xFL007Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLDBDQUFnQyxXQUFBLFFBQVk7TUFDekQsV0FBVztBQUNULFlBQUksUUFBUTtBQUVaLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsY0FBYyxVQUFBO0FBQ25DLGNBQUksVUFBVSxHQUFHO0FBQ2Ysa0JBQU0sVUFBVSxhQUFhO0FBRTdCLG9CQUFRO0FBRVIsbUJBQU87O1dBRVI7QUFFSCxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxXQUFBLFFBQWEsMkNBQTJDLG1CQUFtQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDekJsTjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sMkNBQWlDLFlBQUEsUUFBYTtNQUMzRCx5QkFBeUI7QUFDdkIsY0FBTSxXQUFXLFdBQUEsMkJBQ1gscUJBQXFCLEtBQUssbUJBQW1CO0FBRW5ELGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLFlBQUEsUUFBYywyQ0FBMkMsb0JBQW9CLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNkcE47Ozs7O21DQUlBLFdBQUE7OztlQUFxQjs7OztBQUFOLHNDQUE0QixnQkFBQSxnQkFBZTthQUNqRCwyQ0FBMkMsT0FBTyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxnQkFBQSxnQkFBZ0IsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ0xoTjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sNENBQWtDLFdBQUEsUUFBYTtNQUM1RCxjQUFjO0FBQ1osY0FBTSxXQUFXLFdBQUEsZ0JBQ1gsV0FBVyxLQUFLLGtCQUFrQjtBQUV4QyxlQUFPOzthQUdGLDJDQUEyQyxVQUFVLFlBQVksU0FBUyxZQUFZO0FBQUUsZUFBTyxXQUFBLFFBQWMsMkNBQTJDLHFCQUFxQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDZHJOOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7QUFBTix3Q0FBOEIsZ0JBQUEsZ0JBQWU7YUFDbkQsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sZ0JBQUEsZ0JBQWdCLDJDQUEyQyxPQUFPLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNMaE47Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLDRDQUFrQyxZQUFBLFFBQWU7TUFDOUQsa0JBQWtCO0FBQ2hCLGNBQU0sV0FBVyxXQUFBLG9CQUNYLGVBQWUsS0FBSyxrQkFBa0I7QUFFNUMsZUFBTzs7TUFHVCxvQkFBb0I7QUFDbEIsY0FBTSxXQUFXLFdBQUEsc0JBQ1gsaUJBQWlCLEtBQUssa0JBQWtCO0FBRTlDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLFlBQUEsUUFBZ0IsMkNBQTJDLHFCQUFxQixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDckJ2Tjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sNkNBQW1DLFlBQUEsUUFBZTtNQUMvRCxrQkFBa0I7QUFDaEIsY0FBTSxXQUFXLFdBQUEsb0JBQ1gsZUFBZSxLQUFLLGtCQUFrQjtBQUU1QyxlQUFPOztNQUdULHlCQUF5QjtBQUN2QixjQUFNLFdBQVcsV0FBQSw0QkFDWCxzQkFBc0IsS0FBSyxrQkFBa0I7QUFFbkQsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sWUFBQSxRQUFnQiwyQ0FBMkMsc0JBQXNCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNyQnhOOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7QUFBTixzQ0FBNEIsZ0JBQUEsZ0JBQWU7YUFDakQsMkNBQTJDLE9BQU8sVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sZ0JBQUEsZ0JBQWdCLDJDQUEyQyxPQUFPLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUNMaE47Ozs7O21DQU9BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7Ozs7QUFBTiwrQ0FBcUMsV0FBQSxRQUFhO01BQy9ELFVBQVU7QUFDUixZQUFJO0FBRUosY0FBTSxZQUFZLFlBQUE7QUFFbEIsYUFBSyxpQkFBaUIsQ0FBQyxpQkFBQTtBQUNyQixnQkFBTSxVQUFVLGFBQWE7QUFFN0IsaUJBQU87V0FDTjtBQUVILGVBQU87O01BR1Qsb0JBQW9CO0FBQ2xCLGNBQU0sV0FBVyxXQUFBLHNCQUNYLGlCQUFpQixLQUFLLGtCQUFrQjtBQUU5QyxlQUFPOztNQUdULHFCQUFxQjtBQUNuQixjQUFNLFdBQVcsV0FBQSx3QkFDWCxrQkFBa0IsS0FBSyxrQkFBa0I7QUFFL0MsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sV0FBQSxRQUFjLDJDQUEyQyx3QkFBd0IsVUFBVSxZQUFZLFNBQVM7Ozs7OztBQ3BDeE47Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLCtDQUFxQyxZQUFBLFFBQWU7TUFDakUsa0JBQWtCO0FBQ2hCLGNBQU0sV0FBVyxXQUFBLG9CQUNYLGVBQWUsS0FBSyxrQkFBa0I7QUFFNUMsZUFBTzs7TUFHVCxvQkFBb0I7QUFDbEIsY0FBTSxXQUFXLFdBQUEsc0JBQ1gsaUJBQWlCLEtBQUssa0JBQWtCO0FBRTlDLGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLFlBQUEsUUFBZ0IsMkNBQTJDLHdCQUF3QixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDckIxTjs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLGdEQUFzQyxZQUFBLFFBQWU7TUFDbEUsVUFBVTtBQUNSLFlBQUk7QUFFSixjQUFNLFlBQVksWUFBQTtBQUVsQixhQUFLLGlCQUFpQixDQUFDLGlCQUFBO0FBQ3JCLGdCQUFNLFVBQVUsYUFBYTtBQUU3QixpQkFBTztXQUNOO0FBRUgsZUFBTzs7TUFHVCw2QkFBNkI7QUFDM0IsY0FBTSxXQUFXLFdBQUEsK0JBQ1gsMkJBQTJCLEtBQUssbUJBQW1CO0FBRXpELGVBQU87O2FBR0YsMkNBQTJDLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLFlBQUEsUUFBZ0IsMkNBQTJDLHlCQUF5QixVQUFVLFlBQVksU0FBUzs7Ozs7O0FDN0IzTjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7O0FBQU4sd0NBQThCLGdCQUFBLGdCQUFlO2FBQ25ELDJDQUEyQyxPQUFPLFVBQVUsWUFBWSxTQUFTLFlBQVk7QUFBRSxlQUFPLGdCQUFBLGdCQUFnQiwyQ0FBMkMsT0FBTyxVQUFVLFlBQVksU0FBUzs7Ozs7O0FDTGhOOzs7OzttQ0FPQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7Ozs7O0FBQU4saURBQXVDLGFBQUEsUUFBZTtNQUNuRSxVQUFVO0FBQ1IsWUFBSTtBQUVKLGNBQU0sWUFBWSxZQUFBO0FBRWxCLGFBQUssaUJBQWlCLENBQUMsaUJBQUE7QUFDckIsZ0JBQU0sVUFBVSxhQUFhO0FBRTdCLGlCQUFPO1dBQ047QUFFSCxlQUFPOztNQUdULGVBQWU7QUFDYixjQUFNLFdBQVcsV0FBQSxpQkFDWCxZQUFZLEtBQUssa0JBQWtCO0FBRXpDLGVBQU87O01BR1Qsb0JBQW9CO0FBQ2xCLGNBQU0sV0FBVyxXQUFBLHNCQUNYLGlCQUFpQixLQUFLLGtCQUFrQjtBQUU5QyxlQUFPOztNQUdULHFCQUFxQjtBQUNuQixjQUFNLFdBQVcsV0FBQSx3QkFDWCxrQkFBa0IsS0FBSyxrQkFBa0I7QUFFL0MsZUFBTzs7YUFHRiwyQ0FBMkMsVUFBVSxZQUFZLFNBQVMsWUFBWTtBQUFFLGVBQU8sYUFBQSxRQUFnQiwyQ0FBMkMsMEJBQTBCLFVBQVUsWUFBWSxTQUFTOzs7Ozs7QUMzQzVOOzs7OzttQ0E2R0EsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFyQ0EsUUFBTSxxQkFBcUI7T0FDeEIsV0FBQSxpQkFBaUIsTUFBQTtPQUNqQixXQUFBLGlCQUFpQixNQUFBO09BQ2pCLFdBQUEsaUJBQWlCLE1BQUE7T0FDakIsV0FBQSxrQkFBa0IsT0FBQTtPQUNsQixXQUFBLGtCQUFrQixPQUFBO09BQ2xCLFdBQUEsa0JBQWtCLE9BQUE7T0FDbEIsV0FBQSxrQkFBa0IsT0FBQTtPQUNsQixXQUFBLG1CQUFtQixRQUFBO09BQ25CLFdBQUEsb0JBQW9CLFNBQUE7T0FDcEIsV0FBQSxxQkFBcUIsVUFBQTtPQUNyQixXQUFBLHFCQUFxQixVQUFBO09BQ3JCLFdBQUEscUJBQXFCLFVBQUE7T0FDckIsV0FBQSxzQkFBc0IsV0FBQTtPQUN0QixXQUFBLHNCQUFzQixXQUFBO09BQ3RCLFdBQUEsc0JBQXNCLFdBQUE7T0FDdEIsV0FBQSx1QkFBdUIsV0FBQTtPQUN2QixXQUFBLHVCQUF1QixZQUFBO09BQ3ZCLFdBQUEsdUJBQXVCLFlBQUE7T0FDdkIsV0FBQSx3QkFBd0IsWUFBQTtPQUN4QixXQUFBLHlCQUF5QixhQUFBO09BQ3pCLFdBQUEseUJBQXlCLFNBQUE7T0FDekIsV0FBQSx5QkFBeUIsU0FBQTtPQUN6QixXQUFBLDJCQUEyQixlQUFBO09BQzNCLFdBQUEsMkJBQTJCLFdBQUE7T0FDM0IsV0FBQSw0QkFBNEIsWUFBQTtPQUM1QixXQUFBLDRCQUE0QixPQUFBO09BQzVCLFdBQUEsNkJBQTZCLFFBQUE7T0FDN0IsV0FBQSw2QkFBNkIsUUFBQTtPQUM3QixXQUFBLDZCQUE2QixPQUFBO09BQzdCLFdBQUEsOEJBQThCLFFBQUE7T0FDOUIsV0FBQSxnQ0FBZ0MsVUFBQTtPQUNoQyxXQUFBLGdDQUFnQyxXQUFBO09BQ2hDLFdBQUEsaUNBQWlDLFdBQUE7T0FDakMsV0FBQSxrQ0FBa0MsV0FBQTs7UUFHckMsV0FBZTs7OztBQzdHZjs7Ozs7bUNBUUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7OztBQUFOLHFDQUEyQixlQUFBLGFBQWdCOztBQUNqRCxrQkFETSxjQUNOLHNCQUFxQixvQkFBQTtBQUVyQixrQkFITSxjQUdOLDBCQUF5QixnQkFBQTs7OztBQ1hsQzs7Ozs7Ozs7Ozs7OztVQWd5QmdCLDhCQUFBO2VBQUE7O1VBdllBLCtDQUFBO2VBQUE7O1VBOGhCQSxrQ0FBQTtlQUFBOztVQThDQSxtQ0FBQTtlQUFBOztVQWhJQSxpQ0FBQTtlQUFBOztVQTVmQSx5Q0FBQTtlQUFBOztVQXdaQSw4QkFBQTtlQUFBOztVQW1SQSxxQ0FBQTtlQUFBOztVQXpWQSw0QkFBQTtlQUFBOztVQWlYQSx1Q0FBQTtlQUFBOztVQTlWQSw2QkFBQTtlQUFBOztVQWtMQSxpQ0FBQTtlQUFBOztVQTlDQSxnQ0FBQTtlQUFBOztVQXJ2QkEscUJBQUE7ZUFBQTs7VUFZQSxxQkFBQTtlQUFBOztVQTBlQSwwQkFBQTtlQUFBOztVQXZVQSwrQkFBQTtlQUFBOztVQThYQSwyQkFBQTtlQUFBOztVQStXQSxvQ0FBQTtlQUFBOztVQXFDQSx1Q0FBQTtlQUFBOztVQXBVQSw2QkFBQTtlQUFBOztVQW1EQSw4QkFBQTtlQUFBOztVQWlMQSxrQ0FBQTtlQUFBOztVQXQwQkEscUJBQUE7ZUFBQTs7VUE4NEJBLG9DQUFBO2VBQUE7O1VBN0lBLGlDQUFBO2VBQUE7O1VBL0hBLDhCQUFBO2VBQUE7O1VBd0pBLGlDQUFBO2VBQUE7O1VBdlNBLDBCQUFBO2VBQUE7O1VBcEtBLG9CQUFBO2VBQUE7O1VBNlNBLDZCQUFBO2VBQUE7O1VBeE9BLHdCQUFBO2VBQUE7O1VBTUEsd0JBQUE7ZUFBQTs7VUEzQ0EsdUJBQUE7ZUFBQTs7VUE1SkEsdUNBQUE7ZUFBQTs7VUFlQSx5Q0FBQTtlQUFBOztVQTBDQSwwQ0FBQTtlQUFBOztVQXF3QkEsNkNBQUE7ZUFBQTs7VUE3VEEsZ0NBQUE7ZUFBQTs7VUEwREEsaUNBQUE7ZUFBQTs7VUF2U0EsMEJBQUE7ZUFBQTs7VUFxTEEsOEJBQUE7ZUFBQTs7VUFoa0JBLDZCQUFBO2VBQUE7O1VBcW1CQSwrQkFBQTtlQUFBOztVQXprQkEsK0JBQUE7ZUFBQTs7VUE0bkJBLGlDQUFBO2VBQUE7O1VBamVBLDJDQUFBO2VBQUE7O1VBa2FBLCtCQUFBO2VBQUE7O1VBNW1CQSw2QkFBQTtlQUFBOztVQW8yQkEsdUNBQUE7ZUFBQTs7VUF0Q0Esb0NBQUE7ZUFBQTs7VUFqd0JBLCtCQUFBO2VBQUE7O1VBKzBCQSx5Q0FBQTtlQUFBOztVQWlEQSxtQ0FBQTtlQUFBOztVQTU1QkEsNkJBQUE7ZUFBQTs7VUFpUkEsd0JBQUE7ZUFBQTs7VUFrZEEsa0NBQUE7ZUFBQTs7VUF4b0JBLHFDQUFBO2VBQUE7O1VBNEhBLG1EQUFBO2VBQUE7O1VBc29CQSx3Q0FBQTtlQUFBOztVQWxnQkEseUJBQUE7ZUFBQTs7VUFjQSwwQkFBQTtlQUFBOztVQXNFQSwyQkFBQTtlQUFBOztVQTVnQkEsdUJBQUE7ZUFBQTs7VUE2dUJBLGlDQUFBO2VBQUE7O1VBOXJCQSw2QkFBQTtlQUFBOztVQW80QkEsd0NBQUE7ZUFBQTs7VUEvTkEsZ0NBQUE7ZUFBQTs7VUFpUUEsMENBQUE7ZUFBQTs7VUE3eUJBLGlDQUFBO2VBQUE7O1VBZ3VCQSxxQ0FBQTtlQUFBOztVQXRwQkEseUNBQUE7ZUFBQTs7VUEwbEJBLGtDQUFBO2VBQUE7O1VBNUlBLCtCQUFBO2VBQUE7O1VBcFJBLHlCQUFBO2VBQUE7O1VBN2dCQSxtQkFBQTtlQUFBOztVQWZBLG1CQUFBO2VBQUE7O1VBd29CQSwyQkFBQTtlQUFBOztVQTBDQSw0QkFBQTtlQUFBOztVQWxLQSx5QkFBQTtlQUFBOztVQThGQSwwQkFBQTtlQUFBOztVQW1LQSw4QkFBQTtlQUFBOztVQW52QkEsbUJBQUE7ZUFBQTs7VUEwWkEsc0JBQUE7ZUFBQTs7VUF1cUJBLDBCQUFBO2VBQUE7O1VBN1lBLDZCQUFBO2VBQUE7O1VBenBCQSxxQkFBQTtlQUFBOztVQWltQkEsNEJBQUE7ZUFBQTs7VUExaEJBLHlCQUFBO2VBQUE7O1VBa2VBLDBCQUFBO2VBQUE7O1VBdUhBLDZCQUFBO2VBQUE7O1VBakhBLDBCQUFBO2VBQUE7O1VBdkhBLHdCQUFBO2VBQUE7O1VBa0JBLHdCQUFBO2VBQUE7O1VBNGpCQSwwQ0FBQTtlQUFBOztVQWpHQSxtQ0FBQTtlQUFBOztVQXBCQSxrQ0FBQTtlQUFBOztVQWxmQSx1QkFBQTtlQUFBOztVQXdGQSx5QkFBQTtlQUFBOztVQW1pQkEsc0RBQUE7ZUFBQTs7VUEyQ0EsNkRBQUE7ZUFBQTs7VUF4T0Esa0NBQUE7ZUFBQTs7VUFsZ0JBLGlEQUFBO2VBQUE7O1VBK2lCQSxrQ0FBQTtlQUFBOztVQXpkQSx3QkFBQTtlQUFBOztVQXlLQSw0QkFBQTtlQUFBOztVQXdEQSw2QkFBQTtlQUFBOztVQTRRQSxtQ0FBQTtlQUFBOztVQTljQSx5QkFBQTtlQUFBOztVQTFFQSx1QkFBQTtlQUFBOztVQU9BLHVCQUFBO2VBQUE7O1VBc29CQSw0Q0FBQTtlQUFBOztVQWxNQSxrQ0FBQTtlQUFBOztVQTF2QkEsMkJBQUE7ZUFBQTs7Ozs7Ozs7Ozs7O0FBaEpULDhCQUEwQixVQUFVLFVBQU87QUFDaEQsWUFBTSxDQUFFLFFBQVMsVUFBQSxTQUNYLE9BQU8sVUFDUCxTQUFTLFNBQVEsYUFBYSxPQUM5QixrQkFBa0IsNEJBQTRCLFVBQVUsV0FDeEQsa0JBQWtCLDZCQUE2QixVQUFVLFdBQ3pELHVCQUF1QixnQ0FBZ0MsVUFBVTtBQUV2RSxpQkFBVTtBQUVWLFlBQU0sT0FBTyxJQUFJLEtBQUssVUFBUyxRQUFRLE1BQU0saUJBQWlCLGlCQUFpQjtBQUUvRSxhQUFPOztBQUdGLDhCQUEwQixVQUFVLFVBQU87QUFDaEQsWUFBTSxDQUFFLFFBQVMsVUFBQSxTQUNYLE9BQU8sVUFDUCxXQUFXLHFCQUFxQixVQUFVLFdBQzFDLHFCQUFxQiwrQkFBK0IsVUFBVSxXQUM5RCxhQUFhLElBQUEsUUFBQSw2Q0FBNEMsVUFBVSxxQkFDbkUsU0FBUztBQUVmLGlCQUFVO0FBRVYsWUFBTSxPQUFPLElBQUksS0FBSyxVQUFTLFFBQVEsTUFBTSxVQUFVO0FBRXZELGFBQU87O0FBR0YsOEJBQTBCLFVBQVUsVUFBTztBQUNoRCxZQUFNLENBQUUsUUFBUyxVQUFBLFNBQ1gsT0FBTyxVQUNQLFdBQVcscUJBQXFCLFVBQVUsV0FDMUMsWUFBWSxzQkFBc0IsVUFBVSxXQUM1QyxjQUFjLHdCQUF3QixVQUFVLFdBQ2hELGNBQWMsd0JBQXdCLFVBQVUsV0FDaEQsZ0JBQWdCLDBCQUEwQixVQUFVLFdBQ3BELGlCQUFpQiwyQkFBMkIsVUFBVSxXQUN0RCxhQUFhO1FBQ1g7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1NBRUYsYUFBYSxJQUFBLFFBQUEsMEJBQXlCLFlBQVksV0FDbEQsU0FBUztBQUVmLGlCQUFVO0FBRVYsWUFBTSxPQUFPLElBQUksS0FBSyxVQUFTLFFBQVEsTUFBTSxVQUFVLFdBQVcsYUFBYSxhQUFhLGVBQWU7QUFFM0csYUFBTzs7QUFHRixnQ0FBNEIsV0FBVyxVQUFPO0FBQ25ELFlBQU0sQ0FBRSxTQUFVLFVBQUEsU0FDWixPQUFPLFdBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsWUFBWSxVQUFVLGdCQUN0QixhQUFhLHdCQUF3QixXQUFXLFdBQ2hELFFBQVE7QUFFZCxpQkFBVTtBQUVWLFlBQU0sUUFBUSxJQUFJLE1BQU0sVUFBUyxRQUFRLE1BQU07QUFFL0MsYUFBTzs7QUFHRixnQ0FBNEIsV0FBVyxVQUFPO0FBQ25ELFlBQU0sQ0FBRSxpQkFBVSxVQUFBLFNBQ1osT0FBTyxXQUNQLFNBQVMsU0FBUSxhQUFhO0FBRXBDLGlCQUFVO0FBRVYsWUFBTSxRQUFRLElBQUksT0FBTSxVQUFTLFFBQVE7QUFFekMsYUFBTzs7QUFHRixnQ0FBNEIsV0FBVyxVQUFPO0FBQ25ELFlBQU0sQ0FBRSxTQUFVLFVBQUEsU0FDWixPQUFPLFdBQ1AsV0FBVyxzQkFBc0IsV0FBVyxXQUM1QyxxQkFBcUIsZ0NBQWdDLFdBQVcsV0FDaEUsY0FBYyxJQUFBLFFBQUEsOENBQTZDLFVBQVUscUJBQ3JFLFNBQVM7QUFFZixpQkFBVTtBQUVWLFlBQU0sUUFBUSxJQUFJLE1BQU0sVUFBUyxRQUFRLE1BQU0sVUFBVTtBQUV6RCxhQUFPOztBQUdGLGdDQUE0QixXQUFXLFVBQU87QUFDbkQsWUFBTSxDQUFFLFNBQVUsVUFBQSxTQUNaLE9BQU8sV0FDUCxTQUFTLFNBQVEsYUFBYSxPQUM5QixPQUFPLGtCQUFrQixXQUFXO0FBRTFDLGlCQUFVO0FBRVYsWUFBTSxRQUFRLElBQUksTUFBTSxVQUFTLFFBQVEsTUFBTTtBQUUvQyxhQUFPOztBQUdGLGtDQUE4QixZQUFZLFVBQU87QUFDdEQsWUFBTSxDQUFFLFVBQVcsVUFBQSxTQUNiLE9BQU8sWUFDUCxXQUFXLHVCQUF1QixZQUFZLFdBQzlDLG9CQUFvQixnQ0FBZ0MsWUFBWSxXQUNoRSxxQkFBcUIsaUNBQWlDLFlBQVksV0FDbEUsZUFBZSxJQUFBLFFBQUEsZ0VBQStELFVBQVUsbUJBQW1CLHFCQUMzRyxTQUFTO0FBRWYsaUJBQVU7QUFFVixZQUFNLFNBQVMsSUFBSSxPQUFPLFVBQVMsUUFBUSxNQUFNLFVBQVUsbUJBQW1CO0FBRTlFLGFBQU87O0FBR0Ysb0NBQWdDLGFBQWEsVUFBTztBQUN6RCxZQUFNLENBQUUsV0FBWSxVQUFBLFNBQ2QsT0FBTyxhQUNQLE9BQU8sb0JBQW9CLGFBQWEsV0FDeEMsZUFBZSw0QkFBNEIsYUFBYSxXQUN4RCxpQkFBaUIsOEJBQThCLGFBQWEsV0FDNUQsZ0JBQWdCLElBQUEsUUFBQSx1QkFBc0IsT0FDdEMsU0FBUztBQUVmLGlCQUFVO0FBRVYsWUFBTSxVQUFVLElBQUksUUFBUSxVQUFTLFFBQVEsTUFBTSxNQUFNLGNBQWM7QUFFdkUsYUFBTzs7QUFHRixzQ0FBa0MsY0FBYyxVQUFPO0FBQzVELFlBQU0sQ0FBRSxZQUFhLFVBQUEsU0FDZixPQUFPLGNBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsT0FBTyxxQkFBcUIsY0FBYyxXQUMxQyxPQUFPLHFCQUFxQixjQUFjLFdBQzFDLGFBQWEsMkJBQTJCLGNBQWM7QUFFNUQsaUJBQVU7QUFFVixZQUFNLFdBQVcsSUFBSSxTQUFTLFVBQVMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUVqRSxhQUFPOztBQUdGLHdDQUFvQyxlQUFlLFVBQU87QUFDL0QsWUFBTSxDQUFFLGFBQWMsVUFBQSxTQUNoQixPQUFPLGVBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsT0FBTyxzQkFBc0IsZUFBZTtBQUVsRCxpQkFBVTtBQUVWLFlBQU0sWUFBWSxJQUFJLFVBQVUsVUFBUyxRQUFRLE1BQU07QUFFdkQsYUFBTzs7QUFHRix3Q0FBb0MsZUFBZSxVQUFPO0FBQy9ELFVBQUksWUFBWTtBQUVoQixZQUFNLE9BQU8sc0JBQXNCLGVBQWU7QUFFbEQsVUFBSSxTQUFTLE1BQU07QUFDakIsY0FBTSxDQUFFLGFBQWMsVUFBQSxTQUNoQixPQUFPLGVBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsT0FBTyxzQkFBc0IsZUFBZTtBQUVsRCxtQkFBVTtBQUVWLG9CQUFZLElBQUksVUFBVSxVQUFTLFFBQVEsTUFBTSxNQUFNOztBQUd6RCxhQUFPOztBQUdGLHdDQUFvQyxlQUFlLFVBQU87QUFDL0QsWUFBTSxDQUFFLGFBQWMsVUFBQSxTQUNoQixPQUFPLGVBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsV0FBVywwQkFBMEIsZUFBZSxXQUNwRCxRQUFRLHVCQUF1QixlQUFlO0FBRXBELGlCQUFVO0FBRVYsWUFBTSxZQUFZLElBQUksVUFBVSxVQUFTLFFBQVEsTUFBTSxVQUFVO0FBRWpFLGFBQU87O0FBR0Ysd0NBQW9DLGVBQWUsVUFBTztBQUMvRCxZQUFNLENBQUUsYUFBYyxVQUFBLFNBQ2hCLE9BQU8sZUFDUCxTQUFTLFNBQVEsYUFBYSxPQUM5QixPQUFPLHNCQUFzQixlQUFlLFdBQzVDLFFBQVEsdUJBQXVCLGVBQWU7QUFFcEQsaUJBQVU7QUFFVixZQUFNLFlBQVksSUFBSSxVQUFVLFVBQVMsUUFBUSxNQUFNLE1BQU07QUFFN0QsYUFBTzs7QUFHRiwwQ0FBc0MsZ0JBQWdCLFVBQU87QUFDbEUsWUFBTSxDQUFFLGNBQWUsVUFBQSxTQUNqQixPQUFPLGdCQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLFdBQVcsMkJBQTJCLGdCQUFnQixXQUN0RCxRQUFRLHdCQUF3QixnQkFBZ0I7QUFFdEQsaUJBQVU7QUFFVixZQUFNLGFBQWEsSUFBSSxXQUFXLFVBQVMsUUFBUSxNQUFNLFVBQVU7QUFFbkUsYUFBTzs7QUFHRiwwQ0FBc0MsZ0JBQWdCLFVBQU87QUFDbEUsWUFBTSxDQUFFLGNBQWUsVUFBQSxTQUNqQixPQUFPLGdCQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLGlCQUFpQixpQ0FBaUMsZ0JBQWdCLFdBQ2xFLFFBQVE7QUFFZCxpQkFBVTtBQUVWLFlBQU0sYUFBYSxJQUFJLFdBQVcsVUFBUyxRQUFRLE1BQU07QUFFekQsYUFBTzs7QUFHRiwwQ0FBc0MsZ0JBQWdCLFVBQU87QUFDbEUsWUFBTSxDQUFFLGNBQWUsVUFBQSxTQUNqQixPQUFPLGdCQUNQLE9BQU8sdUJBQXVCLGdCQUFnQixXQUM5QyxPQUFPLHVCQUF1QixnQkFBZ0IsV0FDOUMsUUFBUSx3QkFBd0IsZ0JBQWdCLFdBQ2hELFNBQVMseUJBQXlCLGdCQUFnQixXQUNsRCxVQUFVLDBCQUEwQixnQkFBZ0IsV0FDcEQsWUFBWSw0QkFBNEIsZ0JBQWdCLFdBQ3hELGFBQWEsNkJBQTZCLGdCQUFnQixXQUMxRCxjQUFjLDhCQUE4QixnQkFBZ0IsV0FDNUQsZ0JBQWdCLGdDQUFnQyxnQkFBZ0IsV0FDaEUsYUFBYTtRQUNYO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtTQUVGLG1CQUFtQixJQUFBLFFBQUEsZ0NBQStCLFlBQVksV0FDOUQsU0FBUztBQUVmLGlCQUFVO0FBRVYsWUFBTSxhQUFhLElBQUksV0FBVyxVQUFTLFFBQVEsTUFBTSxNQUFNLE1BQU0sT0FBTyxRQUFRLFNBQVMsV0FBVyxZQUFZLGFBQWE7QUFFakksYUFBTzs7QUFHRiw0Q0FBd0MsaUJBQWlCLFVBQU87QUFDckUsWUFBTSxDQUFFLGVBQWdCLFVBQUEsU0FDbEIsT0FBTyxpQkFDUCxRQUFRLHlCQUF5QixpQkFBaUIsV0FDbEQsY0FBYywrQkFBK0IsaUJBQWlCLFdBQzlELGtCQUFrQixtQ0FBbUMsaUJBQWlCLFdBQ3RFLG9CQUFvQixJQUFBLFFBQUEsMENBQXlDLGtCQUM3RCxTQUFTO0FBRWYsaUJBQVU7QUFFVixZQUFNLGNBQWMsSUFBSSxZQUFZLFVBQVMsUUFBUSxNQUFNLE9BQU8sYUFBYTtBQUUvRSxhQUFPOztBQUdGLGdEQUE0QyxtQkFBbUIsVUFBTztBQUMzRSxZQUFNLENBQUUsaUJBQWtCLFVBQUEsU0FDcEIsT0FBTyxtQkFDUCxTQUFTLFNBQVEsYUFBYSxPQUM5QixZQUFZLCtCQUErQixtQkFBbUIsV0FDOUQsUUFBUSwyQkFBMkIsbUJBQW1CO0FBRTVELGlCQUFVO0FBRVYsWUFBTSxnQkFBZ0IsSUFBSSxjQUFjLFVBQVMsUUFBUSxNQUFNLFdBQVc7QUFFMUUsYUFBTzs7QUFHRixrREFBOEMsb0JBQW9CLFVBQU87QUFDOUUsWUFBTSxDQUFFLGtCQUFtQixVQUFBLFNBQ3JCLE9BQU8sb0JBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsT0FBTywyQkFBMkIsb0JBQW9CLFdBQ3RELE9BQU8sMkJBQTJCLG9CQUFvQixXQUN0RCxRQUFRLDRCQUE0QixvQkFBb0I7QUFFOUQsaUJBQVU7QUFFVixZQUFNLGlCQUFpQixJQUFJLGVBQWUsVUFBUyxRQUFRLE1BQU0sTUFBTSxNQUFNO0FBRTdFLGFBQU87O0FBR0Ysb0RBQWdELHFCQUFxQixVQUFPO0FBQ2pGLFlBQU0sQ0FBRSxtQkFBb0IsVUFBQSxTQUN0QixPQUFPLHFCQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLHNCQUFzQixvQkFBb0IsMEJBQzFDLHVCQUF1QiwyQ0FBMkMscUJBQXFCLFdBQ3ZGLFFBQVE7QUFFZCxpQkFBVTtBQUVWLFlBQU0sa0JBQWtCLElBQUksZ0JBQWdCLFVBQVMsUUFBUSxNQUFNO0FBRW5FLGFBQU87O0FBR0Ysb0RBQWdELHFCQUFxQixVQUFPO0FBQ2pGLFlBQU0sQ0FBRSxtQkFBb0IsVUFBQSxTQUN0QixPQUFPLHFCQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLFdBQVcsZ0NBQWdDLHFCQUFxQixXQUNoRSxhQUFhLGtDQUFrQyxxQkFBcUI7QUFFMUUsaUJBQVU7QUFFVixZQUFNLGtCQUFrQixJQUFJLGdCQUFnQixVQUFTLFFBQVEsTUFBTSxVQUFVO0FBRTdFLGFBQU87O0FBR0Ysb0RBQWdELHFCQUFxQixVQUFPO0FBQ2pGLFlBQU0sQ0FBRSxtQkFBb0IsVUFBQSxTQUN0QixPQUFPLHFCQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLE9BQU8sNEJBQTRCLHFCQUFxQjtBQUU5RCxpQkFBVTtBQUVWLFlBQU0sa0JBQWtCLElBQUksZ0JBQWdCLFVBQVMsUUFBUSxNQUFNO0FBRW5FLGFBQU87O0FBR0YscURBQWlELHNCQUFzQixVQUFPO0FBQ25GLFlBQU0sc0JBQXNCLHFCQUFxQiwwQkFDM0Msa0JBQWtCLHVDQUF1QyxxQkFBcUI7QUFFcEYsYUFBTzs7QUFHRixzREFBa0Qsc0JBQXNCLFVBQU87QUFDcEYsWUFBTSxDQUFFLG1CQUFvQixVQUFBLFNBQ3RCLE9BQU8sc0JBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsV0FBVyxpQ0FBaUMsc0JBQXNCLFdBQ2xFLGtCQUFrQix3Q0FBd0Msc0JBQXNCO0FBRXRGLGlCQUFVO0FBRVYsWUFBTSxtQkFBbUIsSUFBSSxnQkFBZ0IsVUFBUyxRQUFRLE1BQU0sVUFBVTtBQUU5RSxhQUFPOztBQUdGLDBEQUFzRCx3QkFBd0IsVUFBTztBQUMxRixZQUFNLENBQUUsc0JBQXVCLFVBQUEsU0FDekIsT0FBTyx3QkFDUCxPQUFPLHdDQUF3Qyx3QkFBd0IsV0FDdkUsYUFBYSxxQ0FBcUMsd0JBQXdCLFdBQzFFLGNBQWMsc0NBQXNDLHdCQUF3QixXQUM1RSwwQkFBMEIsSUFBQSxRQUFBLDBEQUF5RCxNQUFNLFlBQVksY0FDckcsU0FBUztBQUVmLGlCQUFVO0FBRVYsWUFBTSxxQkFBcUIsSUFBSSxtQkFBbUIsVUFBUyxRQUFRLE1BQU0sTUFBTSxZQUFZO0FBRTNGLGFBQU87O0FBR0YsNERBQXdELHlCQUF5QixVQUFPO0FBQzdGLFlBQU0sQ0FBRSx1QkFBd0IsVUFBQSxTQUMxQixPQUFPLHlCQUNQLE9BQU8sZ0NBQWdDLHlCQUF5QixXQUNoRSwyQkFBMkIsMkRBQTJELE1BQU0seUJBQXlCLFdBQ3JILDJCQUEyQixJQUFBLFFBQUEsNkRBQTRELE1BQU0sMkJBQzdGLFFBQVEsMEJBQ1IsU0FBUztBQUVmLGlCQUFVO0FBRVYsWUFBTSxzQkFBc0IsSUFBSSxvQkFBb0IsVUFBUyxRQUFRLE1BQU07QUFFM0UsYUFBTzs7QUFHRiw4REFBMEQsMEJBQTBCLFVBQU87QUFDaEcsWUFBTSxDQUFFLHdCQUF5QixVQUFBLFNBQzNCLE9BQU8sMEJBQ1AsWUFBWSxzQ0FBc0MsMEJBQTBCLFdBQzVFLDZCQUE2QixJQUFBLFFBQUEseUNBQXdDLFlBQ3JFLFNBQVM7QUFFZixpQkFBVTtBQUVWLFlBQU0sdUJBQXVCLElBQUkscUJBQXFCLFVBQVMsUUFBUSxNQUFNO0FBRTdFLGFBQU87O0FBR0YsK0JBQTJCLFdBQVcsVUFBTztBQUNsRCxZQUFNLE9BQU8sVUFBVTtBQUV2QixhQUFPOztBQUdGLGlDQUE2QixhQUFhLFVBQU87QUFDdEQsWUFBTSxXQUFXLFlBQVksZUFDdkIsT0FBTyxpQkFBaUIsVUFBVTtBQUV4QyxhQUFPOztBQUdGLGtDQUE4QixVQUFVLFVBQU87QUFDcEQsWUFBTSxlQUFlLFNBQVMsbUJBQ3hCLFdBQVcseUJBQXlCLGNBQWM7QUFFeEQsYUFBTzs7QUFHRixrQ0FBOEIsVUFBVSxVQUFPO0FBQ3BELFVBQUksV0FBVztBQUVmLFlBQU0sZUFBZSxTQUFTO0FBRTlCLFVBQUksaUJBQWlCLE1BQU07QUFDekIsbUJBQVcseUJBQXlCLGNBQWM7O0FBR3BELGFBQU87O0FBR0Ysa0NBQThCLGNBQVk7QUFDL0MsWUFBTSxPQUFPLGFBQWE7QUFFMUIsYUFBTzs7QUFHRixrQ0FBOEIsY0FBYyxVQUFPO0FBQ3hELFlBQU0sT0FBTztBQUViLGFBQU87O0FBR0YsbUNBQStCLFVBQVUsVUFBTztBQUNyRCxVQUFJLFlBQVk7QUFFaEIsWUFBTSxnQkFBZ0IsU0FBUztBQUUvQixVQUFJLGtCQUFrQixNQUFNO0FBQzFCLG9CQUFZLDJCQUEyQixlQUFlOztBQUd4RCxhQUFPOztBQUdGLG1DQUErQixXQUFXLFVBQU87QUFDdEQsWUFBTSxlQUFlLFVBQVUsbUJBQ3pCLFdBQVcseUJBQXlCLGNBQWM7QUFFeEQsYUFBTzs7QUFHRixtQ0FBK0IsZUFBZSxVQUFPO0FBQzFELFlBQU0sT0FBTyxjQUFjO0FBRTNCLGFBQU87O0FBR0YsbUNBQStCLGVBQWUsVUFBTztBQUMxRCxZQUFNLE9BQU8sY0FBYztBQUUzQixhQUFPOztBQUdGLG1DQUErQixlQUFlLFVBQU87QUFDMUQsWUFBTSxPQUFPLGNBQWM7QUFFM0IsYUFBTzs7QUFHRixtQ0FBK0IsZUFBZSxVQUFPO0FBQzFELFlBQU0sT0FBTyxjQUFjO0FBRTNCLGFBQU87O0FBR0Ysb0NBQWdDLFlBQVksVUFBTztBQUN4RCxZQUFNLGVBQWUsV0FBVyxtQkFDMUIsV0FBVyx5QkFBeUIsY0FBYztBQUV4RCxhQUFPOztBQUdGLG9DQUFnQyxnQkFBZ0IsVUFBTztBQUM1RCxVQUFJLE9BQU87QUFFWCxZQUFNLFdBQVcsZUFBZTtBQUVoQyxVQUFJLGFBQWEsTUFBTTtBQUNyQixlQUFPLGlCQUFpQixVQUFVOztBQUdwQyxhQUFPOztBQUdGLG9DQUFnQyxnQkFBZ0IsVUFBTztBQUM1RCxVQUFJLE9BQU87QUFFWCxZQUFNLFdBQVcsZUFBZTtBQUVoQyxVQUFJLGFBQWEsTUFBTTtBQUNyQixlQUFPLGlCQUFpQixVQUFVOztBQUdwQyxhQUFPOztBQUdGLG9DQUFnQyxlQUFlLFVBQU87QUFDM0QsWUFBTSxTQUFTLGNBQWMsYUFDdkIsbUJBQW1CLFFBQ25CLFFBQVEsWUFBQSxNQUFNLHFCQUFxQjtBQUV6QyxhQUFPOztBQUdGLG9DQUFnQyxlQUFlLFVBQU87QUFDM0QsWUFBTSxRQUFRLGNBQWM7QUFFNUIsYUFBTzs7QUFHRixxQ0FBaUMsZ0JBQWdCLFVBQU87QUFDN0QsWUFBTSxTQUFTLGVBQWUsYUFDeEIsbUJBQW1CLFFBQ25CLFFBQVEsWUFBQSxNQUFNLHFCQUFxQjtBQUV6QyxhQUFPOztBQUdGLHFDQUFpQyxnQkFBZ0IsVUFBTztBQUM3RCxVQUFJLFFBQVE7QUFFWixZQUFNLFlBQVksZUFBZTtBQUVqQyxVQUFJLGNBQWMsTUFBTTtBQUN0QixnQkFBUSxtQkFBbUIsV0FBVzs7QUFHeEMsYUFBTzs7QUFHRixxQ0FBaUMsVUFBVSxVQUFPO0FBQ3ZELFVBQUksY0FBYztBQUVsQixZQUFNLGtCQUFrQixTQUFTO0FBRWpDLFVBQUksb0JBQW9CLE1BQU07QUFDNUIsc0JBQWMsK0JBQStCLGlCQUFpQjs7QUFHaEUsYUFBTzs7QUFHRixxQ0FBaUMsVUFBVSxVQUFPO0FBQ3ZELFVBQUksY0FBYztBQUVsQixZQUFNLGtCQUFrQixTQUFTO0FBRWpDLFVBQUksb0JBQW9CLE1BQU07QUFDNUIsc0JBQWMsK0JBQStCLGlCQUFpQjs7QUFHaEUsYUFBTzs7QUFHRixxQ0FBaUMsaUJBQWlCLFVBQU87QUFDOUQsWUFBTSxPQUFPLE9BQUE7QUFFYixhQUFPOztBQUdGLHFDQUFpQyxpQkFBaUIsVUFBTztBQUM5RCxZQUFNLE9BQU8sT0FBQTtBQUViLGFBQU87O0FBR0YscUNBQWlDLGlCQUFpQixVQUFPO0FBQzlELFlBQU0sV0FBVyxnQkFBZ0IsZUFDM0IsT0FBTyxpQkFBaUIsVUFBVTtBQUV4QyxhQUFPOztBQUdGLHNDQUFrQyxZQUFZLFVBQU87QUFDMUQsWUFBTSxpQkFBaUIsV0FBVyxxQkFDNUIsYUFBYSw2QkFBNkIsZ0JBQWdCO0FBRWhFLGFBQU87O0FBR0Ysc0NBQWtDLGdCQUFnQixVQUFPO0FBQzlELFVBQUksU0FBUztBQUViLFlBQU0sYUFBYSxlQUFlO0FBRWxDLFVBQUksZUFBZSxNQUFNO0FBQ3ZCLGlCQUFTLHFCQUFxQixZQUFZOztBQUc1QyxhQUFPOztBQUdGLHNDQUFrQyxpQkFBaUIsVUFBTztBQUMvRCxZQUFNLFlBQVksZ0JBQWdCLGdCQUM1QixRQUFRLFVBQVUsSUFBSSxDQUFDLGFBQUE7QUFDckIsY0FBTSxPQUFPLGlCQUFpQixVQUFVO0FBRXhDLGVBQU87O0FBR2YsYUFBTzs7QUFHRix1Q0FBbUMsZUFBZSxVQUFPO0FBQzlELFlBQU0sZUFBZSxjQUFjLG1CQUM3QixXQUFXLHlCQUF5QixjQUFjO0FBRXhELGFBQU87O0FBR0YsdUNBQW1DLGdCQUFnQixVQUFPO0FBQy9ELFVBQUksVUFBVTtBQUVkLFlBQU0sY0FBYyxlQUFlO0FBRW5DLFVBQUksZ0JBQWdCLE1BQU07QUFDeEIsa0JBQVUsdUJBQXVCLGFBQWE7O0FBR2hELGFBQU87O0FBR0YsdUNBQW1DLFVBQVUsVUFBTztBQUN6RCxVQUFJLGdCQUFnQjtBQUVwQixZQUFNLG9CQUFvQixTQUFTO0FBRW5DLFVBQUksc0JBQXNCLE1BQU07QUFDOUIsd0JBQWdCLG1DQUFtQyxtQkFBbUI7O0FBR3hFLGFBQU87O0FBR0YsdUNBQW1DLG1CQUFtQixVQUFPO0FBQ2xFLFlBQU0sV0FBVyxrQkFBa0IsZUFDakMsT0FBTyxpQkFBaUIsVUFBVTtBQUVwQyxhQUFPOztBQUdGLHdDQUFvQyxVQUFVLFVBQU87QUFDMUQsVUFBSSxpQkFBaUI7QUFFckIsWUFBTSxxQkFBcUIsU0FBUztBQUVwQyxVQUFJLHVCQUF1QixNQUFNO0FBQy9CLHlCQUFpQixxQ0FBcUMsb0JBQW9COztBQUc1RSxhQUFPOztBQUdGLHdDQUFvQyxjQUFjLFVBQU87QUFDOUQsWUFBTSxhQUFhO0FBRW5CLGFBQU87O0FBR0Ysd0NBQW9DLGdCQUFnQixVQUFPO0FBQ2hFLFlBQU0sZUFBZSxlQUFlLG1CQUM5QixXQUFXLHlCQUF5QixjQUFjO0FBRXhELGFBQU87O0FBR0Ysd0NBQW9DLG1CQUFtQixVQUFPO0FBQ25FLFlBQU0sWUFBWSxrQkFBa0IsZ0JBQzlCLFFBQVEsbUJBQW1CLFdBQVc7QUFFNUMsYUFBTzs7QUFHRix3Q0FBb0Msb0JBQW9CLFVBQU87QUFDcEUsWUFBTSxPQUFPLG1CQUFtQjtBQUVoQyxhQUFPOztBQUdGLHdDQUFvQyxvQkFBb0IsVUFBTztBQUNwRSxZQUFNLE9BQU8sbUJBQW1CO0FBRWhDLGFBQU87O0FBR0YseUNBQXFDLGlCQUFpQixVQUFPO0FBQ2xFLFlBQU0sZUFBZSxnQkFBZ0IsbUJBQ25DLFdBQVcsaUJBQWlCLGNBQWM7QUFFNUMsYUFBTzs7QUFHRix5Q0FBcUMsVUFBVSxVQUFPO0FBQzNELFVBQUksa0JBQWtCO0FBRXRCLFlBQU0sc0JBQXNCLFNBQVM7QUFFckMsVUFBSSx3QkFBd0IsTUFBTTtBQUNoQywwQkFBa0IsdUNBQXVDLHFCQUFxQjs7QUFHaEYsYUFBTzs7QUFHRix5Q0FBcUMsYUFBYSxVQUFPO0FBQzlELFlBQU0sbUJBQW1CLFlBQVksdUJBQy9CLGVBQWUsNkJBQTZCLGtCQUFrQjtBQUVwRSxhQUFPOztBQUdGLHlDQUFxQyxnQkFBZ0IsVUFBTztBQUNqRSxVQUFJLFlBQVk7QUFFaEIsWUFBTSxnQkFBZ0IsZUFBZTtBQUVyQyxVQUFJLGtCQUFrQixNQUFNO0FBQzFCLG9CQUFZLDJCQUEyQixlQUFlOztBQUd4RCxhQUFPOztBQUdGLHlDQUFxQyxvQkFBb0IsVUFBTztBQUNyRSxZQUFNLFFBQVEsbUJBQW1CO0FBRWpDLGFBQU87O0FBR0YseUNBQXFDLHFCQUFxQixVQUFPO0FBQ3RFLFlBQU0sV0FBVyxvQkFBb0IsZUFDL0IsT0FBTyxpQkFBaUIsVUFBVTtBQUV4QyxhQUFPOztBQUdGLDBDQUFzQyxVQUFVLFVBQU87QUFDNUQsVUFBSSxtQkFBbUI7QUFFdkIsWUFBTSx1QkFBdUIsU0FBUztBQUV0QyxVQUFJLHlCQUF5QixNQUFNO0FBQ2pDLDJCQUFtQix5Q0FBeUMsc0JBQXNCOztBQUdwRixhQUFPOztBQUdGLDBDQUFzQyxnQkFBZ0IsVUFBTztBQUNsRSxVQUFJLGFBQWE7QUFFakIsWUFBTSxpQkFBaUIsZUFBZTtBQUV0QyxVQUFJLG1CQUFtQixNQUFNO0FBQzNCLHFCQUFhLDZCQUE2QixnQkFBZ0I7O0FBRzVELGFBQU87O0FBR0YsMENBQXNDLGlCQUFpQixVQUFPO0FBQ25FLFlBQU0sZ0JBQWdCLGdCQUFnQixvQkFDakMsWUFBWSxpQkFBaUIsZUFBZTtBQUVqRCxhQUFPOztBQUdGLDJDQUF1QyxvQkFBb0IsVUFBTztBQUN2RSxZQUFNLFVBQVUsbUJBQW1CO0FBRW5DLGFBQU87O0FBR0YsMkNBQXVDLGFBQWEsVUFBTztBQUNoRSxZQUFNLHFCQUFxQixZQUFZLHlCQUNqQyxpQkFBaUIsNkJBQTZCLG9CQUFvQjtBQUV4RSxhQUFPOztBQUdGLDJDQUF1QyxnQkFBZ0IsVUFBTztBQUNuRSxVQUFJLGNBQWM7QUFFbEIsWUFBTSxrQkFBa0IsZUFBZTtBQUV2QyxVQUFJLG9CQUFvQixNQUFNO0FBQzVCLHNCQUFjLCtCQUErQixpQkFBaUI7O0FBR2hFLGFBQU87O0FBR0YsNENBQXdDLFVBQVUsVUFBTztBQUM5RCxZQUFNLHlCQUF5QixTQUFTLDZCQUNsQyxxQkFBcUIsNkNBQTZDLHdCQUF3QjtBQUVoRyxhQUFPOztBQUdGLDRDQUF3QyxpQkFBaUIsVUFBTztBQUNyRSxZQUFNLGNBQWMsZ0JBQWdCO0FBRXBDLGFBQU87O0FBR0YsNENBQXdDLG1CQUFtQixVQUFPO0FBQ3ZFLFlBQU0sZ0JBQWdCLGtCQUFrQixvQkFDbEMsWUFBWSwyQkFBMkIsZUFBZTtBQUU1RCxhQUFPOztBQUdGLDRDQUF3QyxvQkFBb0IsVUFBTztBQUN4RSxZQUFNLGVBQWUsbUJBQW1CLG1CQUNsQyxXQUFXLGlCQUFpQixjQUFjO0FBRWhELGFBQU87O0FBR0YsNENBQXdDLGlCQUFpQixVQUFPO0FBQ3JFLFlBQU0sY0FBYyxnQkFBZ0I7QUFFcEMsYUFBTzs7QUFHRiw0Q0FBd0MsaUJBQWlCLFVBQU87QUFDckUsWUFBTSxDQUFFLGVBQWdCLFVBQUEsU0FDbEIsT0FBTyxpQkFDUCxTQUFTLFNBQVEsYUFBYSxPQUM5QixXQUFXLGdCQUFnQixlQUMzQixPQUFPLHdCQUF3QixVQUFVLFdBQ3pDLE9BQU8sd0JBQXdCLGlCQUFpQixXQUNoRCxjQUFjLElBQUksWUFBWSxVQUFTLFFBQVEsTUFBTSxNQUFNO0FBRWpFLGFBQU87O0FBR0YsNENBQXdDLGlCQUFpQixVQUFPO0FBQ3JFLFlBQU0sQ0FBRSxlQUFnQixVQUFBLFNBQ2xCLE9BQU8saUJBQ1AsU0FBUyxTQUFRLGFBQWEsT0FDOUIsT0FBTyx3QkFBd0IsaUJBQWlCLFdBQ2hELGNBQWMsK0JBQStCLGlCQUFpQixXQUM5RCxXQUFXLDRCQUE0QixpQkFBaUIsV0FDeEQsWUFBWSw2QkFBNkIsaUJBQWlCLFdBQzFELGNBQWMsSUFBSSxZQUFZLFVBQVMsUUFBUSxNQUFNLE1BQU0sYUFBYSxVQUFVO0FBRXhGLGFBQU87O0FBR0YsNkNBQXlDLE1BQU0sY0FBYyxVQUFPO0FBQ3pFLFlBQU0sQ0FBRSxZQUFhLFVBQUEsU0FDZixPQUFPLGNBQ1AsT0FBTyxxQkFBcUIsZUFDNUIsYUFBYSxrQ0FBa0MsTUFBTSxjQUFjLFdBQ25FLGlCQUFpQixJQUFBLFFBQUEsd0JBQXVCLE9BQ3hDLFNBQVMsZ0JBQ1QsV0FBVyxJQUFJLFNBQVMsVUFBUyxRQUFRLE1BQU0sTUFBTSxNQUFNO0FBRWpFLGFBQU87O0FBR0YsNkNBQXlDLFVBQVUsVUFBTztBQUMvRCxVQUFJLHNCQUFzQjtBQUUxQixZQUFNLDBCQUEwQixTQUFTO0FBRXpDLFVBQUksNEJBQTRCLE1BQU07QUFDcEMsOEJBQXNCLCtDQUErQyx5QkFBeUI7O0FBR2hHLGFBQU87O0FBR0YsNkNBQXlDLFdBQVcsVUFBTztBQUNoRSxZQUFNLHlCQUF5QixVQUFVLDZCQUNuQyxxQkFBcUIsNkNBQTZDLHdCQUF3QjtBQUVoRyxhQUFPOztBQUdGLDZDQUF5QyxZQUFZLFVBQU87QUFDakUsWUFBTSxhQUFhLHlCQUF5QixZQUFZLFdBQ2xELG9CQUFvQjtBQUUxQixhQUFPOztBQUdGLDZDQUF5QyxnQkFBZ0IsVUFBTztBQUNyRSxVQUFJLGdCQUFnQjtBQUVwQixZQUFNLG9CQUFvQixlQUFlO0FBRXpDLFVBQUksc0JBQXNCLE1BQU07QUFDOUIsd0JBQWdCLG1DQUFtQyxtQkFBbUI7O0FBR3hFLGFBQU87O0FBR0YsNkNBQXlDLG9CQUFvQixVQUFPO0FBQ3pFLFlBQU0sZ0JBQWdCLG1CQUFtQixvQkFDbkMsWUFBWSxpQkFBaUIsZUFBZTtBQUVsRCxhQUFPOztBQUdGLDZDQUF5QyxxQkFBcUIsVUFBTztBQUMxRSxZQUFNLGVBQWUsb0JBQW9CLG1CQUNuQyxXQUFXLHlCQUF5QixjQUFjO0FBRXhELGFBQU87O0FBR0YsNkNBQXlDLHlCQUF5QixVQUFPO0FBQzlFLFlBQU0sT0FBTyx3QkFBd0I7QUFFckMsYUFBTzs7QUFHRiw4Q0FBMEMsWUFBWSxVQUFPO0FBQ2xFLFlBQU0seUJBQXlCLFdBQVcsNkJBQ3BDLHFCQUFxQiw2Q0FBNkMsd0JBQXdCO0FBRWhHLGFBQU87O0FBR0YsOENBQTBDLHNCQUFzQixVQUFPO0FBQzVFLFlBQU0sZUFBZSxxQkFBcUIsbUJBQ3BDLFdBQVcseUJBQXlCLGNBQWM7QUFFeEQsYUFBTzs7QUFHRiw4Q0FBMEMsMEJBQTBCLFVBQU87QUFDaEYsWUFBTSxPQUFPLHlCQUF5QjtBQUV0QyxhQUFPOztBQUdGLCtDQUEyQyxNQUFNLGNBQWMsVUFBTztBQUMzRSxZQUFNLGFBQWE7QUFFbkIsYUFBTzs7QUFHRiwrQ0FBMkMscUJBQXFCLFVBQU87QUFDNUUsWUFBTSxpQkFBaUIsb0JBQW9CLHFCQUNyQyxhQUFhLDZCQUE2QixnQkFBZ0I7QUFFaEUsYUFBTzs7QUFHRiwrQ0FBMkMsMEJBQTBCLFVBQU87QUFDakYsWUFBTSxZQUFZLHlCQUF5QixnQkFDckMsUUFBUSxtQkFBbUIsV0FBVztBQUU1QyxhQUFPOztBQUdGLGdEQUE0QyxpQkFBaUIsVUFBTztBQUN6RSxZQUFNLHNCQUFzQixnQkFBZ0IsMEJBQ3RDLGtCQUFrQix1Q0FBdUMscUJBQXFCO0FBRXBGLGFBQU87O0FBR0YsZ0RBQTRDLG1CQUFtQixVQUFPO0FBQzNFLFlBQU0sQ0FBRSxpQkFBa0IsVUFBQSxTQUNwQixPQUFPLG1CQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLE9BQU8sMEJBQTBCLG1CQUFtQixXQUNwRCxnQkFBZ0IsSUFBSSxjQUFjLFVBQVMsUUFBUSxNQUFNO0FBRS9ELGFBQU87O0FBR0Ysa0RBQThDLHVCQUF1QixVQUFPO0FBQ2pGLFlBQU0saUJBQWlCLHNCQUFzQixxQkFDdkMsYUFBYSw2QkFBNkIsZ0JBQWdCO0FBRWhFLGFBQU87O0FBR0Ysa0RBQThDLHdCQUF3QixVQUFPO0FBQ2xGLFlBQU0saUJBQWlCLHVCQUF1QixxQkFDeEMsYUFBYSw2QkFBNkIsZ0JBQWdCO0FBRWhFLGFBQU87O0FBR0Ysa0RBQThDLG9CQUFvQixVQUFPO0FBQzlFLFlBQU0sQ0FBRSxrQkFBbUIsVUFBQSxTQUNyQixPQUFPLG9CQUNQLFNBQVMsU0FBUSxhQUFhLE9BQzlCLFVBQVUsOEJBQThCLG9CQUFvQixXQUM1RCxXQUFXLCtCQUErQixvQkFBb0IsV0FDOUQsWUFBWSxnQ0FBZ0Msb0JBQW9CLFdBQ2hFLGlCQUFpQixJQUFJLGVBQWUsVUFBUyxRQUFRLE1BQU0sU0FBUyxVQUFVO0FBRXBGLGFBQU87O0FBR0YsbURBQStDLHdCQUF3QixVQUFPO0FBQ25GLFlBQU0sa0JBQWtCLHVCQUF1QixzQkFDekMsY0FBYywrQkFBK0IsaUJBQWlCO0FBRXBFLGFBQU87O0FBR0YsbURBQStDLDBCQUEwQixVQUFPO0FBQ3JGLFlBQU0sQ0FBRSxhQUFjLFVBQUEsU0FDaEIsT0FBTywwQkFDUCxPQUFPLGlDQUFpQywwQkFBMEIsV0FDbEUsUUFBUSxrQ0FBa0MsMEJBQTBCLFdBQ3BFLGFBQWEsdUNBQXVDLDBCQUEwQixXQUM5RSxjQUFjLHdDQUF3QywwQkFBMEIsV0FDaEYsa0JBQWtCLElBQUEsUUFBQSxzREFBcUQsTUFBTSxPQUFPLFlBQVksY0FDaEcsU0FBUyxpQkFDVCxZQUFZLElBQUksVUFBVSxVQUFTLFFBQVEsTUFBTSxNQUFNLE9BQU8sWUFBWTtBQUVoRixhQUFPOztBQUdGLG9EQUFnRCwwQkFBMEIsVUFBTztBQUN0RixZQUFNLGlCQUFpQix5QkFBeUIscUJBQzFDLGFBQWEsNkJBQTZCLGdCQUFnQjtBQUVoRSxhQUFPOztBQUdGLHFEQUFpRCx3QkFBd0IsVUFBTztBQUNyRixZQUFNLE9BQU8sdUJBQXVCO0FBRXBDLGFBQU87O0FBR0YscURBQWlELDBCQUEwQixVQUFPO0FBQ3ZGLFlBQU0sa0JBQWtCLHlCQUF5QixzQkFDM0MsY0FBYywrQkFBK0IsaUJBQWlCO0FBRXBFLGFBQU87O0FBR0YsdURBQW1ELE1BQU0sd0JBQXdCLFVBQU87QUFDN0YsWUFBTSxlQUFlLHVCQUF1QixtQkFDdEMsV0FBVyxnQ0FBZ0MsTUFBTSxjQUFjO0FBRXJFLGFBQU87O0FBR0YsaUVBQTZELE1BQU0sd0JBQXdCLFVBQU87QUFDdkcsWUFBTSxDQUFFLHNCQUF1QixVQUFBLFNBQ3pCLE9BQU8sd0JBQ1AsV0FBVywwQ0FBMEMsTUFBTSx3QkFBd0IsV0FDbkYsYUFBYSxxQ0FBcUMsd0JBQXdCLFdBQzFFLDJCQUEyQixJQUFBLFFBQUEsNkNBQTRDLE1BQU0sVUFBVSxXQUN2RixTQUFTLDBCQUNULGFBQWEsSUFBSSxtQkFBbUIsVUFBUyxRQUFRLE1BQU0sVUFBVTtBQUUzRSxhQUFPOztBQUdGLHFDQUFpQyxXQUFXLFVBQU87QUFDeEQsWUFBTSxhQUFhLFVBQVUsSUFBSSxDQUFDLGFBQUE7QUFDaEMsY0FBTSxPQUFPLGlCQUFpQixVQUFVO0FBRXhDLGVBQU87O0FBR1QsYUFBTzs7QUFHRiw4Q0FBMEMsZ0JBQWdCLFVBQU87QUFDdEUsWUFBTSxpQkFBaUIsZUFBZSxxQkFDaEMsaUJBQWlCLGVBQWUsSUFBSSxDQUFDLGtCQUFBO0FBQ25DLGNBQU0sWUFBWSwyQkFBMkIsZUFBZTtBQUU1RCxlQUFPOztBQUdmLGFBQU87O0FBR0Ysd0RBQW9ELHFCQUFxQixVQUFPO0FBQ3JGLFlBQU0sc0JBQXNCLG9CQUFvQixJQUFJLENBQUMsdUJBQUE7QUFDbkQsY0FBTSxpQkFBaUIscUNBQXFDLG9CQUFvQjtBQUVoRixlQUFPOztBQUdULGFBQU87O0FBR0Ysd0VBQW9FLE1BQU0seUJBQXlCLFVBQU87QUFDL0csWUFBTSwwQkFBMEIsd0JBQXdCLDhCQUNsRCwyQkFBMkIsd0JBQXdCLElBQUksQ0FBQywyQkFBQTtBQUN0RCxjQUFNLHFCQUFxQixvREFBb0QsTUFBTSx3QkFBd0I7QUFFN0csZUFBTzs7QUFHZixhQUFPOzs7OztBQzNwQ1Q7Ozs7O21DQWdEZ0IsY0FBQTs7O2VBQUE7Ozs7O0FBMUNoQixRQUFNLENBQUUsYUFBYyxnQkFBQTtBQUV0QixRQUFNLGlCQUFpQixVQUFVO0FBQWpDLFFBQ00sZ0NBQWdDLFVBQVU7QUFFaEQscUNBQTJCLGdCQUFBLFdBQVU7O0FBQzVCLGtCQURULGNBQ1MsUUFBTztNQUNaO1FBQ0UsV0FBVztRQUNYLEtBQUssQ0FBQyxXQUFXLGFBQUE7QUFDZixjQUFJLFVBQVU7QUFFZCxnQkFBTSxRQUFRLElBQUEsU0FBQSxvQkFBbUIsV0FBVyxXQUN0QyxnQkFBZ0IsTUFBTSxPQUFPO0FBRW5DLGNBQUksZUFBZTtBQUNqQixzQkFBVTs7QUFHWixpQkFBTzs7O01BR1g7UUFDRSxXQUFXO1FBQ1gsS0FBSyxDQUFDLDBCQUEwQixhQUFBO0FBQzlCLGNBQUksVUFBVTtBQUVkLGdCQUFNLHVCQUF1QixJQUFBLFNBQUEsa0RBQWlELDBCQUEwQixXQUNsRywrQkFBK0IscUJBQXFCLE9BQU87QUFFakUsY0FBSSw4QkFBOEI7QUFDaEMsc0JBQVU7O0FBR1osaUJBQU87Ozs7QUFNZixRQUFNLGVBQWUsSUFBSTtBQUVsQix3QkFBb0IsVUFBVSxVQUFPO0FBQzFDLFVBQUksZUFBZTtBQUVuQixZQUFNLE9BQU8sVUFDUCxTQUFTLGFBQWEsSUFBSSxNQUFNO0FBRXRDLFVBQUksUUFBUTtBQUNWLHVCQUFlOztBQUdqQixhQUFPOzs7OztBQzFEVDs7Ozs7Ozs7Ozs7OztVQXdDQSxVQUFBO2VBQUE7O1VBaEJnQix5QkFBQTtlQUFBOztVQWhCQSx5QkFBQTtlQUFBOzs7Ozs7Ozs7O0FBRmhCLFFBQU0sQ0FBRSxnQkFBZ0Isb0JBQXFCLGFBQUE7QUFFdEMsb0NBQWdDLE9BQUs7QUFDMUMsVUFBSSxVQUFVLFFBQVc7QUFDdkIsZ0JBQVEsT0FBQTs7QUFHVixZQUFNLENBQUUsV0FBWSxPQUFBO0FBRXBCLFVBQUk7QUFFSixjQUFRLGlCQUFpQjtBQUV6QixZQUFNLGNBQWMsZUFBZSxPQUFPO0FBRTFDLGFBQU87O0FBR0Ysb0NBQWdDLE9BQU8sU0FBTztBQUNuRCxVQUFJLFlBQVksUUFBVztBQUN6QixrQkFBVTtBQUVWLGdCQUFRLE9BQUE7O0FBR1YsVUFBSTtBQUVKLGNBQVEsaUJBQWlCO0FBRXpCLFlBQU0sY0FBYyxlQUFlLE9BQU87QUFFMUMsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTs7Ozs7QUMxQ0Y7Ozs7Ozs7Ozs7Ozs7VUFpRUEsVUFBQTtlQUFBOztVQXhEZ0Isc0JBQUE7ZUFBQTs7VUFvQ0Esc0NBQUE7ZUFBQTs7VUFsQkEsMEJBQUE7ZUFBQTs7Ozs7Ozs7Ozs7QUFwQmhCLFFBQU0sQ0FBRSxjQUFjLGlCQUFpQixtQ0FBb0MsY0FBQTtBQUVwRSxpQ0FBNkIsT0FBTyxLQUFHO0FBQzVDLFVBQUksUUFBUSxRQUFXO0FBQ3JCLGNBQU07QUFFTixnQkFBUSxRQUFBOztBQUdWLFVBQUk7QUFFSixjQUFRLGFBQWE7QUFFckIsY0FBUSxJQUFBLHVCQUFBLHdCQUF1QjtBQUUvQixZQUFNLGVBQWUsZ0JBQWdCLE9BQU87QUFFNUMsYUFBTzs7QUFHRixxQ0FBaUMsT0FBSztBQUMzQyxVQUFJLFVBQVUsUUFBVztBQUN2QixnQkFBUSxRQUFBOztBQUdWLFlBQU0sQ0FBRSxPQUFRLFFBQUE7QUFFaEIsVUFBSTtBQUVKLGNBQVEsYUFBYTtBQUVyQixjQUFRLElBQUEsdUJBQUEsd0JBQXVCO0FBRS9CLFlBQU0sZUFBZSxnQkFBZ0IsT0FBTztBQUU1QyxhQUFPOztBQUdGLGlEQUE2QyxPQUFPLEtBQUssZUFBYTtBQUMzRSxVQUFJLGtCQUFrQixRQUFXO0FBQy9CLHdCQUFnQjtBQUVoQixjQUFNO0FBRU4sZ0JBQVEsUUFBQTs7QUFHVixVQUFJO0FBRUosY0FBUSxhQUFhO0FBRXJCLGNBQVEsSUFBQSx1QkFBQSx3QkFBdUI7QUFFL0IsWUFBTSxlQUFlLGdDQUFnQyxPQUFPLE9BQU87QUFFbkUsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTtNQUNBOzs7OztBQ3BFRjs7Ozs7Ozs7Ozs7OztVQVFhLGNBQUE7ZUFBQTs7VUFFQSxlQUFBO2VBQUE7Ozs7Ozs7Ozs7OztBQUZOLFFBQU0sY0FBYyxJQUFBLFFBQUEsd0JBQXVCLE9BQUE7QUFFM0MsUUFBTSxlQUFlLElBQUEsU0FBQSx5QkFBd0IsUUFBQTs7OztBQ1ZwRDs7Ozs7bUNBT0EsV0FBQTs7O2VBQXFCOzs7Ozs7QUFBTiwwQ0FBZ0MsZ0JBQUEsWUFBVztNQUN4RCxZQUFZLFVBQVMsVUFBVSxRQUFRLE1BQU0sWUFBWTtBQUN2RCxjQUFNLFVBQVMsVUFBVSxRQUFRO0FBRWpDLGFBQUssYUFBYTs7TUFHcEIsY0FBYyxpQkFBaUIsTUFBTTtBQUNuQyxjQUFNLGFBQWEsaUJBQ0UsS0FBSyxRQUFRLGtCQUNYLEtBQUs7QUFFNUIsZUFBTzs7TUFHVCxXQUFXO0FBQ1QsY0FBTSxRQUFRLFFBQUE7QUFFZCxlQUFPOztNQUdULFlBQVk7QUFDVixjQUFNLFNBQVMsUUFBQTtBQUVmLGVBQU87O01BR1QsVUFBVSxpQkFBaUIsTUFBTTtBQUMvQixjQUFNLFNBQVM7QUFFZixlQUFPOztNQUdULFNBQVMsaUJBQWlCLE1BQU07QUFDOUIsY0FBTSxRQUFRO0FBRWQsZUFBTzs7TUFHVCxTQUFTLGlCQUFpQixNQUFNO0FBQzlCLGNBQU0sUUFBUTtBQUVkLGVBQU87O01BR1QsVUFBVSxpQkFBaUIsTUFBTTtBQUMvQixjQUFNLFNBQVM7QUFFZixlQUFPOztNQUdULFVBQVUsaUJBQWlCLE1BQU07QUFDL0IsY0FBTSxTQUFTO0FBRWYsZUFBTzs7TUFHVCxZQUFZLGlCQUFpQixNQUFNO0FBQ2pDLGNBQU0sV0FBVztBQUVqQixlQUFPOztNQUdULGFBQWEsaUJBQWlCLE1BQU07QUFDbEMsY0FBTSxZQUFZO0FBRWxCLGVBQU87O01BR1QsY0FBYyxpQkFBaUIsTUFBTTtBQUNuQyxjQUFNLGFBQWE7QUFFbkIsZUFBTzs7TUFHVCxlQUFlLGlCQUFpQixNQUFNO0FBQ3BDLGNBQU0sY0FBYztBQUVwQixlQUFPOztNQUdULGVBQWUsaUJBQWlCLE1BQU07QUFDcEMsY0FBTSxjQUFjO0FBRXBCLGVBQU87O01BR1QsZ0JBQWdCLGlCQUFpQixNQUFNO0FBQ3JDLGNBQU0sZUFBZTtBQUVyQixlQUFPOztNQUdULGdCQUFnQixpQkFBaUIsTUFBTTtBQUNyQyxjQUFNLGVBQWU7QUFFckIsZUFBTzs7TUFHVCxnQkFBZ0IsaUJBQWlCLE1BQU07QUFDckMsY0FBTSxlQUFlO0FBRXJCLGVBQU87O01BR1QsaUJBQWlCLGlCQUFpQixNQUFNO0FBQ3RDLGNBQU0sZ0JBQWdCO0FBRXRCLGVBQU87O01BR1QsYUFBYSxXQUFXO0FBQ3RCLGNBQU0sa0JBQWtCLFVBQVU7QUFFbEMsYUFBSyxXQUFXLEtBQUs7QUFFckIsY0FBTSxXQUFXLEtBQUs7QUFFdEIsYUFBSyxNQUFNLGNBQWMsc0NBQXNDOztNQUdqRSw2QkFBNkIsZUFBZTtBQUMxQyxjQUFNLGFBQWEsS0FBSyxpQkFDbEIsWUFBWSxXQUFXLEtBQUssQ0FBQyxlQUFBO0FBQzNCLGdCQUFNLG1DQUFtQyxXQUFVLHFCQUFxQjtBQUV4RSxjQUFJLGtDQUFrQztBQUNwQyxtQkFBTzs7Y0FFTDtBQUVaLGVBQU87O01BR1Qsa0NBQWtDLGVBQWU7QUFDL0MsY0FBTSxZQUFZLEtBQUssNkJBQTZCLGdCQUM5QyxtQkFBb0IsY0FBYztBQUV4QyxlQUFPOztNQUdULFFBQVE7QUFDTixhQUFLLGFBQWE7O01BR3BCLFdBQVc7O1lBSUwsYUFBYTtBQUNqQixjQUFNLE9BQU8sS0FBSyxXQUNaLFdBQVUsTUFDVixXQUFXLE1BQ1gsZUFBZSxJQUFBLFFBQUEsWUFBVyxVQUFVO0FBRTFDLGVBQU87O2FBR0YsU0FBUyxNQUFNLFVBQVM7QUFDN0IsY0FBTSxhQUFhLElBQ2Isb0JBQW9CLGdCQUFBLFlBQVksU0FBUyxtQkFBbUIsTUFBTSxZQUFZO0FBRXBGLGVBQU87O2FBR0YsYUFBYSxVQUFVLFVBQVM7QUFDckMsY0FBTSxhQUFhLE1BQ2Isb0JBQW9CLFdBQVcsYUFBYSxtQkFBbUIsVUFBVSxZQUFZO0FBRTNGLGVBQU87Ozs7OztBQ2hMWDs7Ozs7Ozs7Ozs7OztVQW1DQSxVQUFBO2VBQUE7O1VBNUJnQixpQkFBQTtlQUFBOztVQWVBLHNCQUFBO2VBQUE7Ozs7Ozs7Ozs7O0FBZlQsNEJBQXdCLE9BQU8sVUFBTztBQUMzQyxZQUFNLENBQUUsU0FBVSxVQUFBLFNBQ1osYUFBYSxvQkFBb0IsT0FBTyxXQUN4QyxjQUFjLElBQUEsUUFBQSwyQkFBMEIsYUFDeEMsU0FBUyxhQUNULFFBQVEsWUFDUixPQUFPO0FBRWIsaUJBQVU7QUFFVixZQUFNLFFBQVEsSUFBSSxNQUFNLFVBQVMsUUFBUSxNQUFNO0FBRS9DLGFBQU87O0FBR0YsaUNBQTZCLFlBQVU7QUFDNUMsWUFBTSxDQUFFLFNBQVUsVUFBQSxTQUNaLGFBQWEseUJBQXlCLGFBQ3RDLGNBQWMsSUFBQSxRQUFBLDJCQUEwQixhQUN4QyxXQUFVLE1BQ1YsU0FBUyxhQUNULFFBQVEsWUFDUixPQUFPLE1BQ1AsUUFBUSxJQUFJLE1BQU0sVUFBUyxRQUFRLE1BQU07QUFFL0MsYUFBTzs7UUFHVCxXQUFlO01BQ2I7TUFDQTs7QUFHRixpQ0FBNkIsT0FBTyxVQUFPO0FBQ3pDLFlBQU0sYUFBYSxNQUFNLElBQUksQ0FBQyxTQUFBO0FBQzVCLGNBQU0sT0FBTyxJQUFBLE1BQUEsY0FBYSxNQUFNO0FBRWhDLGVBQU87O0FBR1QsYUFBTzs7QUFHVCxzQ0FBa0MsWUFBVTtBQUMxQyxZQUFNLGFBQWEsV0FBVyxJQUFJLENBQUMsY0FBQTtBQUNqQyxjQUFNLE9BQU8sSUFBQSxNQUFBLG1CQUFrQjtBQUUvQixlQUFPOztBQUdULGFBQU87Ozs7O0FDekRUOzs7Ozs7Ozs7Ozs7O1VBUW9CLG9CQUFBO2VBQUEsUUFBQTs7VUFGQSxjQUFBO2VBQUEsT0FBQTs7VUFDQSxlQUFBO2VBQUEsUUFBQTs7VUFIQSxRQUFBO2VBQUEsT0FBQTs7VUFRQSxrQkFBQTtlQUFBLFFBQUE7O1VBQ0EsbUJBQUE7ZUFBQSxTQUFBOztVQUNBLHFCQUFBO2VBQUEsV0FBQTs7VUFKQSxnQkFBQTtlQUFBLE1BQUE7O1VBQ0EsaUJBQUE7ZUFBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYcEI7Ozs7O21DQWVBLFdBQUE7OztlQUFBOzs7Ozs7Ozs7QUFYQSxRQUFNLGFBQWEsZUFBQSxRQUFVOzs7Ozs7Ozs7O1FBVzdCLFdBQWU7Ozs7QUNmZjs7Ozs7bUNBTUEsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7UUFBQSxXQUFlLElBQUEsZUFBQSxTQUFVLFlBQUE7Ozs7Ozs7OztBQ056Qjs7Ozs7bUNBTUEsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7UUFBQSxXQUFlLElBQUEsZUFBQSxTQUFVLE1BQUE7Ozs7Ozs7Ozs7Ozs7OztBQ056Qjs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTixvQ0FBMEIsVUFBQSxRQUFRO01BQy9DLFNBQVM7QUFDUCxjQUFNLFFBQVEsS0FBSyxZQUNiLE1BQU07QUFFWixlQUFPOztNQUdULE9BQU8sS0FBSztBQUNWLGNBQU0sUUFBUTtBQUVkLGFBQUssU0FBUzs7TUFHaEIsZ0JBQWdCO0FBQ2QsY0FBTSxTQUFTLEtBQUssT0FBTyxLQUFLLE9BQzFCLFNBQVMsS0FBSyxPQUFPLEtBQUs7QUFFaEMsZUFBUTtVQUNOO1VBQ0E7Ozs7QUFJRyxrQkF4Qk0sYUF3Qk4scUJBQW9CO01BQ3pCLFdBQVc7TUFDWCxZQUFZOzs7OztBQzlCaEI7Ozs7O21DQW9DQSxXQUFBOzs7ZUFBQTs7Ozs7Ozs7OztBQTlCQSxzQ0FBNEIsTUFBQSxNQUFLO01BQy9CLGNBQWM7QUFDWixjQUFNLFFBQVEsS0FBSyxZQUNiLFdBQVc7QUFFakIsZUFBTzs7TUFHVCxZQUFZLFVBQVU7QUFDcEIsY0FBTSxRQUFRO0FBRWQsYUFBSyxTQUFTOztNQUdoQixnQkFBZ0I7QUFDZCxjQUFNLGNBQWMsS0FBSyxZQUFZLEtBQUssT0FDcEMsY0FBYyxLQUFLLFlBQVksS0FBSztBQUUxQyxlQUFRO1VBQ047VUFDQTs7OztBQUlHLGtCQXhCVCxlQXdCUyxxQkFBb0I7TUFDekIsV0FBVztNQUNYLFlBQVk7O1FBSWhCLFdBQWUsSUFBQSxlQUFBLFNBQVU7Ozs7Ozs7Ozs7O0FDcEN6Qjs7Ozs7bUNBTUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7O0FBQU4sdUNBQTZCLFVBQUEsUUFBUTtNQUNsRCxVQUFVLFFBQVE7QUFDaEIsWUFBSSxhQUFhLEdBQ2IsZ0JBQWdCO0FBRXBCLGNBQU0sT0FBTyxPQUFPLE9BQU8sQ0FBQyxPQUFNLFVBQUE7QUFDaEMsZ0JBQU0sWUFBWSxNQUFNO0FBRXhCLGNBQUksa0JBQWtCLE1BQU07QUFDMUIscUJBQVEsR0FBRztpQkFDTjtBQUNMLGtCQUFNLDhCQUE4QixjQUFjO0FBRWxELGdCQUFJLDZCQUE2QjtBQUMvQix1QkFBUSxHQUFHOzs7QUFJZixtQkFBUTtBQUVSLDBCQUFnQjtBQUVoQixpQkFBTztXQUNOLFdBQUE7QUFFSCxhQUFLLEtBQUs7O01BR1osY0FBYztBQUNaLGNBQU0sT0FBTyxXQUFBO0FBRWIsYUFBSyxLQUFLOztNQUdaLGdCQUFnQjtBQUNkLGNBQU0sWUFBWSxLQUFLLFVBQVUsS0FBSyxPQUNoQyxjQUFjLEtBQUssWUFBWSxLQUFLO0FBRTFDLGVBQVE7VUFDTjtVQUNBOzs7O0FBSUcsa0JBNUNNLGdCQTRDTixxQkFBb0I7TUFDekIsV0FBVztNQUNYLFlBQVk7TUFDWixVQUFVOzs7OztBQ3JEZDs7Ozs7bUNBSUEsV0FBQTs7O2VBQXFCOzs7Ozs7Ozs7QUFBTix3Q0FBOEIsVUFBQSxRQUFRO01BQ25ELGFBQWE7QUFDWCxjQUFNLFFBQVEsS0FBSyxZQUNiLFVBQVU7QUFFaEIsZUFBTzs7TUFHVCxXQUFXLFNBQVM7QUFDbEIsY0FBTSxRQUFRO0FBRWQsYUFBSyxTQUFTOztNQUdoQixnQkFBZ0I7QUFDZCxjQUFNLGFBQWEsS0FBSyxXQUFXLEtBQUssT0FDbEMsYUFBYSxLQUFLLFdBQVcsS0FBSztBQUV4QyxlQUFRO1VBQ047VUFDQTs7OztBQUlHLGtCQXhCTSxpQkF3Qk4scUJBQW9CO01BQ3pCLFdBQVc7TUFDWCxZQUFZOzs7OztBQzlCaEI7Ozs7O21DQU1BLFdBQUE7OztlQUFxQjs7Ozs7Ozs7OztBQUFOLDBDQUFnQyxVQUFBLFFBQVE7TUFDckQsYUFBYSxXQUFXO0FBQ3RCLFlBQUksY0FBYyxNQUFNO0FBQ3RCLG9CQUFVO0FBRVYsZ0JBQU0sa0JBQWtCLFVBQVUsWUFDNUIsUUFBUTtBQUVkLGVBQUssU0FBUztlQUNUO0FBQ0wsZUFBSzs7O01BSVQsaUJBQWlCO0FBQ2YsY0FBTSxRQUFRLFdBQUE7QUFFZCxhQUFLLFNBQVM7O01BR2hCLGdCQUFnQjtBQUNkLGNBQU0sZUFBZSxLQUFLLGFBQWEsS0FBSyxPQUN0QyxpQkFBaUIsS0FBSyxlQUFlLEtBQUs7QUFFaEQsZUFBUTtVQUNOO1VBQ0E7Ozs7QUFJRyxrQkE5Qk0sbUJBOEJOLHFCQUFvQjtNQUN6QixXQUFXO01BQ1gsWUFBWTtNQUNaLFVBQVU7Ozs7O0FDdkNkOzs7OzttQ0FJQSxXQUFBOzs7ZUFBcUI7Ozs7Ozs7OztBQUFOLCtDQUFxQyxVQUFBLFFBQVE7TUFDMUQsb0JBQW9CO0FBQ2xCLGNBQU0sUUFBUSxLQUFLLFlBQ2IsaUJBQWlCLEtBQUssTUFBTTtBQUVsQyxlQUFPOztNQUdULGtCQUFrQixnQkFBZ0I7QUFDaEMsY0FBTSxRQUFRLEtBQUssVUFBVSxnQkFBZ0IsTUFBTTtBQUVuRCxhQUFLLFNBQVM7O01BR2hCLGdCQUFnQjtBQUNkLGNBQU0sb0JBQW9CLEtBQUssa0JBQWtCLEtBQUssT0FDaEQsb0JBQW9CLEtBQUssa0JBQWtCLEtBQUs7QUFFdEQsZUFBUTtVQUNOO1VBQ0E7Ozs7QUFJRyxrQkF4Qk0sd0JBd0JOLHFCQUFvQjtNQUN6QixXQUFXO01BQ1gsWUFBWTs7Ozs7QUM5QmhCOzs7OzttQ0E4SUEsV0FBQTs7O2VBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBN0hBLFFBQU0sQ0FBRSx1QkFBd0IsT0FBQTtBQUFoQyxRQUNNLENBQUUsMEJBQTJCLE9BQUE7QUFFbkMsUUFBTSxDQUFFLE9BQVEsT0FBQTtBQUFoQixRQUNNLENBQUUsV0FBWSxPQUFBO0FBRXBCLDZCQUFtQixNQUFBLFFBQU87TUFDeEIsZUFBZSxDQUFDLE9BQU8sWUFBQTtBQUVuQixjQUFNLFNBQVMsS0FBSyxhQUNkLFlBQVksS0FBSyxhQUFhO0FBRXBDLGFBQUssVUFBVTtBQUVmLGFBQUssYUFBYTs7TUFVdEIsWUFBWTtBQUNWLGNBQU0saUJBQWlCLEtBQUsscUJBQ3RCLFdBQVUsZ0JBQ1YsY0FBYyx1QkFBdUIsV0FDckMsUUFBUSxhQUNSLFVBQVUsS0FBSyxjQUNmLFNBQVMsTUFBTSxTQUFTO0FBRTlCLGVBQU87O01BR1QsYUFBYSxRQUFRO0FBQ25CLFlBQUksWUFBWTtBQUVoQixjQUFNLE9BQU0sS0FBSyxVQUNYLGVBQWUsb0JBQW9CLE9BQ25DLFNBQVMsY0FDVCxXQUFXLEtBQUssZUFDaEIsVUFBVSxPQUFPLGNBQ2pCLE9BQU8sUUFBUSxXQUNmLE9BQU8sT0FBTyxNQUFNLFFBQVE7QUFFbEMsWUFBSSxTQUFTLE1BQU07QUFDakIsc0JBQVksS0FBSyxZQUFZOztBQUcvQixlQUFPOztNQUdULGdCQUFnQjtBQUNkLGVBRUUsc0JBQUEsY0FBQyxZQUFBLFlBQVUsTUFDVCxzQkFBQSxjQUFDLFVBQUEsU0FBVyxNQUNWLHNCQUFBLGNBQUMsWUFBQSxTQUFPLE1BQ04sc0JBQUEsY0FBQyxZQUFBLFNBQVUsTUFBQyxvQkFHWixzQkFBQSxjQUFDLGdCQUFBLFNBQXNCO1VBQUMsU0FBUyxLQUFLO1lBQ3RDLHNCQUFBLGNBQUMsWUFBQSxTQUFVLE1BQUMsUUFHWixzQkFBQSxjQUFDLEtBQUEsU0FBVztVQUFDLFNBQVMsS0FBSztZQUMzQixzQkFBQSxjQUFDLFlBQUEsU0FBVSxNQUFDLGNBR1osc0JBQUEsY0FBQyxVQUFBLFNBQWE7VUFBQyxTQUFTLEtBQUs7Y0FHakMsc0JBQUEsY0FBQyxZQUFBLHFCQUFtQixPQUNwQixzQkFBQSxjQUFDLFlBQUEsV0FBUyxNQUNSLHNCQUFBLGNBQUMsWUFBQSxTQUFPLE1BQ04sc0JBQUEsY0FBQyxZQUFBLFNBQVUsTUFBQyxZQUdaLHNCQUFBLGNBQUMsU0FBQSxTQUFlO1VBQUMsU0FBUyxLQUFLO1lBQy9CLHNCQUFBLGNBQUMsWUFBQSxTQUFVLE1BQUMsV0FHWixzQkFBQSxjQUFDLFFBQUEsU0FBYyxPQUNmLHNCQUFBLGNBQUMsWUFBQSxTQUFVLE1BQUMsZUFHWixzQkFBQSxjQUFDLFdBQUEsU0FBaUI7O01BUTVCLGFBQWE7QUFDWCxhQUFLO0FBRUwsY0FBTSxDQUFFLGdCQUFnQixtQkFBb0IsS0FBSyxhQUMzQyxVQUFVLGdCQUNWLFdBQVcsaUJBQ1gsaUJBQWlCO0FBRXZCLGFBQUssT0FBTztBQUVaLGFBQUssV0FBVztBQUVoQixhQUFLLFlBQVk7QUFFakIsYUFBSyxrQkFBa0I7QUFFdkIsYUFBSzs7O0FBR0Esa0JBNUdULE1BNEdTLG1CQUFrQjtBQUVsQixrQkE5R1QsTUE4R1Msa0JBQWlCO0FBRWpCLGtCQWhIVCxNQWdIUyxXQUFVO0FBRVYsa0JBbEhULE1Ba0hTLHFCQUFvQjtNQUN6QixXQUFXOztRQUlmLFdBQWUsSUFBQSxlQUFBLFNBQVU7Ozs7Ozs7O0FDOUl6Qjs7Ozs7Ozs7Ozs7Ozs7QUFVQSxRQUFNLENBQUUsZ0JBQWlCLGVBQUE7QUFFekI7QUFFQSxRQUFNLE9BQU8sSUFBSSxNQUFBO0FBRWpCLFNBQUssTUFFSCxzQkFBQSxjQUFDLE1BQUEsU0FBSTs7IiwKICAibmFtZXMiOiBbXQp9Cg==
