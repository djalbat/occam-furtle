(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
  var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/easy/lib/offset.js
  var require_offset = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Offset;
      }
    });
    var Offset = class {
      constructor(top, left) {
        this.top = top;
        this.left = left;
      }
      getTop() {
        return this.top;
      }
      getLeft() {
        return this.left;
      }
      static fromDOMElement(domElement) {
        const {offsetTop, offsetLeft} = domElement, top = offsetTop, left = offsetLeft, offset = new Offset(top, left);
        return offset;
      }
    };
  });

  // node_modules/easy/lib/bounds.js
  var require_bounds = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Bounds;
      }
    });
    var Bounds = class {
      constructor(top, left, right, bottom) {
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
      }
      getTop() {
        return this.top;
      }
      getLeft() {
        return this.left;
      }
      getRight() {
        return this.right;
      }
      getBottom() {
        return this.bottom;
      }
      getWidth() {
        const width = this.right - this.left;
        return width;
      }
      getHeight() {
        const height = this.bottom - this.top;
        return height;
      }
      setTop(top) {
        this.top = top;
      }
      setLeft(left) {
        this.left = left;
      }
      setRight(right) {
        this.right = right;
      }
      setBottom(bottom) {
        this.bottom = bottom;
      }
      areOverlapping(bounds) {
        const bottom = bounds.getBottom(), right = bounds.getRight(), left = bounds.getLeft(), top = bounds.getTop(), overlapping = this.top < bottom && this.left < right && this.right > left && this.bottom > top;
        return overlapping;
      }
      areOverlappingByTopAndLeft(top, left) {
        const overlapping = this.top <= top && this.left <= left && this.right > left && this.bottom > top;
        return overlapping;
      }
      static fromDOMElement(domElement) {
        const {pageXOffset, pageYOffset} = window, boundingClientRect = domElement.getBoundingClientRect(), windowScrollTop = pageYOffset, windowScrollLeft = pageXOffset, top = boundingClientRect.top + windowScrollTop, left = boundingClientRect.left + windowScrollLeft, right = boundingClientRect.right + windowScrollLeft, bottom = boundingClientRect.bottom + windowScrollTop, bounds = new Bounds(top, left, right, bottom);
        return bounds;
      }
      static fromTopLeftWidthAndHeight(top, left, width, height) {
        const bottom = top + height, right = left + width, bounds = new Bounds(top, left, right, bottom);
        return bounds;
      }
    };
  });

  // node_modules/easy/lib/utilities/array.js
  var require_array = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get augment() {
        return augment;
      },
      get first() {
        return first2;
      },
      get flatten() {
        return flatten;
      },
      get guarantee() {
        return guarantee;
      },
      get push() {
        return push;
      }
    });
    function first2(array) {
      return array[0];
    }
    function push(array1, array2) {
      Array.prototype.push.apply(array1, array2);
    }
    function augment(array1, array2, test) {
      array1 = [
        ...array1
      ];
      array2.forEach((element, index) => {
        const passed = test(element, index);
        if (passed) {
          array1.push(element);
        }
      });
      return array1;
    }
    function flatten(array) {
      return array.reduce((array2, element) => {
        array2 = array2.concat(element);
        return array2;
      }, []);
    }
    function guarantee(arrayOrElement) {
      arrayOrElement = arrayOrElement || [];
      return arrayOrElement instanceof Array ? arrayOrElement : [
        arrayOrElement
      ];
    }
  });

  // node_modules/easy/lib/constants.js
  var require_constants = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BLOCK() {
        return BLOCK;
      },
      get BODY() {
        return BODY;
      },
      get BOOLEAN() {
        return BOOLEAN;
      },
      get CLASS() {
        return CLASS;
      },
      get CLASS_NAME() {
        return CLASS_NAME;
      },
      get DEFAULT_PROPERTIES() {
        return DEFAULT_PROPERTIES;
      },
      get DISABLED() {
        return DISABLED;
      },
      get DISPLAY() {
        return DISPLAY;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get FOR() {
        return FOR;
      },
      get FUNCTION() {
        return FUNCTION;
      },
      get HEIGHT() {
        return HEIGHT;
      },
      get HTML_FOR() {
        return HTML_FOR;
      },
      get IGNORED_PROPERTIES() {
        return IGNORED_PROPERTIES;
      },
      get NONE() {
        return NONE;
      },
      get OBJECT() {
        return OBJECT;
      },
      get SPACE() {
        return SPACE;
      },
      get STRING() {
        return STRING;
      },
      get SVG_NAMESPACE_URI() {
        return SVG_NAMESPACE_URI;
      },
      get UNDEFINED() {
        return UNDEFINED;
      },
      get WIDTH() {
        return WIDTH;
      },
      get WILDCARD() {
        return WILDCARD;
      }
    });
    var FOR = "for";
    var BODY = "body";
    var NONE = "none";
    var SPACE = " ";
    var CLASS = "class";
    var WIDTH = "width";
    var BLOCK = "block";
    var HEIGHT = "height";
    var OBJECT = "object";
    var STRING = "string";
    var DISPLAY = "display";
    var BOOLEAN = "boolean";
    var DISABLED = "disabled";
    var FUNCTION = "function";
    var WILDCARD = "*";
    var HTML_FOR = "htmlFor";
    var UNDEFINED = "undefined";
    var CLASS_NAME = "className";
    var EMPTY_STRING = "";
    var SVG_NAMESPACE_URI = "http://www.w3.org/2000/svg";
    var DEFAULT_PROPERTIES = "defaultProperties";
    var IGNORED_PROPERTIES = "ignoredProperties";
  });

  // node_modules/easy/lib/utilities/object.js
  var require_object = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combine() {
        return combine;
      },
      get prune() {
        return prune;
      }
    });
    var _constants = require_constants();
    function combine(target, source = {}) {
      target = {
        ...target
      };
      const names = Object.keys(source);
      names.forEach((name) => {
        const targetValue = target[name], sourceValue = source[name], targetHasOwnProperty = target.hasOwnProperty(name);
        target[name] = targetHasOwnProperty ? combineValues(targetValue, sourceValue) : sourceValue;
      });
      return target;
    }
    function prune(target, names = []) {
      target = {
        ...target
      };
      names.forEach((name) => {
        const targetHasOwnProperty = target.hasOwnProperty(name);
        if (targetHasOwnProperty) {
          delete target[name];
        }
      });
      return target;
    }
    function combineValues(targetValue, sourceValue) {
      const targetValueBoolean = isValueBoolean(targetValue), sourceValueBoolean = isValueBoolean(sourceValue), combinedValue = targetValueBoolean && sourceValueBoolean ? targetValue : `${targetValue} ${sourceValue}`;
      return combinedValue;
    }
    function isValueBoolean(value) {
      const valueBoolean = typeof value === _constants.BOOLEAN;
      return valueBoolean;
    }
  });

  // node_modules/easy/lib/utilities/string.js
  var require_string = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "camelCaseToSnakeCase", {
      enumerable: true,
      get: function() {
        return camelCaseToSnakeCase;
      }
    });
    function camelCaseToSnakeCase(string) {
      return string.replace(/([A-Z]+)/g, (match, characters) => {
        const upperCaseCharacters = characters.toLowerCase(), snakeCaseCharacters = `-${upperCaseCharacters}`;
        return snakeCaseCharacters;
      });
    }
  });

  // node_modules/easy/lib/utilities/name.js
  var require_name = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isHTMLAttributeName() {
        return isHTMLAttributeName;
      },
      get isSVGAttributeName() {
        return isSVGAttributeName;
      },
      get isSVGTagName() {
        return isSVGTagName;
      }
    });
    function isSVGTagName(tagName) {
      return svgTagNames.includes(tagName);
    }
    function isSVGAttributeName(attributeName) {
      return svgAttributeNames.includes(attributeName);
    }
    function isHTMLAttributeName(attributeName) {
      return htmlAttributeNames.includes(attributeName);
    }
    var svgTagNames = [
      "altGlyph",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "animation",
      "audio",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "discard",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "handler",
      "hatch",
      "hatchpath",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "listener",
      "marker",
      "mask",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "prefetch",
      "radialGradient",
      "rect",
      "script",
      "set",
      "solidcolor",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "tbreak",
      "text",
      "textArea",
      "textPath",
      "title",
      "tref",
      "tspan",
      "unknown",
      "use",
      "video",
      "view",
      "vkern"
    ];
    var svgAttributeNames = [
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "alphabetic",
      "amplitude",
      "arabic-form",
      "ascent",
      "attributeName",
      "attributeType",
      "azimuth",
      "bandwidth",
      "baseFrequency",
      "baseProfile",
      "baseline-shift",
      "bbox",
      "begin",
      "bias",
      "by",
      "calcMode",
      "cap-height",
      "clip",
      "className",
      "clip-path",
      "clip-rule",
      "clipPathUnits",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "contentScriptType",
      "contentStyleType",
      "crossorigin",
      "cursor",
      "cx",
      "cy",
      "d",
      "defaultAction",
      "descent",
      "diffuseConstant",
      "direction",
      "display",
      "divisor",
      "dominant-baseline",
      "download",
      "dur",
      "dx",
      "dy",
      "edgeMode",
      "editable",
      "elevation",
      "enable-background",
      "end",
      "event",
      "exponent",
      "externalResourcesRequired",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterRes",
      "filterUnits",
      "flood-color",
      "flood-opacity",
      "focusHighlight",
      "focusable",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "format",
      "fr",
      "from",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "handler",
      "hanging",
      "hatchContentUnits",
      "hatchUnits",
      "height",
      "horiz-adv-x",
      "horiz-origin-x",
      "horiz-origin-y",
      "href",
      "hreflang",
      "id",
      "ideographic",
      "image-rendering",
      "in",
      "in2",
      "initialVisibility",
      "intercept",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kernelMatrix",
      "kernelUnitLength",
      "kerning",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "letter-spacing",
      "lighting-color",
      "limitingConeAngle",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "mask",
      "maskContentUnits",
      "maskUnits",
      "mathematical",
      "max",
      "media",
      "mediaCharacterEncoding",
      "mediaContentEncodings",
      "mediaSize",
      "mediaTime",
      "method",
      "min",
      "mode",
      "name",
      "nav-down",
      "nav-down-left",
      "nav-down-right",
      "nav-left",
      "nav-next",
      "nav-prev",
      "nav-right",
      "nav-up",
      "nav-up-left",
      "nav-up-right",
      "numOctaves",
      "observer",
      "offset",
      "opacity",
      "operator",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "overlay",
      "overline-position",
      "overline-thickness",
      "panose-1",
      "path",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "phase",
      "pitch",
      "playbackOrder",
      "playbackorder",
      "pointer-events",
      "points",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "propagate",
      "r",
      "radius",
      "refX",
      "refY",
      "rendering-intent",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "requiredFonts",
      "requiredFormats",
      "restart",
      "result",
      "rotate",
      "rx",
      "ry",
      "scale",
      "seed",
      "shape-rendering",
      "side",
      "slope",
      "snapshotTime",
      "spacing",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "src",
      "startOffset",
      "stdDeviation",
      "stemh",
      "stemv",
      "stitchTiles",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "string",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "style",
      "surfaceScale",
      "syncBehavior",
      "syncBehaviorDefault",
      "syncMaster",
      "syncTolerance",
      "syncToleranceDefault",
      "systemLanguage",
      "tableValues",
      "target",
      "targetX",
      "targetY",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textLength",
      "timelineBegin",
      "timelinebegin",
      "title",
      "to",
      "transform",
      "transformBehavior",
      "type",
      "u1",
      "u2",
      "underline-position",
      "underline-thickness",
      "unicode",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "values",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "viewBox",
      "viewTarget",
      "visibility",
      "width",
      "widths",
      "word-spacing",
      "writing-mode",
      "x",
      "x-height",
      "x1",
      "x2",
      "xChannelSelector",
      "y",
      "y1",
      "y2",
      "yChannelSelector",
      "z",
      "zoomAndPan"
    ];
    var htmlAttributeNames = [
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "allow",
      "allowFullScreen",
      "allowTransparency",
      "alt",
      "async",
      "autoComplete",
      "autoFocus",
      "autoPlay",
      "capture",
      "cellPadding",
      "cellSpacing",
      "challenge",
      "charSet",
      "checked",
      "cite",
      "classID",
      "className",
      "colSpan",
      "cols",
      "content",
      "contentEditable",
      "contextMenu",
      "controls",
      "coords",
      "crossOrigin",
      "data",
      "dateTime",
      "default",
      "defer",
      "dir",
      "disabled",
      "download",
      "draggable",
      "encType",
      "form",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "frameBorder",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hrefLang",
      "htmlFor",
      "httpEquiv",
      "icon",
      "id",
      "inputMode",
      "integrity",
      "is",
      "keyParams",
      "keyType",
      "kind",
      "label",
      "lang",
      "list",
      "loop",
      "low",
      "manifest",
      "marginHeight",
      "marginWidth",
      "max",
      "maxLength",
      "media",
      "mediaGroup",
      "method",
      "min",
      "minLength",
      "multiple",
      "muted",
      "name",
      "noValidate",
      "nonce",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "poster",
      "preload",
      "profile",
      "radioGroup",
      "readOnly",
      "rel",
      "required",
      "reversed",
      "role",
      "rowSpan",
      "rows",
      "sandbox",
      "scope",
      "scoped",
      "scrolling",
      "seamless",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "spellCheck",
      "src",
      "srcDoc",
      "srcLang",
      "srcSet",
      "start",
      "step",
      "style",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "value",
      "width",
      "wmode",
      "wrap"
    ];
  });

  // node_modules/easy/lib/utilities/element.js
  var require_element = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get constructElement() {
        return constructElement;
      },
      get default() {
        return _default;
      },
      get destroyElement() {
        return destroyElement;
      },
      get mountElement() {
        return mountElement;
      },
      get unmountElement() {
        return unmountElement;
      }
    });
    function constructElement(element, domElement) {
      element.domElement = domElement;
      domElement.__element__ = element;
    }
    function destroyElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.forEach((element2) => {
        const domElement = element2.getDOMElement();
        delete element2.domElement;
        delete domElement.__element__;
      });
    }
    function mountElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.reverse();
      elements.forEach((element2) => {
        element2.didMount && element2.didMount();
      });
    }
    function unmountElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.forEach((element2) => {
        element2.willUnmount && element2.willUnmount();
      });
    }
    var _default = {
      constructElement,
      destroyElement,
      mountElement,
      unmountElement
    };
  });

  // node_modules/easy/lib/utilities/dom.js
  var require_dom = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ascendantDOMNodesFromDOMNode() {
        return ascendantDOMNodesFromDOMNode;
      },
      get descendantDOMNodesFromDOMNode() {
        return descendantDOMNodesFromDOMNode;
      },
      get domNodeMatchesSelector() {
        return domNodeMatchesSelector;
      },
      get elementsFromDOMElements() {
        return elementsFromDOMElements;
      },
      get filterDOMNodes() {
        return filterDOMNodes;
      },
      get filterDOMNodesBySelector() {
        return filterDOMNodesBySelector;
      }
    });
    var _array = require_array();
    var _constants = require_constants();
    function elementsFromDOMElements(domElements) {
      const domElementsWithElements = filterDOMNodes(domElements, (domElement) => {
        if (domElement.__element__) {
          return true;
        }
      }), elements = domElementsWithElements.map((domElement) => {
        const element = domElement.__element__;
        return element;
      });
      return elements;
    }
    function ascendantDOMNodesFromDOMNode(domNode, height, ascendantDOMNodes = []) {
      if (height > 0) {
        const parentDOMNode = domNode.parentElement;
        if (parentDOMNode !== null) {
          ascendantDOMNodes.push(parentDOMNode);
          height--;
          ascendantDOMNodesFromDOMNode(parentDOMNode, height, ascendantDOMNodes);
        }
      }
      return ascendantDOMNodes;
    }
    function descendantDOMNodesFromDOMNode(domNode, depth, descendantDOMNodes = []) {
      if (depth > 0) {
        const childDOMNodes = domNode.childNodes;
        (0, _array.push)(descendantDOMNodes, childDOMNodes);
        depth--;
        childDOMNodes.forEach((childDOMNode) => {
          descendantDOMNodesFromDOMNode(childDOMNode, depth, descendantDOMNodes);
        });
      }
      return descendantDOMNodes;
    }
    function filterDOMNodesBySelector(domNodes, selector) {
      const filteredDOMNodes = filterDOMNodes(domNodes, (domNode) => {
        if (domNodeMatchesSelector(domNode, selector)) {
          return true;
        }
      });
      return filteredDOMNodes;
    }
    function domNodeMatchesSelector(domNode, selector) {
      const domNodeType = domNode.nodeType;
      switch (domNodeType) {
        case Node.ELEMENT_NODE: {
          const domElement = domNode;
          return domElement.matches(selector);
        }
        case Node.TEXT_NODE: {
          if (selector === _constants.WILDCARD) {
            return true;
          }
        }
      }
      return false;
    }
    function filterDOMNodes(domNodes, test) {
      const filteredDOMNodes = [], domNodesLength = domNodes.length;
      for (let index = 0; index < domNodesLength; index++) {
        const domNode = domNodes[index], result = test(domNode);
        if (result) {
          filteredDOMNodes.push(domNode);
        }
      }
      return filteredDOMNodes;
    }
  });

  // node_modules/easy/lib/mixins/element.js
  var require_element2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get getAscendantElements() {
        return getAscendantElements;
      },
      get getChildElements() {
        return getChildElements;
      },
      get getDescendantElements() {
        return getDescendantElements;
      },
      get getNextSiblingElement() {
        return getNextSiblingElement;
      },
      get getParentElement() {
        return getParentElement;
      },
      get getPreviousSiblingElement() {
        return getPreviousSiblingElement;
      }
    });
    var _array = require_array();
    var _constants = require_constants();
    var _dom = require_dom();
    function getParentElement(selector = _constants.WILDCARD) {
      let parentElement = null;
      const parentDOMElement = this.domElement.parentElement;
      if (parentDOMElement !== null) {
        if (parentDOMElement.matches(selector)) {
          const parentDOMElements = [
            parentDOMElement
          ], parentElements = (0, _dom.elementsFromDOMElements)(parentDOMElements), firstParentElement = (0, _array.first)(parentElements);
          parentElement = firstParentElement || null;
        }
      }
      return parentElement;
    }
    function getChildElements(selector = _constants.WILDCARD) {
      const childDOMNodes = this.domElement.childNodes, childDOMElements = (0, _dom.filterDOMNodesBySelector)(childDOMNodes, selector), childElements = (0, _dom.elementsFromDOMElements)(childDOMElements);
      return childElements;
    }
    function getAscendantElements(selector = _constants.WILDCARD, maximumHeight = Infinity) {
      const height = maximumHeight, domNode = this.domElement, ascendantDOMNodes = (0, _dom.ascendantDOMNodesFromDOMNode)(domNode, height), ascendantDOMElements = (0, _dom.filterDOMNodesBySelector)(ascendantDOMNodes, selector), ascendantElements = (0, _dom.elementsFromDOMElements)(ascendantDOMElements);
      return ascendantElements;
    }
    function getDescendantElements(selector = _constants.WILDCARD, maximumDepth = Infinity) {
      const depth = maximumDepth, domNode = this.domElement, descendantDOMNodes = (0, _dom.descendantDOMNodesFromDOMNode)(domNode, depth), descendantDOMElements = (0, _dom.filterDOMNodesBySelector)(descendantDOMNodes, selector), descendantElements = (0, _dom.elementsFromDOMElements)(descendantDOMElements);
      return descendantElements;
    }
    function getNextSiblingElement(selector = _constants.WILDCARD) {
      let nextSiblingElement = null;
      const nextSiblingDOMNode = this.domElement.nextSibling;
      if (nextSiblingDOMNode !== null && (0, _dom.domNodeMatchesSelector)(nextSiblingDOMNode, selector)) {
        nextSiblingElement = nextSiblingDOMNode.__element__ || null;
      }
      return nextSiblingElement;
    }
    function getPreviousSiblingElement(selector = _constants.WILDCARD) {
      let previousSiblingElement = null;
      const previousSiblingDOMNode = this.domElement.previousSibling;
      if (previousSiblingDOMNode !== null && (0, _dom.domNodeMatchesSelector)(previousSiblingDOMNode, selector)) {
        previousSiblingElement = previousSiblingDOMNode.__element__ || null;
      }
      return previousSiblingElement;
    }
    var elementMixins = {
      getParentElement,
      getChildElements,
      getAscendantElements,
      getDescendantElements,
      getNextSiblingElement,
      getPreviousSiblingElement
    };
    var _default = elementMixins;
  });

  // node_modules/easy/lib/textElement.js
  var require_textElement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TextElement;
      }
    });
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _element = require_element();
    var _element1 = require_element2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TextElement = class {
      constructor(text) {
        const element = this, domElement = document.createTextNode(text);
        (0, _element.constructElement)(element, domElement);
      }
      getDOMElement() {
        return this.domElement;
      }
      getOffset() {
        const offset = _offset.default.fromDOMElement(this.domElement);
        return offset;
      }
      getBounds() {
        const bounds = _bounds.default.fromDOMElement(this.domElement);
        return bounds;
      }
      getWidth() {
        return this.domElement.offsetWidth;
      }
      getHeight() {
        return this.domElement.offsetHeight;
      }
      getText() {
        const nodeValue = this.domElement.nodeValue, text = nodeValue;
        return text;
      }
      setText(text) {
        const nodeValue = text;
        this.domElement.nodeValue = nodeValue;
      }
      prependTo(parentElement) {
        parentElement.prepend(this);
      }
      appendTo(parentElement) {
        parentElement.append(this);
      }
      addTo(parentElement) {
        parentElement.add(this);
      }
      removeFrom(parentElement) {
        parentElement.remove(this);
      }
      insertBefore(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, siblingDOMElement);
      }
      insertAfter(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, siblingDOMElement.nextSibling);
      }
      remove() {
        this.domElement.remove();
      }
      destroy() {
        const element = this;
        (0, _element.destroyElement)(element);
      }
    };
    Object.assign(TextElement.prototype, {
      getParentElement: _element1.getParentElement,
      getAscendantElements: _element1.getAscendantElements,
      getNextSiblingElement: _element1.getNextSiblingElement,
      getPreviousSiblingElement: _element1.getPreviousSiblingElement
    });
  });

  // node_modules/easy/lib/utilities/elements.js
  var require_elements = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get removeFalseyElements() {
        return removeFalseyElements;
      },
      get replaceStringsWithTextElements() {
        return replaceStringsWithTextElements;
      }
    });
    var _textElement = /* @__PURE__ */ _interop_require_default(require_textElement());
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function removeFalseyElements(elements) {
      elements = elements.reduce((elements2, element) => {
        if (element) {
          elements2.push(element);
        }
        return elements2;
      }, []);
      return elements;
    }
    function replaceStringsWithTextElements(elements) {
      elements = elements.map((element) => {
        if (typeof element === _constants.STRING) {
          const text = element, textElement = new _textElement.default(text);
          element = textElement;
        }
        return element;
      });
      return elements;
    }
  });

  // node_modules/easy/lib/eventTypes.js
  var require_eventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AUXCLICK_EVENT_TYPE() {
        return AUXCLICK_EVENT_TYPE;
      },
      get BLUR_EVENT_TYPE() {
        return BLUR_EVENT_TYPE;
      },
      get CHANGE_EVENT_TYPE() {
        return CHANGE_EVENT_TYPE;
      },
      get CLICK_EVENT_TYPE() {
        return CLICK_EVENT_TYPE;
      },
      get CONTEXTMENU_EVENT_TYPE() {
        return CONTEXTMENU_EVENT_TYPE;
      },
      get COPY_EVENT_TYPE() {
        return COPY_EVENT_TYPE;
      },
      get CUT_EVENT_TYPE() {
        return CUT_EVENT_TYPE;
      },
      get DBLCLICK_EVENT_TYPE() {
        return DBLCLICK_EVENT_TYPE;
      },
      get ERROR_EVENT_TYPE() {
        return ERROR_EVENT_TYPE;
      },
      get FOCUS_EVENT_TYPE() {
        return FOCUS_EVENT_TYPE;
      },
      get FULLSCREENCHANGE_EVENT_TYPE() {
        return FULLSCREENCHANGE_EVENT_TYPE;
      },
      get INPUT_EVENT_TYPE() {
        return INPUT_EVENT_TYPE;
      },
      get KEYDOWN_EVENT_TYPE() {
        return KEYDOWN_EVENT_TYPE;
      },
      get KEYUP_EVENT_TYPE() {
        return KEYUP_EVENT_TYPE;
      },
      get MOUSEDOWN_EVENT_TYPE() {
        return MOUSEDOWN_EVENT_TYPE;
      },
      get MOUSEMOVE_EVENT_TYPE() {
        return MOUSEMOVE_EVENT_TYPE;
      },
      get MOUSEOUT_EVENT_TYPE() {
        return MOUSEOUT_EVENT_TYPE;
      },
      get MOUSEOVER_EVENT_TYPE() {
        return MOUSEOVER_EVENT_TYPE;
      },
      get MOUSEUP_EVENT_TYPE() {
        return MOUSEUP_EVENT_TYPE;
      },
      get PASTE_EVENT_TYPE() {
        return PASTE_EVENT_TYPE;
      },
      get RESIZE_EVENT_TYPE() {
        return RESIZE_EVENT_TYPE;
      },
      get SCROLL_EVENT_TYPE() {
        return SCROLL_EVENT_TYPE;
      },
      get SELECTIONCHANGE_EVENT_TYPE() {
        return SELECTIONCHANGE_EVENT_TYPE;
      },
      get SELECT_EVENT_TYPE() {
        return SELECT_EVENT_TYPE;
      },
      get TOUCHEND_EVENT_TYPE() {
        return TOUCHEND_EVENT_TYPE;
      },
      get TOUCHMOVE_EVENT_TYPE() {
        return TOUCHMOVE_EVENT_TYPE;
      },
      get TOUCHSTART_EVENT_TYPE() {
        return TOUCHSTART_EVENT_TYPE;
      },
      get UNHANDLEDREJECTION_EVENT_TYPE() {
        return UNHANDLEDREJECTION_EVENT_TYPE;
      },
      get WHEEL_EVENT_TYPE() {
        return WHEEL_EVENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var CUT_EVENT_TYPE = "cut";
    var COPY_EVENT_TYPE = "copy";
    var BLUR_EVENT_TYPE = "blur";
    var ERROR_EVENT_TYPE = "error";
    var PASTE_EVENT_TYPE = "paste";
    var WHEEL_EVENT_TYPE = "wheel";
    var INPUT_EVENT_TYPE = "input";
    var FOCUS_EVENT_TYPE = "focus";
    var CLICK_EVENT_TYPE = "click";
    var KEYUP_EVENT_TYPE = "keyup";
    var SELECT_EVENT_TYPE = "select";
    var CHANGE_EVENT_TYPE = "change";
    var RESIZE_EVENT_TYPE = "resize";
    var SCROLL_EVENT_TYPE = "scroll";
    var KEYDOWN_EVENT_TYPE = "keydown";
    var MOUSEUP_EVENT_TYPE = "mouseup";
    var AUXCLICK_EVENT_TYPE = "auxclick";
    var MOUSEOUT_EVENT_TYPE = "mouseout";
    var DBLCLICK_EVENT_TYPE = "dblclick";
    var TOUCHEND_EVENT_TYPE = "touchend";
    var TOUCHMOVE_EVENT_TYPE = "touchmove";
    var MOUSEOVER_EVENT_TYPE = "mouseover";
    var MOUSEDOWN_EVENT_TYPE = "mousedown";
    var MOUSEMOVE_EVENT_TYPE = "mousemove";
    var TOUCHSTART_EVENT_TYPE = "touchstart";
    var CONTEXTMENU_EVENT_TYPE = "contextmenu";
    var SELECTIONCHANGE_EVENT_TYPE = "selectionchange";
    var FULLSCREENCHANGE_EVENT_TYPE = "fullscreenchange";
    var UNHANDLEDREJECTION_EVENT_TYPE = "unhandledrejection";
    var _default = {
      CUT_EVENT_TYPE,
      COPY_EVENT_TYPE,
      BLUR_EVENT_TYPE,
      ERROR_EVENT_TYPE,
      PASTE_EVENT_TYPE,
      WHEEL_EVENT_TYPE,
      INPUT_EVENT_TYPE,
      FOCUS_EVENT_TYPE,
      CLICK_EVENT_TYPE,
      KEYUP_EVENT_TYPE,
      SELECT_EVENT_TYPE,
      CHANGE_EVENT_TYPE,
      RESIZE_EVENT_TYPE,
      SCROLL_EVENT_TYPE,
      KEYDOWN_EVENT_TYPE,
      MOUSEUP_EVENT_TYPE,
      AUXCLICK_EVENT_TYPE,
      MOUSEOUT_EVENT_TYPE,
      DBLCLICK_EVENT_TYPE,
      TOUCHEND_EVENT_TYPE,
      TOUCHMOVE_EVENT_TYPE,
      MOUSEOVER_EVENT_TYPE,
      MOUSEDOWN_EVENT_TYPE,
      MOUSEMOVE_EVENT_TYPE,
      TOUCHSTART_EVENT_TYPE,
      CONTEXTMENU_EVENT_TYPE,
      SELECTIONCHANGE_EVENT_TYPE,
      FULLSCREENCHANGE_EVENT_TYPE,
      UNHANDLEDREJECTION_EVENT_TYPE
    };
  });

  // node_modules/easy/lib/mixins/jsx.js
  var require_jsx = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _array = require_array();
    var _object = require_object();
    var _string = require_string();
    var _name = require_name();
    var _elements = require_elements();
    var _eventTypes = require_eventTypes();
    var _constants = require_constants();
    var DOUBLE_CLICK_EVENT_TYPE = "doubleclick";
    var SELECTION_CHANGE_EVENT_TYPE = "selectionChange";
    var FULL_SCREEN_CHANGE_EVENT_TYPE = "fullScreenChange";
    function applyProperties(properties, defaultProperties, ignoredProperties) {
      this.properties = (0, _object.combine)(properties, defaultProperties);
      properties = (0, _object.prune)(this.properties, ignoredProperties);
      const namespaceURI = this.domElement.namespaceURI, svg = namespaceURI === _constants.SVG_NAMESPACE_URI, propertiesKeys = Object.keys(properties), names = propertiesKeys;
      names.forEach((name) => {
        const value = properties[name], nameHandlerName = isNameHandlerName(name), nameCustomHandlerName = isNameCustomHandlerName(name);
        if (false) {
        } else if (nameHandlerName) {
          addHandler(this, name, value);
        } else if (nameCustomHandlerName) {
          addCustomHandler(this, name, value);
        } else {
          const nameAttributeName = isNameAttributeName(name, svg);
          if (nameAttributeName) {
            addAttribute(this, name, value);
          }
        }
      });
      const childElements = childElementsFromElement(this) || properties.childElements, context2 = {};
      childElements.forEach((childElement) => {
        updateContext(childElement, context2);
        this.add(childElement);
      });
      this.context = context2;
    }
    function getProperties() {
      return this.properties;
    }
    function getContext() {
      return this.context;
    }
    function assignContext(names) {
      if (names === void 0) {
        names = Object.keys(this.context);
      }
      names.forEach((name) => {
        const value = this.context[name], propertyName = name, descriptor = {
          value
        };
        Object.defineProperty(this, propertyName, descriptor);
        delete this.context[name];
      });
    }
    var jsxMixins = {
      applyProperties,
      getProperties,
      getContext,
      assignContext
    };
    var _default = jsxMixins;
    function childElementsFromElement(element) {
      let childElements = null;
      if (typeof element.childElements === _constants.FUNCTION) {
        childElements = element.childElements.call(element);
        childElements = (0, _array.guarantee)(childElements);
        childElements = (0, _elements.removeFalseyElements)(childElements);
        childElements = (0, _elements.replaceStringsWithTextElements)(childElements);
      }
      return childElements;
    }
    function updateContext(childElement, context2) {
      const parentContext = typeof childElement.parentContext === _constants.FUNCTION ? childElement.parentContext() : childElement.context;
      Object.assign(context2, parentContext);
    }
    function addHandler(element, name, value) {
      let eventType = name.substring(2).toLowerCase();
      switch (eventType) {
        case DOUBLE_CLICK_EVENT_TYPE: {
          eventType = _eventTypes.DBLCLICK_EVENT_TYPE;
          break;
        }
        case SELECTION_CHANGE_EVENT_TYPE: {
          eventType = _eventTypes.SELECTIONCHANGE_EVENT_TYPE;
          break;
        }
        case FULL_SCREEN_CHANGE_EVENT_TYPE: {
          eventType = _eventTypes.FULLSCREENCHANGE_EVENT_TYPE;
          break;
        }
      }
      const handler = value;
      element.onEvent(eventType, handler);
    }
    function addCustomHandler(element, name, value) {
      const customEventType = (0, _string.camelCaseToSnakeCase)(name).replace(/on-custom-/, ""), customHandler = value;
      element.onCustomEvent(customEventType, customHandler);
    }
    function addAttribute(element, name, value) {
      if (name === _constants.CLASS_NAME) {
        name = _constants.CLASS;
      }
      if (name === _constants.HTML_FOR) {
        name = _constants.FOR;
      }
      if (typeof value === _constants.OBJECT) {
        const keys = Object.keys(value);
        keys.forEach((key) => {
          element.domElement[name][key] = value[key];
        });
      } else if (typeof value === _constants.BOOLEAN) {
        if (value) {
          value = name;
          element.addAttribute(name, value);
        }
      } else {
        element.addAttribute(name, value);
      }
    }
    function isNameHandlerName(name) {
      const nameHandlerName = /^on(?!Custom)/.test(name);
      return nameHandlerName;
    }
    function isNameAttributeName(name, svg) {
      const nameAttributeName = svg ? (0, _name.isSVGAttributeName)(name) : (0, _name.isHTMLAttributeName)(name);
      return nameAttributeName;
    }
    function isNameCustomHandlerName(name) {
      const nameCustomHandlerName = /^onCustom/.test(name);
      return nameCustomHandlerName;
    }
  });

  // node_modules/easy/lib/mixins/key.js
  var require_key = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onKeyUp(keyUpHandler, element) {
      this.onEvent(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function offKeyUp(keyUpHandler, element) {
      this.offEvent(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function onKeyDown(keyDownHandler, element) {
      this.onEvent(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    function offKeyDown(keyDownHandler, element) {
      this.offEvent(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    var keyMixins = {
      onKeyUp,
      offKeyUp,
      onKeyDown,
      offKeyDown
    };
    var _default = keyMixins;
  });

  // node_modules/easy/lib/mixins/state.js
  var require_state = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    function getState() {
      return this.state;
    }
    function setState(state) {
      this.state = state;
    }
    function updateState(state) {
      this.state === void 0 ? this.state = state : Object.assign(this.state, state);
    }
    var stateMixins = {
      getState,
      setState,
      updateState
    };
    var _default = stateMixins;
  });

  // node_modules/easy/lib/mixins/event.js
  var require_event = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    function onEvent(eventTypes, handler, element = this) {
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach((eventType) => {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          const resizeEventListeners = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            this.resizeObserver = new ResizeObserver((entries) => {
              const resizeEventListeners2 = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE);
              resizeEventListeners2.forEach((resizeEventListener) => {
                const event = null;
                resizeEventListener(event);
              });
            });
            this.resizeObserver.observe(this.domElement);
          }
          this.addEventListener(eventType, handler, element);
        } else {
          const eventListener = this.addEventListener(eventType, handler, element);
          this.domElement.addEventListener(eventType, eventListener);
        }
      });
    }
    function offEvent(eventTypes, handler, element = this) {
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach((eventType) => {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          this.removeEventListener(eventType, handler, element);
          const resizeEventListeners = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            this.resizeObserver.unobserve(this.domElement);
            delete this.resizeObserver;
          }
        } else {
          const eventListener = this.removeEventListener(eventType, handler, element);
          this.domElement.removeEventListener(eventType, eventListener);
        }
      });
    }
    function addEventListener(eventType, handler, element) {
      const eventListener = this.createEventListener(eventType, handler, element);
      if (!this.eventListeners) {
        this.eventListeners = [];
      }
      this.eventListeners.push(eventListener);
      return eventListener;
    }
    function removeEventListener(eventType, handler, element) {
      const eventListener = this.findEventListener(eventType, handler, element), index = this.eventListeners.indexOf(eventListener), start = index, deleteCount = 1;
      this.eventListeners.splice(start, deleteCount);
      if (this.eventListeners.length === 0) {
        delete this.eventListeners;
      }
      return eventListener;
    }
    function findEventListener(eventType, handler, element) {
      const eventListener = this.eventListeners.find((eventListener2) => {
        if (eventListener2.element === element && eventListener2.handler === handler && eventListener2.eventType === eventType) {
          return true;
        }
      });
      return eventListener;
    }
    function findEventListeners(eventType) {
      const eventListeners = [];
      if (this.eventListeners) {
        this.eventListeners.forEach((eventListener) => {
          const found = eventListener.eventType === eventType;
          if (found) {
            eventListeners.push(eventListener);
          }
        });
      }
      return eventListeners;
    }
    function createEventListener(eventType, handler, element) {
      let eventListener;
      const handlerElement = element;
      eventListener = (event) => {
        const element2 = this;
        handler.call(handlerElement, event, element2);
      };
      Object.assign(eventListener, {
        element,
        handler,
        eventType
      });
      return eventListener;
    }
    var eventMixins = {
      onEvent,
      offEvent,
      addEventListener,
      removeEventListener,
      findEventListener,
      findEventListeners,
      createEventListener
    };
    var _default = eventMixins;
  });

  // node_modules/easy/lib/mixins/mouse.js
  var require_mouse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onMouseUp(mouseUpHandler, element) {
      this.onEvent(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function offMouseUp(mouseUpHandler, element) {
      this.offEvent(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function onMouseOut(mouseOutHandler, element) {
      this.onEvent(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function offMouseOut(mouseOutHandler, element) {
      this.offEvent(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function onMouseDown(mouseDownHandler, element) {
      this.onEvent(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function offMouseDown(mouseDownHandler, element) {
      this.offEvent(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function onMouseOver(mouseOverHandler, element) {
      this.onEvent(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function offMouseOver(mouseOverHandler, element) {
      this.offEvent(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function onMouseMove(mouseMoveHandler, element) {
      this.onEvent(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    function offMouseMove(mouseMoveHandler, element) {
      this.offEvent(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    var mouseMixins = {
      onMouseUp,
      offMouseUp,
      onMouseOut,
      offMouseOut,
      onMouseDown,
      offMouseDown,
      onMouseOver,
      offMouseOver,
      onMouseMove,
      offMouseMove
    };
    var _default = mouseMixins;
  });

  // node_modules/easy/lib/mixins/click.js
  var require_click = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onClick(clickHandler, element) {
      this.onEvent(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function offClick(clickHandler, element) {
      this.offEvent(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function onAuxClick(auxClickHandler, element) {
      this.onEvent(_eventTypes.AUXCLICK_EVENT_TYPE, auxClickHandler, element);
    }
    function offAuxClick(auxClickHandler, element) {
      this.offEvent(_eventTypes.AUXCLICK_EVENT_TYPE, auxClickHandler, element);
    }
    function onDoubleClick(doubleClickHandler, element) {
      this.onEvent(_eventTypes.DBLCLICK_EVENT_TYPE, doubleClickHandler, element);
    }
    function offDoubleClick(doubleClickHandler, element) {
      this.offEvent(_eventTypes.DBLCLICK_EVENT_TYPE, doubleClickHandler, element);
    }
    var clickMixins = {
      onClick,
      offClick,
      onAuxClick,
      offAuxClick,
      onDoubleClick,
      offDoubleClick
    };
    var _default = clickMixins;
  });

  // node_modules/easy/lib/mixins/touch.js
  var require_touch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onTouchStart(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHSTART_EVENT_TYPE, touchStartHandler);
    }
    function offTouchStart(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHSTART_EVENT_TYPE, touchStartHandler);
    }
    function onTouchMove(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHMOVE_EVENT_TYPE, touchStartHandler);
    }
    function offTouchMove(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHMOVE_EVENT_TYPE, touchStartHandler);
    }
    function onTouchEnd(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHEND_EVENT_TYPE, touchStartHandler);
    }
    function offTouchEnd(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHEND_EVENT_TYPE, touchStartHandler);
    }
    var clickMixins = {
      onTouchStart,
      offTouchStart,
      onTouchMove,
      offTouchMove,
      onTouchEnd,
      offTouchEnd
    };
    var _default = clickMixins;
  });

  // node_modules/easy/lib/mixins/scroll.js
  var require_scroll = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get offScroll() {
        return offScroll;
      },
      get onScroll() {
        return onScroll;
      }
    });
    var _eventTypes = require_eventTypes();
    function onScroll(scrollHandler, element) {
      this.onEvent(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function offScroll(scrollHandler, element) {
      this.offEvent(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function scrollTo(scrollTop, scrollLeft) {
      this.domElement.scrollTo(scrollLeft, scrollTop);
    }
    function getScrollTop() {
      return this.domElement.scrollTop;
    }
    function getScrollLeft() {
      return this.domElement.scrollLeft;
    }
    function getScrollWidth() {
      return this.domElement.scrollWidth;
    }
    function getScrollHeight() {
      return this.domElement.scrollHeight;
    }
    function setScrollTop(scrollTop) {
      this.domElement.scrollTop = scrollTop;
    }
    function setScrollLeft(scrollLeft) {
      this.domElement.scrollLeft = scrollLeft;
    }
    var scrollMixins = {
      onScroll,
      offScroll,
      scrollTo,
      getScrollTop,
      getScrollLeft,
      getScrollWidth,
      getScrollHeight,
      setScrollTop,
      setScrollLeft
    };
    var _default = scrollMixins;
  });

  // node_modules/easy/lib/mixins/resize.js
  var require_resize = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onResize(resizeHandler, element) {
      this.onEvent(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    function offResize(resizeHandler, element) {
      this.offEvent(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    var resizeMixins = {
      onResize,
      offResize
    };
    var _default = resizeMixins;
  });

  // node_modules/easy/lib/mixins/fullScreen.js
  var require_fullScreen = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onFullScreenChange(fullScreenChangeHandler, element) {
      this.onEvent(_eventTypes.FULLSCREENCHANGE_EVENT_TYPE, fullScreenChangeHandler, element);
    }
    function offFullScreenChange(fullScreenChangeHandler, element) {
      this.offEvent(_eventTypes.FULLSCREENCHANGE_EVENT_TYPE, fullScreenChangeHandler, element);
    }
    function requestFullScreen(errorHandler) {
      const domElement = this.getDOMElement();
      domElement.requestFullscreen().catch(errorHandler);
    }
    function exitFullScreen() {
      document.exitFullscreen();
    }
    function isFullScreen() {
      const {fullscreenElement} = document, fullScreen = fullscreenElement !== null;
      return fullScreen;
    }
    var fullscreenMixins = {
      onFullScreenChange,
      offFullScreenChange,
      requestFullScreen,
      exitFullScreen,
      isFullScreen
    };
    var _default = fullscreenMixins;
  });

  // node_modules/easy/lib/utilities/async.js
  var require_async = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "forEach", {
      enumerable: true,
      get: function() {
        return forEach;
      }
    });
    function forEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
  });

  // node_modules/easy/lib/mixins/customEvent.js
  var require_customEvent = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants();
    var _async = require_async();
    function onCustomEvent(customEventTypes, customHandler, element = this) {
      customEventTypes = customEventTypes.split(_constants.SPACE);
      customEventTypes.forEach((customEventType) => {
        this.addCustomEventListener(customEventType, customHandler, element);
      });
    }
    function offCustomEvent(customEventTypes, customHandler, element = this) {
      customEventTypes = customEventTypes.split(_constants.SPACE);
      customEventTypes.forEach((customEventType) => {
        this.removeCustomEventListener(customEventType, customHandler, element);
      });
    }
    function callCustomHandlers(customEventType, ...remainingArguments) {
      const customEventListeners = this.findCustomEventListeners(customEventType);
      customEventListeners.forEach((customEventListener) => {
        const {customHandler, element: customHandlerElement} = customEventListener;
        customHandler.call(customHandlerElement, ...remainingArguments);
      });
    }
    function callCustomHandlersAsync(customEventType, ...remainingArguments) {
      const customEventListeners = this.findCustomEventListeners(customEventType), done = remainingArguments.pop();
      (0, _async.forEach)(customEventListeners, (customEventListener, next) => {
        const {customHandler, element: customHandlerElement} = customEventListener, done2 = next;
        customHandler.call(customHandlerElement, ...remainingArguments, done2);
      }, done);
    }
    function addCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.createCustomEventListener(customEventType, customHandler, element);
      if (!this.customEventListeners) {
        this.customEventListeners = [];
      }
      this.customEventListeners.push(customEventListener);
      return customEventListener;
    }
    function removeCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.findCustomEventListener(customEventType, customHandler, element), index = this.customEventListeners.indexOf(customEventListener), start = index, deleteCount = 1;
      this.customEventListeners.splice(start, deleteCount);
      if (this.customEventListeners.length === 0) {
        delete this.customEventListeners;
      }
      return customEventListener;
    }
    function findCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.customEventListeners.find((customEventListener2) => {
        if (customEventListener2.element === element && customEventListener2.customHandler === customHandler && customEventListener2.customEventType === customEventType) {
          return true;
        }
      });
      return customEventListener;
    }
    function findCustomEventListeners(customEventType) {
      const customEventListeners = [];
      if (this.customEventListeners) {
        this.customEventListeners.forEach((customEventListener) => {
          const found = customEventListener.customEventType === customEventType;
          if (found) {
            customEventListeners.push(customEventListener);
          }
        });
      }
      return customEventListeners;
    }
    function createCustomEventListener(customEventType, customHandler, element) {
      let customEventListener;
      customEventListener = () => {
      };
      Object.assign(customEventListener, {
        element,
        customHandler,
        customEventType
      });
      return customEventListener;
    }
    var customEventMixins = {
      onCustomEvent,
      offCustomEvent,
      callCustomHandlers,
      callCustomHandlersAsync,
      addCustomEventListener,
      removeCustomEventListener,
      findCustomEventListener,
      findCustomEventListeners,
      createCustomEventListener
    };
    var _default = customEventMixins;
  });

  // node_modules/easy/lib/element.js
  var require_element3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Element;
      }
    });
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _jsx = /* @__PURE__ */ _interop_require_default(require_jsx());
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _state = /* @__PURE__ */ _interop_require_default(require_state());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _touch = /* @__PURE__ */ _interop_require_default(require_touch());
    var _scroll = /* @__PURE__ */ _interop_require_default(require_scroll());
    var _resize = /* @__PURE__ */ _interop_require_default(require_resize());
    var _element = /* @__PURE__ */ _interop_require_default(require_element2());
    var _fullScreen = /* @__PURE__ */ _interop_require_default(require_fullScreen());
    var _customEvent = /* @__PURE__ */ _interop_require_default(require_customEvent());
    var _array = require_array();
    var _object = require_object();
    var _name = require_name();
    var _element1 = require_element();
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Element = class {
      constructor(selector) {
        if (selector !== null) {
          const element = this, domElement = document.querySelector(selector);
          (0, _element1.constructElement)(element, domElement);
        }
      }
      getDOMElement() {
        return this.domElement;
      }
      getOffset() {
        const offset = _offset.default.fromDOMElement(this.domElement);
        return offset;
      }
      getBounds() {
        const bounds = _bounds.default.fromDOMElement(this.domElement);
        return bounds;
      }
      getWidth() {
        return this.domElement.offsetWidth;
      }
      getHeight() {
        return this.domElement.offsetHeight;
      }
      getInnerWidth() {
        return this.domElement.clientWidth;
      }
      getInnerHeight() {
        return this.domElement.clientHeight;
      }
      setWidth(width) {
        width = `${width}px`;
        this.style(_constants.WIDTH, width);
      }
      setHeight(height) {
        height = `${height}px`;
        this.style(_constants.HEIGHT, height);
      }
      hasAttribute(name) {
        return this.domElement.hasAttribute(name);
      }
      getAttribute(name) {
        return this.domElement.getAttribute(name);
      }
      setAttribute(name, value) {
        this.domElement.setAttribute(name, value);
      }
      clearAttribute(name) {
        this.domElement.removeAttribute(name);
      }
      addAttribute(name, value) {
        this.setAttribute(name, value);
      }
      removeAttribute(name) {
        this.clearAttribute(name);
      }
      hasClass(className) {
        return this.domElement.classList.contains(className);
      }
      setClass(className) {
        this.domElement.className = className;
      }
      addClass(className) {
        this.domElement.classList.add(className);
      }
      removeClass(className) {
        this.domElement.classList.remove(className);
      }
      toggleClass(className) {
        this.domElement.classList.toggle(className);
      }
      removeAllClasses() {
        this.domElement.className = _constants.EMPTY_STRING;
      }
      addTo(parentElement) {
        parentElement.add(this);
      }
      appendTo(parentElement) {
        parentElement.append(this);
      }
      prependTo(parentElement) {
        parentElement.prepend(this);
      }
      removeFrom(parentElement) {
        parentElement.remove(this);
      }
      insert(element) {
        this.append(element);
      }
      add(element) {
        this.append(element);
      }
      remove(element) {
        if (element) {
          element.remove();
          return;
        }
        this.domElement.remove();
      }
      prepend(element) {
        const domElement = element.domElement, referenceDOMElement = this.domElement.firstChild;
        this.domElement.insertBefore(domElement, referenceDOMElement);
      }
      append(element) {
        const domElement = element.domElement, referenceDOMElement = null;
        this.domElement.insertBefore(domElement, referenceDOMElement);
      }
      insertBefore(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, referenceDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, referenceDOMElement);
      }
      insertAfter(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, referenceDOMElement = siblingElement.domElement.nextSibling;
        parentDOMNode.insertBefore(this.domElement, referenceDOMElement);
      }
      mount(element) {
        this.add(element);
        (0, _element1.mountElement)(element);
      }
      unmount(element) {
        (0, _element1.unmountElement)(element);
        this.remove(element);
      }
      mountBefore(siblingElement) {
        this.insertBefore(siblingElement);
        const element = this;
        (0, _element1.mountElement)(element);
      }
      mountAfter(siblingElement) {
        this.insertAfter(siblingElement);
        const element = this;
        (0, _element1.mountElement)(element);
      }
      show(displayStyle = _constants.BLOCK) {
        this.display(displayStyle);
      }
      hide() {
        this.style(_constants.DISPLAY, _constants.NONE);
      }
      display(display) {
        this.style(_constants.DISPLAY, display);
      }
      enable() {
        this.clearAttribute(_constants.DISABLED);
      }
      disable() {
        this.setAttribute(_constants.DISABLED, _constants.DISABLED);
      }
      isEnabled() {
        const disabled = this.isDisabled(), enabled = !disabled;
        return enabled;
      }
      isDisabled() {
        const disabled = this.hasAttribute(_constants.DISABLED);
        return disabled;
      }
      isDisplayed() {
        const display = this.css(_constants.DISPLAY), displayed = display !== _constants.NONE;
        return displayed;
      }
      isShowing() {
        const displayed = this.isDisplayed(), showing = displayed;
        return showing;
      }
      isHidden() {
        const displayed = this.isDisplayed(), hidden = !displayed;
        return hidden;
      }
      style(name, value = null) {
        if (value !== null) {
          this.domElement.style[name] = value;
          return;
        }
        const style = this.domElement.style[name];
        return style;
      }
      html(html = null) {
        if (html !== null) {
          const innerHTML2 = html;
          this.domElement.innerHTML = innerHTML2;
          return;
        }
        const innerHTML = this.domElement.innerHTML;
        html = innerHTML;
        return html;
      }
      css(css = null) {
        if (css === null) {
          css = {};
          const computedStyles = getComputedStyle(this.domElement);
          for (let index = 0; index < computedStyles.length; index++) {
            const computedStyle = computedStyles[index], name = computedStyle, value = computedStyles.getPropertyValue(name);
            css[name] = value;
          }
        } else if (typeof css === _constants.STRING) {
          let name = css;
          const computedStyles = getComputedStyle(this.domElement), value = computedStyles.getPropertyValue(name);
          css = value;
        } else {
          const names = Object.keys(css);
          names.forEach((name) => {
            const value = css[name];
            this.style(name, value);
          });
        }
        return css;
      }
      destroy() {
        const element = this;
        (0, _element1.destroyElement)(element);
      }
      static fromClass(Class, properties, ...remainingArguments) {
        const {tagName} = Class, element = elementFromTagName(Class, tagName, ...remainingArguments), defaultProperties = defaultPropertiesFromClass(Class), ignoredProperties = ignoredPropertiesFromClass(Class);
        element.applyProperties(properties, defaultProperties, ignoredProperties);
        element.initialise && element.initialise();
        return element;
      }
      static fromTagName(tagName, properties, ...remainingArguments) {
        const Class = Element, element = elementFromTagName(Class, tagName, ...remainingArguments), defaultProperties = {}, ignoredProperties = [];
        element.applyProperties(properties, defaultProperties, ignoredProperties);
        element.initialise && element.initialise();
        return element;
      }
    };
    Object.assign(Element.prototype, _jsx.default);
    Object.assign(Element.prototype, _key.default);
    Object.assign(Element.prototype, _mouse.default);
    Object.assign(Element.prototype, _click.default);
    Object.assign(Element.prototype, _state.default);
    Object.assign(Element.prototype, _event.default);
    Object.assign(Element.prototype, _touch.default);
    Object.assign(Element.prototype, _scroll.default);
    Object.assign(Element.prototype, _resize.default);
    Object.assign(Element.prototype, _element.default);
    Object.assign(Element.prototype, _fullScreen.default);
    Object.assign(Element.prototype, _customEvent.default);
    function elementFromTagName(Class, tagName, ...remainingArguments) {
      const selector = null, element = new (Function.prototype.bind.call(Class, null, selector, ...remainingArguments))(), domElement = (0, _name.isSVGTagName)(tagName) ? document.createElementNS(_constants.SVG_NAMESPACE_URI, tagName) : document.createElement(tagName);
      (0, _element1.constructElement)(element, domElement);
      return element;
    }
    function defaultPropertiesFromClass(Class, defaultProperties = {}) {
      if (Class.hasOwnProperty(_constants.DEFAULT_PROPERTIES)) {
        defaultProperties = (0, _object.combine)(defaultProperties, Class[_constants.DEFAULT_PROPERTIES]);
      }
      const superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        defaultProperties = defaultPropertiesFromClass(superClass, defaultProperties);
      }
      return defaultProperties;
    }
    function ignoredPropertiesFromClass(Class, ignoredProperties = []) {
      if (Class.hasOwnProperty(_constants.IGNORED_PROPERTIES)) {
        ignoredProperties = (0, _array.augment)(ignoredProperties, Class[_constants.IGNORED_PROPERTIES], (ignoredProperty) => {
          if (!ignoredProperties.includes(ignoredProperty)) {
            return true;
          }
        });
      }
      const superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        ignoredProperties = ignoredPropertiesFromClass(superClass, ignoredProperties);
      }
      return ignoredProperties;
    }
  });

  // node_modules/easy/lib/react.js
  var require_react = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _array = require_array();
    var _constants = require_constants();
    var _elements = require_elements();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createElement(firstArgument, properties, ...childElements) {
      let element = null;
      if (firstArgument) {
        childElements = sanitiseChildElements(childElements);
        properties = Object.assign({
          childElements
        }, properties);
        if (false) {
        } else if (isSubclassOf(firstArgument, _element.default)) {
          const Class = firstArgument;
          element = Class.fromClass(Class, properties);
        } else if (typeof firstArgument === _constants.STRING) {
          const tagName = firstArgument;
          element = _element.default.fromTagName(tagName, properties);
        } else if (typeof firstArgument === _constants.FUNCTION) {
          const elementFunction = firstArgument;
          element = elementFunction(properties);
        }
      }
      return element;
    }
    var React2 = {
      createElement
    };
    var _default = React2;
    function sanitiseChildElements(childElements) {
      childElements = (0, _array.flatten)(childElements);
      childElements = (0, _elements.removeFalseyElements)(childElements);
      childElements = (0, _elements.replaceStringsWithTextElements)(childElements);
      return childElements;
    }
    function isSubclassOf(argument, Class) {
      const subclassOf = argument.prototype instanceof Class;
      return subclassOf;
    }
  });

  // node_modules/easy/lib/mouseButtons.js
  var require_mouseButtons = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get LEFT_MOUSE_BUTTON() {
        return LEFT_MOUSE_BUTTON;
      },
      get MIDDLE_MOUSE_BUTTON() {
        return MIDDLE_MOUSE_BUTTON;
      },
      get RIGHT_MOUSE_BUTTON() {
        return RIGHT_MOUSE_BUTTON;
      },
      get default() {
        return _default;
      }
    });
    var LEFT_MOUSE_BUTTON = 0;
    var RIGHT_MOUSE_BUTTON = 2;
    var MIDDLE_MOUSE_BUTTON = 1;
    var _default = {
      LEFT_MOUSE_BUTTON,
      RIGHT_MOUSE_BUTTON,
      MIDDLE_MOUSE_BUTTON
    };
  });

  // node_modules/easy/lib/mixins/input.js
  var require_input = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onInput(inputHandler, element) {
      this.onEvent(_eventTypes.INPUT_EVENT_TYPE, inputHandler, element);
    }
    function offInput(inputHandler, element) {
      this.offEvent(_eventTypes.INPUT_EVENT_TYPE, inputHandler, element);
    }
    function onChange(changeHandler, element) {
      this.onEvent(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function offChange(changeHandler, element) {
      this.offEvent(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function getValue() {
      return this.domElement.value;
    }
    function setValue(value) {
      this.domElement.value = value;
    }
    function isReadOnly() {
      return this.domElement.readOnly;
    }
    function setReadOnly(readOnly) {
      this.domElement.readOnly = readOnly;
    }
    var inputMixins = {
      onInput,
      offInput,
      onChange,
      offChange,
      getValue,
      setValue,
      isReadOnly,
      setReadOnly
    };
    var _default = inputMixins;
  });

  // node_modules/easy/lib/mixins/focus.js
  var require_focus = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onBlur(blurHandler, element) {
      this.onEvent(_eventTypes.BLUR_EVENT_TYPE, blurHandler, element);
    }
    function offBlur(blurHandler, element) {
      this.offEvent(_eventTypes.BLUR_EVENT_TYPE, blurHandler, element);
    }
    function onFocus(focusHandler, element) {
      this.onEvent(_eventTypes.FOCUS_EVENT_TYPE, focusHandler, element);
    }
    function offFocus(focusHandler, element) {
      this.offEvent(_eventTypes.FOCUS_EVENT_TYPE, focusHandler, element);
    }
    function blur() {
      this.domElement.blur();
    }
    function focus() {
      this.domElement.focus();
    }
    function hasFocus() {
      const focus2 = document.activeElement === this.domElement;
      return focus2;
    }
    var focusMixins = {
      onBlur,
      offBlur,
      onFocus,
      offFocus,
      blur,
      focus,
      hasFocus
    };
    var _default = focusMixins;
  });

  // node_modules/easy/lib/mixins/selection.js
  var require_selection = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onCut(cutHandler, element) {
      this.onEvent(_eventTypes.CUT_EVENT_TYPE, cutHandler, element);
    }
    function offCut(cutHandler, element) {
      this.offEvent(_eventTypes.CUT_EVENT_TYPE, cutHandler, element);
    }
    function onCopy(copyHandler, element) {
      this.onEvent(_eventTypes.COPY_EVENT_TYPE, copyHandler, element);
    }
    function offCopy(copyHandler, element) {
      this.offEvent(_eventTypes.COPY_EVENT_TYPE, copyHandler, element);
    }
    function onPaste(pasteHandler, element) {
      this.onEvent(_eventTypes.PASTE_EVENT_TYPE, pasteHandler, element);
    }
    function offPaste(pasteHandler, element) {
      this.offEvent(_eventTypes.PASTE_EVENT_TYPE, pasteHandler, element);
    }
    function getSelectionStart() {
      return this.domElement.selectionStart;
    }
    function getSelectionEnd() {
      return this.domElement.selectionEnd;
    }
    function setSelectionStart(selectionStart) {
      this.domElement.selectionStart = selectionStart;
    }
    function setSelectionEnd(selectionEnd) {
      this.domElement.selectionEnd = selectionEnd;
    }
    function select() {
      this.domElement.select();
    }
    var selectionMixins = {
      onCut,
      offCut,
      onCopy,
      offCopy,
      onPaste,
      offPaste,
      getSelectionStart,
      getSelectionEnd,
      setSelectionStart,
      setSelectionEnd,
      select
    };
    var _default = selectionMixins;
  });

  // node_modules/easy/lib/document.js
  var require_document = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Document = class {
      constructor() {
        this.domElement = document;
      }
      getDOMElement() {
        return this.domElement;
      }
      getSelection() {
        return this.domElement.getSelection();
      }
      createRange() {
        return this.domElement.createRange();
      }
      createTextNode(data) {
        return this.domElement.createTextNode(data);
      }
      onSelectionChange(selectionChangeHandler, element) {
        this.onEvent(_eventTypes.SELECTIONCHANGE_EVENT_TYPE, selectionChangeHandler, element);
      }
      offSelectionChange(selectionChangeHandler, element) {
        this.offEvent(_eventTypes.SELECTIONCHANGE_EVENT_TYPE, selectionChangeHandler, element);
      }
      createEventListener(eventType, handler, element) {
        let eventListener;
        const handlerElement = element;
        eventListener = (event) => {
          if (eventType === _eventTypes.SELECTIONCHANGE_EVENT_TYPE) {
            const {domElement} = handlerElement, {currentTarget} = event, {activeElement} = currentTarget;
            if (domElement !== activeElement) {
              return;
            }
          }
          const element2 = this;
          handler.call(handlerElement, event, element2);
        };
        Object.assign(eventListener, {
          element,
          handler,
          eventType
        });
        return eventListener;
      }
    };
    Object.assign(Document.prototype, _key.default);
    Object.assign(Document.prototype, _event.default);
    Object.assign(Document.prototype, _mouse.default);
    Object.assign(Document.prototype, _click.default);
    var _default = typeof document === _constants.UNDEFINED ? void 0 : new Document();
  });

  // node_modules/easy/lib/window.js
  var require_window = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    var _scroll = require_scroll();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Window = class {
      constructor() {
        this.domElement = window;
      }
      getDOMElement() {
        return this.domElement;
      }
      assign(...sources) {
        const target = this.domElement;
        Object.assign(target, ...sources);
      }
      reload() {
        window.location.reload();
      }
      getWidth() {
        return this.domElement.innerWidth;
      }
      getHeight() {
        return this.domElement.innerHeight;
      }
      getScrollTop() {
        return this.domElement.pageYOffset;
      }
      getScrollLeft() {
        return this.domElement.pageXOffset;
      }
      getSelection() {
        return this.domElement.getSelection();
      }
      getScreenWidth() {
        return this.domElement.screen.width;
      }
      getScreenHeight() {
        return this.domElement.screen.height;
      }
      scrollTo(scrollTop, scrollLeft) {
        this.domElement.scrollTo(scrollLeft, scrollTop);
      }
      onResize(resizeHandler, element) {
        const eventType = _eventTypes.RESIZE_EVENT_TYPE, eventListener = this.addEventListener(eventType, resizeHandler, element);
        this.domElement.addEventListener(eventType, eventListener);
      }
      offResize(resizeHandler, element) {
        const eventType = _eventTypes.RESIZE_EVENT_TYPE, eventListener = this.removeEventListener(eventType, resizeHandler, element);
        this.domElement.removeEventListener(eventType, eventListener);
      }
    };
    Object.assign(Window.prototype, _key.default);
    Object.assign(Window.prototype, _event.default);
    Object.assign(Window.prototype, _mouse.default);
    Object.assign(Window.prototype, _click.default);
    Object.assign(Window.prototype, _focus.default);
    Object.assign(Window.prototype, {
      onScroll: _scroll.onScroll,
      offScroll: _scroll.offScroll
    });
    var _default = typeof window === _constants.UNDEFINED ? void 0 : new Window();
  });

  // node_modules/easy/lib/element/body.js
  var require_body = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Body;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Body = class extends _element.default {
      constructor(selector = _constants.BODY) {
        super(selector);
      }
    };
    __publicField(Body, "tagName", "body");
  });

  // node_modules/easy/lib/element/link.js
  var require_link = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Link;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Link = class extends _element.default {
      getHRef() {
        return this.getAttribute("href");
      }
      setHRef(href) {
        return this.setAttribute("href", href);
      }
    };
    __publicField(Link, "tagName", "a");
    Object.assign(Link.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/input.js
  var require_input2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Input;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Input = class extends _element.default {
    };
    __publicField(Input, "tagName", "input");
    Object.assign(Input.prototype, _input.default);
    Object.assign(Input.prototype, _focus.default);
    Object.assign(Input.prototype, _selection.default);
  });

  // node_modules/easy/lib/element/button.js
  var require_button = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Button;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Button = class extends _element.default {
    };
    __publicField(Button, "tagName", "button");
    Object.assign(Button.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/select.js
  var require_select = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Select;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Select = class extends _element.default {
    };
    __publicField(Select, "tagName", "select");
    Object.assign(Select.prototype, _input.default);
    Object.assign(Select.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/checkbox.js
  var require_checkbox = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Checkbox;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Checkbox = class extends _element.default {
      isChecked() {
        return this.domElement.checked;
      }
      check(checked = true) {
        this.domElement.checked = checked;
      }
    };
    __publicField(Checkbox, "tagName", "input");
    __publicField(Checkbox, "defaultProperties", {
      type: "checkbox"
    });
    Object.assign(Checkbox.prototype, _input.default);
    Object.assign(Checkbox.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/textarea.js
  var require_textarea = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Textarea;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Textarea = class extends _element.default {
    };
    __publicField(Textarea, "tagName", "textarea");
    Object.assign(Textarea.prototype, _input.default);
    Object.assign(Textarea.prototype, _focus.default);
    Object.assign(Textarea.prototype, _selection.default);
  });

  // node_modules/easy/lib/index.js
  var require_lib = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Body() {
        return _body.default;
      },
      get Bounds() {
        return _bounds.default;
      },
      get Button() {
        return _button.default;
      },
      get Checkbox() {
        return _checkbox.default;
      },
      get Element() {
        return _element1.default;
      },
      get Input() {
        return _input1.default;
      },
      get Link() {
        return _link.default;
      },
      get Offset() {
        return _offset.default;
      },
      get React() {
        return _react.default;
      },
      get Select() {
        return _select.default;
      },
      get TextElement() {
        return _textElement.default;
      },
      get Textarea() {
        return _textarea.default;
      },
      get customEventMixins() {
        return _customEvent.default;
      },
      get document() {
        return _document.default;
      },
      get elementUtilities() {
        return _element.default;
      },
      get eventTypes() {
        return _eventTypes.default;
      },
      get focusMixins() {
        return _focus.default;
      },
      get inputMixins() {
        return _input.default;
      },
      get mouseButtons() {
        return _mouseButtons.default;
      },
      get selectionMixins() {
        return _selection.default;
      },
      get window() {
        return _window.default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_default(require_react());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _eventTypes = /* @__PURE__ */ _interop_require_default(require_eventTypes());
    var _mouseButtons = /* @__PURE__ */ _interop_require_default(require_mouseButtons());
    var _element = /* @__PURE__ */ _interop_require_default(require_element());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    var _customEvent = /* @__PURE__ */ _interop_require_default(require_customEvent());
    var _element1 = /* @__PURE__ */ _interop_require_default(require_element3());
    var _textElement = /* @__PURE__ */ _interop_require_default(require_textElement());
    var _document = /* @__PURE__ */ _interop_require_default(require_document());
    var _window = /* @__PURE__ */ _interop_require_default(require_window());
    var _body = /* @__PURE__ */ _interop_require_default(require_body());
    var _link = /* @__PURE__ */ _interop_require_default(require_link());
    var _input1 = /* @__PURE__ */ _interop_require_default(require_input2());
    var _button = /* @__PURE__ */ _interop_require_default(require_button());
    var _select = /* @__PURE__ */ _interop_require_default(require_select());
    var _checkbox = /* @__PURE__ */ _interop_require_default(require_checkbox());
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/juxtapose/lib/juxtapose.js
  var require_juxtapose = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _easy = require_lib();
    Object.assign(globalThis, {
      React: _easy.React
    });
  });

  // node_modules/juxtapose/lib/index.js
  var require_lib2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_juxtapose();
  });

  // node_modules/with-style/lib/tagNames.js
  var require_tagNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var tagNames = [
      "a",
      "abbr",
      "address",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ];
    var _default = tagNames;
  });

  // node_modules/necessary/lib/levels.js
  var require_levels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DEBUG_LEVEL() {
        return DEBUG_LEVEL;
      },
      get ERROR_LEVEL() {
        return ERROR_LEVEL;
      },
      get FATAL_LEVEL() {
        return FATAL_LEVEL;
      },
      get INFO_LEVEL() {
        return INFO_LEVEL;
      },
      get TRACE_LEVEL() {
        return TRACE_LEVEL;
      },
      get WARNING_LEVEL() {
        return WARNING_LEVEL;
      },
      get default() {
        return _default;
      }
    });
    var TRACE_LEVEL = "trace";
    var DEBUG_LEVEL = "debug";
    var INFO_LEVEL = "info";
    var WARNING_LEVEL = "warning";
    var ERROR_LEVEL = "error";
    var FATAL_LEVEL = "fatal";
    var _default = {
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL,
      FATAL_LEVEL
    };
  });

  // node_modules/necessary/lib/methods.js
  var require_methods = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DELETE_METHOD() {
        return DELETE_METHOD;
      },
      get GET_METHOD() {
        return GET_METHOD;
      },
      get OPTIONS_METHOD() {
        return OPTIONS_METHOD;
      },
      get PATCH_METHOD() {
        return PATCH_METHOD;
      },
      get POST_METHOD() {
        return POST_METHOD;
      },
      get default() {
        return _default;
      }
    });
    var GET_METHOD = "GET";
    var POST_METHOD = "POST";
    var PATCH_METHOD = "PATCH";
    var DELETE_METHOD = "DELETE";
    var OPTIONS_METHOD = "OPTIONS";
    var _default = {
      GET_METHOD,
      POST_METHOD,
      PATCH_METHOD,
      DELETE_METHOD,
      OPTIONS_METHOD
    };
  });

  // node_modules/necessary/lib/headers.js
  var require_headers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ACCEPT_HEADER() {
        return ACCEPT_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_HEADERS_HEADER() {
        return ACCESS_CONTROL_ALLOW_HEADERS_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_METHODS_HEADER() {
        return ACCESS_CONTROL_ALLOW_METHODS_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_ORIGIN_HEADER() {
        return ACCESS_CONTROL_ALLOW_ORIGIN_HEADER;
      },
      get ACCESS_CONTROL_REQUEST_METHOD_HEADER() {
        return ACCESS_CONTROL_REQUEST_METHOD_HEADER;
      },
      get AUTHORIZATION_HEADER() {
        return AUTHORIZATION_HEADER;
      },
      get CACHE_CONTROL_HEADER() {
        return CACHE_CONTROL_HEADER;
      },
      get CONTENT_DISPOSITION_HEADER() {
        return CONTENT_DISPOSITION_HEADER;
      },
      get CONTENT_LENGTH_HEADER() {
        return CONTENT_LENGTH_HEADER;
      },
      get CONTENT_TYPE_HEADER() {
        return CONTENT_TYPE_HEADER;
      },
      get LOCATION_HEADER() {
        return LOCATION_HEADER;
      },
      get PRAGMA_HEADER() {
        return PRAGMA_HEADER;
      },
      get TRANSFER_ENCODING_HEADER() {
        return TRANSFER_ENCODING_HEADER;
      },
      get USER_AGENT_HEADER() {
        return USER_AGENT_HEADER;
      },
      get default() {
        return _default;
      }
    });
    var PRAGMA_HEADER = "pragma";
    var ACCEPT_HEADER = "accept";
    var LOCATION_HEADER = "location";
    var USER_AGENT_HEADER = "user-agent";
    var CONTENT_TYPE_HEADER = "content-type";
    var AUTHORIZATION_HEADER = "authorization";
    var CACHE_CONTROL_HEADER = "cache-control";
    var CONTENT_LENGTH_HEADER = "content-length";
    var TRANSFER_ENCODING_HEADER = "transfer-encoding";
    var CONTENT_DISPOSITION_HEADER = "content-disposition";
    var ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = "access-control-allow-origin";
    var ACCESS_CONTROL_ALLOW_METHODS_HEADER = "access-control-allow-methods";
    var ACCESS_CONTROL_ALLOW_HEADERS_HEADER = "access-control-allow-headers";
    var ACCESS_CONTROL_REQUEST_METHOD_HEADER = "access-control-request-method";
    var _default = {
      PRAGMA_HEADER,
      ACCEPT_HEADER,
      LOCATION_HEADER,
      USER_AGENT_HEADER,
      CONTENT_TYPE_HEADER,
      AUTHORIZATION_HEADER,
      CACHE_CONTROL_HEADER,
      CONTENT_LENGTH_HEADER,
      TRANSFER_ENCODING_HEADER,
      CONTENT_DISPOSITION_HEADER,
      ACCESS_CONTROL_ALLOW_ORIGIN_HEADER,
      ACCESS_CONTROL_ALLOW_METHODS_HEADER,
      ACCESS_CONTROL_ALLOW_HEADERS_HEADER,
      ACCESS_CONTROL_REQUEST_METHOD_HEADER
    };
  });

  // node_modules/necessary/lib/keyCodes.js
  var require_keyCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ARROW_DOWN_KEY_CODE() {
        return ARROW_DOWN_KEY_CODE;
      },
      get ARROW_LEFT_KEY_CODE() {
        return ARROW_LEFT_KEY_CODE;
      },
      get ARROW_RIGHT_KEY_CODE() {
        return ARROW_RIGHT_KEY_CODE;
      },
      get ARROW_UP_KEY_CODE() {
        return ARROW_UP_KEY_CODE;
      },
      get BACKSPACE_KEY_CODE() {
        return BACKSPACE_KEY_CODE;
      },
      get DELETE_KEY_CODE() {
        return DELETE_KEY_CODE;
      },
      get ENTER_KEY_CODE() {
        return ENTER_KEY_CODE;
      },
      get ESCAPE_KEY_CODE() {
        return ESCAPE_KEY_CODE;
      },
      get SHIFT_KEY_CODE() {
        return SHIFT_KEY_CODE;
      },
      get TAB_KEY_CODE() {
        return TAB_KEY_CODE;
      },
      get default() {
        return _default;
      }
    });
    var TAB_KEY_CODE = 9;
    var SHIFT_KEY_CODE = 16;
    var ENTER_KEY_CODE = 13;
    var ESCAPE_KEY_CODE = 27;
    var DELETE_KEY_CODE = 46;
    var BACKSPACE_KEY_CODE = 8;
    var ARROW_UP_KEY_CODE = 38;
    var ARROW_DOWN_KEY_CODE = 40;
    var ARROW_LEFT_KEY_CODE = 37;
    var ARROW_RIGHT_KEY_CODE = 39;
    var _default = {
      TAB_KEY_CODE,
      SHIFT_KEY_CODE,
      ENTER_KEY_CODE,
      ESCAPE_KEY_CODE,
      DELETE_KEY_CODE,
      BACKSPACE_KEY_CODE,
      ARROW_UP_KEY_CODE,
      ARROW_DOWN_KEY_CODE,
      ARROW_LEFT_KEY_CODE,
      ARROW_RIGHT_KEY_CODE
    };
  });

  // node_modules/necessary/lib/encodings.js
  var require_encodings = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BASE64_ENCODING() {
        return BASE64_ENCODING;
      },
      get UTF8_ENCODING() {
        return UTF8_ENCODING;
      },
      get UTF_8_ENCODING() {
        return UTF_8_ENCODING;
      },
      get default() {
        return _default;
      }
    });
    var UTF8_ENCODING = "utf8";
    var UTF_8_ENCODING = "utf-8";
    var BASE64_ENCODING = "base64";
    var _default = {
      UTF8_ENCODING,
      UTF_8_ENCODING,
      BASE64_ENCODING
    };
  });

  // node_modules/necessary/lib/characters.js
  var require_characters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AMPERSAND_CHARACTER() {
        return AMPERSAND_CHARACTER;
      },
      get ASTERISK_CHARACTER() {
        return ASTERISK_CHARACTER;
      },
      get BACKSLASH_CHARACTER() {
        return BACKSLASH_CHARACTER;
      },
      get BACKSPACE_CHARACTER() {
        return BACKSPACE_CHARACTER;
      },
      get BACKTICK_DELIMITER() {
        return BACKTICK_DELIMITER;
      },
      get BAR_CHARACTER() {
        return BAR_CHARACTER;
      },
      get CARRIAGE_RETURN_CHARACTER() {
        return CARRIAGE_RETURN_CHARACTER;
      },
      get CLOSING_BRACKET_CHARACTER() {
        return CLOSING_BRACKET_CHARACTER;
      },
      get CLOSING_CURLY_BRACKET_CHARACTER() {
        return CLOSING_CURLY_BRACKET_CHARACTER;
      },
      get CLOSING_SQUARE_BRACKET_CHARACTER() {
        return CLOSING_SQUARE_BRACKET_CHARACTER;
      },
      get COLON_CHARACTER() {
        return COLON_CHARACTER;
      },
      get COMMA_CHARACTER() {
        return COMMA_CHARACTER;
      },
      get CTRL_C_CHARACTER() {
        return CTRL_C_CHARACTER;
      },
      get DASH_CHARACTER() {
        return DASH_CHARACTER;
      },
      get DOLLAR_CHARACTER() {
        return DOLLAR_CHARACTER;
      },
      get DOWN_CHARACTER() {
        return DOWN_CHARACTER;
      },
      get ESCAPE_CHARACTER() {
        return ESCAPE_CHARACTER;
      },
      get ETX_CHARACTER() {
        return ETX_CHARACTER;
      },
      get EXCLAMATION_MARK_CHARACTER() {
        return EXCLAMATION_MARK_CHARACTER;
      },
      get FORWARD_SLASH_CHARACTER() {
        return FORWARD_SLASH_CHARACTER;
      },
      get HAT_CHARACTER() {
        return HAT_CHARACTER;
      },
      get LEFT_CHARACTER() {
        return LEFT_CHARACTER;
      },
      get NEW_LINE_CHARACTER() {
        return NEW_LINE_CHARACTER;
      },
      get OPENING_BRACKET_CHARACTER() {
        return OPENING_BRACKET_CHARACTER;
      },
      get OPENING_CURLY_BRACKET_CHARACTER() {
        return OPENING_CURLY_BRACKET_CHARACTER;
      },
      get OPENING_SQUARE_BRACKET_CHARACTER() {
        return OPENING_SQUARE_BRACKET_CHARACTER;
      },
      get PERIOD_CHARACTER() {
        return PERIOD_CHARACTER;
      },
      get PLUS_CHARACTER() {
        return PLUS_CHARACTER;
      },
      get QUESTION_MARK_CHARACTER() {
        return QUESTION_MARK_CHARACTER;
      },
      get RIGHT_CHARACTER() {
        return RIGHT_CHARACTER;
      },
      get SPACE_CHARACTER() {
        return SPACE_CHARACTER;
      },
      get UP_CHARACTER() {
        return UP_CHARACTER;
      },
      get WILDCARD_CHARACTER() {
        return WILDCARD_CHARACTER;
      },
      get default() {
        return _default;
      }
    });
    var UP_CHARACTER = "[A";
    var ETX_CHARACTER = "";
    var BAR_CHARACTER = "|";
    var HAT_CHARACTER = "^";
    var PLUS_CHARACTER = "+";
    var DASH_CHARACTER = "-";
    var DOWN_CHARACTER = "[B";
    var LEFT_CHARACTER = "[D";
    var RIGHT_CHARACTER = "[C";
    var SPACE_CHARACTER = " ";
    var COMMA_CHARACTER = ",";
    var COLON_CHARACTER = ":";
    var PERIOD_CHARACTER = ".";
    var DOLLAR_CHARACTER = "$";
    var CTRL_C_CHARACTER = "^C";
    var ESCAPE_CHARACTER = "";
    var ASTERISK_CHARACTER = "*";
    var WILDCARD_CHARACTER = "*";
    var BACKTICK_DELIMITER = "`";
    var NEW_LINE_CHARACTER = "\n";
    var AMPERSAND_CHARACTER = "&";
    var BACKSLASH_CHARACTER = "\\";
    var BACKSPACE_CHARACTER = String.fromCharCode(127);
    var QUESTION_MARK_CHARACTER = "?";
    var FORWARD_SLASH_CHARACTER = "/";
    var OPENING_BRACKET_CHARACTER = "(";
    var CLOSING_BRACKET_CHARACTER = ")";
    var CARRIAGE_RETURN_CHARACTER = "\r";
    var EXCLAMATION_MARK_CHARACTER = "!";
    var OPENING_CURLY_BRACKET_CHARACTER = "{";
    var CLOSING_CURLY_BRACKET_CHARACTER = "}";
    var OPENING_SQUARE_BRACKET_CHARACTER = "[";
    var CLOSING_SQUARE_BRACKET_CHARACTER = "]";
    var _default = {
      UP_CHARACTER,
      ETX_CHARACTER,
      BAR_CHARACTER,
      HAT_CHARACTER,
      PLUS_CHARACTER,
      DASH_CHARACTER,
      DOWN_CHARACTER,
      LEFT_CHARACTER,
      RIGHT_CHARACTER,
      SPACE_CHARACTER,
      COMMA_CHARACTER,
      COLON_CHARACTER,
      PERIOD_CHARACTER,
      DOLLAR_CHARACTER,
      CTRL_C_CHARACTER,
      ESCAPE_CHARACTER,
      ASTERISK_CHARACTER,
      WILDCARD_CHARACTER,
      BACKTICK_DELIMITER,
      NEW_LINE_CHARACTER,
      AMPERSAND_CHARACTER,
      BACKSLASH_CHARACTER,
      BACKSPACE_CHARACTER,
      QUESTION_MARK_CHARACTER,
      FORWARD_SLASH_CHARACTER,
      OPENING_BRACKET_CHARACTER,
      CLOSING_BRACKET_CHARACTER,
      CARRIAGE_RETURN_CHARACTER,
      EXCLAMATION_MARK_CHARACTER,
      OPENING_CURLY_BRACKET_CHARACTER,
      CLOSING_CURLY_BRACKET_CHARACTER,
      OPENING_SQUARE_BRACKET_CHARACTER,
      CLOSING_SQUARE_BRACKET_CHARACTER
    };
  });

  // node_modules/necessary/lib/statusCodes.js
  var require_statusCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BAD_GATEWAY_502_STATUS_CODE() {
        return BAD_GATEWAY_502_STATUS_CODE;
      },
      get BAD_REQUEST_400_STATUS_CODE() {
        return BAD_REQUEST_400_STATUS_CODE;
      },
      get CONFLICT_409_STATUS_CODE() {
        return CONFLICT_409_STATUS_CODE;
      },
      get CREATED_201_STATUS_CODE() {
        return CREATED_201_STATUS_CODE;
      },
      get FORBIDDEN_403_STATUS_CODE() {
        return FORBIDDEN_403_STATUS_CODE;
      },
      get FOUND_302_STATUS_CODE() {
        return FOUND_302_STATUS_CODE;
      },
      get INTERNAL_SERVER_ERROR_500_STATUS_CODE() {
        return INTERNAL_SERVER_ERROR_500_STATUS_CODE;
      },
      get METHOD_NOT_ALLOWED_405_STATUS_CODE() {
        return METHOD_NOT_ALLOWED_405_STATUS_CODE;
      },
      get NOT_ACCEPTABLE_406_STATUS_CODE() {
        return NOT_ACCEPTABLE_406_STATUS_CODE;
      },
      get NOT_FOUND_404_STATUS_CODE() {
        return NOT_FOUND_404_STATUS_CODE;
      },
      get NO_CONTENT_204_STATUS_CODE() {
        return NO_CONTENT_204_STATUS_CODE;
      },
      get OK_200_STATUS_CODE() {
        return OK_200_STATUS_CODE;
      },
      get REQUEST_TIMEOUT_408_STATUS_CODE() {
        return REQUEST_TIMEOUT_408_STATUS_CODE;
      },
      get SEE_OTHER_303_STATUS_CODE() {
        return SEE_OTHER_303_STATUS_CODE;
      },
      get SERVICE_UNAVAILABLE_503_STATUS_CODE() {
        return SERVICE_UNAVAILABLE_503_STATUS_CODE;
      },
      get TOO_MANY_REQUESTS_429_STATUS_CODE() {
        return TOO_MANY_REQUESTS_429_STATUS_CODE;
      },
      get UNAUTHORIZED_401_STATUS_CODE() {
        return UNAUTHORIZED_401_STATUS_CODE;
      },
      get UNPROCESSABLE_ENTITY_422_STATUS_CODE() {
        return UNPROCESSABLE_ENTITY_422_STATUS_CODE;
      },
      get ZERO_0_STATUS_CODE() {
        return ZERO_0_STATUS_CODE;
      },
      get default() {
        return _default;
      }
    });
    var ZERO_0_STATUS_CODE = 0;
    var OK_200_STATUS_CODE = 200;
    var FOUND_302_STATUS_CODE = 302;
    var CREATED_201_STATUS_CODE = 201;
    var CONFLICT_409_STATUS_CODE = 409;
    var SEE_OTHER_303_STATUS_CODE = 303;
    var FORBIDDEN_403_STATUS_CODE = 403;
    var NOT_FOUND_404_STATUS_CODE = 404;
    var NO_CONTENT_204_STATUS_CODE = 204;
    var BAD_GATEWAY_502_STATUS_CODE = 502;
    var BAD_REQUEST_400_STATUS_CODE = 400;
    var UNAUTHORIZED_401_STATUS_CODE = 401;
    var NOT_ACCEPTABLE_406_STATUS_CODE = 406;
    var REQUEST_TIMEOUT_408_STATUS_CODE = 408;
    var TOO_MANY_REQUESTS_429_STATUS_CODE = 429;
    var METHOD_NOT_ALLOWED_405_STATUS_CODE = 405;
    var SERVICE_UNAVAILABLE_503_STATUS_CODE = 503;
    var UNPROCESSABLE_ENTITY_422_STATUS_CODE = 422;
    var INTERNAL_SERVER_ERROR_500_STATUS_CODE = 500;
    var _default = {
      ZERO_0_STATUS_CODE,
      OK_200_STATUS_CODE,
      FOUND_302_STATUS_CODE,
      CREATED_201_STATUS_CODE,
      CONFLICT_409_STATUS_CODE,
      SEE_OTHER_303_STATUS_CODE,
      FORBIDDEN_403_STATUS_CODE,
      NOT_FOUND_404_STATUS_CODE,
      NO_CONTENT_204_STATUS_CODE,
      BAD_GATEWAY_502_STATUS_CODE,
      BAD_REQUEST_400_STATUS_CODE,
      UNAUTHORIZED_401_STATUS_CODE,
      NOT_ACCEPTABLE_406_STATUS_CODE,
      REQUEST_TIMEOUT_408_STATUS_CODE,
      TOO_MANY_REQUESTS_429_STATUS_CODE,
      METHOD_NOT_ALLOWED_405_STATUS_CODE,
      SERVICE_UNAVAILABLE_503_STATUS_CODE,
      UNPROCESSABLE_ENTITY_422_STATUS_CODE,
      INTERNAL_SERVER_ERROR_500_STATUS_CODE
    };
  });

  // node_modules/necessary/lib/contentTypes.js
  var require_contentTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE() {
        return APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get APPLICATION_JSON_CONTENT_TYPE() {
        return APPLICATION_JSON_CONTENT_TYPE;
      },
      get APPLICATION_OCTET_STREAM_CONTENT_TYPE() {
        return APPLICATION_OCTET_STREAM_CONTENT_TYPE;
      },
      get APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE() {
        return APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE() {
        return APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE;
      },
      get TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE() {
        return TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get TEXT_HTML_CONTENT_TYPE() {
        return TEXT_HTML_CONTENT_TYPE;
      },
      get TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE() {
        return TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get TEXT_PLAIN_CONTENT_TYPE() {
        return TEXT_PLAIN_CONTENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var TEXT_HTML_CONTENT_TYPE = "text/html";
    var TEXT_PLAIN_CONTENT_TYPE = "text/plain";
    var APPLICATION_JSON_CONTENT_TYPE = "application/json";
    var TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE = "text/html; charset=utf-8";
    var TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE = "text/plain; charset=utf-8";
    var APPLICATION_OCTET_STREAM_CONTENT_TYPE = "application/octet-stream";
    var APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE = "application/x-www-form-urlencoded";
    var APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE = "application/json; charset=utf-8";
    var APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE = "application/x-www-form-urlencoded; charset=utf-8";
    var _default = {
      TEXT_HTML_CONTENT_TYPE,
      TEXT_PLAIN_CONTENT_TYPE,
      APPLICATION_JSON_CONTENT_TYPE,
      TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE,
      TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_OCTET_STREAM_CONTENT_TYPE,
      APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE
    };
  });

  // node_modules/necessary/lib/statusMessages.js
  var require_statusMessages = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BAD_GATEWAY_502_STATUS_MESSAGE() {
        return BAD_GATEWAY_502_STATUS_MESSAGE;
      },
      get BAD_REQUEST_400_STATUS_MESSAGE() {
        return BAD_REQUEST_400_STATUS_MESSAGE;
      },
      get CONFLICT_409_STATUS_MESSAGE() {
        return CONFLICT_409_STATUS_MESSAGE;
      },
      get CREATED_201_STATUS_MESSAGE() {
        return CREATED_201_STATUS_MESSAGE;
      },
      get FORBIDDEN_403_STATUS_MESSAGE() {
        return FORBIDDEN_403_STATUS_MESSAGE;
      },
      get FOUND_302_STATUS_MESSAGE() {
        return FOUND_302_STATUS_MESSAGE;
      },
      get INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE() {
        return INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE;
      },
      get METHOD_NOT_ALLOWED_405_STATUS_MESSAGE() {
        return METHOD_NOT_ALLOWED_405_STATUS_MESSAGE;
      },
      get NOT_ACCEPTABLE_406_STATUS_MESSAGE() {
        return NOT_ACCEPTABLE_406_STATUS_MESSAGE;
      },
      get NOT_FOUND_404_STATUS_MESSAGE() {
        return NOT_FOUND_404_STATUS_MESSAGE;
      },
      get NO_CONTENT_204_STATUS_MESSAGE() {
        return NO_CONTENT_204_STATUS_MESSAGE;
      },
      get OK_200_STATUS_MESSAGE() {
        return OK_200_STATUS_MESSAGE;
      },
      get REQUEST_TIMEOUT_408_STATUS_MESSAGE() {
        return REQUEST_TIMEOUT_408_STATUS_MESSAGE;
      },
      get SEE_OTHER_303_STATUS_MESSAGE() {
        return SEE_OTHER_303_STATUS_MESSAGE;
      },
      get SERVICE_UNAVAILABLE_503_STATUS_MESSAGE() {
        return SERVICE_UNAVAILABLE_503_STATUS_MESSAGE;
      },
      get TOO_MANY_REQUESTS_429_STATUS_MESSAGE() {
        return TOO_MANY_REQUESTS_429_STATUS_MESSAGE;
      },
      get UNAUTHORIZED_401_STATUS_MESSAGE() {
        return UNAUTHORIZED_401_STATUS_MESSAGE;
      },
      get UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE() {
        return UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE;
      },
      get ZERO_0_STATUS_MESSAGE() {
        return ZERO_0_STATUS_MESSAGE;
      },
      get default() {
        return _default;
      }
    });
    var ZERO_0_STATUS_MESSAGE = "";
    var OK_200_STATUS_MESSAGE = "OK";
    var FOUND_302_STATUS_MESSAGE = "Found";
    var CREATED_201_STATUS_MESSAGE = "Created";
    var CONFLICT_409_STATUS_MESSAGE = "Conflict";
    var SEE_OTHER_303_STATUS_MESSAGE = "See other";
    var FORBIDDEN_403_STATUS_MESSAGE = "Forbidden";
    var NOT_FOUND_404_STATUS_MESSAGE = "Not found";
    var NO_CONTENT_204_STATUS_MESSAGE = "No content";
    var BAD_GATEWAY_502_STATUS_MESSAGE = "Bad gateway";
    var BAD_REQUEST_400_STATUS_MESSAGE = "Bad request";
    var UNAUTHORIZED_401_STATUS_MESSAGE = "Unauthorized";
    var NOT_ACCEPTABLE_406_STATUS_MESSAGE = "Not Acceptable";
    var REQUEST_TIMEOUT_408_STATUS_MESSAGE = "Request timeout";
    var TOO_MANY_REQUESTS_429_STATUS_MESSAGE = "Too many requests";
    var METHOD_NOT_ALLOWED_405_STATUS_MESSAGE = "Method not allowed";
    var SERVICE_UNAVAILABLE_503_STATUS_MESSAGE = "Service unavailable";
    var UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE = "Unprocessable Entity";
    var INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE = "Internal server error";
    var _default = {
      ZERO_0_STATUS_MESSAGE,
      OK_200_STATUS_MESSAGE,
      FOUND_302_STATUS_MESSAGE,
      CREATED_201_STATUS_MESSAGE,
      CONFLICT_409_STATUS_MESSAGE,
      SEE_OTHER_303_STATUS_MESSAGE,
      FORBIDDEN_403_STATUS_MESSAGE,
      NOT_FOUND_404_STATUS_MESSAGE,
      NO_CONTENT_204_STATUS_MESSAGE,
      BAD_GATEWAY_502_STATUS_MESSAGE,
      BAD_REQUEST_400_STATUS_MESSAGE,
      UNAUTHORIZED_401_STATUS_MESSAGE,
      NOT_ACCEPTABLE_406_STATUS_MESSAGE,
      REQUEST_TIMEOUT_408_STATUS_MESSAGE,
      TOO_MANY_REQUESTS_429_STATUS_MESSAGE,
      METHOD_NOT_ALLOWED_405_STATUS_MESSAGE,
      SERVICE_UNAVAILABLE_503_STATUS_MESSAGE,
      UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE,
      INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE
    };
  });

  // node_modules/necessary/lib/constants.js
  var require_constants2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN() {
        return BOOLEAN;
      },
      get DATA() {
        return DATA;
      },
      get DEFAULT() {
        return DEFAULT;
      },
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ENVIRONMENT() {
        return ENVIRONMENT;
      },
      get ERROR() {
        return ERROR;
      },
      get FUNCTION() {
        return FUNCTION;
      },
      get NUMBER() {
        return NUMBER;
      },
      get PACKAGE_JSON() {
        return PACKAGE_JSON;
      },
      get STRING() {
        return STRING;
      },
      get ZERO() {
        return ZERO;
      }
    });
    var ZERO = "0";
    var DATA = "data";
    var ERROR = "error";
    var STRING = "string";
    var NUMBER = "number";
    var BOOLEAN = "boolean";
    var DEFAULT = "default";
    var FUNCTION = "function";
    var ENVIRONMENT = "ENVIRONMENT";
    var EMPTY_STRING = "";
    var DOUBLE_SPACE = "  ";
    var PACKAGE_JSON = "package.json";
  });

  // node_modules/necessary/lib/utilities/array.js
  var require_array2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get augment() {
        return augment;
      },
      get back() {
        return back;
      },
      get backwardsEvery() {
        return backwardsEvery;
      },
      get backwardsFind() {
        return backwardsFind;
      },
      get backwardsFindIndex() {
        return backwardsFindIndex;
      },
      get backwardsForEach() {
        return backwardsForEach;
      },
      get backwardsReduce() {
        return backwardsReduce;
      },
      get backwardsSome() {
        return backwardsSome;
      },
      get clear() {
        return clear;
      },
      get combine() {
        return combine;
      },
      get compare() {
        return compare;
      },
      get compress() {
        return compress;
      },
      get concat() {
        return concat;
      },
      get copy() {
        return copy;
      },
      get correlate() {
        return correlate;
      },
      get default() {
        return _default;
      },
      get eighth() {
        return eighth;
      },
      get eighthLast() {
        return eighthLast;
      },
      get extract() {
        return extract;
      },
      get fifth() {
        return fifth;
      },
      get fifthLast() {
        return fifthLast;
      },
      get filter() {
        return filter;
      },
      get find() {
        return find;
      },
      get first() {
        return first2;
      },
      get firstLast() {
        return firstLast;
      },
      get forwardsEvery() {
        return forwardsEvery;
      },
      get forwardsFind() {
        return forwardsFind;
      },
      get forwardsFindIndex() {
        return forwardsFindIndex;
      },
      get forwardsForEach() {
        return forwardsForEach;
      },
      get forwardsReduce() {
        return forwardsReduce;
      },
      get forwardsSome() {
        return forwardsSome;
      },
      get fourth() {
        return fourth;
      },
      get fourthLast() {
        return fourthLast;
      },
      get front() {
        return front;
      },
      get head() {
        return head;
      },
      get last() {
        return last;
      },
      get match() {
        return match;
      },
      get merge() {
        return merge;
      },
      get ninth() {
        return ninth;
      },
      get ninthLast() {
        return ninthLast;
      },
      get patch() {
        return patch;
      },
      get prune() {
        return prune;
      },
      get push() {
        return push;
      },
      get replace() {
        return replace;
      },
      get resolve() {
        return resolve;
      },
      get reverse() {
        return reverse;
      },
      get second() {
        return second;
      },
      get secondLast() {
        return secondLast;
      },
      get separate() {
        return separate;
      },
      get seventh() {
        return seventh;
      },
      get seventhLast() {
        return seventhLast;
      },
      get sixth() {
        return sixth;
      },
      get sixthLast() {
        return sixthLast;
      },
      get splice() {
        return splice;
      },
      get tail() {
        return tail;
      },
      get tenth() {
        return tenth;
      },
      get third() {
        return third;
      },
      get thirdLast() {
        return thirdLast;
      },
      get unshift() {
        return unshift;
      }
    });
    function first2(array) {
      return array[0];
    }
    function second(array) {
      return array[1];
    }
    function third(array) {
      return array[2];
    }
    function fourth(array) {
      return array[3];
    }
    function fifth(array) {
      return array[4];
    }
    function sixth(array) {
      return array[5];
    }
    function seventh(array) {
      return array[6];
    }
    function eighth(array) {
      return array[7];
    }
    function ninth(array) {
      return array[8];
    }
    function tenth(array) {
      return array[9];
    }
    function firstLast(array) {
      return array[array.length - 1];
    }
    function secondLast(array) {
      return array[array.length - 2];
    }
    function thirdLast(array) {
      return array[array.length - 3];
    }
    function fourthLast(array) {
      return array[array.length - 4];
    }
    function fifthLast(array) {
      return array[array.length - 5];
    }
    function sixthLast(array) {
      return array[array.length - 6];
    }
    function seventhLast(array) {
      return array[array.length - 7];
    }
    function eighthLast(array) {
      return array[array.length - 8];
    }
    function ninthLast(array) {
      return array[array.length - 9];
    }
    function last(array) {
      return array[array.length - 1];
    }
    function head(array) {
      return array.slice(0, 1);
    }
    function tail(array) {
      return array.slice(1);
    }
    function back(array) {
      return array.slice(array.length - 1);
    }
    function front(array) {
      return array.slice(0, Math.max(1, array.length - 1));
    }
    function push(arrayA, arrayB) {
      Array.prototype.push.apply(arrayA, arrayB);
    }
    function unshift(arrayA, arrayB) {
      Array.prototype.unshift.apply(arrayA, arrayB);
    }
    function concat(arrayA, elementOrArray2) {
      const arrayB = elementOrArray2 instanceof Array ? elementOrArray2 : [
        elementOrArray2
      ];
      push(arrayA, arrayB);
    }
    function clear(array) {
      const start = 0;
      return array.splice(start);
    }
    function copy(arrayA, arrayB) {
      const start = 0, deleteCount = arrayB.length;
      splice(arrayA, start, deleteCount, arrayB);
    }
    function merge(arrayA, arrayB) {
      Array.prototype.push.apply(arrayA, arrayB);
    }
    function match(arrayA, arrayB, callback) {
      let matches = false;
      const arrayALength = arrayA.length, arrayBLength = arrayB.length;
      if (arrayALength === arrayBLength) {
        matches = arrayA.every((elementA, index) => {
          const elementB = arrayB[index], passed = callback(elementA, elementB, index);
          if (passed) {
            return true;
          }
        });
      }
      return matches;
    }
    function compare(arrayA, arrayB, callback) {
      let coupled = false;
      const arrayALength = arrayA.length, arrayBLength = arrayB.length;
      if (arrayALength === arrayBLength) {
        arrayB = [
          ...arrayB
        ];
        coupled = arrayA.every((elementA, index) => {
          const elementB = extract(arrayB, (elementB2) => {
            const result = callback(elementA, elementB2);
            if (result) {
              return true;
            }
          }) || null;
          if (elementB !== null) {
            return true;
          }
        });
      }
      return coupled;
    }
    function correlate(arrayA, arrayB, callback) {
      arrayB = [
        ...arrayB
      ];
      const correlates = arrayA.every((elementA) => {
        const elementB = extract(arrayB, (elementB2) => {
          const result = callback(elementA, elementB2);
          if (result) {
            return true;
          }
        }) || null;
        if (elementB !== null) {
          return true;
        }
      });
      return correlates;
    }
    function resolve(arrayA, arrayB, callback) {
      let resolved;
      arrayA = [
        ...arrayA
      ];
      for (; ; ) {
        const arrayALength2 = arrayA.length;
        if (arrayALength2 === 0) {
          break;
        }
        let resolved2 = false;
        arrayA.forEach((elementA) => {
          const passed = callback(elementA);
          if (passed) {
            const elementB = elementA;
            arrayB.push(elementB);
            resolved2 = true;
          }
        });
        if (!resolved2) {
          break;
        }
        filter(arrayA, (elementA) => {
          const arrayBIncludesElementA = arrayB.includes(elementA);
          if (!arrayBIncludesElementA) {
            return true;
          }
        });
      }
      const arrayALength = arrayA.length;
      resolved = arrayALength === 0;
      return resolved;
    }
    function find(array, callback) {
      const elements = [];
      forwardsForEach(array, (element, index) => {
        const passed = callback(element, index);
        if (passed) {
          elements.push(element);
        }
      });
      return elements;
    }
    function replace(array, element, callback) {
      let start;
      const found = array.some((element2, index) => {
        const passed = callback(element2, index);
        if (passed) {
          start = index;
          return true;
        }
      });
      if (found) {
        const deleteCount = 1;
        array.splice(start, deleteCount, element);
      }
      return found;
    }
    function splice(arrayA, start, deleteCount = Infinity, arrayB = []) {
      const args = [
        start,
        deleteCount,
        ...arrayB
      ], deletedElements = Array.prototype.splice.apply(arrayA, args);
      return deletedElements;
    }
    function filter(array, callback) {
      const deletedElements = [];
      backwardsForEach(array, (element, index) => {
        const passed = callback(element, index);
        if (!passed) {
          const start = index, deleteCount = 1, deletedElements2 = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements2);
          deletedElements2.unshift(firstDeletedElement);
        }
      });
      return deletedElements;
    }
    function prune(array, callback) {
      let deletedElement = void 0;
      array.some((element, index) => {
        const passed = callback(element, index);
        if (!passed) {
          const start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements);
          deletedElement = firstDeletedElement;
          return true;
        }
      });
      return deletedElement;
    }
    function extract(array, callback) {
      let deletedElement = void 0;
      array.some((element, index) => {
        const passed = callback(element, index);
        if (passed) {
          const start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements);
          deletedElement = firstDeletedElement;
          return true;
        }
      });
      return deletedElement;
    }
    function patch(array, element, callback) {
      const found = array.some((element2, index) => {
        const passed = callback(element2, index);
        if (passed) {
          return true;
        }
      });
      if (found) {
        array.push(element);
      }
      return found;
    }
    function compress(array, callback) {
      let index1 = 0, length = array.length;
      while (index1 < length) {
        const elementB = array[index1];
        for (let index2 = length - 1; index2 > index1; index2--) {
          const elementA = array[index2], passed = callback(elementA, elementB);
          if (!passed) {
            const start = index2, deleteCount = 1;
            array.splice(start, deleteCount);
          }
        }
        index1++;
        length = array.length;
      }
    }
    function combine(arrayA, arrayB, callback) {
      const array = [
        ...arrayA,
        ...arrayB
      ];
      compress(array, callback);
      return array;
    }
    function reverse(array) {
      array = [
        ...array
      ].reverse();
      return array;
    }
    function augment(arrayA, arrayB, callback) {
      arrayB.forEach((element, index) => {
        const passed = callback(element, index);
        if (passed) {
          arrayA.push(element);
        }
      });
    }
    function separate(array, arrayA, arrayB, callback) {
      array.forEach((element, index) => {
        const passed = callback(element, index);
        passed ? arrayA.push(element) : arrayB.push(element);
      });
    }
    function forwardsFind(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return element;
        }
      }
      return false;
    }
    function backwardsFind(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return element;
        }
      }
      return false;
    }
    function forwardsSome(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return true;
        }
      }
      return false;
    }
    function backwardsSome(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return true;
        }
      }
      return false;
    }
    function forwardsEvery(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    function backwardsEvery(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    function forwardsReduce(array, callback, initialValue) {
      let value = initialValue;
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index];
        value = callback(value, element, index);
      }
      return value;
    }
    function backwardsReduce(array, callback, initialValue) {
      let value = initialValue;
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index];
        value = callback(value, element, index);
      }
      return value;
    }
    function forwardsForEach(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index];
        callback(element, index);
      }
    }
    function backwardsForEach(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index];
        callback(element, index);
      }
    }
    function forwardsFindIndex(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return index;
        }
      }
      return -1;
    }
    function backwardsFindIndex(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return index;
        }
      }
      return -1;
    }
    var _default = {
      first: first2,
      second,
      third,
      fourth,
      fifth,
      sixth,
      seventh,
      eighth,
      ninth,
      firstLast,
      secondLast,
      thirdLast,
      fourthLast,
      fifthLast,
      sixthLast,
      seventhLast,
      eighthLast,
      ninthLast,
      last,
      head,
      tail,
      back,
      front,
      push,
      unshift,
      concat,
      clear,
      copy,
      merge,
      match,
      compare,
      correlate,
      resolve,
      find,
      replace,
      splice,
      filter,
      prune,
      extract,
      patch,
      compress,
      combine,
      reverse,
      augment,
      separate,
      forwardsFind,
      backwardsFind,
      forwardsSome,
      backwardsSome,
      forwardsEvery,
      backwardsEvery,
      forwardsReduce,
      backwardsReduce,
      forwardsForEach,
      backwardsForEach,
      forwardsFindIndex,
      backwardsFindIndex
    };
  });

  // node_modules/necessary/lib/utilities/path.js
  var require_path = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get bottommostNameFromPath() {
        return bottommostNameFromPath;
      },
      get combinePaths() {
        return combinePaths;
      },
      get concatenatePaths() {
        return concatenatePaths;
      },
      get default() {
        return _default;
      },
      get isPathAbsolutePath() {
        return isPathAbsolutePath;
      },
      get isPathName() {
        return isPathName;
      },
      get isPathRelativePath() {
        return isPathRelativePath;
      },
      get isPathTopmostName() {
        return isPathTopmostName;
      },
      get isTopmostNameInAbsolutePath() {
        return isTopmostNameInAbsolutePath;
      },
      get pathWithoutBottommostNameFromPath() {
        return pathWithoutBottommostNameFromPath;
      },
      get pathWithoutTopmostDirectoryNameFromPath() {
        return pathWithoutTopmostDirectoryNameFromPath;
      },
      get topmostDirectoryNameFromPath() {
        return topmostDirectoryNameFromPath;
      },
      get topmostDirectoryPathFromPath() {
        return topmostDirectoryPathFromPath;
      }
    });
    var _constants = require_constants2();
    var _array = require_array2();
    function isPathName(path) {
      path = path.replace(/^\//, _constants.EMPTY_STRING).replace(/\/$/, _constants.EMPTY_STRING);
      const pathName = /\//.test(path) === false;
      return pathName;
    }
    function isPathTopmostName(path) {
      const pathName = isPathName(path), pathAbsolutePath = isPathAbsolutePath(path), pathTopmostName = pathName && pathAbsolutePath;
      return pathTopmostName;
    }
    function isPathRelativePath(path) {
      const pathRelativePath = !/^\//.test(path);
      return pathRelativePath;
    }
    function isPathAbsolutePath(path) {
      const pathAbsolutePath = /^\//.test(path);
      return pathAbsolutePath;
    }
    function isTopmostNameInAbsolutePath(topmostName, absolutePath) {
      const regExp = new RegExp(`^${topmostName}(?:\\/.+)?$`), topmostNameInAbsolutePath = regExp.test(absolutePath);
      return topmostNameInAbsolutePath;
    }
    function combinePaths(path, relativePath) {
      let combinedPath = null;
      const pathNames = path.split(/\//), relativePathNames = relativePath.split(/\//);
      let lastPathName, firstRelativePathName = (0, _array.first)(relativePathNames);
      if (firstRelativePathName === ".") {
        relativePathNames.shift();
      }
      firstRelativePathName = (0, _array.first)(relativePathNames);
      lastPathName = (0, _array.last)(pathNames);
      while (firstRelativePathName === ".." && lastPathName !== void 0) {
        relativePathNames.shift();
        pathNames.pop();
        firstRelativePathName = (0, _array.first)(relativePathNames);
        lastPathName = (0, _array.last)(pathNames);
      }
      if (lastPathName !== void 0) {
        const combinedPathNames = [].concat(pathNames).concat(relativePathNames);
        combinedPath = combinedPathNames.join("/");
      }
      return combinedPath;
    }
    function concatenatePaths(path, relativePath, ...remainingArguments) {
      let concatenatedPath;
      path = path.replace(/\/$/, _constants.EMPTY_STRING);
      concatenatedPath = `${path}/${relativePath}`;
      const remainingAArgumentsLength = remainingArguments.length;
      if (remainingAArgumentsLength > 0) {
        const path2 = concatenatedPath, relativePath2 = remainingArguments.shift();
        concatenatedPath = concatenatePaths(path2, relativePath2, ...remainingArguments);
      }
      return concatenatedPath;
    }
    function bottommostNameFromPath(path) {
      let bottommostName = null;
      const matches = path.match(/^.*\/([^\/]+\/?)$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        bottommostName = secondMatch;
      }
      return bottommostName;
    }
    function topmostDirectoryPathFromPath(path) {
      const matches = path.match(/^(.+)\/[^\/]+\/?$/), secondMatch = (0, _array.second)(matches), topmostDirectoryPath = secondMatch;
      return topmostDirectoryPath;
    }
    function topmostDirectoryNameFromPath(path) {
      let topmostDirectoryName = null;
      const matches = path.match(/^([^\/]+)\/.+$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        topmostDirectoryName = secondMatch;
      }
      return topmostDirectoryName;
    }
    function pathWithoutBottommostNameFromPath(path) {
      let pathWithoutBottommostName = null;
      const matches = path.match(/^(.*)\/[^\/]+\/?$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        pathWithoutBottommostName = secondMatch;
      }
      return pathWithoutBottommostName;
    }
    function pathWithoutTopmostDirectoryNameFromPath(path) {
      let pathWithoutTopmostDirectoryName = null;
      const matches = path.match(/^[^\/]+\/(.+)$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        pathWithoutTopmostDirectoryName = secondMatch;
      }
      return pathWithoutTopmostDirectoryName;
    }
    var _default = {
      isPathName,
      isPathTopmostName,
      isPathRelativePath,
      isPathAbsolutePath,
      isTopmostNameInAbsolutePath,
      combinePaths,
      concatenatePaths,
      bottommostNameFromPath,
      topmostDirectoryPathFromPath,
      topmostDirectoryNameFromPath,
      pathWithoutBottommostNameFromPath,
      pathWithoutTopmostDirectoryNameFromPath
    };
  });

  // node_modules/necessary/lib/utilities/http.js
  var require_http = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get hostnameFromHost() {
        return hostnameFromHost;
      },
      get overwrite() {
        return overwrite;
      },
      get portFromHost() {
        return portFromHost;
      },
      get queryStringFromQuery() {
        return queryStringFromQuery;
      },
      get secureFromHost() {
        return secureFromHost;
      },
      get underwrite() {
        return underwrite;
      },
      get urlFromHostURIAndQuery() {
        return urlFromHostURIAndQuery;
      }
    });
    var _array = require_array2();
    var _constants = require_constants2();
    var _characters = require_characters();
    function overwrite(headers, name, value) {
      const lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName = existingNames.find((existingName2) => {
        const existingLowerCaseName = existingName2.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName !== null) {
        headers[existingName] = value;
      }
    }
    function underwrite(headers, name, value) {
      const lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName = existingNames.find((existingName2) => {
        const existingLowerCaseName = existingName2.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName === null) {
        headers[name] = value;
      }
    }
    function portFromHost(host) {
      let port;
      const matches = host.match(/^https?:\/\/([^\/]+)/), secondMatch = (0, _array.second)(matches), index = secondMatch.indexOf(_characters.COLON_CHARACTER);
      if (index === -1) {
        const secure = secureFromHost(host);
        port = secure ? 443 : 80;
      } else {
        const start = index + 1, portString = secondMatch.substring(start);
        port = Number(portString);
      }
      return port;
    }
    function secureFromHost(host) {
      const secure = /^https:\/\//.test(host);
      return secure;
    }
    function hostnameFromHost(host) {
      const matches = host.match(/^https?:\/\/([^:\/]+)/), secondMatch = (0, _array.second)(matches), hostname = secondMatch;
      return hostname;
    }
    function queryStringFromQuery(query) {
      const names = Object.keys(query), namesLength = names.length, lastIndex = namesLength - 1, queryString = names.reduce((queryString2, name, index) => {
        const value = query[name], encodedName = encodeURIComponent(name), encodedValue = encodeURIComponent(value), ampersandOrNothing = index !== lastIndex ? _characters.AMPERSAND_CHARACTER : _constants.EMPTY_STRING;
        queryString2 += `${encodedName}=${encodedValue}${ampersandOrNothing}`;
        return queryString2;
      }, _constants.EMPTY_STRING);
      return queryString;
    }
    function urlFromHostURIAndQuery(host, uri, query) {
      const queryString = queryStringFromQuery(query), url = queryString === _constants.EMPTY_STRING ? `${host}${uri}` : `${host}${uri}?${queryString}`;
      return url;
    }
    var _default = {
      overwrite,
      underwrite,
      portFromHost,
      secureFromHost,
      hostnameFromHost,
      queryStringFromQuery,
      urlFromHostURIAndQuery
    };
  });

  // node_modules/necessary/lib/utilities/string.js
  var require_string2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get indexOf() {
        return indexOf;
      },
      get strcmp() {
        return strcmp;
      },
      get strlen() {
        return strlen;
      },
      get substring() {
        return substring;
      }
    });
    var _constants = require_constants2();
    function strlen(string) {
      let length = 0;
      const iterator = string[Symbol.iterator]();
      let character = iterator.next();
      while (!character.done) {
        character = iterator.next();
        length++;
      }
      return length;
    }
    function strcmp(stringA, stringB) {
      let difference;
      const iteratorA = stringA[Symbol.iterator](), iteratorB = stringB[Symbol.iterator]();
      let characterA = iteratorA.next(), characterB = iteratorB.next(), codePointA, codePointB;
      while (true) {
        codePointA = characterA.value ? characterA.value.codePointAt(0) : 0;
        codePointB = characterB.value ? characterB.value.codePointAt(0) : 0;
        difference = codePointB - codePointA;
        if (difference !== 0) {
          break;
        }
        if (characterA.done || characterB.done) {
          break;
        }
        characterA = iteratorA.next();
        characterB = iteratorB.next();
      }
      return difference;
    }
    function indexOf(string, searchString) {
      let index = -1, found = false;
      const searchStringLength = strlen(searchString);
      if (searchStringLength > 0) {
        let character;
        const iterator = string[Symbol.iterator](), searchIterator = searchString[Symbol.iterator](), searchCharacter = searchIterator.next();
        character = iterator.next();
        index++;
        while (!character.done) {
          if (character.value === searchCharacter.value) {
            const start = index, end = start + searchStringLength, subString = substring(string, start, end), difference = strcmp(subString, searchString);
            if (difference === 0) {
              found = true;
              break;
            }
          }
          character = iterator.next();
          index++;
        }
      }
      if (!found) {
        index = -1;
      }
      return index;
    }
    function substring(string, start, end = Infinity) {
      let index = 0;
      const iterator = string[Symbol.iterator](), characters = [];
      let character = iterator.next();
      while (!character.done) {
        if (index === end) {
          break;
        }
        if (index >= start) {
          characters.push(character.value);
        }
        index++;
        character = iterator.next();
      }
      const substring1 = characters.join(_constants.EMPTY_STRING);
      return substring1;
    }
    var _default = {
      strcmp,
      strlen,
      indexOf,
      substring
    };
  });

  // node_modules/necessary/lib/utilities/version.js
  var require_version = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get migrate() {
        return migrate;
      }
    });
    function migrate(json, migrationMap, latestVersion) {
      let {version} = json;
      while (version !== latestVersion) {
        const migrateFunction = migrationMap[version];
        json = migrateFunction(json);
        ({version} = json);
      }
      return json;
    }
    var _default = {
      migrate
    };
  });

  // node_modules/necessary/lib/utilities/asynchronous.js
  var require_asynchronous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get backwardsForEach() {
        return backwardsForEach;
      },
      get default() {
        return _default;
      },
      get eventually() {
        return eventually;
      },
      get forEach() {
        return forEach;
      },
      get forwardsForEach() {
        return forwardsForEach;
      },
      get repeatedly() {
        return repeatedly;
      },
      get sequence() {
        return sequence;
      },
      get whilst() {
        return whilst;
      }
    });
    function whilst(operation, done, context2) {
      let count = -1;
      function next() {
        count++;
        const index = count;
        operation(next, done, context2, index);
      }
      next();
    }
    function forEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    function sequence(operations, done, context2) {
      const length = operations.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, operation = operations[index];
          operation(next, done, context2, index);
        }
      }
      next();
    }
    function eventually(operations, done, context2) {
      const length = operations.length;
      if (length === 0) {
        done();
        return;
      }
      let count = 0;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        }
      }
      operations.forEach((operation, index) => {
        operation(next, done, context2, index);
      });
    }
    function repeatedly(operation, length, done, context2) {
      if (length === 0) {
        done();
        return;
      }
      let count = 0;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        }
      }
      for (let index = 0; index < length; index++) {
        operation(next, done, context2, index);
      }
    }
    function forwardsForEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    function backwardsForEach(array, operation, done, context2) {
      const length = array.length;
      let count = length;
      function next() {
        count--;
        const terminate = count === -1;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    var _default = {
      whilst,
      forEach,
      sequence,
      eventually,
      repeatedly,
      forwardsForEach,
      backwardsForEach
    };
  });

  // node_modules/necessary/lib/utilities/ajax.js
  var require_ajax = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get get() {
        return get;
      },
      get post() {
        return post;
      },
      get request() {
        return request;
      }
    });
    var _constants = require_constants2();
    var _methods = require_methods();
    var _contentTypes = require_contentTypes();
    var _headers = require_headers();
    var _http = require_http();
    function get(host, uri, query, headers, responseType, callback) {
      if (typeof headers === _constants.FUNCTION) {
        callback = headers;
        responseType = null;
        headers = {};
      }
      if (typeof responseType === _constants.FUNCTION) {
        callback = responseType;
        if (typeof headers === _constants.STRING) {
          responseType = headers;
          headers = {};
        } else {
          responseType = null;
        }
      }
      const method = _methods.GET_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, content = null;
      underwriteAcceptHeader(headers, accept);
      request(host, uri, query, method, content, headers, responseType, callback);
    }
    function post(host, uri, query, content, headers, responseType, callback) {
      if (typeof headers === _constants.FUNCTION) {
        callback = headers;
        responseType = null;
        headers = {};
      }
      if (typeof responseType === _constants.FUNCTION) {
        callback = responseType;
        if (typeof headers === _constants.STRING) {
          responseType = headers;
          headers = {};
        } else {
          responseType = null;
        }
      }
      const method = _methods.POST_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, contentType = _contentTypes.APPLICATION_JSON_CONTENT_TYPE;
      underwriteAcceptHeader(headers, accept);
      underwriteContentTypeHeader(headers, contentType);
      request(host, uri, query, method, content, headers, responseType, callback);
    }
    function request(host, uri, query, method, content, headers, responseType, callback) {
      const url = (0, _http.urlFromHostURIAndQuery)(host, uri, query), accept = headers[_headers.ACCEPT_HEADER] || null, contentType = headers[_headers.CONTENT_TYPE_HEADER] || null, xmlHttpRequest = new XMLHttpRequest();
      if (contentType === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
        const json = content, jsonString = JSON.stringify(json);
        content = jsonString;
      }
      if (responseType !== null) {
        Object.assign(xmlHttpRequest, {
          responseType
        });
      }
      xmlHttpRequest.onreadystatechange = () => {
        const {readyState, status, response} = xmlHttpRequest, statusCode = status;
        if (readyState == 4) {
          let content2 = response;
          if (accept === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
            try {
              const jsonString = content2, json = JSON.parse(jsonString);
              content2 = json;
            } catch (error) {
              content2 = null;
            }
          }
          callback(content2, statusCode);
        }
      };
      xmlHttpRequest.open(method, url);
      if (accept !== null) {
        xmlHttpRequest.setRequestHeader(_headers.ACCEPT_HEADER, accept);
      }
      if (contentType !== null) {
        xmlHttpRequest.setRequestHeader(_headers.CONTENT_TYPE_HEADER, contentType);
      }
      content !== null ? xmlHttpRequest.send(content) : xmlHttpRequest.send();
    }
    var _default = {
      get,
      post,
      request
    };
    function underwriteAcceptHeader(headers, accept) {
      const name = _headers.ACCEPT_HEADER, value = accept;
      (0, _http.underwrite)(headers, name, value);
    }
    function underwriteContentTypeHeader(headers, contentTYpe) {
      const name = _headers.CONTENT_TYPE_HEADER, value = contentTYpe;
      (0, _http.underwrite)(headers, name, value);
    }
  });

  // node_modules/necessary/lib/browser.js
  var require_browser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ajaxUtilities() {
        return _ajax.default;
      },
      get arrayUtilities() {
        return _array.default;
      },
      get asynchronousUtilities() {
        return _asynchronous.default;
      },
      get characters() {
        return _characters.default;
      },
      get contentTypes() {
        return _contentTypes.default;
      },
      get encodings() {
        return _encodings.default;
      },
      get headers() {
        return _headers.default;
      },
      get httpUtilities() {
        return _http.default;
      },
      get keyCodes() {
        return _keyCodes.default;
      },
      get levels() {
        return _levels.default;
      },
      get methods() {
        return _methods.default;
      },
      get pathUtilities() {
        return _path.default;
      },
      get statusCodes() {
        return _statusCodes.default;
      },
      get statusMessages() {
        return _statusMessages.default;
      },
      get stringUtilities() {
        return _string.default;
      },
      get versionUtilities() {
        return _version.default;
      }
    });
    var _levels = /* @__PURE__ */ _interop_require_default(require_levels());
    var _methods = /* @__PURE__ */ _interop_require_default(require_methods());
    var _headers = /* @__PURE__ */ _interop_require_default(require_headers());
    var _keyCodes = /* @__PURE__ */ _interop_require_default(require_keyCodes());
    var _encodings = /* @__PURE__ */ _interop_require_default(require_encodings());
    var _characters = /* @__PURE__ */ _interop_require_default(require_characters());
    var _statusCodes = /* @__PURE__ */ _interop_require_default(require_statusCodes());
    var _contentTypes = /* @__PURE__ */ _interop_require_default(require_contentTypes());
    var _statusMessages = /* @__PURE__ */ _interop_require_default(require_statusMessages());
    var _path = /* @__PURE__ */ _interop_require_default(require_path());
    var _http = /* @__PURE__ */ _interop_require_default(require_http());
    var _array = /* @__PURE__ */ _interop_require_default(require_array2());
    var _string = /* @__PURE__ */ _interop_require_default(require_string2());
    var _version = /* @__PURE__ */ _interop_require_default(require_version());
    var _asynchronous = /* @__PURE__ */ _interop_require_default(require_asynchronous());
    var _ajax = /* @__PURE__ */ _interop_require_default(require_ajax());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-lexers/lib/constants.js
  var require_constants3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_AMPERSAND() {
        return ESCAPED_AMPERSAND;
      },
      get ESCAPED_GREATER_THAN() {
        return ESCAPED_GREATER_THAN;
      },
      get ESCAPED_LESS_THAN() {
        return ESCAPED_LESS_THAN;
      },
      get V() {
        return V;
      }
    });
    var V = "v";
    var EMPTY_STRING = "";
    var ESCAPED_AMPERSAND = "&amp;";
    var ESCAPED_LESS_THAN = "&lt;";
    var ESCAPED_GREATER_THAN = "&gt;";
  });

  // node_modules/occam-lexers/lib/utilities/content.js
  var require_content = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "sanitiseContent", {
      enumerable: true,
      get: function() {
        return sanitiseContent;
      }
    });
    var _constants = require_constants3();
    function sanitiseContent(content) {
      const sanitisedContent = content.replace(/&/g, _constants.ESCAPED_AMPERSAND).replace(/</g, _constants.ESCAPED_LESS_THAN).replace(/>/g, _constants.ESCAPED_GREATER_THAN);
      return sanitisedContent;
    }
  });

  // node_modules/occam-lexers/lib/types.js
  var require_types = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get commentType() {
        return commentType;
      },
      get default() {
        return _default;
      },
      get endOfLineCommentType() {
        return endOfLineCommentType;
      },
      get endOfLineType() {
        return endOfLineType;
      },
      get endOfMultiLineCommentType() {
        return endOfMultiLineCommentType;
      },
      get middleOfMultiLineCommentType() {
        return middleOfMultiLineCommentType;
      },
      get nameType() {
        return nameType;
      },
      get numberType() {
        return numberType;
      },
      get regularExpressionType() {
        return regularExpressionType;
      },
      get singleLineCommentType() {
        return singleLineCommentType;
      },
      get startOfMultiLineCommentType() {
        return startOfMultiLineCommentType;
      },
      get stringLiteralType() {
        return stringLiteralType;
      },
      get typeType() {
        return typeType;
      },
      get whitespaceType() {
        return whitespaceType;
      }
    });
    var typeType = "type";
    var nameType = "name";
    var numberType = "number";
    var commentType = "comment";
    var endOfLineType = "end-of-line";
    var whitespaceType = "whitespace";
    var stringLiteralType = "string-literal";
    var endOfLineCommentType = `${endOfLineType} ${commentType}`;
    var singleLineCommentType = `single-line ${commentType}`;
    var regularExpressionType = "regular-expression";
    var endOfMultiLineCommentType = `end-of-multi-line ${commentType}`;
    var startOfMultiLineCommentType = `start-of-multi-line ${commentType}`;
    var middleOfMultiLineCommentType = `middle-of-multi-line ${commentType}`;
    var _default = {
      typeType,
      nameType,
      numberType,
      commentType,
      endOfLineType,
      whitespaceType,
      stringLiteralType,
      endOfLineCommentType,
      singleLineCommentType,
      regularExpressionType,
      endOfMultiLineCommentType,
      startOfMultiLineCommentType,
      middleOfMultiLineCommentType
    };
  });

  // node_modules/occam-lexers/lib/token.js
  var require_token = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Token;
      }
    });
    var _necessary = require_browser();
    var _content = require_content();
    var _types = require_types();
    var {first: first2} = _necessary.arrayUtilities;
    var {strlen} = _necessary.stringUtilities;
    var Token = class {
      constructor(type, content, significant) {
        this.type = type;
        this.content = content;
        this.significant = significant;
      }
      getType() {
        return this.type;
      }
      getContent() {
        return this.content;
      }
      getContentLength(naive = false) {
        const contentLength = naive ? this.content.length : strlen(this.content);
        return contentLength;
      }
      isSignificant() {
        return this.significant;
      }
      isCommentToken() {
        const typeIncludesCommentType = this.type.includes(_types.commentType), commentToken = typeIncludesCommentType;
        return commentToken;
      }
      isEndOfLineToken() {
        const typeEndOfLineType = this.type.includes(_types.endOfLineType), endOfLineToken = typeEndOfLineType;
        return endOfLineToken;
      }
      isWhitespaceToken() {
        const typeWhitespaceType = this.type === _types.whitespaceType, whitespaceToken = typeWhitespaceType;
        return whitespaceToken;
      }
      match(token) {
        let matches = false;
        if (token !== null) {
          const type = token.getType(), content = token.getContent(), significant = token.isSignificant();
          matches = this.type === type && this.content === content && this.significant === significant;
        }
        return matches;
      }
      asHTML() {
        const className = this.type, sanitisedContent = (0, _content.sanitiseContent)(this.content), html = `<span class="${className}">${sanitisedContent}</span>`;
        return html;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, type = this.type, content = this.content, significant = this.significant, token = new Class(type, content, significant, ...remainingArguments);
        return token;
      }
      static match(Class, content, significant, ...remainingArguments) {
        let token = null;
        const {regularExpression} = Class, matches = content.match(regularExpression);
        if (matches !== null) {
          const {index} = matches;
          if (index === 0) {
            const firstMatch = first2(matches);
            content = firstMatch;
            const contentLength = content.length;
            if (contentLength > 0) {
              const {type} = Class;
              token = new Class(type, content, significant, ...remainingArguments);
            }
          }
        }
        return token;
      }
      static fromContent(Class, content, significant, ...remainingArguments) {
        const {type} = Class, token = new Class(type, content, significant, ...remainingArguments);
        return token;
      }
      static fromContentAndType(Class, content, type, significant, ...remainingArguments) {
        return new Class(type, content, significant, ...remainingArguments);
      }
    };
  });

  // node_modules/occam-lexers/lib/token/significant.js
  var require_significant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantToken;
      }
    });
    var _token = /* @__PURE__ */ _interop_require_default(require_token());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantToken = class extends _token.default {
      static match(Class, content, ...remainingArguments) {
        if (content === void 0) {
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.match(Class, content, significant, ...remainingArguments);
        return significantToken;
      }
      static fromContent(Class, content, ...remainingArguments) {
        if (content === void 0) {
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.fromContent(Class, content, significant, ...remainingArguments);
        return significantToken;
      }
      static fromContentAndType(Class, content, type, ...remainingArguments) {
        if (type === void 0) {
          type = content;
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.fromContentAndType(Class, content, type, significant, ...remainingArguments);
        return significantToken;
      }
    };
  });

  // node_modules/occam-lexers/lib/rule.js
  var require_rule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Rule;
      }
    });
    var _necessary = require_browser();
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _constants = require_constants3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var Rule = class {
      constructor(type, regularExpression) {
        this.type = type;
        this.regularExpression = regularExpression;
      }
      getType() {
        return this.type;
      }
      getRegularExpression() {
        return this.regularExpression;
      }
      match(content) {
        let significantToken = null;
        const matches = content.match(this.regularExpression);
        if (matches !== null) {
          const {index} = matches;
          if (index === 0) {
            const firstMatch = first2(matches);
            content = firstMatch;
            const contentLength = content.length;
            if (contentLength > 0) {
              significantToken = _significant.default.fromContentAndType(content, this.type);
            }
          }
        }
        return significantToken;
      }
      static fromToken(Token) {
        const {type, regularExpression} = Token, rule = new Rule(type, regularExpression);
        return rule;
      }
      static fromEntry(entry) {
        const entryKeys = Object.keys(entry), firstEntryKey = first2(entryKeys), type = firstEntryKey, regularExpressionPattern = entry[type], regularExpression = regularExpressionFromRegularExpressionPattern(regularExpressionPattern), rule = new Rule(type, regularExpression);
        return rule;
      }
      static fromTypeAndRegularExpressionPattern(type, regularExpressionPattern) {
        const regularExpression = regularExpressionFromRegularExpressionPattern(regularExpressionPattern), rule = new Rule(type, regularExpression);
        return rule;
      }
    };
    function regularExpressionFromRegularExpressionPattern(regularExpressionPattern) {
      const flags = _constants.V, regExp = new RegExp(regularExpressionPattern, flags), regularExpression = regExp;
      return regularExpression;
    }
  });

  // node_modules/occam-lexers/lib/specialSymbols.js
  var require_specialSymbols = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get asterisk() {
        return asterisk;
      },
      get closeBracket() {
        return closeBracket;
      },
      get default() {
        return _default;
      },
      get ellipsis() {
        return ellipsis;
      },
      get endOfLine() {
        return endOfLine;
      },
      get epsilon() {
        return epsilon;
      },
      get noWhitespace() {
        return noWhitespace;
      },
      get opaque() {
        return opaque;
      },
      get openBracket() {
        return openBracket;
      },
      get plus() {
        return plus;
      },
      get questionMark() {
        return questionMark;
      },
      get semiOpaque() {
        return semiOpaque;
      },
      get separator() {
        return separator;
      },
      get startOfContent() {
        return startOfContent;
      },
      get terminator() {
        return terminator;
      },
      get verticalBar() {
        return verticalBar;
      },
      get wildcard() {
        return wildcard;
      }
    });
    var plus = "+";
    var opaque = ".";
    var epsilon = "\u03B5";
    var wildcard = ".";
    var asterisk = "*";
    var ellipsis = "...";
    var separator = "::=";
    var semiOpaque = "..";
    var terminator = ";";
    var verticalBar = "|";
    var openBracket = "(";
    var closeBracket = ")";
    var questionMark = "?";
    var endOfLine = "<END_OF_LINE>";
    var noWhitespace = "<NO_WHITESPACE>";
    var startOfContent = "<START_OF_CONTENT>";
    var _default = {
      plus,
      opaque,
      epsilon,
      wildcard,
      asterisk,
      ellipsis,
      separator,
      semiOpaque,
      terminator,
      verticalBar,
      openBracket,
      closeBracket,
      questionMark,
      endOfLine,
      noWhitespace,
      startOfContent
    };
  });

  // node_modules/occam-lexers/lib/utilities/rules.js
  var require_rules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get rulesAsEntries() {
        return rulesAsEntries;
      }
    });
    function rulesAsEntries(rules) {
      const entries = rules.map((rule) => {
        const entry = ruleAsEntry(rule);
        return entry;
      });
      return entries;
    }
    var _default = {
      rulesAsEntries
    };
    function ruleAsEntry(rule) {
      const type = rule.getType(), regularExpression = rule.getRegularExpression(), {source} = regularExpression, entry = {
        [type]: source
      };
      return entry;
    }
  });

  // node_modules/occam-lexers/lib/utilities/lexer.js
  var require_lexer = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get lexerFromRules() {
        return lexerFromRules;
      },
      get rulesFromEntries() {
        return rulesFromEntries;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function rulesFromEntries(entries) {
      const rules = entries.map((entry) => {
        const rule = _rule.default.fromEntry(entry);
        return rule;
      });
      return rules;
    }
    function lexerFromRules(Class, rules) {
      const InCommentClasses = InCommentClassesFromClass(Class), NotInCommentClasses = NotInCommentClassesFromClass(Class), lexer = new Class(rules, InCommentClasses, NotInCommentClasses);
      return lexer;
    }
    var _default = {
      rulesFromEntries,
      lexerFromRules
    };
    function InCommentClassesFromClass(Class) {
      const {EndOfLineCommentToken, EndOfMultiLineCommentToken, MiddleOfMultiLineCommentToken} = Class;
      const InCommentClasses = [
        EndOfLineCommentToken,
        EndOfMultiLineCommentToken,
        MiddleOfMultiLineCommentToken
      ];
      return InCommentClasses;
    }
    function NotInCommentClassesFromClass(Class) {
      const {EndOfLineToken, WhitespaceToken, SingleLineCommentToken, RegularExpressionToken, StartOfMultiLineCommentToken, SinglyQuotedStringLiteralToken, DoublyQuotedStringLiteralToken} = Class;
      const NotInCommentClasses = [
        EndOfLineToken,
        WhitespaceToken,
        StartOfMultiLineCommentToken,
        SingleLineCommentToken,
        RegularExpressionToken,
        SinglyQuotedStringLiteralToken,
        DoublyQuotedStringLiteralToken
      ];
      return NotInCommentClasses;
    }
  });

  // node_modules/occam-lexers/lib/bnf/entries.js
  var require_entries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\||\\(|\\)|\\?|\\*|\\+|\\.\\.\\.|\\.\\.|\\.|::=|;|\u03B5|<START_OF_CONTENT>|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        number: "^(?:0|[1-9][0-9]*)"
      },
      {
        name: "^[\\w~]+"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-lexers/lib/utilities/token.js
  var require_token2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "inCommentFromTokenAndInComment", {
      enumerable: true,
      get: function() {
        return inCommentFromTokenAndInComment;
      }
    });
    function inCommentFromTokenAndInComment(token, inComment) {
      const tokenCommentToken = token.isCommentToken();
      if (tokenCommentToken) {
        const commentToken = token, commentTokenInCommentPreserving = commentToken.isInCommentPreserving();
        inComment = commentTokenInCommentPreserving;
      }
      return inComment;
    }
  });

  // node_modules/occam-lexers/lib/common/lexer.js
  var require_lexer2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CommonLexer;
      }
    });
    var _constants = require_constants3();
    var _token = require_token2();
    var _lexer = require_lexer();
    var CommonLexer = class {
      constructor(rules, InCommentClasses, NotInCommentClasses) {
        this.rules = rules;
        this.InCommentClasses = InCommentClasses;
        this.NotInCommentClasses = NotInCommentClasses;
      }
      getRules() {
        return this.rules;
      }
      getInCommentClasses() {
        return this.InCommentClasses;
      }
      getNotInCommentClasses() {
        return this.NotInCommentClasses;
      }
      tokenise(content, inComment = false) {
        const tokens = [];
        while (content !== _constants.EMPTY_STRING) {
          let token = null;
          const Classes = inComment ? this.InCommentClasses : this.NotInCommentClasses;
          Classes.some((Class) => {
            if (Class !== null) {
              token = Class.match(content);
              if (token !== null) {
                return true;
              }
            }
          });
          if (token === null) {
            let significantToken = null;
            this.rules.some((rule) => {
              significantToken = rule.match(content);
              if (significantToken !== null) {
                token = significantToken;
                return true;
              }
            });
          }
          if (token === null) {
            throw new Error(`The content '${content}' cannot be tokenised.`);
          }
          tokens.push(token);
          inComment = (0, _token.inCommentFromTokenAndInComment)(token, inComment);
          const naive = true, tokenContentLength = token.getContentLength(naive), start = tokenContentLength;
          content = content.substring(start);
        }
        return tokens;
      }
      static fromNothing(Class) {
        const {entries} = Class, rules = (0, _lexer.rulesFromEntries)(entries), lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
      static fromRules(Class, rules) {
        const lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
      static fromEntries(Class, entries) {
        const rules = (0, _lexer.rulesFromEntries)(entries), lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
    };
  });

  // node_modules/occam-lexers/lib/token/nonSignificant.js
  var require_nonSignificant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonSignificantToken;
      }
    });
    var _token = /* @__PURE__ */ _interop_require_default(require_token());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonSignificantToken = class extends _token.default {
      static match(Class, content) {
        const significant = false, nonSignificantToken = _token.default.match(Class, content, significant);
        return nonSignificantToken;
      }
      static fromContent(Class, content) {
        const significant = false, nonSignificantToken = _token.default.fromContent(Class, content, significant);
        return nonSignificantToken;
      }
      static fromContentAndType(Class, content, type) {
        const significant = false, nonSignificantToken = _token.default.fromContentAndType(Class, content, type, significant);
        return nonSignificantToken;
      }
    };
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/whitespace.js
  var require_whitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WhitespaceToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _WhitespaceToken = class extends _nonSignificant.default {
      static match(content) {
        return _nonSignificant.default.match(_WhitespaceToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_WhitespaceToken, content);
      }
    };
    var WhitespaceToken = _WhitespaceToken;
    __publicField(WhitespaceToken, "type", _types.whitespaceType);
    __publicField(WhitespaceToken, "regularExpression", /^[\t\v ]+/);
  });

  // node_modules/occam-lexers/lib/token/significant/regularExpression.js
  var require_regularExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _RegularExpressionToken = class extends _significant.default {
      static match(content) {
        return _significant.default.match(_RegularExpressionToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_RegularExpressionToken, content);
      }
    };
    var RegularExpressionToken = _RegularExpressionToken;
    __publicField(RegularExpressionToken, "type", _types.regularExpressionType);
    __publicField(RegularExpressionToken, "regularExpression", /^\/(?:\\[^\s]|[^\/\r\n\f])*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/endOfLine.js
  var require_endOfLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNonSignificantToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineNonSignificantToken = class extends _nonSignificant.default {
      asHTML() {
        const content = this.getContent(), html = content;
        return html;
      }
      static match(content) {
        return _nonSignificant.default.match(_EndOfLineNonSignificantToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_EndOfLineNonSignificantToken, content);
      }
    };
    var EndOfLineNonSignificantToken = _EndOfLineNonSignificantToken;
    __publicField(EndOfLineNonSignificantToken, "type", _types.endOfLineType);
    __publicField(EndOfLineNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral.js
  var require_stringLiteral = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralToken;
      }
    });
    var _necessary = require_browser();
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {substring} = _necessary.stringUtilities;
    var StringLiteralToken = class extends _significant.default {
      getString() {
        const content = this.getContent(), contentLength = this.getContentLength(), start = 1, end = contentLength - 1, string = substring(content, start, end);
        return string;
      }
      static match(Class, content) {
        return _significant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _significant.default.fromContent(Class, content);
      }
    };
    __publicField(StringLiteralToken, "type", _types.stringLiteralType);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/doublyQuoted.js
  var require_doublyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DoublyQuotedStringLiteralToken;
      }
    });
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _DoublyQuotedStringLiteralToken = class extends _stringLiteral.default {
      static match(content) {
        return _stringLiteral.default.match(_DoublyQuotedStringLiteralToken, content);
      }
      static fromContent(content) {
        return _stringLiteral.default.fromContent(_DoublyQuotedStringLiteralToken, content);
      }
    };
    var DoublyQuotedStringLiteralToken = _DoublyQuotedStringLiteralToken;
    __publicField(DoublyQuotedStringLiteralToken, "regularExpression", /^"(?:\\[^\s]|[^"\\\r\n])*"/);
  });

  // node_modules/occam-lexers/lib/bnf/lexer.js
  var require_lexer3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFLexer;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BNFLexer = class extends _lexer.default {
      tokensFromBNF(bnf) {
        const content = bnf, tokens = super.tokenise(content);
        return tokens;
      }
      static fromNothing() {
        return _lexer.default.fromNothing(_BNFLexer);
      }
      static fromRules(rules) {
        return _lexer.default.fromRules(_BNFLexer, rules);
      }
      static fromEntries(entries) {
        return _lexer.default.fromEntries(_BNFLexer, entries);
      }
    };
    var BNFLexer = _BNFLexer;
    __publicField(BNFLexer, "entries", _entries.default);
    __publicField(BNFLexer, "EndOfLineToken", _endOfLine.default);
    __publicField(BNFLexer, "WhitespaceToken", _whitespace.default);
    __publicField(BNFLexer, "EndOfLineCommentToken", null);
    __publicField(BNFLexer, "RegularExpressionToken", _regularExpression.default);
    __publicField(BNFLexer, "SingleLineCommentToken", null);
    __publicField(BNFLexer, "EndOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "StartOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(BNFLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/basic/entries.js
  var require_entries2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        digit: "^\\d+"
      },
      {
        bracket: "^(?:\\(|\\))"
      },
      {
        operator: "^(?:\\+|-|\\*|\\/)"
      },
      {
        unassigned: "^[^\\s]"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/singlyQuoted.js
  var require_singlyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SinglyQuotedStringLiteralToken;
      }
    });
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _SinglyQuotedStringLiteralToken = class extends _stringLiteral.default {
      static match(content) {
        return _stringLiteral.default.match(_SinglyQuotedStringLiteralToken, content);
      }
      static fromContent(content) {
        return _stringLiteral.default.fromContent(_SinglyQuotedStringLiteralToken, content);
      }
    };
    var SinglyQuotedStringLiteralToken = _SinglyQuotedStringLiteralToken;
    __publicField(SinglyQuotedStringLiteralToken, "regularExpression", /^'(?:\\[^\s]|[^'\\\r\n])*'/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine.js
  var require_singleLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SingleLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SingleLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = false;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(SingleLineCommentToken, "type", _types.singleLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/pythonStyle.js
  var require_pythonStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleSingleLineCommentToken;
      }
    });
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleSingleLineCommentToken = class extends _singleLine.default {
      static match(content) {
        return _singleLine.default.match(_PythonStyleSingleLineCommentToken, content);
      }
      static fromContent(content) {
        return _singleLine.default.fromContent(_PythonStyleSingleLineCommentToken, content);
      }
    };
    var PythonStyleSingleLineCommentToken = _PythonStyleSingleLineCommentToken;
    __publicField(PythonStyleSingleLineCommentToken, "regularExpression", /^#[^\r\n\f]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/endOfLine.js
  var require_endOfLine2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineCommentNonSignificantToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineCommentNonSignificantToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(content) {
        return _nonSignificant.default.match(_EndOfLineCommentNonSignificantToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_EndOfLineCommentNonSignificantToken, content);
      }
    };
    var EndOfLineCommentNonSignificantToken = _EndOfLineCommentNonSignificantToken;
    __publicField(EndOfLineCommentNonSignificantToken, "type", _types.endOfLineCommentType);
    __publicField(EndOfLineCommentNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf.js
  var require_endOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = false;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(EndOfMultiLineCommentToken, "type", _types.endOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/pythonStyle.js
  var require_pythonStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleEndOfMultiLineCommentToken;
      }
    });
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleEndOfMultiLineCommentToken = class extends _endOf.default {
      static match(content) {
        return _endOf.default.match(_PythonStyleEndOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _endOf.default.fromContent(_PythonStyleEndOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleEndOfMultiLineCommentToken = _PythonStyleEndOfMultiLineCommentToken;
    __publicField(PythonStyleEndOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf.js
  var require_startOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(StartOfMultiLineCommentToken, "type", _types.startOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/pythonStyle.js
  var require_pythonStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleStartOfMultiLineCommentToken;
      }
    });
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleStartOfMultiLineCommentToken = class extends _startOf.default {
      static match(content) {
        return _startOf.default.match(_PythonStyleStartOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _startOf.default.fromContent(_PythonStyleStartOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleStartOfMultiLineCommentToken = _PythonStyleStartOfMultiLineCommentToken;
    __publicField(PythonStyleStartOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf.js
  var require_middleOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return MiddleOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var MiddleOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(MiddleOfMultiLineCommentToken, "type", _types.middleOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/pythonStyle.js
  var require_pythonStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleMiddleOfMultiLineCommentToken;
      }
    });
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleMiddleOfMultiLineCommentToken = class extends _middleOf.default {
      static match(content) {
        return _middleOf.default.match(_PythonStyleMiddleOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _middleOf.default.fromContent(_PythonStyleMiddleOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleMiddleOfMultiLineCommentToken = _PythonStyleMiddleOfMultiLineCommentToken;
    __publicField(PythonStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n\f]+?(?=###)|[^\r\n\f]+)/);
  });

  // node_modules/occam-lexers/lib/basic/lexer.js
  var require_lexer4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BasicLexer;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries2());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _singlyQuoted = /* @__PURE__ */ _interop_require_default(require_singlyQuoted());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    var _pythonStyle = /* @__PURE__ */ _interop_require_default(require_pythonStyle());
    var _endOfLine1 = /* @__PURE__ */ _interop_require_default(require_endOfLine2());
    var _pythonStyle1 = /* @__PURE__ */ _interop_require_default(require_pythonStyle2());
    var _pythonStyle2 = /* @__PURE__ */ _interop_require_default(require_pythonStyle3());
    var _pythonStyle3 = /* @__PURE__ */ _interop_require_default(require_pythonStyle4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BasicLexer = class extends _lexer.default {
      static fromNothing() {
        return _lexer.default.fromNothing(_BasicLexer);
      }
      static fromRules(rules) {
        return _lexer.default.fromRules(_BasicLexer, rules);
      }
      static fromEntries(entries) {
        return _lexer.default.fromEntries(_BasicLexer, entries);
      }
    };
    var BasicLexer = _BasicLexer;
    __publicField(BasicLexer, "entries", _entries.default);
    __publicField(BasicLexer, "EndOfLineToken", _endOfLine.default);
    __publicField(BasicLexer, "WhitespaceToken", _whitespace.default);
    __publicField(BasicLexer, "EndOfLineCommentToken", _endOfLine1.default);
    __publicField(BasicLexer, "RegularExpressionToken", _regularExpression.default);
    __publicField(BasicLexer, "SingleLineCommentToken", _pythonStyle.default);
    __publicField(BasicLexer, "EndOfMultiLineCommentToken", _pythonStyle1.default);
    __publicField(BasicLexer, "StartOfMultiLineCommentToken", _pythonStyle2.default);
    __publicField(BasicLexer, "MiddleOfMultiLineCommentToken", _pythonStyle3.default);
    __publicField(BasicLexer, "SinglyQuotedStringLiteralToken", _singlyQuoted.default);
    __publicField(BasicLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/token/significant/endOfLine.js
  var require_endOfLine3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineSignificantToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineSignificantToken = class extends _significant.default {
      asHTML() {
        const content = this.getContent(), html = content;
        return html;
      }
      static match(content) {
        return _significant.default.match(_EndOfLineSignificantToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_EndOfLineSignificantToken, content);
      }
    };
    var EndOfLineSignificantToken = _EndOfLineSignificantToken;
    __publicField(EndOfLineSignificantToken, "type", _types.endOfLineType);
    __publicField(EndOfLineSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/significant/comment/endOfLine.js
  var require_endOfLine4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineCommentSignificantToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineCommentSignificantToken = class extends _significant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(content) {
        return _significant.default.match(_EndOfLineCommentSignificantToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_EndOfLineCommentSignificantToken, content);
      }
    };
    var EndOfLineCommentSignificantToken = _EndOfLineCommentSignificantToken;
    __publicField(EndOfLineCommentSignificantToken, "type", _types.endOfLineCommentType);
    __publicField(EndOfLineCommentSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/cStyle.js
  var require_cStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleSingleLineCommentToken;
      }
    });
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleSingleLineCommentToken = class extends _singleLine.default {
      static match(content) {
        return _singleLine.default.match(_CStyleSingleLineCommentToken, content);
      }
      static fromContent(content) {
        return _singleLine.default.fromContent(_CStyleSingleLineCommentToken, content);
      }
    };
    var CStyleSingleLineCommentToken = _CStyleSingleLineCommentToken;
    __publicField(CStyleSingleLineCommentToken, "regularExpression", /^\/\/[^\r\n\f]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/cStyle.js
  var require_cStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleEndOfMultiLineCommentToken;
      }
    });
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleEndOfMultiLineCommentToken = class extends _endOf.default {
      static match(content) {
        return _endOf.default.match(_CStyleEndOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _endOf.default.fromContent(_CStyleEndOfMultiLineCommentToken, content);
      }
    };
    var CStyleEndOfMultiLineCommentToken = _CStyleEndOfMultiLineCommentToken;
    __publicField(CStyleEndOfMultiLineCommentToken, "regularExpression", /^\*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/cStyle.js
  var require_cStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleStartOfMultiLineCommentToken;
      }
    });
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleStartOfMultiLineCommentToken = class extends _startOf.default {
      static match(content) {
        return _startOf.default.match(_CStyleStartOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _startOf.default.fromContent(_CStyleStartOfMultiLineCommentToken, content);
      }
    };
    var CStyleStartOfMultiLineCommentToken = _CStyleStartOfMultiLineCommentToken;
    __publicField(CStyleStartOfMultiLineCommentToken, "regularExpression", /^\/\*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/cStyle.js
  var require_cStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleMiddleOfMultiLineCommentToken;
      }
    });
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleMiddleOfMultiLineCommentToken = class extends _middleOf.default {
      static match(content) {
        return _middleOf.default.match(_CStyleMiddleOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _middleOf.default.fromContent(_CStyleMiddleOfMultiLineCommentToken, content);
      }
    };
    var CStyleMiddleOfMultiLineCommentToken = _CStyleMiddleOfMultiLineCommentToken;
    __publicField(CStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n\f]+?(?=\*\/)|[^\r\n\f]+)/);
  });

  // node_modules/occam-lexers/lib/index.js
  var require_lib3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BNFLexer() {
        return _lexer1.default;
      },
      get BasicLexer() {
        return _lexer2.default;
      },
      get CStyleEndOfMultiLineCommentToken() {
        return _cStyle1.default;
      },
      get CStyleMiddleOfMultiLineCommentToken() {
        return _cStyle3.default;
      },
      get CStyleSingleLineCommentToken() {
        return _cStyle.default;
      },
      get CStyleStartOfMultiLineCommentToken() {
        return _cStyle2.default;
      },
      get CommonLexer() {
        return _lexer3.default;
      },
      get DoublyQuotedStringLiteralToken() {
        return _doublyQuoted.default;
      },
      get EndOfLineCommentNonSignificantToken() {
        return _endOfLine3.default;
      },
      get EndOfLineCommentSignificantToken() {
        return _endOfLine2.default;
      },
      get EndOfLineNonSignificantToken() {
        return _endOfLine1.default;
      },
      get EndOfLineSignificantToken() {
        return _endOfLine.default;
      },
      get EndOfMultiLineCommentToken() {
        return _endOf.default;
      },
      get MiddleOfMultiLineCommentToken() {
        return _middleOf.default;
      },
      get NonSignificantToken() {
        return _nonSignificant.default;
      },
      get PythonStyleEndOfMultiLineCommentToken() {
        return _pythonStyle1.default;
      },
      get PythonStyleMiddleOfMultiLineCommentToken() {
        return _pythonStyle3.default;
      },
      get PythonStyleSingleLineCommentToken() {
        return _pythonStyle.default;
      },
      get PythonStyleStartOfMultiLineCommentToken() {
        return _pythonStyle2.default;
      },
      get RegularExpressionToken() {
        return _regularExpression.default;
      },
      get Rule() {
        return _rule.default;
      },
      get SignificantToken() {
        return _significant.default;
      },
      get SingleLineCommentToken() {
        return _singleLine.default;
      },
      get SinglyQuotedStringLiteralToken() {
        return _singlyQuoted.default;
      },
      get StartOfMultiLineCommentToken() {
        return _startOf.default;
      },
      get StringLiteralToken() {
        return _stringLiteral.default;
      },
      get WhitespaceToken() {
        return _whitespace.default;
      },
      get lexerUtilities() {
        return _lexer.default;
      },
      get rulesUtilities() {
        return _rules.default;
      },
      get specialSymbols() {
        return _specialSymbols.default;
      },
      get types() {
        return _types.default;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule());
    var _types = /* @__PURE__ */ _interop_require_default(require_types());
    var _specialSymbols = /* @__PURE__ */ _interop_require_default(require_specialSymbols());
    var _rules = /* @__PURE__ */ _interop_require_default(require_rules());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer());
    var _lexer1 = /* @__PURE__ */ _interop_require_default(require_lexer3());
    var _lexer2 = /* @__PURE__ */ _interop_require_default(require_lexer4());
    var _lexer3 = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine3());
    var _endOfLine1 = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _endOfLine2 = /* @__PURE__ */ _interop_require_default(require_endOfLine4());
    var _endOfLine3 = /* @__PURE__ */ _interop_require_default(require_endOfLine2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _singlyQuoted = /* @__PURE__ */ _interop_require_default(require_singlyQuoted());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    var _cStyle = /* @__PURE__ */ _interop_require_default(require_cStyle());
    var _cStyle1 = /* @__PURE__ */ _interop_require_default(require_cStyle2());
    var _cStyle2 = /* @__PURE__ */ _interop_require_default(require_cStyle3());
    var _cStyle3 = /* @__PURE__ */ _interop_require_default(require_cStyle4());
    var _pythonStyle = /* @__PURE__ */ _interop_require_default(require_pythonStyle());
    var _pythonStyle1 = /* @__PURE__ */ _interop_require_default(require_pythonStyle2());
    var _pythonStyle2 = /* @__PURE__ */ _interop_require_default(require_pythonStyle3());
    var _pythonStyle3 = /* @__PURE__ */ _interop_require_default(require_pythonStyle4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/entries.js
  var require_entries3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        media: "^@media"
      },
      {
        keyframes: "^@keyframes"
      },
      {
        colour: "^#(?:[0-9a-fA-F]{6}|[0-9a-fA-F]{3})"
      },
      {
        important: "^!important"
      },
      {
        percentage: "^(?:[0-9]+|[0-9]*\\.[0-9]+)%"
      },
      {
        frequency: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:hz|khz)"
      },
      {
        fraction: "^[1-9][0-9]*?fr"
      },
      {
        length: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:px|cm|mm|in|pt|pc)"
      },
      {
        angle: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:deg|rad|grad)"
      },
      {
        time: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:s|ms)"
      },
      {
        rems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)rem"
      },
      {
        ems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)em"
      },
      {
        number: "^[0-9]+|[0-9]*\\.[0-9]+"
      },
      {
        special: "^;|::|:|\\.|,|\\|=|~=|=|>|\\{|\\}|\\(|\\)|\\[|\\]"
      },
      {
        identifier: "^[_a-zA-Z0-9\\-]+"
      },
      {
        "logical-operator": "^(?:and|not)$"
      },
      {
        "plus-or-minus": "^[\\+\\-]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/with-style/lib/css/lexer.js
  var require_lexer5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CSSLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries3());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CSSLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CSSLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CSSLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CSSLexer, entries);
      }
    };
    var CSSLexer = _CSSLexer;
    __publicField(CSSLexer, "entries", _entries.default);
    __publicField(CSSLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(CSSLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CSSLexer, "EndOfLineCommentToken", null);
    __publicField(CSSLexer, "RegularExpressionToken", null);
    __publicField(CSSLexer, "SingleLineCommentToken", null);
    __publicField(CSSLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CSSLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-parsers/lib/bnf/bnf.js
  var require_bnf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

      document                 ::=  ( rule | error )+ ;

      rule                     ::=  name opacityModifier? "::=" definitions ";" ;

      name                     ::=  [name] ;

      definitions              ::=  definition ( "|" definition )* ;

      definition               ::=  part+ precedence? ;
 
      part                     ::=  nonTerminalPart quantifier*

                                 |  terminalPart quantifier*

                                 ;

      nonTerminalPart          ::=  choiceOfParts

                                 |  sequenceOfParts

                                 |  ruleName callAheadModifier?

                                 ;

      terminalPart             ::=  significantTokenType
  
                                 |  regularExpression
 
                                 |  stringLiteral
  
                                 |  endOfLine
  
                                 |  wildcard
  
                                 |  epsilon

                                 |  noWhitespace
                              
                                 |  startOfContent

                                 ;
                              
      sequenceOfParts          ::=  "(" part part+ ")" ;

      choiceOfParts            ::=  "(" partChoice ( "|" partChoice )+ ")" ;

      partChoice               ::=  part precedence? ;

      ruleName                 ::=  [name] ;

      significantTokenType     ::=  [type] ;

      regularExpression        ::=  [regular-expression] ;

      stringLiteral            ::=  [string-literal] ;

      precedence               ::=  "(" [number]? ")" ;
      
      endOfLine                ::=  "<END_OF_LINE>" ;
      
      wildcard                 ::=  "." ;

      epsilon                  ::=  "\u03B5" ;

      noWhitespace             ::=  "<NO_WHITESPACE>" ;                              

      startOfContent           ::+  "<START_OF_CONTENT>"; 
      
      quantifier               ::=  optionalQuantifier
 
                                 |  oneOrMoreQuantifier
  
                                 |  zeroOrMoreQuantifier
  
                                 ;

      opacityModifier          ::=  <NO_WHITESPACE>( "." | ".." );
      
      callAheadModifier        ::=  <NO_WHITESPACE>"..." ;

      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;

      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;

      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;

      error.                   ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-parsers/lib/constants.js
  var require_constants4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_BACKSLASH() {
        return ESCAPED_BACKSLASH;
      },
      get ESCAPED_DOUBLE_QUOTE() {
        return ESCAPED_DOUBLE_QUOTE;
      }
    });
    var EMPTY_STRING = "";
    var ESCAPED_BACKSLASH = "\\";
    var ESCAPED_DOUBLE_QUOTE = '"';
  });

  // node_modules/occam-parsers/lib/utilities/string.js
  var require_string3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "paddingFromPaddingLength", {
      enumerable: true,
      get: function() {
        return paddingFromPaddingLength;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {SPACE_CHARACTER} = _necessary.characters;
    function paddingFromPaddingLength(paddingLength) {
      let padding = _constants.EMPTY_STRING;
      for (let position = 0; position < paddingLength; position++) {
        padding += SPACE_CHARACTER;
      }
      return padding;
    }
  });

  // node_modules/occam-parsers/lib/rule.js
  var require_rule2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Rule;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var _occamlexers = require_lib3();
    var _string = require_string3();
    var {clear} = _necessary.arrayUtilities;
    var {opaque: opaqueSpecialSymbol, semiOpaque: semiOpaqueSpecialSymbol} = _occamlexers.specialSymbols;
    var Rule = class {
      constructor(name, opacity, definitions) {
        this.name = name;
        this.opacity = opacity;
        this.definitions = definitions;
      }
      getName() {
        return this.name;
      }
      getOpacity() {
        return this.opacity;
      }
      getDefinitions() {
        return this.definitions;
      }
      setName(name) {
        this.name = name;
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      setDefinitions(definitions) {
        this.definitions = definitions;
      }
      isOpaque() {
        const opaque = this.opacity === opaqueSpecialSymbol;
        return opaque;
      }
      isSemiOpaque() {
        const semiOpaque = this.opacity === semiOpaqueSpecialSymbol;
        return semiOpaque;
      }
      isTransparent() {
        const semiOpaque = this.opacity === null;
        return semiOpaque;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const opacity = this.opacity, ruleName = this.name, precedence = null, childNodes = [], NonTerminalNode = this.NonTerminalNodeFromRuleName(ruleName, state), nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), savedPrecedence = state.getSavedPrecedence();
        let node = nonTerminalNode;
        nodes.push(node);
        parsed = this.definitions.some((definition) => {
          let parsed2;
          clear(childNodes);
          const precedence2 = definition.getPrecedence();
          state.setPrecedence(precedence2);
          callback = () => {
            let parsed3;
            const precedence3 = state.getPrecedence();
            nonTerminalNode.setPrecedence(precedence3);
            parsed3 = true;
            if (parsed3) {
              node.setChildNodesParentNode();
            }
            const rewrittenNonTerminalNode = nonTerminalNode.rewrite(state);
            if (rewrittenNonTerminalNode !== null) {
              if (parsed3) {
                nodes.pop();
                node = rewrittenNonTerminalNode;
                nodes.push(node);
              }
            }
            if (parsed3) {
              const empty = node.isEmpty();
              if (empty) {
                parsed3 = false;
              }
            }
            if (parsed3) {
              const unprecedented = node.isUnprecedented();
              if (unprecedented) {
                parsed3 = false;
              }
            }
            if (parsed3) {
              if (callAhead !== null) {
                state.resetPrecedence(savedPrecedence);
                parsed3 = callAhead();
              }
            }
            if (rewrittenNonTerminalNode !== null) {
              if (!parsed3) {
                nodes.pop();
                node = nonTerminalNode;
                nodes.push(node);
              }
            }
            if (!parsed3) {
              node.resetChildNodesParentNode();
            }
            return parsed3;
          };
          parsed2 = definition.parse(childNodes, state, callback, callAhead);
          if (!parsed2) {
            state.resetPrecedence(savedPrecedence);
          }
          return parsed2;
        });
        if (!parsed) {
          nodes.pop();
        }
        if (callAhead === null) {
          state.resetPrecedence(savedPrecedence);
        }
        return parsed;
      }
      NonTerminalNodeFromRuleName(ruleName, state) {
        return state.NonTerminalNodeFromRuleName(ruleName);
      }
      asString(maximumRuleNameLength, multiLine = true) {
        const definitionsLength = this.definitions.length;
        multiLine = multiLine && definitionsLength > 1;
        const maximumPadding = (0, _string.paddingFromPaddingLength)(maximumRuleNameLength), definitionsString = this.definitions.reduce((definitionsString2, definition) => {
          const definitionString = definition.asString();
          if (definitionsString2 === _constants.EMPTY_STRING) {
            definitionsString2 = definitionString;
          } else {
            definitionsString2 = multiLine ? `${definitionsString2}

${maximumPadding}   | ${definitionString}` : `${definitionsString2} | ${definitionString}`;
          }
          return definitionsString2;
        }, _constants.EMPTY_STRING), ruleName = this.name, ruleNameLength = ruleName.length, opacityString = this.opacity === null ? _constants.EMPTY_STRING : this.opacity, opacityStringLength = opacityString.length, paddingLength = maximumRuleNameLength - ruleNameLength - opacityStringLength, padding = (0, _string.paddingFromPaddingLength)(paddingLength);
        const semicolonString = multiLine ? `

${maximumPadding}   ;` : " ;", string = `

${this.name}${opacityString}${padding} ::= ${definitionsString}${semicolonString}`;
        return string;
      }
      static fromNameOpacityAndDefinitions(Class, name, opacity, definitions) {
        if (definitions === void 0) {
          definitions = opacity;
          opacity = name;
          name = Class;
          Class = Rule;
        }
        const rule = new Class(name, opacity, definitions);
        return rule;
      }
    };
  });

  // node_modules/occam-parsers/lib/mixins/node.js
  var require_node = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var {push, first: first2, forwardsSome, backwardsSome} = _necessary.arrayUtilities;
    function getMultiplicity() {
      const childNodesLength = this.childNodes.length, multiplicity = childNodesLength;
      return multiplicity;
    }
    function mapChildNode(callback) {
      return this.childNodes.map(callback);
    }
    function someChildNode(callback) {
      return this.childNodes.some(callback);
    }
    function findChildNode(callback) {
      return this.childNodes.find(callback);
    }
    function everyChildNode(callback) {
      return this.childNodes.every(callback);
    }
    function filterChildNode(callback) {
      return this.childNodes.filter(callback);
    }
    function reduceChildNode(callback, initialValue) {
      return this.childNodes.reduce(callback, initialValue);
    }
    function forEachChildNode(callback) {
      this.childNodes.forEach(callback);
    }
    function forwardsSomeChildNode(callback) {
      return forwardsSome(this.childNodes, callback);
    }
    function backwardsSomeChildNode(callback) {
      return backwardsSome(this.childNodes, callback);
    }
    function indexOfChildNode(childNode) {
      return this.childNodes.indexOf(childNode);
    }
    function setChildNodesParentNode(childNodes) {
      if (childNodes === void 0) {
        childNodes = [
          ...this.childNodes
        ];
      }
      const parentNode = this;
      childNodes.forEach((childNode) => {
        childNode.setParentNode(parentNode);
      });
    }
    function resetChildNodesParentNode(childNodes) {
      if (childNodes === void 0) {
        childNodes = [
          ...this.childNodes
        ];
      }
      const parentNode = null;
      childNodes.forEach((childNode) => {
        childNode.setParentNode(parentNode);
      });
    }
    function addChildNode(addedChildNode, startIndex) {
      const addedChildNodes = [
        addedChildNode
      ];
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function addChildNodes(addedChildNodes, startIndex) {
      const deleteCount = 0;
      this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
    }
    function removeChildNode(removedChildNode) {
      let removedChildNodes;
      removedChildNodes = [
        removedChildNode
      ];
      removedChildNodes = this.removeChildNodes(removedChildNodes);
      return removedChildNodes;
    }
    function removeChildNodes(removedChildNodes) {
      if (removedChildNodes === void 0) {
        removedChildNodes = [
          ...this.childNodes
        ];
      }
      const removedChildNodesLength = removedChildNodes.length;
      if (removedChildNodesLength > 0) {
        const firstReplacedChildNode = first2(removedChildNodes), startIndex = this.childNodes.indexOf(firstReplacedChildNode), deleteCount = removedChildNodesLength, addedChildNodes = [];
        removedChildNodes = this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
      }
      return removedChildNodes;
    }
    function replaceChildNode(replacedChildNode, replacementChildNodes) {
      const replacedChildNodes = [
        replacedChildNode
      ];
      this.replaceChildNodes(replacedChildNodes, replacementChildNodes);
    }
    function replaceChildNodes(replacedChildNodes, replacementChildNodes) {
      const replacedChildNodesLength = replacedChildNodes.length, firstReplacedChildNode = first2(replacedChildNodes), startIndex = this.childNodes.indexOf(firstReplacedChildNode), deleteCount = replacedChildNodesLength;
      this.spliceChildNodes(startIndex, deleteCount, replacementChildNodes);
    }
    function appendChildNode(appendedChildNode) {
      const appendedChildNodes = [
        appendedChildNode
      ];
      this.appendChildNodes(appendedChildNodes);
    }
    function appendChildNodes(appendedChildNodes) {
      const addedChildNodes = appendedChildNodes, multiplicity = this.getMultiplicity(), startIndex = multiplicity;
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function prependChildNode(prependedChildNode) {
      const prependedChildNodes = [
        prependedChildNode
      ];
      this.prependChildNodes(prependedChildNodes);
    }
    function prependChildNodes(prependedChildNodes) {
      const addedChildNodes = prependedChildNodes, startIndex = 0;
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function spliceChildNodes(startIndex, deleteCount, addedChildNodes = []) {
      const removedChildNodes = this.childNodes.splice(startIndex, deleteCount, ...addedChildNodes);
      this.resetChildNodesParentNode(removedChildNodes);
      this.setChildNodesParentNode(addedChildNodes);
      return removedChildNodes;
    }
    function sliceChildNodes(startIndex, endIndex = Infinity) {
      const childNodes = this.childNodes.slice(startIndex, endIndex);
      return childNodes;
    }
    function getAncestorNodes() {
      const ancestorNodes = [];
      let ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        ancestorNodes.push(ancestorNode);
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
      }
      return ancestorNodes;
    }
    function mapAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.map(callback);
    }
    function someAncestorNode(callback) {
      let result = false;
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        result = !!callback(ancestorNode, index);
        if (result) {
          break;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      return result;
    }
    function findAncestorNode(callback) {
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        const result = callback(ancestorNode, index);
        if (result) {
          return ancestorNode;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      ancestorNode = void 0;
      return ancestorNode;
    }
    function everyAncestorNode(callback) {
      let result = true;
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        result = !!callback(ancestorNode, index);
        if (!result) {
          break;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      return result;
    }
    function filterAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.filter(callback);
    }
    function reduceAncestorNode(callback, initialValue) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.reduce(callback, initialValue);
    }
    function forEachAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      ancestorNodes.forEach(callback);
    }
    function getDescendantNodes(descendantNodes = []) {
      push(descendantNodes, this.childNodes);
      this.forEachChildNode((childNode) => {
        childNode.getDescendantNodes(descendantNodes);
      });
      return descendantNodes;
    }
    function mapDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.map(callback);
    }
    function someDescendantNode(callback) {
      let result = false;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        const childNode = this.childNodes[index], descendantNode = childNode;
        result = !!callback(descendantNode);
        if (result) {
          break;
        }
        result = childNode.someDescendantNode(callback);
        if (result) {
          break;
        }
      }
      return result;
    }
    function findDescendantNode(callback) {
      let descendantNode = void 0;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        let result;
        const childNode = this.childNodes[index];
        descendantNode = childNode;
        result = callback(descendantNode);
        if (result) {
          break;
        }
        descendantNode = childNode.findDescendantNode(callback);
        if (descendantNode !== void 0) {
          break;
        }
      }
      return descendantNode;
    }
    function everyDescendantNode(callback) {
      let result = true;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        const childNode = this.childNodes[index], descendantNode = childNode;
        result = !!callback(descendantNode);
        if (!result) {
          break;
        }
        result = childNode.everyDescendantNode(callback);
        if (!result) {
          break;
        }
      }
      return result;
    }
    function filterDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.filter(callback);
    }
    function reduceDescendantNode(callback, initialValue) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.reduce(callback, initialValue);
    }
    function forEachDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      descendantNodes.forEach(callback);
    }
    var nodeMixins = {
      getMultiplicity,
      mapChildNode,
      someChildNode,
      findChildNode,
      everyChildNode,
      filterChildNode,
      reduceChildNode,
      forEachChildNode,
      forwardsSomeChildNode,
      backwardsSomeChildNode,
      indexOfChildNode,
      setChildNodesParentNode,
      resetChildNodesParentNode,
      addChildNode,
      addChildNodes,
      removeChildNode,
      removeChildNodes,
      replaceChildNode,
      replaceChildNodes,
      appendChildNode,
      appendChildNodes,
      prependChildNode,
      prependChildNodes,
      spliceChildNodes,
      sliceChildNodes,
      getAncestorNodes,
      mapAncestorNode,
      someAncestorNode,
      findAncestorNode,
      everyAncestorNode,
      filterAncestorNode,
      reduceAncestorNode,
      forEachAncestorNode,
      getDescendantNodes,
      mapDescendantNode,
      someDescendantNode,
      findDescendantNode,
      everyDescendantNode,
      filterDescendantNode,
      reduceDescendantNode,
      forEachDescendantNode
    };
    var _default = nodeMixins;
  });

  // node_modules/occam-parsers/lib/parseTree.js
  var require_parseTree = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParseTree;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {last} = _necessary.arrayUtilities;
    var {NEW_LINE_CHARACTER, SPACE_CHARACTER} = _necessary.characters;
    var ParseTree = class {
      constructor(lines) {
        this.lines = lines;
      }
      clone() {
        const lines = this.lines.slice(), parseTree = new ParseTree(lines);
        return parseTree;
      }
      getWidth() {
        let width;
        let linesLength = this.lines.length;
        if (linesLength === 0) {
          width = 0;
        } else {
          const lastLine = last(this.lines), lastLineLength = lastLine.length;
          width = lastLineLength;
        }
        return width;
      }
      getDepth() {
        const linesLength = this.lines.length, depth = linesLength;
        return depth;
      }
      forEachLine(callback) {
        this.lines.forEach(callback);
      }
      appendToTop(parseTree) {
        parseTree.forEachLine((line) => {
          this.lines.unshift(line);
        });
      }
      appendToLeft(parseTree) {
        parseTree.forEachLine((line, index) => {
          this.lines[index] = line + this.lines[index];
        });
      }
      appendToRight(parseTree) {
        parseTree.forEachLine((line, index) => {
          this.lines[index] = this.lines[index] + line;
        });
      }
      appendToBottom(parseTree) {
        parseTree.forEachLine((line) => {
          this.lines.push(line);
        });
      }
      addTopMargin(topMarginDepth) {
        const width = this.getWidth(), topMarginWidth = width, topMarginString = marginStringFromMarginWidth(topMarginWidth);
        for (let index = 0; index < topMarginDepth; index++) {
          this.lines.unshift(topMarginString);
        }
      }
      addLeftMargin(leftMarginWidth) {
        const leftMarginString = marginStringFromMarginWidth(leftMarginWidth), linesLength = this.lines.length;
        for (let index = 0; index < linesLength; index++) {
          this.lines[index] = leftMarginString + this.lines[index];
        }
      }
      addRightMargin(rightMarginWidth) {
        const rightMarginString = marginStringFromMarginWidth(rightMarginWidth), linesLength = this.lines.length;
        for (let index = 0; index < linesLength; index++) {
          this.lines[index] = this.lines[index] + rightMarginString;
        }
      }
      addBottomMargin(bottomMarginDepth) {
        const width = this.getWidth(), bottomMarginWidth = width, bottomMarginString = marginStringFromMarginWidth(bottomMarginWidth);
        for (let index = 0; index < bottomMarginDepth; index++) {
          this.lines.push(bottomMarginString);
        }
      }
      popLine() {
        return this.lines.pop();
      }
      shiftLine() {
        return this.lines.shift();
      }
      pushLine(line) {
        this.lines.push(line);
      }
      unshiftLine(line) {
        this.lines.unshift(line);
      }
      asString() {
        const string = this.lines.reduce((string2, line) => {
          string2 += line + NEW_LINE_CHARACTER;
          return string2;
        }, _constants.EMPTY_STRING);
        return string;
      }
    };
    function marginStringFromMarginWidth(marginWidth, spaceCharacter) {
      spaceCharacter = spaceCharacter || SPACE_CHARACTER;
      let marginString = _constants.EMPTY_STRING;
      for (let index = 0; index < marginWidth; index++) {
        marginString += spaceCharacter;
      }
      return marginString;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/verticalBranch.js
  var require_verticalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VerticalBranchParseTree;
      }
    });
    var _necessary = require_browser();
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {BAR_CHARACTER} = _necessary.characters;
    var VerticalBranchParseTree = class extends _parseTree.default {
      constructor(lines, verticalBranchPosition) {
        super(lines);
        this.verticalBranchPosition = verticalBranchPosition;
      }
      getVerticalBranchPosition() {
        return this.verticalBranchPosition;
      }
      addLeftMargin(leftMarginWidth) {
        super.addLeftMargin(leftMarginWidth);
        this.verticalBranchPosition += leftMarginWidth;
      }
      static fromWidth(width) {
        const string = BAR_CHARACTER, verticalBranchPosition = 0, verticalBranchParseTree = VerticalBranchParseTree.fromStringAndVerticalBranchPosition(VerticalBranchParseTree, string, verticalBranchPosition), leftMarginWidth = Math.floor(width / 2), rightMarginWidth = width - leftMarginWidth - 1;
        verticalBranchParseTree.addLeftMargin(leftMarginWidth);
        verticalBranchParseTree.addRightMargin(rightMarginWidth);
        return verticalBranchParseTree;
      }
      static fromDepthAndVerticalBranchPosition(Class, depth, verticalBranchPosition) {
        const lines = linesFromDepth(depth), verticalBranchParseTree = new Class(lines, verticalBranchPosition);
        return verticalBranchParseTree;
      }
      static fromStringAndVerticalBranchPosition(Class, string, verticalBranchPosition) {
        if (verticalBranchPosition === void 0) {
          verticalBranchPosition = string;
          string = Class;
          Class = _parseTree.default;
        }
        const line = string, lines = [
          line
        ], verticalBranchParseTree = new Class(lines, verticalBranchPosition);
        return verticalBranchParseTree;
      }
    };
    function linesFromDepth(depth) {
      const lines = [];
      let index = 0;
      while (index < depth) {
        lines[index++] = _constants.EMPTY_STRING;
      }
      return lines;
    }
  });

  // node_modules/occam-parsers/lib/utilities/tokens.js
  var require_tokens = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lineIndexFromTokenIndexAndTokens", {
      enumerable: true,
      get: function() {
        return lineIndexFromTokenIndexAndTokens;
      }
    });
    function lineIndexFromTokenIndexAndTokens(tokenIndex, tokens) {
      let lineIndex = null;
      if (tokenIndex !== null) {
        lineIndex = 0;
        const start = 0, end = tokenIndex;
        tokens = tokens.slice(start, end);
        tokens.forEach((token) => {
          const tokenEndOfLineToken = token.isEndOfLineToken();
          if (tokenEndOfLineToken) {
            lineIndex++;
          }
        });
      }
      return lineIndex;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/ruleName.js
  var require_ruleName = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _constants = require_constants4();
    var _tokens = require_tokens();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {SPACE_CHARACTER} = _necessary.characters;
    var RuleNameParseTree = class extends _verticalBranch.default {
      static fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
        const ruleName = nonTerminalNode.getRuleName(), opacity = nonTerminalNode.getOpacity(), firstSignificantTokenIndex = nonTerminalNode.getFirstSignificantTokenIndex(tokens), lastSignificantTokenIndex = nonTerminalNode.getLastSignificantTokenIndex(tokens), firstLineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(firstSignificantTokenIndex, tokens), lastLineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(lastSignificantTokenIndex, tokens);
        let lineIndexes;
        if (firstLineIndex === lastLineIndex) {
          const lineIndex = firstLineIndex;
          if (lineIndex === null) {
            lineIndexes = _constants.EMPTY_STRING;
          } else {
            lineIndexes = ` [${lineIndex}]`;
          }
        } else {
          if (false) {
          } else if (firstLineIndex === null) {
            lineIndexes = ` [${lastLineIndex}]`;
          } else if (lastLineIndex === null) {
            lineIndexes = ` [${firstLineIndex}]`;
          } else {
            lineIndexes = ` [${firstLineIndex}-${lastLineIndex}]`;
          }
        }
        let string = `${ruleName}`;
        if (opacity !== null) {
          string = `${string}${opacity}`;
        }
        string = `${string}${lineIndexes}`;
        let precedence = nonTerminalNode.getPrecedence();
        if (precedence !== null) {
          if (precedence === Infinity) {
            precedence = SPACE_CHARACTER;
          }
          string = `${string} (${precedence})`;
        }
        const stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), ruleNameParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(RuleNameParseTree, string, verticalBranchPosition);
        ruleNameParseTree.appendToTop(verticalBranchParseTree);
        return ruleNameParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/horizontalBranch.js
  var require_horizontalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return HorizontalBranchParseTree;
      }
    });
    var _necessary = require_browser();
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {DASH_CHARACTER} = _necessary.characters;
    var HorizontalBranchParseTree = class extends _parseTree.default {
      static fromWidth(width) {
        const string = stringFromCharactersWidth(width, DASH_CHARACTER), line = string, lines = [
          line
        ], horizontalBranchParseTree = new HorizontalBranchParseTree(lines);
        return horizontalBranchParseTree;
      }
    };
    function stringFromCharactersWidth(charactersWidth, character) {
      let string = _constants.EMPTY_STRING;
      for (let index = 0; index < charactersWidth; index++) {
        string += character;
      }
      return string;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/childNodes.js
  var require_childNodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChildNodesParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _horizontalBranch = /* @__PURE__ */ _interop_require_default(require_horizontalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var ChildNodesParseTree = class extends _verticalBranch.default {
      static fromChildNodesAndTokens(childNodes, tokens) {
        let childNodesParseTree = null;
        const childNodesLength = childNodes.length;
        if (childNodesLength > 0) {
          const childNodeParseTrees = childNodes.reduce((childNodeParseTrees2, childNode) => {
            const childNodeParseTree = childNode.asParseTree(tokens);
            childNodeParseTrees2.push(childNodeParseTree);
            return childNodeParseTrees2;
          }, []), childNodeParseTreesLength = childNodeParseTrees.length;
          if (childNodeParseTreesLength === 1) {
            const firstChildNodeParseTree = first2(childNodeParseTrees);
            childNodesParseTree = firstChildNodeParseTree;
          } else {
            let firstVerticalBranchPosition, lastVerticalBranchPosition = 0, childNodeParseTreesWidth = 0, childNodeParseTreesDepth = 0;
            childNodeParseTrees.forEach((childNodeParseTree, index) => {
              const childNodeParseTreeWidth = childNodeParseTree.getWidth(), childNodeParseTreeDepth = childNodeParseTree.getDepth();
              if (index === 0) {
                const firstChildNodeParseTree = childNodeParseTree, firstChildNodeParseTreeVerticalBranchPosition = firstChildNodeParseTree.getVerticalBranchPosition();
                firstVerticalBranchPosition = firstChildNodeParseTreeVerticalBranchPosition;
              }
              if (index === childNodeParseTreesLength - 1) {
                const lastChildNodeParseTree = childNodeParseTree, lastChildNodeParseTreeVerticalBranchPosition = lastChildNodeParseTree.getVerticalBranchPosition();
                lastVerticalBranchPosition += lastChildNodeParseTreeVerticalBranchPosition;
              }
              if (index < childNodeParseTreesLength - 1) {
                lastVerticalBranchPosition += childNodeParseTreeWidth;
                lastVerticalBranchPosition += 1;
                childNodeParseTreesWidth += 1;
              }
              childNodeParseTreesWidth += childNodeParseTreeWidth;
              childNodeParseTreesDepth = Math.max(childNodeParseTreesDepth, childNodeParseTreeDepth);
            });
            const width = lastVerticalBranchPosition - firstVerticalBranchPosition + 1, verticalBranchParseTree = _verticalBranch.default.fromWidth(width), horizontalBranchParseTree = _horizontalBranch.default.fromWidth(width), leftMarginWidth = firstVerticalBranchPosition, rightMarginWidth = childNodeParseTreesWidth - width - leftMarginWidth;
            verticalBranchParseTree.addLeftMargin(leftMarginWidth);
            verticalBranchParseTree.addRightMargin(rightMarginWidth);
            horizontalBranchParseTree.addLeftMargin(leftMarginWidth);
            horizontalBranchParseTree.addRightMargin(rightMarginWidth);
            const verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), depth = childNodeParseTreesDepth;
            childNodesParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(ChildNodesParseTree, depth, verticalBranchPosition);
            childNodeParseTrees.forEach((childNodeParseTree, index) => {
              const childNodeParseTreeDepth = childNodeParseTree.getDepth(), clonedChildNodeParseTree = childNodeParseTree.clone();
              if (index < childNodeParseTreesLength - 1) {
                const rightMarginWidth2 = 1;
                clonedChildNodeParseTree.addRightMargin(rightMarginWidth2);
              }
              if (childNodeParseTreeDepth < childNodeParseTreesDepth) {
                const bottomMarginDepth = childNodeParseTreesDepth - childNodeParseTreeDepth;
                clonedChildNodeParseTree.addBottomMargin(bottomMarginDepth);
              }
              childNodesParseTree.appendToRight(clonedChildNodeParseTree);
            });
            childNodesParseTree.appendToTop(horizontalBranchParseTree);
            childNodesParseTree.appendToTop(verticalBranchParseTree);
          }
        }
        return childNodesParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/nonTerminalNode.js
  var require_nonTerminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNodeParseTree;
      }
    });
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName());
    var _childNodes = /* @__PURE__ */ _interop_require_default(require_childNodes());
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeParseTree = class extends _verticalBranch.default {
      static fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
        let nonTerminalNodeParseTree;
        const childNodes = nonTerminalNode.getChildNodes(), ruleNameParseTree = _ruleName.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), childNodesParseTree = _childNodes.default.fromChildNodesAndTokens(childNodes, tokens);
        if (childNodesParseTree === null) {
          const ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition(), verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, depth = ruleNameParseTreeDepth;
          nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree, depth, verticalBranchPosition);
          nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
        } else {
          let ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
          const childNodesParseTreeVerticalBranchPosition = childNodesParseTree.getVerticalBranchPosition(), verticalBranchPositionsDifference = ruleNameParseTreeVerticalBranchPosition - childNodesParseTreeVerticalBranchPosition;
          let leftMarginWidth;
          if (false) {
          } else if (verticalBranchPositionsDifference < 0) {
            leftMarginWidth = -verticalBranchPositionsDifference;
            ruleNameParseTree.addLeftMargin(leftMarginWidth);
          } else if (verticalBranchPositionsDifference > 0) {
            leftMarginWidth = +verticalBranchPositionsDifference;
            childNodesParseTree.addLeftMargin(leftMarginWidth);
          }
          const ruleNameParseTreeWidth = ruleNameParseTree.getWidth(), childNodesParseTreeWidth = childNodesParseTree.getWidth(), widthsDifference = ruleNameParseTreeWidth - childNodesParseTreeWidth;
          let rightMarginWidth;
          if (false) {
          } else if (widthsDifference < 0) {
            rightMarginWidth = -widthsDifference;
            ruleNameParseTree.addRightMargin(rightMarginWidth);
          } else if (widthsDifference > 0) {
            rightMarginWidth = +widthsDifference;
            childNodesParseTree.addRightMargin(rightMarginWidth);
          }
          ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
          const ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, depth = ruleNameParseTreeDepth;
          nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree, depth, verticalBranchPosition);
          nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
          nonTerminalNodeParseTree.appendToBottom(childNodesParseTree);
        }
        return nonTerminalNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/nonTerminal.js
  var require_nonTerminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNode;
      }
    });
    var _necessary = require_browser();
    var _occamlexers = require_lib3();
    var _node = /* @__PURE__ */ _interop_require_default(require_node());
    var _nonTerminalNode = /* @__PURE__ */ _interop_require_default(require_nonTerminalNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, match} = _necessary.arrayUtilities;
    var {opaque: opaqueSpecialSymbol, semiOpaque: semiOpaqueSpecialSymbol} = _occamlexers.specialSymbols;
    var NonTerminalNode = class {
      constructor(ruleName, parentNode, childNodes, opacity, precedence) {
        this.ruleName = ruleName;
        this.parentNode = parentNode;
        this.childNodes = childNodes;
        this.opacity = opacity;
        this.precedence = precedence;
      }
      getRuleName() {
        return this.ruleName;
      }
      getParentNode() {
        return this.parentNode;
      }
      getChildNodes() {
        return this.childNodes;
      }
      getOpacity() {
        return this.opacity;
      }
      getPrecedence() {
        return this.precedence;
      }
      setRuleName(ruleName) {
        this.ruleName = ruleName;
      }
      setParentNode(parentNode) {
        this.parentNode = parentNode;
      }
      setChildNodes(childNodes) {
        const startIndex = 0, deleteCount = Infinity, addedChildNodes = childNodes;
        this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      setPrecedence(precedence) {
        this.precedence = precedence;
      }
      isOpaque() {
        const opaque = this.opacity === opaqueSpecialSymbol;
        return opaque;
      }
      isSemiOpaque() {
        const semiOpaque = this.opacity === semiOpaqueSpecialSymbol;
        return semiOpaque;
      }
      isTransparent() {
        const semiOpaque = this.opacity === null;
        return semiOpaque;
      }
      isTerminalNode() {
        const terminalNode = false;
        return terminalNode;
      }
      isNonTerminalNode() {
        const nonTerminalNode = true;
        return nonTerminalNode;
      }
      getDescendantNodes(descendantNodes) {
        return descendantNodes;
      }
      getFirstSignificantTokenIndex(tokens) {
        let firstSignificantTokenIndex;
        this.forwardsSomeChildNode((childNode) => {
          const node = childNode;
          firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens);
          if (firstSignificantTokenIndex !== null) {
            return true;
          }
        });
        return firstSignificantTokenIndex;
      }
      getLastSignificantTokenIndex(tokens) {
        let lastSignificantTokenIndex;
        this.backwardsSomeChildNode((childNode) => {
          const node = childNode;
          lastSignificantTokenIndex = node.getLastSignificantTokenIndex(tokens);
          if (lastSignificantTokenIndex !== null) {
            return true;
          }
        });
        return lastSignificantTokenIndex;
      }
      getSignificantTokens(significantTokens = []) {
        this.childNodes.forEach((childNode) => {
          childNode.getSignificantTokens(significantTokens);
        });
        return significantTokens;
      }
      getMultiplicity() {
        const childNodesLength = this.childNodes.length, multiplicity = childNodesLength;
        return multiplicity;
      }
      isEmpty() {
        const multiplicity = this.getMultiplicity(), empty = multiplicity === 0;
        return empty;
      }
      isSingular() {
        const multiplicity = this.getMultiplicity(), singular = multiplicity === 1;
        return singular;
      }
      isLowerPrecedence(ruleName, precedence) {
        let lowerPrecedence;
        if (false) {
        } else if (this.precedence === null) {
          lowerPrecedence = false;
        } else if (this.precedence === Infinity) {
          const firstChildNode = first2(this.childNodes);
          lowerPrecedence = firstChildNode.isLowerPrecedence(ruleName, precedence);
        } else {
          lowerPrecedence = this.ruleName === ruleName && this.precedence < precedence;
        }
        return lowerPrecedence;
      }
      isUnprecedented() {
        let unprecedented = false;
        if (this.precedence !== null) {
          unprecedented = this.childNodes.some((childNode) => {
            const childNodeLowerPrecedence = childNode.isLowerPrecedence(this.ruleName, this.precedence);
            if (childNodeLowerPrecedence) {
              return true;
            }
          });
        }
        return unprecedented;
      }
      asParseTree(tokens) {
        const nonTerminalNode = this, nonTerminalNodeParseTree = _nonTerminalNode.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), parseTree = nonTerminalNodeParseTree;
        return parseTree;
      }
      match(node, depth = Infinity, exactly = false) {
        let matches = false;
        const nodeNonTerminalNode = node.isNonTerminalNode();
        if (nodeNonTerminalNode) {
          const nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
          if (this.ruleName === nonTerminalNodeRuleName) {
            const nonTerminalNodeOpacity = nonTerminalNode.getOpacity();
            if (this.opacity === nonTerminalNodeOpacity) {
              const precedence = this.getPrecedence(), nonTerminalNodePrecedence = nonTerminalNode.getPrecedence();
              if (precedence === nonTerminalNodePrecedence) {
                depth--;
                if (depth === 0) {
                  matches = true;
                } else {
                  const nonTerminalNodeChildNodes = nonTerminalNode.getChildNodes();
                  matches = match(this.childNodes, nonTerminalNodeChildNodes, (childNode, nonTerminalNodeChildNode) => {
                    const childNodeMatchesNonTerminalNodeChildNode = childNode.match(nonTerminalNodeChildNode, depth, exactly);
                    if (childNodeMatchesNonTerminalNodeChildNode) {
                      return true;
                    }
                  });
                }
              }
            }
          }
        }
        return matches;
      }
      rewrite(state) {
        const rewrittenNonTerminalNode = null;
        return rewrittenNonTerminalNode;
      }
      destroy() {
        this.forEachChildNode((childNode) => {
          childNode.destroy();
        });
        this.parentNode = null;
        this.childNodes = null;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, parentNode = null, ruleName = this.ruleName, childNodes = cloneChildNodes(this.childNodes), opacity = this.opacity, precedence = this.precedence, nonTerminalNode = new Class(ruleName, parentNode, childNodes, opacity, precedence, ...remainingArguments);
        nonTerminalNode.setChildNodesParentNode();
        return nonTerminalNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence, ...remainingArguments) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = NonTerminalNode;
        }
        const parentNode = null, nonTerminalNode = new Class(ruleName, parentNode, childNodes, opacity, precedence, ...remainingArguments);
        nonTerminalNode.setChildNodesParentNode();
        return nonTerminalNode;
      }
    };
    Object.assign(NonTerminalNode.prototype, _node.default);
    function cloneChildNodes(childNodes) {
      childNodes = childNodes.map((childNode) => {
        childNode = childNode.clone();
        return childNode;
      });
      return childNodes;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal.js
  var require_nonTerminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPart;
      }
    });
    var NonTerminalPart = class {
      constructor(type, callAhead) {
        this.type = type;
        this.callAhead = callAhead;
      }
      getType() {
        return this.type;
      }
      isCallAhead() {
        return this.callAhead;
      }
      isNonTerminalPart() {
        const nonTerminalPart = true;
        return nonTerminalPart;
      }
      isTerminalPart() {
        const terminalPart = false;
        return terminalPart;
      }
      isRuleNamePart() {
        const ruleNamePart = false;
        return ruleNamePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/partTypes.js
  var require_partTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ChoiceOfPartsPartType() {
        return ChoiceOfPartsPartType;
      },
      get OneOrMorePartsPartType() {
        return OneOrMorePartsPartType;
      },
      get OptionalPartPartType() {
        return OptionalPartPartType;
      },
      get RuleNamePartType() {
        return RuleNamePartType;
      },
      get SequenceOfPartsPartType() {
        return SequenceOfPartsPartType;
      },
      get ZeroOrMorePartsPartType() {
        return ZeroOrMorePartsPartType;
      },
      get default() {
        return _default;
      }
    });
    var RuleNamePartType = "ruleNamePart";
    var OptionalPartPartType = "optionalPart";
    var ChoiceOfPartsPartType = "choiceOfParts";
    var OneOrMorePartsPartType = "oneOrMoreParts";
    var ZeroOrMorePartsPartType = "zeroOrMoreParts";
    var SequenceOfPartsPartType = "sequenceOfParts";
    var _default = {
      RuleNamePartType,
      OptionalPartPartType,
      ChoiceOfPartsPartType,
      OneOrMorePartsPartType,
      ZeroOrMorePartsPartType,
      SequenceOfPartsPartType
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/optionalPart.js
  var require_optionalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return OptionalPartPart;
      },
      get parseOptionalPart() {
        return parseOptionalPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {questionMark} = _occamlexers.specialSymbols;
    var OptionalPartPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseOptionalPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${questionMark}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.OptionalPartPartType, callAhead = false, optionalPartPart = new OptionalPartPart(type, callAhead, part);
        return optionalPartPart;
      }
    };
    function parseOptionalPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        parsed = true;
      } else {
        parsed = callAhead();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback, callAhead);
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/zeroOrMoreParts.js
  var require_zeroOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return ZeroOrMorePartsPart;
      },
      get parseZeroOrMorePartsPart() {
        return parseZeroOrMorePartsPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asterisk} = _occamlexers.specialSymbols;
    var ZeroOrMorePartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseZeroOrMorePartsPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${asterisk}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.ZeroOrMorePartsPartType, callAhead = false, zeroOrMorePartsPart = new ZeroOrMorePartsPart(type, callAhead, part);
        return zeroOrMorePartsPart;
      }
    };
    function parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        if (parsed) {
          parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead);
        }
        parsed = true;
      } else {
        parsed = callAhead();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback, () => {
            let parsed2;
            parsed2 = parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead);
            return parsed2;
          });
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/oneOrMoreParts.js
  var require_oneOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return OneOrMorePartsPart;
      },
      get parseOneOrMorePartsPart() {
        return parseOneOrMorePartsPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    var _zeroOrMoreParts = require_zeroOrMoreParts();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {plus} = _occamlexers.specialSymbols;
    var OneOrMorePartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseOneOrMorePartsPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${plus}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.OneOrMorePartsPartType, callAhead = false, oneOrMorePartsPart = new OneOrMorePartsPart(type, callAhead, part);
        return oneOrMorePartsPart;
      }
    };
    function parseOneOrMorePartsPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        if (parsed) {
          (0, _zeroOrMoreParts.parseZeroOrMorePartsPart)(part, nodes, state, callback, callAhead);
        }
      } else {
        parsed = part.parse(nodes, state, callback, () => {
          let parsed2;
          parsed2 = (0, _zeroOrMoreParts.parseZeroOrMorePartsPart)(part, nodes, state, callback, callAhead);
          return parsed2;
        });
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/ruleNames.js
  var require_ruleNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CALL_AHEAD_MODIFIER_RULE_NAME() {
        return CALL_AHEAD_MODIFIER_RULE_NAME;
      },
      get CHOICE_OF_PARTS_RULE_NAME() {
        return CHOICE_OF_PARTS_RULE_NAME;
      },
      get DEFINITIONS_RULE_NAME() {
        return DEFINITIONS_RULE_NAME;
      },
      get DEFINITION_RULE_NAME() {
        return DEFINITION_RULE_NAME;
      },
      get DOCUMENT_RULE_NAME() {
        return DOCUMENT_RULE_NAME;
      },
      get END_OF_LINE_RULE_NAME() {
        return END_OF_LINE_RULE_NAME;
      },
      get EPSILON_RULE_NAME() {
        return EPSILON_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get NAME_RULE_NAME() {
        return NAME_RULE_NAME;
      },
      get NON_TERMINAL_PART_RULE_NAME() {
        return NON_TERMINAL_PART_RULE_NAME;
      },
      get NO_WHITESPACE_PART_RULE_NAME() {
        return NO_WHITESPACE_PART_RULE_NAME;
      },
      get ONE_OR_MORE_QUANTIFIER_RULE_NAME() {
        return ONE_OR_MORE_QUANTIFIER_RULE_NAME;
      },
      get OPACITY_MODIFIER_RULE_NAME() {
        return OPACITY_MODIFIER_RULE_NAME;
      },
      get OPTIONAL_QUANTIFIER_RULE_NAME() {
        return OPTIONAL_QUANTIFIER_RULE_NAME;
      },
      get PART_CHOICE_RULE_NAME() {
        return PART_CHOICE_RULE_NAME;
      },
      get PART_RULE_NAME() {
        return PART_RULE_NAME;
      },
      get PRECEDENCE_RULE_NAME() {
        return PRECEDENCE_RULE_NAME;
      },
      get QUANTIFIER_RULE_NAME() {
        return QUANTIFIER_RULE_NAME;
      },
      get REGULAR_EXPRESSION_RULE_NAME() {
        return REGULAR_EXPRESSION_RULE_NAME;
      },
      get RULE_NAME_RULE_NAME() {
        return RULE_NAME_RULE_NAME;
      },
      get RULE_RULE_NAME() {
        return RULE_RULE_NAME;
      },
      get SEQUENCE_OF_PARTS_RULE_NAME() {
        return SEQUENCE_OF_PARTS_RULE_NAME;
      },
      get SIGNIFICANT_TOKEN_TYPE_RULE_NAME() {
        return SIGNIFICANT_TOKEN_TYPE_RULE_NAME;
      },
      get START_OF_CONTENT_PART_RULE_NAME() {
        return START_OF_CONTENT_PART_RULE_NAME;
      },
      get STRING_LITERAL_RULE_NAME() {
        return STRING_LITERAL_RULE_NAME;
      },
      get TERMINAL_PART_RULE_NAME() {
        return TERMINAL_PART_RULE_NAME;
      },
      get WILDCARD_RULE_NAME() {
        return WILDCARD_RULE_NAME;
      },
      get ZERO_OR_MORE_QUANTIFIER_RULE_NAME() {
        return ZERO_OR_MORE_QUANTIFIER_RULE_NAME;
      }
    });
    var NAME_RULE_NAME = "name";
    var PART_RULE_NAME = "part";
    var RULE_RULE_NAME = "rule";
    var ERROR_RULE_NAME = "error";
    var EPSILON_RULE_NAME = "epsilon";
    var DOCUMENT_RULE_NAME = "document";
    var WILDCARD_RULE_NAME = "wildcard";
    var RULE_NAME_RULE_NAME = "ruleName";
    var DEFINITION_RULE_NAME = "definition";
    var PRECEDENCE_RULE_NAME = "precedence";
    var QUANTIFIER_RULE_NAME = "quantifier";
    var END_OF_LINE_RULE_NAME = "endOfLine";
    var PART_CHOICE_RULE_NAME = "partChoice";
    var DEFINITIONS_RULE_NAME = "definitions";
    var TERMINAL_PART_RULE_NAME = "terminalPart";
    var STRING_LITERAL_RULE_NAME = "stringLiteral";
    var CHOICE_OF_PARTS_RULE_NAME = "choiceOfParts";
    var OPACITY_MODIFIER_RULE_NAME = "opacityModifier";
    var NON_TERMINAL_PART_RULE_NAME = "nonTerminalPart";
    var SEQUENCE_OF_PARTS_RULE_NAME = "sequenceOfParts";
    var NO_WHITESPACE_PART_RULE_NAME = "noWhitespace";
    var REGULAR_EXPRESSION_RULE_NAME = "regularExpression";
    var CALL_AHEAD_MODIFIER_RULE_NAME = "callAheadModifier";
    var OPTIONAL_QUANTIFIER_RULE_NAME = "optionalQuantifier";
    var START_OF_CONTENT_PART_RULE_NAME = "startOfContent";
    var SIGNIFICANT_TOKEN_TYPE_RULE_NAME = "significantTokenType";
    var ONE_OR_MORE_QUANTIFIER_RULE_NAME = "oneOrMoreQuantifier";
    var ZERO_OR_MORE_QUANTIFIER_RULE_NAME = "zeroOrMoreQuantifier";
  });

  // node_modules/occam-parsers/lib/utilities/bnf.js
  var require_bnf2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isNodeCallAheadModifierNode() {
        return isNodeCallAheadModifierNode;
      },
      get isNodeChoiceNode() {
        return isNodeChoiceNode;
      },
      get isNodeQuantifierNode() {
        return isNodeQuantifierNode;
      },
      get isNodeRuleNameNode() {
        return isNodeRuleNameNode;
      },
      get ruleNameFromQuantifierNode() {
        return ruleNameFromQuantifierNode;
      }
    });
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames();
    var {first: first2} = _necessary.arrayUtilities;
    function isNodeChoiceNode(node) {
      let nodeNoChoiceNode = false;
      const nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        const terminalNode = node, terminalNodeContent = terminalNode.getContent();
        nodeNoChoiceNode = terminalNodeContent === "|";
      }
      return nodeNoChoiceNode;
    }
    function isNodeRuleNameNode(node) {
      let nodeRuleNameNode = false;
      const nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
        nodeRuleNameNode = nonTerminalNodeRuleName === _ruleNames.RULE_NAME_RULE_NAME;
      }
      return nodeRuleNameNode;
    }
    function isNodeQuantifierNode(node) {
      let nodeQuantifierNode = false;
      const nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameQuantifierRuleName = ruleName === _ruleNames.QUANTIFIER_RULE_NAME;
        nodeQuantifierNode = ruleNameQuantifierRuleName;
      }
      return nodeQuantifierNode;
    }
    function isNodeCallAheadModifierNode(node) {
      let nodeCallAheadModifierNode = false;
      const nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameCallAheadModifierRuleName = ruleName === _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME;
        nodeCallAheadModifierNode = ruleNameCallAheadModifierRuleName;
      }
      return nodeCallAheadModifierNode;
    }
    function ruleNameFromQuantifierNode(quantifierNode) {
      let nonTerminalNode;
      nonTerminalNode = quantifierNode;
      const childNodes = nonTerminalNode.getChildNodes(), firstChildNode = first2(childNodes);
      nonTerminalNode = firstChildNode;
      const ruleName = nonTerminalNode.getRuleName();
      return ruleName;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/part.js
  var require_part = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _bnf = require_bnf2();
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {last} = _necessary.arrayUtilities;
    var PartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = partFromNodes(nodes);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    function partFromNodes(nodes) {
      let part;
      const nodesLength = nodes.length;
      if (nodesLength === 1) {
        const node = nodes.pop(), callAhead = false;
        part = node.generatePart(callAhead);
      } else {
        const lastNodeQuantifierNode = isLastNodeQuantifierNode(nodes);
        if (lastNodeQuantifierNode) {
          const node = nodes.pop(), quantifierNode = node;
          part = partFromNodes(nodes);
          const ruleName = (0, _bnf.ruleNameFromQuantifierNode)(quantifierNode), collectionOfPartsPart = collectionOfPartsPartFromPartAndRuleName(part, ruleName);
          part = collectionOfPartsPart;
        } else {
          nodes.shift();
          part = partFromNodes(nodes);
        }
      }
      return part;
    }
    function isLastNodeQuantifierNode(nodes) {
      const lastNode = last(nodes), lastNodeQuantifierNode = (0, _bnf.isNodeQuantifierNode)(lastNode);
      return lastNodeQuantifierNode;
    }
    function collectionOfPartsPartFromPartAndRuleName(part, ruleName) {
      let collectionOfPartsPart;
      switch (ruleName) {
        case _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME:
          const optionalPartPart = _optionalPart.default.fromPart(part);
          collectionOfPartsPart = optionalPartPart;
          break;
        case _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME:
          const oneOrMorePartsPart = _oneOrMoreParts.default.fromPart(part);
          collectionOfPartsPart = oneOrMorePartsPart;
          break;
        case _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME:
          const zeroOrMorePartsPart = _zeroOrMoreParts.default.fromPart(part);
          collectionOfPartsPart = zeroOrMorePartsPart;
          break;
      }
      return collectionOfPartsPart;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/name.js
  var require_name2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var NameBNFNode = class extends _nonTerminal.default {
      getName() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), name = terminalNodeContent;
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NameBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/node.js
  var require_node2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeFromChildNodesAndRuleName() {
        return nodeFromChildNodesAndRuleName;
      },
      get nodesFromChildNodesAndRuleName() {
        return nodesFromChildNodesAndRuleName;
      }
    });
    function nodeFromChildNodesAndRuleName(childNodes, ruleName) {
      let node = null;
      childNodes.some((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode = childNode, nonTerminalNodeRuleName = nonTerminalNode.getRuleName(), nonTerminalNodeRuleNameRuleName = nonTerminalNodeRuleName === ruleName;
          if (nonTerminalNodeRuleNameRuleName) {
            node = childNode;
            return true;
          }
        }
      });
      return node;
    }
    function nodesFromChildNodesAndRuleName(childNodes, ruleName) {
      const nodes = childNodes.filter((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode = childNode, nonTerminalNodeRuleName = nonTerminalNode.getRuleName(), nonTerminalNodeRuleNameRuleName = nonTerminalNodeRuleName === ruleName;
          if (nonTerminalNodeRuleNameRuleName) {
            return true;
          }
        }
      });
      return nodes;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/rule.js
  var require_rule3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, secondLast} = _necessary.arrayUtilities;
    var RuleBNFNode = class extends _nonTerminal.default {
      generateRule(Rule) {
        const name = this.getName(), opacity = this.getOpacity(), definitions = this.generateDefinitions(), rule = Rule.fromNameOpacityAndDefinitions(name, opacity, definitions);
        return rule;
      }
      getOpacity() {
        let opacity = null;
        const ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME, childNodes = this.getChildNodes(), opacityModifierBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        if (opacityModifierBNFNode !== null) {
          opacity = opacityModifierBNFNode.getOpacity();
        }
        return opacity;
      }
      getName() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), nameBNFNode = firstChildNode, name = nameBNFNode.getName();
        return name;
      }
      generateDefinitions() {
        const childNodes = this.getChildNodes(), secondLastChildNode = secondLast(childNodes), definitionsBNFNode = secondLastChildNode, definitions = definitionsBNFNode.generateDefinitions();
        return definitions;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RuleBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/error.js
  var require_error = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ErrorBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ErrorBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal.js
  var require_terminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPart;
      }
    });
    var TerminalPart = class {
      isCallAhead() {
        const callAhead = false;
        return callAhead;
      }
      isNonTerminalPart() {
        const nonTerminalPart = false;
        return nonTerminalPart;
      }
      isTerminalPart() {
        const terminalPart = true;
        return terminalPart;
      }
      isNoWhitespacePart() {
        const noWhitespacePart = false;
        return noWhitespacePart;
      }
      isStartOfContentPart() {
        const startOfContentPart = false;
        return startOfContentPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/terminalNode.js
  var require_terminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalNodeParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _constants = require_constants4();
    var _tokens = require_tokens();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {NEW_LINE_CHARACTER, CARRIAGE_RETURN_CHARACTER} = _necessary.characters;
    var TerminalNodeParseTree = class extends _verticalBranch.default {
      static fromTerminalNodeAndTokens(terminalNode, tokens) {
        let content;
        content = terminalNode.getContent();
        content = content.replace(/[\r\n]/g, (match) => {
          switch (match) {
            case CARRIAGE_RETURN_CHARACTER:
              return "\\r";
            case NEW_LINE_CHARACTER:
              return "\\n";
            default:
              return match;
          }
        });
        const type = terminalNode.getType(), significantTokenIndex = terminalNode.getSignificantTokenIndex(tokens), lineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(significantTokenIndex, tokens);
        let lineIndexes;
        if (lineIndex === null) {
          lineIndexes = _constants.EMPTY_STRING;
        } else {
          lineIndexes = ` [${lineIndex}]`;
        }
        const string = `"${content}"[${type}]${lineIndexes}`, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(TerminalNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        return terminalNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal.js
  var require_terminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalNode;
      }
    });
    var _terminalNode = /* @__PURE__ */ _interop_require_default(require_terminalNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalNode = class {
      constructor(parentNode, significantToken) {
        this.parentNode = parentNode;
        this.significantToken = significantToken;
      }
      getParentNode() {
        return this.parentNode;
      }
      getSignificantToken() {
        return this.significantToken;
      }
      setParentNode(parentNode) {
        this.parentNode = parentNode;
      }
      setSignificantToken(significantToken) {
        this.significantToken = significantToken;
      }
      isStartOfContentNode() {
        const startOfContentNode = false;
        return startOfContentNode;
      }
      isNoWhitespaceNode() {
        const noWhitespaceNode = false;
        return noWhitespaceNode;
      }
      isEpsilonNode() {
        const epsilonNode = false;
        return epsilonNode;
      }
      isTerminalNode() {
        const terminalNode = true;
        return terminalNode;
      }
      isNonTerminalNode() {
        const nonTerminalNode = false;
        return nonTerminalNode;
      }
      getType() {
        return this.significantToken.getType();
      }
      getContent() {
        return this.significantToken.getContent();
      }
      getPrecedence() {
        const precedence = null;
        return precedence;
      }
      isLowerPrecedence(parentRuleName, parentPrecedence) {
        const lowerPrecedence = false;
        return lowerPrecedence;
      }
      getFirstSignificantTokenIndex(tokens) {
        const significantTokenIndex = this.getSignificantTokenIndex(tokens), firstSignificantTokenIndex = significantTokenIndex;
        return firstSignificantTokenIndex;
      }
      getLastSignificantTokenIndex(tokens) {
        const significantTokenIndex = this.getSignificantTokenIndex(tokens), lastSignificantTokenIndex = significantTokenIndex;
        return lastSignificantTokenIndex;
      }
      getSignificantTokenIndex(tokens) {
        let significantTokenIndex = null;
        if (this.significantToken !== null) {
          significantTokenIndex = tokens.indexOf(this.significantToken);
        }
        return significantTokenIndex;
      }
      getSignificantTokens(significantTokens = []) {
        if (this.significantToken !== null) {
          significantTokens.push(this.significantToken);
        }
        return significantTokens;
      }
      getAncestorNodes() {
        const ancestorNodes = [];
        let ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          ancestorNodes.push(ancestorNode);
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
        }
        return ancestorNodes;
      }
      mapAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.map(callback);
      }
      someAncestorNode(callback) {
        let result = false;
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          result = !!callback(ancestorNode, index);
          if (result) {
            break;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        return result;
      }
      findAncestorNode(callback) {
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          const result = callback(ancestorNode, index);
          if (result) {
            return ancestorNode;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        ancestorNode = void 0;
        return ancestorNode;
      }
      everyAncestorNode(callback) {
        let result = true;
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          result = !!callback(ancestorNode, index);
          if (!result) {
            break;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        return result;
      }
      filterAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.filter(callback);
      }
      reduceAncestorNode(callback, initialValue) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.reduce(callback, initialValue);
      }
      forEachAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        ancestorNodes.forEach(callback);
      }
      getDescendantNodes(descendantNodes = []) {
        return descendantNodes;
      }
      someDescendantNode(callback) {
        const result = false;
        return result;
      }
      findDescendantNode(callback) {
        let descendantNode = void 0;
        return descendantNode;
      }
      everyDescendantNode(callback) {
        let result = true;
        return result;
      }
      asParseTree(tokens) {
        const terminalNode = this, terminalNodeParseTree = _terminalNode.default.fromTerminalNodeAndTokens(terminalNode, tokens), parseTree = terminalNodeParseTree;
        return parseTree;
      }
      match(node, depth = Infinity, exactly = false) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, significantToken = terminalNode.getSignificantToken();
          matches = exactly ? this.significantToken === significantToken : this.significantToken.match(significantToken);
        }
        return matches;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, parentNode = null, significantToken = this.significantToken, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
      destroy() {
        this.parentNode = null;
        this.significantToken = null;
      }
      static fromNothing(Class, ...remainingArguments) {
        if (Class === void 0) {
          Class = TerminalNode;
        }
        const parentNode = null, significantToken = null, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
      static fromSignificantToken(Class, significantToken, ...remainingArguments) {
        if (significantToken === void 0) {
          significantToken = Class;
          Class = TerminalNode;
        }
        const parentNode = null, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/epsilonNode.js
  var require_epsilonNode = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = epsilon, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EpsilonNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const epsilonNodeParseTree = terminalNodeParseTree;
        return epsilonNodeParseTree;
      }
    };
    module.exports = EpsilonNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/terminal/epsilon.js
  var require_epsilon = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonNode;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _epsilonNode = /* @__PURE__ */ _interop_require_default(require_epsilonNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = epsilon;
        return content;
      }
      isEpsilonNode() {
        const epsilonNode = true;
        return epsilonNode;
      }
      asParseTree(tokens) {
        const epsilonNodeParseTree = _epsilonNode.default.fromNothing(), parseTree = epsilonNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeEpsilonNode = terminalNode.isEpsilonNode();
          if (terminalNodeEpsilonNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(EpsilonNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/epsilon.js
  var require_epsilon2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonPart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), epsilonBNFNode = _epsilon.default.fromNothing();
        parsed = epsilonBNFNode !== null;
        if (parsed) {
          nodes.push(epsilonBNFNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = epsilon;
        return string;
      }
      static fromNothing() {
        const epsilonPart = new EpsilonPart();
        return epsilonPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/epsilon.js
  var require_epsilon3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonBNFNode;
      }
    });
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EpsilonBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const epsilonPart = _epsilon.default.fromNothing();
        return epsilonPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(EpsilonBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/document.js
  var require_document2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentBNFNode = class extends _nonTerminal.default {
      generateRules(Rule) {
        const ruleName = _ruleNames.RULE_RULE_NAME, childNodes = this.getChildNodes(), ruleBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName), rules = ruleBNFNodes.map((ruleBNFNode) => {
          const rule = ruleBNFNode.generateRule(Rule);
          return rule;
        });
        return rules;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DocumentBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/ruleName.js
  var require_ruleName2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNamePart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _constants = require_constants4();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {ellipsis} = _occamlexers.specialSymbols;
    var RuleNamePart = class extends _nonTerminal.default {
      constructor(type, callAAhead, ruleName) {
        super(type, callAAhead);
        this.ruleName = ruleName;
      }
      getRuleName() {
        return this.ruleName;
      }
      isRuleNamePart() {
        const ruleNamePart = true;
        return ruleNamePart;
      }
      findRule(state) {
        const ruleMap = state.getRuleMap(), rule = ruleMap[this.ruleName] || null;
        return rule;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const rule = this.findRule(state);
        parsed = rule !== null ? rule.parse(nodes, state, callback, callAhead) : false;
        return parsed;
      }
      asString() {
        const callAAhead = this.isCallAhead(), callAAheadString = callAAhead ? ellipsis : _constants.EMPTY_STRING, string = `${this.ruleName}${callAAheadString}`;
        return string;
      }
      static fromRuleName(ruleName) {
        const type = _partTypes.RuleNamePartType, callAAhead = false, ruleNamePart = new RuleNamePart(type, callAAhead, ruleName);
        return ruleNamePart;
      }
      static fromCallAheadAndRuleName(callAAhead, ruleName) {
        const type = _partTypes.RuleNamePartType, ruleNamePart = new RuleNamePart(type, callAAhead, ruleName);
        return ruleNamePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/ruleName.js
  var require_ruleName3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameBNFNode;
      }
    });
    var _necessary = require_browser();
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var RuleNameBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), ruleName = terminalNodeContent, ruleNamePart = _ruleName.default.fromCallAheadAndRuleName(callAhead, ruleName);
        return ruleNamePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RuleNameBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/wildcard.js
  var require_wildcard = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {wildcard} = _occamlexers.specialSymbols;
    var WildcardPart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          terminalNode = _terminal1.default.fromSignificantToken(significantToken);
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = wildcard;
        return string;
      }
      static fromNothing() {
        const wildcardPart = new WildcardPart();
        return wildcardPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/wildcard.js
  var require_wildcard2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardBNFNode;
      }
    });
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var WildcardBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const wildcardPart = _wildcard.default.fromNothing();
        return wildcardPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(WildcardBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/endOfLineNode.js
  var require_endOfLineNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLineNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = endOfLine, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EndOfLineNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const endOfLineNodeParseTree = terminalNodeParseTree;
        return endOfLineNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/endOfLine.js
  var require_endOfLine5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _endOfLineNode = /* @__PURE__ */ _interop_require_default(require_endOfLineNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfLineNode = class extends _terminal.default {
      getContent(faithful = false) {
        const content = faithful ? super.getContent() : _constants.EMPTY_STRING;
        return content;
      }
      asParseTree(tokens) {
        const endOfLineNodeParseTree = _endOfLineNode.default.fromNothing(), parseTree = endOfLineNodeParseTree;
        return parseTree;
      }
      static fromSignificantToken(significantToken) {
        return _terminal.default.fromSignificantToken(EndOfLineNode, significantToken);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/endOfLine.js
  var require_endOfLine6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLinePart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLinePart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let endOfLineNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const significantTokenEndOfLineToken = significantToken.isEndOfLineToken();
          if (significantTokenEndOfLineToken) {
            endOfLineNode = _endOfLine.default.fromSignificantToken(significantToken);
          }
        }
        parsed = endOfLineNode !== null;
        if (parsed) {
          nodes.push(endOfLineNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = endOfLine;
        return string;
      }
      static fromNothing() {
        const endOfLinePart = new EndOfLinePart();
        return endOfLinePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/endOfLine.js
  var require_endOfLine7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineBNFNode;
      }
    });
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine6());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfLineBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const endOfLinePart = _endOfLine.default.fromNothing();
        return endOfLinePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(EndOfLineBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/partChoice.js
  var require_partChoice = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoice;
      }
    });
    var _necessary = require_browser();
    var {SPACE_CHARACTER} = _necessary.characters;
    var PartChoice = class {
      constructor(part, precedence) {
        this.part = part;
        this.precedence = precedence;
      }
      getPart() {
        return this.part;
      }
      getPrecedence() {
        return this.precedence;
      }
      asString() {
        let string;
        const partString = this.part.asString();
        string = partString;
        if (this.precedence !== null) {
          const precedence = this.precedence === Infinity ? SPACE_CHARACTER : this.precedence;
          string = `${string} (${precedence})`;
        }
        return string;
      }
      static fromPart(part) {
        const precedence = null, partChoice = new PartChoice(part, precedence);
        return partChoice;
      }
      static fromPartAndPrecedence(part, precedence) {
        const partChoice = new PartChoice(part, precedence);
        return partChoice;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/partChoice.js
  var require_partChoice2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceBNFNode;
      }
    });
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _node = require_node2();
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceBNFNode = class extends _nonTerminal.default {
      generatePartChoice(callAhead) {
        let ruleName;
        const childNodes = this.getChildNodes();
        ruleName = _ruleNames.PART_RULE_NAME;
        const partBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const part = partBNFNode.generatePart(callAhead), precedence = precedenceBNFNode === null ? null : precedenceBNFNode.getPrecedence(), definition = _partChoice.default.fromPartAndPrecedence(part, precedence);
        return definition;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PartChoiceBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/precedence.js
  var require_precedence = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {second} = _necessary.arrayUtilities;
    var PrecedenceBNFNode = class extends _nonTerminal.default {
      getPrecedence() {
        let precedence = Infinity;
        const multiplicity = this.getMultiplicity();
        if (multiplicity === 3) {
          const childNodes = this.getChildNodes(), secondChildNode = second(childNodes), terminalNode = secondChildNode, content = terminalNode.getContent();
          precedence = Number(content);
        }
        return precedence;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PrecedenceBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/quantifier.js
  var require_quantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(QuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/parse.js
  var require_parse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get parsePart() {
        return parsePart;
      },
      get parseParts() {
        return parseParts;
      }
    });
    function parsePart(part, nodes, state, callback, callAhead) {
      let parsed;
      const index = 0, parts = [
        part
      ];
      parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      return parsed;
    }
    function parseParts(parts, nodes, state, callback, callAhead) {
      let parsed;
      const index = 0;
      parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      return parsed;
    }
    function parsePartOfParts(index, parts, nodes, state, callback, callAhead) {
      let parsed;
      const partsLength = parts.length;
      if (index === partsLength) {
        parsed = callback !== null ? callback() : true;
      } else {
        const part = parts[index], partCallAhead = callAhead === null ? part.isCallAhead() : true;
        index++;
        parsed = partCallAhead ? parsePartWithCallAhead(part, index, parts, nodes, state, callback, callAhead) : parsePartWithoutCallAhead(part, index, parts, nodes, state, callback, callAhead);
      }
      return parsed;
    }
    function parsePartWithCallAhead(part, index, parts, nodes, state, callback, callAhead) {
      let parsed;
      const nodesLength = nodes.length;
      callAhead = () => {
        let parsed2;
        parsed2 = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
        return parsed2;
      };
      parsed = part.parse(nodes, state, callback, callAhead);
      if (!parsed) {
        const start = nodesLength;
        nodes.splice(start);
      }
      return parsed;
    }
    function parsePartWithoutCallAhead(part, index, parts, nodes, state, callback, callAhead) {
      let parsed;
      parsed = part.parse(nodes, state, callback, callAhead);
      if (parsed) {
        parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/definition.js
  var require_definition = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Definition;
      }
    });
    var _necessary = require_browser();
    var _parse = require_parse();
    var _constants = require_constants4();
    var {SPACE_CHARACTER} = _necessary.characters;
    var Definition = class {
      constructor(parts, precedence) {
        this.parts = parts;
        this.precedence = precedence;
      }
      getParts() {
        return this.parts;
      }
      getPrecedence() {
        return this.precedence;
      }
      parse(childNodes, state, callback, callAhead) {
        let parsed;
        const nodes = childNodes, savedIndex = state.getSavedIndex();
        parsed = (0, _parse.parseParts)(this.parts, nodes, state, callback, callAhead);
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        let string;
        const partsString = this.parts.reduce((partsString2, part) => {
          const partString = part.asString();
          if (partsString2 === _constants.EMPTY_STRING) {
            partsString2 = partString;
          } else {
            partsString2 = `${partsString2} ${partString}`;
          }
          return partsString2;
        }, _constants.EMPTY_STRING);
        string = partsString;
        if (this.precedence !== null) {
          const precedence = this.precedence === Infinity ? SPACE_CHARACTER : this.precedence;
          string = `${string} (${precedence})`;
        }
        return string;
      }
      static fromParts(Class, parts) {
        if (parts === void 0) {
          parts = Class;
          Class = Definition;
        }
        const precedence = null, definition = new Class(parts, precedence);
        return definition;
      }
      static fromPartsAndPrecedence(Class, parts, precedence) {
        if (precedence === void 0) {
          precedence = parts;
          parts = Class;
          Class = Definition;
        }
        const definition = new Class(parts, precedence);
        return definition;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/definition.js
  var require_definition2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionBNFNode;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionBNFNode = class extends _nonTerminal.default {
      generateDefinition() {
        let ruleName;
        const childNodes = this.getChildNodes();
        ruleName = _ruleNames.PART_RULE_NAME;
        const partBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName), callAhead = false, parts = partBNFNodes.map((partBNFNode) => {
          const part = partBNFNode.generatePart(callAhead);
          return part;
        }), precedence = precedenceBNFNode === null ? null : precedenceBNFNode.getPrecedence(), definition = _definition.default.fromPartsAndPrecedence(parts, precedence);
        return definition;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DefinitionBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/definitions.js
  var require_definitions = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionsBNFNode = class extends _nonTerminal.default {
      generateDefinitions() {
        const ruleName = _ruleNames.DEFINITION_RULE_NAME, childNodes = this.getChildNodes(), definitionBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName), definitions = definitionBNFNodes.map((definitionBNFNode) => {
          const definition = definitionBNFNode.generateDefinition();
          return definition;
        });
        return definitions;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DefinitionsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/terminalPart.js
  var require_terminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var TerminalPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), node = firstChildNode, part = node.generatePart(callAhead);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(TerminalPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/choiceOfParts.js
  var require_choiceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsPart;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _parse = require_parse();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, partChoices) {
        super(type, callAhead);
        this.partChoices = partChoices;
      }
      getPartChoices() {
        return this.partChoices;
      }
      getParts() {
        const parts = this.partChoices.map((partChoice) => {
          const part = partChoice.getPart();
          return part;
        });
        return parts;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedPrecedence = state.getSavedPrecedence();
        parsed = this.partChoices.some((partChoice) => {
          let parsed2;
          const part = partChoice.getPart(), savedIndex = state.getSavedIndex(), precedence = partChoice.getPrecedence(), nodesLength = nodes.length;
          if (precedence !== null) {
            state.setPrecedence(precedence);
          }
          callback = callAhead === null ? null : () => {
            let parsed3;
            parsed3 = callAhead();
            return parsed3;
          };
          parsed2 = (0, _parse.parsePart)(part, nodes, state, callback, callAhead);
          if (!parsed2) {
            const start = nodesLength;
            nodes.splice(start);
            state.backtrack(savedIndex);
          }
          return parsed2;
        });
        if (!parsed) {
          state.resetPrecedence(savedPrecedence);
        }
        return parsed;
      }
      asString() {
        const partChoicesString = this.partChoices.reduce((partChoicesString2, partChoice) => {
          const partChoiceString = partChoice.asString();
          if (partChoicesString2 === null) {
            partChoicesString2 = partChoiceString;
          } else {
            partChoicesString2 = `${partChoicesString2} | ${partChoiceString}`;
          }
          return partChoicesString2;
        }, null), string = `( ${partChoicesString} )`;
        return string;
      }
      static fromPartChoices(partChoices) {
        const type = _partTypes.ChoiceOfPartsPartType, callAhead = false, choiceOfPartsPart = new ChoiceOfPartsPart(type, callAhead, partChoices);
        return choiceOfPartsPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/choiceOfParts.js
  var require_choiceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const ruleName = _ruleNames.PART_CHOICE_RULE_NAME, childNodes = this.getChildNodes(), partChoiceBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const partChoices = partChoiceBNFNodes.map((partChoiceBNFNode) => {
          const partChoice = partChoiceBNFNode.generatePartChoice(callAhead);
          return partChoice;
        }), choiceOfPartsPart = _choiceOfParts.default.fromPartChoices(partChoices), part = choiceOfPartsPart;
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ChoiceOfPartsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/stringLiteral.js
  var require_stringLiteral2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralPart;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StringLiteralPart = class extends _terminal.default {
      constructor(content) {
        super();
        this.content = content;
      }
      getContent() {
        return this.content;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const content = significantToken.getContent();
          if (content === this.content) {
            terminalNode = _terminal1.default.fromSignificantToken(significantToken);
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const content = this.content.replace(/\\/, "\\\\"), string = `"${content}"`;
        return string;
      }
      static fromContent(content) {
        const stringLiteralPart = new StringLiteralPart(content);
        return stringLiteralPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/stringLiteral.js
  var require_stringLiteral3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var StringLiteralBNFNode = class extends _nonTerminal.default {
      regularExpression = /^"((?:\\.|[^"\\])*)"$/;
      generatePart(callAhead) {
        const content = this.getContent(), stringLiteralPart = _stringLiteral.default.fromContent(content);
        return stringLiteralPart;
      }
      getContent() {
        let content;
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches);
        content = secondMatch;
        content = sanitiseContent(content);
        return content;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(StringLiteralBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    function sanitiseContent(content) {
      content = content.replace(/\\\\/g, _constants.ESCAPED_BACKSLASH).replace(/\\"/g, _constants.ESCAPED_DOUBLE_QUOTE);
      return content;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/nonTerminalPart.js
  var require_nonTerminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var NonTerminalPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes();
        if (!callAhead) {
          const ruleName = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME, callAheadModifierBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
          callAhead = callAheadModifierBNFNode !== null;
        }
        const firstChildNode = first2(childNodes), node = firstChildNode, part = node.generatePart(callAhead);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NonTerminalPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/sequenceOfParts.js
  var require_sequenceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsPart;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _parse = require_parse();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, parts) {
        super(type, callAhead);
        this.parts = parts;
      }
      getParts() {
        return this.parts;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        callback = callAhead === null ? null : () => {
          let parsed2;
          parsed2 = callAhead();
          return parsed2;
        };
        parsed = (0, _parse.parseParts)(this.parts, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partsString = this.parts.reduce((partsString2, part) => {
          const partString = part.asString();
          if (partsString2 === null) {
            partsString2 = partString;
          } else {
            partsString2 = `${partsString2} ${partString}`;
          }
          return partsString2;
        }, null), string = `( ${partsString} )`;
        return string;
      }
      static fromParts(parts) {
        const type = _partTypes.SequenceOfPartsPartType, callAhead = false, sequenceOfPartsPart = new SequenceOfPartsPart(type, callAhead, parts);
        return sequenceOfPartsPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/sequenceOfParts.js
  var require_sequenceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const ruleName = _ruleNames.PART_RULE_NAME, childNodes = this.getChildNodes(), partBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const parts = partBNFNodes.map((partBNFNode) => {
          const part2 = partBNFNode.generatePart(callAhead);
          return part2;
        }), sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), part = sequenceOfPartsPart;
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(SequenceOfPartsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/opacityModifier.js
  var require_opacityModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {second} = _necessary.arrayUtilities;
    var OpacityModifierBNFNode = class extends _nonTerminal.default {
      getOpacity() {
        const childNodes = this.getChildNodes(), secondChildNode = second(childNodes), terminalNode = secondChildNode, terminalNodeContent = terminalNode.getContent(), opacity = terminalNodeContent;
        return opacity;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OpacityModifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/noWhitespaceNode.js
  var require_noWhitespaceNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespaceNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespaceNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = noWhitespace, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(NoWhitespaceNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const noWhitespaceNodeParseTree = terminalNodeParseTree;
        return noWhitespaceNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/noWhitespace.js
  var require_noWhitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespaceNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _noWhitespaceNode = /* @__PURE__ */ _interop_require_default(require_noWhitespaceNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespaceNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = _constants.EMPTY_STRING;
        return content;
      }
      isNoWhitespaceNode() {
        const noWhitespaceNode = true;
        return noWhitespaceNode;
      }
      asParseTree(tokens) {
        const noWhitespaceNodeParseTree = _noWhitespaceNode.default.fromNothing(), parseTree = noWhitespaceNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeNoWhitespaceNode = terminalNode.isNoWhitespaceNode();
          if (terminalNodeNoWhitespaceNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(NoWhitespaceNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/noWhitespace.js
  var require_noWhitespace2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespacePart = class extends _terminal.default {
      isNoWhitespacePart() {
        const noWhitespacePart = true;
        return noWhitespacePart;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let noWhitespaceNode = null;
        const savedIndex = state.getSavedIndex(), nextTokenWhitespaceToken = state.isNextTokenWhitespaceToken();
        if (!nextTokenWhitespaceToken) {
          noWhitespaceNode = _noWhitespace.default.fromNothing();
        }
        parsed = noWhitespaceNode !== null;
        if (parsed) {
          nodes.push(noWhitespaceNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = noWhitespace;
        return string;
      }
      static fromNothing() {
        const noWhitespacePart = new NoWhitespacePart();
        return noWhitespacePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/noWhitespacePart.js
  var require_noWhitespacePart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespacePartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const noWhitespacePart = _noWhitespace.default.fromNothing();
        return noWhitespacePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NoWhitespacePartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/callAheadModifier.js
  var require_callAheadModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CallAheadModifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(CallAheadModifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/regularExpression.js
  var require_regularExpression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionPart;
      }
    });
    var _necessary = require_browser();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var RegularExpressionPart = class extends _terminal.default {
      constructor(regularExpression) {
        super();
        this.regularExpression = regularExpression;
      }
      getRegularExpression() {
        return this.regularExpression;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const content = significantToken.getContent(), matches = content.match(this.regularExpression);
          if (matches !== null) {
            const firstMatch = first2(matches);
            if (firstMatch === content) {
              terminalNode = _terminal1.default.fromSignificantToken(significantToken);
            }
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const regularExpressionString = this.regularExpression.toString(), string = regularExpressionString;
        return string;
      }
      static fromRegularExpression(regularExpression) {
        const regularExpressionPart = new RegularExpressionPart(regularExpression);
        return regularExpressionPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/regularExpression.js
  var require_regularExpression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var RegularExpressionBNFNode = class extends _nonTerminal.default {
      regularExpression = /^\/((?:\\.|[^\/])*)\/$/;
      generatePart(callAhead) {
        const regularExpression = this.getRegularExpression(), regularExpressionPart = _regularExpression.default.fromRegularExpression(regularExpression);
        return regularExpressionPart;
      }
      getRegularExpression() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches), pattern = secondMatch, regularExpression = new RegExp(pattern);
        return regularExpression;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RegularExpressionBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/startOfContentNode.js
  var require_startOfContentNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = startOfContent, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(StartOfContentNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const startOfContentNodeParseTree = terminalNodeParseTree;
        return startOfContentNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/startOfContent.js
  var require_startOfContent = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _startOfContentNode = /* @__PURE__ */ _interop_require_default(require_startOfContentNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = _constants.EMPTY_STRING;
        return content;
      }
      isStartOfContentNode() {
        const startOfContentNode = true;
        return startOfContentNode;
      }
      asParseTree(tokens) {
        const startOfContentNodeParseTree = _startOfContentNode.default.fromNothing(), parseTree = startOfContentNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeStartOfContentNode = terminalNode.isStartOfContentNode();
          if (terminalNodeStartOfContentNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(StartOfContentNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/startOfContent.js
  var require_startOfContent2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _startOfContent = /* @__PURE__ */ _interop_require_default(require_startOfContent());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentPart = class extends _terminal.default {
      isStartOfContentPart() {
        const startOfContentPart = true;
        return startOfContentPart;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let startOfContentNode = null;
        const savedIndex = state.getSavedIndex(), atStartOfContent = state.isAtStartOfContent();
        if (atStartOfContent) {
          startOfContentNode = _startOfContent.default.fromNothing();
        }
        parsed = startOfContentNode !== null;
        if (parsed) {
          nodes.push(startOfContentNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = startOfContent;
        return string;
      }
      static fromNothing() {
        const startOfContentPart = new StartOfContentPart();
        return startOfContentPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/startOfContentPart.js
  var require_startOfContentPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _startOfContent = /* @__PURE__ */ _interop_require_default(require_startOfContent2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const startOfContentPart = _startOfContent.default.fromNothing();
        return startOfContentPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(StartOfContentPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/optionalQuantifier.js
  var require_optionalQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OptionalQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OptionalQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OptionalQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/oneOneOrMoreQuantifier.js
  var require_oneOneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OneOrMoreQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OneOrMoreQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OneOrMoreQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/significantTokenType.js
  var require_significantTokenType = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypePart;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantTokenTypePart = class extends _terminal.default {
      constructor(significantTokenType) {
        super();
        this.significantTokenType = significantTokenType;
      }
      getSignificantTokenType() {
        return this.significantTokenType;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const significantTokenType = significantToken.getType();
          if (significantTokenType === this.significantTokenType) {
            terminalNode = _terminal1.default.fromSignificantToken(significantToken);
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = `[${this.significantTokenType}]`;
        return string;
      }
      static fromSignificantTokenType(significantTokenType) {
        const significantTokenTypePart = new SignificantTokenTypePart(significantTokenType);
        return significantTokenTypePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/significantTokenType.js
  var require_significantTokenType2 = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var SignificantTokenTypeBNFNode = class extends _nonTerminal.default {
      regularExpression = /^\[([^\]]+)]$/;
      generatePart(callAhead) {
        const significantTokenType = this.getSignificantTokenType(), significantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType);
        return significantTokenTypePart;
      }
      getSignificantTokenType() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches), significantTokenType = secondMatch;
        return significantTokenType;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(SignificantTokenTypeBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    module.exports = SignificantTokenTypeBNFNode;
  });

  // node_modules/occam-parsers/lib/node/bnf/zeroOneOrMoreQuantifier.js
  var require_zeroOneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZerorOrMoreQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ZerorOrMoreQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ZerorOrMoreQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _part = /* @__PURE__ */ _interop_require_default(require_part());
    var _name = /* @__PURE__ */ _interop_require_default(require_name2());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule3());
    var _error = /* @__PURE__ */ _interop_require_default(require_error());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon3());
    var _document = /* @__PURE__ */ _interop_require_default(require_document2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName3());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard2());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine7());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice2());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence());
    var _quantifier = /* @__PURE__ */ _interop_require_default(require_quantifier());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition2());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions());
    var _terminalPart = /* @__PURE__ */ _interop_require_default(require_terminalPart());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral3());
    var _nonTerminalPart = /* @__PURE__ */ _interop_require_default(require_nonTerminalPart());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts2());
    var _opacityModifier = /* @__PURE__ */ _interop_require_default(require_opacityModifier());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart());
    var _callAheadModifier = /* @__PURE__ */ _interop_require_default(require_callAheadModifier());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression3());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart());
    var _optionalQuantifier = /* @__PURE__ */ _interop_require_default(require_optionalQuantifier());
    var _oneOneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_oneOneOrMoreQuantifier());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType2());
    var _zeroOneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_zeroOneOrMoreQuantifier());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeMap = {
      [_ruleNames.NAME_RULE_NAME]: _name.default,
      [_ruleNames.PART_RULE_NAME]: _part.default,
      [_ruleNames.RULE_RULE_NAME]: _rule.default,
      [_ruleNames.ERROR_RULE_NAME]: _error.default,
      [_ruleNames.EPSILON_RULE_NAME]: _epsilon.default,
      [_ruleNames.DOCUMENT_RULE_NAME]: _document.default,
      [_ruleNames.WILDCARD_RULE_NAME]: _wildcard.default,
      [_ruleNames.RULE_NAME_RULE_NAME]: _ruleName.default,
      [_ruleNames.DEFINITION_RULE_NAME]: _definition.default,
      [_ruleNames.PRECEDENCE_RULE_NAME]: _precedence.default,
      [_ruleNames.QUANTIFIER_RULE_NAME]: _quantifier.default,
      [_ruleNames.END_OF_LINE_RULE_NAME]: _endOfLine.default,
      [_ruleNames.PART_CHOICE_RULE_NAME]: _partChoice.default,
      [_ruleNames.DEFINITIONS_RULE_NAME]: _definitions.default,
      [_ruleNames.TERMINAL_PART_RULE_NAME]: _terminalPart.default,
      [_ruleNames.STRING_LITERAL_RULE_NAME]: _stringLiteral.default,
      [_ruleNames.CHOICE_OF_PARTS_RULE_NAME]: _choiceOfParts.default,
      [_ruleNames.OPACITY_MODIFIER_RULE_NAME]: _opacityModifier.default,
      [_ruleNames.NON_TERMINAL_PART_RULE_NAME]: _nonTerminalPart.default,
      [_ruleNames.SEQUENCE_OF_PARTS_RULE_NAME]: _sequenceOfParts.default,
      [_ruleNames.NO_WHITESPACE_PART_RULE_NAME]: _noWhitespacePart.default,
      [_ruleNames.REGULAR_EXPRESSION_RULE_NAME]: _regularExpression.default,
      [_ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME]: _callAheadModifier.default,
      [_ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME]: _optionalQuantifier.default,
      [_ruleNames.START_OF_CONTENT_PART_RULE_NAME]: _startOfContentPart.default,
      [_ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME]: _significantTokenType.default,
      [_ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME]: _oneOneOrMoreQuantifier.default,
      [_ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME]: _zeroOneOrMoreQuantifier.default
    };
    var _default = NonTerminalNodeMap;
  });

  // node_modules/occam-parsers/lib/state.js
  var require_state2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return State;
      }
    });
    var State = class {
      constructor(index, tokens, ruleMap, precedence, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode) {
        this.index = index;
        this.tokens = tokens;
        this.ruleMap = ruleMap;
        this.precedence = precedence;
        this.startOfContent = startOfContent;
        this.NonTerminalNodeMap = NonTerminalNodeMap;
        this.defaultNonTerminalNode = defaultNonTerminalNode;
      }
      getIndex() {
        return this.index;
      }
      getTokens() {
        return this.tokens;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      getPrecedence() {
        return this.precedence;
      }
      getStartOfContent() {
        return this.startOfContent;
      }
      getNonTerminalNode() {
        return this.NonTerminalNodeMap;
      }
      getDefaultNonTerminalNode() {
        return this.defaultNonTerminalNode;
      }
      setIndex(index) {
        this.index = index;
      }
      setTokens(tokens) {
        this.tokens = tokens;
      }
      setRuleMap(ruleMap) {
        this.ruleMap = ruleMap;
      }
      setPrecedence(precedence) {
        this.precedence = precedence;
      }
      setStartOfContent(startOfContent) {
        this.startOfContent = startOfContent;
      }
      getSavedPrecedence() {
        const savedPrecedence = this.precedence;
        return savedPrecedence;
      }
      getSavedIndex() {
        const savedIndex = this.index;
        return savedIndex;
      }
      getNextToken() {
        let nextToken = null;
        const tokensLength = this.tokens.length;
        if (this.index < tokensLength) {
          nextToken = this.tokens[this.index++];
        }
        return nextToken;
      }
      isAtStartOfContent() {
        const atStartOfContent = this.startOfContent ? this.index === 0 : false;
        return atStartOfContent;
      }
      getNextSignificantToken() {
        let nextSignificantToken = null;
        const tokensLength = this.tokens.length;
        while (this.index < tokensLength) {
          const token = this.tokens[this.index++], tokenSignificant = token.isSignificant();
          if (tokenSignificant) {
            const significantToken = token;
            nextSignificantToken = significantToken;
            break;
          }
        }
        return nextSignificantToken;
      }
      isNextTokenWhitespaceToken() {
        let nextTokenWhitespaceToken = false;
        const tokensLength = this.tokens.length;
        if (this.index < tokensLength) {
          const nextToken = this.tokens[this.index];
          nextTokenWhitespaceToken = nextToken.isWhitespaceToken();
        }
        return nextTokenWhitespaceToken;
      }
      backtrack(savedIndex) {
        this.index = savedIndex;
      }
      resetPrecedence(savedPrecedence) {
        this.precedence = savedPrecedence;
      }
      NonTerminalNodeFromRuleName(ruleName) {
        const NonTerminalNode = Object.hasOwn(this.NonTerminalNodeMap, ruleName) ? this.NonTerminalNodeMap[ruleName] : this.defaultNonTerminalNode;
        return NonTerminalNode;
      }
      static fromTokensRuleMapStartOfContentNonTerminalNodeMapAndDefaultNonTerminalNode(tokens, ruleMap, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode) {
        const index = 0, precedence = null, state = new State(index, tokens, ruleMap, precedence, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode);
        return state;
      }
    };
  });

  // node_modules/occam-parsers/lib/mixins/parser.js
  var require_parser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _state = /* @__PURE__ */ _interop_require_default(require_state2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    function parse(tokens, rule = this.startRule, startOfContent = true) {
      let node = null;
      const nodes = [], {NonTerminalNodeMap, defaultNonTerminalNode} = this.constructor, state = _state.default.fromTokensRuleMapStartOfContentNonTerminalNodeMapAndDefaultNonTerminalNode(tokens, this.ruleMap, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode), callback = null, callAhead = null, parsed = rule.parse(nodes, state, callback, callAhead);
      if (parsed) {
        const firstNode = first2(nodes);
        node = firstNode;
      }
      return node;
    }
    var parserMixins = {
      parse
    };
    var _default = parserMixins;
  });

  // node_modules/occam-parsers/lib/definition/name.js
  var require_name3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {nameType} = _occamlexers.types;
    var NameDefinition = class extends _definition.default {
      static fromNothing() {
        const significantTokenType = nameType, nameSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), parts = [
          nameSignificantTokenTypePart
        ], precedence = null, nameDefinition = new NameDefinition(parts, precedence);
        return nameDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/name.js
  var require_name4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _name = /* @__PURE__ */ _interop_require_default(require_name3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NameBNFRule = class extends _rule.default {
      static fromNothing() {
        const nameDefinition = _name.default.fromNothing(), name = _ruleNames.NAME_RULE_NAME, opacity = null, definitions = [
          nameDefinition
        ], nameRule = new NameBNFRule(name, opacity, definitions);
        return nameRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/terminal.js
  var require_terminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.QUANTIFIER_RULE_NAME;
        const quantifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.TERMINAL_PART_RULE_NAME;
        const terminalPartRuleNamePart = _ruleName.default.fromRuleName(ruleName), zeroOrMoreQuantifierRuleNamePartsPart = _zeroOrMoreParts.default.fromPart(quantifierRuleNamePart), parts = [
          terminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ], precedence = null, terminalPartRuleDefinition = new TerminalPartRuleDefinition(parts, precedence);
        return terminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal.js
  var require_nonTerminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.QUANTIFIER_RULE_NAME;
        const quantifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NON_TERMINAL_PART_RULE_NAME;
        const nonTerminalPartRuleNamePart = _ruleName.default.fromRuleName(ruleName), zeroOrMoreQuantifierRuleNamePartsPart = _zeroOrMoreParts.default.fromPart(quantifierRuleNamePart), parts = [
          nonTerminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ], precedence = null, nonTerminalPartRuleDefinition = new NonTerminalPartRuleDefinition(parts, precedence);
        return nonTerminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/part.js
  var require_part2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal3());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PART_RULE_NAME, terminalPartRuleDefinition = _terminal.default.fromNothing(), nonTerminalPartRuleDefinition = _nonTerminal.default.fromNothing(), opacity = null, definitions = [
          nonTerminalPartRuleDefinition,
          terminalPartRuleDefinition
        ], partRule = new PartBNFRule(name, opacity, definitions);
        return partRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/rule.js
  var require_rule4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {separator, terminator} = _occamlexers.specialSymbols;
    var RuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        const separatorStringLiteralContent = separator, terminatorStringLiteralContent = terminator;
        ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME;
        const opacityModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NAME_RULE_NAME;
        const nameRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalOpacityRuleNamePartPart = _optionalPart.default.fromPart(opacityModifierRuleNamePart), separatorStringLiteralPart = _stringLiteral.default.fromContent(separatorStringLiteralContent);
        ruleName = _ruleNames.DEFINITIONS_RULE_NAME;
        const definitionsRuleNamePart = _ruleName.default.fromRuleName(ruleName), terminatorStringLiteralPart = _stringLiteral.default.fromContent(terminatorStringLiteralContent), parts = [
          nameRuleNamePart,
          optionalOpacityRuleNamePartPart,
          separatorStringLiteralPart,
          definitionsRuleNamePart,
          terminatorStringLiteralPart
        ], precedence = null, ruleDefinition = new RuleDefinition(parts, precedence);
        return ruleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/rule.js
  var require_rule5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _rule1 = /* @__PURE__ */ _interop_require_default(require_rule4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleBNFRule = class extends _rule.default {
      static fromNothing() {
        const ruleDefinition = _rule1.default.fromNothing(), name = _ruleNames.RULE_RULE_NAME, opacity = null, definitions = [
          ruleDefinition
        ], ruleRule = new RuleBNFRule(name, opacity, definitions);
        return ruleRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/error.js
  var require_error2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ErrorDefinition = class extends _definition.default {
      static fromNothing() {
        const wildcardPart = _wildcard.default.fromNothing(), parts = [
          wildcardPart
        ], precedence = null, errorDefinition = new ErrorDefinition(parts, precedence);
        return errorDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/error.js
  var require_error3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _error = /* @__PURE__ */ _interop_require_default(require_error2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque} = _occamlexers.specialSymbols;
    var ErrorBNFRule = class extends _rule.default {
      static fromNothing() {
        const errorDefinition = _error.default.fromNothing(), name = _ruleNames.ERROR_RULE_NAME, opacity = opaque, definitions = [
          errorDefinition
        ], errorRule = new ErrorBNFRule(name, opacity, definitions);
        return errorRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/stringLiteral.js
  var require_stringLiteral4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StringLiteralDefinition = class extends _definition.default {
      static fromContent(content) {
        const stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, stringLiteralDefinition = new StringLiteralDefinition(parts, precedence);
        return stringLiteralDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/epsilon.js
  var require_epsilon4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = epsilon, epsilonStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.EPSILON_RULE_NAME, opacity = null, definitions = [
          epsilonStringLiteralDefinition
        ], epsilonRule = new EpsilonBNFRule(name, opacity, definitions);
        return epsilonRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/document.js
  var require_document3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.RULE_RULE_NAME;
        const ruleRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ERROR_RULE_NAME;
        const errorRuleNamePart = _ruleName.default.fromRuleName(ruleName), ruleRuleNamePartChoice = _partChoice.default.fromPart(ruleRuleNamePart), errorRuleNamePartChoice = _partChoice.default.fromPart(errorRuleNamePart), partChoices = [
          ruleRuleNamePartChoice,
          errorRuleNamePartChoice
        ], choiceOfRuleRuleNameAndErrorRuleNamePartsPart = _choiceOfParts.default.fromPartChoices(partChoices), oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart = _oneOrMoreParts.default.fromPart(choiceOfRuleRuleNameAndErrorRuleNamePartsPart), parts = [
          oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart
        ], precedence = null, documentDefinition = new DocumentDefinition(parts, precedence);
        return documentDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/document.js
  var require_document4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _document = /* @__PURE__ */ _interop_require_default(require_document3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentBNFRule = class extends _rule.default {
      static fromNothing() {
        const documentDefinition = _document.default.fromNothing(), name = _ruleNames.DOCUMENT_RULE_NAME, opacity = null, definitions = [
          documentDefinition
        ], documentRule = new DocumentBNFRule(name, opacity, definitions);
        return documentRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/ruleName.js
  var require_ruleName4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _name = /* @__PURE__ */ _interop_require_default(require_name3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameBNFRule = class extends _rule.default {
      static fromNothing() {
        const nameDefinition = _name.default.fromNothing(), name = _ruleNames.RULE_NAME_RULE_NAME, opacity = null, definitions = [
          nameDefinition
        ], ruleNameRule = new RuleNameBNFRule(name, opacity, definitions);
        return ruleNameRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/wildcard.js
  var require_wildcard3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {wildcard} = _occamlexers.specialSymbols;
    var WildcardBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = wildcard, wildcardStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.WILDCARD_RULE_NAME, opacity = null, definitions = [
          wildcardStringLiteralDefinition
        ], wildcardRule = new WildcardBNFRule(name, opacity, definitions);
        return wildcardRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/endOfLine.js
  var require_endOfLine8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLineBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = endOfLine, endOfLineStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.END_OF_LINE_RULE_NAME, opacity = null, definitions = [
          endOfLineStringLiteralDefinition
        ], endOfLineRule = new EndOfLineBNFRule(name, opacity, definitions);
        return endOfLineRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partChoice.js
  var require_partChoice3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.PART_RULE_NAME;
        const partRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalPrecedenceRuleNamePartPart = _optionalPart.default.fromPart(precedenceRuleNamePart), parts = [
          partRuleNamePart,
          optionalPrecedenceRuleNamePartPart
        ], precedence = null, partChoiceDefinition = new PartChoiceDefinition(parts, precedence);
        return partChoiceDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/partChoice.js
  var require_partChoice4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PART_CHOICE_RULE_NAME, partChoiceDefinition = _partChoice.default.fromNothing(), opacity = null, definitions = [
          partChoiceDefinition
        ], definitionRule = new PartChoiceBNFRule(name, opacity, definitions);
        return definitionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/ruleName.js
  var require_ruleName5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameDefinition = class extends _definition.default {
      static fromRuleName(ruleName) {
        const ruleNameRuleNamePart = _ruleName.default.fromRuleName(ruleName), parts = [
          ruleNameRuleNamePart
        ], precedence = null, ruleNameDefinition = new RuleNameDefinition(parts, precedence);
        return ruleNameDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/quantifier.js
  var require_quantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.QUANTIFIER_RULE_NAME;
        ruleName = _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME;
        const optionalQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME;
        const oneOrMoreQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME;
        const zeroOrMoreQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), opacity = null, definitions = [
          optionalQuantifierRuleNameDefinition,
          oneOrMoreQuantifierRuleNameDefinition,
          zeroOrMoreQuantifierRuleNameDefinition
        ], quantifierRule = new QuantifierBNFRule(name, opacity, definitions);
        return quantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/definition.js
  var require_definition3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.PART_RULE_NAME;
        const partRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceRuleNamePart = _ruleName.default.fromRuleName(ruleName), oneOrMoreRuleNamePartsPart = _oneOrMoreParts.default.fromPart(partRuleNamePart), optionalPrecedenceRuleNamePartPart = _optionalPart.default.fromPart(precedenceRuleNamePart), parts = [
          oneOrMoreRuleNamePartsPart,
          optionalPrecedenceRuleNamePartPart
        ], precedence = null, definitionDefinition = new DefinitionDefinition(parts, precedence);
        return definitionDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/definition.js
  var require_definition4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.DEFINITION_RULE_NAME, definitionDefinition = _definition.default.fromNothing(), opacity = null, definitions = [
          definitionDefinition
        ], definitionRule = new DefinitionBNFRule(name, opacity, definitions);
        return definitionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/precedence.js
  var require_precedence2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {numberType} = _occamlexers.types;
    var {openBracket, closeBracket} = _occamlexers.specialSymbols;
    var PrecedenceDefinition = class extends _definition.default {
      static fromNothing() {
        const significantTokenType = numberType, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), numberSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), optionalNumberSignificantTokenTypePartPart = _optionalPart.default.fromPart(numberSignificantTokenTypePart), parts = [
          openBracketStringLiteralPart,
          optionalNumberSignificantTokenTypePartPart,
          closeBracketStringLiteralPart
        ], precedence = null, precedenceDefinition = new PrecedenceDefinition(parts, precedence);
        return precedenceDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/precedence.js
  var require_precedence3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrecedenceBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PRECEDENCE_RULE_NAME, precedenceDefinition = _precedence.default.fromNothing(), opacity = null, definitions = [
          precedenceDefinition
        ], precedenceRule = new PrecedenceBNFRule(name, opacity, definitions);
        return precedenceRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/definitions.js
  var require_definitions2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {verticalBar} = _occamlexers.specialSymbols;
    var DefinitionsDefinition = class extends _definition.default {
      static fromNothing() {
        let parts;
        const content = verticalBar, ruleName = _ruleNames.DEFINITION_RULE_NAME, definitionRuleNamePart = _ruleName.default.fromRuleName(ruleName), verticalBarStringLiteralPart = _stringLiteral.default.fromContent(content);
        parts = [
          verticalBarStringLiteralPart,
          definitionRuleNamePart
        ];
        const sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), zeroOrMoreSequenceOfPartsPart = _zeroOrMoreParts.default.fromPart(sequenceOfPartsPart);
        parts = [
          definitionRuleNamePart,
          zeroOrMoreSequenceOfPartsPart
        ];
        const precedence = null, definitionsDefinition = new DefinitionsDefinition(parts, precedence);
        return definitionsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/definitions.js
  var require_definitions3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionsBNFRule = class extends _rule.default {
      static fromNothing() {
        const definitionsDefinition = _definitions.default.fromNothing(), name = _ruleNames.DEFINITIONS_RULE_NAME, opacity = null, definitions = [
          definitionsDefinition
        ], definitionsRule = new DefinitionsBNFRule(name, opacity, definitions);
        return definitionsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/terminalPart.js
  var require_terminalPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalPartBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.TERMINAL_PART_RULE_NAME;
        ruleName = _ruleNames.EPSILON_RULE_NAME;
        const epsilonRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.WILDCARD_RULE_NAME;
        const wildcardRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.END_OF_LINE_RULE_NAME;
        const endOfLineRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.STRING_LITERAL_RULE_NAME;
        const stringLiteralRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NO_WHITESPACE_PART_RULE_NAME;
        const noWhitespacePartRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.REGULAR_EXPRESSION_RULE_NAME;
        const regularExpressionRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.START_OF_CONTENT_PART_RULE_NAME;
        const startOfContentPartRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME;
        const significantTokenTypeRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), opacity = null, definitions = [
          significantTokenTypeRuleNameDefinition,
          regularExpressionRuleNameDefinition,
          stringLiteralRuleNameDefinition,
          endOfLineRuleNameDefinition,
          wildcardRuleNameDefinition,
          epsilonRuleNameDefinition,
          noWhitespacePartRuleNameDefinition,
          startOfContentPartRuleNameDefinition
        ], terminalPartRule = new TerminalPartBNFRule(name, opacity, definitions);
        return terminalPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/choiceOfParts.js
  var require_choiceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {verticalBar, openBracket, closeBracket} = _occamlexers.specialSymbols;
    var ChoiceOfPartsDefinition = class extends _definition.default {
      static fromNothing() {
        let parts;
        const ruleName = _ruleNames.PART_CHOICE_RULE_NAME, verticalBarStringLiteralContent = verticalBar, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, partChoiceRuleNamePart = _ruleName.default.fromRuleName(ruleName), verticalBarStringLiteralPart = _stringLiteral.default.fromContent(verticalBarStringLiteralContent), openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent);
        parts = [
          verticalBarStringLiteralPart,
          partChoiceRuleNamePart
        ];
        const sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), oneOrMoreSequenceOfPartsPart = _oneOrMoreParts.default.fromPart(sequenceOfPartsPart);
        parts = [
          openBracketStringLiteralPart,
          partChoiceRuleNamePart,
          oneOrMoreSequenceOfPartsPart,
          closeBracketStringLiteralPart
        ];
        const precedence = null, choiceOfPartsDefinition = new ChoiceOfPartsDefinition(parts, precedence);
        return choiceOfPartsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/choiceOfParts.js
  var require_choiceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.CHOICE_OF_PARTS_RULE_NAME, choiceOfPartsDefinition = _choiceOfParts.default.fromNothing(), opacity = null, definitions = [
          choiceOfPartsDefinition
        ], choiceOfPartsRule = new ChoiceOfPartsBNFRule(name, opacity, definitions);
        return choiceOfPartsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/significantTokenType.js
  var require_significantTokenType3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantTokenTypeDefinition = class extends _definition.default {
      static fromSignificantTokenType(significantTokenType) {
        const significantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), parts = [
          significantTokenTypePart
        ], precedence = null, significantTokenTypeDefinition = new SignificantTokenTypeDefinition(parts, precedence);
        return significantTokenTypeDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/stringLiteral.js
  var require_stringLiteral5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {stringLiteralType} = _occamlexers.types;
    var StringLiteralBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = stringLiteralType, stringLiteralSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.STRING_LITERAL_RULE_NAME, opacity = null, definitions = [
          stringLiteralSignificantTokenTypeDefinition
        ], stringLiteralRule = new StringLiteralBNFRule(name, opacity, definitions);
        return stringLiteralRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal/ruleName.js
  var require_ruleName6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameNonTerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameNonTerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.RULE_NAME_RULE_NAME;
        const ruleNameRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME;
        const callAheadModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalCallAheadRuleNamePartPart = _optionalPart.default.fromPart(callAheadModifierRuleNamePart), parts = [
          ruleNameRuleNamePart,
          optionalCallAheadRuleNamePartPart
        ], precedence = null, ruleNameNonTerminalPartRuleDefinition = new RuleNameNonTerminalPartRuleDefinition(parts, precedence);
        return ruleNameNonTerminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/nonTerminalPart.js
  var require_nonTerminalPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleName1 = /* @__PURE__ */ _interop_require_default(require_ruleName6());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalPartBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.NON_TERMINAL_PART_RULE_NAME;
        ruleName = _ruleNames.CHOICE_OF_PARTS_RULE_NAME;
        const choiceOfPartsRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.SEQUENCE_OF_PARTS_RULE_NAME;
        const sequenceOfPartsRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), ruleNameNonTerminalPartRuleDefinition = _ruleName1.default.fromNothing(), opacity = null, definitions = [
          choiceOfPartsRuleNameDefinition,
          sequenceOfPartsRuleNameDefinition,
          ruleNameNonTerminalPartRuleDefinition
        ], nonTerminalPartRule = new NonTerminalPartBNFRule(name, opacity, definitions);
        return nonTerminalPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/sequenceOfParts.js
  var require_sequenceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {openBracket, closeBracket} = _occamlexers.specialSymbols;
    var SequenceOfPartsDefinition = class extends _definition.default {
      static fromNothing() {
        const ruleName = _ruleNames.PART_RULE_NAME, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, partRuleNamePart = _ruleName.default.fromRuleName(ruleName), openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), oneOrMorePartRuleNamePartsPart = _oneOrMoreParts.default.fromPart(partRuleNamePart), parts = [
          openBracketStringLiteralPart,
          partRuleNamePart,
          oneOrMorePartRuleNamePartsPart,
          closeBracketStringLiteralPart
        ], precedence = null, sequenceOfPartsDefinition = new SequenceOfPartsDefinition(parts, precedence);
        return sequenceOfPartsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/sequenceOfParts.js
  var require_sequenceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.SEQUENCE_OF_PARTS_RULE_NAME, sequenceOfPartsDefinition = _sequenceOfParts.default.fromNothing(), opacity = null, definitions = [
          sequenceOfPartsDefinition
        ], sequenceOfPartsRule = new SequenceOfPartsBNFRule(name, opacity, definitions);
        return sequenceOfPartsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/opacityModifierRule.js
  var require_opacityModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierRuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque, semiOpaque} = _occamlexers.specialSymbols;
    var OpacityModifierRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let content;
        content = opaque;
        const opaqueStringLiteralPart = _stringLiteral.default.fromContent(content);
        content = semiOpaque;
        const semiOpaqueStringLiteralPart = _stringLiteral.default.fromContent(content);
        const opaqueStringLiteralPartChoice = _partChoice.default.fromPart(opaqueStringLiteralPart), semiOpaqueStringLiteralPartChoice = _partChoice.default.fromPart(semiOpaqueStringLiteralPart), partChoices = [
          opaqueStringLiteralPartChoice,
          semiOpaqueStringLiteralPartChoice
        ], choiceOfOpaqueStringLiteralAndSemiOpaqueStringLiteralPartsPart = _choiceOfParts.default.fromPartChoices(partChoices), noWhitespacePart = _noWhitespace.default.fromNothing(), parts = [
          noWhitespacePart,
          choiceOfOpaqueStringLiteralAndSemiOpaqueStringLiteralPartsPart
        ], precedence = null, opacityModifierRuleDefinition = new OpacityModifierRuleDefinition(parts, precedence);
        return opacityModifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/opacityModifier.js
  var require_opacityModifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _opacityModifierRule = /* @__PURE__ */ _interop_require_default(require_opacityModifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OpacityModifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.OPACITY_MODIFIER_RULE_NAME, opacityModifierRuleDefinition = _opacityModifierRule.default.fromNothing(), opacity = null, definitions = [
          opacityModifierRuleDefinition
        ], opacityModifierRule = new OpacityModifierBNFRule(name, opacity, definitions);
        return opacityModifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/noWhitespacePart.js
  var require_noWhitespacePart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespacePartDefinition = class extends _definition.default {
      static fromNothing() {
        const content = noWhitespace, stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, noWhitespacePartDefinition = new NoWhitespacePartDefinition(parts, precedence);
        return noWhitespacePartDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/noWhitespacePart.js
  var require_noWhitespacePart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespacePartBNFRule = class extends _rule.default {
      static fromNothing() {
        const noWhitespacePartDefinition = _noWhitespacePart.default.fromNothing(), name = _ruleNames.NO_WHITESPACE_PART_RULE_NAME, opacity = null, definitions = [
          noWhitespacePartDefinition
        ], noWhitespacePartRule = new NoWhitespacePartBNFRule(name, opacity, definitions);
        return noWhitespacePartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/callAheadModifierRule.js
  var require_callAheadModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierRuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {ellipsis} = _occamlexers.specialSymbols;
    var CallAheadModifierRuleDefinition = class extends _definition.default {
      static fromNothing() {
        const content = ellipsis, noWhitespacePart = _noWhitespace.default.fromNothing(), stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          noWhitespacePart,
          stringLiteralPart
        ], precedence = null, callAheadModifierRuleDefinition = new CallAheadModifierRuleDefinition(parts, precedence);
        return callAheadModifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/callAheadModifier.js
  var require_callAheadModifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _callAheadModifierRule = /* @__PURE__ */ _interop_require_default(require_callAheadModifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CallAheadModifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME, callAheadModifierRuleDefinition = _callAheadModifierRule.default.fromNothing(), opacity = null, definitions = [
          callAheadModifierRuleDefinition
        ], callAheadModifierRule = new CallAheadModifierBNFRule(name, opacity, definitions);
        return callAheadModifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/regularExpression.js
  var require_regularExpression4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {regularExpressionType} = _occamlexers.types;
    var RegularExpressionBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = regularExpressionType, regularExpressionSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.REGULAR_EXPRESSION_RULE_NAME, opacity = null, definitions = [
          regularExpressionSignificantTokenTypeDefinition
        ], regularExpressionRule = new RegularExpressionBNFRule(name, opacity, definitions);
        return regularExpressionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/quantifierRule.js
  var require_quantifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierRuleDefinition = class extends _definition.default {
      static fromSpecialSymbol(specialSymbol) {
        const content = specialSymbol, noWhitespacePart = _noWhitespace.default.fromNothing(), stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          noWhitespacePart,
          stringLiteralPart
        ], precedence = null, quantifierRuleDefinition = new QuantifierRuleDefinition(parts, precedence);
        return quantifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/optionalQuantifier.js
  var require_optionalQuantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OptionalQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {questionMark} = _occamlexers.specialSymbols;
    var OptionalQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME, specialSymbol = questionMark, optionalQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          optionalQuantifierRuleDefinition
        ], optionalQuantifierRule = new OptionalQuantifierBNFRule(name, opacity, definitions);
        return optionalQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/startOfContentPart.js
  var require_startOfContentPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentPartDefinition = class extends _definition.default {
      static fromNothing() {
        const content = startOfContent, stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, startOfContentPartDefinition = new StartOfContentPartDefinition(parts, precedence);
        return startOfContentPartDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/startOfContentPart.js
  var require_startOfContentPart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentPartBNFRule = class extends _rule.default {
      static fromNothing() {
        const startOfContentPartDefinition = _startOfContentPart.default.fromNothing(), name = _ruleNames.START_OF_CONTENT_PART_RULE_NAME, opacity = null, definitions = [
          startOfContentPartDefinition
        ], startOfContentPartRule = new StartOfContentPartBNFRule(name, opacity, definitions);
        return startOfContentPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/oneOrMoreQuantifier.js
  var require_oneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OneOrMoreQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {plus} = _occamlexers.specialSymbols;
    var OneOrMoreQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME, specialSymbol = plus, oneOrMoreQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          oneOrMoreQuantifierRuleDefinition
        ], oneOrMoreQuantifierRule = new OneOrMoreQuantifierBNFRule(name, opacity, definitions);
        return oneOrMoreQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/zeroOrMoreQuantifier.js
  var require_zeroOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZeroOrMoreQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asterisk} = _occamlexers.specialSymbols;
    var ZeroOrMoreQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME, specialSymbol = asterisk, zeroOrMoreQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          zeroOrMoreQuantifierRuleDefinition
        ], zeroOrMoreQuantifierRule = new ZeroOrMoreQuantifierBNFRule(name, opacity, definitions);
        return zeroOrMoreQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/significantTokenType.js
  var require_significantTokenType4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {typeType} = _occamlexers.types;
    var SignificantTokenTypeBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = typeType, typeSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME, opacity = null, definitions = [
          typeSignificantTokenTypeDefinition
        ], significantTokenTypeRule = new SignificantTokenTypeBNFRule(name, opacity, definitions);
        return significantTokenTypeRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/rules.js
  var require_rules2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get ruleMapFromRules() {
        return ruleMapFromRules;
      },
      get rulesAsString() {
        return rulesAsString;
      },
      get rulesFromStartRuleAndRuleMap() {
        return rulesFromStartRuleAndRuleMap;
      },
      get startRuleFromRules() {
        return startRuleFromRules;
      },
      get startRuleFromRulesAndStartRuleName() {
        return startRuleFromRulesAndStartRuleName;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {first: first2, prune} = _necessary.arrayUtilities;
    function rulesAsString(rules, multiLine) {
      const maximumRuleNameLength = rules.reduce((maximumRuleNameLength2, rule) => {
        const ruleName = rule.getName(), opacity = rule.getOpacity();
        let ruleNameLength = ruleName.length;
        if (opacity !== null) {
          const opacityLength = opacity.length;
          ruleNameLength += opacityLength;
        }
        maximumRuleNameLength2 = Math.max(maximumRuleNameLength2, ruleNameLength);
        return maximumRuleNameLength2;
      }, 0), rulesString = rules.reduce((rulesString2, rule) => {
        const ruleString = rule.asString(maximumRuleNameLength, multiLine);
        rulesString2 += ruleString;
        return rulesString2;
      }, _constants.EMPTY_STRING).replace(/^\n\n/, _constants.EMPTY_STRING);
      return rulesString;
    }
    function ruleMapFromRules(rules) {
      const ruleMap = {};
      rules.forEach((rule) => {
        const ruleName = rule.getName();
        ruleMap[ruleName] = rule;
      });
      return ruleMap;
    }
    function startRuleFromRules(rules) {
      const firstRule = first2(rules), startRule = firstRule;
      return startRule;
    }
    function rulesFromStartRuleAndRuleMap(startRule, ruleMap) {
      const rules = Object.values(ruleMap), startRuleName = startRule.getName();
      startRule = prune(rules, (rule) => {
        const ruleName = rule.getName();
        if (ruleName !== startRuleName) {
          return true;
        }
      });
      rules.unshift(startRule);
      return rules;
    }
    function startRuleFromRulesAndStartRuleName(rules, startRuleName) {
      let startRule = rules.find((rule) => {
        const ruleName = rule.getName();
        if (ruleName === startRuleName) {
          return true;
        }
      }) || null;
      if (startRule === null) {
        startRule = startRuleFromRules(rules);
      }
      return startRule;
    }
    var _default = {
      rulesAsString,
      ruleMapFromRules,
      startRuleFromRules,
      rulesFromStartRuleAndRuleMap,
      startRuleFromRulesAndStartRuleName
    };
  });

  // node_modules/occam-parsers/lib/bnf/parser.js
  var require_parser2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFParser;
      }
    });
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser());
    var _name = /* @__PURE__ */ _interop_require_default(require_name4());
    var _part = /* @__PURE__ */ _interop_require_default(require_part2());
    var _rule1 = /* @__PURE__ */ _interop_require_default(require_rule5());
    var _error = /* @__PURE__ */ _interop_require_default(require_error3());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon4());
    var _document = /* @__PURE__ */ _interop_require_default(require_document4());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName4());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard3());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine8());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice4());
    var _quantifier = /* @__PURE__ */ _interop_require_default(require_quantifier2());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition4());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence3());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions3());
    var _terminalPart = /* @__PURE__ */ _interop_require_default(require_terminalPart2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts4());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral5());
    var _nonTerminalPart = /* @__PURE__ */ _interop_require_default(require_nonTerminalPart2());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts4());
    var _opacityModifier = /* @__PURE__ */ _interop_require_default(require_opacityModifier2());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart3());
    var _callAheadModifier = /* @__PURE__ */ _interop_require_default(require_callAheadModifier2());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression4());
    var _optionalQuantifier = /* @__PURE__ */ _interop_require_default(require_optionalQuantifier2());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart3());
    var _oneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_oneOrMoreQuantifier());
    var _zeroOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreQuantifier());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType4());
    var _rules = require_rules2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BNFParser = class {
      constructor(startRule, ruleMap) {
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      getStartRule() {
        return this.startRule;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      rulesFromTokens(tokens) {
        let rules;
        const node = this.parse(tokens);
        if (node === null) {
          throw new Error(`There is no node.`);
        }
        rules = node.generateRules(_rule.default);
        const rulesLength = rules.length;
        if (rulesLength === 0) {
          throw new Error(`There are no rules.`);
        }
        return rules;
      }
      static fromNothing() {
        const nameBNFRule = _name.default.fromNothing(), partBNFRule = _part.default.fromNothing(), ruleBNFRule = _rule1.default.fromNothing(), errorBNFRule = _error.default.fromNothing(), epsilonBNFRule = _epsilon.default.fromNothing(), documentBNFRule = _document.default.fromNothing(), ruleNameBNFRule = _ruleName.default.fromNothing(), wildcardBNFRule = _wildcard.default.fromNothing(), endOfLineBNFRule = _endOfLine.default.fromNothing(), partChoiceBNFRule = _partChoice.default.fromNothing(), quantifierBNFRule = _quantifier.default.fromNothing(), definitionBNFRule = _definition.default.fromNothing(), precedentsBNFRule = _precedence.default.fromNothing(), definitionsBNFRule = _definitions.default.fromNothing(), terminalPartBNFRule = _terminalPart.default.fromNothing(), choiceOfPartsBNFRule = _choiceOfParts.default.fromNothing(), stringLiteralBNFRule = _stringLiteral.default.fromNothing(), nonTerminalPartBNFRule = _nonTerminalPart.default.fromNothing(), sequenceOfPartsBNFRule = _sequenceOfParts.default.fromNothing(), opacityModifierBNFRule = _opacityModifier.default.fromNothing(), noWhitespacePartBNFRule = _noWhitespacePart.default.fromNothing(), regularExpressionBNFRule = _regularExpression.default.fromNothing(), callAheadModifierBNFRule = _callAheadModifier.default.fromNothing(), optionalQuantifierBNFRule = _optionalQuantifier.default.fromNothing(), startOfContentPartBNFRule = _startOfContentPart.default.fromNothing(), oneOrMoreQuantifierBNFRule = _oneOrMoreQuantifier.default.fromNothing(), zeroOrMoreQuantifierBNFRule = _zeroOrMoreQuantifier.default.fromNothing(), significantTokenTypeBNFRule = _significantTokenType.default.fromNothing(), rules = [
          documentBNFRule,
          ruleBNFRule,
          nameBNFRule,
          definitionsBNFRule,
          definitionBNFRule,
          partBNFRule,
          nonTerminalPartBNFRule,
          terminalPartBNFRule,
          startOfContentPartBNFRule,
          noWhitespacePartBNFRule,
          sequenceOfPartsBNFRule,
          choiceOfPartsBNFRule,
          partChoiceBNFRule,
          ruleNameBNFRule,
          significantTokenTypeBNFRule,
          regularExpressionBNFRule,
          stringLiteralBNFRule,
          precedentsBNFRule,
          endOfLineBNFRule,
          wildcardBNFRule,
          epsilonBNFRule,
          quantifierBNFRule,
          opacityModifierBNFRule,
          callAheadModifierBNFRule,
          optionalQuantifierBNFRule,
          oneOrMoreQuantifierBNFRule,
          zeroOrMoreQuantifierBNFRule,
          errorBNFRule
        ], startRule = (0, _rules.startRuleFromRules)(rules), ruleMap = (0, _rules.ruleMapFromRules)(rules), bnfParser = new _BNFParser(startRule, ruleMap);
        return bnfParser;
      }
    };
    var BNFParser = _BNFParser;
    __publicField(BNFParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
    __publicField(BNFParser, "defaultNonTerminalNode", null);
    __publicField(BNFParser, "bnf", _bnf.default);
    Object.assign(BNFParser.prototype, _parser.default);
  });

  // node_modules/occam-parsers/lib/basic/bnf.js
  var require_bnf3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    expressions  ::=  expression+ ;

    expression   ::=  term... "." ;
    
    term         ::=  term_ term~* ;
    
    operator     ::=  "+"
    
                   |  "-"
    
                   |  "*"
    
                   ;
    
    number       ::=  /\\d+/ ;
    
    term_        ::=  "(" term ")"
    
                   |  number
    
                   ;
    
    term~term    ::=  operator term ;
    
    term~        ::=  term~term ;

`;
    var _default = bnf;
  });

  // node_modules/occam-parsers/lib/utilities/parser.js
  var require_parser3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get parserFromRules() {
        return parserFromRules;
      },
      get parserFromRulesAndStartRuleName() {
        return parserFromRulesAndStartRuleName;
      },
      get rulesFromBNF() {
        return rulesFromBNF;
      }
    });
    var _occamlexers = require_lib3();
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser2());
    var _rules = require_rules2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var bnfLexer = _occamlexers.BNFLexer.fromNothing();
    var bnfParser = _parser.default.fromNothing();
    function rulesFromBNF(bnf) {
      const tokens = bnfLexer.tokensFromBNF(bnf), rules = bnfParser.rulesFromTokens(tokens);
      return rules;
    }
    function parserFromRules(Class, rules) {
      const startRule = (0, _rules.startRuleFromRules)(rules), ruleMap = (0, _rules.ruleMapFromRules)(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
    function parserFromRulesAndStartRuleName(Class, rules, startRuleName) {
      const startRule = (0, _rules.startRuleFromRulesAndStartRuleName)(rules, startRuleName), ruleMap = (0, _rules.ruleMapFromRules)(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
    var _default = {
      rulesFromBNF,
      parserFromRules,
      parserFromRulesAndStartRuleName
    };
  });

  // node_modules/occam-parsers/lib/common/parser.js
  var require_parser4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CommonParser;
      }
    });
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _parser1 = require_parser3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CommonParser = class {
      constructor(startRule, ruleMap) {
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      getStartRule() {
        return this.startRule;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      static fromNothing(Class) {
        const {bnf} = Class, rules = (0, _parser1.rulesFromBNF)(bnf), parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
      static fromBNF(Class, bnf) {
        const rules = (0, _parser1.rulesFromBNF)(bnf), parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
      static fromRules(Class, rules) {
        const parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
    };
    __publicField(CommonParser, "NonTerminalNodeMap", {});
    __publicField(CommonParser, "defaultNonTerminalNode", _nonTerminal.default);
    Object.assign(CommonParser.prototype, _parser.default);
  });

  // node_modules/occam-parsers/lib/basic/parser.js
  var require_parser5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BasicParser;
      }
    });
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf3());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BasicParser = class extends _parser.default {
      static fromNothing() {
        return _parser.default.fromNothing(_BasicParser);
      }
      static fromBNF(bnf) {
        return _parser.default.fromBNF(_BasicParser, bnf);
      }
      static fromRules(rules) {
        return _parser.default.fromRules(_BasicParser, rules);
      }
    };
    var BasicParser = _BasicParser;
    __publicField(BasicParser, "bnf", _bnf.default);
  });

  // node_modules/occam-parsers/lib/parts.js
  var require_parts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine6());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = {
      EpsilonPart: _epsilon.default,
      RuleNamePart: _ruleName.default,
      WildcardPart: _wildcard.default,
      EndOfLinePart: _endOfLine.default,
      OptionalPartPart: _optionalPart.default,
      ChoiceOfPartsPart: _choiceOfParts.default,
      StringLiteralPart: _stringLiteral.default,
      OneOrMorePartsPart: _oneOrMoreParts.default,
      SequenceOfPartsPart: _sequenceOfParts.default,
      ZeroOrMorePartsPart: _zeroOrMoreParts.default,
      RegularExpressionPart: _regularExpression.default,
      SignificantTokenTypePart: _significantTokenType.default
    };
  });

  // node_modules/occam-parsers/lib/index.js
  var require_lib4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BNFParser() {
        return _parser.default;
      },
      get BasicParser() {
        return _parser1.default;
      },
      get CommonParser() {
        return _parser2.default;
      },
      get Definition() {
        return _definition.default;
      },
      get EpsilonNode() {
        return _epsilon.default;
      },
      get NonTerminalNode() {
        return _nonTerminal.default;
      },
      get PartChoice() {
        return _partChoice.default;
      },
      get Parts() {
        return _parts.default;
      },
      get Rule() {
        return _rule.default;
      },
      get TerminalNode() {
        return _terminal.default;
      },
      get nodeMixins() {
        return _node.default;
      },
      get parserUtilities() {
        return _parser3.default;
      },
      get partTypes() {
        return _partTypes.default;
      },
      get rulesUtilities() {
        return _rules.default;
      }
    });
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser2());
    var _parser1 = /* @__PURE__ */ _interop_require_default(require_parser5());
    var _parser2 = /* @__PURE__ */ _interop_require_default(require_parser4());
    var _node = /* @__PURE__ */ _interop_require_default(require_node());
    var _rules = /* @__PURE__ */ _interop_require_default(require_rules2());
    var _parser3 = /* @__PURE__ */ _interop_require_default(require_parser3());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _parts = /* @__PURE__ */ _interop_require_default(require_parts());
    var _partTypes = /* @__PURE__ */ _interop_require_default(require_partTypes());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon());
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/bnf.js
  var require_bnf4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    stylesheet                 ::= ( media | ruleSet | keyframes | declaration | error )+ ;


    media                      ::= "@media" mediaQueries "{" ( ruleSet | declaration )* "}" ;
                                     
                                                              
    ruleSet                    ::=  selectors "{" declaration* "}" ;
    
    
    keyframes                  ::= "@keyframes" [identifier] "{" keyframe+ "}" ;
                                     
                                                              
    declaration                ::=  propertyName ":" propertyValues important? ";" ;


    error.                     ::=  . ;


    propertyValues             ::=  propertyValue ( "," propertyValue )* ;


    mediaQueries               ::=  mediaQuery ( ( "," | "or" ) mediaQuery )* ;
                                                              
                                                              
    selectors                  ::=  selector ( "," selector )* ;


    keyframe                   ::=  [percentage] "{" declaration+ "}" ;
    
    
    mediaQuery                 ::=  ( "not"? mediaType "and" )? mediaFeatures 
    
                                 |  "not"? mediaType
                                 
                                 ;


    mediaType                  ::=  "all" | "print" | "screen" | "speech" ;
                                                              
                                                              
    mediaFeatures              ::=  ( 
    
                                      mediaFeature 
                                      
                                      | 
                                      
                                      ( "(" "not" mediaFeature ")" ) 
                                      
                                    ) 
    
                                    ( 
                                    
                                      "and" 
                                    
                                      ( 
                                      
                                        mediaFeature 
                                        
                                        | 
                                        
                                        ( "(" "not" mediaFeature ")" ) 
                                        
                                      ) 
                                      
                                    )* 
                                    
                                 ;


    mediaFeature               ::=  "(" [identifier] ( ":" propertyValue )? ")" ;


    propertyValue              ::=  term ( ","? term )* ;


    propertyName               ::=  [identifier] ;


    important                  ::=  "!important" ;


    selector                   ::=  ( class | pseudoClass | pseudoElement | attribute )+ ;


    class                      ::=  "."<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    pseudoClass                ::=  ":"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    pseudoElement              ::=  "::"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    parenthesisedSelector      ::=  <NO_WHITESPACE>"(" selector <NO_WHITESPACE>")" ;


    attribute                  ::=  "["

                                       [identifier]

                                       (

                                         ( "=" | "~=" | "|=" )

                                         ( [identifier] | [string-literal] )

                                       )?

                                    "]"

                                 ;


    term                       ::=  [plus-or-minus]?
                                                       
                                    (
                                                     
                                      ( [percentage] | [frequency] | [fraction] | [length] | [angle] | [rems] | [ems] | [time] | [number] )
                                                     
                                      |
                                                     
                                      uri
                                                     
                                      |
                                                     
                                      function
                                                     
                                      |
                                                     
                                      [string-literal]+
                                                     
                                      |
                                                     
                                      [identifier]
                                                     
                                      |
                                                     
                                      [colour]
                                                     
                                    )
                                                       
                                 ;


    uri                        ::=  "url"<NO_WHITESPACE>"(" [string-literal] ")" ;


    function                   ::=  [identifier]<NO_WHITESPACE>"(" propertyValue ")" ;

`;
    var _default = bnf;
  });

  // node_modules/with-style/lib/css/parser.js
  var require_parser6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CSSParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CSSParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CSSParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CSSParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CSSParser, rules);
      }
    };
    var CSSParser = _CSSParser;
    __publicField(CSSParser, "bnf", _bnf.default);
  });

  // node_modules/occam-query/lib/ruleNames.js
  var require_ruleNames2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get END_INDEX_RULE_NAME() {
        return END_INDEX_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get INDEX_RULE_NAME() {
        return INDEX_RULE_NAME;
      },
      get INFINITE_DESCENT_RULE_NAME() {
        return INFINITE_DESCENT_RULE_NAME;
      },
      get RULE_NAME_RULE_NAME() {
        return RULE_NAME_RULE_NAME;
      },
      get SPREAD_RULE_NAME() {
        return SPREAD_RULE_NAME;
      },
      get START_INDEX_RULE_NAME() {
        return START_INDEX_RULE_NAME;
      },
      get SUB_EXPRESSION_RULE_NAME() {
        return SUB_EXPRESSION_RULE_NAME;
      },
      get TOKEN_TYPE_RULE_NAME() {
        return TOKEN_TYPE_RULE_NAME;
      },
      get UNIQUE_RULE_NAME() {
        return UNIQUE_RULE_NAME;
      }
    });
    var ERROR_RULE_NAME = "error";
    var INDEX_RULE_NAME = "index";
    var UNIQUE_RULE_NAME = "unique";
    var SPREAD_RULE_NAME = "spread";
    var END_INDEX_RULE_NAME = "endIndex";
    var RULE_NAME_RULE_NAME = "ruleName";
    var TOKEN_TYPE_RULE_NAME = "tokenType";
    var START_INDEX_RULE_NAME = "startIndex";
    var SUB_EXPRESSION_RULE_NAME = "subExpression";
    var INFINITE_DESCENT_RULE_NAME = "infiniteDescent";
  });

  // node_modules/occam-query/lib/utilities/node.js
  var require_node3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get endIndexFromSpreadNode() {
        return endIndexFromSpreadNode;
      },
      get errorNodesFromExpressionNode() {
        return errorNodesFromExpressionNode;
      },
      get indexFromIndexNode() {
        return indexFromIndexNode;
      },
      get indexFromSpreadNode() {
        return indexFromSpreadNode;
      },
      get infiniteDescentFromPathNode() {
        return infiniteDescentFromPathNode;
      },
      get pathNodeFromExpressionNode() {
        return pathNodeFromExpressionNode;
      },
      get pathNodeFromSubExpressionNode() {
        return pathNodeFromSubExpressionNode;
      },
      get ruleNamesFromPathNode() {
        return ruleNamesFromPathNode;
      },
      get selectorNodesFromPathNode() {
        return selectorNodesFromPathNode;
      },
      get spreadNodeFromExpressionNode() {
        return spreadNodeFromExpressionNode;
      },
      get spreadNodeFromSubExpressionNode() {
        return spreadNodeFromSubExpressionNode;
      },
      get startIndexFromSpreadNode() {
        return startIndexFromSpreadNode;
      },
      get subExpressionNodeFromExpressionNode() {
        return subExpressionNodeFromExpressionNode;
      },
      get subExpressionNodeFromSubExpressionNode() {
        return subExpressionNodeFromSubExpressionNode;
      },
      get tokenTypesFromPathNode() {
        return tokenTypesFromPathNode;
      },
      get uniqueFromSpreadNode() {
        return uniqueFromSpreadNode;
      }
    });
    var _ruleNames = require_ruleNames2();
    function indexFromIndexNode(indexNode) {
      const nonTerminalNode = indexNode, index = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const terminalNode = firstChildNode, content = terminalNode.getContent(), index2 = Number(content);
        return index2;
      });
      return index;
    }
    function ruleNamesFromPathNode(pathNode) {
      const selectorNodes = selectorNodesFromPathNode(pathNode), ruleNameNodes = selectorNodes.reduce((ruleNameNodes2, selectorNode) => {
        const nonTerminalNode = selectorNode, ruleNameNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          let ruleNameNode2 = null;
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameRuleNameRuleName = ruleName === _ruleNames.RULE_NAME_RULE_NAME;
          if (ruleNameRuleNameRuleName) {
            ruleNameNode2 = nonTerminalNode2;
          }
          return ruleNameNode2;
        });
        if (ruleNameNode !== null) {
          ruleNameNodes2.push(ruleNameNode);
        }
        return ruleNameNodes2;
      }, []), ruleNames = ruleNameNodes.map((ruleNameNode) => {
        const nonTerminalNode = ruleNameNode, ruleName = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          const terminalNode = firstChildNode, content = terminalNode.getContent(), ruleName2 = content;
          return ruleName2;
        });
        return ruleName;
      });
      return ruleNames;
    }
    function tokenTypesFromPathNode(pathNode) {
      const selectorNodes = selectorNodesFromPathNode(pathNode), tokenTypeNodes = selectorNodes.reduce((tokenTypeNodes2, selectorNode) => {
        const nonTerminalNode = selectorNode, tokenTypeNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          let tokenTypeNode2 = null;
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameTokenTypeRuleName = ruleName === _ruleNames.TOKEN_TYPE_RULE_NAME;
          if (ruleNameTokenTypeRuleName) {
            tokenTypeNode2 = nonTerminalNode2;
          }
          return tokenTypeNode2;
        });
        if (tokenTypeNode !== null) {
          tokenTypeNodes2.push(tokenTypeNode);
        }
        return tokenTypeNodes2;
      }, []), tokenTypes = tokenTypeNodes.map((tokenTypeNode) => {
        const nonTerminalNode = tokenTypeNode, tokenType = fromThirdChildNode(nonTerminalNode, (thirdChildNode) => {
          const terminalNode = thirdChildNode, content = terminalNode.getContent(), tokenType2 = content;
          return tokenType2;
        });
        return tokenType;
      });
      return tokenTypes;
    }
    function selectorNodesFromPathNode(pathNode) {
      let nonTerminalNode;
      nonTerminalNode = pathNode;
      const selectorsNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
        const selectorsNode2 = lastChildNode;
        return selectorsNode2;
      });
      nonTerminalNode = selectorsNode;
      const selectorNodes = nonTerminalNode.filterChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          return true;
        }
      });
      return selectorNodes;
    }
    function infiniteDescentFromPathNode(pathNode) {
      const nonTerminalNode = pathNode, infiniteDescent = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
        const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameInfiniteDescentRuleName = ruleName === _ruleNames.INFINITE_DESCENT_RULE_NAME, infiniteDescent2 = ruleNameInfiniteDescentRuleName;
        return infiniteDescent2;
      }) || false;
      return infiniteDescent;
    }
    function uniqueFromSpreadNode(spreadNode) {
      const nonTerminalNode = spreadNode, unique = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        let unique2 = false;
        const firstChildNodeNonTerminalNode = firstChildNode.isNonTerminalNode();
        if (firstChildNodeNonTerminalNode) {
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameUniqueRuleName = ruleName === _ruleNames.UNIQUE_RULE_NAME;
          if (ruleNameUniqueRuleName) {
            unique2 = true;
          }
        }
        return unique2;
      });
      return unique;
    }
    function indexFromSpreadNode(spreadNode) {
      let index = null;
      const nonTerminalNode = spreadNode, indexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameIndexRuleName = ruleName === _ruleNames.INDEX_RULE_NAME;
          if (ruleNameIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (indexNode !== null) {
        index = indexFromIndexNode(indexNode);
      }
      return index;
    }
    function endIndexFromSpreadNode(spreadNode) {
      let endIndex = Infinity;
      const nonTerminalNode = spreadNode, endIndexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameEndIndexRuleName = ruleName === _ruleNames.END_INDEX_RULE_NAME;
          if (ruleNameEndIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (endIndexNode !== null) {
        endIndex = indexFromIndexNode(endIndexNode);
      }
      return endIndex;
    }
    function startIndexFromSpreadNode(spreadNode) {
      let startIndex = 0;
      const nonTerminalNode = spreadNode, startIndexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameStartIndexRuleName = ruleName === _ruleNames.START_INDEX_RULE_NAME;
          if (ruleNameStartIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (startIndexNode !== null) {
        startIndex = indexFromIndexNode(startIndexNode);
      }
      return startIndex;
    }
    function pathNodeFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, pathNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const pathNode2 = firstChildNode;
        return pathNode2;
      });
      return pathNode;
    }
    function spreadNodeFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, spreadNode = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
        let spreadNode2 = null;
        const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSpreadRuleName = ruleName === _ruleNames.SPREAD_RULE_NAME;
        if (ruleNameSpreadRuleName) {
          spreadNode2 = secondChildNode;
        }
        return spreadNode2;
      }) || null;
      return spreadNode;
    }
    function errorNodesFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, errorNodes = nonTerminalNode.reduceChildNode((errorNodes2, childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameErrorRuleName = ruleName === _ruleNames.ERROR_RULE_NAME;
          if (ruleNameErrorRuleName) {
            const errorNode = nonTerminalNode2;
            errorNodes2.push(errorNode);
          }
        }
        return errorNodes2;
      }, []);
      return errorNodes;
    }
    function subExpressionNodeFromExpressionNode(expressionNode) {
      let subExpressionNode = null;
      const nonTerminalNode = expressionNode, multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        subExpressionNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
          let subExpressionNode2 = null;
          const nonTerminalNode2 = lastChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSubExpressionRuleName = ruleName === _ruleNames.SUB_EXPRESSION_RULE_NAME;
          if (ruleNameSubExpressionRuleName) {
            subExpressionNode2 = lastChildNode;
          }
          return subExpressionNode2;
        });
      }
      return subExpressionNode;
    }
    function pathNodeFromSubExpressionNode(subExpressionNode) {
      const nonTerminalNode = subExpressionNode, pathNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const pathNode2 = firstChildNode;
        return pathNode2;
      });
      return pathNode;
    }
    function spreadNodeFromSubExpressionNode(subExpressionNode) {
      let spreadNode = null;
      const nonTerminalNode = subExpressionNode, multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        spreadNode = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
          let spreadNode2 = null;
          const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSpreadRuleName = ruleName === _ruleNames.SPREAD_RULE_NAME;
          if (ruleNameSpreadRuleName) {
            spreadNode2 = secondChildNode;
          }
          return spreadNode2;
        }) || null;
      }
      return spreadNode;
    }
    function subExpressionNodeFromSubExpressionNode(subExpressionNode) {
      const nonTerminalNode = subExpressionNode;
      subExpressionNode = null;
      const multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        subExpressionNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
          let subExpressionNode2 = null;
          const nonTerminalNoe = lastChildNode, ruleName = nonTerminalNoe.getRuleName(), ruleNameSubExpressionRuleName = ruleName === _ruleNames.SUB_EXPRESSION_RULE_NAME;
          if (ruleNameSubExpressionRuleName) {
            subExpressionNode2 = lastChildNode;
          }
          return subExpressionNode2;
        });
      }
      return subExpressionNode;
    }
    function fromFirstChildNode(nonTerminalNode, callback) {
      let result;
      const firstIndex = 0;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === firstIndex) {
          const firstChildNode = childNode;
          result = callback(firstChildNode);
          return true;
        }
      });
      return result;
    }
    function fromSecondChildNode(nonTerminalNode, callback) {
      let result;
      const secondIndex = 1;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === secondIndex) {
          const firstChildNode = childNode;
          result = callback(firstChildNode);
          return true;
        }
      });
      return result;
    }
    function fromThirdChildNode(nonTerminalNode, callback) {
      let result;
      const thirdIndex = 2;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === thirdIndex) {
          const thirdChildNode = childNode;
          result = callback(thirdChildNode);
          return true;
        }
      });
      return result;
    }
    function fromLastChildNode(nonTerminalNode, callback) {
      let result;
      const multiplicity = nonTerminalNode.getMultiplicity(), lastIndex = multiplicity - 1;
      nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
        if (index === lastIndex) {
          const thirdChildNode = childNode;
          result = callback(thirdChildNode);
          return true;
        }
      });
      return result;
    }
  });

  // node_modules/occam-query/lib/path.js
  var require_path2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Path;
      }
    });
    var _node = require_node3();
    var Path = class {
      constructor(ruleNames, tokenTypes, infiniteDescent) {
        this.ruleNames = ruleNames;
        this.tokenTypes = tokenTypes;
        this.infiniteDescent = infiniteDescent;
      }
      getRuleNames() {
        return this.ruleNames;
      }
      getTokenTypes() {
        return this.tokenTypes;
      }
      isInfiniteDescent() {
        return this.infiniteDescent;
      }
      static fromPathNode(pathNode) {
        const ruleNames = (0, _node.ruleNamesFromPathNode)(pathNode), tokenTypes = (0, _node.tokenTypesFromPathNode)(pathNode), infiniteDescent = (0, _node.infiniteDescentFromPathNode)(pathNode), path = new Path(ruleNames, tokenTypes, infiniteDescent);
        return path;
      }
    };
  });

  // node_modules/occam-query/lib/utilities/array.js
  var require_array3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get clear() {
        return clear;
      },
      get fifth() {
        return fifth;
      },
      get first() {
        return first2;
      },
      get fourth() {
        return fourth;
      },
      get includes() {
        return includes;
      },
      get last() {
        return last;
      },
      get push() {
        return push;
      },
      get second() {
        return second;
      },
      get third() {
        return third;
      },
      get trim() {
        return trim;
      }
    });
    var _necessary = require_browser();
    var {clear, push, first: first2, second, third, fourth, fifth, last} = _necessary.arrayUtilities;
    function trim(array, startIndex, endIndex) {
      if (startIndex < 0) {
        const length = array.length;
        startIndex = length + startIndex;
        endIndex = length + endIndex;
      }
      if (endIndex !== Infinity) {
        const start2 = endIndex + 1;
        array.splice(start2);
      }
      const start = 0, deleteCount = startIndex;
      array.splice(start, deleteCount);
    }
    function includes(array, ...elements) {
      return elements.some((element) => array.includes(element));
    }
  });

  // node_modules/occam-query/lib/spread.js
  var require_spread = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Spread;
      }
    });
    var _necessary = require_browser();
    var _array = require_array3();
    var _node = require_node3();
    var {EXCLAMATION_MARK_CHARACTER} = _necessary.characters;
    var Spread = class {
      constructor(startIndex, endIndex, unique) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.unique = unique;
      }
      adjustNodes(nodes) {
        if (this.unique) {
          const nodesLength = nodes.length;
          if (nodesLength > 1) {
            (0, _array.clear)(nodes);
          }
        } else {
          (0, _array.trim)(nodes, this.startIndex, this.endIndex);
        }
      }
      static fromNothing() {
        const startIndex = 0, endIndex = Infinity, unique = false, spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
      static fromSpreadNode(spreadNode) {
        let startIndex = 0, endIndex = Infinity, unique = false;
        if (spreadNode !== null) {
          const index = (0, _node.indexFromSpreadNode)(spreadNode);
          if (index !== null) {
            startIndex = index;
            endIndex = index;
          } else {
            startIndex = (0, _node.startIndexFromSpreadNode)(spreadNode);
            endIndex = (0, _node.endIndexFromSpreadNode)(spreadNode);
          }
          unique = (0, _node.uniqueFromSpreadNode)(spreadNode);
        }
        const spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
      static fromSpreadExpression(spreadExpression) {
        let startIndex = 0, endIndex = Infinity, unique = false;
        if (spreadExpression !== null) {
          if (spreadExpression === EXCLAMATION_MARK_CHARACTER) {
            unique = true;
          } else {
            const regExp = /\[(-?\d+)?(\.\.\.)?(-?\d+)?]/, matches = spreadExpression.match(regExp), secondMatch = (0, _array.second)(matches) || null, thirdMatch = (0, _array.third)(matches) || null, fourthMatch = (0, _array.fourth)(matches) || null;
            if (secondMatch !== null) {
              startIndex = parseInt(secondMatch);
              if (thirdMatch === null) {
                endIndex = startIndex;
              }
            }
            if (fourthMatch !== null) {
              endIndex = parseInt(fourthMatch);
              if (thirdMatch === null) {
                startIndex = endIndex;
              }
            }
          }
        }
        const spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
    };
  });

  // node_modules/occam-query/lib/subExpression.js
  var require_subExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SubExpression;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path2());
    var _spread = /* @__PURE__ */ _interop_require_default(require_spread());
    var _node = require_node3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SubExpression = class {
      constructor(path, spread, subExpression) {
        this.path = path;
        this.spread = spread;
        this.subExpression = subExpression;
      }
      getPath() {
        return this.path;
      }
      getSpread() {
        return this.spread;
      }
      getSubExpression() {
        return this.subExpression;
      }
      getRuleNames() {
        return this.path.getRuleNames();
      }
      getTokenTypes() {
        return this.path.getTokenTypes();
      }
      isInfiniteDescent() {
        return this.path.isInfiniteDescent();
      }
      static fromSubExpressionNode(subExpressionNode) {
        let subExpression = null;
        if (subExpressionNode !== null) {
          const pathNode = (0, _node.pathNodeFromSubExpressionNode)(subExpressionNode), spreadNode = (0, _node.spreadNodeFromSubExpressionNode)(subExpressionNode);
          subExpressionNode = (0, _node.subExpressionNodeFromSubExpressionNode)(subExpressionNode);
          const path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode);
          subExpression = SubExpression.fromSubExpressionNode(subExpressionNode);
          subExpression = new SubExpression(path, spread, subExpression);
        }
        return subExpression;
      }
    };
  });

  // node_modules/occam-query/lib/expression/entries.js
  var require_entries4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:@|!|\\*|\\||\\/|\\[|\\]|\\.\\.\\.)"
      },
      {
        name: "^[a-zA-Z\\-]+"
      },
      {
        number: "^[0-9]+"
      },
      {
        unassigned: "^."
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-query/lib/expression/lexer.js
  var require_lexer6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _ExpressionLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_ExpressionLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_ExpressionLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_ExpressionLexer, entries);
      }
    };
    var ExpressionLexer = _ExpressionLexer;
    __publicField(ExpressionLexer, "entries", _entries.default);
    __publicField(ExpressionLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(ExpressionLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(ExpressionLexer, "EndOfLineCommentToken", null);
    __publicField(ExpressionLexer, "SingleLineCommentToken", null);
    __publicField(ExpressionLexer, "RegularExpressionToken", null);
    __publicField(ExpressionLexer, "EndOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "StartOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(ExpressionLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-query/lib/expression/bnf.js
  var require_bnf5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    expression       ::=  path spread? subExpression?   
    
                       |  error+ 
                                 
                       ;
  
    path             ::=  "/" infiniteDescent? selectors ;
    
    subExpression    ::=  path spread? subExpression?;

    infiniteDescent  ::=  "/" ;
    
    selectors        ::=  selector ( "|" selector )* ;

    spread           ::=  unique
    
                       |  "[" 

                          ( 
                            
                            ( startIndex "..." endIndex ) 
                            
                            | 
                            
                            ( startIndex "..." ) 
                            
                            | 
                            
                            ( "..." endIndex )
                             
                            | 
                            
                            index 
                            
                          )  
                          
                          "]" ;

    selector         ::=  ruleName | tokenType ;
                       
    ruleName         ::=  [name] | "*" ;
                       
    tokenType        ::=  "@"<NO_WHITESPACE>( [name] | "*" ) ;
                       
    startIndex       ::=  [number] ;
                       
    endIndex         ::=  [number] ;
                       
    index            ::=  [number] ;
                       
    unique           ::=  "!" ;
                       


    error.           ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-query/lib/expression/parser.js
  var require_parser7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _ExpressionParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_ExpressionParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_ExpressionParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_ExpressionParser, rules);
      }
    };
    var ExpressionParser = _ExpressionParser;
    __publicField(ExpressionParser, "bnf", _bnf.default);
  });

  // node_modules/occam-query/lib/expression.js
  var require_expression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Expression;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path2());
    var _spread = /* @__PURE__ */ _interop_require_default(require_spread());
    var _subExpression = /* @__PURE__ */ _interop_require_default(require_subExpression());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer6());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser7());
    var _node = require_node3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var expressionLexer = _lexer.default.fromNothing();
    var expressionParser = _parser.default.fromNothing();
    var Expression = class {
      constructor(path, spread, subExpression) {
        this.path = path;
        this.spread = spread;
        this.subExpression = subExpression;
      }
      getPath() {
        return this.path;
      }
      getSpread() {
        return this.spread;
      }
      getSubExpression() {
        return this.subExpression;
      }
      getRuleNames() {
        return this.path.getRuleNames();
      }
      getTokenTypes() {
        return this.path.getTokenTypes();
      }
      isInfiniteDescent() {
        return this.path.isInfiniteDescent();
      }
      static fromExpressionNode(expressionNode) {
        const pathNode = (0, _node.pathNodeFromExpressionNode)(expressionNode), spreadNode = (0, _node.spreadNodeFromExpressionNode)(expressionNode), subExpressionNode = (0, _node.subExpressionNodeFromExpressionNode)(expressionNode), path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode), subExpression = _subExpression.default.fromSubExpressionNode(subExpressionNode), expression = new Expression(path, spread, subExpression);
        return expression;
      }
      static fromExpressionString(expressionString) {
        let expression = null;
        const lexer = expressionLexer, parser = expressionParser, content = expressionString, tokens = lexer.tokenise(content), node = parser.parse(tokens);
        if (node !== null) {
          const expressionNode = node, errorNodes = (0, _node.errorNodesFromExpressionNode)(expressionNode), errorNodesLength = errorNodes.length;
          if (errorNodesLength === 0) {
            const pathNode = (0, _node.pathNodeFromExpressionNode)(expressionNode), spreadNode = (0, _node.spreadNodeFromExpressionNode)(expressionNode), subExpressionNode = (0, _node.subExpressionNodeFromExpressionNode)(expressionNode), path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode), subExpression = _subExpression.default.fromSubExpressionNode(subExpressionNode);
            expression = new Expression(path, spread, subExpression);
          }
        }
        return expression;
      }
    };
  });

  // node_modules/occam-query/lib/query.js
  var require_query = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Query;
      }
    });
    var _necessary = require_browser();
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    var _array = require_array3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {WILDCARD_CHARACTER} = _necessary.characters;
    var Query = class {
      constructor(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes) {
        this.spread = spread;
        this.subQuery = subQuery;
        this.ruleNames = ruleNames;
        this.tokenTypes = tokenTypes;
        this.maximumDepth = maximumDepth;
        this.infiniteDescent = infiniteDescent;
        this.intermediateNodes = intermediateNodes;
      }
      getSpread() {
        return this.sprea;
      }
      getSubQuery() {
        return this.subQuery;
      }
      getRuleNames() {
        return this.ruleNames;
      }
      getTokenTypes() {
        return this.tokenTypes;
      }
      getMaximumDepth() {
        return this.maximumDepth;
      }
      isInfiniteDescent() {
        return this.infiniteDescent;
      }
      getIntermediateNodes() {
        return this.intermediateNodes;
      }
      execute(node, depth = 0, maximumDepth = this.maximumDepth) {
        const nodes = [];
        this.clear();
        this.find(node, depth, maximumDepth);
        this.apply(nodes, depth, maximumDepth);
        return nodes;
      }
      clear() {
        (0, _array.clear)(this.intermediateNodes);
      }
      find(node, depth, maximumDepth) {
        if (depth > maximumDepth) {
          return;
        }
        const nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
        let found;
        if (nodeTerminalNode) {
          const terminalNode = node, types = this.tokenTypes, type = terminalNode.getType();
          found = (0, _array.includes)(types, type, WILDCARD_CHARACTER);
        }
        if (nodeNonTerminalNode) {
          const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName();
          found = (0, _array.includes)(this.ruleNames, ruleName, WILDCARD_CHARACTER);
        }
        if (found) {
          const intermediateNode = node;
          this.intermediateNodes.push(intermediateNode);
        }
        if (this.infiniteDescent) {
          if (nodeNonTerminalNode) {
            depth++;
            const nonTerminalNode = node;
            nonTerminalNode.forEachChildNode((childNode) => {
              this.find(childNode, depth, maximumDepth);
            });
          }
        }
      }
      apply(nodes, depth, maximumDepth) {
        this.spread.adjustNodes(this.intermediateNodes);
        if (this.subQuery === null) {
          (0, _array.push)(nodes, this.intermediateNodes);
        } else {
          this.intermediateNodes.forEach((intermediateNode) => {
            const intermediateNodeNonTerminalNode = intermediateNode.isNonTerminalNode();
            if (intermediateNodeNonTerminalNode) {
              depth++;
              const nonTerminalNode = intermediateNode;
              this.subQuery.clear();
              nonTerminalNode.forEachChildNode((childNode) => {
                this.subQuery.find(childNode, depth, maximumDepth);
              });
              this.subQuery.apply(nodes, depth, maximumDepth);
            }
          });
        }
      }
      static fromExpression(expression, maximumDepth = Infinity) {
        const spread = expression.getSpread(), subQuery = subQueryFromExpression(expression), ruleNames = expression.getRuleNames(), tokenTypes = expression.getTokenTypes(), infiniteDescent = expression.isInfiniteDescent(), intermediateNodes = [], query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        return query;
      }
      static fromSubExpression(subExpression) {
        const spread = subExpression.getSpread(), subQuery = subQueryFromSubExpression(subExpression), ruleNames = subExpression.getRuleNames(), tokenTypes = subExpression.getTokenTypes(), maximumDepth = Infinity, infiniteDescent = subExpression.isInfiniteDescent(), intermediateNodes = [], query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        return query;
      }
      static fromExpressionString(expressionString, maximumDepth = Infinity) {
        let query = null;
        const expression = _expression.default.fromExpressionString(expressionString);
        if (expression !== null) {
          const spread = expression.getSpread(), subQuery = subQueryFromExpression(expression), ruleNames = expression.getRuleNames(), tokenTypes = expression.getTokenTypes(), infiniteDescent = expression.isInfiniteDescent(), intermediateNodes = [];
          query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        }
        return query;
      }
    };
    function subQueryFromExpression(expression) {
      let subQuery = null;
      const subExpression = expression.getSubExpression();
      if (subExpression !== null) {
        const query = Query.fromSubExpression(subExpression);
        subQuery = query;
      }
      return subQuery;
    }
    function subQueryFromSubExpression(subExpression) {
      let subQuery = null;
      subExpression = subExpression.getSubExpression();
      if (subExpression !== null) {
        const query = Query.fromSubExpression(subExpression);
        subQuery = query;
      }
      return subQuery;
    }
  });

  // node_modules/occam-query/lib/utilities/query.js
  var require_query2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get queryByExpressionString() {
        return queryByExpressionString;
      }
    });
    var _query = /* @__PURE__ */ _interop_require_default(require_query());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function queryByExpressionString(node, expressionString, maximumDepth) {
      let nodes = null;
      const expression = _expression.default.fromExpressionString(expressionString);
      if (expression !== null) {
        const query = _query.default.fromExpression(expression, maximumDepth);
        nodes = query.execute(node);
      }
      return nodes;
    }
    var _default = {
      queryByExpressionString
    };
  });

  // node_modules/occam-query/lib/index.js
  var require_lib5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Expression() {
        return _expression.default;
      },
      get ExpressionLexer() {
        return _lexer.default;
      },
      get ExpressionParser() {
        return _parser.default;
      },
      get Query() {
        return _query.default;
      },
      get queryUtilities() {
        return _query1.default;
      }
    });
    var _query = /* @__PURE__ */ _interop_require_default(require_query());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    var _query1 = /* @__PURE__ */ _interop_require_default(require_query2());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer6());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/constants.js
  var require_constants5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CHARACTERS() {
        return CHARACTERS;
      },
      get CLASS_NAME_LENGTH() {
        return CLASS_NAME_LENGTH;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get HEAD() {
        return HEAD;
      },
      get STYLE() {
        return STYLE;
      },
      get TWO_SPACES() {
        return TWO_SPACES;
      }
    });
    var HEAD = "head";
    var STYLE = "style";
    var CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var TWO_SPACES = "  ";
    var EMPTY_STRING = "";
    var CLASS_NAME_LENGTH = 6;
  });

  // node_modules/with-style/lib/utilities/content.js
  var require_content2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "contentFromQueryNodeAndTokens", {
      enumerable: true,
      get: function() {
        return contentFromQueryNodeAndTokens;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants5();
    var {first: first2} = _necessary.arrayUtilities;
    function contentFromQueryNodeAndTokens(query, node, tokens) {
      let content = null;
      const nodes = query.execute(node), nodesLength = nodes.length;
      if (nodesLength > 0) {
        const firstNode = first2(nodes);
        node = firstNode;
        content = contentFromNodeAndTokens(node, tokens);
      }
      return content;
    }
    function contentFromNodeAndTokens(node, tokens) {
      const firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens), lastSignificantTokenIndex = node.getLastSignificantTokenIndex(tokens);
      let content = _constants.EMPTY_STRING;
      for (let index = firstSignificantTokenIndex; index <= lastSignificantTokenIndex; index++) {
        const token = tokens[index], tokenContent = token.getContent();
        content += tokenContent;
      }
      return content;
    }
  });

  // node_modules/with-style/lib/style/declaration.js
  var require_declaration = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Declaration;
      }
    });
    var _occamquery = require_lib5();
    var _constants = require_constants5();
    var _content = require_content2();
    var importantQuery = _occamquery.Query.fromExpressionString("/*/important");
    var propertyNameQuery = _occamquery.Query.fromExpressionString("/*/propertyName");
    var propertyValuesQuery = _occamquery.Query.fromExpressionString("/*/propertyValues");
    var Declaration = class {
      constructor(propertyValues, propertyName, important) {
        this.propertyValues = propertyValues;
        this.propertyName = propertyName;
        this.important = important;
      }
      getPropertyValues() {
        return this.propertyValues;
      }
      getPropertyName() {
        return this.propertyName;
      }
      getImportant() {
        return this.important;
      }
      matchPropertyName(propertyName) {
        const matches = this.propertyName === propertyName;
        return matches;
      }
      matchDeclaration(declaration) {
        const propertyName = declaration.getPropertyName(), matches = this.matchPropertyName(propertyName);
        return matches;
      }
      matchDeclarations(declarations) {
        const matches = declarations.someDeclaration((declaration) => {
          const matches2 = this.matchDeclaration(declaration);
          if (matches2) {
            return true;
          }
        });
        return matches;
      }
      asCSS(indent) {
        indent = indent + _constants.TWO_SPACES;
        const css = `${indent}${this.propertyName}: ${this.propertyValues}${this.important};
`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const propertyValuesContent = (0, _content.contentFromQueryNodeAndTokens)(propertyValuesQuery, node, tokens), propertyNameContent = (0, _content.contentFromQueryNodeAndTokens)(propertyNameQuery, node, tokens), importantContent = (0, _content.contentFromQueryNodeAndTokens)(importantQuery, node, tokens), propertyValues = propertyValuesContent, propertyName = propertyNameContent, important = importantContent === null ? _constants.EMPTY_STRING : ` ${importantContent}`, declaration = new Declaration(propertyValues, propertyName, important);
        return declaration;
      }
    };
  });

  // node_modules/with-style/lib/style/declarations.js
  var require_declarations = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Declarations;
      }
    });
    var _occamquery = require_lib5();
    var _necessary = require_browser();
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forwardsForEach, backwardsForEach} = _necessary.arrayUtilities;
    var declarationQuery = _occamquery.Query.fromExpressionString("/*/declaration");
    var Declarations = class {
      constructor(array) {
        this.array = array;
      }
      someDeclaration(callback) {
        return this.array.some(callback);
      }
      forwardsForEachDeclaration(callback) {
        forwardsForEach(this.array, callback);
      }
      backwardsForEachDeclaration(callback) {
        backwardsForEach(this.array, callback);
      }
      unshift(declarations) {
        declarations.backwardsForEachDeclaration((declaration) => {
          const matches = declaration.matchDeclarations(this);
          if (!matches) {
            this.array.unshift(declaration);
          }
        });
      }
      asCSS(className, indent) {
        const declarationsCSS = this.array.reduce((declarationsCSS2, declaration) => {
          const declarationCSS = declaration.asCSS(indent);
          declarationsCSS2 += declarationCSS;
          return declarationsCSS2;
        }, _constants.EMPTY_STRING), css = className === null ? declarationsCSS : `${indent}.${className} {
${declarationsCSS}${indent}}

`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarationNodes = declarationQuery.execute(node), array = declarationNodes.map((declarationNode) => {
          const node2 = declarationNode, declaration = _declaration.default.fromNodeAndTokens(node2, tokens);
          return declaration;
        }), declarations = new Declarations(array);
        return declarations;
      }
    };
  });

  // node_modules/with-style/lib/style/ruleSet.js
  var require_ruleSet = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleSet;
      }
    });
    var _occamquery = require_lib5();
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var selectorsQuery = _occamquery.Query.fromExpressionString("//selectors");
    var RuleSet = class {
      constructor(selectors, declarations) {
        this.selectors = selectors;
        this.declarations = declarations;
      }
      getSelectors() {
        return this.selectors;
      }
      getDeclarations() {
        return this.declarations;
      }
      unshift(ruleSet) {
        const declarations = ruleSet.getDeclarations();
        this.declarations.unshift(declarations);
      }
      findMatchingRuleSet(ruleSets) {
        const matchingRuleSet = ruleSets.find((ruleSet) => {
          const selectors = ruleSet.getSelectors(), selectorsMatch = selectors === this.selectors, ruleSetsMatch = selectorsMatch;
          if (ruleSetsMatch) {
            return true;
          }
        }) || null;
        return matchingRuleSet;
      }
      asCSS(className, indent) {
        let css = _constants.EMPTY_STRING;
        const declarationsCSS = this.declarations.asCSS(null, indent);
        if (declarationsCSS !== _constants.EMPTY_STRING) {
          css = `${indent}.${className}${this.selectors} {
${declarationsCSS}${indent}}

`;
        }
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const selectors = selectorsFromNodeAndTokens(node, tokens), declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSet = new RuleSet(selectors, declarations);
        return ruleSet;
      }
    };
    function selectorsFromNodeAndTokens(node, tokens) {
      const selectorsNodeContent = (0, _content.contentFromQueryNodeAndTokens)(selectorsQuery, node, tokens), selectors = `${selectorsNodeContent}`;
      return selectors;
    }
  });

  // node_modules/with-style/lib/style/ruleSets.js
  var require_ruleSets = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleSets;
      }
    });
    var _occamquery = require_lib5();
    var _ruleSet = /* @__PURE__ */ _interop_require_default(require_ruleSet());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ruleSetQuery = _occamquery.Query.fromExpressionString("/*/ruleSet");
    var RuleSets = class {
      constructor(array) {
        this.array = array;
      }
      unshift(ruleSets) {
        ruleSets.forEach((ruleSet) => {
          const matchingRuleSet = ruleSet.findMatchingRuleSet(this.array);
          matchingRuleSet === null ? this.array.unshift(ruleSet) : matchingRuleSet.unshift(ruleSet);
        });
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, ruleSet) => {
          const ruleSetCSS = ruleSet.asCSS(className, indent);
          css2 += ruleSetCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const ruleSetNodes = ruleSetQuery.execute(node), array = ruleSetNodes.map((ruleSetNode) => {
          const node2 = ruleSetNode, ruleSet = _ruleSet.default.fromNodeAndTokens(node2, tokens);
          return ruleSet;
        }), ruleSets = new RuleSets(array);
        return ruleSets;
      }
    };
  });

  // node_modules/with-style/lib/utilities/string.js
  var require_string4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "trim", {
      enumerable: true,
      get: function() {
        return trim;
      }
    });
    var _constants = require_constants5();
    function trim(string) {
      string = string.replace(/[\n\r]$/g, _constants.EMPTY_STRING);
      return string;
    }
  });

  // node_modules/with-style/lib/style/media.js
  var require_media = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Media;
      }
    });
    var _occamquery = require_lib5();
    var _ruleSets = /* @__PURE__ */ _interop_require_default(require_ruleSets());
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _string = require_string4();
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var queriesQuery = _occamquery.Query.fromExpressionString("/media/mediaQueries");
    var Media = class {
      constructor(declarations, ruleSets, queries) {
        this.declarations = declarations;
        this.ruleSets = ruleSets;
        this.queries = queries;
      }
      getDeclarations() {
        return this.declarations;
      }
      getRuleSets() {
        return this.ruleSets;
      }
      getQueries() {
        return this.queries;
      }
      asCSS(className, indent) {
        indent = indent + _constants.TWO_SPACES;
        let css = _constants.EMPTY_STRING;
        const ruleSetsCSS = this.ruleSets.asCSS(className, indent), declarationsCSS = this.declarations.asCSS(className, indent);
        let ruleSetsDeclarationsCSS = `${declarationsCSS}${ruleSetsCSS}`;
        if (ruleSetsDeclarationsCSS !== _constants.EMPTY_STRING) {
          ruleSetsDeclarationsCSS = (0, _string.trim)(ruleSetsDeclarationsCSS);
          css = `@media ${this.queries} {
${ruleSetsDeclarationsCSS}}

`;
        }
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), queries = queriesFromNodeAndTokens(node, tokens), media = new Media(declarations, ruleSets, queries);
        return media;
      }
    };
    function queriesFromNodeAndTokens(node, tokens) {
      const queriesNodeContent = (0, _content.contentFromQueryNodeAndTokens)(queriesQuery, node, tokens), queries = `${queriesNodeContent}`;
      return queries;
    }
  });

  // node_modules/with-style/lib/style/medias.js
  var require_medias = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Medias;
      }
    });
    var _occamquery = require_lib5();
    var _media = /* @__PURE__ */ _interop_require_default(require_media());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var mediaQuery = _occamquery.Query.fromExpressionString("/stylesheet/media");
    var Medias = class {
      constructor(array) {
        this.array = array;
      }
      unshift(medias) {
        medias.forEach((media) => {
          this.array.unshift(media);
        });
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, media) => {
          const mediaCSS = media.asCSS(className, indent);
          css2 += mediaCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const mediaNodes = mediaQuery.execute(node), array = mediaNodes.map((mediaNode) => {
          const node2 = mediaNode, media = _media.default.fromNodeAndTokens(node2, tokens);
          return media;
        }), medias = new Medias(array);
        return medias;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframe.js
  var require_keyframe = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframe;
      }
    });
    var _occamquery = require_lib5();
    var _necessary = require_browser();
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration());
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var percentageQuery = _occamquery.Query.fromExpressionString("/*/@percentage");
    var declarationQuery = _occamquery.Query.fromExpressionString("/*/declaration");
    var {first: first2} = _necessary.arrayUtilities;
    var Keyframe = class {
      constructor(percentage, declaration) {
        this.percentage = percentage;
        this.declaration = declaration;
      }
      getPercentage() {
        return this.percentage;
      }
      getDeclaration() {
        return this.declaration;
      }
      asCSS(indent) {
        const declarationCSS = this.declaration.asCSS(indent), css = `${indent}${this.percentage} { 
${declarationCSS}${indent}}
`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const percentageContent = (0, _content.contentFromQueryNodeAndTokens)(percentageQuery, node, tokens), percentage = percentageContent, declarationNodes = declarationQuery.execute(node), firstDeclarationNode = first2(declarationNodes), declarationNode = firstDeclarationNode;
        node = declarationNode;
        const declaration = _declaration.default.fromNodeAndTokens(node, tokens), keyframe = new Keyframe(percentage, declaration);
        return keyframe;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframes.js
  var require_keyframes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframes;
      }
    });
    var _occamquery = require_lib5();
    var _keyframe = /* @__PURE__ */ _interop_require_default(require_keyframe());
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var keyframeQuery = _occamquery.Query.fromExpressionString("/keyframes/keyframe");
    var identifierQuery = _occamquery.Query.fromExpressionString("/keyframes/@identifier");
    var Keyframes = class {
      constructor(array, identifier) {
        this.array = array;
        this.identifier = identifier;
      }
      getIdentifier() {
        return this.identifier;
      }
      asCSS(indent) {
        indent = indent + _constants.TWO_SPACES;
        const keyframesCSS = this.array.reduce((keyframesCSS2, keyframe) => {
          const keyframeCSS = keyframe.asCSS(indent);
          keyframesCSS2 += keyframeCSS;
          return keyframesCSS2;
        }, _constants.EMPTY_STRING), css = `@keyframes ${this.identifier} {
${keyframesCSS}}

`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const keyframeNodes = keyframeQuery.execute(node), array = keyframeNodes.map((keyframeNode) => {
          const node2 = keyframeNode, keyframe = _keyframe.default.fromNodeAndTokens(node2, tokens);
          return keyframe;
        }), identifierContent = (0, _content.contentFromQueryNodeAndTokens)(identifierQuery, node, tokens), identifier = identifierContent, keyframes = new Keyframes(array, identifier);
        return keyframes;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframess.js
  var require_keyframess = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframess;
      }
    });
    var _occamquery = require_lib5();
    var _keyframes = /* @__PURE__ */ _interop_require_default(require_keyframes());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var keyframesQuery = _occamquery.Query.fromExpressionString("/stylesheet/keyframes");
    var Keyframess = class {
      constructor(array) {
        this.array = array;
      }
      unshift(keyframess) {
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, keyframes) => {
          const keyframesCSS = keyframes.asCSS(indent);
          css2 += keyframesCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const keyframesNodes = keyframesQuery.execute(node), array = keyframesNodes.map((keyframesNode) => {
          const node2 = keyframesNode, keyframes = _keyframes.default.fromNodeAndTokens(node2, tokens);
          return keyframes;
        }), keyframess = new Keyframess(array);
        return keyframess;
      }
    };
  });

  // node_modules/with-style/lib/style.js
  var require_style = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Style;
      }
    });
    var _medias = /* @__PURE__ */ _interop_require_default(require_medias());
    var _ruleSets = /* @__PURE__ */ _interop_require_default(require_ruleSets());
    var _keyframess = /* @__PURE__ */ _interop_require_default(require_keyframess());
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Style = class {
      constructor(declarations, keyframess, ruleSets, medias) {
        this.declarations = declarations;
        this.keyframess = keyframess;
        this.ruleSets = ruleSets;
        this.medias = medias;
      }
      getDeclarations() {
        return this.declarations;
      }
      getKeyframess() {
        return this.keyframess;
      }
      getRuleSets() {
        return this.ruleSets;
      }
      getMedias() {
        return this.medias;
      }
      extends(superStyle) {
        const declarations = superStyle.getDeclarations(), keyframess = superStyle.getKeyframess(), ruleSets = superStyle.getRuleSets(), medias = superStyle.getMedias();
        this.unshift(declarations, keyframess, ruleSets, medias);
      }
      unshift(declarations, keyframess, ruleSets, medias) {
        this.declarations.unshift(declarations);
        this.keyframess.unshift(keyframess);
        this.ruleSets.unshift(ruleSets);
        this.medias.unshift(medias);
      }
      asCSS(className) {
        const indent = _constants.EMPTY_STRING, declarationsCSS = this.declarations.asCSS(className, indent), keyframessCSS = this.keyframess.asCSS(className, indent), ruleSetsCSS = this.ruleSets.asCSS(className, indent), mediasCSS = this.medias.asCSS(className, indent), css = `${declarationsCSS}${keyframessCSS}${ruleSetsCSS}${mediasCSS}`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarations = _declarations.default.fromNodeAndTokens(node, tokens), keyframess = _keyframess.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), medias = _medias.default.fromNodeAndTokens(node, tokens), style = new Style(declarations, keyframess, ruleSets, medias);
        return style;
      }
    };
  });

  // node_modules/with-style/lib/utilities/styles.js
  var require_styles = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _style = /* @__PURE__ */ _interop_require_default(require_style());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer5());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser6());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var cssLexer = _lexer.default.fromNothing();
    var cssParser = _parser.default.fromNothing();
    if (!globalThis.styleMap) {
      globalThis.styleMap = {};
    }
    var {styleMap} = globalThis;
    function renderStyle(style) {
      const headDOMElement = document.querySelector(_constants.HEAD), styleDOMElement = document.createElement(_constants.STYLE), innerHTML = `        
${style}
`;
      Object.assign(styleDOMElement, {
        innerHTML
      });
      headDOMElement.appendChild(styleDOMElement);
      return styleDOMElement;
    }
    function renderStyles() {
      const stylesCSS = retrieveStylesCSS(), style = stylesCSS;
      renderStyle(style);
    }
    function generateStyle(args, className, superStyle = null) {
      const strings = args.shift(), content = strings.reduce((content2, string, index) => {
        const arg = args[index] || null;
        content2 = arg === null ? `${content2}${string}` : `${content2}${string}${arg}`;
        return content2;
      }, _constants.EMPTY_STRING), tokens = cssLexer.tokenise(content), node = cssParser.parse(tokens), style = _style.default.fromNodeAndTokens(node, tokens);
      if (superStyle !== null) {
        style.extends(superStyle);
      }
      styleMap[className] = style;
    }
    function retrieveStyle(className) {
      const style = styleMap[className] || null;
      return style;
    }
    var _default = {
      renderStyle,
      renderStyles,
      generateStyle,
      retrieveStyle
    };
    function retrieveStylesCSS() {
      const classNames = Object.keys(styleMap), stylesCSS = classNames.reduce((stylesCSS2, className) => {
        const style = retrieveStyle(className), styleCSS = style.asCSS(className);
        stylesCSS2 += styleCSS;
        return stylesCSS2;
      }, _constants.EMPTY_STRING);
      return stylesCSS;
    }
  });

  // node_modules/with-style/lib/utilities/className.js
  var require_className = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get generateClassName() {
        return generateClassName;
      },
      get retrieveClassName() {
        return retrieveClassName;
      }
    });
    var _constants = require_constants5();
    var length = _constants.CLASS_NAME_LENGTH;
    var characters = _constants.CHARACTERS;
    var charactersLength = characters.length;
    var classNames = [];
    function generateClassName() {
      let className = _constants.EMPTY_STRING;
      for (let count = 0; count < length; count++) {
        const index = Math.floor(Math.random() * charactersLength), character = characters[index];
        className += character;
      }
      const classNamesIncludesClassName = classNames.includes(className);
      if (!classNamesIncludesClassName) {
        classNames.push(className);
      } else {
        className = generateClassName();
      }
      return className;
    }
    function retrieveClassName(element) {
      const {className} = element.reactFunction || element.reactComponent.constructor;
      return className;
    }
    var _default = {
      generateClassName,
      retrieveClassName
    };
  });

  // node_modules/with-style/lib/index.js
  var require_lib6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CSSLexer() {
        return _lexer.default;
      },
      get CSSParser() {
        return _parser.default;
      },
      get classNameUtilities() {
        return _className.default;
      },
      get stylesUtilities() {
        return _styles.default;
      },
      get tagNames() {
        return _tagNames.default;
      }
    });
    var _tagNames = /* @__PURE__ */ _interop_require_default(require_tagNames());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer5());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser6());
    var _styles = /* @__PURE__ */ _interop_require_default(require_styles());
    var _className = /* @__PURE__ */ _interop_require_default(require_className());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-with-style/lib/utilities/class.js
  var require_class = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isClass", {
      enumerable: true,
      get: function() {
        return isClass;
      }
    });
    var _easy = require_lib();
    function isClass(argument) {
      return isSubclassOf(argument, _easy.Element);
    }
    function isSubclassOf(argument, Class) {
      const subclassOf = argument.prototype instanceof Class;
      return subclassOf;
    }
  });

  // node_modules/easy-with-style/lib/constants.js
  var require_constants6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CLASS_NAME", {
      enumerable: true,
      get: function() {
        return CLASS_NAME;
      }
    });
    var CLASS_NAME = "className";
  });

  // node_modules/easy-with-style/lib/withStyle.js
  var require_withStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easy = require_lib();
    var _withstyle = require_lib6();
    var _class = require_class();
    var _constants = require_constants6();
    var {generateClassName} = _withstyle.classNameUtilities;
    var {renderStyle, renderStyles, generateStyle, retrieveStyle} = _withstyle.stylesUtilities;
    function withStyle(ClassOrFunction) {
      return function() {
        const args = [
          ...arguments
        ];
        let {className = null} = ClassOrFunction;
        const superStyle = retrieveStyle(className);
        className = generateClassName();
        generateStyle(args, className, superStyle);
        const ClassOrFunctionClass = (0, _class.isClass)(ClassOrFunction);
        if (ClassOrFunctionClass) {
          const Class = ClassOrFunction;
          ClassOrFunction = class extends Class {
            static fromClass(_Class, properties, ...remainingArguments) {
              properties = appendClassNameToProperties(className, properties);
              return Class.fromClass(_Class, properties, ...remainingArguments);
            }
          };
        } else {
          const Function2 = ClassOrFunction;
          ClassOrFunction = (properties) => {
            properties = appendClassNameToProperties(className, properties);
            return Function2(properties);
          };
        }
        Object.assign(ClassOrFunction, {
          className
        });
        return ClassOrFunction;
      };
    }
    Object.assign(withStyle, {
      renderStyle,
      renderStyles
    });
    var _default = withStyle;
    _withstyle.tagNames.forEach((tagName) => {
      Object.defineProperty(withStyle, tagName, {
        get: () => function() {
          const args = [
            ...arguments
          ], className = generateClassName();
          generateStyle(args, className);
          const Function2 = (properties) => {
            properties = appendClassNameToProperties(className, properties);
            return _easy.React.createElement(tagName, properties);
          };
          Object.assign(Function2, {
            className
          });
          return Function2;
        }
      });
    });
    function appendClassNameToProperties(className, properties) {
      properties = properties.hasOwnProperty(_constants.CLASS_NAME) ? properties : {
        ...properties,
        className
      };
      return properties;
    }
  });

  // node_modules/easy-with-style/lib/index.js
  var require_lib7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _withStyle = /* @__PURE__ */ _interop_require_default(require_withStyle());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = _withStyle.default;
  });

  // node_modules/easy-layout/lib/constants.js
  var require_constants7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CURSOR", {
      enumerable: true,
      get: function() {
        return CURSOR;
      }
    });
    var CURSOR = "cursor";
  });

  // node_modules/easy-layout/lib/cursors.js
  var require_cursors = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AUTO_CURSOR() {
        return AUTO_CURSOR;
      },
      get COL_RESIZE_CURSOR() {
        return COL_RESIZE_CURSOR;
      },
      get POINTER_CURSOR() {
        return POINTER_CURSOR;
      },
      get ROW_RESIZE_CURSOR() {
        return ROW_RESIZE_CURSOR;
      }
    });
    var AUTO_CURSOR = "auto";
    var POINTER_CURSOR = "pointer";
    var COL_RESIZE_CURSOR = "col-resize";
    var ROW_RESIZE_CURSOR = "row-resize";
  });

  // node_modules/easy-layout/lib/cursor.js
  var require_cursor = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get autoCursor() {
        return autoCursor;
      },
      get columnResizeCursor() {
        return columnResizeCursor;
      },
      get default() {
        return _default;
      },
      get pointerCursor() {
        return pointerCursor;
      },
      get resetCursor() {
        return resetCursor;
      },
      get rowResizeCursor() {
        return rowResizeCursor;
      }
    });
    var _easy = require_lib();
    var _constants = require_constants7();
    var _cursors = require_cursors();
    var body = new _easy.Body();
    var previousCursor;
    function autoCursor() {
      const cursor = _cursors.AUTO_CURSOR;
      updateCursor(cursor);
    }
    function resetCursor() {
      setCursor(previousCursor);
    }
    function pointerCursor() {
      const cursor = _cursors.POINTER_CURSOR;
      updateCursor(cursor);
    }
    function rowResizeCursor() {
      const cursor = _cursors.ROW_RESIZE_CURSOR;
      updateCursor(cursor);
    }
    function columnResizeCursor() {
      const cursor = _cursors.COL_RESIZE_CURSOR;
      updateCursor(cursor);
    }
    var _default = {
      autoCursor,
      resetCursor,
      pointerCursor,
      rowResizeCursor,
      columnResizeCursor
    };
    function setCursor(cursor) {
      const css = {
        cursor
      };
      body.css(css);
    }
    function updateCursor(cursor) {
      const currentCursor = getCurrentCursor();
      if (currentCursor !== cursor) {
        previousCursor = currentCursor;
        setCursor(cursor);
      }
    }
    function getCurrentCursor() {
      const currentCursor = body.css(_constants.CURSOR) || _cursors.AUTO_CURSOR;
      return currentCursor;
    }
  });

  // node_modules/easy-layout/lib/div/row.js
  var require_row = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RowDiv = class extends _easy.Element {
    };
    __publicField(RowDiv, "tagName", "div");
    __publicField(RowDiv, "defaultProperties", {
      className: "row"
    });
    var _default = (0, _easywithstyle.default)(RowDiv)`

  display: flex;
  flex-grow: 1;

`;
  });

  // node_modules/easy-layout/lib/div/rows.js
  var require_rows = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RowsDiv = class extends _easy.Element {
    };
    __publicField(RowsDiv, "tagName", "div");
    __publicField(RowsDiv, "defaultProperties", {
      className: "rows"
    });
    var _default = (0, _easywithstyle.default)(RowsDiv)`

  display: flex;
  flex-grow: 1;
  flex-direction: column;

`;
  });

  // node_modules/easy-layout/lib/div/column.js
  var require_column = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ColumnDiv = class extends _easy.Element {
    };
    __publicField(ColumnDiv, "tagName", "div");
    __publicField(ColumnDiv, "defaultProperties", {
      className: "column"
    });
    var _default = (0, _easywithstyle.default)(ColumnDiv)`

  display: flex;
  flex-grow: 1;

`;
  });

  // node_modules/easy-layout/lib/div/columns.js
  var require_columns = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ColumnsDiv = class extends _easy.Element {
    };
    __publicField(ColumnsDiv, "tagName", "div");
    __publicField(ColumnsDiv, "defaultProperties", {
      className: "columns"
    });
    var _default = (0, _easywithstyle.default)(ColumnsDiv)`

  display: flex;
  flex-grow: 1;
  flex-direction: row;

`;
  });

  // node_modules/easy-drag-and-drop/lib/constants.js
  var require_constants8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "START_DRAGGING_DELAY", {
      enumerable: true,
      get: function() {
        return START_DRAGGING_DELAY;
      }
    });
    var START_DRAGGING_DELAY = 175;
  });

  // node_modules/easy-drag-and-drop/lib/utilities/reference.js
  var require_reference = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "checkDragElementIgnoresDropElement", {
      enumerable: true,
      get: function() {
        return checkDragElementIgnoresDropElement;
      }
    });
    function checkDragElementIgnoresDropElement(dragElement, dropElement) {
      const reference = dropElement.getReference(), references = dragElement.getReferences(), referencesIncludesReference = references.includes(reference), dragElementIgnoresDropElement = !referencesIncludesReference;
      return dragElementIgnoresDropElement;
    }
  });

  // node_modules/easy-drag-and-drop/lib/utilities/event.js
  var require_event2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get mouseLeftFromEvent() {
        return mouseLeftFromEvent;
      },
      get mouseTopFromEvent() {
        return mouseTopFromEvent;
      }
    });
    function mouseTopFromEvent(event) {
      const {pageY} = event, mouseTop = pageY;
      return mouseTop;
    }
    function mouseLeftFromEvent(event) {
      const {pageX} = event, mouseLeft = pageX;
      return mouseLeft;
    }
  });

  // node_modules/easy-drag-and-drop/lib/customEventTypes.js
  var require_customEventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DRAG_CUSTOM_EVENT_TYPE() {
        return DRAG_CUSTOM_EVENT_TYPE;
      },
      get DRAG_OUT_CUSTOM_EVENT_TYPE() {
        return DRAG_OUT_CUSTOM_EVENT_TYPE;
      },
      get DRAG_OVER_CUSTOM_EVENT_TYPE() {
        return DRAG_OVER_CUSTOM_EVENT_TYPE;
      },
      get DROP_CUSTOM_EVENT_TYPE() {
        return DROP_CUSTOM_EVENT_TYPE;
      },
      get START_DRAG_CUSTOM_EVENT_TYPE() {
        return START_DRAG_CUSTOM_EVENT_TYPE;
      },
      get STOP_DRAG_CUSTOM_EVENT_TYPE() {
        return STOP_DRAG_CUSTOM_EVENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var DRAG_CUSTOM_EVENT_TYPE = "drag";
    var DROP_CUSTOM_EVENT_TYPE = "drop";
    var DRAG_OUT_CUSTOM_EVENT_TYPE = "drag-out";
    var DRAG_OVER_CUSTOM_EVENT_TYPE = "drag-over";
    var STOP_DRAG_CUSTOM_EVENT_TYPE = "stop-drag";
    var START_DRAG_CUSTOM_EVENT_TYPE = "start-drag";
    var _default = {
      DRAG_CUSTOM_EVENT_TYPE,
      DROP_CUSTOM_EVENT_TYPE,
      DRAG_OUT_CUSTOM_EVENT_TYPE,
      DRAG_OVER_CUSTOM_EVENT_TYPE,
      STOP_DRAG_CUSTOM_EVENT_TYPE,
      START_DRAG_CUSTOM_EVENT_TYPE
    };
  });

  // node_modules/easy-drag-and-drop/lib/mixins/drag.js
  var require_drag = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _easy = require_lib();
    var _constants = require_constants8();
    var _reference = require_reference();
    var _event = require_event2();
    var _customEventTypes = require_customEventTypes();
    var {ESCAPE_KEY_CODE} = _necessary.keyCodes;
    var {LEFT_MOUSE_BUTTON} = _easy.mouseButtons;
    function getDragElement2() {
      const {dragElement} = globalThis;
      return dragElement;
    }
    function setDragElement(dragElement) {
      Object.assign(globalThis, {
        dragElement
      });
    }
    function resetDragElement() {
      const dragElement = null;
      setDragElement(dragElement);
    }
    Object.assign(globalThis, {
      getDragElement: getDragElement2,
      setDragElement,
      resetDragElement
    });
    resetDragElement();
    function enableDrag() {
      const timeout = null, topOffset = null, leftOffset = null, dragEnabled = true, startMouseTop = null, startMouseLeft = null;
      this.onMouseDown(mouseDownHandler, this);
      this.updateState({
        timeout,
        topOffset,
        leftOffset,
        dragEnabled,
        startMouseTop,
        startMouseLeft
      });
    }
    function disableDrag() {
      const dragEnabled = false;
      this.updateState({
        dragEnabled
      });
      this.offMouseDown(mouseDownHandler, this);
    }
    function onCustomDrag(dragCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, customHandler = dragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDrag(dragCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, customHandler = dragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomStopDrag(stopDragCustomHandler, element) {
      const customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE, customHandler = stopDragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomStopDrag(stopDragCustomHandler, element) {
      const customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE, customHandler = stopDragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomStartDrag(startDragCustomHandler, element) {
      const customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE, customHandler = startDragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomStartDrag(startDragCustomHandler, element) {
      const customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE, customHandler = startDragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function isDragEnabled() {
      const {dragEnabled = false} = this.getState();
      return dragEnabled;
    }
    function isDragging() {
      const dragging = this.hasClass("dragging");
      return dragging;
    }
    function startDrag(event, element, mouseTop, mouseLeft) {
      const bounds = this.getBounds(), boundsTop = bounds.getTop(), boundsLeft = bounds.getLeft(), boundsRight = bounds.getRight(), boundsBottom = bounds.getBottom(), boundsWidth = boundsRight - boundsLeft, boundsHeight = boundsBottom - boundsTop, topOffset = Math.floor(boundsHeight / 2), leftOffset = Math.floor(boundsWidth / 2), dragElement = this, startMouseTop = mouseTop, startMouseLeft = mouseLeft, customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE;
      _easy.window.onKeyDown(keyDownHandler, this);
      _easy.window.onMouseMove(mouseMoveHandler, this);
      this.addClass("dragging");
      setDragElement(dragElement);
      this.setTopOffset(topOffset);
      this.setLeftOffset(leftOffset);
      this.setStartMouseTop(startMouseTop);
      this.setStartMouseLeft(startMouseLeft);
      this.callCustomHandlers(customEventType, event, element);
      this.drag(event, element, mouseTop, mouseLeft);
    }
    function stopDrag(event, element, aborted) {
      const dropElement = getDropElement(), customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE;
      this.removeClass("dragging");
      _easy.window.offKeyDown(keyDownHandler, this);
      _easy.window.offMouseMove(mouseMoveHandler, this);
      const done = () => {
        this.callCustomHandlersAsync(customEventType, event, element, dropElement, aborted, () => {
          resetDragElement();
        });
      };
      if (dropElement !== null) {
        let dragElement = this;
        const dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
          dragElement = null;
        }
        dropElement.drop(event, element, dragElement, aborted, done);
      } else {
        done();
      }
    }
    function drag(event, element, mouseTop, mouseLeft) {
      const scrollTop = _easy.window.getScrollTop(), scrollLeft = _easy.window.getScrollLeft(), topOffset = this.getTopOffset(), leftOffset = this.getLeftOffset(), startMouseTop = this.getStartMouseTop(), startMouseLeft = this.getStartMouseLeft(), customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, relativeMouseTop = mouseTop - startMouseTop, relativeMouseLeft = mouseLeft - startMouseLeft;
      let top = startMouseTop + relativeMouseTop - topOffset - scrollTop, left = startMouseLeft + relativeMouseLeft - leftOffset - scrollLeft;
      top = `${top}px`;
      left = `${left}px`;
      const css = {
        top,
        left
      };
      this.css(css);
      this.callCustomHandlers(customEventType, event, element, relativeMouseTop, relativeMouseLeft);
    }
    function startWaitingToDrag(event, element, mouseTop, mouseLeft) {
      let timeout = this.getTimeout();
      if (timeout === null) {
        timeout = setTimeout(() => {
          this.resetTimeout();
          this.startDrag(event, element, mouseTop, mouseLeft);
        }, _constants.START_DRAGGING_DELAY);
        this.updateTimeout(timeout);
      }
    }
    function stopWaitingToDrag() {
      const timeout = this.getTimeout();
      if (timeout !== null) {
        clearTimeout(timeout);
        this.resetTimeout();
      }
    }
    function getTimeout() {
      const {timeout} = this.getState();
      return timeout;
    }
    function resetTimeout() {
      const timeout = null;
      this.updateTimeout(timeout);
    }
    function updateTimeout(timeout) {
      this.updateState({
        timeout
      });
    }
    function getTopOffset() {
      const {topOffset} = this.getState();
      return topOffset;
    }
    function getLeftOffset() {
      const {leftOffset} = this.getState();
      return leftOffset;
    }
    function getStartMouseTop() {
      const {startMouseTop} = this.getState();
      return startMouseTop;
    }
    function getStartMouseLeft() {
      const {startMouseLeft} = this.getState();
      return startMouseLeft;
    }
    function setTopOffset(topOffset) {
      this.updateState({
        topOffset
      });
    }
    function setLeftOffset(leftOffset) {
      this.updateState({
        leftOffset
      });
    }
    function setStartMouseTop(startMouseTop) {
      this.updateState({
        startMouseTop
      });
    }
    function setStartMouseLeft(startMouseLeft) {
      this.updateState({
        startMouseLeft
      });
    }
    var _default = {
      enableDrag,
      disableDrag,
      onCustomDrag,
      offCustomDrag,
      onCustomStopDrag,
      offCustomStopDrag,
      onCustomStartDrag,
      offCustomStartDrag,
      isDragEnabled,
      isDragging,
      startDrag,
      stopDrag,
      drag,
      startWaitingToDrag,
      stopWaitingToDrag,
      getTimeout,
      resetTimeout,
      updateTimeout,
      getTopOffset,
      getLeftOffset,
      getStartMouseTop,
      getStartMouseLeft,
      setTopOffset,
      setLeftOffset,
      setStartMouseTop,
      setStartMouseLeft
    };
    function keyDownHandler(event, element) {
      const {keyCode} = event, escapeKey = keyCode === ESCAPE_KEY_CODE, aborted = true;
      if (escapeKey) {
        this.stopDrag(event, element, aborted);
        event.stopPropagation();
      }
    }
    function mouseUpHandler(event, element) {
      const dragging = this.isDragging(), aborted = false;
      dragging ? this.stopDrag(event, element, aborted) : this.stopWaitingToDrag();
      event.stopPropagation();
      _easy.window.offBlur(mouseUpHandler, this);
      _easy.window.offMouseUp(mouseUpHandler, this);
    }
    function mouseDownHandler(event, element) {
      const {button} = event;
      if (button === LEFT_MOUSE_BUTTON) {
        const dragging = this.isDragging();
        if (!dragging) {
          const mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
          this.startWaitingToDrag(event, element, mouseTop, mouseLeft);
        }
      }
      event.stopPropagation();
      _easy.window.onBlur(mouseUpHandler, this);
      _easy.window.onMouseUp(mouseUpHandler, this);
    }
    function mouseMoveHandler(event, element) {
      const dragging = this.isDragging();
      if (dragging) {
        const mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
        this.drag(event, element, mouseTop, mouseLeft);
      }
      event.stopPropagation();
    }
  });

  // node_modules/easy-drag-and-drop/lib/mixins/drop.js
  var require_drop = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _reference = require_reference();
    var _customEventTypes = require_customEventTypes();
    function getDropElement2() {
      const {dropElement} = globalThis;
      return dropElement;
    }
    function setDropElement(dropElement) {
      Object.assign(globalThis, {
        dropElement
      });
    }
    function resetDropElement() {
      const dropElement = null;
      setDropElement(dropElement);
    }
    Object.assign(globalThis, {
      getDropElement: getDropElement2,
      setDropElement,
      resetDropElement
    });
    resetDropElement();
    function drop(event, element, dragElement, aborted, done) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE;
      this.callCustomHandlersAsync(customEventType, event, element, dragElement, aborted, done);
    }
    function dragOut(event, element, dragElement) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE;
      this.callCustomHandlers(customEventType, event, element, dragElement);
    }
    function dragOver(event, element, dragElement) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE;
      this.callCustomHandlers(customEventType, event, element, dragElement);
    }
    function enableDrop() {
      this.onMouseOut(mouseOutHandler, this);
      this.onMouseOver(mouseOverHandler, this);
    }
    function disableDrop() {
      this.offMouseOut(mouseOutHandler, this);
      this.offMouseOver(mouseOverHandler, this);
    }
    function onCustomDrop(dropCustomHandler, element) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE, customHandler = dropCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDrop(dropCustomHandler, element) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE, customHandler = dropCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomDragOut(dragOutCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE, customHandler = dragOutCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDragOut(dragOutCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE, customHandler = dragOutCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomDragOver(dragOverCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE, customHandler = dragOverCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDragOver(dragOverCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE, customHandler = dragOverCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    var _default = {
      drop,
      dragOut,
      dragOver,
      enableDrop,
      disableDrop,
      onCustomDrop,
      offCustomDrop,
      onCustomDragOut,
      offCustomDragOut,
      onCustomDragOver,
      offCustomDragOver
    };
    function mouseOutHandler(event, element) {
      const dragElement = getDragElement();
      if (dragElement !== null) {
        resetDropElement();
        this.dragOut(event, element, dragElement);
      }
      event.stopPropagation();
    }
    function mouseOverHandler(event, element) {
      const dragElement = getDragElement();
      if (dragElement !== null) {
        const dropElement = this, dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
          return;
        }
        setDropElement(dropElement);
        this.dragOver(event, element, dragElement);
      }
      event.stopPropagation();
    }
  });

  // node_modules/easy-drag-and-drop/lib/element/drag.js
  var require_drag2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _drag = /* @__PURE__ */ _interop_require_default(require_drag());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DragElement = class extends _easy.Element {
      getReferences() {
        const {references = []} = this.properties;
        return references;
      }
      didMount() {
        this.enableDrag();
      }
      willUnmount() {
        this.disableDrag();
      }
    };
    __publicField(DragElement, "ignoredProperties", [
      "references"
    ]);
    Object.assign(DragElement.prototype, _drag.default);
    var _default = (0, _easywithstyle.default)(DragElement)`

  .dragging {
    z-index: 1;
    position: fixed;
    pointer-events: none;
  }
  
`;
  });

  // node_modules/easy-drag-and-drop/lib/element/drop.js
  var require_drop2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DropElement;
      }
    });
    var _easy = require_lib();
    var _drop = /* @__PURE__ */ _interop_require_default(require_drop());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DropElement = class extends _easy.Element {
      getReference() {
        const {reference = null} = this.properties;
        return reference;
      }
      didMount() {
        this.enableDrop();
      }
      willUnmount() {
        this.disableDrop();
      }
    };
    __publicField(DropElement, "ignoredProperties", [
      "reference"
    ]);
    Object.assign(DropElement.prototype, _drop.default);
  });

  // node_modules/easy-drag-and-drop/lib/index.js
  var require_lib8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DragElement() {
        return _drag1.default;
      },
      get DropElement() {
        return _drop1.default;
      },
      get customEventTypes() {
        return _customEventTypes.default;
      },
      get dragMixins() {
        return _drag.default;
      },
      get dropMixins() {
        return _drop.default;
      }
    });
    var _drag = /* @__PURE__ */ _interop_require_default(require_drag());
    var _drop = /* @__PURE__ */ _interop_require_default(require_drop());
    var _drag1 = /* @__PURE__ */ _interop_require_default(require_drag2());
    var _drop1 = /* @__PURE__ */ _interop_require_default(require_drop2());
    var _customEventTypes = /* @__PURE__ */ _interop_require_default(require_customEventTypes());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-layout/lib/div/sizeable.js
  var require_sizeable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SizeableDiv = class extends _easy.Element {
    };
    __publicField(SizeableDiv, "tagName", "div");
    __publicField(SizeableDiv, "defaultProperties", {
      className: "sizeable"
    });
    var _default = (0, _easywithstyle.default)(SizeableDiv)`

  display: flex;
  
`;
  });

  // node_modules/easy-layout/lib/div/splitter.js
  var require_splitter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _easydraganddrop = require_lib8();
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SplitterDiv = class extends _easy.Element {
      stopDragCustomHandler = (event, element, dropElement, aborted, done) => {
        (0, _cursor.resetCursor)();
        done();
      };
      mouseOutHandler = (event, element) => {
        (0, _cursor.resetCursor)();
      };
      getSizeableDiv() {
        let sizeableDiv;
        const nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement(), nextSiblingElementSizeableDiv = nextSiblingElement instanceof _sizeable.default, previousSiblingElementSizeableDiv = previousSiblingElement instanceof _sizeable.default;
        if (nextSiblingElementSizeableDiv) {
          sizeableDiv = nextSiblingElement;
        }
        if (previousSiblingElementSizeableDiv) {
          sizeableDiv = previousSiblingElement;
        }
        return sizeableDiv;
      }
      getDirection() {
        let direction;
        const nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement(), nextSiblingElementSizeableDiv = nextSiblingElement instanceof _sizeable.default, previousSiblingElementSizeableDiv = previousSiblingElement instanceof _sizeable.default;
        if (nextSiblingElementSizeableDiv) {
          direction = 1;
        }
        if (previousSiblingElementSizeableDiv) {
          direction = -1;
        }
        return direction;
      }
      getReferences() {
        const references = [];
        return references;
      }
      enable() {
        const dragEnabled = this.isDragEnabled();
        if (!dragEnabled) {
          this.enableDrag();
          this.onCustomDrag(this.dragCustomHandler);
          this.onCustomStopDrag(this.stopDragCustomHandler);
          this.onCustomStartDrag(this.startDragCustomHandler);
        }
      }
      disable() {
        const dragEnabled = this.isDragEnabled();
        if (dragEnabled) {
          this.offCustomStartDrag(this.startDragCustomHandler);
          this.offCustomStopDrag(this.stopDragCustomHandler);
          this.offCustomDrag(this.dragCustomHandler);
          this.disableDrag();
        }
      }
      isDisabled() {
        const dragEnabled = this.isDragEnabled(), disabled = !dragEnabled;
        return disabled;
      }
      didMount() {
        const {disabled = false} = this.properties;
        if (!disabled) {
          this.enable();
        }
        this.onMouseOver(this.mouseOverHandler);
        this.onMouseOut(this.mouseOutHandler);
      }
      willUnmount() {
        const disabled = this.isDisabled();
        this.offMouseOut(this.mouseOutHandler);
        this.offMouseOver(this.mouseOverHandler);
        if (!disabled) {
          this.disable();
        }
      }
      initialise() {
        this.setInitialState();
      }
    };
    __publicField(SplitterDiv, "tagName", "div");
    __publicField(SplitterDiv, "ignoredProperties", [
      "disabled"
    ]);
    __publicField(SplitterDiv, "defaultProperties", {
      className: "splitter"
    });
    Object.assign(SplitterDiv.prototype, _easydraganddrop.dragMixins);
    var _default = (0, _easywithstyle.default)(SplitterDiv)`

  flex-shrink: 0;

`;
  });

  // node_modules/easy-layout/lib/div/splitter/vertical.js
  var require_vertical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VerticalSplitter = class extends _splitter.default {
      startDragCustomHandler = (event, element) => {
        const sizeableDiv = this.getSizeableDiv(), sizeableDivWidth = sizeableDiv.getWidth(), previousSizeableDivWidth = sizeableDivWidth;
        this.setPreviousSizeableDivWidth(previousSizeableDivWidth);
        this.setCursor();
      };
      dragCustomHandler = (event, element, relativeMouseTop, relativeMouseLeft) => {
        const direction = this.getDirection(), sizeableDiv = this.getSizeableDiv(), previousSizeableDivWidth = this.getPreviousSizeableDivWidth(), sizeableDivWidth = previousSizeableDivWidth - direction * relativeMouseLeft, width = sizeableDivWidth;
        sizeableDiv.setWidth(width);
      };
      mouseOverHandler = (event, element) => {
        this.setCursor();
      };
      setCursor() {
        const disabled = this.isDisabled();
        if (!disabled) {
          (0, _cursor.columnResizeCursor)();
        }
      }
      getPreviousSizeableDivWidth() {
        const {previousSizeableDivWidth} = this.getState();
        return previousSizeableDivWidth;
      }
      setPreviousSizeableDivWidth(previousSizeableDivWidth) {
        this.updateState({
          previousSizeableDivWidth
        });
      }
      setInitialState() {
        const previousSizeableDivWidth = null;
        this.setState({
          previousSizeableDivWidth
        });
      }
    };
    __publicField(VerticalSplitter, "defaultProperties", {
      className: "vertical"
    });
    var _default = (0, _easywithstyle.default)(VerticalSplitter)`

  width: 1rem;

`;
  });

  // node_modules/easy-layout/lib/div/splitter/horizontal.js
  var require_horizontal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var HorizontalSplitter = class extends _splitter.default {
      startDragCustomHandler = (event, element) => {
        const sizeableDiv = this.getSizeableDiv(), sizeableDivHeight = sizeableDiv.getHeight(), previousSizeableDivHeight = sizeableDivHeight;
        this.setPreviousSizeableDivHeight(previousSizeableDivHeight);
        this.setCursor();
      };
      dragCustomHandler = (event, element, relativeMouseTop, relativeMouseLeft) => {
        const direction = this.getDirection(), sizeableDiv = this.getSizeableDiv(), previousSizeableDivHeight = this.getPreviousSizeableDivHeight(), sizeableDivHeight = previousSizeableDivHeight - direction * relativeMouseTop, height = sizeableDivHeight;
        sizeableDiv.setHeight(height);
      };
      mouseOverHandler = (event, element) => {
        this.setCursor();
      };
      setCursor() {
        const disabled = this.isDisabled();
        if (!disabled) {
          (0, _cursor.rowResizeCursor)();
        }
      }
      getPreviousSizeableDivHeight() {
        const {previousSizeableDivHeight} = this.getState();
        return previousSizeableDivHeight;
      }
      setPreviousSizeableDivHeight(previousSizeableDivHeight) {
        this.updateState({
          previousSizeableDivHeight
        });
      }
      setInitialState() {
        const previousSizeableDivHeight = null;
        this.setState({
          previousSizeableDivHeight
        });
      }
    };
    __publicField(HorizontalSplitter, "defaultProperties", {
      className: "horizontal"
    });
    var _default = (0, _easywithstyle.default)(HorizontalSplitter)`

  height: 1rem;

`;
  });

  // node_modules/easy-layout/lib/index.js
  var require_lib9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ColumnDiv() {
        return _column.default;
      },
      get ColumnsDiv() {
        return _columns.default;
      },
      get HorizontalSplitterDiv() {
        return _horizontal.default;
      },
      get RowDiv() {
        return _row.default;
      },
      get RowsDiv() {
        return _rows.default;
      },
      get SizeableDiv() {
        return _sizeable.default;
      },
      get SplitterDiv() {
        return _splitter.default;
      },
      get VerticalSplitterDiv() {
        return _vertical.default;
      },
      get cursor() {
        return _cursor.default;
      }
    });
    var _cursor = /* @__PURE__ */ _interop_require_default(require_cursor());
    var _row = /* @__PURE__ */ _interop_require_default(require_row());
    var _rows = /* @__PURE__ */ _interop_require_default(require_rows());
    var _column = /* @__PURE__ */ _interop_require_default(require_column());
    var _columns = /* @__PURE__ */ _interop_require_default(require_columns());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable());
    var _vertical = /* @__PURE__ */ _interop_require_default(require_vertical());
    var _horizontal = /* @__PURE__ */ _interop_require_default(require_horizontal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/constants.js
  var require_constants9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BREAK_MESSAGE() {
        return BREAK_MESSAGE;
      },
      get DEBUG_LEVEL() {
        return DEBUG_LEVEL;
      },
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ERROR_LEVEL() {
        return ERROR_LEVEL;
      },
      get INFO_LEVEL() {
        return INFO_LEVEL;
      },
      get LEVELS() {
        return LEVELS;
      },
      get LEVEL_MAXIMUM_LENGTH() {
        return LEVEL_MAXIMUM_LENGTH;
      },
      get SINGLE_SPACE() {
        return SINGLE_SPACE;
      },
      get TRACE_LEVEL() {
        return TRACE_LEVEL;
      },
      get WARNING_LEVEL() {
        return WARNING_LEVEL;
      }
    });
    var _necessary = require_browser();
    var {TRACE_LEVEL, DEBUG_LEVEL, INFO_LEVEL, WARNING_LEVEL, ERROR_LEVEL} = _necessary.levels;
    var LEVELS = [
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL
    ];
    var EMPTY_STRING = "";
    var SINGLE_SPACE = " ";
    var DOUBLE_SPACE = "  ";
    var BREAK_MESSAGE = ":: BREAK ::";
    var LEVEL_MAXIMUM_LENGTH = 7;
  });

  // node_modules/occam-languages/lib/log.js
  var require_log = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Log;
      }
    });
    var _constants = require_constants9();
    var [TRACE_LEVEL, DEBUG_LEVEL, INFO_LEVEL, WARNING_LEVEL, ERROR_LEVEL] = _constants.LEVELS;
    var Log = class {
      constructor(messages, logLevel, follow) {
        this.messages = messages;
        this.logLevel = logLevel;
        this.follow = follow;
      }
      getMessages() {
        return this.messages;
      }
      getLogLevel() {
        return this.logLevel;
      }
      getFollow() {
        return this.follow;
      }
      trace(message) {
        const level = TRACE_LEVEL;
        this.write(level, message);
      }
      debug(message) {
        const level = DEBUG_LEVEL;
        this.write(level, message);
      }
      info(message) {
        const level = INFO_LEVEL;
        this.write(level, message);
      }
      warning(message) {
        const level = WARNING_LEVEL;
        this.write(level, message);
      }
      error(message) {
        const level = ERROR_LEVEL;
        this.write(level, message);
      }
      write(level, message, filePath = null, lineIndex = null) {
        const levelIndex = _constants.LEVELS.indexOf(level), logLevelIndex = _constants.LEVELS.indexOf(this.logLevel);
        if (levelIndex < logLevelIndex) {
          return;
        }
        message = formatMessage(level, message, filePath, lineIndex);
        this.follow ? console.log(message) : this.messages.push(message);
      }
      static fromNothing() {
        const messages = null, logLevel = TRACE_LEVEL, follow = true, log = new Log(messages, logLevel, follow);
        return log;
      }
      static fromFollowAndLogLevel(follow, logLevel) {
        const messages = follow ? null : [], log = new Log(messages, logLevel, follow);
        return log;
      }
    };
    function formatMessage(level, message, filePath, lineIndex) {
      let formattedMessage = _constants.EMPTY_STRING;
      const leftPaddedLevel = leftPadLevel(level), upperCaseLeftPaddedLevel = leftPaddedLevel.toUpperCase();
      formattedMessage += `${upperCaseLeftPaddedLevel}: `;
      if (filePath !== null) {
        formattedMessage += `${filePath} `;
      }
      if (lineIndex !== null) {
        formattedMessage += `[${lineIndex}] `;
      }
      if (filePath !== null || lineIndex !== null) {
        formattedMessage += `- `;
      }
      formattedMessage += message;
      message = formattedMessage;
      return message;
    }
    function leftPadLevel(level) {
      const maximumLength = _constants.LEVEL_MAXIMUM_LENGTH, leftPaddedLevel = leftPad(level, maximumLength);
      return leftPaddedLevel;
    }
    function leftPad(string, maximumLength) {
      const stringLength = string.length, length = maximumLength - stringLength, indent = _constants.SINGLE_SPACE.repeat(length), leftPaddedString = `${indent}${string}`;
      return leftPaddedString;
    }
  });

  // node_modules/occam-languages/lib/element.js
  var require_element4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Element;
      }
    });
    var Element = class {
      constructor(context2, string, node) {
        this.context = context2;
        this.string = string;
        this.node = node;
      }
      getContext() {
        return this.context;
      }
      getString() {
        return this.string;
      }
      getNode() {
        return this.node;
      }
      setContext(context2) {
        this.context = context2;
      }
      setString(string) {
        this.string = string;
      }
      setNode(node) {
        this.node = node;
      }
      async break(context2) {
        await context2.break(this.node);
      }
      matchNode(node) {
        return this.node.match(node);
      }
    };
  });

  // node_modules/occam-languages/lib/context.js
  var require_context = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Context;
      }
    });
    var _constants = require_constants9();
    var Context = class {
      constructor(context2) {
        this.context = context2;
      }
      getContext() {
        return this.context;
      }
      getDepth() {
        let depth = this.context.getDepth();
        depth++;
        return depth;
      }
      getReleaseContext() {
        return this.context.getReleaseContext();
      }
      nodesAsString(node) {
        return this.context.nodesAsString(node);
      }
      nodeAsString(node) {
        return this.context.nodeAsString(node);
      }
      trace(message) {
        const level = _constants.TRACE_LEVEL;
        this.writeToLog(level, message);
      }
      debug(message) {
        const level = _constants.DEBUG_LEVEL;
        this.writeToLog(level, message);
      }
      info(message) {
        const level = _constants.INFO_LEVEL;
        this.writeToLog(level, message);
      }
      warning(message) {
        const level = _constants.WARNING_LEVEL;
        this.writeToLog(level, message);
      }
      error(message) {
        const level = _constants.ERROR_LEVEL;
        this.writeToLog(level, message);
      }
      writeToLog(level, message) {
        const depth = this.getDepth(), indent = _constants.DOUBLE_SPACE.repeat(depth);
        message = `${indent}${message}`;
        const releaseContext = this.getReleaseContext();
        releaseContext.writeToLog(level, message);
      }
      async break(node) {
        await this.context.break(node);
      }
      static fromNothing(Class, ...remainingArguments) {
        let context2 = remainingArguments.pop();
        context2 = new Class(context2, ...remainingArguments);
        return context2;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/lineIndex.js
  var require_lineIndex = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lineIndexFromNodeAndTokens", {
      enumerable: true,
      get: function() {
        return lineIndexFromNodeAndTokens;
      }
    });
    function lineIndexFromNodeAndTokens(node, tokens) {
      let lineIndex = 0;
      const firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens);
      tokens.some((token, tokenIndex) => {
        const tokenEndOfLineToken = token.isEndOfLineToken();
        if (tokenEndOfLineToken) {
          lineIndex += 1;
        }
        if (tokenIndex === firstSignificantTokenIndex) {
          return true;
        }
      });
      return lineIndex;
    }
  });

  // node_modules/occam-languages/lib/utilities/node.js
  var require_node4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get nodeAsString() {
        return nodeAsString;
      },
      get nodesAsString() {
        return nodesAsString;
      }
    });
    var _constants = require_constants9();
    function nodeAsString(node, tokens) {
      let string;
      tokens = nodeAsTokens(node, tokens);
      string = tokensAsString(tokens);
      string = trimString(string);
      return string;
    }
    function nodesAsString(nodes, tokens) {
      const string = nodes.reduce((string2, node) => {
        const nodeString = nodeAsString(node, tokens);
        string2 = string2 === null ? nodeString : `${string2}, ${nodeString}`;
        return string2;
      }, null);
      return string;
    }
    var _default = {
      nodeAsString,
      nodesAsString
    };
    function trimString(string) {
      string = string.replace(/\s+$/, _constants.EMPTY_STRING);
      return string;
    }
    function tokensAsString(tokens) {
      const string = tokens.reduce((string2, token) => {
        const content = token.getContent();
        string2 = `${string2}${content}`;
        return string2;
      }, _constants.EMPTY_STRING);
      return string;
    }
    function nodeAsTokens(node, tokens) {
      const nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        const terminalNode = node;
        tokens = terminalNodeAsTokens(terminalNode, tokens);
      } else {
        const nonTerminalNode = node;
        tokens = nonTerminalNodeAsTokens(nonTerminalNode, tokens);
      }
      return tokens;
    }
    function terminalNodeAsTokens(terminalNode, tokens) {
      const significantToken = terminalNode.getSignificantToken(), token = significantToken;
      tokens = [
        token
      ];
      return tokens;
    }
    function nonTerminalNodeAsTokens(nonTerminalNode, tokens) {
      const lastSignificantTokenIndex = nonTerminalNode.getLastSignificantTokenIndex(tokens), firstSignificantTokenIndex = nonTerminalNode.getFirstSignificantTokenIndex(tokens), start = firstSignificantTokenIndex, end = lastSignificantTokenIndex + 1;
      tokens = tokens.slice(start, end);
      return tokens;
    }
  });

  // node_modules/occam-languages/lib/context/file.js
  var require_file = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FileContext;
      }
    });
    var _context = /* @__PURE__ */ _interop_require_default(require_context());
    var _lineIndex = require_lineIndex();
    var _node = require_node4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FileContext = class extends _context.default {
      constructor(context2, fileContent, filePath, tokens, node) {
        super(context2);
        this.fileContent = fileContent;
        this.filePath = filePath;
        this.tokens = tokens;
        this.node = node;
      }
      getFileContent() {
        return this.fileContent;
      }
      getFilePath() {
        return this.filePath;
      }
      getTokens() {
        return this.tokens;
      }
      getNode() {
        return this.node;
      }
      getLexer() {
        const lexer = null;
        return lexer;
      }
      getParser() {
        const parser = null;
        return parser;
      }
      getTypePrefix() {
        const context2 = this.getContext(), typePrefix = context2.getTypePrefix();
        return typePrefix;
      }
      matchFilePath(filePath) {
        const filePathMatches = this.filePath === filePath;
        return filePathMatches;
      }
      nodeAsString(node) {
        const string = (0, _node.nodeAsString)(node, this.tokens);
        return string;
      }
      nodesAsString(nodes) {
        const string = (0, _node.nodesAsString)(nodes, this.tokens);
        return string;
      }
      prepare() {
        if (this.tokens !== null) {
          return;
        }
        const lexer = this.getLexer(), parser = this.getParser(), content = this.fileContent;
        this.tokens = lexer.tokenise(content);
        this.node = parser.parse(this.tokens);
      }
      initialise(json) {
        const {content} = json, lexer = this.getLexer(), parser = this.getParser();
        this.tokens = lexer.tokenise(content);
        this.node = parser.parse(this.tokens);
        this.clear();
        this.addProcedures();
      }
      async break(node) {
        const filePath = this.filePath, lineIndex = (0, _lineIndex.lineIndexFromNodeAndTokens)(node, this.tokens), releaseContext = this.getReleaseContext();
        await releaseContext.break(filePath, lineIndex);
      }
      async verify() {
        let verifies = false;
        this.prepare();
        if (this.node === null) {
          this.warning(`Unable to verify the '${this.filePath}' file because it cannot be parsed.`);
        } else {
          this.debug(`Verifying the '${this.filePath}' file...`);
          const fileVerifies = await this.verifyFile();
          if (fileVerifies) {
            verifies = true;
          }
          verifies ? this.complete() : this.clear();
          if (verifies) {
            this.info(`...verified the '${this.filePath}' file.`);
          }
        }
        return verifies;
      }
      static fromFile(Class, file, ...remainingArguments) {
        const fileContent = file.getContent(), filePath = file.getPath(), tokens = null, node = null, context2 = remainingArguments.pop(), fileContext = new Class(context2, fileContent, filePath, tokens, node, ...remainingArguments);
        return fileContext;
      }
      static fromJSON(Class, json, ...remainingArguments) {
        const {fileContent, filePath} = json, tokens = null, node = null, context2 = remainingArguments.pop(), fileContext = new Class(context2, fileContent, filePath, tokens, node, ...remainingArguments);
        return fileContext;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/asynchronous.js
  var require_asynchronous2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get asyncBackwardsEvery() {
        return asyncBackwardsEvery;
      },
      get asyncEvery() {
        return asyncEvery;
      },
      get asyncForEach() {
        return asyncForEach;
      },
      get asyncForwardsEvery() {
        return asyncForwardsEvery;
      },
      get asyncReduce() {
        return asyncReduce;
      },
      get asyncResolve() {
        return asyncResolve;
      },
      get asyncSome() {
        return asyncSome;
      },
      get default() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var {filter} = _necessary.arrayUtilities;
    async function asyncSome(array, callback) {
      let result = false;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        result = await callback(element, index, array);
        if (result) {
          break;
        }
      }
      return result;
    }
    async function asyncEvery(array, callback) {
      let result = true;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        result = await callback(element, index, array);
        if (!result) {
          break;
        }
      }
      return result;
    }
    async function asyncReduce(array, callback, initialValue) {
      let value = initialValue;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        value = await callback(value, element, index, array);
      }
      return value;
    }
    async function asyncForEach(array, callback) {
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        await callback(element, index, array);
      }
    }
    async function asyncResolve(arrayA, arrayB, callback) {
      let resolved;
      arrayA = [
        ...arrayA
      ];
      for (; ; ) {
        const arrayALength2 = arrayA.length;
        if (arrayALength2 === 0) {
          break;
        }
        let resolved2 = false;
        await asyncForEach(arrayA, async (elementA, index) => {
          const passed = await callback(elementA, index, arrayA);
          if (passed) {
            const elementB = elementA;
            arrayB.push(elementB);
            resolved2 = true;
          }
        });
        if (!resolved2) {
          break;
        }
        filter(arrayA, (elementA) => {
          const arrayBIncludesElementA = arrayB.includes(elementA);
          if (!arrayBIncludesElementA) {
            return true;
          }
        });
      }
      const arrayALength = arrayA.length;
      resolved = arrayALength === 0;
      return resolved;
    }
    async function asyncForwardsEvery(array, callback) {
      const length = array.length;
      for (let index = 0; index < length; index++) {
        const element = array[index], passed = await callback(element, index, array);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    async function asyncBackwardsEvery(array, callback) {
      const length = array.length;
      for (let index = length - 1; index >= 0; index--) {
        const element = array[index], passed = await callback(element, index, array);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    var _default = {
      asyncSome,
      asyncEvery,
      asyncReduce,
      asyncForEach,
      asyncResolve,
      asyncForwardsEvery,
      asyncBackwardsEvery
    };
  });

  // node_modules/occam-languages/lib/utilities/verify.js
  var require_verify = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get verifyFileContexts() {
        return verifyFileContexts;
      },
      get verifyTypePrefixes() {
        return verifyTypePrefixes;
      }
    });
    var _necessary = require_browser();
    var _asynchronous = require_asynchronous2();
    var {first: first2, filter, compress} = _necessary.arrayUtilities;
    async function verifyFileContexts(fileContexts, verifiedFileContexts) {
      const resolved = await (0, _asynchronous.asyncResolve)(fileContexts, verifiedFileContexts, async (fileContext) => {
        const fileContextVerifies = await fileContext.verify();
        if (fileContextVerifies) {
          return true;
        }
      }), fileContextsVerify = resolved;
      return fileContextsVerify;
    }
    function verifyTypePrefixes(typePrefixes, releaseContext) {
      let typePrefixesVerify = true;
      const typePrefixesLength = typePrefixes.length, compressedTypePrefixes = [
        ...typePrefixes
      ];
      compress(compressedTypePrefixes, (typePrefixA, typePrefixB) => {
        const typePrefixAName = typePrefixA.getName(), typePrefixBName = typePrefixB.getName();
        if (typePrefixAName !== typePrefixBName) {
          return true;
        }
      });
      const compressTypePrefixesLength = compressedTypePrefixes.length;
      if (typePrefixesLength > compressTypePrefixesLength) {
        filter(compressedTypePrefixes, (typePrefix2) => {
          const typePrefixesIncludesTypePrefix = typePrefixes.includes(typePrefix2);
          if (!typePrefixesIncludesTypePrefix) {
            return true;
          }
        });
        const firstTypePrefix = first2(typePrefixes), typePrefix = firstTypePrefix, typePrefixString = typePrefix.getString();
        releaseContext.info(`The '${typePrefixString}' type prefix is duplicated.`);
        typePrefixesVerify = false;
      }
      return typePrefixesVerify;
    }
  });

  // node_modules/occam-custom-grammars/lib/grammarNames.js
  var require_grammarNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DEFAULT_CUSTOM_GRAMMAR_NAME", {
      enumerable: true,
      get: function() {
        return DEFAULT_CUSTOM_GRAMMAR_NAME;
      }
    });
    var DEFAULT_CUSTOM_GRAMMAR_NAME = "Default";
  });

  // node_modules/occam-custom-grammars/lib/ruleNames.js
  var require_ruleNames3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get STATEMENT_RULE_NAME() {
        return STATEMENT_RULE_NAME;
      },
      get TERM_RULE_NAME() {
        return TERM_RULE_NAME;
      },
      get default() {
        return _default;
      }
    });
    var TERM_RULE_NAME = "term";
    var STATEMENT_RULE_NAME = "statement";
    var _default = {
      TERM_RULE_NAME,
      STATEMENT_RULE_NAME
    };
  });

  // node_modules/occam-custom-grammars/lib/vocabularyNames.js
  var require_vocabularyNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get SYMBOL_VOCABULARY_NAME() {
        return SYMBOL_VOCABULARY_NAME;
      },
      get TYPE_VOCABULARY_NAME() {
        return TYPE_VOCABULARY_NAME;
      },
      get default() {
        return _default;
      }
    });
    var TYPE_VOCABULARY_NAME = "type";
    var SYMBOL_VOCABULARY_NAME = "symbol";
    var _default = {
      TYPE_VOCABULARY_NAME,
      SYMBOL_VOCABULARY_NAME
    };
  });

  // node_modules/occam-custom-grammars/lib/constants.js
  var require_constants10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BASE_TYPE_SYMBOL() {
        return BASE_TYPE_SYMBOL;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get NONSENSE_RULE_NAME() {
        return NONSENSE_RULE_NAME;
      },
      get STUFF_RULE_NAME() {
        return STUFF_RULE_NAME;
      },
      get UNASSIGNED_TYPE() {
        return UNASSIGNED_TYPE;
      },
      get VERTICAL_BAR() {
        return VERTICAL_BAR;
      },
      get VERTICAL_SPACE() {
        return VERTICAL_SPACE;
      }
    });
    var EMPTY_STRING = "";
    var VERTICAL_BAR = "|";
    var VERTICAL_SPACE = `

`;
    var UNASSIGNED_TYPE = "unassigned";
    var STUFF_RULE_NAME = "stuff";
    var BASE_TYPE_SYMBOL = "<>";
    var NONSENSE_RULE_NAME = "nonsense";
  });

  // node_modules/occam-custom-grammars/lib/customGrammar.js
  var require_customGrammar = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammar;
      }
    });
    var _constants = require_constants10();
    var _grammarNames = require_grammarNames();
    var _ruleNames = require_ruleNames3();
    var _vocabularyNames = require_vocabularyNames();
    var CustomGrammar = class {
      constructor(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary) {
        this.name = name;
        this.termBNF = termBNF;
        this.statementBNF = statementBNF;
        this.typeVocabulary = typeVocabulary;
        this.symbolVocabulary = symbolVocabulary;
      }
      getName() {
        return this.name;
      }
      getTermBNF() {
        return this.termBNF;
      }
      getStatementBNF() {
        return this.statementBNF;
      }
      getTypeVocabulary() {
        return this.typeVocabulary;
      }
      getSymbolVocabulary() {
        return this.symbolVocabulary;
      }
      getBNF(ruleName) {
        let bnf;
        switch (ruleName) {
          case _ruleNames.TERM_RULE_NAME:
            bnf = this.termBNF;
            break;
          case _ruleNames.STATEMENT_RULE_NAME:
            bnf = this.statementBNF;
            break;
        }
        return bnf;
      }
      getVocabulary(vocabularyName) {
        let vocabulary;
        switch (vocabularyName) {
          case _vocabularyNames.TYPE_VOCABULARY_NAME:
            vocabulary = this.typeVocabulary;
            break;
          case _vocabularyNames.SYMBOL_VOCABULARY_NAME:
            vocabulary = this.symbolVocabulary;
            break;
        }
        return vocabulary;
      }
      getVocabularies() {
        const vocabularies = [
          this.typeVocabulary,
          this.symbolVocabulary
        ];
        return vocabularies;
      }
      isDefaultCustomGrammar() {
        const defaultCustomGrammar = this.name === _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
        return defaultCustomGrammar;
      }
      setName(name) {
        this.name = name;
      }
      setBNF(ruleName, bnf) {
        switch (ruleName) {
          case _ruleNames.TERM_RULE_NAME:
            this.termBNF = bnf;
            break;
          case _ruleNames.STATEMENT_RULE_NAME:
            this.statementBNF = bnf;
            break;
        }
      }
      setVocabulary(vocabularyName, vocabulary) {
        switch (vocabularyName) {
          case _vocabularyNames.TYPE_VOCABULARY_NAME:
            this.typeVocabulary = vocabulary;
            break;
          case _vocabularyNames.SYMBOL_VOCABULARY_NAME:
            this.symbolVocabulary = vocabulary;
            break;
        }
      }
      resetBNF(ruleName) {
        const bnf = _constants.EMPTY_STRING;
        this.setBNF(ruleName, bnf);
      }
      resetVocabulary(vocabularyName) {
        const vocabulary = _constants.EMPTY_STRING;
        this.setVocabulary(vocabularyName, vocabulary);
      }
      update(ruleName, bnf, vocabularyName, vocabulary) {
        this.setBNF(ruleName, bnf);
        this.setVocabulary(vocabularyName, vocabulary);
      }
      toJSON() {
        const name = this.name, termBNF = this.termBNF, statementBNF = this.statementBNF, typeVocabulary = this.typeVocabulary, symbolVocabulary = this.symbolVocabulary, json = {
          name,
          termBNF,
          statementBNF,
          typeVocabulary,
          symbolVocabulary
        };
        return json;
      }
      static fromJSON(json) {
        const {name, termBNF, statementBNF, typeVocabulary, symbolVocabulary} = json, customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
      static fromName(name) {
        const termBNF = _constants.EMPTY_STRING, statementBNF = _constants.EMPTY_STRING, typeVocabulary = _constants.EMPTY_STRING, symbolVocabulary = _constants.EMPTY_STRING, customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
      static fromNameTermBNFStatementBNFTypeVocabularyAndSymbolVocabulary(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary) {
        const customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
    };
  });

  // node_modules/occam-custom-grammars/lib/customGrammar/default.js
  var require_default = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name2 in all)
        Object.defineProperty(target, name2, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name2).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get statementBNF() {
        return statementBNF;
      },
      get symbolVocabulary() {
        return symbolVocabulary;
      },
      get termBNF() {
        return termBNF;
      },
      get typeVocabulary() {
        return typeVocabulary;
      }
    });
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _grammarNames = require_grammarNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var termBNF = `term                                 ::=  "(" argument ")"

                                       |  variable 
                                       
                                       ;`;
    var statementBNF = `statement                            ::=  "(" metaArgument ")" 
                                                  
                                       |  equality

                                       |  judgement

                                       |  typeAssertion 
                                                  
                                       |  definedAssertion  

                                       |  containedAssertion  
                                       
                                       |  satisfiesAssertion

                                       |  subproofAssertion         

                                       |  propertyAssertion  

                                       |  metavariable ( frameSubstitution | termSubstitution )?

                                       ;

equality                             ::=  term "=" term ;

typeAssertion                        ::=  term ":" type ;

definedAssertion                     ::=  ( frame | term ) "is" ( "defined" | "undefined" );

containedAssertion                   ::=  ( frame | term ) "is" ( "present" | "missing" ) "in" statement ;

satisfiesAssertion                   ::=  signature "satisfies" metavariable ;  

subproofAssertion                    ::=  "[" statement ( "," statement )* "]" "..." statement ;

propertyAssertion                    ::=  term "is" ( "a" | "an" ) propertyRelation ;

propertyRelation                     ::=  property "of" term ;

judgement                            ::=  frame "|"<NO_WHITESPACE>"-" assumption ;

frame                                ::=  "[" ( ( assumption ( "," assumption )* ) | metavariable ) "]" ;
 
assumption                           ::=  metavariable "::" statement ;

termSubstitution                     ::=  "[" term "for" term "]";

frameSubstitution                    ::=  "[" frame "for" frame "]";

statementSubstitution                ::=  "[" statement "for" statement "]";

referenceSubstitution                ::=  "[" reference "for" reference "]";`;
    var typeVocabulary = "";
    var symbolVocabulary = "";
    var name = _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
    var json = {
      name,
      termBNF,
      statementBNF,
      typeVocabulary,
      symbolVocabulary
    };
    var defaultCustomGrammar = _customGrammar.default.fromJSON(json);
    var _default = defaultCustomGrammar;
  });

  // node_modules/occam-grammar-utilities/lib/example/lexer/example.js
  var require_example = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExampleLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _ExampleLexer = class extends _occamlexers.CommonLexer {
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_ExampleLexer, entries);
      }
    };
    var ExampleLexer = _ExampleLexer;
    __publicField(ExampleLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(ExampleLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(ExampleLexer, "RegularExpressionToken", null);
    __publicField(ExampleLexer, "EndOfLineCommentToken", null);
    __publicField(ExampleLexer, "SingleLineCommentToken", null);
    __publicField(ExampleLexer, "EndOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "StartOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(ExampleLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammar-utilities/lib/example/parser/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamparsers = require_lib4();
    var A = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(A, ruleName, childNodes, opacity, precedence);
      }
    };
    var B = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(B, ruleName, childNodes, opacity, precedence);
      }
    };
    var C = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(C, ruleName, childNodes, opacity, precedence);
      }
    };
    var D = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(D, ruleName, childNodes, opacity, precedence);
      }
    };
    var E = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(E, ruleName, childNodes, opacity, precedence);
      }
    };
    var F = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(F, ruleName, childNodes, opacity, precedence);
      }
    };
    var S = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(S, ruleName, childNodes, opacity, precedence);
      }
    };
    var T = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(T, ruleName, childNodes, opacity, precedence);
      }
    };
    var V = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(V, ruleName, childNodes, opacity, precedence);
      }
    };
    var NonTerminalNodeMap = {
      A,
      B,
      C,
      D,
      E,
      F,
      S,
      T,
      V
    };
    var _default = NonTerminalNodeMap;
  });

  // node_modules/occam-grammar-utilities/lib/example/parser/example.js
  var require_example2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExampleParser;
      }
    });
    var _occamparsers = require_lib4();
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ExampleParser = class extends _occamparsers.CommonParser {
    };
    __publicField(ExampleParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
  });

  // node_modules/occam-grammar-utilities/lib/cycle.js
  var require_cycle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Cycle;
      }
    });
    var _necessary = require_browser();
    var {COMMA_CHARACTER} = _necessary.characters;
    var Cycle = class {
      constructor(edges) {
        this.edges = edges;
      }
      getEdges() {
        return this.edges;
      }
      getLength() {
        const length = this.edges.length;
        return length;
      }
      getEdge(index) {
        const edge = this.edges[index];
        return edge;
      }
      getVertexes() {
        const vertexes = this.mapEdge((edge) => {
          const sourceVertex = edge.getSourceVertex(), vertex = sourceVertex;
          return vertex;
        });
        return vertexes;
      }
      mapEdge(callback) {
        return this.edges.map(callback);
      }
      everyEdge(callback) {
        return this.edges.every(callback);
      }
      forEachEdge(callback) {
        return this.edges.forEach(callback);
      }
      isEqualTo(cycle) {
        let equalTo = false;
        const cycleA = this, cycleB = cycle, cycleALength = cycleA.getLength(), cycleBLength = cycleB.getLength();
        if (cycleALength === cycleBLength) {
          equalTo = cycleA.everyEdge((edgeA, index) => {
            const edgeB = cycleB.getEdge(index), matches = edgeA.match(edgeB);
            if (matches) {
              return true;
            }
          });
        }
        return equalTo;
      }
      permuted() {
        const edges = this.edges.slice(), edge = edges.pop();
        edges.unshift(edge);
        const cycle = new Cycle(edges);
        return cycle;
      }
      asString() {
        const vertexes = this.getVertexes(), string = vertexes.join(COMMA_CHARACTER);
        return string;
      }
      static fromEdge(edge) {
        const edges = [
          edge
        ], cycle = new Cycle(edges);
        return cycle;
      }
      static fromEdges(edges) {
        const cycle = new Cycle(edges);
        return cycle;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/directedGraph.js
  var require_directedGraph = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return DirectedGraph;
      },
      get edgesMatchEdge() {
        return edgesMatchEdge;
      }
    });
    var _necessary = require_browser();
    var _cycle = /* @__PURE__ */ _interop_require_default(require_cycle());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {last, find, compress} = _necessary.arrayUtilities;
    var DirectedGraph = class {
      constructor(edges, startVertex) {
        this.edges = edges;
        this.startVertex = startVertex;
      }
      getEdges() {
        return this.edges;
      }
      getStartVertex() {
        return this.startVertex;
      }
      addEdge(edge) {
        const matches = edgesMatchEdge(this.edges, edge);
        if (!matches) {
          this.edges.push(edge);
        }
      }
      addEdges(edges) {
        edges.forEach((edge) => {
          this.addEdge(edge);
        });
      }
      removeEdge(edge) {
        const index = this.edges.indexOf(edge), start = index, deleteCount = 1;
        this.edges.splice(start, deleteCount);
      }
      depthFirstSearch(vertex, vertexes, callback) {
        const previousVertexes = vertexes, successorVertexes = this.findSuccessorVertexes(vertex);
        successorVertexes.forEach((successorVertex) => {
          const previousVertexesIncludesSuccessorVertex = previousVertexes.includes(successorVertex), vertexes2 = [
            ...previousVertexes,
            successorVertex
          ], vertex2 = successorVertex;
          if (previousVertexesIncludesSuccessorVertex) {
            callback(vertexes2);
          } else {
            this.depthFirstSearch(vertex2, vertexes2, callback);
          }
        });
      }
      findCycles() {
        const trivialCycles = this.findTrivialCycles(), nonTrivialCycles = this.findNonTrivialCycles(), cycles = [
          ...trivialCycles,
          ...nonTrivialCycles
        ];
        compress(cycles, (cycleA, cycleB) => {
          const cyclesCoincident = areCyclesCoincident(cycleA, cycleB);
          if (!cyclesCoincident) {
            return true;
          }
        });
        return cycles;
      }
      findTrivialCycles() {
        const triviallyCyclicEdges = this.findTriviallyCyclicEdges(), trivialCycles = triviallyCyclicEdges.map((triviallyCyclicEdge) => {
          const edge = triviallyCyclicEdge, cycle = _cycle.default.fromEdge(edge), trivialCycle = cycle;
          return trivialCycle;
        });
        return trivialCycles;
      }
      findNonTrivialCycles() {
        const nonTrivialCycles = [], directedGraph = this, vertex = this.startVertex, vertexes = [
          vertex
        ];
        this.depthFirstSearch(vertex, vertexes, (vertexes2) => {
          const nonTrivialCycle = nonTrivialCycleFromVertexes(vertexes2, directedGraph);
          nonTrivialCycles.push(nonTrivialCycle);
        });
        return nonTrivialCycles;
      }
      findSuccessorEdges(vertex) {
        const sourceVertex = vertex, edges = this.findEdgesBySourceVertex(sourceVertex), successorEdges = edges.filter((edge) => {
          const targetVertex = edge.getTargetVertex();
          if (targetVertex !== sourceVertex) {
            return true;
          }
        });
        return successorEdges;
      }
      findSuccessorVertexes(vertex) {
        const successorEdges = this.findSuccessorEdges(vertex), successorVertexes = successorEdges.map((successorEdge) => {
          const successorEdgeTargetVertex = successorEdge.getTargetVertex(), successorVertex = successorEdgeTargetVertex;
          return successorVertex;
        });
        return successorVertexes;
      }
      findEdgesBySourceVertex(sourceVertex) {
        const edges = find(this.edges, (edge) => {
          const edgeMatchesSourceVertex = edge.matchSourceVertex(sourceVertex);
          if (edgeMatchesSourceVertex) {
            return true;
          }
        });
        return edges;
      }
      findTriviallyCyclicEdges() {
        const triviallyCyclicEdges = find(this.edges, (edge) => {
          const edgeTriviallyCyclic = edge.isTriviallyCyclic();
          if (edgeTriviallyCyclic) {
            return true;
          }
        });
        return triviallyCyclicEdges;
      }
      findEdgeBySourceVertexAndTargetVertex(sourceVertex, targetVertex) {
        const edge = this.edges.find((edge2) => {
          const matches = edge2.matchSourceVertexAndTargetVertex(sourceVertex, targetVertex);
          if (matches) {
            return true;
          }
        }) || null;
        return edge;
      }
      static fromEdgesAndStartVertex(edges, startVertex) {
        const directedGraph = new DirectedGraph(edges, startVertex);
        return directedGraph;
      }
    };
    function edgesMatchEdge(edges, edge) {
      const edgeA = edge, matches = edges.some((edge2) => {
        const edgeB = edge2, edgeAMatchesEdgeB = edgeA.match(edgeB);
        if (edgeAMatchesEdgeB) {
          return true;
        }
      });
      return matches;
    }
    function nonTrivialCycleFromVertexes(vertexes, directedGraph) {
      const lastVertex = last(vertexes), index = vertexes.indexOf(lastVertex), start = index;
      vertexes = vertexes.slice(start);
      vertexes.pop();
      const length = vertexes.length, edges = vertexes.map((vertex, index2) => {
        const nextIndex = (index2 + 1) % length, nextVertex = vertexes[nextIndex], sourceVertex = vertex, targetVertex = nextVertex, edge = directedGraph.findEdgeBySourceVertexAndTargetVertex(sourceVertex, targetVertex);
        return edge;
      }), cycle = _cycle.default.fromEdges(edges);
      return cycle;
    }
    function someCyclePermutation(cycle, callback) {
      let result = false;
      const length = cycle.getLength();
      for (let offset = 0; offset < length; offset++) {
        result = callback(cycle);
        if (result) {
          break;
        }
        cycle = cycle.permuted();
      }
      return result;
    }
    function areCyclesCoincident(cycleA, cycleB) {
      let cyclesCoincident = false;
      const cycleALength = cycleA.getLength(), cycleBLength = cycleB.getLength();
      if (cycleALength === cycleBLength) {
        cyclesCoincident = someCyclePermutation(cycleA, (cycleA2) => {
          const cycleAEqualTo = cycleA2.isEqualTo(cycleB);
          if (cycleAEqualTo) {
            return true;
          }
        });
      }
      return cyclesCoincident;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/reduced.js
  var require_reduced = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReducedNode;
      }
    });
    var _occamparsers = require_lib4();
    var ReducedNode = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReducedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/constants.js
  var require_constants11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "EMPTY_STRING", {
      enumerable: true,
      get: function() {
        return EMPTY_STRING;
      }
    });
    var EMPTY_STRING = "";
  });

  // node_modules/occam-grammar-utilities/lib/utilities/ruleName.js
  var require_ruleName7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get directlyRepeatedRuleNameFromRuleName() {
        return directlyRepeatedRuleNameFromRuleName;
      },
      get indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName() {
        return indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName;
      },
      get leftRecursiveRuleNameFromIndirectlyRepeatedRuleName() {
        return leftRecursiveRuleNameFromIndirectlyRepeatedRuleName;
      },
      get reducedRuleNameFromRuleName() {
        return reducedRuleNameFromRuleName;
      },
      get ruleNameFromIndirectlyRepeatedRuleName() {
        return ruleNameFromIndirectlyRepeatedRuleName;
      },
      get ruleNameFromReducedRuleName() {
        return ruleNameFromReducedRuleName;
      }
    });
    var _constants = require_constants11();
    function reducedRuleNameFromRuleName(ruleName) {
      const reducedRuleName = `${ruleName}_`;
      return reducedRuleName;
    }
    function ruleNameFromReducedRuleName(reducedRuleName) {
      const ruleName = reducedRuleName.replace(/_$/g, _constants.EMPTY_STRING);
      return ruleName;
    }
    function directlyRepeatedRuleNameFromRuleName(ruleName) {
      const directlyRepeatedRuleName = `${ruleName}~`;
      return directlyRepeatedRuleName;
    }
    function ruleNameFromIndirectlyRepeatedRuleName(indirectlyRepeatedRuleName) {
      const ruleName = indirectlyRepeatedRuleName.replace(/~.+$/g, _constants.EMPTY_STRING);
      return ruleName;
    }
    function leftRecursiveRuleNameFromIndirectlyRepeatedRuleName(indirectlyRepeatedRuleName) {
      const leftRecursiveRuleName = indirectlyRepeatedRuleName.replace(/^[^~]+~/g, _constants.EMPTY_STRING);
      return leftRecursiveRuleName;
    }
    function indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = `${ruleName}~${leftRecursiveRuleName}`;
      return indirectlyRepeatedRuleName;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/cycle.js
  var require_cycle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isCycleIrreducible() {
        return isCycleIrreducible;
      },
      get ruleCyclesFromRuleNameAndCycles() {
        return ruleCyclesFromRuleNameAndCycles;
      },
      get ruleNamesFromCycle() {
        return ruleNamesFromCycle;
      },
      get ruleNamesFromCycles() {
        return ruleNamesFromCycles;
      }
    });
    var _necessary = require_browser();
    var _ruleName = require_ruleName7();
    var {push, compress} = _necessary.arrayUtilities;
    function isCycleIrreducible(cycle, ruleMap) {
      const ruleNames = ruleNamesFromCycle(cycle), reducedRules = ruleNames.reduce((reducedRules2, ruleName) => {
        const reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName), reducedRule = ruleMap[reducedRuleName] || null;
        if (reducedRule !== null) {
          reducedRules2.push(reducedRule);
        }
        return reducedRules2;
      }, []), reducedRulesLength = reducedRules.length, cycleIrreducible = reducedRulesLength === 0;
      return cycleIrreducible;
    }
    function ruleNamesFromCycle(cycle, ruleNames = []) {
      const cycleVertexes = cycle.getVertexes(), cycleRuleNames = cycleVertexes;
      push(ruleNames, cycleRuleNames);
      return ruleNames;
    }
    function ruleNamesFromCycles(cycles, ruleNames = []) {
      cycles.forEach((cycle) => {
        ruleNamesFromCycle(cycle, ruleNames);
      });
      compress(ruleNames, (ruleNameA, ruleNameB) => {
        if (ruleNameA !== ruleNameB) {
          return true;
        }
      });
      return ruleNames;
    }
    function ruleCyclesFromRuleNameAndCycles(ruleName, cycles) {
      const ruleCycles = cycles.reduce((ruleCycles2, cycle) => {
        const ruleNames = ruleNamesFromCycle(cycle), ruleNamesIncludeRuleName = ruleNames.includes(ruleName);
        if (ruleNamesIncludeRuleName) {
          const ruleCycle = cycle;
          ruleCycles2.push(ruleCycle);
        }
        return ruleCycles2;
      }, []);
      return ruleCycles;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/nonConsuming.js
  var require_nonConsuming = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isPartNonConsuming() {
        return isPartNonConsuming;
      },
      get isRuleNonConsuming() {
        return isRuleNonConsuming;
      }
    });
    var _occamparsers = require_lib4();
    var _occamlexers = require_lib3();
    var {epsilon, noWhitespace, startOfContent} = _occamlexers.specialSymbols;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isRuleNonConsuming(rule, ruleMap, ruleNames = []) {
      let ruleNonConsuming = false;
      const ruleName = rule.getName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
      if (!ruleNamesIncludesRuleName) {
        ruleNames = [
          ...ruleNames,
          ruleName
        ];
        const definitions = rule.getDefinitions(), definitionsNonConsuming = areDefinitionsNonConsuming(definitions, ruleMap, ruleNames);
        ruleNonConsuming = definitionsNonConsuming;
      }
      return ruleNonConsuming;
    }
    function isPartNonConsuming(part, ruleMap, ruleNames = []) {
      let partNonConsuming;
      const parTerminalPart = part.isTerminalPart();
      if (parTerminalPart) {
        const terminalPart = part, terminalPartNonConsuming = isTerminalPartNonConsuming(terminalPart);
        partNonConsuming = terminalPartNonConsuming;
      } else {
        const nonTerminalNPart = part, nonTerminalPartNonConsuming = isNonTerminalPartNonConsuming(nonTerminalNPart, ruleMap, ruleNames);
        partNonConsuming = nonTerminalPartNonConsuming;
      }
      return partNonConsuming;
    }
    function areDefinitionsNonConsuming(definitions, ruleMap, ruleNames) {
      const definitionsNonConsuming = definitions.some((definition) => {
        const definitionNonConsuming = isDefinitionNonConsuming(definition, ruleMap, ruleNames);
        if (definitionNonConsuming) {
          return true;
        }
      });
      return definitionsNonConsuming;
    }
    function isDefinitionNonConsuming(definition, ruleMap, ruleNames) {
      const parts = definition.getParts(), partsNonConsuming = arePartsNonConsuming(parts, ruleMap, ruleNames), definitionNonConsuming = partsNonConsuming;
      return definitionNonConsuming;
    }
    function arePartsNonConsuming(parts, ruleMap, ruleNames) {
      const partsNonConsuming = parts.every((part) => {
        const partNonConsuming = isPartNonConsuming(part, ruleMap, ruleNames);
        if (partNonConsuming) {
          return true;
        }
      });
      return partsNonConsuming;
    }
    function isTerminalPartNonConsuming(terminalPart) {
      let terminalPartNonConsuming;
      const terminalPartString = terminalPart.asString();
      switch (terminalPartString) {
        case epsilon:
        case noWhitespace:
        case startOfContent: {
          terminalPartNonConsuming = true;
          break;
        }
        default: {
          terminalPartNonConsuming = false;
          break;
        }
      }
      return terminalPartNonConsuming;
    }
    function isNonTerminalPartNonConsuming(nonTerminalPart, ruleMap, ruleNames) {
      let partNonConsuming = false;
      const type = nonTerminalPart.getType();
      switch (type) {
        case RuleNamePartType: {
          const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), rule = ruleMap[ruleName] || null;
          if (rule !== null) {
            const ruleNonConsuming = isRuleNonConsuming(rule, ruleMap, ruleNames);
            partNonConsuming = ruleNonConsuming;
          }
          break;
        }
        case OptionalPartPartType: {
          partNonConsuming = true;
          break;
        }
        case OneOrMorePartsPartType: {
          const oneOrMorePartsPart = nonTerminalPart, part = oneOrMorePartsPart.getPart();
          partNonConsuming = isPartNonConsuming(part, ruleMap, ruleNames);
          break;
        }
        case ZeroOrMorePartsPartType: {
          partNonConsuming = true;
          break;
        }
        case SequenceOfPartsPartType: {
          const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), partsNonConsuming = arePartsNonConsuming(parts, ruleMap, ruleNames);
          partNonConsuming = partsNonConsuming;
          break;
        }
        case ChoiceOfPartsPartType: {
          const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts(), partsNonConsuming = parts.some((part) => {
            const partNonConsuming2 = isPartNonConsuming(part, ruleMap, ruleNames);
            return partNonConsuming2;
          });
          partNonConsuming = partsNonConsuming;
          break;
        }
      }
      return partNonConsuming;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/leftRecursive.js
  var require_leftRecursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isDefinitionLeftRecursive() {
        return isDefinitionLeftRecursive;
      },
      get leftRecursiveRuleNamesFromDefinition() {
        return leftRecursiveRuleNamesFromDefinition;
      },
      get leftRecursiveRuleNamesFromRule() {
        return leftRecursiveRuleNamesFromRule;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var _nonConsuming = require_nonConsuming();
    var {first: first2} = _necessary.arrayUtilities;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isDefinitionLeftRecursive(definition, ruleMap) {
      const parts = definition.getParts(), partsLeftRecursive = arePartsLeftRecursive(parts, ruleMap), definitionLeftRecursive = partsLeftRecursive;
      return definitionLeftRecursive;
    }
    function leftRecursiveRuleNamesFromRule(rule, ruleMap, leftRecursiveRuleNames = []) {
      const definitions = rule.getDefinitions();
      definitions.forEach((definition) => {
        leftRecursiveRuleNamesFromDefinition(definition, ruleMap, leftRecursiveRuleNames);
      });
      return leftRecursiveRuleNames;
    }
    function leftRecursiveRuleNamesFromDefinition(definition, ruleMap, leftRecursiveRuleNames = []) {
      const parts = definition.getParts();
      leftRecursiveRuleNamesFromParts(parts, ruleMap, leftRecursiveRuleNames);
      return leftRecursiveRuleNames;
    }
    function arePartsLeftRecursive(parts, ruleMap) {
      const leftRecursiveRuleNames = leftRecursiveRuleNamesFromParts(parts, ruleMap), leftRecursiveRuleNamesLength = leftRecursiveRuleNames.length, partsLeftRecursive = leftRecursiveRuleNamesLength > 0;
      return partsLeftRecursive;
    }
    function leftRecursiveRuleNamesFromPart(part, ruleMap, leftRecursiveRuleNames) {
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), leftRecursiveRuleNamesIncludesRuleName = leftRecursiveRuleNames.includes(ruleName);
            if (!leftRecursiveRuleNamesIncludesRuleName) {
              const leftRecursiveRuleName = ruleName;
              leftRecursiveRuleNames.push(leftRecursiveRuleName);
            }
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case SequenceOfPartsPartType: {
            const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), firstPart = first2(parts), part2 = firstPart;
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case ChoiceOfPartsPartType: {
            const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts();
            parts.forEach((part2) => {
              leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            });
            break;
          }
        }
      }
    }
    function leftRecursiveRuleNamesFromParts(parts, ruleMap, leftRecursiveRuleNames = []) {
      parts.every((part) => {
        const partNonConsuming = (0, _nonConsuming.isPartNonConsuming)(part, ruleMap);
        if (!partNonConsuming) {
          leftRecursiveRuleNamesFromPart(part, ruleMap, leftRecursiveRuleNames);
        } else {
          return true;
        }
      });
      return leftRecursiveRuleNames;
    }
  });

  // node_modules/occam-grammar-utilities/lib/edge.js
  var require_edge = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Edge;
      }
    });
    var Edge = class {
      constructor(label, sourceVertex, targetVertex) {
        this.label = label;
        this.sourceVertex = sourceVertex;
        this.targetVertex = targetVertex;
      }
      getLabel() {
        return this.label;
      }
      getSourceVertex() {
        return this.sourceVertex;
      }
      getTargetVertex() {
        return this.targetVertex;
      }
      isTriviallyCyclic() {
        const triviallyCyclic = this.sourceVertex === this.targetVertex;
        return triviallyCyclic;
      }
      match(edge) {
        const label = this.getLabel(), sourceVertex = edge.getSourceVertex(), targetVertex = edge.getTargetVertex(), matches = this.matchLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex);
        return matches;
      }
      matchSourceVertex(sourceVertex) {
        const matchesSourceVertex = this.sourceVertex === sourceVertex;
        return matchesSourceVertex;
      }
      matchTargetVertex(targetVertex) {
        const matchesTargetVertex = this.targetVertex === targetVertex;
        return matchesTargetVertex;
      }
      matchSourceVertexAndTargetVertex(sourceVertex, targetVertex) {
        const matches = this.sourceVertex === sourceVertex && this.targetVertex === targetVertex;
        return matches;
      }
      matchLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex) {
        const matches = this.label === label && this.sourceVertex === sourceVertex && this.targetVertex === targetVertex;
        return matches;
      }
      static fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex) {
        const edge = new Edge(label, sourceVertex, targetVertex);
        return edge;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/recursive.js
  var require_recursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "recursiveRuleNamesFromRule", {
      enumerable: true,
      get: function() {
        return recursiveRuleNamesFromRule;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, SequenceOfPartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    function recursiveRuleNamesFromRule(rule, recursiveRuleNames = []) {
      const definitions = rule.getDefinitions();
      definitions.forEach((definition) => {
        recursiveRuleNamesFromDefinition(definition, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromDefinition(definition, recursiveRuleNames = []) {
      const parts = definition.getParts();
      recursiveRuleNamesFromParts(parts, recursiveRuleNames);
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromParts(parts, recursiveRuleNames = []) {
      parts.forEach((part) => {
        recursiveRuleNamesFromPart(part, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromPart(part, recursiveRuleNames) {
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), recursiveRuleNamesIncludesRuleName = recursiveRuleNames.includes(ruleName);
            if (!recursiveRuleNamesIncludesRuleName) {
              const recursiveRuleName = ruleName;
              recursiveRuleNames.push(recursiveRuleName);
            }
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case SequenceOfPartsPartType: {
            const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts();
            parts.forEach((part2) => {
              recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            });
            break;
          }
          case ChoiceOfPartsPartType: {
            const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts();
            parts.forEach((part2) => {
              recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            });
            break;
          }
        }
      }
    }
  });

  // node_modules/occam-grammar-utilities/lib/labels.js
  var require_labels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get LEFT_RECURSIVE_LABEL() {
        return LEFT_RECURSIVE_LABEL;
      },
      get RECURSIVE_LABEL() {
        return RECURSIVE_LABEL;
      }
    });
    var RECURSIVE_LABEL = "recursive";
    var LEFT_RECURSIVE_LABEL = "left-recursive";
  });

  // node_modules/occam-grammar-utilities/lib/utilities/directedGraph.js
  var require_directedGraph2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get edgeFromRuleNameAndLeftRecursiveRuleName() {
        return edgeFromRuleNameAndLeftRecursiveRuleName;
      },
      get edgesFromRuleNames() {
        return edgesFromRuleNames;
      },
      get edgesFromStartRule() {
        return edgesFromStartRule;
      }
    });
    var _edge = /* @__PURE__ */ _interop_require_default(require_edge());
    var _directedGraph = require_directedGraph();
    var _recursive = require_recursive();
    var _labels = require_labels();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function edgesFromRuleNames(ruleNames) {
      const length = ruleNames.length, edges = ruleNames.map((ruleName, index) => {
        const nextIndex = (index + 1) % length, nextRuleName = ruleNames[nextIndex], leftRecursiveRuleName = nextRuleName, edge = edgeFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName);
        return edge;
      });
      return edges;
    }
    function edgesFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const rule = startRule, edges = [], vertexes = [];
      edgesFromRule(rule, edges, vertexes, ruleMap, ruleNamesMap);
      return edges;
    }
    function edgeFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const label = _labels.LEFT_RECURSIVE_LABEL, sourceVertex = ruleName, targetVertex = leftRecursiveRuleName, edge = _edge.default.fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex);
      return edge;
    }
    function edgesFromRule(rule, edges, vertexes, ruleMap, ruleNamesMap) {
      const ruleName = rule.getName(), vertex = ruleName, vertexesIncludesVertex = vertexes.includes(vertex);
      if (vertexesIncludesVertex) {
        return;
      }
      vertexes = [
        ...vertexes,
        vertex
      ];
      const ruleNames = ruleNamesMap[ruleName], recursiveRuleNames = (0, _recursive.recursiveRuleNamesFromRule)(rule), leftRecursiveRuleNames = ruleNames;
      recursiveRuleNames.forEach((recursiveRuleName) => {
        const leftRecursiveRuleNamesIncludesRecursiveRuleName = leftRecursiveRuleNames.includes(recursiveRuleName), leftRecursiveRuleName = recursiveRuleName, label = leftRecursiveRuleNamesIncludesRecursiveRuleName ? _labels.LEFT_RECURSIVE_LABEL : _labels.RECURSIVE_LABEL, sourceVertex = ruleName, targetVertex = leftRecursiveRuleName, edge = _edge.default.fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex), matches = (0, _directedGraph.edgesMatchEdge)(edges, edge);
        if (!matches) {
          edges.push(edge);
        }
        const recursiveRule = ruleMap[recursiveRuleName] || null;
        if (recursiveRule !== null) {
          const rule2 = recursiveRule;
          edgesFromRule(rule2, edges, vertexes, ruleMap, ruleNamesMap);
        }
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/reduced.js
  var require_reduced2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReducedRule;
      }
    });
    var _occamparsers = require_lib4();
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced());
    var _directedGraph = require_directedGraph();
    var _cycle = require_cycle2();
    var _ruleName = require_ruleName7();
    var _leftRecursive = require_leftRecursive();
    var _directedGraph1 = require_directedGraph2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ReducedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _reduced.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles, ruleMap) {
        const ruleName = rule.getName();
        let reducedRule = null, definitions = rule.getDefinitions();
        definitions = definitions.filter((definition) => {
          const definitionLeftReducible = isDefinitionReducible(definition, ruleName, cycles, ruleMap);
          if (definitionLeftReducible) {
            return true;
          }
        });
        const definitionsLength = definitions.length;
        if (definitionsLength > 0) {
          const ruleName2 = rule.getName(), reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName2), name = reducedRuleName, opacity = rule.getOpacity();
          reducedRule = new ReducedRule(name, opacity, definitions);
        }
        return reducedRule;
      }
    };
    function isDefinitionReducible(definition, ruleName, cycles, ruleMap) {
      const leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromDefinition)(definition, ruleMap), definitionReducible = leftRecursiveRuleNames.every((leftRecursiveRuleName) => {
        const cyclesIncludeRuleNameAndLeftRecursiveRuleName = cycles.some((cycle) => {
          const cycleIncludesRuleNameAndLeftRecursiveRuleName = doesCycleIncludeRuleNameAndLeftRecursiveRuleName(cycle, ruleName, leftRecursiveRuleName);
          if (cycleIncludesRuleNameAndLeftRecursiveRuleName) {
            return true;
          }
        });
        if (!cyclesIncludeRuleNameAndLeftRecursiveRuleName) {
          return true;
        }
      });
      return definitionReducible;
    }
    function doesCycleIncludeRuleNameAndLeftRecursiveRuleName(cycle, ruleName, leftRecursiveRuleName) {
      const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), edge = (0, _directedGraph1.edgeFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), edges = (0, _directedGraph1.edgesFromRuleNames)(ruleNames), matches = (0, _directedGraph.edgesMatchEdge)(edges, edge), cycleIncludesRuleNameAndLeftRecursiveRuleName = matches;
      return cycleIncludesRuleNameAndLeftRecursiveRuleName;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createReducedRules.js
  var require_createReducedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createReducedRules;
      }
    });
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced2());
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createReducedRules(cycles, ruleMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], reducedRule = _reduced.default.fromRuleAndCycles(rule, cycles, ruleMap);
        if (reducedRule !== null) {
          const reducedRuleName = reducedRule.getName();
          ruleMap[reducedRuleName] = reducedRule;
        }
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/precedence.js
  var require_precedence4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isNonTerminalNodeUnprecedented", {
      enumerable: true,
      get: function() {
        return isNonTerminalNodeUnprecedented;
      }
    });
    function isNonTerminalNodeUnprecedented(nonTerminalNode) {
      let nonTerminalNodeUnprecedented;
      const childNonTerminalNodeUnprecedented = nonTerminalNode.someChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const childNonTerminalNode = childNode, childNonTerminalNodeUnprecedented2 = isNonTerminalNodeUnprecedented(childNonTerminalNode);
          if (childNonTerminalNodeUnprecedented2) {
            return true;
          }
        }
      });
      if (childNonTerminalNodeUnprecedented) {
        nonTerminalNodeUnprecedented = true;
      } else {
        const precedence = nonTerminalNode.getPrecedence();
        if (precedence !== null) {
          const ruleName = nonTerminalNode.getRuleName();
          nonTerminalNodeUnprecedented = nonTerminalNode.someChildNode((childNode) => {
            const childNodeLowerPrecedence = childNode.isLowerPrecedence(ruleName, precedence);
            if (childNodeLowerPrecedence) {
              return true;
            }
          });
        }
      }
      return nonTerminalNodeUnprecedented;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/repeated/directly.js
  var require_directly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedNode;
      }
    });
    var _occamparsers = require_lib4();
    var _rewrite = require_rewrite();
    var DirectlyRepeatedNode = class extends _occamparsers.NonTerminalNode {
      rewrite(state) {
        const nonTerminalNode = this.clone();
        (0, _rewrite.rewriteDirectlyRepeatedNodes)(nonTerminalNode, state);
        return nonTerminalNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(DirectlyRepeatedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/node/repeated/indirectly.js
  var require_indirectly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return IndirectlyRepeatedNode;
      }
    });
    var _occamparsers = require_lib4();
    var IndirectlyRepeatedNode = class extends _occamparsers.NonTerminalNode {
      isNullary() {
        let nullary = false;
        const singular = this.isSingular();
        if (singular) {
          nullary = this.everyChildNode((childNode) => {
            if (childNode instanceof _occamparsers.EpsilonNode) {
              return true;
            }
          });
        }
        return nullary;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(IndirectlyRepeatedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/rewrite.js
  var require_rewrite = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get rewriteDirectlyRepeatedNodes() {
        return rewriteDirectlyRepeatedNodes;
      },
      get rewriteIndirectlyRepeatedNodes() {
        return rewriteIndirectlyRepeatedNodes;
      },
      get rewriteReducedNodes() {
        return rewriteReducedNodes;
      }
    });
    var _necessary = require_browser();
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced());
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly());
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly());
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {push} = _necessary.arrayUtilities;
    function rewriteReducedNodes(nonTerminalNode, state) {
      let reducedChildNode;
      const firstChildNodeReducedNode = nonTerminalNode.someChildNode((childNode, index) => {
        if (index === 0) {
          if (childNode instanceof _reduced.default) {
            reducedChildNode = childNode;
            return true;
          }
        }
      });
      if (!firstChildNodeReducedNode) {
        return;
      }
      const parentNode = nonTerminalNode, replacedChildNode = reducedChildNode, replacedChildNodeOpacity = replacedChildNode.getOpacity(), replacedChildNodeRuleName = replacedChildNode.getRuleName(), replacedChildNodePrecedence = replacedChildNode.getPrecedence(), replacedChildNodeChildNodes = replacedChildNode.removeChildNodes(), parentNodeRuleName = parentNode.getRuleName(), reducedRuleName = replacedChildNodeRuleName, parentRuleName = parentNodeRuleName, precedence = replacedChildNodePrecedence, opacity = replacedChildNodeOpacity, ruleName = (0, _ruleName.ruleNameFromReducedRuleName)(reducedRuleName);
      let replacementChildNodes;
      if (ruleName === parentRuleName) {
        replacementChildNodes = replacedChildNodeChildNodes;
        parentNode.setPrecedence(precedence);
      } else {
        const childNodes = replacedChildNodeChildNodes, NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName), nonTerminalNode2 = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), replacementChildNode = nonTerminalNode2;
        replacementChildNodes = [
          replacementChildNode
        ];
      }
      parentNode.replaceChildNode(replacedChildNode, replacementChildNodes);
    }
    function rewriteDirectlyRepeatedNodes(nonTerminalNode, state) {
      let directlyRepeatedNodesReplaced;
      directlyRepeatedNodesReplaced = replaceDirectlyRepeatedNodes(nonTerminalNode);
      while (directlyRepeatedNodesReplaced) {
        directlyRepeatedNodesReplaced = replaceDirectlyRepeatedNodes(nonTerminalNode);
      }
    }
    function rewriteIndirectlyRepeatedNodes(nonTerminalNode, state) {
      let parentNode = nonTerminalNode;
      const indirectlyRepeatedNodes = findIndirectlyRepeatedNodes(nonTerminalNode);
      indirectlyRepeatedNodes.forEach((indirectlyRepeatedNode) => {
        const leftRecursiveNode = leftRecursiveNodeFromParentNodeAndIndirectlyRepeatedNode(parentNode, indirectlyRepeatedNode, state), childNodes = childNodesFromLeftRecursiveNodeNodeAndIndirectlyRepeatedNode(leftRecursiveNode, indirectlyRepeatedNode);
        adjustParentNodePrecedence(parentNode, indirectlyRepeatedNode);
        parentNode.setChildNodes(childNodes);
        parentNode = leftRecursiveNode;
      });
      return parentNode;
    }
    function findRepeatedNodes(nonTerminalNode, RepeatedNode) {
      let repeatedNodes;
      let endIndex = -1;
      nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
        const childNodeRepeatedNode = childNode instanceof RepeatedNode;
        if (childNodeRepeatedNode) {
          endIndex = index + 1;
          return true;
        }
      });
      if (endIndex === -1) {
        repeatedNodes = [];
      } else {
        let startIndex;
        nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
          const childNodeRepeatedNode = childNode instanceof RepeatedNode;
          if (!childNodeRepeatedNode) {
            if (index < endIndex) {
              return true;
            }
          }
          startIndex = index;
        });
        const childNodes = nonTerminalNode.sliceChildNodes(startIndex, endIndex);
        repeatedNodes = childNodes;
      }
      return repeatedNodes;
    }
    function removeFrontChildNodes(parentNode) {
      const multiplicity = parentNode.getMultiplicity(), deleteCount = multiplicity - 1, start = 0, removedFrontChildNodes = parentNode.spliceChildNodes(start, deleteCount);
      return removedFrontChildNodes;
    }
    function findDirectlyRepeatedNodes(nonTerminalNode) {
      const directlyRepeatedNodes = findRepeatedNodes(nonTerminalNode, _directly.default);
      return directlyRepeatedNodes;
    }
    function findIndirectlyRepeatedNodes(nonTerminalNode) {
      const indirectlyRepeatedNodes = findRepeatedNodes(nonTerminalNode, _indirectly.default);
      indirectlyRepeatedNodes.reverse();
      return indirectlyRepeatedNodes;
    }
    function replaceDirectlyRepeatedNodes(nonTerminalNode) {
      let directlyRepeatedNodesReplaced = false;
      const directlyRepeatedNodes = findDirectlyRepeatedNodes(nonTerminalNode), directlyRepeatedNodesLength = directlyRepeatedNodes.length;
      if (directlyRepeatedNodesLength > 0) {
        const parentNode = nonTerminalNode, replacedChildNodes = directlyRepeatedNodes, replacementChildNodes = [];
        directlyRepeatedNodes.forEach((directlyRepeatedNode) => {
          const directlyRepeatedNodesChildNodes = directlyRepeatedNode.removeChildNodes();
          push(replacementChildNodes, directlyRepeatedNodesChildNodes);
        });
        parentNode.replaceChildNodes(replacedChildNodes, replacementChildNodes);
        directlyRepeatedNodesReplaced = true;
      }
      return directlyRepeatedNodesReplaced;
    }
    function adjustParentNodePrecedence(parentNode, indirectlyRepeatedNode) {
      const indirectlyRepeatedNodeRuleName = indirectlyRepeatedNode.getRuleName(), indirectlyRepeatedRuleName = indirectlyRepeatedNodeRuleName, parentNodeNodeRuleName = parentNode.getRuleName(), ruleName = (0, _ruleName.ruleNameFromIndirectlyRepeatedRuleName)(indirectlyRepeatedRuleName);
      if (parentNodeNodeRuleName === ruleName) {
        const precedence = indirectlyRepeatedNode.getPrecedence();
        parentNode.setPrecedence(precedence);
      }
    }
    function leftRecursiveNodeFromParentNodeAndIndirectlyRepeatedNode(parentNode, indirectlyRepeatedNode, state) {
      const indirectlyRepeatedNodeRuleName = indirectlyRepeatedNode.getRuleName(), indirectlyRepeatedNodeOpacity = indirectlyRepeatedNode.getOpacity(), indirectlyRepeatedRuleName = indirectlyRepeatedNodeRuleName, removedFrontChildNodes = removeFrontChildNodes(parentNode), leftRecursiveRuleName = (0, _ruleName.leftRecursiveRuleNameFromIndirectlyRepeatedRuleName)(indirectlyRepeatedRuleName), ruleName = leftRecursiveRuleName, childNodes = removedFrontChildNodes, opacity = indirectlyRepeatedNodeOpacity, precedence = null, NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName), nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), leftRecursiveNode = nonTerminalNode;
      return leftRecursiveNode;
    }
    function childNodesFromLeftRecursiveNodeNodeAndIndirectlyRepeatedNode(leftRecursiveNode, indirectlyRepeatedNode) {
      const childNodes = [
        leftRecursiveNode
      ], indirectlyRepeatedNodeNullary = indirectlyRepeatedNode.isNullary();
      if (!indirectlyRepeatedNodeNullary) {
        const removedChildNodes = indirectlyRepeatedNode.removeChildNodes();
        push(childNodes, removedChildNodes);
      }
      return childNodes;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/rewritten.js
  var require_rewritten = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenNode;
      }
    });
    var _occamparsers = require_lib4();
    var _precedence = require_precedence4();
    var _rewrite = require_rewrite();
    var RewrittenNode = class extends _occamparsers.NonTerminalNode {
      rewrite(state) {
        let nonTerminalNode;
        const ruleName = this.getRuleName(), NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName);
        nonTerminalNode = this.clone();
        const opacity = nonTerminalNode.getOpacity(), childNodes = nonTerminalNode.getChildNodes(), precedence = nonTerminalNode.getPrecedence();
        nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence);
        (0, _rewrite.rewriteDirectlyRepeatedNodes)(nonTerminalNode, state);
        const parentNode = (0, _rewrite.rewriteIndirectlyRepeatedNodes)(nonTerminalNode, state);
        {
          const nonTerminalNode2 = parentNode;
          (0, _rewrite.rewriteReducedNodes)(nonTerminalNode2, state);
        }
        return nonTerminalNode;
      }
      isUnprecedented() {
        const nonTerminalNode = this, nonTerminalNodeUnprecedented = (0, _precedence.isNonTerminalNodeUnprecedented)(nonTerminalNode), unprecedented = nonTerminalNodeUnprecedented;
        return unprecedented;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(RewrittenNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/ruleNames.js
  var require_ruleNames4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get forEachRuleNameAndLeftRecursiveRuleName() {
        return forEachRuleNameAndLeftRecursiveRuleName;
      },
      get permuteRuleNames() {
        return permuteRuleNames;
      }
    });
    function permuteRuleNames(ruleNames, ruleName) {
      let start, end;
      const index = ruleNames.indexOf(ruleName);
      start = 0;
      end = index;
      const leadingRuleNames = ruleNames.slice(start, end);
      start = index;
      const trailingRuleNames = ruleNames.slice(start), permutedRuleNames = [
        ...trailingRuleNames,
        ...leadingRuleNames
      ];
      return permutedRuleNames;
    }
    function forEachRuleNameAndLeftRecursiveRuleName(ruleNames, callback) {
      const ruleNamesLength = ruleNames.length, lastIndex = ruleNamesLength - 1;
      ruleNames.forEach((ruleName, index) => {
        const nextIndex = index === lastIndex ? 0 : index + 1, leftRecursiveRuleName = ruleNames[nextIndex];
        callback(ruleName, leftRecursiveRuleName, index);
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/part.js
  var require_part3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ruleNamePartFromRuleName() {
        return ruleNamePartFromRuleName;
      },
      get zeroOrMorePartsPartFromPart() {
        return zeroOrMorePartsPartFromPart;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePart, ZeroOrMorePartsPart} = _occamparsers.Parts;
    function ruleNamePartFromRuleName(ruleName) {
      const ruleNamePart = RuleNamePart.fromRuleName(ruleName);
      return ruleNamePart;
    }
    function zeroOrMorePartsPartFromPart(part) {
      const zeroOrMorePartsPart = ZeroOrMorePartsPart.fromPart(part);
      return zeroOrMorePartsPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/path.js
  var require_path3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get arePathsEqual() {
        return arePathsEqual;
      },
      get differenceFromPaths() {
        return differenceFromPaths;
      },
      get pathsFromRuleNameAndCycles() {
        return pathsFromRuleNameAndCycles;
      },
      get reducedRuleNameFromPath() {
        return reducedRuleNameFromPath;
      },
      get reducedRuleNamePartFromPath() {
        return reducedRuleNamePartFromPath;
      }
    });
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames4();
    var _cycle = require_cycle2();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var {last, match, compress} = _necessary.arrayUtilities;
    function arePathsEqual(pathA, pathB) {
      const ruleNamesA = pathA, ruleNamesB = pathB, ruleNamesMatch = match(ruleNamesA, ruleNamesB, (ruleNameA, ruleNameB) => {
        if (ruleNameA === ruleNameB) {
          return true;
        }
      }), pathsEqual = ruleNamesMatch;
      return pathsEqual;
    }
    function differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap) {
      let difference;
      const pathALength = pathA.length, pathBLength = pathB.length;
      if (false) {
      } else if (pathALength === 1) {
        difference = -1;
      } else if (pathBLength === 1) {
        difference = 1;
      } else if (pathALength === 0 && pathBLength === 0) {
        difference = 0;
      } else if (pathALength === 0) {
        difference = 1;
      } else if (pathBLength === 0) {
        difference = -1;
      } else {
        const ruleNamesA = pathA.slice(), ruleNamesB = pathB.slice(), ruleNameA = ruleNamesA.shift(), ruleNameB = ruleNamesB.shift();
        if (ruleNameA === ruleNameB) {
          pathA = ruleNamesA;
          pathB = ruleNamesB;
          ruleName = ruleNameA;
          difference = differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap);
        } else {
          const ruleNames = ruleNamesMap[ruleName], indexA = ruleNames.indexOf(ruleNameA), indexB = ruleNames.indexOf(ruleNameB);
          difference = indexA - indexB;
        }
      }
      return difference;
    }
    function reducedRuleNameFromPath(path) {
      const ruleNames = path, lastRuleName = last(ruleNames), ruleName = lastRuleName, reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName);
      return reducedRuleName;
    }
    function pathsFromRuleNameAndCycles(ruleName, cycles, ruleMap, ruleNamesMap) {
      const paths = cycles.reduce((paths2, cycle) => {
        const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
        if (ruleNamesIncludesRuleName) {
          const permutedRuleNames = (0, _ruleNames.permuteRuleNames)(ruleNames, ruleName), path = permutedRuleNames;
          paths2.push(path);
        }
        return paths2;
      }, []);
      let length;
      paths.forEach((path) => {
        length = path.length;
        while (length > 1) {
          path = path.slice();
          path.pop();
          paths.push(path);
          length = path.length;
        }
      });
      compress(paths, (pathA, pathB) => {
        const pathsEqual = arePathsEqual(pathA, pathB);
        if (!pathsEqual) {
          return true;
        }
      });
      ruleName = null;
      paths.sort((pathA, pathB) => {
        const difference = differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap);
        return difference;
      });
      return paths;
    }
    function reducedRuleNamePartFromPath(path) {
      const reducedRuleName = reducedRuleNameFromPath(path), reducedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(reducedRuleName);
      return reducedRuleNamePart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/definition/rewritten.js
  var require_rewritten2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames4();
    var _path = require_path3();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var {first: first2} = _necessary.arrayUtilities;
    var RewrittenDefinition = class extends _occamparsers.Definition {
      static fromPath(path, ruleMap) {
        let rewrittenDefinition = null;
        const reducedRuleName = (0, _path.reducedRuleNameFromPath)(path), reducedRule = ruleMap[reducedRuleName] || null;
        if (reducedRule !== null) {
          rewrittenDefinition = rewrittenDefinitionFromPath(path);
        }
        return rewrittenDefinition;
      }
    };
    function reversePath(path) {
      const reversedPath = path.slice();
      reversedPath.reverse();
      return reversedPath;
    }
    function rewrittenDefinitionFromPath(path) {
      const reducedRuleNamePart = (0, _path.reducedRuleNamePartFromPath)(path), reversedPath = reversePath(path), ruleNames = reversedPath, ruleNamesLength = ruleNames.length, lastIndex = ruleNamesLength - 1, parts = [];
      parts.push(reducedRuleNamePart);
      (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName, index) => {
        if (index < lastIndex) {
          const directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
          parts.push(directlyRepeatedPart);
          const temporaryRuleName = leftRecursiveRuleName;
          leftRecursiveRuleName = ruleName;
          ruleName = temporaryRuleName;
          const indirectlyRepeatedPart = indirectlyRepeatedPartFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName);
          parts.push(indirectlyRepeatedPart);
        }
      });
      if (ruleNamesLength === 1) {
        const firstRuleName = first2(ruleNames), ruleName = firstRuleName, directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
        parts.push(directlyRepeatedPart);
      }
      const precedence = null, rewrittenDefinition = new RewrittenDefinition(parts, precedence);
      return rewrittenDefinition;
    }
    function directlyRepeatedPartFromRuleName(ruleName) {
      const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), directlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(directlyRepeatedRuleName), zeroOrMoreDirectlyRepeatedRuleNamePartsPart = (0, _part.zeroOrMorePartsPartFromPart)(directlyRepeatedRuleNamePart), directlyRepeatedPart = zeroOrMoreDirectlyRepeatedRuleNamePartsPart;
      return directlyRepeatedPart;
    }
    function indirectlyRepeatedPartFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), indirectlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(indirectlyRepeatedRuleName), indirectlyRepeatedPart = indirectlyRepeatedRuleNamePart;
      return indirectlyRepeatedPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/rewritten.js
  var require_rewritten3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenRule;
      }
    });
    var _occamparsers = require_lib4();
    var _rewritten = /* @__PURE__ */ _interop_require_default(require_rewritten());
    var _rewritten1 = /* @__PURE__ */ _interop_require_default(require_rewritten2());
    var _path = require_path3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RewrittenRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _rewritten.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles, ruleMap, ruleNamesMap) {
        const definitions = [], ruleName = rule.getName(), paths = (0, _path.pathsFromRuleNameAndCycles)(ruleName, cycles, ruleMap, ruleNamesMap);
        paths.forEach((path) => {
          const rewrittenDefinition = _rewritten1.default.fromPath(path, ruleMap);
          if (rewrittenDefinition !== null) {
            const definition = rewrittenDefinition;
            definitions.push(definition);
          }
        });
        const name = ruleName, opacity = rule.getOpacity(), rewrittenRule = new RewrittenRule(name, opacity, definitions);
        return rewrittenRule;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/definition/repeated/directly.js
  var require_directly2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var _cycle = require_cycle2();
    var _ruleNames = require_ruleNames4();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var DirectlyRepeatedDefinition = class extends _occamparsers.Definition {
      static fromRuleAndCycle(rule, cycle) {
        let directlyRepeatedDefinition = null;
        const ruleName = rule.getName(), ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), ruleNameIncludesRuleName = ruleNames.includes(ruleName);
        if (ruleNameIncludesRuleName) {
          const permutedRuleNames = (0, _ruleNames.permuteRuleNames)(ruleNames, ruleName), path = permutedRuleNames, parts = partsFromPath(path), precedence = null;
          directlyRepeatedDefinition = new DirectlyRepeatedDefinition(parts, precedence);
        }
        return directlyRepeatedDefinition;
      }
    };
    function permutePath(path) {
      const permutedPath = path.slice();
      permutedPath.reverse();
      const ruleName = permutedPath.pop();
      permutedPath.unshift(ruleName);
      return permutedPath;
    }
    function partsFromPath(path) {
      const permutedPath = permutePath(path), ruleNames = permutedPath, parts = [];
      (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName) => {
        const temporaryRuleName = leftRecursiveRuleName;
        leftRecursiveRuleName = ruleName;
        ruleName = temporaryRuleName;
        const indirectlyRepeatedPart = indirectlyRepeatedPartFromRuleNameAndLeftReucrsiveRuleName(ruleName, leftRecursiveRuleName), directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
        parts.push(indirectlyRepeatedPart);
        parts.push(directlyRepeatedPart);
      });
      parts.pop();
      return parts;
    }
    function directlyRepeatedPartFromRuleName(ruleName) {
      const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), directlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(directlyRepeatedRuleName), zeroOrMoreDirectlyRepeatedRuleNamePartsPart = (0, _part.zeroOrMorePartsPartFromPart)(directlyRepeatedRuleNamePart), directlyRepeatedPart = zeroOrMoreDirectlyRepeatedRuleNamePartsPart;
      return directlyRepeatedPart;
    }
    function indirectlyRepeatedPartFromRuleNameAndLeftReucrsiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), indirectlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(indirectlyRepeatedRuleName), indirectlyRepeatedPart = indirectlyRepeatedRuleNamePart;
      return indirectlyRepeatedPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/repeated/directly.js
  var require_directly3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedRule;
      }
    });
    var _occamparsers = require_lib4();
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly());
    var _directly1 = /* @__PURE__ */ _interop_require_default(require_directly2());
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DirectlyRepeatedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _directly.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles) {
        const ruleName = rule.getName(), definitions = [];
        cycles.map((cycle) => {
          const directlyRepeatedDefinition = _directly1.default.fromRuleAndCycle(rule, cycle);
          if (directlyRepeatedDefinition !== null) {
            const definition = directlyRepeatedDefinition;
            definitions.push(definition);
          }
        });
        const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), name = directlyRepeatedRuleName, opacity = rule.getOpacity(), directlyRepeatedRule = new DirectlyRepeatedRule(name, opacity, definitions);
        return directlyRepeatedRule;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/rewriteLeftRecursiveRules.js
  var require_rewriteLeftRecursiveRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return rewriteLeftRecursiveRules;
      }
    });
    var _necessary = require_browser();
    var _rewritten = /* @__PURE__ */ _interop_require_default(require_rewritten3());
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly3());
    var _nonConsuming = require_nonConsuming();
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {filter} = _necessary.arrayUtilities;
    function rewriteLeftRecursiveRules(cycles, ruleMap, ruleNamesMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        let rule = ruleMap[ruleName];
        const rewrittenRule = _rewritten.default.fromRuleAndCycles(rule, cycles, ruleMap, ruleNamesMap);
        rule = rewrittenRule;
        ruleMap[ruleName] = rule;
      });
      const directlyRepeatedRules = rulesFromRule(_directly.default, ruleMap);
      directlyRepeatedRules.forEach((directlyRepeatedRule) => {
        const directlyRepeatedRuleNonConsuming = (0, _nonConsuming.isRuleNonConsuming)(directlyRepeatedRule, ruleMap);
        if (directlyRepeatedRuleNonConsuming) {
          const directlyRepeatedRuleName = directlyRepeatedRule.getName();
          throw new Error(`The directly repeated '${directlyRepeatedRuleName}' rule is non-consuming.`);
        }
      });
      ruleNames.forEach((ruleName) => {
        const ruleCycles = (0, _cycle.ruleCyclesFromRuleNameAndCycles)(ruleName, cycles), ruleCyclesIrreducible = ruleCycles.every((ruleCycle) => {
          const ruleCycleIrreducible = (0, _cycle.isCycleIrreducible)(ruleCycle, ruleMap);
          if (ruleCycleIrreducible) {
            return true;
          }
        });
        if (ruleCyclesIrreducible) {
          throw new Error(`None of the cycles including the '${ruleName}' rule have a reduced rule.`);
        }
      });
    }
    function rulesFromRule(Rule, ruleMap) {
      const rules = Object.values(ruleMap);
      filter(rules, (rule) => {
        const ruleRule = rule instanceof Rule;
        if (ruleRule) {
          return true;
        }
      });
      return rules;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createDirectlyRepeatedRules.js
  var require_createDirectlyRepeatedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createDirectlyRepeatedRules;
      }
    });
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly3());
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createDirectlyRepeatedRules(cycles, ruleMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], directlyRepeatedRule = _directly.default.fromRuleAndCycles(rule, cycles, ruleMap), directlyRepeatedRuleName = directlyRepeatedRule.getName();
        ruleMap[directlyRepeatedRuleName] = directlyRepeatedRule;
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/definition/epsilon.js
  var require_epsilon5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var {EpsilonPart} = _occamparsers.Parts;
    var EpsilonDefinition = class extends _occamparsers.Definition {
      static fromPrecedence(precedence) {
        const epsilonPart = EpsilonPart.fromNothing(), parts = [
          epsilonPart
        ], epsilonDefinition = EpsilonDefinition.fromPartsAndPrecedence(parts, precedence);
        return epsilonDefinition;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/parts.js
  var require_parts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "arePartsEqual", {
      enumerable: true,
      get: function() {
        return arePartsEqual;
      }
    });
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    function arePartsEqual(parts) {
      const firstPart = first2(parts), firstPartString = firstPart.asString(), partsEqual = parts.every((part) => {
        const partString = part.asString(), partStringFirstPartString = partString === firstPartString;
        if (partStringFirstPartString) {
          return true;
        }
      });
      return partsEqual;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/nonProducing.js
  var require_nonProducing = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isRuleNonProducing", {
      enumerable: true,
      get: function() {
        return isRuleNonProducing;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isRuleNonProducing(rule, ruleMap, ruleNames = []) {
      let ruleNonProducing = false;
      const ruleName = rule.getName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
      if (!ruleNamesIncludesRuleName) {
        ruleNames = [
          ...ruleNames,
          ruleName
        ];
        const definitions = rule.getDefinitions(), definitionsNonProducing = areDefinitionsNonProducing(definitions, ruleMap, ruleNames);
        ruleNonProducing = definitionsNonProducing;
      }
      return ruleNonProducing;
    }
    function areDefinitionsNonProducing(definitions, ruleMap, ruleNames) {
      const definitionsNonProducing = definitions.every((definition) => {
        const definitionNonProducing = isDefinitionNonProducing(definition, ruleMap, ruleNames);
        if (definitionNonProducing) {
          return true;
        }
      });
      return definitionsNonProducing;
    }
    function isDefinitionNonProducing(definition, ruleMap, ruleNames) {
      const parts = definition.getParts(), partsNonProducing = arePartsNonProducing(parts, ruleMap, ruleNames), definitionNonProducing = partsNonProducing;
      return definitionNonProducing;
    }
    function arePartsNonProducing(parts, ruleMap, ruleNames) {
      const partsNonProducing = parts.every((part) => {
        const partNonProducing = isPartNonProducing(part, ruleMap, ruleNames);
        if (partNonProducing) {
          return true;
        }
      });
      return partsNonProducing;
    }
    function isPartNonProducing(part, ruleMap, ruleNames) {
      let partNonProducing;
      const parTerminalPart = part.isTerminalPart();
      if (parTerminalPart) {
        const terminalPart = part, terminalPartUseless = isTerminalPartNonProducing(terminalPart);
        partNonProducing = terminalPartUseless;
      } else {
        const nonTerminalNPart = part, nonTerminalPartNonProducing = isNonTerminalPartNonProducing(nonTerminalNPart, ruleMap, ruleNames);
        partNonProducing = nonTerminalPartNonProducing;
      }
      return partNonProducing;
    }
    function isTerminalPartNonProducing(terminalPart) {
      const terminalPartNonProducing = false;
      return terminalPartNonProducing;
    }
    function isNonTerminalPartNonProducing(nonTerminalPart, ruleMap, ruleNames) {
      let partNonProducing = false;
      const type = nonTerminalPart.getType();
      switch (type) {
        case RuleNamePartType: {
          const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), rule = ruleMap[ruleName] || null;
          if (rule !== null) {
            const ruleNonProducing = isRuleNonProducing(rule, ruleMap, ruleNames);
            partNonProducing = ruleNonProducing;
          }
          break;
        }
        case OptionalPartPartType: {
          partNonProducing = true;
          break;
        }
        case OneOrMorePartsPartType: {
          const oneOrMorePartsPart = nonTerminalPart, part = oneOrMorePartsPart.getPart();
          partNonProducing = isPartNonProducing(part, ruleMap, ruleNames);
          break;
        }
        case ZeroOrMorePartsPartType: {
          partNonProducing = true;
          break;
        }
        case SequenceOfPartsPartType: {
          const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), partsNonProducing = arePartsNonProducing(parts, ruleMap, ruleNames);
          partNonProducing = partsNonProducing;
          break;
        }
        case ChoiceOfPartsPartType: {
          const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts(), partsNonProducing = parts.every((part) => {
            const partNonProducing2 = isPartNonProducing(part, ruleMap, ruleNames);
            return partNonProducing2;
          });
          partNonProducing = partsNonProducing;
          break;
        }
      }
      return partNonProducing;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/complex.js
  var require_complex = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionComplex", {
      enumerable: true,
      get: function() {
        return isDefinitionComplex;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, SequenceOfPartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    function isDefinitionComplex(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartComplex = isPartComplex(firstPart), definitionComplex = firstPartComplex;
      return definitionComplex;
    }
    function isPartComplex(part) {
      let partComplex = true;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            partComplex = false;
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case SequenceOfPartsPartType:
          case ChoiceOfPartsPartType: {
            partComplex = true;
            break;
          }
        }
      }
      return partComplex;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/occluded.js
  var require_occluded = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionOccluded", {
      enumerable: true,
      get: function() {
        return isDefinitionOccluded;
      }
    });
    var _necessary = require_browser();
    var _nonConsuming = require_nonConsuming();
    var {first: first2} = _necessary.arrayUtilities;
    function isDefinitionOccluded(definition, ruleMap, ruleNames = []) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartNonConsuming = (0, _nonConsuming.isPartNonConsuming)(firstPart, ruleMap, ruleNames), definitionOccluded = firstPartNonConsuming;
      return definitionOccluded;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/callAhead.js
  var require_callAhead = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionCallAhead", {
      enumerable: true,
      get: function() {
        return isDefinitionCallAhead;
      }
    });
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    function isDefinitionCallAhead(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartCallAhead = isPartCallAhead(firstPart), definitionCallAhead = firstPartCallAhead;
      return definitionCallAhead;
    }
    function isPartCallAhead(part) {
      let partCallAhead = false;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, nonTerminalPartRuleNamePart = nonTerminalPart.isRuleNamePart();
        if (nonTerminalPartRuleNamePart) {
          const ruleNamePart = nonTerminalPart, callAhead = ruleNamePart.isCallAhead();
          partCallAhead = callAhead;
        }
      }
      return partCallAhead;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/qualified.js
  var require_qualified = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isDefinitionQualified() {
        return isDefinitionQualified;
      },
      get isPartQualified() {
        return isPartQualified;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var {OptionalPartPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    var {first: first2} = _necessary.arrayUtilities;
    function isPartQualified(part) {
      let partQualified = false;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case OptionalPartPartType:
          case OneOrMorePartsPartType:
          case ZeroOrMorePartsPartType: {
            partQualified = true;
            break;
          }
        }
      }
      return partQualified;
    }
    function isDefinitionQualified(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartQualified = isPartQualified(firstPart), definitionQualified = firstPartQualified;
      return definitionQualified;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/repeated/indirectly.js
  var require_indirectly2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return IndirectlyRepeatedRule;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon5());
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly());
    var _parts = require_parts2();
    var _nonProducing = require_nonProducing();
    var _complex = require_complex();
    var _occluded = require_occluded();
    var _callAhead = require_callAhead();
    var _qualified = require_qualified();
    var _ruleName = require_ruleName7();
    var _leftRecursive = require_leftRecursive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var IndirectlyRepeatedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _indirectly.default;
        return NonTerminalNode;
      }
      static fromRuleAndLeftRecursiveRule(rule, leftRecursiveRule, ruleMap) {
        let definitions = rule.getDefinitions();
        const leftRecursiveRuleName = leftRecursiveRule.getName();
        let leftRecursiveDefinitions = definitions.filter((definition) => {
          const definitionLeftRecursive = (0, _leftRecursive.isDefinitionLeftRecursive)(definition, ruleMap);
          if (definitionLeftRecursive) {
            const leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromDefinition)(definition, ruleMap), firstLeftRecursiveRuleName = first2(leftRecursiveRuleNames);
            if (firstLeftRecursiveRuleName === leftRecursiveRuleName) {
              const ruleName2 = rule.getName(), definitionString = definition.asString();
              const definitionComplex = (0, _complex.isDefinitionComplex)(definition);
              if (definitionComplex) {
                throw new Error(`The '${definitionString}' left recursive-definition of the '${ruleName2}' rule is complex.`);
              }
              const definitionOccluded = (0, _occluded.isDefinitionOccluded)(definition, ruleMap);
              if (definitionOccluded) {
                const definitionString2 = definition.asString();
                throw new Error(`The '${definitionString2}' left recursive definition of the '${ruleName2}' rule is occluded.`);
              }
              const definitionCallAhead = (0, _callAhead.isDefinitionCallAhead)(definition);
              if (definitionCallAhead) {
                throw new Error(`The first part of the '${definitionString}' left recursive definition of the '${ruleName2}' rule is look-ahead.`);
              }
              const definitionQualified = (0, _qualified.isDefinitionQualified)(definition);
              if (definitionQualified) {
                throw new Error(`The first part of the '${definitionString}' left recursive definition of the '${ruleName2}' rule is qualified.`);
              }
              return true;
            }
          }
        });
        const firstPartsEqual = areFirstPartsEqual(leftRecursiveDefinitions);
        if (!firstPartsEqual) {
          const ruleName2 = rule.getName();
          throw new Error(`The first parts of the '${leftRecursiveRuleName}' left recursive definitions in the '${ruleName2}' rule are not equal.`);
        }
        let precedence = null;
        leftRecursiveDefinitions = leftRecursiveDefinitions.filter((leftRecursiveDefinition) => {
          const parts = leftRecursiveDefinition.getParts(), partsLength = parts.length;
          if (partsLength === 1) {
            precedence = leftRecursiveDefinition.getPrecedence();
          } else {
            return true;
          }
        });
        const ruleName = rule.getName(), leftRecursiveRuleOpacity = leftRecursiveRule.getOpacity(), indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), name = indirectlyRepeatedRuleName, opacity = leftRecursiveRuleOpacity;
        definitions = definitionsFromLeftRecursiveDefinitions(leftRecursiveDefinitions);
        const indirectlyRepeatedRule = new IndirectlyRepeatedRule(name, opacity, definitions), indirectlyRepeatedRuleNonProducing = (0, _nonProducing.isRuleNonProducing)(indirectlyRepeatedRule, ruleMap);
        if (indirectlyRepeatedRuleNonProducing) {
          const epsilonDefinition = _epsilon.default.fromPrecedence(precedence);
          definitions.push(epsilonDefinition);
        }
        return indirectlyRepeatedRule;
      }
    };
    function areFirstPartsEqual(definitions) {
      const firstParts = definitions.map((definition) => {
        const parts = definition.getParts(), firstPart = first2(parts);
        return firstPart;
      }), firstPartsEqual = (0, _parts.arePartsEqual)(firstParts);
      return firstPartsEqual;
    }
    function definitionsFromLeftRecursiveDefinitions(leftRecursiveDefinitions) {
      const definitions = leftRecursiveDefinitions.map((leftRecursiveDefinition) => {
        let parts = leftRecursiveDefinition.getParts();
        parts = [
          ...parts
        ];
        parts.shift();
        const precedence = leftRecursiveDefinition.getPrecedence(), definition = _occamparsers.Definition.fromPartsAndPrecedence(parts, precedence);
        return definition;
      });
      return definitions;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createIndirectlyRepeatedRules.js
  var require_createIndirectlyRepeatedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createIndirectlyRepeatedRules;
      }
    });
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly2());
    var _cycle = require_cycle2();
    var _ruleNames = require_ruleNames4();
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createIndirectlyRepeatedRules(cycles, ruleMap) {
      cycles.forEach((cycle) => {
        const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle);
        (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName) => {
          const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName);
          let indirectlyRepeatedRule = ruleMap[indirectlyRepeatedRuleName] || null;
          if (indirectlyRepeatedRule === null) {
            const rule = ruleMap[ruleName], leftRecursiveRule = ruleMap[leftRecursiveRuleName];
            indirectlyRepeatedRule = _indirectly.default.fromRuleAndLeftRecursiveRule(rule, leftRecursiveRule, ruleMap);
            ruleMap[indirectlyRepeatedRuleName] = indirectlyRepeatedRule;
          }
        });
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/eliminateLeftRecursion.js
  var require_eliminateLeftRecursion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return eliminateLeftRecursion;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var _directedGraph = /* @__PURE__ */ _interop_require_default(require_directedGraph());
    var _createReducedRules = /* @__PURE__ */ _interop_require_default(require_createReducedRules());
    var _rewriteLeftRecursiveRules = /* @__PURE__ */ _interop_require_default(require_rewriteLeftRecursiveRules());
    var _createDirectlyRepeatedRules = /* @__PURE__ */ _interop_require_default(require_createDirectlyRepeatedRules());
    var _createIndirectlyRepeatedRules = /* @__PURE__ */ _interop_require_default(require_createIndirectlyRepeatedRules());
    var _directedGraph1 = require_directedGraph2();
    var _labels = require_labels();
    var _leftRecursive = require_leftRecursive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {filter} = _necessary.arrayUtilities;
    var {ruleMapFromRules, startRuleFromRules, rulesFromStartRuleAndRuleMap} = _occamparsers.rulesUtilities;
    function eliminateLeftRecursion(rules) {
      const ruleMap = ruleMapFromRules(rules), startRule = startRuleFromRules(rules), ruleNamesMap = ruleNamesMapFromNothing(ruleMap), cycles = cyclesFromStartRule(startRule, ruleMap, ruleNamesMap);
      (0, _createReducedRules.default)(cycles, ruleMap);
      (0, _createIndirectlyRepeatedRules.default)(cycles, ruleMap);
      (0, _createDirectlyRepeatedRules.default)(cycles, ruleMap);
      (0, _rewriteLeftRecursiveRules.default)(cycles, ruleMap, ruleNamesMap);
      rules = rulesFromStartRuleAndRuleMap(startRule, ruleMap);
      return rules;
    }
    function directedGraphFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const startRuleName = startRule.getName(), edges = (0, _directedGraph1.edgesFromStartRule)(startRule, ruleMap, ruleNamesMap), startVertex = startRuleName, directedGraph = _directedGraph.default.fromEdgesAndStartVertex(edges, startVertex);
      return directedGraph;
    }
    function ruleNamesMapFromNothing(ruleMap) {
      const ruleNamesMap = {}, ruleNames = Object.keys(ruleMap);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromRule)(rule, ruleMap), ruleNames2 = leftRecursiveRuleNames;
        ruleNamesMap[ruleName] = ruleNames2;
      });
      return ruleNamesMap;
    }
    function isCycleLeftRecursive(cycle) {
      const cycleLeftRecursive = cycle.everyEdge((edge) => {
        const label = edge.getLabel(), labelLeftRecursiveLabel = label === _labels.LEFT_RECURSIVE_LABEL, edgeLeftRecursive = labelLeftRecursiveLabel;
        if (edgeLeftRecursive) {
          return true;
        }
      });
      return cycleLeftRecursive;
    }
    function cyclesFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const directedGraph = directedGraphFromStartRule(startRule, ruleMap, ruleNamesMap), cycles = directedGraph.findCycles();
      filter(cycles, (cycle) => {
        const cycleLeftRecursive = isCycleLeftRecursive(cycle);
        if (cycleLeftRecursive) {
          return true;
        }
      });
      return cycles;
    }
  });

  // node_modules/occam-grammar-utilities/lib/index.js
  var require_lib10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ExampleLexer() {
        return _example.default;
      },
      get ExampleParser() {
        return _example1.default;
      },
      get eliminateLeftRecursion() {
        return _eliminateLeftRecursion.default;
      }
    });
    var _example = /* @__PURE__ */ _interop_require_default(require_example());
    var _example1 = /* @__PURE__ */ _interop_require_default(require_example2());
    var _eliminateLeftRecursion = /* @__PURE__ */ _interop_require_default(require_eliminateLeftRecursion());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/query.js
  var require_query3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
  });

  // node_modules/occam-grammars/lib/teX/entries.js
  var require_entries5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\$\\$|\\$|\\\\\\(|\\\\\\)|\\\\\\[|\\\\\\])"
      },
      {
        unassigned: "^(?:.+?(?=\\$\\$|\\$|\\\\\\(|\\\\\\)|\\\\\\[|\\\\\\])|.+)"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/teX/lexer.js
  var require_lexer7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TeXLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _TeXLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_TeXLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_TeXLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_TeXLexer, entries);
      }
    };
    var TeXLexer = _TeXLexer;
    __publicField(TeXLexer, "entries", _entries.default);
    __publicField(TeXLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(TeXLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(TeXLexer, "EndOfLineCommentToken", null);
    __publicField(TeXLexer, "SingleLineCommentToken", null);
    __publicField(TeXLexer, "RegularExpressionToken", null);
    __publicField(TeXLexer, "EndOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "StartOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(TeXLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/json/entries.js
  var require_entries6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:,|:|\\{|\\}|\\[|\\])"
      },
      {
        number: "^-?[1-9][0-9]*(\\.[0-9]+)?"
      },
      {
        boolean: "^(?:true|false)"
      },
      {
        null: "^(?:null)"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/json/lexer.js
  var require_lexer8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return JSONLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries6());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _JSONLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_JSONLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_JSONLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_JSONLexer, entries);
      }
    };
    var JSONLexer = _JSONLexer;
    __publicField(JSONLexer, "entries", _entries.default);
    __publicField(JSONLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(JSONLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(JSONLexer, "EndOfLineCommentToken", null);
    __publicField(JSONLexer, "SingleLineCommentToken", null);
    __publicField(JSONLexer, "RegularExpressionToken", null);
    __publicField(JSONLexer, "EndOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "StartOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(JSONLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/furtle/entries.js
  var require_entries7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var LATIN = "[\\p{Script=Latin}]";
    var DECIMAL = "[0-9]";
    var entries = [
      {
        type: "^(?:Nodes|Node|String|Number|Boolean)"
      },
      {
        query: "^(?:nodeQuery|nodesQuery)"
      },
      {
        "primary-keyword": "^return"
      },
      {
        "secondary-keyword": "^(?:if|else|reduce|every|some|as)"
      },
      {
        null: "^null"
      },
      {
        boolean: "^(?:true|false)"
      },
      {
        bracket: "^(?:\\{|\\})"
      },
      {
        special: "^(?:!=|==|!|=|,|;|_|&&|\\|\\||\\(|\\)|\\[|\\])"
      },
      {
        name: `^${LATIN}+${DECIMAL}*`
      },
      {
        number: `^${DECIMAL}+`
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/furtle/lexer.js
  var require_lexer9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _FurtleLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_FurtleLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_FurtleLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_FurtleLexer, entries);
      }
    };
    var FurtleLexer = _FurtleLexer;
    __publicField(FurtleLexer, "entries", _entries.default);
    __publicField(FurtleLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(FurtleLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(FurtleLexer, "RegularExpressionToken", null);
    __publicField(FurtleLexer, "EndOfLineCommentToken", _occamlexers.EndOfLineCommentNonSignificantToken);
    __publicField(FurtleLexer, "SingleLineCommentToken", _occamlexers.PythonStyleSingleLineCommentToken);
    __publicField(FurtleLexer, "EndOfMultiLineCommentToken", _occamlexers.PythonStyleEndOfMultiLineCommentToken);
    __publicField(FurtleLexer, "StartOfMultiLineCommentToken", _occamlexers.PythonStyleStartOfMultiLineCommentToken);
    __publicField(FurtleLexer, "MiddleOfMultiLineCommentToken", _occamlexers.PythonStyleMiddleOfMultiLineCommentToken);
    __publicField(FurtleLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(FurtleLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/nominal/entries.js
  var require_entries8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var GREEK = "[\\p{Script=Greek}]";
    var LATIN = "[\\p{Script=Latin}]";
    var DECIMAL = "[0-9]";
    var LATIN_LOWER_CASE = "[\\p{Script=Latin}&&\\p{Lowercase}]";
    var LATIN_UPPER_CASE = "[\\p{Script=Latin}&&\\p{Uppercase}]";
    var MATHEMATICAL_SANS_SERIF_BOLD = "[\\u{1D5D4}-\\u{1D607}]";
    var MATHEMATICAL_ITALIC_UPPER_CASE = "[\\u{1D434}-\\u{1D44D}]";
    var MATHEMATICAL_SCRIPT_UPPER_CASE = "[\\u{1D49C}\\u{212C}\\u{1D49E}\\u{1D49F}\\u{2130}\\u{2131}\\u{1D4A2}\\u{210B}\\u{2110}\\u{1D4A5}\\u{1D4A6}\\u{2112}\\u{2133}\\u{1D4A9}-\\u{1D4AC}\\u{211B}\\u{1D4AE}-\\u{1D4B5}]";
    var MATHEMATICAL_FRAKTUR_UPPER_CASE = "[\\u{1D504}\\u{1D505}\\u{212D}\\u{1D507}-\\u{1D50A}\\u{210C}\\u{2111}\\u{1D50D}-\\u{1D514}\\u{211C}\\u{1D516}-\\u{1D51C}\\u{2128}]";
    var entries = [
      {
        "primary-keyword": "^(?:Rule|Axiom|Theorem|Lemma|Conjecture|MetaLemma|Metatheorem|Premises|Premise|Conclusion|Proof|Therefore|Suppose|Hence|Then|Provisional|Type|TypePrefix|Properties|Property|Variable|Constructor|Combinator|Metavariable|Given)\\b"
      },
      {
        "secondary-keyword": "^(?:is|in|an|a|of|by|from|because|for|satisfies|provisionally|defined|undefined|missing|present)\\b"
      },
      {
        "meta-type": "^(?:Statement|Reference|Frame)\\b"
      },
      {
        name: `^(?:${LATIN_UPPER_CASE}${LATIN}*${DECIMAL}*|${LATIN_LOWER_CASE}${LATIN}+${DECIMAL}*)`
      },
      {
        identifier: `^(?:${LATIN_LOWER_CASE}${DECIMAL}*|${GREEK}+|${MATHEMATICAL_SANS_SERIF_BOLD}+|${MATHEMATICAL_ITALIC_UPPER_CASE}+|${MATHEMATICAL_SCRIPT_UPPER_CASE}+|${MATHEMATICAL_FRAKTUR_UPPER_CASE}+)`
      },
      {
        primitive: "^(?:\\||\\.\\.\\.|\\(|\\)|\\[|\\]|\\+|-|,|<|>)"
      },
      {
        special: "^(?:@|::|:|=)"
      },
      {
        unassigned: "^[^\\s\\(\\)\\[\\]:,]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/nominal/lexer.js
  var require_lexer10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NominalLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries8());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NominalLexer = class extends _occamlexers.CommonLexer {
    };
    __publicField(NominalLexer, "entries", _entries.default);
    __publicField(NominalLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(NominalLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(NominalLexer, "RegularExpressionToken", null);
    __publicField(NominalLexer, "EndOfLineCommentToken", _occamlexers.EndOfLineCommentSignificantToken);
    __publicField(NominalLexer, "SingleLineCommentToken", _occamlexers.PythonStyleSingleLineCommentToken);
    __publicField(NominalLexer, "EndOfMultiLineCommentToken", _occamlexers.PythonStyleEndOfMultiLineCommentToken);
    __publicField(NominalLexer, "StartOfMultiLineCommentToken", _occamlexers.PythonStyleStartOfMultiLineCommentToken);
    __publicField(NominalLexer, "MiddleOfMultiLineCommentToken", _occamlexers.PythonStyleMiddleOfMultiLineCommentToken);
    __publicField(NominalLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(NominalLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/plainText/entries.js
  var require_entries9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        "alpha-numeric": "^[a-zA-Z0-9]+"
      },
      {
        punctuation: "^[@,\\.\"'`]+"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/plainText/lexer.js
  var require_lexer11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PlainTextLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries9());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PlainTextLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_PlainTextLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_PlainTextLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_PlainTextLexer, entries);
      }
    };
    var PlainTextLexer = _PlainTextLexer;
    __publicField(PlainTextLexer, "entries", _entries.default);
    __publicField(PlainTextLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(PlainTextLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(PlainTextLexer, "EndOfLineCommentToken", null);
    __publicField(PlainTextLexer, "SingleLineCommentToken", null);
    __publicField(PlainTextLexer, "RegularExpressionToken", null);
    __publicField(PlainTextLexer, "EndOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "StartOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(PlainTextLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/entries.js
  var require_entries10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\||\\(|\\)|\\?|\\*|\\+|::=|;|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        number: "^(?:0|[1-9][0-9]*)"
      },
      {
        name: "^[\\w~]+"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/lexer.js
  var require_lexer12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarBNFnLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries10());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarBNFnLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CustomGrammarBNFnLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CustomGrammarBNFnLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CustomGrammarBNFnLexer, entries);
      }
    };
    var CustomGrammarBNFnLexer = _CustomGrammarBNFnLexer;
    __publicField(CustomGrammarBNFnLexer, "entries", _entries.default);
    __publicField(CustomGrammarBNFnLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(CustomGrammarBNFnLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CustomGrammarBNFnLexer, "EndOfLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "RegularExpressionToken", null);
    __publicField(CustomGrammarBNFnLexer, "SingleLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CustomGrammarBNFnLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/entries.js
  var require_entries11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/lexer.js
  var require_lexer13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarVocabularyLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries11());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarVocabularyLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CustomGrammarVocabularyLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CustomGrammarVocabularyLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CustomGrammarVocabularyLexer, entries);
      }
    };
    var CustomGrammarVocabularyLexer = _CustomGrammarVocabularyLexer;
    __publicField(CustomGrammarVocabularyLexer, "entries", _entries.default);
    __publicField(CustomGrammarVocabularyLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(CustomGrammarVocabularyLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CustomGrammarVocabularyLexer, "EndOfLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "SingleLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "RegularExpressionToken", null);
    __publicField(CustomGrammarVocabularyLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CustomGrammarVocabularyLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/teX/bnf.js
  var require_bnf6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document                        ::=   ( delimitedTeX | plainMarkup )+ ;
    
    
    
    delimitedTeX                    ::=   dollarDelimiter inlineTeX dollarDelimiter 
    
                                      |   doubleDollarDelimiter displayTeX doubleDollarDelimiter 
    
                                      |   openingBracketDelimiter inlineTeX closingBracketDelimiter 
    
                                      |   openingSquareBracketDelimiter displayTeX closingSquareBracketDelimiter 
                                      
                                      ;
    

    
    inlineTeX                       ::=   [unassigned]* ;

    displayTeX                      ::=   [unassigned]* ;



    dollarDelimiter                 ::=   "$" ;
 
    doubleDollarDelimiter           ::=   "$$" ;
    

    
    openingBracketDelimiter         ::=   "\\(" ;

    closingBracketDelimiter         ::=   "\\)" ;

    openingSquareBracketDelimiter   ::=   "\\[" ;
    
    closingSquareBracketDelimiter   ::=   "\\]" ;
    
    
    
    plainMarkup                     ::=   . ;


`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/teX/parser.js
  var require_parser8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TeXParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf6());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _TeXParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_TeXParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_TeXParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_TeXParser, rules);
      }
    };
    var TeXParser = _TeXParser;
    __publicField(TeXParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/json/bnf.js
  var require_bnf7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document     ::=  json error* 
    
                   |  error+ 
                                 
                   ;
  
  
  
    json         ::=  array 
    
                   |  object 
    
                   |  [string-literal] 
    
                   |  [boolean] 
    
                   |  [number] 
    
                   |  [null] 
    
                   ;
  
  
  
    array..      ::=  "[" ( element ( "," element )* )? nonsense? "]" ;
  
  
     
    object..     ::=  "{" ( property ( "," property )* )? nonsense? "}" ;
  
  
    
    property     ::=  [string-literal] ":" json ;
  
    

    element      ::=  json ;
  
    

    nonsense.    ::=  ( ":" | "," | [string-literal] | [number] | [boolean] | [null] | [unassigned] )+ ;
    


    error.       ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/json/parser.js
  var require_parser9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return JSONParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _JSONParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_JSONParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_JSONParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_JSONParser, rules);
      }
    };
    var JSONParser = _JSONParser;
    __publicField(JSONParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/furtle/bnf.js
  var require_bnf8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document                ::=  ( procedureDeclaration | error )+ ;
    
    
    
    procedureDeclaration    ::=  [type] label<NO_WHITESPACE>"(" parameters? ")" returnBlock ;
    
    anonymousProcedure      ::=  [type] "(" parameters? ")" returnBlock ;
    
    returnStatement         ::=  "return" term ";" ; 
    
    
    
    step                    ::=  arrayAssignment
                              
                              |  objectAssignment
                              
                              |  variableAssignments
     
                              ;  
      
      
    
    arrayAssignment         ::=  "[" parameters "]" "=" variable ";" ;
    
    objectAssignment        ::=  "{" namedParameters "}" "=" variable ";" ;
    
    variableAssignments     ::=  [type] variableAssignment ( "," variableAssignment )* ";" ;
    
    variableAssignment      ::=  variable "=" expression ;
    


    namedParameters         ::=  namedParameter ( "," namedParameter )* ;
    
    parameters              ::=  parameter ( "," parameter )* ;
    
    terms                   ::=  term ( "," term )* ;
    


    namedParameter          ::=  [type] [name] ( "as" [name] )? ;   
    
    parameter               ::=  [type] [name]
    
                              |  "_" 
    
                              ;


    
    procedureCall           ::=  reference<NO_WHITESPACE>"(" terms? ")" ;
    
    returnBlock..           ::=  "{" ( step | nonsense )* returnStatement "}" ;
                                     
    nodesQuery              ::=  "nodesQuery"<NO_WHITESPACE>"(" variable "," [string-literal] ")" ;
    
    nodeQuery               ::=  "nodeQuery"<NO_WHITESPACE>"(" variable "," [string-literal] ")" ;
    
    ternary                 ::=  "if" "(" term ")" expression "else" expression ;
    
    reduce                  ::=  "reduce"<NO_WHITESPACE>"(" variable "," anonymousProcedure "," expression ")" ;
    
    every                   ::=  "every"<NO_WHITESPACE>"(" variable "," anonymousProcedure ")" ;
    
    some                    ::=  "some"<NO_WHITESPACE>"(" variable "," anonymousProcedure ")" ;
    
    
    
    comparisonTerm          ::=  term ( "==" | "!=" ) term ; 
    
    bracketedTerm           ::=  "(" term ")" ; 
    
    negatedTerm             ::=  "!"<NO_WHITESPACE>term ; 
    
    logicalTerm             ::=  term ( "||" | "&&" ) term ; 


    
    expression              ::=  procedureCall
     
                              |  returnBlock
    
                              |  nodesQuery
                              
                              |  nodeQuery
                              
                              |  ternary
                              
                              |  reduce
    
                              |  every
    
                              |  some
                             
                              |  term
                              
                              ;
    
    
    
    term                    ::=  comparisonTerm 
    
                              |  bracketedTerm 
    
                              |  logicalTerm 
    
                              |  negatedTerm 
    
                              |  primitive 
    
                              |  variable 
                              
                              ;


    
    primitive               ::=  [string-literal]
                              
                              |  [boolean]
                              
                              |  [number] 
                              
                              |  [null]
                             
                              ;



    reference.              ::=  [name] ;
    
    variable                ::=  [name] ;
    
    label.                  ::=  [name] ;
    
    
    
    nonsense.               ::=  [secondary-keyword] | [type] | [null] | [boolean] | [string-literal] | [query] | [special] | [name] | [number] | [unassigned] ;


    
    error.                  ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/furtle/parser.js
  var require_parser10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf8());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _FurtleParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_FurtleParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_FurtleParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_FurtleParser, rules);
      }
    };
    var FurtleParser = _FurtleParser;
    __publicField(FurtleParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/nominal/bnf.js
  var require_bnf9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `document                             ::=  ( variableDeclaration 
                                           
                                          | combinatorDeclaration 
                                                          
                                          | constructorDeclaration 
                                                          
                                          | metavariableDeclaration 
                                                          
                                          | typePrefixDeclaration  
                                                                                                     
                                          | simpleTypeDeclaration 
                                                          
                                          | complexTypeDeclaration 
                                                      
                                          | rule 
               
                                          | axiom 
               
                                          | lemma 
               
                                          | theorem 
               
                                          | conjecture 
               
                                          | metaLemma 
               
                                          | metatheorem  
                                                      
                                          | section 
                                                      
                                          | verticalSpace 
                                                      
                                          | error )+ ;



section                              ::=  "Given" <END_OF_LINE>

                                          hypothesis+
                                          
                                          <END_OF_LINE>
                                          
                                          ( axiom 
                                          
                                          | lemma 
                                          
                                          | theorem 
                                          
                                          | conjecture ) ; 



verticalSpace                        ::=  <END_OF_LINE>+ ;



error.                               ::=  . ;



variableDeclaration                  ::=  "Variable" variable ( ":" type "provisionally"? )? <END_OF_LINE> ;
 
combinatorDeclaration                ::=  "Combinator" combinator... <END_OF_LINE> ;
 
constructorDeclaration               ::=  "Constructor" constructor... ( ":" type "provisionally"? )? <END_OF_LINE> ;
 
metavariableDeclaration              ::=  "Metavariable" metavariable... ":" metaType <END_OF_LINE> ;
 
typePrefixDeclaration                ::=  "TypePrefix" typePrefix <END_OF_LINE> ;

simpleTypeDeclaration                ::=  "Provisional"? "Type" type ( ":" types )? <END_OF_LINE> ;
 
complexTypeDeclaration               ::=  "Provisional"? "Type" <END_OF_LINE> 

                                          type ( ":" types )? <END_OF_LINE>
                                          
                                          (
                                          
                                            ( "Properties" <END_OF_LINE> propertyDeclaration propertyDeclaration+ ) 
                                             
                                            | 
                                             
                                            ( "Property" <END_OF_LINE> propertyDeclaration ) 
                                             
                                          );
  

  
rule                                 ::=  ruleHeader ruleBody ;                                         

metaLemma                            ::=  metaLemmaHeader metaLemmaBody ;

metatheorem                          ::=  metatheoremHeader metatheoremBody ;

axiom                                ::=  axiomHeader axiomBody ;

lemma                                ::=  lemmaHeader lemmaBody ;

theorem                              ::=  theoremHeader theoremBody ;

conjecture                           ::=  conjectureHeader conjectureBody ;



ruleHeader                          ::=  "Rule" parenthesisedLabels... <END_OF_LINE> ; 

metaLemmaHeader                     ::=  "MetaLemma" parenthesisedLabel... <END_OF_LINE> | "MetaLemma" <END_OF_LINE> ;

metatheoremHeader                   ::=  "Metatheorem" parenthesisedLabel... <END_OF_LINE> ; 

axiomHeader                         ::=  "Axiom" signature? parenthesisedLabels... <END_OF_LINE> ; 

lemmaHeader                         ::=  "Lemma" parenthesisedLabels... <END_OF_LINE> | "Lemma" <END_OF_LINE> ; 

theoremHeader                       ::=  "Theorem" parenthesisedLabels... <END_OF_LINE> ; 

conjectureHeader                    ::=  "Conjecture" parenthesisedLabels... <END_OF_LINE> ;



ruleBody                             ::=  ( 

                                            ( "Premises" <END_OF_LINE> premise premise+ ) 
                                             
                                            | 
                                             
                                            ( "Premise" <END_OF_LINE> premise ) 
                                             
                                          )?
                                             
                                          "Conclusion" <END_OF_LINE> conclusion 
                                           
                                          proof? ;                                         

metaLemmaBody                        ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+ 

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                                                                         
                                          proof ;

metatheoremBody                      ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+ 

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                           
                                          proof ;

axiomBody                            ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+
    
                                            "Then" <END_OF_LINE> 
                                                 
                                          )?
                                                 
                                          deduction ;

lemmaBody                            ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                           
                                          proof ;

theoremBody                          ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                             
                                          deduction
                                           
                                          proof ;

conjectureBody                       ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                             
                                          deduction
                                           
                                          proof? ;



proof                                ::=  "Proof" <END_OF_LINE> derivation ;

subproof                             ::=  "Suppose" <END_OF_LINE> supposition+ subDerivation ;

derivation                           ::=  ( 

                                            ( step | subproof )+ 
                                            
                                            "Therefore" <END_OF_LINE> 
                                            
                                          )? 
                                          
                                          step ;                                        

subDerivation                        ::=  (

                                            "Hence" <END_OF_LINE>
    
                                            ( step | subproof )+ 
                                                                                         
                                          )? 
                                           
                                          "Then" <END_OF_LINE> 
                                           
                                          step ;                                        



propertyDeclaration.                 ::=  property ( ":" type )? <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;



combinator                           ::=  statement ;

constructor                          ::=  term ; 

 

premise.                             ::=  procedureCall <END_OF_LINE>  

                                       |  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

supposition.                         ::=  procedureCall <END_OF_LINE>  

                                       |  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

conclusion.                          ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

deduction.                           ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

hypothesis.                          ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;



step.                                ::=  statement... qualification? <END_OF_LINE>  

                                       |  nonsense... qualification? <END_OF_LINE>
                                       
                                       ;



qualification                        ::=  "because" satisfiesAssertion

                                       |  ( "by" | "from" ) reference
                                       
                                       ; 



parenthesisedLabels                  ::=  "(" labels ")" ; 

parenthesisedLabel                   ::=  "(" label ")" ; 



procedureCall                        ::=  "@"<NO_WHITESPACE>procedureReference<NO_WHITESPACE>"(" parameter ( "," parameter )* ")" ;



signature                            ::=  "[" term ( "," term )* "]" ;



arguments                            ::=  argument ( "," argument )* ;

labels                               ::=  label ( "," label )* ;

types                                ::=  type ( "," type )* ;



argument                             ::=  term ( ) 

                                       |  type ( )
                                       
                                       ;

metaArgument                         ::=  statement ( ) 

                                       |  metaType ( ) 
                                       
                                       ;

frameArgument                        ::=  frame ( ) 

                                       |  metaType ( ) 
                                       
                                       ;


procedureReference.                  ::=  [name] ;

reference.                           ::=  metavariable ;

label.                               ::=  metavariable ;



equivalences                         ::=  equivalence ( "," equivalence )* ;

equivalence                          ::=  "[" term ( "," term )+ "]" ;



metavariable.                        ::=  [name] ( <NO_WHITESPACE>"(" ( term | type | stuff ) ")" )? ;

parameter.                           ::=  [name] | [identifier] ;

variable.                            ::=  [identifier] ;

metaType.                            ::=  [meta-type] ;

property.                            ::=  [name]+ ;

typePrefix.                          ::=  [type] ;

type.                                ::=  [type] ( <NO_WHITESPACE>[type] )? 

                                       |  "<"<NO_WHITESPACE>">"

                                       ;



stuff.                               ::=  ( [string-literal] | [symbol] | [type] | [name] | [identifier] | [primitive] | [unassigned] )+ ;

nonsense.                            ::=  ( [secondary-keyword] | [meta-type] | [special] | [symbol] | [type] | [name] | [identifier] | [primitive] | [unassigned] )+ ;`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/nominal/parser.js
  var require_parser11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NominalParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf9());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NominalParser = class extends _occamparsers.CommonParser {
    };
    __publicField(NominalParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/plainText/bnf.js
  var require_bnf10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document       ::=  ( block | verticalSpace )+ ;

    block          ::=  endedLine* lastLine 
                          
                     |  endedLine+
                          
                     ;

    lastLine       ::=  ( [alpha-numeric] | [punctuation] | [unassigned] )+ ;

    endedLine      ::=  ( [alpha-numeric] | [punctuation] | [unassigned] )+ <END_OF_LINE> ;

    verticalSpace  ::=  <END_OF_LINE>+ ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/plainText/parser.js
  var require_parser12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PlainTextParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf10());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PlainTextParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_PlainTextParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_PlainTextParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_PlainTextParser, rules);
      }
    };
    var PlainTextParser = _PlainTextParser;
    __publicField(PlainTextParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/bnf.js
  var require_bnf11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

      document                 ::=  ( rule | error )+ ;

      rule                     ::=  name "::=" definitions ";" ;

      name                     ::=  [name] ;

      definitions              ::=  definition ( "|" definition )* ;

      definition               ::=  part+ precedence? ;
 
      part                     ::=  nonTerminalPart quantifier*

                                 |  terminalPart quantifier*

                                 ;

      nonTerminalPart          ::=  choiceOfParts

                                 |  sequenceOfParts

                                 |  ruleName 

                                 ;

      terminalPart             ::=  significantTokenType
  
                                 |  stringLiteral
  
                                 |  endOfLine
  
                                 |  noWhitespace
                              
                                 ;
                              
      sequenceOfParts          ::=  "(" part part+ ")" ;

      choiceOfParts            ::=  "(" partChoice ( "|" partChoice )+ ")" ;

      partChoice               ::=  part precedence? ;

      ruleName                 ::=  [name] ;

      significantTokenType     ::=  [type] ;

      stringLiteral            ::=  [string-literal] ;

      precedence               ::=  "(" [number]? ")" ;
      
      endOfLine                ::=  "<END_OF_LINE>" ;
      
      noWhitespace             ::=  "<NO_WHITESPACE>" ;                              

      quantifier               ::=  optionalQuantifier
 
                                 |  oneOrMoreQuantifier
  
                                 |  zeroOrMoreQuantifier
  
                                 ;

      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;

      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;

      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;

      error.                   ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/parser.js
  var require_parser13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarBNFParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf11());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarBNFParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CustomGrammarBNFParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CustomGrammarBNFParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CustomGrammarBNFParser, rules);
      }
    };
    var CustomGrammarBNFParser = _CustomGrammarBNFParser;
    __publicField(CustomGrammarBNFParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/bnf.js
  var require_bnf12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document       ::=  ( expression | verticalSpace | error )+ ;

    expression     ::=  <NO_WHITESPACE>[unassigned]<NO_WHITESPACE><END_OF_LINE> ;

    verticalSpace  ::=  <END_OF_LINE>+ ;
   
    error.         ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/parser.js
  var require_parser14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarVocabularyParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf12());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarVocabularyParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CustomGrammarVocabularyParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CustomGrammarVocabularyParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CustomGrammarVocabularyParser, rules);
      }
    };
    var CustomGrammarVocabularyParser = _CustomGrammarVocabularyParser;
    __publicField(CustomGrammarVocabularyParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/index.js
  var require_lib11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CustomGrammarBNFLexer() {
        return _lexer5.default;
      },
      get CustomGrammarBNFParser() {
        return _parser5.default;
      },
      get CustomGrammarVocabularyLexer() {
        return _lexer6.default;
      },
      get CustomGrammarVocabularyParser() {
        return _parser6.default;
      },
      get FurtleLexer() {
        return _lexer2.default;
      },
      get FurtleParser() {
        return _parser2.default;
      },
      get JSONLexer() {
        return _lexer1.default;
      },
      get JSONParser() {
        return _parser1.default;
      },
      get NominalLexer() {
        return _lexer3.default;
      },
      get NominalParser() {
        return _parser3.default;
      },
      get PlainTextLexer() {
        return _lexer4.default;
      },
      get PlainTextParser() {
        return _parser4.default;
      },
      get TeXLexer() {
        return _lexer.default;
      },
      get TeXParser() {
        return _parser.default;
      }
    });
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer7());
    var _lexer1 = /* @__PURE__ */ _interop_require_default(require_lexer8());
    var _lexer2 = /* @__PURE__ */ _interop_require_default(require_lexer9());
    var _lexer3 = /* @__PURE__ */ _interop_require_default(require_lexer10());
    var _lexer4 = /* @__PURE__ */ _interop_require_default(require_lexer11());
    var _lexer5 = /* @__PURE__ */ _interop_require_default(require_lexer12());
    var _lexer6 = /* @__PURE__ */ _interop_require_default(require_lexer13());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser8());
    var _parser1 = /* @__PURE__ */ _interop_require_default(require_parser9());
    var _parser2 = /* @__PURE__ */ _interop_require_default(require_parser10());
    var _parser3 = /* @__PURE__ */ _interop_require_default(require_parser11());
    var _parser4 = /* @__PURE__ */ _interop_require_default(require_parser12());
    var _parser5 = /* @__PURE__ */ _interop_require_default(require_parser13());
    var _parser6 = /* @__PURE__ */ _interop_require_default(require_parser14());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/grammar.js
  var require_grammar = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get customGrammarBNFLexer() {
        return customGrammarBNFLexer;
      },
      get customGrammarBNFParser() {
        return customGrammarBNFParser;
      },
      get customGrammarVocabularyLexer() {
        return customGrammarVocabularyLexer;
      },
      get customGrammarVocabularyParser() {
        return customGrammarVocabularyParser;
      }
    });
    var _occamgrammars = require_lib11();
    var customGrammarBNFLexer = _occamgrammars.CustomGrammarBNFLexer.fromNothing();
    var customGrammarBNFParser = _occamgrammars.CustomGrammarBNFParser.fromNothing();
    var customGrammarVocabularyLexer = _occamgrammars.CustomGrammarVocabularyLexer.fromNothing();
    var customGrammarVocabularyParser = _occamgrammars.CustomGrammarVocabularyParser.fromNothing();
  });

  // node_modules/occam-custom-grammars/lib/utilities/vocabulary.js
  var require_vocabulary = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "expressionsFromVocabulary", {
      enumerable: true,
      get: function() {
        return expressionsFromVocabulary;
      }
    });
    var _necessary = require_browser();
    var _query = require_query3();
    var _grammar = require_grammar();
    var {second} = _necessary.arrayUtilities;
    var expressionNodesQuery = (0, _query.nodesQuery)("//expression");
    function expressionsFromVocabulary(vocabulary, expressions) {
      const content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
      if (node === null) {
        return;
      }
      const expressionNodes = expressionNodesQuery(node);
      expressionNodes.forEach((expressionNode) => {
        const content2 = contentFromExpressionNode(expressionNode), expression = escape(content2);
        expressions.push(expression);
      });
    }
    function contentFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, childNodes = nonTerminalNode.getChildNodes(), secondChildNode = second(childNodes), unassignedTerminalNode = secondChildNode, content = unassignedTerminalNode.getContent();
      return content;
    }
    function escape(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/nominal.js
  var require_nominal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nominalLexer() {
        return nominalLexer;
      },
      get nominalParser() {
        return nominalParser;
      }
    });
    var _occamlexers = require_lib3();
    var _occamparsers = require_lib4();
    var _occamgrammars = require_lib11();
    var nominalLexer = _occamlexers.CommonLexer.fromNothing(_occamgrammars.NominalLexer);
    var nominalParser = _occamparsers.CommonParser.fromNothing(_occamgrammars.NominalParser);
  });

  // node_modules/occam-custom-grammars/lib/typesMap.js
  var require_typesMap = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _nominal = require_nominal();
    var _ruleNames = require_ruleNames3();
    var _constants = require_constants10();
    var {first: first2} = _necessary.arrayUtilities;
    var ruleMap = _nominal.nominalParser.getRuleMap();
    var stuffRule = ruleMap[_constants.STUFF_RULE_NAME];
    var nonsenseRule = ruleMap[_constants.NONSENSE_RULE_NAME];
    var stuffTypes = typesFromRule(stuffRule);
    var nonsenseTypes = typesFromRule(nonsenseRule);
    var termTypes = stuffTypes;
    var statementTypes = nonsenseTypes;
    var typesMap = {
      [_ruleNames.TERM_RULE_NAME]: termTypes,
      [_ruleNames.STATEMENT_RULE_NAME]: statementTypes
    };
    var _default = typesMap;
    function typesFromRule(rule) {
      let parts;
      const definitions = rule.getDefinitions(), firstDDefinition = first2(definitions), definition = firstDDefinition;
      parts = definition.getParts();
      const firstPart = first2(parts), oneOrMorePartsPart = firstPart, part = oneOrMorePartsPart.getPart(), choiceOrPartsPart = part;
      parts = choiceOrPartsPart.getParts();
      const types = parts.map((part2) => {
        const significantTokenTypePart = part2, significantTokenType = significantTokenTypePart.getSignificantTokenType(), type = significantTokenType;
        return type;
      });
      return types;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/validate.js
  var require_validate = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get validateBNF() {
        return validateBNF;
      },
      get validateVocabulary() {
        return validateVocabulary;
      }
    });
    var _necessary = require_browser();
    var _typesMap = /* @__PURE__ */ _interop_require_default(require_typesMap());
    var _nominal = require_nominal();
    var _query = require_query3();
    var _constants = require_constants10();
    var _grammar = require_grammar();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var expressionNodesQuery = (0, _query.nodesQuery)("//expression");
    var ruleNameTerminalNodeQuery = (0, _query.nodeQuery)("/document/rule/name/@*!");
    var unassignedTerminalNodeQuery = (0, _query.nodeQuery)("/expression/@unassigned");
    var stringLiteralTerminalNodesQuery = (0, _query.nodesQuery)("//stringLiteral/@*!");
    var significantTokenTypeTerminalNodesQuery = (0, _query.nodesQuery)("//significantTokenType/@*!");
    function validateBNF(bnf, ruleName) {
      const content = bnf, tokens = _grammar.customGrammarBNFLexer.tokenise(content), node = _grammar.customGrammarBNFParser.parse(tokens);
      if (node === null) {
        return;
      }
      const ruleNameTerminalNode = ruleNameTerminalNodeQuery(node);
      if (ruleNameTerminalNode !== null) {
        const name = nameFromRuleNameTerminalNode(ruleNameTerminalNode);
        if (name !== ruleName) {
          throw new Error(`The '${name}' rule should be named '${ruleName}'.`);
        }
      }
      const types = _typesMap.default[ruleName], significantTokenTypeTerminalNodes = significantTokenTypeTerminalNodesQuery(node);
      significantTokenTypeTerminalNodes.forEach((significantTokenTypeTerminalNode) => {
        const type = typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
          throw new Error(`The '${type}' type is not included in the '${ruleName}' rule's types.`);
        }
      });
      const stringLiteralTerminalNodes = stringLiteralTerminalNodesQuery(node);
      stringLiteralTerminalNodes.forEach((stringLiteralTerminalNode) => {
        const content2 = contentFromStringLiteralTerminalNode(stringLiteralTerminalNode);
        if (content2 === _constants.BASE_TYPE_SYMBOL) {
          throw new Error(`The "${content2}" string literal cannot be the same as the base type symbol.`);
        }
        const tokens2 = _nominal.nominalLexer.tokenise(content2), tokensLength = tokens2.length;
        if (tokensLength !== 1) {
          throw new Error(`Tokenising the "${content2}" string literal does not result in a single token.`);
        }
        const firstToken = first2(tokens2), token = firstToken, type = token.getType(), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
          throw new Error(`The "${content2}" string literal's token's '${type}' type is not included in the '${ruleName}' rule's types.`);
        }
      });
    }
    function validateVocabulary(vocabulary) {
      const content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
      if (node === null) {
        return;
      }
      const expressionNodes = expressionNodesQuery(node);
      expressionNodes.forEach((expressionNode) => {
        const content2 = contentFromExpressionNode(expressionNode), tokens2 = _nominal.nominalLexer.tokenise(content2), tokensLength = tokens2.length;
        if (tokensLength > 1) {
          throw new Error(`Tokenising the '${content2}' content results in more than one token.`);
        }
        const firstToken = first2(tokens2), token = firstToken, type = token.getType();
        if (type !== _constants.UNASSIGNED_TYPE) {
          throw new Error(`The '${type}' type of the '${content2}' token is not 'unassigned'.`);
        }
        if (content2 === _constants.BASE_TYPE_SYMBOL) {
          throw new Error(`The '${content2}' token cannot be the same as the base type symbol.`);
        }
      });
    }
    function contentFromExpressionNode(expressionNode) {
      let content;
      const unassignedTerminalNode = unassignedTerminalNodeQuery(expressionNode);
      content = unassignedTerminalNode.getContent();
      return content;
      ;
    }
    function nameFromRuleNameTerminalNode(ruleNameTerminalNode) {
      let name;
      const content = ruleNameTerminalNode.getContent();
      name = content;
      return name;
    }
    function contentFromStringLiteralTerminalNode(stringLiteralTerminalNode) {
      let content;
      content = stringLiteralTerminalNode.getContent();
      const matches = content.match(/"([^"]*)"/), secondMatch = second(matches);
      content = secondMatch;
      return content;
    }
    function typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode) {
      let type;
      const content = significantTokenTypeTerminalNode.getContent(), matches = content.match(/\[([^\]]*)\]/), secondMatch = second(matches);
      type = secondMatch;
      return type;
    }
  });

  // node_modules/occam-custom-grammars/lib/customGrammar/combined.js
  var require_combined = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CombinedCustomGrammar;
      }
    });
    var _necessary = require_browser();
    var _occamlexers = require_lib3();
    var _occamparsers = require_lib4();
    var _occamgrammarutilities = require_lib10();
    var _default = /* @__PURE__ */ _interop_require_default(require_default());
    var _vocabulary = require_vocabulary();
    var _constants = require_constants10();
    var _validate = require_validate();
    var _ruleNames = require_ruleNames3();
    var _vocabularyNames = require_vocabularyNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque} = _occamlexers.specialSymbols;
    var {rulesFromBNF} = _occamparsers.parserUtilities;
    var {unshift, forwardsForEach, backwardsForEach} = _necessary.arrayUtilities;
    var CombinedCustomGrammar = class {
      constructor(rules, entries) {
        this.rules = rules;
        this.entries = entries;
      }
      getRules() {
        return this.rules;
      }
      getEntries() {
        return this.entries;
      }
      postProcess(rules) {
        rules = [
          ...rules,
          ...this.rules
        ];
        rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
        return rules;
      }
      static fromNothing(includeDefault = true) {
        let customGrammars = [];
        if (includeDefault) {
          customGrammars = [
            _default.default,
            ...customGrammars
          ];
        }
        const rules = rulesFromCustomGrammars(customGrammars), entries = entriesFromCustomGrammars(customGrammars), combinedCustomGrammar = new CombinedCustomGrammar(rules, entries);
        return combinedCustomGrammar;
      }
      static fromCustomGrammars(customGrammars, includeDefault = true) {
        if (includeDefault) {
          customGrammars = [
            _default.default,
            ...customGrammars
          ];
        }
        const rules = rulesFromCustomGrammars(customGrammars), entries = entriesFromCustomGrammars(customGrammars), combinedCustomGrammar = new CombinedCustomGrammar(rules, entries);
        return combinedCustomGrammar;
      }
    };
    function rulesFromCustomGrammars(customGrammars) {
      const ruleNames = [
        _ruleNames.TERM_RULE_NAME,
        _ruleNames.STATEMENT_RULE_NAME
      ], bnfs = ruleNames.map((ruleName) => {
        const bnf2 = bnfFromCustomGrammars(customGrammars, ruleName);
        return bnf2;
      }), bnf = bnfs.join(_constants.VERTICAL_SPACE), rules = rulesFromBNF(bnf);
      combineRules(rules);
      const opacity = opaque;
      ruleNames.forEach((ruleName) => {
        const rule = rules.find((rule2) => {
          const name = rule2.getName();
          if (name === ruleName) {
            return true;
          }
        });
        rule.setOpacity(opacity);
      });
      return rules;
    }
    function entriesFromCustomGrammars(customGrammars) {
      const vocabularyNames = [
        _vocabularyNames.TYPE_VOCABULARY_NAME,
        _vocabularyNames.SYMBOL_VOCABULARY_NAME
      ], entries = vocabularyNames.map((vocabularyName) => {
        const entry = entryFromCustomGrammars(customGrammars, vocabularyName);
        return entry;
      });
      return entries;
    }
    function entryFromCustomGrammars(customGrammars, vocabularyName) {
      const expressions = [];
      backwardsForEach(customGrammars, (customGrammar) => {
        const vocabulary = customGrammar.getVocabulary(vocabularyName), customGrammarDefaultCustomGrammar = customGrammar.isDefaultCustomGrammar();
        if (!customGrammarDefaultCustomGrammar) {
          (0, _validate.validateVocabulary)(vocabulary);
        }
        (0, _vocabulary.expressionsFromVocabulary)(vocabulary, expressions);
      });
      const pattern = expressions.join(_constants.VERTICAL_BAR), entryName = vocabularyName, entryValue = `^(?:${pattern})`, entry = {
        [entryName]: entryValue
      };
      return entry;
    }
    function bnfFromCustomGrammars(customGrammars, ruleName) {
      const bnfs = [];
      forwardsForEach(customGrammars, (customGrammar) => {
        const bnf2 = customGrammar.getBNF(ruleName), customGrammarDefaultCustomGrammar = customGrammar.isDefaultCustomGrammar();
        if (!customGrammarDefaultCustomGrammar) {
          (0, _validate.validateBNF)(bnf2, ruleName);
        }
        bnfs.push(bnf2);
      });
      const bnf = bnfs.join(_constants.VERTICAL_SPACE);
      return bnf;
    }
    function combineRules(rules) {
      let outerIndex = 0, length = rules.length;
      while (outerIndex < length) {
        const outerRule = rules[outerIndex], outerRuleName = outerRule.getName();
        let innerIndex = outerIndex + 1;
        while (innerIndex < length) {
          const innerRule = rules[innerIndex], innerRuleName = innerRule.getName();
          if (innerRuleName === outerRuleName) {
            const innerRuleDefinitions = innerRule.getDefinitions(), outerRuleDefinitions = outerRule.getDefinitions();
            unshift(outerRuleDefinitions, innerRuleDefinitions);
            const start = innerIndex, deleteCount = 1;
            rules.splice(start, deleteCount);
            length = rules.length;
          } else {
            innerIndex++;
          }
        }
        outerIndex++;
        length = rules.length;
      }
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/lexers.js
  var require_lexers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get lexerFromCombinedCustomGrammar() {
        return lexerFromCombinedCustomGrammar;
      },
      get lexerFromEntriesAndCombinedCustomGrammar() {
        return lexerFromEntriesAndCombinedCustomGrammar;
      },
      get lexerFromNothing() {
        return lexerFromNothing;
      }
    });
    var _occamlexers = require_lib3();
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {lexerFromRules, rulesFromEntries} = _occamlexers.lexerUtilities;
    function lexerFromNothing(Class) {
      const {entries} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    function lexerFromCombinedCustomGrammar(Class, combinedCustomGrammar) {
      const {entries} = Class, rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    function lexerFromEntriesAndCombinedCustomGrammar(Class, entries, combinedCustomGrammar) {
      const rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    var _default = {
      lexerFromNothing,
      lexerFromCombinedCustomGrammar,
      lexerFromEntriesAndCombinedCustomGrammar
    };
    function rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar) {
      const customGrammarEntries = combinedCustomGrammar.getEntries();
      entries = [
        ...customGrammarEntries,
        ...entries
      ];
      const rules = rulesFromEntries(entries);
      return rules;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/parsers.js
  var require_parsers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get parserFromBNFAndCombinedCustomGrammar() {
        return parserFromBNFAndCombinedCustomGrammar;
      },
      get parserFromBNFStartRuleNameAndCombinedCustomGrammar() {
        return parserFromBNFStartRuleNameAndCombinedCustomGrammar;
      },
      get parserFromCombinedCustomGrammar() {
        return parserFromCombinedCustomGrammar;
      },
      get parserFromNothing() {
        return parserFromNothing;
      },
      get parserFromStartRuleName() {
        return parserFromStartRuleName;
      },
      get parserFromStartRuleNameAndCombinedCustomGrammar() {
        return parserFromStartRuleNameAndCombinedCustomGrammar;
      }
    });
    var _occamparsers = require_lib4();
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {rulesFromBNF, parserFromRules, parserFromRulesAndStartRuleName} = _occamparsers.parserUtilities;
    function parserFromNothing(Class) {
      const {bnf} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromStartRuleName(Class, startRuleName) {
      const {bnf} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    function parserFromCombinedCustomGrammar(Class, combinedCustomGrammar) {
      const {bnf} = Class, rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromBNFAndCombinedCustomGrammar(Class, bnf, combinedCustomGrammar) {
      const rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromStartRuleNameAndCombinedCustomGrammar(Class, startRuleName, combinedCustomGrammar) {
      const {bnf} = Class, rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    function parserFromBNFStartRuleNameAndCombinedCustomGrammar(Class, bnf, startRuleName, combinedCustomGrammar) {
      const rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    var _default = {
      parserFromNothing,
      parserFromStartRuleName,
      parserFromCombinedCustomGrammar,
      parserFromBNFAndCombinedCustomGrammar,
      parserFromStartRuleNameAndCombinedCustomGrammar,
      parserFromBNFStartRuleNameAndCombinedCustomGrammar
    };
    function rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar) {
      let rules = rulesFromBNF(bnf);
      rules = combinedCustomGrammar.postProcess(rules);
      return rules;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/customGrammar.js
  var require_customGrammar2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combinedCustomGrammarFromCustomGrammars() {
        return combinedCustomGrammarFromCustomGrammars;
      },
      get combinedCustomGrammarFromJSON() {
        return combinedCustomGrammarFromJSON;
      },
      get combinedCustomGrammarFromNothing() {
        return combinedCustomGrammarFromNothing;
      },
      get default() {
        return _default;
      }
    });
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function combinedCustomGrammarFromJSON(json) {
      const customGrammarsJSON = json, customGrammars = customGrammarsJSON.map((customGrammarJSON) => {
        const json2 = customGrammarJSON, customGrammar = _customGrammar.default.fromJSON(json2);
        return customGrammar;
      });
      customGrammars.reverse();
      const combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    function combinedCustomGrammarFromNothing() {
      const customGrammars = [], combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    function combinedCustomGrammarFromCustomGrammars(customGrammars) {
      customGrammars = [
        ...customGrammars
      ];
      customGrammars.reverse();
      const combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    var _default = {
      combinedCustomGrammarFromJSON,
      combinedCustomGrammarFromNothing,
      combinedCustomGrammarFromCustomGrammars
    };
  });

  // node_modules/occam-custom-grammars/lib/index.js
  var require_lib12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CombinedCustomGrammar() {
        return _combined.default;
      },
      get CustomGrammar() {
        return _customGrammar.default;
      },
      get DEFAULT_CUSTOM_GRAMMAR_NAME() {
        return _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
      },
      get customGrammarUtilities() {
        return _customGrammar1.default;
      },
      get defaultCustomGrammar() {
        return _default.default;
      },
      get lexersUtilities() {
        return _lexers.default;
      },
      get parsersUtilities() {
        return _parsers.default;
      },
      get ruleNames() {
        return _ruleNames.default;
      },
      get vocabularyNames() {
        return _vocabularyNames.default;
      }
    });
    var _grammarNames = require_grammarNames();
    var _ruleNames = /* @__PURE__ */ _interop_require_default(require_ruleNames3());
    var _vocabularyNames = /* @__PURE__ */ _interop_require_default(require_vocabularyNames());
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _default = /* @__PURE__ */ _interop_require_default(require_default());
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    var _lexers = /* @__PURE__ */ _interop_require_default(require_lexers());
    var _parsers = /* @__PURE__ */ _interop_require_default(require_parsers());
    var _customGrammar1 = /* @__PURE__ */ _interop_require_default(require_customGrammar2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/utilities/customGrammar.js
  var require_customGrammar3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combinedCustomGrammarFromReleaseContexts() {
        return combinedCustomGrammarFromReleaseContexts;
      },
      get customGrammarFromNameAndEntries() {
        return customGrammarFromNameAndEntries;
      }
    });
    var _occamcustomgrammars = require_lib12();
    var {combinedCustomGrammarFromCustomGrammars} = _occamcustomgrammars.customGrammarUtilities;
    function customGrammarFromNameAndEntries(name, entries) {
      const termBNF = entries.getTermBNF(), statementBNF = entries.getStatementBNF(), typeVocabulary = entries.getTypeVocabulary(), symbolVocabulary = entries.getSymbolVocabulary(), customGrammar = _occamcustomgrammars.CustomGrammar.fromNameTermBNFStatementBNFTypeVocabularyAndSymbolVocabulary(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
      return customGrammar;
    }
    function combinedCustomGrammarFromReleaseContexts(releaseContexts) {
      const customGrammars = releaseContexts.map((releaseContext) => {
        const customGrammar = releaseContext.getCustomGrammar();
        return customGrammar;
      });
      const combinedCustomGrammar = combinedCustomGrammarFromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
  });

  // node_modules/occam-languages/lib/utilities/fileContext.js
  var require_fileContext = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get fileContextsFromEntries() {
        return fileContextsFromEntries;
      },
      get fileContextsFromJSON() {
        return fileContextsFromJSON;
      }
    });
    function fileContextsFromJSON(json, fileContexts, releaseContext, FileContextFromFilePath) {
      const fileContextsJSON = json;
      fileContextsJSON.forEach((fileContextJSON) => {
        const {filePath} = fileContextJSON, FileContext = FileContextFromFilePath(filePath);
        if (FileContext !== null) {
          const json2 = fileContextJSON, fileContext = FileContext.fromJSON(json2, releaseContext);
          fileContexts.push(fileContext);
        }
      });
    }
    function fileContextsFromEntries(entries, fileContexts, releaseContext, FileContextFromFilePath) {
      entries.forEachFile((file) => {
        const filePath = file.getPath(), FileContext = FileContextFromFilePath(filePath);
        if (FileContext !== null) {
          const fileContext = FileContext.fromFile(file, releaseContext);
          fileContexts.push(fileContext);
        }
      });
    }
    var _default = {
      fileContextsFromJSON,
      fileContextsFromEntries
    };
  });

  // node_modules/occam-languages/lib/context/release.js
  var require_release = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReleaseContext;
      }
    });
    var _necessary = require_browser();
    var _verify = require_verify();
    var _customGrammar = require_customGrammar3();
    var _fileContext = require_fileContext();
    var _constants = require_constants9();
    var {push, tail, first: first2} = _necessary.arrayUtilities;
    var ReleaseContext = class {
      constructor(log, name, json, entries, callback, customGrammar, verifies, initialised, fileContexts, combinedCustomGrammar, dependencyReleaseContexts) {
        this.log = log;
        this.name = name;
        this.json = json;
        this.entries = entries;
        this.callback = callback;
        this.customGrammar = customGrammar;
        this.verifies = verifies;
        this.initialised = initialised;
        this.fileContexts = fileContexts;
        this.combinedCustomGrammar = combinedCustomGrammar;
        this.dependencyReleaseContexts = dependencyReleaseContexts;
      }
      getLog() {
        return this.log;
      }
      getName() {
        return this.name;
      }
      getJSON() {
        return this.json;
      }
      getEntries() {
        return this.entries;
      }
      getCallback() {
        return this.callback;
      }
      getCustomGrammar() {
        return this.customGrammar;
      }
      getVerifies() {
        return this.verifies;
      }
      isInitialised() {
        return this.initialised;
      }
      getFileContexts() {
        return this.fileContexts;
      }
      getCombinedCustomGrammar() {
        return this.combinedCustomGrammar;
      }
      getDependencyReleaseContexts() {
        return this.dependencyReleaseContexts;
      }
      getReleaseContext() {
        const releaseContext = this;
        return releaseContext;
      }
      getDepth() {
        const depth = 0;
        return depth;
      }
      hasVerified() {
        const verified = this.verifies;
        return verified;
      }
      isReleased() {
        const released = this.json !== null;
        return released;
      }
      getTypePrefix() {
        let typePrefix = null;
        const includeDependencies = false, typePrefixes = this.getTypePrefixes(includeDependencies), typePrefixesLength = typePrefixes.length;
        if (typePrefixesLength === 1) {
          const firstTypePrefix = first2(typePrefixes);
          typePrefix = firstTypePrefix;
        }
        return typePrefix;
      }
      getLabels(includeDependencies = true) {
        const labels = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextLabels = fileContext.getLabels(includeRelease);
          push(labels, fileContextLabels);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextLabels = releaseContext.getLabels(includeDependencies2);
            push(labels, releaseContextLabels);
          });
        }
        return labels;
      }
      getTypes(includeDependencies = true) {
        const types = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTypes = fileContext.getTypes(includeRelease);
          push(types, fileContextTypes);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTypes = releaseContext.getTypes(includeDependencies2);
            push(types, releaseContextTypes);
          });
        }
        return types;
      }
      getRules(includeDependencies = true) {
        const rules = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextRules = fileContext.getRules(includeRelease);
          push(rules, fileContextRules);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextRules = releaseContext.getRules(includeDependencies2);
            push(rules, releaseContextRules);
          });
        }
        return rules;
      }
      getAxioms(includeDependencies = true) {
        const axioms = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextAxioms = fileContext.getAxioms(includeRelease);
          push(axioms, fileContextAxioms);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextAxioms = releaseContext.getAxioms(includeDependencies2);
            push(axioms, releaseContextAxioms);
          });
        }
        return axioms;
      }
      getLemmas(includeDependencies = true) {
        const lemmas = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextLemmas = fileContext.getLemmas(includeRelease);
          push(lemmas, fileContextLemmas);
        });
        return lemmas;
      }
      getTheorems(includeDependencies = true) {
        const theorems = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTheorems = fileContext.getTheorems(includeRelease);
          push(theorems, fileContextTheorems);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTheorems = releaseContext.getTheorems(includeDependencies2);
            push(theorems, releaseContextTheorems);
          });
        }
        return theorems;
      }
      getProcedures(includeDependencies = true) {
        const procedures = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextProcedures = fileContext.getProcedures(includeRelease);
          push(procedures, fileContextProcedures);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextProcedures = releaseContext.getProcedures(includeDependencies2);
            push(procedures, releaseContextProcedures);
          });
        }
        return procedures;
      }
      getMetaLemmas(includeDependencies = true) {
        const metaLemmas = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextMetaLemmas = fileContext.getMetaLemmas(includeRelease);
          push(metaLemmas, fileContextMetaLemmas);
        });
        return metaLemmas;
      }
      getConjectures(includeDependencies = true) {
        const conjectures = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextConjectures = fileContext.getConjectures(includeRelease);
          push(conjectures, fileContextConjectures);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextConjectures = releaseContext.getConjectures(includeDependencies2);
            push(conjectures, releaseContextConjectures);
          });
        }
        return conjectures;
      }
      getCombinators(includeDependencies = true) {
        const combinators = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextCombinators = fileContext.getCombinators(includeRelease);
          push(combinators, fileContextCombinators);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextCombinators = releaseContext.getCombinators(includeDependencies2);
            push(combinators, releaseContextCombinators);
          });
        }
        return combinators;
      }
      getTypePrefixes(includeDependencies = true) {
        const typePrefixes = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTypePrefixes = fileContext.getTypePrefixes(includeRelease);
          push(typePrefixes, fileContextTypePrefixes);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTypePrefixes = releaseContext.getTypePrefixes(includeDependencies2);
            push(typePrefixes, releaseContextTypePrefixes);
          });
        }
        return typePrefixes;
      }
      getConstructors(includeDependencies = true) {
        const constructors = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextConstructors = fileContext.getConstructors(includeRelease);
          push(constructors, fileContextConstructors);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextConstructors = releaseContext.getConstructors(includeDependencies2);
            push(constructors, releaseContextConstructors);
          });
        }
        return constructors;
      }
      getMetatheorems(includeDependencies = true) {
        const metatheorems = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextMetatheorems = fileContext.getMetatheorems(includeRelease);
          push(metatheorems, fileContextMetatheorems);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextMetatheorems = releaseContext.getMetatheorems(includeDependencies2);
            push(metatheorems, releaseContextMetatheorems);
          });
        }
        return metatheorems;
      }
      getDependencies() {
        return this.entries.getDependencies();
      }
      matchShortenedVersion(shortenedVersion) {
        return this.entries.matchShortenedVersion(shortenedVersion);
      }
      trace(message) {
        const level = _constants.TRACE_LEVEL;
        this.writeToLog(level, message);
      }
      debug(message) {
        const level = _constants.DEBUG_LEVEL;
        this.writeToLog(level, message);
      }
      info(message) {
        const level = _constants.INFO_LEVEL;
        this.writeToLog(level, message);
      }
      warning(message) {
        const level = _constants.WARNING_LEVEL;
        this.writeToLog(level, message);
      }
      error(message) {
        const level = _constants.ERROR_LEVEL;
        this.writeToLog(level, message);
      }
      writeToLog(level, message, filePath = null, lineIndex = null) {
        this.log.write(level, message, filePath, lineIndex);
      }
      initialise(releaseContexts, FileContextFromFilePath) {
        const released = this.isReleased(), releaseContext = this, releaseContextsTail = tail(releaseContexts);
        this.dependencyReleaseContexts = releaseContextsTail;
        this.combinedCustomGrammar = (0, _customGrammar.combinedCustomGrammarFromReleaseContexts)(releaseContexts);
        released ? (0, _fileContext.fileContextsFromJSON)(this.json, this.fileContexts, releaseContext, FileContextFromFilePath) : (0, _fileContext.fileContextsFromEntries)(this.entries, this.fileContexts, releaseContext, FileContextFromFilePath);
        this.initialised = true;
      }
      async break(filePath, lineIndex) {
        const level = _constants.TRACE_LEVEL, message = _constants.BREAK_MESSAGE;
        this.writeToLog(level, message, filePath, lineIndex);
        const context2 = this;
        await this.callback(context2, filePath, lineIndex);
      }
      async verify() {
        let verifies = false;
        const typePrefixes = this.getTypePrefixes(), releaseContext = this, typePrefixesVerify = (0, _verify.verifyTypePrefixes)(typePrefixes, releaseContext);
        if (typePrefixesVerify) {
          const verifiedFileContexts = [], fileContextsVerify = await (0, _verify.verifyFileContexts)(this.fileContexts, verifiedFileContexts);
          if (fileContextsVerify) {
            verifies = true;
            this.verifies = verifies;
            this.fileContexts = verifiedFileContexts;
          }
        }
        return verifies;
      }
      toJSON() {
        const fileContextsJSON = this.fileContexts.map((fileContext) => {
          const fileContextJSON = fileContext.toJSON();
          return fileContextJSON;
        }), json = fileContextsJSON;
        return json;
      }
      static fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar) {
        const verifies = false, initialised = false, fileContexts = [], combinedCustomGrammar = null, dependencyReleaseContexts = null, releaseContext = new ReleaseContext(log, name, json, entries, callback, customGrammar, verifies, initialised, fileContexts, combinedCustomGrammar, dependencyReleaseContexts);
        return releaseContext;
      }
    };
  });

  // node_modules/occam-languages/lib/nonTerminalNode.js
  var require_nonTerminalNode2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNode;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var {first: first2} = _necessary.arrayUtilities;
    var NonTerminalNode = class extends _occamparsers.NonTerminalNode {
      someTerminalNode(callback, tokenType) {
        return this.someChildNode((childNode, index) => {
          const childNodeTerminalNode = childNode.isTerminalNode();
          if (childNodeTerminalNode) {
            const terminalNode = childNode, terminalNodeType = terminalNode.getType();
            if (terminalNodeType === tokenType) {
              return callback(terminalNode, index);
            }
          }
        });
      }
      getNodeByRuleName(...ruleNames) {
        const node = this.findChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        }) || null;
        return node;
      }
      getNodesByRuleName(...ruleNames) {
        const nodes = this.filterChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        });
        return nodes;
      }
      getLastNodeByRuleName(...ruleNames) {
        let lastNode = null;
        this.backwardsSomeChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              lastNode = childNode;
              return true;
            }
          }
        });
        return lastNode;
      }
      getFirstNodeByRuleName(...ruleNames) {
        let firstNode = null;
        this.forwardsSomeChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              firstNode = childNode;
              return true;
            }
          }
        });
        return firstNode;
      }
      getSingularNodeByRuleName(...ruleNames) {
        let singularNode = null;
        const nodes = this.filterChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        }), nodesLength = nodes.length;
        if (nodesLength === 1) {
          const firstNode = first2(nodes);
          singularNode = firstNode;
        }
        return singularNode;
      }
      getDescendantNodesByRuleName(...ruleNames) {
        const nodes = this.filterDescendantNode((descendantNode) => {
          const descendantNodeNonTerminalNode = descendantNode.isNonTerminalNode();
          if (descendantNodeNonTerminalNode) {
            const nonTerminalNode = descendantNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        });
        return nodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/query.js
  var require_query4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
    var _default = {
      nodeQuery,
      nodesQuery
    };
  });

  // node_modules/occam-languages/lib/utilities/pass.js
  var require_pass = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get areTerminalNodeMapsEqual() {
        return areTerminalNodeMapsEqual;
      },
      get nonTerminalNodeQuery() {
        return nonTerminalNodeQuery;
      },
      get terminalNodeMapFromNodes() {
        return terminalNodeMapFromNodes;
      }
    });
    var _necessary = require_browser();
    var _query = require_query4();
    var {match} = _necessary.arrayUtilities;
    var nonTerminalNodeQuery = (0, _query.nodeQuery)("/*");
    function terminalNodeMapFromNodes(nodes) {
      const terminalNodeMap = {};
      nodes.forEach((node, index) => {
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          terminalNodeMap[index] = terminalNode;
        }
      });
      return terminalNodeMap;
    }
    function areTerminalNodeMapsEqual(generalTerminalNodeMap, specificTerminalNodeMap) {
      let terminalNodeMapsEqual = false;
      const generalIndexes = Object.keys(generalTerminalNodeMap), specificIndexes = Object.keys(specificTerminalNodeMap), terminalNodeMapKeysMatch = match(generalIndexes, specificIndexes, (generalIndex, specificIndex) => {
        if (generalIndex === specificIndex) {
          return true;
        }
      });
      if (terminalNodeMapKeysMatch) {
        const generalTerminalNodes = Object.values(generalTerminalNodeMap), specificTerminalNodes = Object.values(specificTerminalNodeMap), terminalNodeMapValuesMatch = match(generalTerminalNodes, specificTerminalNodes, (generalTerminalNode, specificTerminalNode) => {
          const generalTerminalNodeMatchesSpecificTerminalNode = generalTerminalNode.match(specificTerminalNode);
          if (generalTerminalNodeMatchesSpecificTerminalNode) {
            return true;
          }
        });
        terminalNodeMapsEqual = terminalNodeMapValuesMatch;
      }
      return terminalNodeMapsEqual;
    }
  });

  // node_modules/occam-languages/lib/pass/zip.js
  var require_zip = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZipPass;
      }
    });
    var _pass = require_pass();
    var ZipPass = class {
      run(generalNode, specificNode, ...remainingArguments) {
        let success;
        const visited = this.visitNode(generalNode, specificNode, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(generalChildNodes, specificChildNodes, ...remainingArguments) {
        let descended = false;
        const generalChildNodesLength = generalChildNodes.length, specificChildNodesLength = specificChildNodes.length;
        if (generalChildNodesLength === specificChildNodesLength) {
          const specificTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(specificChildNodes), generalTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(generalChildNodes), terminalNodeMapsEqual = (0, _pass.areTerminalNodeMapsEqual)(generalTerminalNodeMap, specificTerminalNodeMap);
          if (terminalNodeMapsEqual) {
            const visited = generalChildNodes.every((generalChildNode, index) => {
              const specificChildNode = specificChildNodes[index], specificNode = specificChildNode, generalNode = generalChildNode, visited2 = this.visitNode(generalNode, specificNode, ...remainingArguments);
              if (visited2) {
                return true;
              }
            });
            if (visited) {
              descended = true;
            }
          }
        }
        return descended;
      }
      visitNode(generalNode, specificNode, ...remainingArguments) {
        let visited = false;
        const generalNodeTerminalNode = generalNode.isTerminalNode(), specificNodeTerminalNode = specificNode.isTerminalNode(), generalNodeNonTerminalNode = generalNode.isNonTerminalNode(), specificNodeNonTerminalNode = specificNode.isNonTerminalNode();
        if (false) {
        } else if (generalNodeTerminalNode && specificNodeTerminalNode) {
          const generalTerminalNode = generalNode, specificTerminalNode = specificNode;
          visited = this.visitTerminalNode(generalTerminalNode, specificTerminalNode, ...remainingArguments);
        } else if (generalNodeNonTerminalNode && specificNodeNonTerminalNode) {
          const generalNonTerminalNode = generalNode, specificNonTerminalNode = specificNode;
          visited = this.visitNonTerminalNode(generalNonTerminalNode, specificNonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(generalTerminalNode, specificTerminalNode, ...remainingArguments) {
        let visited;
        visited = true;
        return visited;
      }
      visitNonTerminalNode(generalNonTerminalNode, specificNonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            generalNodeQuery: _pass.nonTerminalNodeQuery,
            specificNodeQuery: _pass.nonTerminalNodeQuery,
            run: (generalNode, specificNode, ...remainingArguments2) => {
              let visited2 = false;
              const generalNonTerminalNodeRuleName = generalNonTerminalNode.getRuleName(), specificNonTerminalNodeRuleName = specificNonTerminalNode.getRuleName();
              if (generalNonTerminalNodeRuleName === specificNonTerminalNodeRuleName) {
                const generalNonTerminalNodeChildNodes = generalNonTerminalNode.getChildNodes(), specificNonTerminalNodeChildNodes = specificNonTerminalNode.getChildNodes(), generalChildNodes = generalNonTerminalNodeChildNodes, specificChildNodes = specificNonTerminalNodeChildNodes, descended = this.descend(generalChildNodes, specificChildNodes, ...remainingArguments2);
                if (descended) {
                  visited2 = true;
                }
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {generalNodeQuery, specificNodeQuery, run} = map;
          const generalNode = generalNodeQuery(generalNonTerminalNode), specificNode = specificNodeQuery(specificNonTerminalNode);
          if (generalNode !== null && specificNode !== null) {
            const success = run(generalNode, specificNode, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/async.js
  var require_async2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AsyncPass;
      }
    });
    var _pass = require_pass();
    var _asynchronous = require_asynchronous2();
    var AsyncPass = class {
      async run(node, ...remainingArguments) {
        let success;
        const visited = await this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      async descend(childNodes, ...remainingArguments) {
        let descended = false;
        const visited = await (0, _asynchronous.asyncEvery)(childNodes, async (childNode) => {
          const node = childNode, visited2 = await this.visitNode(node, ...remainingArguments);
          if (visited2) {
            return true;
          }
        });
        if (visited) {
          descended = true;
        }
        return descended;
      }
      async visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = await this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = await this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      async visitTerminalNode(terminalNode, ...remainingArguments) {
        const visited = true;
        return visited;
      }
      async visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: async (node, ...remainingArguments2) => {
              let visited2 = false;
              const childNodes = nonTerminalNode.getChildNodes(), descended = await this.descend(childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        await (0, _asynchronous.asyncSome)(maps, async (map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = await run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/simple.js
  var require_simple = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SimplePass;
      }
    });
    var _pass = require_pass();
    var SimplePass = class {
      run(node, ...remainingArguments) {
        let success;
        const visited = this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(childNodes, ...remainingArguments) {
        let descended = false;
        const visited = childNodes.every((childNode) => {
          const node = childNode, visited2 = this.visitNode(node, ...remainingArguments);
          if (visited2) {
            return true;
          }
        });
        if (visited) {
          descended = true;
        }
        return descended;
      }
      visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(terminalNode, ...remainingArguments) {
        const visited = true;
        return visited;
      }
      visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: (node, ...remainingArguments2) => {
              let visited2 = false;
              const childNodes = nonTerminalNode.getChildNodes(), descended = this.descend(childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/forward.js
  var require_forward = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ForwardPass;
      }
    });
    var _pass = require_pass();
    var ForwardPass = class {
      run(node, ...remainingArguments) {
        let success;
        const visited = this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(index, childNodes, ...remainingArguments) {
        let descendedForward = false;
        const descendForward = remainingArguments.pop(), childNodesLength = childNodes.length;
        if (index === childNodesLength) {
          descendedForward = descendForward();
        } else {
          const childNode = childNodes[index], node = childNode, visited = this.visitNode(node, ...remainingArguments, () => {
            remainingArguments.push(descendForward);
            const aheadIndex = index + 1, descendedForward2 = this.descend(aheadIndex, childNodes, ...remainingArguments);
            return descendedForward2;
          });
          if (visited) {
            descendedForward = true;
          }
        }
        return descendedForward;
      }
      visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(terminalNode, ...remainingArguments) {
        let visited = false;
        const descendForward = remainingArguments.pop(), descendedForward = descendForward();
        if (descendedForward) {
          visited = true;
        }
        remainingArguments.push(descendForward);
        return visited;
      }
      visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: (node, ...remainingArguments2) => {
              let visited2 = false;
              const index = 0, childNodes = nonTerminalNode.getChildNodes(), descended = this.descend(index, childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/equivalence.js
  var require_equivalence = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EquivalencePass;
      }
    });
    var _pass = require_pass();
    var EquivalencePass = class {
      run(leftNode, rightNode, ...remainingArguments) {
        let success;
        const visited = this.visitNode(leftNode, rightNode, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(leftChildNodes, rightChildNodes, ...remainingArguments) {
        let descended = false;
        const leftChildNodesLength = leftChildNodes.length, rightChildNodesLength = rightChildNodes.length;
        if (leftChildNodesLength === rightChildNodesLength) {
          const leftTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(leftChildNodes), rightTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(rightChildNodes), terminalNodeMapsEqual = (0, _pass.areTerminalNodeMapsEqual)(leftTerminalNodeMap, rightTerminalNodeMap);
          if (terminalNodeMapsEqual) {
            descended = leftChildNodes.every((leftChildNode, index) => {
              const rightChildNode = rightChildNodes[index], leftNode = leftChildNode, rightNode = rightChildNode, visited = this.visitNode(leftNode, rightNode, ...remainingArguments);
              if (visited) {
                return true;
              }
            });
          }
        }
        return descended;
      }
      visitNode(leftNode, rightNode, ...remainingArguments) {
        let visited = false;
        const leftNodeTerminalNode = leftNode.isTerminalNode(), rightNodeTerminalNode = rightNode.isTerminalNode(), leftNodeNonTerminalNode = leftNode.isNonTerminalNode(), rightNodeNonTerminalNode = rightNode.isNonTerminalNode();
        if (false) {
        } else if (leftNodeTerminalNode && rightNodeTerminalNode) {
          const leftTerminalNode = leftNode, rightTerminalNode = rightNode;
          visited = this.visitTerminalNode(leftTerminalNode, rightTerminalNode, ...remainingArguments);
        } else if (leftNodeNonTerminalNode && rightNodeNonTerminalNode) {
          const leftNonTerminalNode = leftNode, rightNonTerminalNode = rightNode;
          visited = this.visitNonTerminalNode(leftNonTerminalNode, rightNonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(leftTerminalNode, rightTerminalNode, ...remainingArguments) {
        let visited;
        visited = true;
        return visited;
      }
      visitNonTerminalNode(leftNonTerminalNode, rightNonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            leftNodeQuery: _pass.nonTerminalNodeQuery,
            rightNodeQuery: _pass.nonTerminalNodeQuery,
            run: (leftNode, rightNode, ...remainingArguments2) => {
              let visited2 = false;
              const leftNonTerminalNodeRuleName = leftNonTerminalNode.getRuleName(), rightNonTerminalNodeRuleName = rightNonTerminalNode.getRuleName();
              if (leftNonTerminalNodeRuleName === rightNonTerminalNodeRuleName) {
                const leftNonTerminalNodeChildNodes = leftNonTerminalNode.getChildNodes(), rightNonTerminalNodeChildNodes = rightNonTerminalNode.getChildNodes(), leftChildNodes = leftNonTerminalNodeChildNodes, rightChildNodes = rightNonTerminalNodeChildNodes, descended = this.descend(leftChildNodes, rightChildNodes, ...remainingArguments2);
                if (descended) {
                  visited2 = true;
                }
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {leftNodeQuery, rightNodeQuery, run} = map;
          const leftNode = leftNodeQuery(leftNonTerminalNode), rightNode = rightNodeQuery(rightNonTerminalNode);
          if (leftNode !== null && rightNode !== null) {
            const success = run(leftNode, rightNode, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/dependency.js
  var require_dependency = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "asyncEveryDependency", {
      enumerable: true,
      get: function() {
        return asyncEveryDependency;
      }
    });
    var _asynchronous = require_asynchronous2();
    async function asyncEveryDependency(dependencies, callback) {
      const array = dependencies.getArray();
      return await (0, _asynchronous.asyncEvery)(array, callback);
    }
  });

  // node_modules/occam-languages/lib/utilities/verification.js
  var require_verification = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get createReleaseContext() {
        return createReleaseContext;
      },
      get default() {
        return _default;
      },
      get initialiseReleaseContext() {
        return initialiseReleaseContext;
      },
      get verifyReleaseContext() {
        return verifyReleaseContext;
      }
    });
    var _necessary = require_browser();
    var _dependency = require_dependency();
    var {last} = _necessary.arrayUtilities;
    function initialiseReleaseContext(dependency, context2) {
      const {log, releaseContextMap} = context2, dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext = releaseContextMap[releaseName] || null;
      if (releaseContext === null) {
        log.warning(`Unable to initialise the '${dependencyName}' context because it has not been created.`);
      } else {
        const releaseContextInitialised = releaseContext.isInitialised();
        if (!releaseContextInitialised) {
          initialiseDependencyReleaseContexts(dependency, releaseContext, context2);
          const releaseContexts = retrieveReleaseContexts(releaseContext, releaseContextMap);
          log.info(`Initialising the '${dependencyName}' context...`);
          const {FileContextFromFilePath} = context2;
          releaseContext.initialise(releaseContexts, FileContextFromFilePath);
          log.debug(`...initialised the '${dependencyName}' context.`);
        }
      }
    }
    async function createReleaseContext(dependency, dependentNames, context2) {
      let releaseContextCreated = false;
      const {log, releaseContextMap} = context2, dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext = releaseContextMap[releaseName] || null;
      if (releaseContext !== null) {
        const releaseMatchesDependency = checkReleaseMatchesDependency(releaseContext, dependency, dependentNames, context2);
        if (releaseMatchesDependency) {
          log.debug(`The '${releaseName}' context has already been created.`);
          releaseContextCreated = true;
        }
      } else {
        const dependencyString = dependency.asString(), dependentNamesLength = dependentNames.length;
        if (dependentNamesLength === 0) {
          log.info(`Creating the '${releaseName}' context...`);
        } else {
          const lastDependentName = last(dependentNames), dependentName = lastDependentName;
          log.info(`Creating the '${releaseName}' context given the '${dependentName}' dependant's '${dependencyString}' dependency...`);
        }
        const {releaseContextFromDependency} = context2, releaseContext2 = await releaseContextFromDependency(dependency, context2);
        if (releaseContext2 !== null) {
          const releaseMatchesDependency = checkReleaseMatchesDependency(releaseContext2, dependency, dependentNames, context2);
          if (releaseMatchesDependency) {
            releaseContextMap[releaseName] = releaseContext2;
            const dependencyReleaseContextsCreated = await createDependencyReleaseContexts(dependency, releaseContext2, dependentNames, context2);
            if (dependencyReleaseContextsCreated) {
              releaseContextCreated = true;
            }
          }
        } else {
          const dependencyName2 = dependency.getName(), releaseName2 = dependencyName2;
          log.warning(`The '${releaseName2}' context could not be created. Perhaps the 'meta.json' file is missing or invalid. Or there could be a dependency mismatch.`);
        }
        releaseContextCreated ? log.debug(`...created the '${releaseName}' context.`) : log.warning(`...unable to create the '${releaseName}' context.`);
      }
      return releaseContextCreated;
    }
    async function verifyReleaseContext(releaseName, dependentName, dependentReleased, releaseContextMap) {
      let releaseContextVerifies = false;
      const releaseContext = releaseContextMap[releaseName];
      if (releaseContext !== null) {
        const released = releaseContext.isReleased();
        if (released) {
          releaseContextVerifies = true;
        } else {
          if (dependentReleased) {
            releaseContext.warning(`The '${releaseName}' project cannot be verifies because its '${dependentName}' dependent is a package.`);
          } else {
            const dependentName2 = releaseName, dependentReleased2 = released, dependencyReleaseContextsVerify = await verifyDependencyReleaseContexts(releaseContext, dependentName2, dependentReleased2, releaseContextMap);
            if (dependencyReleaseContextsVerify) {
              const releaseContextVerified = releaseContext.hasVerified();
              if (releaseContextVerified) {
                releaseContextVerifies = true;
              } else {
                releaseContext.info(`Verifying the '${releaseName}' project...`);
                const verifies = await releaseContext.verify();
                if (verifies) {
                  releaseContext.info(`...verified the '${releaseName}' project.`);
                  releaseContextVerifies = true;
                }
              }
            }
          }
        }
      }
      return releaseContextVerifies;
    }
    var _default = {
      createReleaseContext,
      verifyReleaseContext,
      initialiseReleaseContext
    };
    async function createDependencyReleaseContexts(dependency, releaseContext, dependentNames, context2) {
      let dependencyReleaseContextsCreated;
      const dependencyName = dependency.getName(), dependencies = releaseContext.getDependencies();
      dependentNames = [
        ...dependentNames,
        dependencyName
      ];
      dependencyReleaseContextsCreated = await (0, _dependency.asyncEveryDependency)(dependencies, async (dependency2) => {
        const cyclicDependencyExists = checkCyclicDependencyExists(dependency2, dependentNames, context2);
        if (!cyclicDependencyExists) {
          const releaseContextCreated = await createReleaseContext(dependency2, dependentNames, context2);
          if (releaseContextCreated) {
            return true;
          }
        }
      });
      return dependencyReleaseContextsCreated;
    }
    async function verifyDependencyReleaseContexts(releaseContext, dependentName, dependentReleased, releaseContextMap) {
      const dependencies = releaseContext.getDependencies(), dependencyReleaseContextsVerify = await (0, _dependency.asyncEveryDependency)(dependencies, async (dependency) => {
        const name = dependency.getName(), releaseName = name, releaseContextVerifies = await verifyReleaseContext(releaseName, dependentName, dependentReleased, releaseContextMap);
        if (releaseContextVerifies) {
          return true;
        }
      });
      return dependencyReleaseContextsVerify;
    }
    function retrieveReleaseContexts(releaseContext, releaseContextMap) {
      const releaseContexts = [], remainingReleaseContext = releaseContext, remainingReleaseContexts = [
        remainingReleaseContext
      ];
      let remainingReleaseContextsLength = remainingReleaseContexts.length;
      while (remainingReleaseContextsLength > 0) {
        const remainingReleaseContext2 = remainingReleaseContexts.shift(), releaseContext2 = remainingReleaseContext2;
        releaseContexts.push(releaseContext2);
        const dependencies = releaseContext2.getDependencies();
        dependencies.forEachDependency((dependency) => {
          const dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext3 = releaseContextMap[releaseName], releaseContextsIncludesReleaseContext = releaseContexts.includes(releaseContext3), remainingReleaseContextsIncludesReleaseContext = remainingReleaseContexts.includes(releaseContext3);
          if (!releaseContextsIncludesReleaseContext && !remainingReleaseContextsIncludesReleaseContext) {
            const remainingReleaseContext3 = releaseContext3;
            remainingReleaseContexts.push(remainingReleaseContext3);
          }
        });
        remainingReleaseContextsLength = remainingReleaseContexts.length;
      }
      return releaseContexts;
    }
    function checkCyclicDependencyExists(dependency, dependentNames, context2) {
      const dependencyName = dependency.getName(), dependentNamesIncludesDependencyName = dependentNames.includes(dependencyName), cyclicDependencyExists = dependentNamesIncludesDependencyName;
      if (cyclicDependencyExists) {
        const {log} = context2, firstDependentName = first(dependentNames), dependencyNames = [
          ...dependentNames,
          firstDependentName
        ], dependencyNamesString = dependencyNames.join(`' -> '`);
        log.warning(`There is a cyclic dependency, '${dependencyNamesString}'.`);
      }
      return cyclicDependencyExists;
    }
    function checkReleaseMatchesDependency(releaseContext, dependency, dependentNames, context2) {
      let releaseMatchesDependency = true;
      const shortenedVersion = dependency.getShortedVersion();
      if (shortenedVersion !== null) {
        const entriesMatchShortenedVersion = releaseContext.matchShortenedVersion(shortenedVersion);
        if (!entriesMatchShortenedVersion) {
          const {log} = context2, version = releaseContext.getVersion(), lastDependentName = last(dependentNames), dependentName = lastDependentName, versionString = version.toString(), dependencyString = dependency.asString();
          log.warning(`The '${dependentName}' dependent requires the '${dependencyString}' dependency but a context with version '${versionString}' was provided.`);
          releaseMatchesDependency = false;
        }
      }
      return releaseMatchesDependency;
    }
    function initialiseDependencyReleaseContexts(dependency, releaseContext, context2) {
      const dependencies = releaseContext.getDependencies();
      dependencies.forEachDependency((dependency2) => {
        initialiseReleaseContext(dependency2, context2);
      });
    }
  });

  // node_modules/occam-model/lib/types.js
  var require_types2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DIRECTORY_TYPE() {
        return DIRECTORY_TYPE;
      },
      get FILE_TYPE() {
        return FILE_TYPE;
      }
    });
    var FILE_TYPE = "File";
    var DIRECTORY_TYPE = "Directory";
  });

  // node_modules/occam-model/lib/constants.js
  var require_constants12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_AMPERSAND() {
        return ESCAPED_AMPERSAND;
      },
      get ESCAPED_GREATER_THAN() {
        return ESCAPED_GREATER_THAN;
      },
      get ESCAPED_LESS_THAN() {
        return ESCAPED_LESS_THAN;
      }
    });
    var EMPTY_STRING = "";
    var DOUBLE_SPACE = "  ";
    var ESCAPED_AMPERSAND = "&amp;";
    var ESCAPED_LESS_THAN = "&lt;";
    var ESCAPED_GREATER_THAN = "&gt;";
  });

  // node_modules/occam-model/lib/utilities/content.js
  var require_content3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get convertContentTabsToWhitespace() {
        return convertContentTabsToWhitespace;
      },
      get default() {
        return _default;
      },
      get sanitiseContent() {
        return sanitiseContent;
      },
      get trimDoubleQuotes() {
        return trimDoubleQuotes;
      }
    });
    var _constants = require_constants12();
    function sanitiseContent(content) {
      const sanitisedContent = content.replace(/&/g, _constants.ESCAPED_AMPERSAND).replace(/</g, _constants.ESCAPED_LESS_THAN).replace(/>/g, _constants.ESCAPED_GREATER_THAN);
      return sanitisedContent;
    }
    function trimDoubleQuotes(content) {
      return content.replace(/(^"|"$)/g, _constants.EMPTY_STRING);
    }
    function convertContentTabsToWhitespace(content) {
      return content.replace(/\t/g, _constants.DOUBLE_SPACE);
    }
    var _default = {
      sanitiseContent,
      trimDoubleQuotes,
      convertContentTabsToWhitespace
    };
  });

  // node_modules/occam-model/lib/file.js
  var require_file2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return File;
      }
    });
    var _types = require_types2();
    var _content = require_content3();
    var _File = class {
      constructor(path, content, released) {
        this.path = path;
        this.content = content;
        this.released = released;
      }
      getPath() {
        return this.path;
      }
      getContent() {
        return this.content;
      }
      isReleased() {
        return this.released;
      }
      isFile() {
        const file = true;
        return file;
      }
      isDirectory() {
        const directory = false;
        return directory;
      }
      setPath(path) {
        this.path = path;
      }
      setContent(content) {
        this.content = content;
      }
      setReleased(released) {
        this.released = released;
      }
      matchFilePath(filePath) {
        const filePathMatches = this.path === filePath;
        return filePathMatches;
      }
      toJSON() {
        const {type} = _File, path = this.path, content = this.content, released = this.released, json = {
          type,
          path,
          content,
          released
        };
        return json;
      }
      static fromJSON(json) {
        let file = null;
        if (json !== null) {
          const {type} = json;
          if (type === _types.FILE_TYPE) {
            let {content} = json;
            const {path, released} = json;
            content = (0, _content.convertContentTabsToWhitespace)(content);
            file = new _File(path, content, released);
          }
        }
        return file;
      }
      static fromDocument(document2) {
        const filePath = document2.getFilePath(), released = document2.isReleased(), path = filePath;
        let content = document2.getContent();
        content = (0, _content.convertContentTabsToWhitespace)(content);
        const file = new _File(path, content, released);
        return file;
      }
      static fromPathContentAndReleased(path, content, released) {
        content = (0, _content.convertContentTabsToWhitespace)(content);
        const file = new _File(path, content, released);
        return file;
      }
    };
    var File = _File;
    __publicField(File, "type", _types.FILE_TYPE);
  });

  // node_modules/occam-model/lib/files.js
  var require_files = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Files;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Files = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getFilePaths() {
        const filePaths = this.mapFile((file) => {
          const filePath = file.getPath();
          return filePath;
        });
        return filePaths;
      }
      addFile(file) {
        this.array.push(file);
      }
      mapFile(callback) {
        return this.array.map(callback);
      }
      someFile(callback) {
        return this.array.some(callback);
      }
      reduceFile(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachFile(callback) {
        this.array.forEach(callback);
      }
      findFile(callback) {
        return this.array.find(callback) || null;
      }
      toJSON() {
        const filesJSON = this.array.map((file) => {
          const fileJSON = file !== null ? file.toJSON() : null;
          return fileJSON;
        }), json = filesJSON;
        return json;
      }
      static fromJSON(json) {
        const filesJSON = json, array = [], files = new Files(array);
        filesJSON.forEach((fileJSON) => {
          const json2 = fileJSON, file = _file.default.fromJSON(json2);
          files.addFile(file);
        });
        return files;
      }
      static fromNothing() {
        const array = [], files = new Files(array);
        return files;
      }
    };
  });

  // node_modules/occam-model/lib/multiplers.js
  var require_multiplers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get MAJOR_NUMBER_MULTIPLIER() {
        return MAJOR_NUMBER_MULTIPLIER;
      },
      get MINOR_NUMBER_MULTIPLIER() {
        return MINOR_NUMBER_MULTIPLIER;
      },
      get PATCH_NUMBER_MULTIPLIER() {
        return PATCH_NUMBER_MULTIPLIER;
      }
    });
    var MAJOR_NUMBER_MULTIPLIER = 1e12;
    var MINOR_NUMBER_MULTIPLIER = 1e6;
    var PATCH_NUMBER_MULTIPLIER = 1;
  });

  // node_modules/occam-model/lib/utilities/version.js
  var require_version2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get majorNumberFromNumber() {
        return majorNumberFromNumber;
      },
      get majorNumberFromString() {
        return majorNumberFromString;
      },
      get minorNumberFromNumber() {
        return minorNumberFromNumber;
      },
      get minorNumberFromString() {
        return minorNumberFromString;
      },
      get patchNumberFromNumber() {
        return patchNumberFromNumber;
      },
      get patchNumberFromString() {
        return patchNumberFromString;
      }
    });
    var _necessary = require_browser();
    var _multiplers = require_multiplers();
    var {second} = _necessary.arrayUtilities;
    function majorNumberFromNumber(number) {
      const majorNumber = number !== null ? Math.floor(number / _multiplers.MAJOR_NUMBER_MULTIPLIER) : 0;
      return majorNumber;
    }
    function minorNumberFromNumber(number) {
      const minorNumber = number !== null ? Math.floor(number % _multiplers.MAJOR_NUMBER_MULTIPLIER / _multiplers.MINOR_NUMBER_MULTIPLIER) : 0;
      return minorNumber;
    }
    function patchNumberFromNumber(number) {
      const patchNumber = number !== null ? Math.floor(number % _multiplers.MINOR_NUMBER_MULTIPLIER / _multiplers.PATCH_NUMBER_MULTIPLIER) : 0;
      return patchNumber;
    }
    function majorNumberFromString(string) {
      let majorNumber = 0;
      if (string) {
        const matches = string.match(/^(\d+)/), secondMatch = second(matches);
        majorNumber = Number(secondMatch);
      }
      return majorNumber;
    }
    function minorNumberFromString(string) {
      let minorNumber = 0;
      if (string) {
        const matches = string.match(/^\d+\.(\d+)/), secondMatch = second(matches);
        minorNumber = Number(secondMatch);
      }
      return minorNumber;
    }
    function patchNumberFromString(string) {
      let patchNumber = 0;
      if (string) {
        const matches = string.match(/^\d+\.\d+\.(\d+)/), secondMatch = second(matches);
        patchNumber = Number(secondMatch);
      }
      return patchNumber;
    }
  });

  // node_modules/occam-model/lib/version.js
  var require_version3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Version;
      }
    });
    var _multiplers = require_multiplers();
    var _version = require_version2();
    var Version = class {
      constructor(majorNumber, minorNumber, patchNumber) {
        this.majorNumber = majorNumber;
        this.minorNumber = minorNumber;
        this.patchNumber = patchNumber;
      }
      getMajorNumber() {
        return this.majorNumber;
      }
      getMinorNumber() {
        return this.minorNumber;
      }
      getPatchNumber() {
        return this.patchNumber;
      }
      bumpMajorNumber() {
        this.majorNumber += 1;
      }
      bumpMinorNumber() {
        this.minorNumber += 1;
      }
      bumpPatchNumber() {
        this.patchNumber += 1;
      }
      resetMajorNumber() {
        this.majorNumber = 0;
      }
      resetMinorNumber() {
        this.minorNumber = 0;
      }
      resetPatchNumber() {
        this.patchNumber = 0;
      }
      matchShortenedVersion(shortenedVersion) {
        let matchesShortenedVersion = false;
        if (shortenedVersion === null) {
          matchesShortenedVersion = true;
        } else {
          const majorNumber = shortenedVersion.getMajorNumber();
          if (this.majorNumber === majorNumber) {
            const minorNumber = shortenedVersion.getMinorNumber();
            if (this.minorNumber >= minorNumber) {
              matchesShortenedVersion = true;
            }
          }
        }
        return matchesShortenedVersion;
      }
      toString() {
        const string = `${this.majorNumber}.${this.minorNumber}.${this.patchNumber}`;
        return string;
      }
      toVersionNumber() {
        const versionNumber = this.majorNumber * _multiplers.MAJOR_NUMBER_MULTIPLIER + this.minorNumber * _multiplers.MINOR_NUMBER_MULTIPLIER + this.patchNumber * _multiplers.PATCH_NUMBER_MULTIPLIER;
        return versionNumber;
      }
      static fromString(string) {
        const majorNumber = (0, _version.majorNumberFromString)(string), minorNumber = (0, _version.minorNumberFromString)(string), patchNumber = (0, _version.patchNumberFromString)(string), version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromNothing() {
        const majorNumber = 0, minorNumber = 0, patchNumber = 0, version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromVersion(version) {
        const majorNumber = version.getMajorNumber(), minorNumber = version.getMinorNumber(), patchNumber = version.getPatchNumber();
        version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromVersionNumber(versionNumber) {
        const number = versionNumber, majorNumber = (0, _version.majorNumberFromNumber)(number), minorNumber = (0, _version.minorNumberFromNumber)(number), patchNumber = (0, _version.patchNumberFromNumber)(number), version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
    };
  });

  // node_modules/occam-model/lib/directory.js
  var require_directory = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Directory;
      }
    });
    var _types = require_types2();
    var _Directory = class {
      constructor(path) {
        this.path = path;
      }
      getPath() {
        return this.path;
      }
      isFile() {
        const file = false;
        return file;
      }
      isDirectory() {
        const directory = true;
        return directory;
      }
      toJSON() {
        const {type} = _Directory, path = this.path, json = {
          type,
          path
        };
        return json;
      }
      static fromPath(path) {
        const directory = new _Directory(path);
        return directory;
      }
      static fromJSON(json) {
        let directory = null;
        if (json !== null) {
          const {type} = json;
          if (type === _types.DIRECTORY_TYPE) {
            const {path} = json;
            directory = new _Directory(path);
          }
        }
        return directory;
      }
    };
    var Directory = _Directory;
    __publicField(Directory, "type", _types.DIRECTORY_TYPE);
  });

  // node_modules/occam-model/lib/utilities/name.js
  var require_name5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "fileNameFromFilePath", {
      enumerable: true,
      get: function() {
        return fileNameFromFilePath;
      }
    });
    var _necessary = require_browser();
    var {bottommostNameFromPath} = _necessary.pathUtilities;
    function fileNameFromFilePath(filePath) {
      const path = filePath, bottommostName = bottommostNameFromPath(path), fileName = bottommostName;
      return fileName;
    }
  });

  // node_modules/occam-model/lib/fileNames.js
  var require_fileNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get META_JSON_FILE_NAME() {
        return META_JSON_FILE_NAME;
      },
      get README_MD_FILE_NAME() {
        return README_MD_FILE_NAME;
      },
      get STATEMENT_BNF_FILE_NAME() {
        return STATEMENT_BNF_FILE_NAME;
      },
      get SYMBOL_VOCABULARY_FILE_NAME() {
        return SYMBOL_VOCABULARY_FILE_NAME;
      },
      get TERM_BNF_FILE_NAME() {
        return TERM_BNF_FILE_NAME;
      },
      get TYPE_VOCABULARY_FILE_NAME() {
        return TYPE_VOCABULARY_FILE_NAME;
      },
      get default() {
        return _default;
      }
    });
    var README_MD_FILE_NAME = "README.md";
    var META_JSON_FILE_NAME = "meta.json";
    var TERM_BNF_FILE_NAME = "term.bnf";
    var STATEMENT_BNF_FILE_NAME = "statement.bnf";
    var TYPE_VOCABULARY_FILE_NAME = "type.vcb";
    var SYMBOL_VOCABULARY_FILE_NAME = "symbol.vcb";
    var _default = {
      README_MD_FILE_NAME,
      META_JSON_FILE_NAME,
      TERM_BNF_FILE_NAME,
      STATEMENT_BNF_FILE_NAME,
      TYPE_VOCABULARY_FILE_NAME,
      SYMBOL_VOCABULARY_FILE_NAME
    };
  });

  // node_modules/occam-model/lib/mixins/bnf.js
  var require_bnf13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants12();
    var _name = require_name5();
    var _fileNames = require_fileNames();
    function getBNF(bnfFileName) {
      let bnf = _constants.EMPTY_STRING;
      const customGrammarBNFFiles = this.getCustomGrammarBNFFiles(), customGrammarBNFFile = customGrammarBNFFiles.find((customGrammarBNFFile2) => {
        const customGrammarBNFFilePath = customGrammarBNFFile2.getPath(), customGrammarBNFFileName = (0, _name.fileNameFromFilePath)(customGrammarBNFFilePath);
        if (customGrammarBNFFileName === bnfFileName) {
          return true;
        }
      }) || null;
      if (customGrammarBNFFile !== null) {
        const customGrammarBNFFileContent = customGrammarBNFFile.getContent();
        bnf = customGrammarBNFFileContent;
      }
      return bnf;
    }
    function getTermBNF() {
      const fileName = _fileNames.TERM_BNF_FILE_NAME, bnf = this.getBNF(fileName), termBNF = bnf;
      return termBNF;
    }
    function getStatementBNF() {
      const fileName = _fileNames.STATEMENT_BNF_FILE_NAME, bnf = this.getBNF(fileName), statementBNF = bnf;
      return statementBNF;
    }
    var bnfMixins = {
      getBNF,
      getTermBNF,
      getStatementBNF
    };
    var _default = bnfMixins;
  });

  // node_modules/occam-model/lib/utilities/filePath.js
  var require_filePath = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get isFilePathCustomGrammarBNFFilePath() {
        return isFilePathCustomGrammarBNFFilePath;
      },
      get isFilePathCustomGrammarVocabularyFilePath() {
        return isFilePathCustomGrammarVocabularyFilePath;
      },
      get isFilePathDefaultMarkdownStyleFilePath() {
        return isFilePathDefaultMarkdownStyleFilePath;
      },
      get isFilePathFurtleFilePath() {
        return isFilePathFurtleFilePath;
      },
      get isFilePathIndexJSONFilePath() {
        return isFilePathIndexJSONFilePath;
      },
      get isFilePathMarkdownFilePath() {
        return isFilePathMarkdownFilePath;
      },
      get isFilePathMarkdownStyleFilePath() {
        return isFilePathMarkdownStyleFilePath;
      },
      get isFilePathMetaJSONFilePath() {
        return isFilePathMetaJSONFilePath;
      },
      get isFilePathNominalFilePath() {
        return isFilePathNominalFilePath;
      },
      get isFilePathReadmeFilePath() {
        return isFilePathReadmeFilePath;
      },
      get isFilePathRecognisedFilePath() {
        return isFilePathRecognisedFilePath;
      },
      get isFilePathReleaseFilePath() {
        return isFilePathReleaseFilePath;
      }
    });
    var readmeFilePathPattern = "^(?:[^\\/]+\\/){1}README\\.md$";
    var furtleFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.ftl$";
    var nominalFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.nml$";
    var markdownFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.md$";
    var metaJSONFilePathPattern = "^(?:[^\\/]+\\/){1}meta\\.json$";
    var indexJSONFilePathPattern = "^(?:[^\\/]+\\/){1}index\\.json$";
    var markdownStyleFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.mds$";
    var customGrammarBNFFilePathPattern = "^(?:[^\\/]+\\/){1}(term|statement)\\.bnf$";
    var defaultMarkdownStyleFilePathPattern = "^[^\\/]+\\/default\\.mds$";
    var customGrammarVocabularyFilePathPattern = "^(?:[^\\/]+\\/){1}(type|symbol)\\.vcb$";
    var releaseFilePathPattern = `${readmeFilePathPattern}|${furtleFilePathPattern}|${nominalFilePathPattern}|${metaJSONFilePathPattern}|${customGrammarBNFFilePathPattern}|${customGrammarVocabularyFilePathPattern}`;
    var recognisedFilePathPattern = `${releaseFilePathPattern}|${indexJSONFilePathPattern}|${markdownFilePathPattern}|${markdownStyleFilePathPattern}`;
    var readmeFilePathRegularExpression = new RegExp(readmeFilePathPattern);
    var furtleFilePathRegularExpression = new RegExp(furtleFilePathPattern);
    var releaseFilePathRegularExpression = new RegExp(releaseFilePathPattern);
    var nominalFilePathRegularExpression = new RegExp(nominalFilePathPattern);
    var markdownFilePathRegularExpression = new RegExp(markdownFilePathPattern);
    var metaJSONFilePathRegularExpression = new RegExp(metaJSONFilePathPattern);
    var indexJSONFilePathRegularExpression = new RegExp(indexJSONFilePathPattern);
    var recognisedFilePathRegularExpression = new RegExp(recognisedFilePathPattern);
    var markdownStyleFilePathRegularExpression = new RegExp(markdownStyleFilePathPattern);
    var customGrammarBNFFilePathRegularExpression = new RegExp(customGrammarBNFFilePathPattern);
    var defaultMarkdownStyleFilePathRegularExpression = new RegExp(defaultMarkdownStyleFilePathPattern);
    var customGrammarVocabularyFilePathRegularExpression = new RegExp(customGrammarVocabularyFilePathPattern);
    function isFilePathReadmeFilePath(filePath) {
      return readmeFilePathRegularExpression.test(filePath);
    }
    function isFilePathFurtleFilePath(filePath) {
      return furtleFilePathRegularExpression.test(filePath);
    }
    function isFilePathReleaseFilePath(filePath) {
      return releaseFilePathRegularExpression.test(filePath);
    }
    function isFilePathNominalFilePath(filePath) {
      return nominalFilePathRegularExpression.test(filePath);
    }
    function isFilePathMarkdownFilePath(filePath) {
      return markdownFilePathRegularExpression.test(filePath);
    }
    function isFilePathMetaJSONFilePath(filePath) {
      return metaJSONFilePathRegularExpression.test(filePath);
    }
    function isFilePathIndexJSONFilePath(filePath) {
      return indexJSONFilePathRegularExpression.test(filePath);
    }
    function isFilePathRecognisedFilePath(filePath) {
      return recognisedFilePathRegularExpression.test(filePath);
    }
    function isFilePathMarkdownStyleFilePath(filePath) {
      return markdownStyleFilePathRegularExpression.test(filePath);
    }
    function isFilePathCustomGrammarBNFFilePath(filePath) {
      return customGrammarBNFFilePathRegularExpression.test(filePath);
    }
    function isFilePathDefaultMarkdownStyleFilePath(filePath) {
      return defaultMarkdownStyleFilePathRegularExpression.test(filePath);
    }
    function isFilePathCustomGrammarVocabularyFilePath(filePath) {
      return customGrammarVocabularyFilePathRegularExpression.test(filePath);
    }
    var _default = {
      isFilePathReadmeFilePath,
      isFilePathFurtleFilePath,
      isFilePathReleaseFilePath,
      isFilePathNominalFilePath,
      isFilePathMarkdownFilePath,
      isFilePathMetaJSONFilePath,
      isFilePathIndexJSONFilePath,
      isFilePathRecognisedFilePath,
      isFilePathMarkdownStyleFilePath,
      isFilePathCustomGrammarBNFFilePath,
      isFilePathDefaultMarkdownStyleFilePath,
      isFilePathCustomGrammarVocabularyFilePath
    };
  });

  // node_modules/occam-model/lib/utilities/files.js
  var require_files2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get customGrammarBNFFilesFromFiles() {
        return customGrammarBNFFilesFromFiles;
      },
      get customGrammarVocabularyFilesFromFiles() {
        return customGrammarVocabularyFilesFromFiles;
      },
      get furtleFilesFromFiles() {
        return furtleFilesFromFiles;
      },
      get metaJSONFileFromFiles() {
        return metaJSONFileFromFiles;
      },
      get nominalFilesFromFiles() {
        return nominalFilesFromFiles;
      },
      get readmeFileFromFiles() {
        return readmeFileFromFiles;
      }
    });
    var _filePath = require_filePath();
    function readmeFileFromFiles(files) {
      let readmeFile = null;
      files.someFile((file) => {
        const filePath = file.getPath(), filePathReadmeFilePath = (0, _filePath.isFilePathReadmeFilePath)(filePath);
        if (filePathReadmeFilePath) {
          readmeFile = file;
          return true;
        }
      });
      return readmeFile;
    }
    function furtleFilesFromFiles(files) {
      const furtleFiles = files.reduceFile((furtleFiles2, file) => {
        const filePath = file.getPath(), filePathFurtleFilePath = (0, _filePath.isFilePathFurtleFilePath)(filePath), fileFurtleFile = filePathFurtleFilePath;
        if (fileFurtleFile) {
          const furtleFile = file;
          furtleFiles2.push(furtleFile);
        }
        return furtleFiles2;
      }, []);
      return furtleFiles;
    }
    function nominalFilesFromFiles(files) {
      const nominalFiles = files.reduceFile((nominalFiles2, file) => {
        const filePath = file.getPath(), filePathNominalFilePath = (0, _filePath.isFilePathNominalFilePath)(filePath), fileNominalFile = filePathNominalFilePath;
        if (fileNominalFile) {
          const nominalFile = file;
          nominalFiles2.push(nominalFile);
        }
        return nominalFiles2;
      }, []);
      return nominalFiles;
    }
    function metaJSONFileFromFiles(files) {
      let metaJSONFile = null;
      files.someFile((file) => {
        const filePath = file.getPath(), filePathMetaJSONFilePath = (0, _filePath.isFilePathMetaJSONFilePath)(filePath);
        if (filePathMetaJSONFilePath) {
          metaJSONFile = file;
          return true;
        }
      });
      return metaJSONFile;
    }
    function customGrammarBNFFilesFromFiles(files) {
      const customGrammarBNFFiles = files.reduceFile((customGrammarBNFFiles2, file) => {
        const filePath = file.getPath(), filePathCustomGrammarBNFFilePath = (0, _filePath.isFilePathCustomGrammarBNFFilePath)(filePath), fileCustomGrammarBNFFile = filePathCustomGrammarBNFFilePath;
        if (fileCustomGrammarBNFFile) {
          const customGrammarBNFFile = file;
          customGrammarBNFFiles2.push(customGrammarBNFFile);
        }
        return customGrammarBNFFiles2;
      }, []);
      return customGrammarBNFFiles;
    }
    function customGrammarVocabularyFilesFromFiles(files) {
      const customGrammarVocabularyFiles = files.reduceFile((customGrammarVocabularyFiles2, file) => {
        const filePath = file.getPath(), filePathCustomGrammarVocabularyFilePath = (0, _filePath.isFilePathCustomGrammarVocabularyFilePath)(filePath), fileCustomGrammarVocabularyFile = filePathCustomGrammarVocabularyFilePath;
        if (fileCustomGrammarVocabularyFile) {
          const customGrammarVocabularyFile = file;
          customGrammarVocabularyFiles2.push(customGrammarVocabularyFile);
        }
        return customGrammarVocabularyFiles2;
      }, []);
      return customGrammarVocabularyFiles;
    }
  });

  // node_modules/occam-model/lib/mixins/files.js
  var require_files3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _files = require_files2();
    function getReadmeFile() {
      const files = this.getFiles(), readmeFile = (0, _files.readmeFileFromFiles)(files);
      return readmeFile;
    }
    function getFurtleFiles() {
      const files = this.getFiles(), furtleFiles = (0, _files.furtleFilesFromFiles)(files);
      return furtleFiles;
    }
    function getNominalFiles() {
      const files = this.getFiles(), nominalFiles = (0, _files.nominalFilesFromFiles)(files);
      return nominalFiles;
    }
    function getMetaJSONFile() {
      const files = this.getFiles(), metaJSONFile = (0, _files.metaJSONFileFromFiles)(files);
      return metaJSONFile;
    }
    function getCustomGrammarBNFFiles() {
      const files = this.getFiles(), customGrammarBNFFiles = (0, _files.customGrammarBNFFilesFromFiles)(files);
      return customGrammarBNFFiles;
    }
    function getCustomGrammarVocabularyFiles() {
      const files = this.getFiles(), customGrammarVocabularyFiles = (0, _files.customGrammarVocabularyFilesFromFiles)(files);
      return customGrammarVocabularyFiles;
    }
    var filesMixins = {
      getReadmeFile,
      getFurtleFiles,
      getNominalFiles,
      getMetaJSONFile,
      getCustomGrammarBNFFiles,
      getCustomGrammarVocabularyFiles
    };
    var _default = filesMixins;
  });

  // node_modules/occam-model/lib/dependency.js
  var require_dependency2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Dependency;
      }
    });
    var Dependency = class {
      constructor(name, shortenedVersion) {
        this.name = name;
        this.shortenedVersion = shortenedVersion;
      }
      getName() {
        return this.name;
      }
      getShortedVersion() {
        return this.shortenedVersion;
      }
      asString() {
        let string;
        if (this.shortenedVersion !== null) {
          const shortenedVersionString = this.shortenedVersion.toString();
          string = `${this.name}@${shortenedVersionString}`;
        } else {
          string = this.name;
        }
        return string;
      }
      static fromName(name) {
        const shortenedVersion = null, dependency = new Dependency(name, shortenedVersion);
        return dependency;
      }
      static fromNameAndShortenedVersion(name, shortenedVersion) {
        const dependency = new Dependency(name, shortenedVersion);
        return dependency;
      }
    };
  });

  // node_modules/occam-model/lib/shortenedVersion.js
  var require_shortenedVersion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ShortenedVersion;
      }
    });
    var _multiplers = require_multiplers();
    var _version = require_version2();
    var ShortenedVersion = class {
      constructor(majorNumber, minorNumber) {
        this.majorNumber = majorNumber;
        this.minorNumber = minorNumber;
      }
      getMajorNumber() {
        return this.majorNumber;
      }
      getMinorNumber() {
        return this.minorNumber;
      }
      toString() {
        const string = `${this.majorNumber}.${this.minorNumber}`;
        return string;
      }
      toVersionNumber() {
        const versionNumber = this.majorNumber * _multiplers.MAJOR_NUMBER_MULTIPLIER + this.minorNumber * _multiplers.MINOR_NUMBER_MULTIPLIER;
        return versionNumber;
      }
      getLeastMatchingVersionNumber() {
        const versionNumber = this.toVersionNumber(), leastMatchingVersionNumber = versionNumber;
        return leastMatchingVersionNumber;
      }
      getGreatestMatchingVersionNumber() {
        const majorNumber = this.majorNumber + 1, minorNumber = 0, shortenedVersion = ShortenedVersion.fromMajorNumberAndMinorNumber(majorNumber, minorNumber), shortenedVersionNumber = shortenedVersion.toVersionNumber(), greatestMatchingVersionNumber = shortenedVersionNumber - 1;
        return greatestMatchingVersionNumber;
      }
      static fromString(string) {
        const majorNumber = (0, _version.majorNumberFromString)(string), minorNumber = (0, _version.minorNumberFromString)(string), shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
      static fromVersionNumber(versionNumber) {
        const number = versionNumber, majorNumber = (0, _version.majorNumberFromNumber)(number), minorNumber = (0, _version.minorNumberFromNumber)(number), shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
      static fromMajorNumberAndMinorNumber(majorNumber, minorNumber) {
        const shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
    };
  });

  // node_modules/occam-model/lib/dependencies.js
  var require_dependencies = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Dependencies;
      }
    });
    var _necessary = require_browser();
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Dependencies = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      addDependency(dependency) {
        this.array.push(dependency);
      }
      mapDependency(callback) {
        return this.array.map(callback);
      }
      everyDependency(callback) {
        return this.array.every(callback);
      }
      reduceDependency(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachDependency(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachDependency(operation, done) {
        forEach(this.array, operation, done);
      }
      toJSON() {
        const dependenciesJSON = this.array.reduce((dependenciesJSON2, dependency) => {
          const name = dependency.getName(), shortenedVersion = dependency.getShortedVersion(), shortenedVersionString = shortenedVersion.toString();
          dependenciesJSON2[name] = shortenedVersionString;
          return dependenciesJSON2;
        }, {}), json = dependenciesJSON;
        return json;
      }
      static fromJSON(json) {
        const dependenciesJSON = json, dependenciesJSONKeys = Object.keys(dependenciesJSON), names = dependenciesJSONKeys, array = names.map((name) => {
          const shortenedVersionString = dependenciesJSON[name], string = shortenedVersionString, shortenedVersion = _shortenedVersion.default.fromString(string), dependency = _dependency.default.fromNameAndShortenedVersion(name, shortenedVersion);
          return dependency;
        }), dependencies = new Dependencies(array);
        return dependencies;
      }
      static fromNothing() {
        const array = [], dependencies = new Dependencies(array);
        return dependencies;
      }
    };
  });

  // node_modules/occam-model/lib/utilities/query.js
  var require_query5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
  });

  // node_modules/occam-model/lib/utilities/validate.js
  var require_validate2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isStringShortenedVersionString() {
        return isStringShortenedVersionString;
      },
      get isStringVersionString() {
        return isStringVersionString;
      }
    });
    function isStringVersionString(string) {
      return /(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))/.test(string);
    }
    function isStringShortenedVersionString(string) {
      return /(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))/.test(string);
    }
  });

  // node_modules/occam-model/lib/propertyNames.js
  var require_propertyNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DEPENDENCIES_PROPERTY_NAME() {
        return DEPENDENCIES_PROPERTY_NAME;
      },
      get REPOSITORY_PROPERTY_NAME() {
        return REPOSITORY_PROPERTY_NAME;
      },
      get VERSION_PROPERTY_NAME() {
        return VERSION_PROPERTY_NAME;
      }
    });
    var VERSION_PROPERTY_NAME = "version";
    var REPOSITORY_PROPERTY_NAME = "repository";
    var DEPENDENCIES_PROPERTY_NAME = "dependencies";
  });

  // node_modules/occam-model/lib/utilities/metaJSON.js
  var require_metaJSON = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get dependenciesFromDocumentNode() {
        return dependenciesFromDocumentNode;
      },
      get dependencyNamesFromDocumentNode() {
        return dependencyNamesFromDocumentNode;
      },
      get documentNodeFromMetaJSONFile() {
        return documentNodeFromMetaJSONFile;
      },
      get isMetaJSONFileValid() {
        return isMetaJSONFileValid;
      },
      get repositoryFromDocumentNode() {
        return repositoryFromDocumentNode;
      },
      get updateMetaJSONFileVersion() {
        return updateMetaJSONFileVersion;
      },
      get versionFromDocumentNode() {
        return versionFromDocumentNode;
      }
    });
    var _occamgrammars = require_lib11();
    var _version = /* @__PURE__ */ _interop_require_default(require_version3());
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _dependencies = /* @__PURE__ */ _interop_require_default(require_dependencies());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    var _constants = require_constants12();
    var _content = require_content3();
    var _query = require_query5();
    var _validate = require_validate2();
    var _propertyNames = require_propertyNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var jsonLexer = _occamgrammars.JSONLexer.fromNothing();
    var jsonParser = _occamgrammars.JSONParser.fromNothing();
    var errorNodesQuery = (0, _query.nodesQuery)("/*/error");
    var propertyNodesQuery = (0, _query.nodesQuery)("/property/json/object/property");
    var documentPropertyNodesQuery = (0, _query.nodesQuery)("/document/json/object/property");
    var propertyStringLiteralTerminalNodeQuery = (0, _query.nodeQuery)("/property/@string-literal");
    var propertyJSONStringLiteralTerminalNodeQuery = (0, _query.nodeQuery)("/property/json/@string-literal!");
    function isMetaJSONFileValid(metaJSONFile) {
      let metaJSONFileValid = false;
      const documentNode = documentNodeFromMetaJSONFile(metaJSONFile);
      if (documentNode !== null) {
        const errorNodes = errorNodesQuery(documentNode), errorNodesLength = errorNodes.length;
        if (errorNodesLength === 0) {
          const version = versionFromDocumentNode(documentNode), repository = repositoryFromDocumentNode(documentNode), dependencies = dependenciesFromDocumentNode(documentNode);
          metaJSONFileValid = version !== null && repository !== null && dependencies !== null;
        }
      }
      return metaJSONFileValid;
    }
    function updateMetaJSONFileVersion(metaJSONFile, version) {
      const documentNode = documentNodeFromMetaJSONFile(metaJSONFile), repository = repositoryFromDocumentNode(documentNode);
      let dependencies = dependenciesFromDocumentNode(documentNode);
      const string = version.toString(), dependenciesJSON = dependencies.toJSON();
      version = string;
      dependencies = dependenciesJSON;
      const metaJSON = {
        version,
        repository,
        dependencies
      }, metaJSONString = JSON.stringify(metaJSON, null, _constants.DOUBLE_SPACE), metaJSONFileContent = metaJSONString;
      metaJSONFile.setContent(metaJSONFileContent);
    }
    function documentNodeFromMetaJSONFile(metaJSONFile) {
      let documentNode = null;
      if (metaJSONFile !== null) {
        const content = metaJSONFile.getContent(), tokens = jsonLexer.tokenise(content), node = jsonParser.parse(tokens);
        documentNode = node;
      }
      return documentNode;
    }
    function versionFromDocumentNode(documentNode) {
      let version = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.VERSION_PROPERTY_NAME) {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringVersionString = (0, _validate.isStringVersionString)(string);
            if (stringVersionString) {
              version = _version.default.fromString(string);
            }
            return true;
          }
        }
      });
      return version;
    }
    function repositoryFromDocumentNode(documentNode) {
      let repository = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.REPOSITORY_PROPERTY_NAME) {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode);
          if (stringPropertyValue !== null) {
            repository = stringPropertyValue;
            return true;
          }
        }
      });
      return repository;
    }
    function dependenciesFromDocumentNode(documentNode) {
      let dependencies = null;
      const dependenciesPropertyNode = dependenciesPropertyNodeFromDocumentNode(documentNode);
      if (dependenciesPropertyNode !== null) {
        dependencies = _dependencies.default.fromNothing();
        const propertyNode = dependenciesPropertyNode, propertyNodes = propertyNodesQuery(propertyNode);
        propertyNodes.forEach((propertyNode2) => {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode2);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringShortenedVersionString = (0, _validate.isStringShortenedVersionString)(string);
            if (stringShortenedVersionString) {
              const propertyName = propertyNameFromPropertyNode(propertyNode2), name = propertyName, shortenedVersion = _shortenedVersion.default.fromString(string), dependency = _dependency.default.fromNameAndShortenedVersion(name, shortenedVersion);
              dependencies.addDependency(dependency);
            }
          }
        });
      }
      return dependencies;
    }
    function dependencyNamesFromDocumentNode(documentNode) {
      let dependencyNames = null;
      const dependenciesPropertyNode = dependenciesPropertyNodeFromDocumentNode(documentNode);
      if (dependenciesPropertyNode !== null) {
        dependencyNames = [];
        const propertyNode = dependenciesPropertyNode, propertyNodes = propertyNodesQuery(propertyNode);
        propertyNodes.forEach((propertyNode2) => {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode2);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringShortenedVersionString = (0, _validate.isStringShortenedVersionString)(string);
            if (stringShortenedVersionString) {
              const propertyName = propertyNameFromPropertyNode(propertyNode2), dependencyName = propertyName;
              dependencyNames.push(dependencyName);
            }
          }
        });
      }
      return dependencyNames;
    }
    var _default = {
      isMetaJSONFileValid,
      updateMetaJSONFileVersion,
      documentNodeFromMetaJSONFile,
      versionFromDocumentNode,
      repositoryFromDocumentNode,
      dependenciesFromDocumentNode,
      dependencyNamesFromDocumentNode
    };
    function propertyNameFromPropertyNode(propertyNode) {
      const propertyStringLiteralTerminalNode = propertyStringLiteralTerminalNodeQuery(propertyNode), propertyStringLiteralTerminalNodeContent = propertyStringLiteralTerminalNode.getContent(), propertyName = (0, _content.trimDoubleQuotes)(propertyStringLiteralTerminalNodeContent);
      return propertyName;
    }
    function stringPropertyValueFromPropertyNode(propertyNode) {
      let stringPropertyValue = null;
      const propertyJSONStringLiteralTerminalNode = propertyJSONStringLiteralTerminalNodeQuery(propertyNode);
      if (propertyJSONStringLiteralTerminalNode !== null) {
        const propertyJSONStringLiteralTerminalNodeContent = propertyJSONStringLiteralTerminalNode.getContent();
        stringPropertyValue = (0, _content.trimDoubleQuotes)(propertyJSONStringLiteralTerminalNodeContent);
      }
      return stringPropertyValue;
    }
    function documentPropertyNodesFromDocumentNode(documentNode) {
      const documentPropertyNodes = documentPropertyNodesQuery(documentNode);
      return documentPropertyNodes;
    }
    function dependenciesPropertyNodeFromDocumentNode(documentNode) {
      let dependenciesPropertyNode = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.DEPENDENCIES_PROPERTY_NAME) {
          dependenciesPropertyNode = propertyNode;
          return true;
        }
      });
      return dependenciesPropertyNode;
    }
  });

  // node_modules/occam-model/lib/mixins/metaJSON.js
  var require_metaJSON2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _metaJSON = require_metaJSON();
    function getVersion() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), version = (0, _metaJSON.versionFromDocumentNode)(documentNode);
      return version;
    }
    function getRepository() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), repository = (0, _metaJSON.repositoryFromDocumentNode)(documentNode);
      return repository;
    }
    function getDependencies() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), dependencies = (0, _metaJSON.dependenciesFromDocumentNode)(documentNode);
      return dependencies;
    }
    function getDependencyNames() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), dependencyNames = (0, _metaJSON.dependencyNamesFromDocumentNode)(documentNode);
      return dependencyNames;
    }
    var metaJSONMixins = {
      getVersion,
      getRepository,
      getDependencies,
      getDependencyNames
    };
    var _default = metaJSONMixins;
  });

  // node_modules/occam-model/lib/mixins/vocabulary.js
  var require_vocabulary2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants12();
    var _name = require_name5();
    var _fileNames = require_fileNames();
    function getVocabulary(vocabularyFileName) {
      let vocabulary = _constants.EMPTY_STRING;
      const customGrammarVocabularyFiles = this.getCustomGrammarVocabularyFiles(), customGrammarVocabularyFile = customGrammarVocabularyFiles.find((customGrammarVocabularyFile2) => {
        const customGrammarVocabularyFilePath = customGrammarVocabularyFile2.getPath(), customGrammarVocabularyFileName = (0, _name.fileNameFromFilePath)(customGrammarVocabularyFilePath);
        if (customGrammarVocabularyFileName === vocabularyFileName) {
          return true;
        }
      }) || null;
      if (customGrammarVocabularyFile !== null) {
        const customGrammarVocabularyFileContent = customGrammarVocabularyFile.getContent();
        vocabulary = customGrammarVocabularyFileContent;
      }
      return vocabulary;
    }
    function getTypeVocabulary() {
      const fileName = _fileNames.TYPE_VOCABULARY_FILE_NAME, vocabulary = this.getVocabulary(fileName), typeVocabulary = vocabulary;
      return typeVocabulary;
    }
    function getSymbolVocabulary() {
      const fileName = _fileNames.SYMBOL_VOCABULARY_FILE_NAME, vocabulary = this.getVocabulary(fileName), symbolVocabulary = vocabulary;
      return symbolVocabulary;
    }
    var vocabularyMixins = {
      getVocabulary,
      getTypeVocabulary,
      getSymbolVocabulary
    };
    var _default = vocabularyMixins;
  });

  // node_modules/occam-model/lib/entries.js
  var require_entries12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _files = /* @__PURE__ */ _interop_require_default(require_files());
    var _directory = /* @__PURE__ */ _interop_require_default(require_directory());
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf13());
    var _files1 = /* @__PURE__ */ _interop_require_default(require_files3());
    var _metaJSON = /* @__PURE__ */ _interop_require_default(require_metaJSON2());
    var _vocabulary = /* @__PURE__ */ _interop_require_default(require_vocabulary2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, filter} = _necessary.arrayUtilities;
    var {topmostDirectoryNameFromPath} = _necessary.pathUtilities;
    var Entries = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getTopmostDirectoryName() {
        let topmostDirectoryName = null;
        const firstEntry = first2(this.array);
        if (firstEntry) {
          const firstEntryPath = firstEntry.getPath();
          topmostDirectoryName = topmostDirectoryNameFromPath(firstEntryPath);
          if (topmostDirectoryName === null) {
            topmostDirectoryName = firstEntryPath;
          }
        }
        return topmostDirectoryName;
      }
      removeFileByPath(path) {
        filter(this.array, (entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry, filePath = file.getPath();
            if (filePath === path) {
              return false;
            }
          }
          return true;
        });
      }
      findFile(filePath) {
        const files = this.getFiles(), file = files.findFile((file2) => {
          const filePathMatches = file2.matchFilePath(filePath);
          if (filePathMatches) {
            return true;
          }
        }) || null;
        return file;
      }
      getFiles() {
        const files = _files.default.fromNothing();
        this.mapEntry((entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry;
            files.addFile(file);
          }
        });
        return files;
      }
      getFilePaths() {
        const filePaths = this.reduceEntry((filePaths2, entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry, filePath = file.getPath();
            filePaths2.push(filePath);
          }
          return filePaths2;
        }, []);
        return filePaths;
      }
      getDirectoryPaths() {
        const directoryPaths = this.reduceEntry((directoryPaths2, entry) => {
          const entryDirectory = entry.isDirectory();
          if (entryDirectory) {
            const directory = entry, directoryPath = directory.getPath();
            directoryPaths2.push(directoryPath);
          }
          return directoryPaths2;
        }, []);
        return directoryPaths;
      }
      matchShortenedVersion(shortenedVersion) {
        const version = this.getVersion(), versionMatchesShortenedVersion = version.matchShortenedVersion(shortenedVersion);
        return versionMatchesShortenedVersion;
      }
      addFile(file) {
        const entry = file;
        this.addEntry(entry);
      }
      addEntry(entry) {
        this.array.push(entry);
      }
      addDirectory(directory) {
        const entry = directory;
        this.addEntry(entry);
      }
      forEachFile(callback) {
        const files = this.getFiles();
        files.forEachFile(callback);
      }
      mapEntry(callback) {
        return this.array.map(callback);
      }
      someEntry(callback) {
        return this.array.some(callback);
      }
      everyEntry(callback) {
        return this.array.every(callback);
      }
      forEachEntry(callback) {
        this.array.forEach(callback);
      }
      reduceEntry(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      toJSON() {
        const entriesJSON = this.array.map((entry) => {
          const entryJSON = entry.toJSON();
          return entryJSON;
        }), json = entriesJSON;
        return json;
      }
      static fromJSON(json) {
        const array = [], entries = new Entries(array), entriesJSON = json;
        entriesJSON.map((entryJSON) => {
          const json2 = entryJSON, file = _file.default.fromJSON(json2), directory = _directory.default.fromJSON(json2), entry = file || directory;
          entries.addEntry(entry);
        });
        return entries;
      }
      static fromEntry(entry) {
        const array = [
          entry
        ], entries = new Entries(array);
        return entries;
      }
      static fromNothing() {
        const array = [], entries = new Entries(array);
        return entries;
      }
    };
    Object.assign(Entries.prototype, _bnf.default);
    Object.assign(Entries.prototype, _files1.default);
    Object.assign(Entries.prototype, _metaJSON.default);
    Object.assign(Entries.prototype, _vocabulary.default);
    var _default = Entries;
  });

  // node_modules/occam-model/lib/mixins/entries.js
  var require_entries13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    function forEachFile(callback) {
      return this.entries.forEachFile(callback);
    }
    function findFile(filePath) {
      return this.entries.findFile(filePath);
    }
    function getBNF() {
      return this.entries.getBNF();
    }
    function getFiles() {
      return this.entries.getFiles();
    }
    function getTermBNF() {
      return this.entries.getTermBNF();
    }
    function getVersion() {
      return this.entries.getVersion();
    }
    function getFilePaths() {
      return this.entries.getFilePaths();
    }
    function getVocabulary() {
      return this.entries.getVocabulary();
    }
    function getRepository() {
      return this.entries.getRepository();
    }
    function getReadmeFile() {
      return this.entries.getReadmeFile();
    }
    function getStatementBNF() {
      return this.entries.getStatementBNF();
    }
    function getDependencies() {
      return this.entries.getDependencies();
    }
    function getTypeVocabulary() {
      return this.entries.getTypeVocabulary();
    }
    function getSymbolVocabulary() {
      return this.entries.getSymbolVocabulary();
    }
    function getMetaJSONFile() {
      return this.entries.getMetaJSONFile();
    }
    function getFurtleFiles() {
      return this.entries.getFurtleFiles();
    }
    function getNominalFiles() {
      return this.entries.getNominalFiles();
    }
    function getDirectoryPaths() {
      return this.entries.getDirectoryPaths();
    }
    function getDependencyNames() {
      return this.entries.getDependencyNames();
    }
    function getCustomGrammarBNFFiles() {
      return this.entries.getCustomGrammarBNFFiles();
    }
    function getCustomGrammarVocabularyFiles() {
      return this.entries.getCustomGrammarVocabularyFiles();
    }
    var entriesMixins = {
      forEachFile,
      findFile,
      getBNF,
      getFiles,
      getTermBNF,
      getVersion,
      getFilePaths,
      getVocabulary,
      getRepository,
      getReadmeFile,
      getStatementBNF,
      getDependencies,
      getTypeVocabulary,
      getSymbolVocabulary,
      getMetaJSONFile,
      getFurtleFiles,
      getNominalFiles,
      getDirectoryPaths,
      getDependencyNames,
      getCustomGrammarBNFFiles,
      getCustomGrammarVocabularyFiles
    };
    var _default = entriesMixins;
  });

  // node_modules/occam-model/lib/project.js
  var require_project = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _entries1 = /* @__PURE__ */ _interop_require_default(require_entries13());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Project = class {
      constructor(name, entries) {
        this.name = name;
        this.entries = entries;
      }
      getName() {
        return this.name;
      }
      getEntries() {
        return this.entries;
      }
      toJSON() {
        const entriesJSON = this.entries.toJSON(), name = this.name, entries = entriesJSON, json = {
          name,
          entries
        };
        return json;
      }
      static fromJSON(json) {
        let {entries} = json;
        const {name} = json, entriesJSON = entries;
        json = entriesJSON;
        entries = _entries.default.fromJSON(json);
        const project = new Project(name, entries);
        return project;
      }
      static fromName(name) {
        const entries = _entries.default.fromNothing(), project = new Project(name, entries);
        return project;
      }
      static fromNameAndEntries(name, entries) {
        const project = new Project(name, entries);
        return project;
      }
    };
    Object.assign(Project.prototype, _entries1.default);
    var _default = Project;
  });

  // node_modules/occam-model/lib/release.js
  var require_release2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _entries1 = /* @__PURE__ */ _interop_require_default(require_entries13());
    var _constants = require_constants12();
    var _metaJSON = require_metaJSON();
    var _filePath = require_filePath();
    var _files = require_files2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Release = class {
      constructor(name, entries) {
        this.name = name;
        this.entries = entries;
      }
      getName() {
        return this.name;
      }
      getEntries() {
        return this.entries;
      }
      updateVersion(version) {
        let repository = this.getRepository(), dependencies = this.getDependencies();
        const versionString = version.toString(), repositoryJSON = repository, dependenciesJSON = dependencies.toJSON();
        version = versionString;
        repository = repositoryJSON;
        dependencies = dependenciesJSON;
        const metaJSONFile = this.getMetaJSONFile(), json = {
          version,
          repository,
          dependencies
        }, jsonString = JSON.stringify(json, null, _constants.DOUBLE_SPACE), file = metaJSONFile, content = jsonString;
        file.setContent(content);
      }
      toJSON() {
        const entriesJSON = this.entries.toJSON(), name = this.name, entries = entriesJSON, json = {
          name,
          entries
        };
        return json;
      }
      static fromJSON(json) {
        let {entries} = json;
        const {name} = json, entriesJSON = entries;
        json = entriesJSON;
        entries = _entries.default.fromJSON(json);
        const release = new Release(name, entries);
        return release;
      }
      static fromProject(project) {
        let release = null, entries = project.getEntries();
        const entriesReleasable = areEntriesReleasable(entries);
        if (entriesReleasable) {
          const name = project.getName(), releasedEntries = releaseEntriesFromEntries(entries);
          entries = releasedEntries;
          release = new Release(name, entries);
        }
        return release;
      }
      static fromNameAndEntries(name, entries) {
        let release = null;
        const entriesReleasable = areEntriesReleasable(entries);
        if (entriesReleasable) {
          release = new Release(name, entries);
        }
        return release;
      }
    };
    Object.assign(Release.prototype, _entries1.default);
    var _default = Release;
    function releaseEntriesFromEntries(entries) {
      const releasedEntries = _entries.default.fromNothing(), files = entries.getFiles();
      files.forEachFile((file) => {
        const filePath = file.getPath(), filePathReleaseFilePath = (0, _filePath.isFilePathReleaseFilePath)(filePath);
        if (filePathReleaseFilePath) {
          const path = filePath, content = file.getContent(), released = true;
          file = _file.default.fromPathContentAndReleased(path, content, released);
          releasedEntries.addFile(file);
        }
      });
      return releasedEntries;
    }
    function areEntriesReleasable(entries) {
      let entriesReleasable = false;
      const files = entries.getFiles(), readmeFile = (0, _files.readmeFileFromFiles)(files), metaJSONFile = (0, _files.metaJSONFileFromFiles)(files);
      if (readmeFile !== null && metaJSONFile !== null) {
        const metaJSONFileValid = (0, _metaJSON.isMetaJSONFileValid)(metaJSONFile);
        if (metaJSONFileValid) {
          entriesReleasable = true;
        }
      }
      return entriesReleasable;
    }
  });

  // node_modules/occam-model/lib/projects.js
  var require_projects = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Projects;
      }
    });
    var _necessary = require_browser();
    var _project = /* @__PURE__ */ _interop_require_default(require_project());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Projects = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        return this.array.length;
      }
      addProject(project) {
        this.array.push(project);
      }
      mapProject(callback) {
        return this.array.map(callback);
      }
      reduceProject(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachProject(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachProject(callback, done) {
        forEach(this.array, callback, done);
      }
      toJSON() {
        const json = this.array.map((project) => {
          const projectJSON = project.toJSON();
          return projectJSON;
        });
        return json;
      }
      static fromJSON(json) {
        const array = json.map((json2) => {
          const project = _project.default.fromJSON(json2);
          return project;
        }), projects = new Projects(array);
        return projects;
      }
      static fromNothing() {
        const array = [], projects = new Projects(array);
        return projects;
      }
    };
  });

  // node_modules/occam-model/lib/releases.js
  var require_releases = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Releases;
      }
    });
    var _necessary = require_browser();
    var _release = /* @__PURE__ */ _interop_require_default(require_release2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Releases = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        return this.array.length;
      }
      addRelease(release) {
        this.array.push(release);
      }
      mapRelease(callback) {
        return this.array.map(callback);
      }
      reduceRelease(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachRelease(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachRelease(callback, done) {
        forEach(this.array, callback, done);
      }
      toJSON() {
        const json = this.array.map((release) => {
          const releaseJSON = release.toJSON();
          return releaseJSON;
        });
        return json;
      }
      static fromJSON(json) {
        const array = json.map((json2) => {
          const release = _release.default.fromJSON(json2);
          return release;
        }), releases = new Releases(array);
        return releases;
      }
      static fromNothing() {
        const array = [], releases = new Releases(array);
        return releases;
      }
    };
  });

  // node_modules/occam-model/lib/index.js
  var require_lib13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Dependencies() {
        return _dependencies.default;
      },
      get Dependency() {
        return _dependency.default;
      },
      get Directory() {
        return _directory.default;
      },
      get Entries() {
        return _entries.default;
      },
      get File() {
        return _file.default;
      },
      get Files() {
        return _files.default;
      },
      get Project() {
        return _project.default;
      },
      get Projects() {
        return _projects.default;
      },
      get Release() {
        return _release.default;
      },
      get Releases() {
        return _releases.default;
      },
      get ShortenedVersion() {
        return _shortenedVersion.default;
      },
      get Version() {
        return _version.default;
      },
      get contentUtilities() {
        return _content.default;
      },
      get fileNames() {
        return _fileNames.default;
      },
      get filePathUtilities() {
        return _filePath.default;
      },
      get metaJSONUtilities() {
        return _metaJSON.default;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _files = /* @__PURE__ */ _interop_require_default(require_files());
    var _version = /* @__PURE__ */ _interop_require_default(require_version3());
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _project = /* @__PURE__ */ _interop_require_default(require_project());
    var _release = /* @__PURE__ */ _interop_require_default(require_release2());
    var _projects = /* @__PURE__ */ _interop_require_default(require_projects());
    var _releases = /* @__PURE__ */ _interop_require_default(require_releases());
    var _directory = /* @__PURE__ */ _interop_require_default(require_directory());
    var _fileNames = /* @__PURE__ */ _interop_require_default(require_fileNames());
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _dependencies = /* @__PURE__ */ _interop_require_default(require_dependencies());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    var _content = /* @__PURE__ */ _interop_require_default(require_content3());
    var _filePath = /* @__PURE__ */ _interop_require_default(require_filePath());
    var _metaJSON = /* @__PURE__ */ _interop_require_default(require_metaJSON());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/utilities/releaseContext.js
  var require_releaseContext = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get releaseContextFromJSON() {
        return releaseContextFromJSON;
      },
      get releaseContextFromProject() {
        return releaseContextFromProject;
      },
      get releaseContextFromRelease() {
        return releaseContextFromRelease;
      }
    });
    var _occammodel = require_lib13();
    var _release = /* @__PURE__ */ _interop_require_default(require_release());
    var _customGrammar = require_customGrammar3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {isMetaJSONFileValid} = _occammodel.metaJSONUtilities;
    function releaseContextFromJSON(json, context2) {
      const {log, callback} = context2, {name} = json;
      let {entries} = json;
      ({context: context2} = json);
      json = entries;
      entries = _occammodel.Entries.fromJSON(json);
      const contextJSON = context2;
      json = contextJSON;
      const customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries), releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
      return releaseContext;
    }
    function releaseContextFromProject(project, context2) {
      let releaseContext = null;
      if (project !== null) {
        const metaJSONFile = project.getMetaJSONFile();
        if (metaJSONFile !== null) {
          const metaJSONFileValid = isMetaJSONFileValid(metaJSONFile);
          if (metaJSONFileValid) {
            const {log, callback} = context2, name = project.getName(), json = null, entries = project.getEntries(), customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries);
            releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
          }
        }
      }
      return releaseContext;
    }
    function releaseContextFromRelease(release, context2) {
      let releaseContext = null;
      if (release !== null) {
        const {log, callback} = context2, name = release.getName(), json = null, entries = release.getEntries(), customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries);
        releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
      }
      return releaseContext;
    }
    var _default = {
      releaseContextFromJSON,
      releaseContextFromProject,
      releaseContextFromRelease
    };
  });

  // node_modules/occam-languages/lib/index.js
  var require_lib14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AsyncPass() {
        return _async.default;
      },
      get Context() {
        return _context.default;
      },
      get Element() {
        return _element.default;
      },
      get EquivalencePass() {
        return _equivalence.default;
      },
      get FileContext() {
        return _file.default;
      },
      get ForwardPass() {
        return _forward.default;
      },
      get Log() {
        return _log.default;
      },
      get NonTerminalNode() {
        return _nonTerminalNode.default;
      },
      get ReleaseContext() {
        return _release.default;
      },
      get SimplePass() {
        return _simple.default;
      },
      get ZipPass() {
        return _zip.default;
      },
      get asynchronousUtilities() {
        return _asynchronous.default;
      },
      get fileContextUtilities() {
        return _fileContext.default;
      },
      get nodeUtilities() {
        return _node.default;
      },
      get queryUtilities() {
        return _query.default;
      },
      get releaseContextUtilities() {
        return _releaseContext.default;
      },
      get verificationUtilities() {
        return _verification.default;
      }
    });
    var _log = /* @__PURE__ */ _interop_require_default(require_log());
    var _element = /* @__PURE__ */ _interop_require_default(require_element4());
    var _context = /* @__PURE__ */ _interop_require_default(require_context());
    var _file = /* @__PURE__ */ _interop_require_default(require_file());
    var _release = /* @__PURE__ */ _interop_require_default(require_release());
    var _nonTerminalNode = /* @__PURE__ */ _interop_require_default(require_nonTerminalNode2());
    var _zip = /* @__PURE__ */ _interop_require_default(require_zip());
    var _async = /* @__PURE__ */ _interop_require_default(require_async2());
    var _simple = /* @__PURE__ */ _interop_require_default(require_simple());
    var _forward = /* @__PURE__ */ _interop_require_default(require_forward());
    var _equivalence = /* @__PURE__ */ _interop_require_default(require_equivalence());
    var _node = /* @__PURE__ */ _interop_require_default(require_node4());
    var _query = /* @__PURE__ */ _interop_require_default(require_query4());
    var _fileContext = /* @__PURE__ */ _interop_require_default(require_fileContext());
    var _verification = /* @__PURE__ */ _interop_require_default(require_verification());
    var _asynchronous = /* @__PURE__ */ _interop_require_default(require_asynchronous2());
    var _releaseContext = /* @__PURE__ */ _interop_require_default(require_releaseContext());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/elements.js
  var require_elements2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get define() {
        return define;
      }
    });
    var elements = {};
    function define(Element) {
      const {name} = Element;
      elements[name] = Element;
      return Element;
    }
    var _default = elements;
  });

  // lib/element/step.js
  var require_step = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, arrayAssignment, objectAssigment, variablessAssignment) {
        super(context2, string, node);
        this.arrayAssignment = arrayAssignment;
        this.objectAssigment = objectAssigment;
        this.variablessAssignment = variablessAssignment;
      }
      getArrayAssignment() {
        return this.arrayAssignment;
      }
      getObjectAssigment() {
        return this.objectAssigment;
      }
      getVariablessAssignment() {
        return this.variablessAssignment;
      }
      async evaluate(context2) {
        if (false) {
        } else if (this.arrayAssignment !== null) {
          this.arrayAssignment.evaluate(context2);
        } else if (this.objectAssigment !== null) {
          this.objectAssigment.evaluate(context2);
        } else if (this.variablessAssignment !== null) {
          await this.variablessAssignment.evaluate(context2);
        }
      }
    }, __publicField(_a, "name", "Step"), _a));
  });

  // lib/exception.js
  var require_exception = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Exception;
      }
    });
    var Exception = class {
      constructor(message) {
        this.message = message;
      }
      getMessage() {
        return this.message;
      }
      static fromMessage(message) {
        const exception = new Exception(message);
        return exception;
      }
    };
  });

  // lib/types.js
  var require_types3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN_TYPE() {
        return BOOLEAN_TYPE;
      },
      get NODES_TYPE() {
        return NODES_TYPE;
      },
      get NODE_TYPE() {
        return NODE_TYPE;
      },
      get NUMBER_TYPE() {
        return NUMBER_TYPE;
      },
      get STRING_TYPE() {
        return STRING_TYPE;
      }
    });
    var NODE_TYPE = "Node";
    var NODES_TYPE = "Nodes";
    var STRING_TYPE = "String";
    var NUMBER_TYPE = "Number";
    var BOOLEAN_TYPE = "Boolean";
  });

  // lib/nullNode.js
  var require_nullNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var NullNode = class {
      static fromNothing() {
        const nullNode2 = new NullNode();
        return nullNode2;
      }
    };
    var nullNode = NullNode.fromNothing();
    var _default = nullNode;
  });

  // lib/constants.js
  var require_constants13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CONJUNCTION_OPERATOR() {
        return CONJUNCTION_OPERATOR;
      },
      get DISJUNCTION_OPERATOR() {
        return DISJUNCTION_OPERATOR;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get FALSE() {
        return FALSE;
      },
      get NOT_EQUAL_TO() {
        return NOT_EQUAL_TO;
      },
      get NULL() {
        return NULL;
      },
      get TRUE() {
        return TRUE;
      }
    });
    var NULL = "null";
    var TRUE = "true";
    var FALSE = "false";
    var EMPTY_STRING = "";
    var NOT_EQUAL_TO = "!=";
    var CONJUNCTION_OPERATOR = "&&";
    var DISJUNCTION_OPERATOR = "||";
  });

  // lib/utilities/stringLiteral.js
  var require_stringLiteral6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get stringFromStringLiteral() {
        return stringFromStringLiteral;
      },
      get stringLiteralFromString() {
        return stringLiteralFromString;
      }
    });
    var _constants = require_constants13();
    function stringFromStringLiteral(stringLiteral) {
      const string = stringLiteral.replace(/(^"|"$)/g, _constants.EMPTY_STRING);
      return string;
    }
    function stringLiteralFromString(string) {
      const stringLiteral = `"${string}"`;
      return stringLiteral;
    }
  });

  // lib/utilities/string.js
  var require_string5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get anonymousProcedureStringFromTypeParametersAndReturnBlock() {
        return anonymousProcedureStringFromTypeParametersAndReturnBlock;
      },
      get everyStringFromVariableAndAnonymousProcedure() {
        return everyStringFromVariableAndAnonymousProcedure;
      },
      get expressionStringFromProperties() {
        return expressionStringFromProperties;
      },
      get nodePropertiesStringFromNodePropertiesArray() {
        return nodePropertiesStringFromNodePropertiesArray;
      },
      get nodePropertyStringFromNameAndType() {
        return nodePropertyStringFromNameAndType;
      },
      get primtiveStringFromBoolean() {
        return primtiveStringFromBoolean;
      },
      get primtiveStringFromNode() {
        return primtiveStringFromNode;
      },
      get primtiveStringFromNodes() {
        return primtiveStringFromNodes;
      },
      get primtiveStringFromStringLiteral() {
        return primtiveStringFromStringLiteral;
      },
      get procedureDeclarationStringFromProcedure() {
        return procedureDeclarationStringFromProcedure;
      },
      get procedureStringFromTypeLabelParametersAndReturnBlock() {
        return procedureStringFromTypeLabelParametersAndReturnBlock;
      },
      get reduceStringFromVariableInitialExpressionAndAnonymousProcedure() {
        return reduceStringFromVariableInitialExpressionAndAnonymousProcedure;
      },
      get returnBlockStringFromReturnStatementNode() {
        return returnBlockStringFromReturnStatementNode;
      },
      get someStringFromVariableAndAnonymousProcedure() {
        return someStringFromVariableAndAnonymousProcedure;
      },
      get termStringFromProperties() {
        return termStringFromProperties;
      },
      get termsStringFromTermsArray() {
        return termsStringFromTermsArray;
      },
      get ternaryStringFromTerm() {
        return ternaryStringFromTerm;
      },
      get variableAssignmentStringFromTypeAndVariable() {
        return variableAssignmentStringFromTypeAndVariable;
      },
      get variableAssignmentStringFromTypeAndVariableAssignmentsArray() {
        return variableAssignmentStringFromTypeAndVariableAssignmentsArray;
      },
      get variableAssignmentStringFromVariableAssignment() {
        return variableAssignmentStringFromVariableAssignment;
      },
      get variableStringFromName() {
        return variableStringFromName;
      }
    });
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _constants = require_constants13();
    var _stringLiteral = require_stringLiteral6();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ternaryStringFromTerm(term) {
      const termString = term.getString(), ternaryString = `if (${termString}) { ... } else { ... }`;
      return ternaryString;
    }
    function variableStringFromName(name) {
      const variableString = name;
      return variableString;
    }
    function primtiveStringFromNode(node, context2) {
      const primtiveString = node === _nullNode.default ? _constants.NULL : context2.nodeAsString(node);
      return primtiveString;
    }
    function primtiveStringFromNodes(nodes, context2) {
      const string = context2.nodesAsString(nodes), primtiveString = string;
      return primtiveString;
    }
    function termStringFromProperties(properties) {
      let termString;
      properties.forEach((property) => {
        if (property !== null) {
          const propertyString = property.getString();
          termString = propertyString;
        }
      });
      return termString;
    }
    function primtiveStringFromBoolean(boolean) {
      const expresssionString = `${boolean}`;
      return expresssionString;
    }
    function termsStringFromTermsArray(termsArray) {
      const termsString = termsArray.reduce((termsString2, term) => {
        const termString = term.getString();
        termsString2 = termsString2 === null ? termString : `${termsString2}, ${termString}`;
        return termsString2;
      }, null);
      return termsString;
    }
    function expressionStringFromProperties(properties) {
      let expressionString;
      properties.forEach((property) => {
        if (property !== null) {
          const propertyString = property.getString();
          expressionString = propertyString;
        }
      });
      return expressionString;
    }
    function primtiveStringFromStringLiteral(stringLiteral) {
      const string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral), primtiveString = string;
      return primtiveString;
    }
    function nodePropertyStringFromNameAndType(name, type) {
      const typeString = type, nameString = name, nodePropertyString = `${typeString} ${nameString}`;
      return nodePropertyString;
    }
    function procedureDeclarationStringFromProcedure(procedure) {
      const type = procedure.getType(), label = procedure.getLabel(), parameters = procedure.getParameters(), returnStatement = procedure.getReturnStatement(), labelString = label.getString(), parametersString = parameters.getString(), returnStatementString = returnStatement.getString(), procedureDelcarationString = `${type} ${labelString}(${parametersString}) { ... ${returnStatementString} }`;
      return procedureDelcarationString;
    }
    function returnBlockStringFromReturnStatementNode(returnStatement) {
      const returnStatementString = returnStatement.getString(), returnBlockString = `{ ... ${returnStatementString} }`;
      return returnBlockString;
    }
    function nodePropertiesStringFromNodePropertiesArray(nodePropertiesArray) {
      const nodePropertiesString = nodePropertiesArray.reduce((nodePropertiesString2, nodeProperty) => {
        const nodePropertyString = nodeProperty.getString();
        nodePropertiesString2 = nodePropertiesString2 === null ? nodePropertyString : `${nodePropertiesString2}, ${nodePropertyString}`;
        return nodePropertiesString2;
      }, null);
      return nodePropertiesString;
    }
    function variableAssignmentStringFromTypeAndVariable(type, variable) {
      const variableString = variable.getString(), variableAssignmentString = `${type} ${variableString} = ... ;`;
      return variableAssignmentString;
    }
    function someStringFromVariableAndAnonymousProcedure(variable, anonymousProcedure) {
      const variableString = variable.getString(), anonymousProcedureString = anonymousProcedure.getString(), someString = `Some(${variableString}, ${anonymousProcedureString}) `;
      return someString;
    }
    function everyStringFromVariableAndAnonymousProcedure(variable, anonymousProcedure) {
      const variableString = variable.getString(), anonymousProcedureString = anonymousProcedure.getString(), everyString = `Every(${variableString}, ${anonymousProcedureString}) `;
      return everyString;
    }
    function variableAssignmentStringFromVariableAssignment(variableAssignment) {
      const variable = variableAssignment.getVariable(), variableString = variable.getString(), variableAssignmentString = `${variableString} = ...`;
      return variableAssignmentString;
    }
    function procedureStringFromTypeLabelParametersAndReturnBlock(type, label, parameters, returnBlock) {
      const typeString = type, labelString = label.getString(), parametersString = parameters.getString(), returnBlockString = returnBlock.getString(), procedureString = `${typeString} ${labelString}(${parametersString}) ${returnBlockString}`;
      return procedureString;
    }
    function anonymousProcedureStringFromTypeParametersAndReturnBlock(type, parameters, returnBlock) {
      const typeString = type, parametersString = parameters.getString(), returnBlockString = returnBlock.getString(), anonymousProcedureString = `${typeString} (${parametersString}) ${returnBlockString}`;
      return anonymousProcedureString;
    }
    function variableAssignmentStringFromTypeAndVariableAssignmentsArray(type, variableAssignmentsArray) {
      let variableAssignmentsString = variableAssignmentsArray.reduce((variableAssignmentsString2, variableAssignment) => {
        const variableAssignmentString = variableAssignmentStringFromVariableAssignment(variableAssignment);
        variableAssignmentsString2 = variableAssignmentsString2 === null ? variableAssignmentString : `${variableAssignmentsString2}, ${variableAssignmentString}`;
        return variableAssignmentsString2;
      }, null);
      variableAssignmentsString = `${type} ${variableAssignmentsString} ;`;
      return variableAssignmentsString;
    }
    function reduceStringFromVariableInitialExpressionAndAnonymousProcedure(variable, initialExpression, anonymousProcedure) {
      const variableString = variable.getString(), initialExpressionString = initialExpression.getString(), anonymousProcedureString = anonymousProcedure.getString(), reduceString = `Reduce(${variableString}, ${anonymousProcedureString}, ${initialExpressionString})`;
      return reduceString;
    }
  });

  // lib/utilities/primitive.js
  var require_primitive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get primitiveFromBoolean() {
        return primitiveFromBoolean;
      },
      get primitiveFromNode() {
        return primitiveFromNode;
      },
      get primitiveFromNodes() {
        return primitiveFromNodes;
      },
      get primitiveFromStringLiteral() {
        return primitiveFromStringLiteral;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _types = require_types3();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function primitiveFromNode(node, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromNode)(node, context2), string = primitiveString, type = _types.NODE_TYPE, value = node;
      node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromNodes(nodes, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromNodes)(nodes, context2), string = primitiveString, type = _types.NODES_TYPE, value = nodes, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromBoolean(boolean, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromBoolean)(boolean), string = primitiveString, type = _types.BOOLEAN_TYPE, value = boolean, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromStringLiteral(stringLiteral, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromStringLiteral)(stringLiteral), string = primitiveString, type = _types.STRING_TYPE, value = stringLiteral, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    var _default = {
      primitiveFromNode,
      primitiveFromNodes,
      primitiveFromBoolean,
      primitiveFromStringLiteral
    };
  });

  // lib/utilities/term.js
  var require_term = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get termFromBoolean() {
        return termFromBoolean;
      },
      get termFromNode() {
        return termFromNode;
      },
      get termFromNodes() {
        return termFromNodes;
      },
      get termFromPrimitive() {
        return termFromPrimitive;
      },
      get termFromStringLiteral() {
        return termFromStringLiteral;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _primitive = require_primitive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function termFromNode(node, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromNode)(node, context2), string = primitive.getString();
      node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromNodes(nodes, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromNodes)(nodes, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromBoolean(boolean, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromBoolean)(boolean, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromStringLiteral(stringLiteral, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromStringLiteral)(stringLiteral, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromPrimitive(primitive) {
      const {Term} = _elements.default, context2 = null, string = primitive.getString(), node = null, variable = null, term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    var _default = {
      termFromNode,
      termFromNodes,
      termFromBoolean,
      termFromStringLiteral,
      termFromPrimitive
    };
  });

  // lib/element/some.js
  var require_some = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncSome} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, anonymousProcedure) {
        super(context2, string, node);
        this.variable = variable;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const someString = this.getString();
        context2.trace(`Evaluating the '${someString}' some...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), nodes = primitiveValue, boolean = await asyncSome(nodes, async (node) => {
          let term2;
          term2 = (0, _term.termFromNode)(node, context2);
          const {Terms} = _elements.default, terms = Terms.fromTerm(term2, context2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          const termType2 = term2.getType();
          if (termType2 !== _types.BOOLEAN_TYPE) {
            const termString2 = term2.getString(), message = `The '${termString2}' term's type is '${termType2}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
            throw exception;
          }
          const primitiveValue2 = term2.getPrimitiveValue(), boolean2 = primitiveValue2;
          return boolean2;
        });
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.trace(`...evaluated the '${someString}' some as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Some"), _a));
  });

  // lib/element/term.js
  var require_term2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _types = require_types3();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm) {
        super(context2, string, node);
        this.variable = variable;
        this.primitive = primitive;
        this.negatedTerm = negatedTerm;
        this.logicalTerm = logicalTerm;
        this.bracketedTerm = bracketedTerm;
        this.comparisonTerm = comparisonTerm;
      }
      getVariable() {
        return this.variable;
      }
      getPrimitive() {
        return this.primitive;
      }
      getNegatedTerm() {
        return this.negatedTerm;
      }
      getLogicalTerm() {
        return this.logicalTerm;
      }
      getBreedingTerm() {
        return this.bracketedTerm;
      }
      getComparisonTerm() {
        return this.comparisonTerm;
      }
      getPrimitiveValue() {
        const primitiveValue = this.primitive.getValue();
        return primitiveValue;
      }
      getType() {
        let type;
        if (false) {
        } else if (this.variable !== null) {
          type = this.variable.getType();
        } else if (this.primitive !== null) {
          type = this.primitive.getType();
        } else if (this.negatedTerm !== null) {
          type = this.negatedTerm.getType();
        } else if (this.logicalTerm !== null) {
          type = this.logicalTerm.getType();
        } else if (this.bracketedTerm !== null) {
          type = this.bracketedTerm.getType();
        } else if (this.comparisonTerm !== null) {
          type = this.comparisonTerm.getType();
        }
        return type;
      }
      isBoolean() {
        const type = this.getType(), boolean = type === _types.BOOLEAN_TYPE;
        return boolean;
      }
      evaluate(context2) {
        let term;
        if (false) {
        } else if (this.variable !== null) {
          term = this.variable.evaluate(context2);
        } else if (this.primitive !== null) {
          term = this.primitive.evaluate(context2);
        } else if (this.negatedTerm !== null) {
          term = this.negatedTerm.evaluate(context2);
        } else if (this.logicalTerm !== null) {
          term = this.logicalTerm.evaluate(context2);
        } else if (this.bracketedTerm !== null) {
          term = this.bracketedTerm.evaluate(context2);
        } else if (this.comparisonTerm !== null) {
          term = this.comparisonTerm.evaluate(context2);
        }
        return term;
      }
      isEqualTo(term) {
        let equalTo = false;
        if (false) {
        } else if (this.variable !== null) {
          const variable = term.getVariable();
          if (variable !== null) {
            equalTo = this.variable.isEqualTo(variable);
          }
        } else if (this.primitive !== null) {
          const primitive = term.getPrimitive();
          if (primitive !== null) {
            equalTo = this.primitive.isEqualTo(primitive);
          }
        }
        return equalTo;
      }
      static fromPrimitive(primitive, context2) {
        const primitiveString = primitive.getString(), string = primitiveString, node = null, variable = null, negatedTerm = null, logicalTerm = null, bracketedTerm = null, comparisonTerm = null;
        context2 = null;
        const term = new _a(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm);
        return term;
      }
    }, __publicField(_a, "name", "Term"), _a));
  });

  // lib/element/terms.js
  var require_terms = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _string = require_string5();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getTerm(index) {
        const term = this.array[index] || null;
        return term;
      }
      addTerm(term) {
        this.array.push(term);
      }
      mapTerm(callback) {
        return this.array.map(callback);
      }
      forEachTerm(callback) {
        this.array.forEach(callback);
      }
      evaluate(context2) {
        const termsArray = this.mapTerm((term) => {
          term = term.evaluate(context2);
          return term;
        }), termsString = (0, _string.termsStringFromTermsArray)(termsArray, context2), string = termsString, array = termsArray, node = null;
        context2 = null;
        const terms = new _a(context2, string, node, array);
        return terms;
      }
      static fromTerm(term, context2) {
        const termsArray = [
          term
        ], termsString = (0, _string.termsStringFromTermsArray)(termsArray, context2), string = termsString, array = termsArray, node = null;
        context2 = null;
        const terms = new _a(context2, string, node, array);
        return terms;
      }
    }, __publicField(_a, "name", "Terms"), _a));
  });

  // lib/element/label.js
  var require_label = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, name) {
        super(context2, string, node);
        this.name = name;
      }
      getName() {
        return this.name;
      }
      compareProcedureName(procedureName) {
        const procedureNameCompares = this.name === procedureName;
        return procedureNameCompares;
      }
    }, __publicField(_a, "name", "Label"), _a));
  });

  // lib/element/error.js
  var require_error4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(conterxt, string, node) {
        super(context, string, node);
      }
      verify(context1) {
        const verifies = false, errorString = this.getString();
        context1.warning(`The '${errorString}' error cannot be verified.`);
        return verifies;
      }
    }, __publicField(_a, "name", "Error"), _a));
  });

  // lib/element/every.js
  var require_every = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncEvery} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, anonymousProcedure) {
        super(context2, string, node);
        this.string = string;
        this.variable = variable;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const everyString = this.getString();
        context2.trace(`Evaluating the '${everyString}' every...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = term.getNodes(), boolean = await asyncEvery(nodes, async (node) => {
          let term2;
          const {Terms} = _elements.default;
          term2 = (0, _term.termFromNode)(node, context2);
          const terms = Terms.fromTerm(term2, context2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          const termType2 = term2.getType();
          if (termType2 !== _types.BOOLEAN_TYPE) {
            const termString2 = term2.getString(), message = `The '${termString2}' term's type is '${termType2}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
            throw exception;
          }
          const boolean2 = term2.getBoolean();
          return boolean2;
        });
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.trace(`...evaluated the '${everyString}' every as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Every"), _a));
  });

  // lib/element/reduce.js
  var require_reduce = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncReduce} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, initialExpression, anonymousProcedure) {
        super(context2, string, node);
        this.variable = variable;
        this.initialExpression = initialExpression;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getInitialExpression() {
        return this.initialExpression;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const reduceString = this.getString();
        context2.trace(`Evaluating the '${reduceString}' reduce...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = term.getNodes(), initialExpression = await this.initialExpression.evaluate(context2);
        term = await asyncReduce(nodes, async (currentExpression, node) => {
          let term2;
          const {Terms} = _elements.default;
          term2 = currentTerm;
          const terms = Terms.fromTerm(term2, context2);
          term2 = (0, _term.termFromNode)(node, context2);
          terms.addTerm(term2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          return term2;
        }, initialExpression);
        const termString = term.getString();
        context2.trace(`...evaluated the '${reduceString}' reduce as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Reduce"), _a));
  });

  // lib/element/ternary.js
  var require_ternary = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term, ifExpression, elseExpression) {
        super(context2, string, node);
        this.term = term;
        this.ifExpression = ifExpression;
        this.elseExpression = elseExpression;
      }
      getTerm() {
        return this.term;
      }
      getIfBlock() {
        return this.ifExpression;
      }
      getElseBlock() {
        return this.elseExpression;
      }
      async evaluate(context2) {
        let term;
        const ternaryString = this.getString();
        context2.trace(`Evaluating the '${ternaryString}' ternary...`);
        term = this.term.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.BOOLEAN_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's type is '${termType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), boolean = primitiveValue;
        term = boolean ? await this.ifExpression.evaluate(context2) : await this.elseExpression.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${ternaryString}' ternary as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Ternary"), _a));
  });

  // lib/element/variable.js
  var require_variable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name, term) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
        this.term = term;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      getTerm() {
        return this.term;
      }
      compareVariableName(variableName) {
        const comparesToVariableName = this.name === variableName;
        return comparesToVariableName;
      }
      evaluate(context2) {
        const variableString = this.getString();
        context2.trace(`Evaluating the '${variableString}' variable...`);
        const nested = true, variableName = this.name, variablePresent = context2.isVariablePresentByVariableName(variableName, nested);
        if (!variablePresent) {
          const message = `The '${variableString}' variable is not present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const variable = context2.findVariableByVariableName(variableName), term = variable.getTerm(), termString = term.getString();
        context2.debug(`...evaluated the '${variableString}' variable as the '${termString}' term.`);
        return term;
      }
      assign(term, context2) {
        const nested = false, termString = term.getString(), variableName = this.name, variableString = this.getString(), variablePresent = context2.isVariablePresentByVariableName(variableName, nested);
        context2.trace(`Assigning the '${termString}' term to the '${variableString}' variable...`);
        if (variablePresent) {
          const message = `The '${variableString}' variable is already present.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const termType = term.getType(), variableType = this.type;
        if (termType !== variableType) {
          const message = `The '${variableString} variable's '${variableType}' type does not compare to the term's '${termType}' type.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.term = term;
        const variable = this;
        context2.addVariable(variable);
        context2.debug(`...assigned the '${termString}' term to the '${variableString}' variable.`);
      }
      static fromParameter(parameter, context2) {
        const type = parameter.getType(), name = parameter.getName(), term = null, variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
      static fromNamedParameter(namedParameter, context2) {
        const aliasedName = namedParameter.getAliasedName(), type = namedParameter.getType(), name = aliasedName, term = null, variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
      static fromTermAndParameter(term, parameter, context2) {
        const type = parameter.getType(), name = parameter.getName(), variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
    }, __publicField(_a, "name", "Variable"), _a));
  });

  // lib/element/primitive.js
  var require_primitive2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {match} = _necessary.arrayUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, value) {
        super(context2, string, node);
        this.type = type;
        this.value = value;
      }
      getType() {
        return this.type;
      }
      getValue() {
        return this.value;
      }
      evaluate(context2) {
        const {Term} = _elements.default, primitive = this, term = Term.fromPrimitive(primitive, context2);
        return term;
      }
      isEqualTo(primitive) {
        let equalTo = false;
        const type = primitive.getType();
        if (this.type === type) {
          const value = primitive.getValue();
          switch (type) {
            case _types.NODE_TYPE: {
              const nodeA = this.value, nodeB = value, nodeMatches = matchNode(nodeA, nodeB);
              if (nodeMatches) {
                equalTo = true;
              }
              break;
            }
            case _types.NODES_TYPE: {
              const nodesA = this.value, nodesB = value, nodesMatch = matchNodes(nodesA, nodesB);
              if (nodesMatch) {
                equalTo = true;
              }
              break;
            }
            case _types.STRING_TYPE: {
              const stringLiteralA = this.value, stringLiteralB = value;
              if (stringLiteralA === stringLiteralB) {
                equalTo = true;
              }
              break;
            }
            case _types.NUMBER_TYPE: {
              const numberA = this.value, numberB = value;
              if (numberA === numberB) {
                equalTo = true;
              }
              break;
            }
            case _types.BOOLEAN_TYPE: {
              const booleanA = this.value, booleanB = value;
              if (booleanA === booleanB) {
                equalTo = true;
              }
              break;
            }
          }
        }
        return equalTo;
      }
    }, __publicField(_a, "name", "Primitive"), _a));
    function matchNode(nodeA, nodeB) {
      let nodeMatches;
      if (nodeA === _nullNode.default || nodeB === _nullNode.default) {
        nodeMatches = nodeA === nodeB;
      } else if (nodeA === _nullNode.default) {
        nodeMatches = false;
      } else if (nodeB === _nullNode.default) {
        nodeMatches = false;
      } else {
        const nodeAMatchesNodeB = nodeA.match(nodeB);
        nodeMatches = nodeAMatchesNodeB;
      }
      return nodeMatches;
    }
    function matchNodes(nodesA, nodesB) {
      const nodesMatch = match(nodesA, nodesB, (nodeA, nodeB) => {
        const nodeMatches = matchNode(nodeA, nodeB);
        if (nodeMatches) {
          return true;
        }
      });
      return nodesMatch;
    }
  });

  // lib/element/reference.js
  var require_reference2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, name) {
        super(context2, string, node);
        this.name = name;
      }
      getName() {
        return this.name;
      }
      getProcedureName() {
        const procedureName = this.name;
        return procedureName;
      }
    }, __publicField(_a, "name", "Reference"), _a));
  });

  // lib/element/procedure.js
  var require_procedure = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get variablesFromTermsAndParameters() {
        return variablesFromTermsAndParameters;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, label, parameters, returnBlock) {
        super(context2, string, node);
        this.type = type;
        this.label = label;
        this.parameters = parameters;
        this.returnBlock = returnBlock;
      }
      getType() {
        return this.type;
      }
      getLabel() {
        return this.label;
      }
      getParameters() {
        return this.parameters;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      isBoolean() {
        const typeBooleanType = this.type === _types.BOOLEAN_TYPE, boolean = typeBooleanType;
        return boolean;
      }
      getName() {
        return this.label.getName();
      }
      getReturnStatement() {
        return this.returnBlock.getReturnStatement();
      }
      compareProcedureName(procedureName) {
        return this.label.compareProcedureName(procedureName);
      }
      async call(terms, context2) {
        await this.break(context2);
        const procedureString = this.getString();
        context2.trace(`Calling the '${procedureString}' procedure...`);
        this.parameters.compareTerms(terms, context2);
        const variables = variablesFromTermsAndParameters(terms, this.parameters, context2), term = await this.returnBlock.evaluate(variables, context2), termType = term.getType();
        if (this.type !== termType) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type is not equal to the '${procedureString}' procedure's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...called the '${procedureString}' procedure.`);
        return term;
      }
    }, __publicField(_a, "name", "Procedure"), _a));
    function variablesFromTermsAndParameters(terms, parameters, context2) {
      const variables = [];
      terms.forEachTerm((term, index) => {
        const parameter = parameters.getParameter(index);
        if (parameter !== null) {
          const {Variable} = _elements.default, variable = Variable.fromTermAndParameter(term, parameter, context2);
          variables.push(variable);
        }
      });
      return variables;
    }
  });

  // lib/element/nodeQuery.js
  var require_nodeQuery = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, query) {
        super(context2, string, node);
        this.variable = variable;
        this.query = query;
      }
      getVariable() {
        return this.variable;
      }
      getQuery() {
        return this.query;
      }
      evaluate(context2) {
        let term;
        const nodeQueryString = this.getString();
        context2.trace(`Evaluating the '${nodeQueryString}' node query...`);
        if (this.query === null) {
          const message = `Cannot evaluate the '${nodeQueryString}' node query because its expression is malformed.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let node;
        const primitiveValue = term.getPrimitiveValue();
        node = primitiveValue;
        if (node === null) {
          const termString2 = term.getString(), message = `The '${termString2}' term's node is null.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = this.query.execute(node), nodesLength = nodes.length;
        if (nodesLength !== 1) {
          const message = `The length of the returned nodes is ${nodesLength} when it should be 1.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const firstNode = first2(nodes);
        node = firstNode;
        term = (0, _term.termFromNode)(node, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${nodeQueryString}' node query as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NodeQuery"), _a));
  });

  // lib/element/parameter.js
  var require_parameter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      compareTerm(term, context2) {
        const termString = term.getString(), parameterString = this.getString();
        context2.trace(`Comparing the '${termString}' term against the '${parameterString}' parameter...`);
        const termType = term.getType();
        if (this.type !== termType) {
          const message = `The '${termString}' term's '${termType}' type is not equal to the '${parameterString}' parameter's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...comparing the '${termString}' term against the '${parameterString}' parameter.`);
      }
    }, __publicField(_a, "name", "Parameter"), _a));
  });

  // lib/element/parameters.js
  var require_parameters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getParameter(index) {
        const parameter = this.array[index] || null;
        return parameter;
      }
      forEachParameter(callback) {
        this.array.forEach(callback);
      }
      compareTerms(terms, context2) {
        const termsString = terms.getString(), parametersString = this.getString();
        context2.trace(`Comparing the '${termsString}' terms against the '${parametersString}' parameters...`);
        const termsLength = terms.getLength(), parametersLength = this.getLength();
        if (termsLength !== parametersLength) {
          const message = `The '${termsString}' expressions and '${parametersString}' parameters are not of the same length.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.forEachParameter((parameter, index) => {
          if (parameter !== null) {
            const term = terms.getTerm(index);
            parameter.compareTerm(term, context2);
          }
        });
        context2.debug(`...compared the '${termsString}' terms against the '${parametersString}' parameters.`);
      }
    }, __publicField(_a, "name", "Parameters"), _a));
  });

  // lib/element/nodesQuery.js
  var require_nodesQuery = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, query) {
        super(context2, string, node);
        this.variable = variable;
        this.query = query;
      }
      getVariable() {
        return this.variable;
      }
      getQuery() {
        return this.query;
      }
      evaluate(context2) {
        let term;
        const nodesQueryString = this.getString();
        context2.trace(`Evaluating the '${nodesQueryString}' nodes query...`);
        if (this.query === null) {
          const message = `Cannot evaluate the '${nodesQueryString}' nodes query because its expression is malformed.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let node;
        const primitiveValue = term.getPrimitiveValue();
        node = primitiveValue;
        if (node === null) {
          const termString2 = term.getString(), message = `The '${termString2}' term's node is null.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = this.query.execute(node);
        term = (0, _term.termFromNodes)(nodes, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${nodesQueryString}' nodes query as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NodesQuery"), _a));
  });

  // lib/element/expression.js
  var require_expression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term, some, every, reduce, ternary, nodeQuery, nodesQuery, returnBlock, procedureCall) {
        super(context2, string, node);
        this.term = term;
        this.some = some;
        this.every = every;
        this.reduce = reduce;
        this.ternary = ternary;
        this.nodeQuery = nodeQuery;
        this.nodesQuery = nodesQuery;
        this.returnBlock = returnBlock;
        this.procedureCall = procedureCall;
      }
      getTerm() {
        return this.term;
      }
      getSome() {
        return this.some;
      }
      getEvery() {
        return this.every;
      }
      getReduce() {
        return this.reduce;
      }
      getTernary() {
        return this.ternay;
      }
      getNodeQuery() {
        return this.nodeQuery;
      }
      getNodesQuery() {
        return this.nodesQuery;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      getProcedureCall() {
        return this.procedureCall;
      }
      getType() {
        let type;
        if (false) {
        } else if (this.term !== null) {
          type = this.term.getType();
        } else if (this.some !== null) {
          type = this.some.getType();
        } else if (this.every !== null) {
          type = this.every.getType();
        } else if (this.reduce !== null) {
          type = this.reduce.getType();
        } else if (this.ternary !== null) {
          type = this.ternary.getType();
        } else if (this.nodeQuery !== null) {
          type = this.nodeQuery.getType();
        } else if (this.nodesQuery !== null) {
          type = this.nodesQuery.getType();
        } else if (this.returnBlock !== null) {
          type = this.returnBlock.getType();
        } else if (this.procedureCall !== null) {
          type = this.procedureCall.getType();
        }
        return type;
      }
      async evaluate(context2) {
        let term;
        if (false) {
        } else if (this.term !== null) {
          term = this.term.evaluate(context2);
        } else if (this.nodeQuery !== null) {
          term = this.nodeQuery.evaluate(context2);
        } else if (this.nodesQuery !== null) {
          term = this.nodesQuery.evaluate(context2);
        } else if (this.some !== null) {
          term = await this.some.evaluate(context2);
        } else if (this.every !== null) {
          term = await this.every.evaluate(context2);
        } else if (this.reduce !== null) {
          term = await this.reduce.evaluate(context2);
        } else if (this.ternary !== null) {
          term = await this.ternary.evaluate(context2);
        } else if (this.returnBlock !== null) {
          term = await this.returnBlock.evaluate(context2);
        } else if (this.procedureCall !== null) {
          term = await this.procedureCall.evaluate(context2);
        }
        return term;
      }
    }, __publicField(_a, "name", "Expression"), _a));
  });

  // lib/context/block.js
  var require_block = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BlockContext;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {push} = _necessary.arrayUtilities;
    var BlockContext = class extends _occamlanguages.Context {
      constructor(context2, variables) {
        super(context2);
        this.variables = variables;
      }
      getVariables(nested = true) {
        const variables = [];
        push(variables, this.variables);
        if (nested) {
          const context2 = this.getContext(), contextVariables = context2.getVariables();
          push(variables, contextVariables);
        }
        return variables;
      }
      addVariable(variable) {
        const nested = false, variableName = variable.getName(), variableString = variable.getString(), variablePresent = this.isVariablePresentByVariableName(variableName, nested);
        if (variablePresent) {
          const message = `The '${variableString}' variable is already present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const context2 = this;
        context2.trace(`Added the '${variableString}' variable to the context.`);
        this.variables.push(variable);
      }
      findProcedureByProcedureName(procedureName) {
        const context2 = this.getContext(), procedure = context2.findProcedureByProcedureName(procedureName);
        return procedure;
      }
      isProcedurePresentByProcedureName(procedureName) {
        const context2 = this.getContext(), procedurePresent = context2.isProcedurePresentByProcedureName(procedureName);
        return procedurePresent;
      }
      findVariableByVariableName(variableName, nested = true) {
        const variables = this.getVariables(nested), variable = variables.find((variable2) => {
          const variableComparesToVariableName = variable2.compareVariableName(variableName);
          if (variableComparesToVariableName) {
            return true;
          }
        }) || null;
        return variable;
      }
      isVariablePresentByVariableName(variableName, nested = true) {
        const variable = this.findVariableByVariableName(variableName, nested), variablePresent = variable !== null;
        return variablePresent;
      }
      static fromVariables(variables, context2) {
        const blockContext = _occamlanguages.Context.fromNothing(BlockContext, variables, context2);
        return blockContext;
      }
    };
  });

  // lib/element/returnBlock.js
  var require_returnBlock = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _block = /* @__PURE__ */ _interop_require_default(require_block());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asyncForEach} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, steps, nonsensical, returnStatement) {
        super(context2, string, node);
        this.steps = steps;
        this.nonsensical = nonsensical;
        this.returnStatement = returnStatement;
      }
      getSteps() {
        return this.steps;
      }
      isNonsensical() {
        return this.nonsensical;
      }
      getReturnStatement() {
        return this.returnStatement;
      }
      async evaluate(variables, context2) {
        if (context2 === void 0) {
          context2 = variables;
          variables = [];
        }
        const returnBlockString = this.getString();
        context2.trace(`Evaluating the '${returnBlockString}' return block...`);
        if (this.nonsensical) {
          const message = `The return block is nonsensical.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const blockContext = _block.default.fromVariables(variables, context2);
        context2 = blockContext;
        await asyncForEach(this.steps, async (step) => {
          await step.evaluate(context2);
        });
        const term = this.returnStatement.evaluate(context2), termString = term.getString();
        context2.debug(`Evaluated... the '${returnBlockString}' return block as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ReturnBlock"), _a));
  });

  // lib/element/term/negated.js
  var require_negated = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, term) {
        super(context2, string, node);
        this.type = type;
        this.term = term;
      }
      getType() {
        return this.type;
      }
      getTerm() {
        return this.term;
      }
      evaluate(context2) {
        let term;
        const negatedTermString = this.getString();
        context2.trace(`Evaluating the '${negatedTermString}' negated term...`);
        term = this.term.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.BOOLEAN_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' left term's type is '${termType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let boolean;
        const primitiveValue = term.getPrimitiveValue();
        boolean = primitiveValue;
        boolean = !boolean;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${negatedTermString}' negated term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NegatedTerm"), _a));
  });

  // lib/element/term/logical.js
  var require_logical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, disjunction, leftTerm, rightTerm) {
        super(context2, string, node);
        this.type = type;
        this.disjunction = disjunction;
        this.leftTerm = leftTerm;
        this.rightTerm = rightTerm;
      }
      getType() {
        return this.type;
      }
      isDisjunction() {
        return this.disjunction;
      }
      getLeftTerm() {
        return this.leftTerm;
      }
      getRightTerm() {
        return this.rightTerm;
      }
      evaluate(context2) {
        let term;
        const logicalTermString = this.getString();
        context2.trace(`Evaluating the '${logicalTermString}' logical term...`);
        const leftTerm = this.leftTerm.evaluate(context2), rightTerm = this.rightTerm.evaluate(context2), leftTermType = leftTerm.getType(), rightTermType = rightTerm.getType();
        if (leftTermType !== _types.BOOLEAN_TYPE) {
          const leftTermString = leftTerm.getString(), message = `The '${leftTermString}' left term's type is '${leftTermType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        if (rightTermType !== _types.BOOLEAN_TYPE) {
          const rightTermString = rightTerm.getString(), message = `The '${rightTermString}' right term's type is '${rightTermType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const leftTermPrimitiveValue = leftTerm.getPrimitiveValue(), rightTermPrimitiveValue = rightTerm.getPrimitiveValue(), leftBoolean = leftTermPrimitiveValue, rightBoolean = rightTermPrimitiveValue, boolean = this.disjunction ? leftBoolean || rightBoolean : leftBoolean && rightBoolean;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${logicalTermString}' logical term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "LogicalTerm"), _a));
  });

  // lib/element/term/bracketed.js
  var require_bracketed = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term) {
        super(context2, string, node);
        this.term = term;
      }
      getTerm() {
        return this.term;
      }
      getType() {
        return this.term.getType();
      }
      evaluate(context2) {
        let term;
        const bracketedTermString = this.getString();
        context2.trace(`Evaluating the '${bracketedTermString}' bracketed term...`);
        term = this.term.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${bracketedTermString}' bracketed term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "BracketedTerm"), _a));
  });

  // lib/element/procedureCall.js
  var require_procedureCall = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, reference, terms) {
        super(context2, string, node);
        this.reference = reference;
        this.terms = terms;
      }
      getReference() {
        return this.reference;
      }
      getTerms() {
        return this.terms;
      }
      getProcedureName() {
        return this.reference.getProcedureName();
      }
      async evaluate(context2) {
        await this.break(context2);
        const procedureCallString = this.getString();
        context2.trace(`Evaluating the '${procedureCallString}' procedure call...`);
        const procedureName = this.getProcedureName(), procedurePresent = context2.isProcedurePresentByProcedureName(procedureName);
        if (!procedurePresent) {
          const message = `The '${procedureCallString} procedure is not present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const procedure = context2.findProcedureByProcedureName(procedureName), terms = this.terms.evaluate(context2), term = await procedure.call(terms, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${procedureCallString}' procedure call as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ProcedureCall"), _a));
  });

  // lib/element/term/comparison.js
  var require_comparison = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, negated, leftTerm, rightTerm) {
        super(context2, string, node);
        this.negated = negated;
        this.leftTerm = leftTerm;
        this.rightTerm = rightTerm;
      }
      isNegated() {
        return this.negated;
      }
      getLeftTerm() {
        return this.leftTerm;
      }
      getRightTerm() {
        return this.rightTerm;
      }
      evaluate(context2) {
        let term;
        const comparisonTermString = this.getString();
        context2.trace(`Evaluating the '${comparisonTermString}' comparison term...`);
        const leftTerm = this.leftTerm.evaluate(context2), rightTerm = this.rightTerm.evaluate(context2), leftTermType = leftTerm.getType(), rightTermType = rightTerm.getType();
        if (leftTermType !== rightTermType) {
          const leftTermString = leftTerm.getString(), rightTermString = rightTerm.getString(), message = `The '${leftTermString}' left term's type is '${leftTermType}' whereas the '${rightTermString}' right term's type is '${rightTermType}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const leftTermEqualToRightTerm = leftTerm.isEqualTo(rightTerm);
        let boolean = leftTermEqualToRightTerm;
        if (this.negated) {
          boolean = !boolean;
        }
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${comparisonTermString}' comparison term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ComparisonTerm"), _a));
  });

  // lib/element/parameter/named.js
  var require_named = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name, alias) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
        this.alias = alias;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      getAlias() {
        return this.alias;
      }
      isAliased() {
        const aliased = this.alias !== null;
        return aliased;
      }
      getAliasedName() {
        const aliased = this.isAliased(), aliasedName = aliased ? this.alias : this.name;
        return aliasedName;
      }
      compareTerm(term, context2) {
        const termString = term.getString(), namedParameterString = this.getString();
        context2.trace(`Comparing the '${termString}' term with the '${namedParameterString}' named parameter...`);
        const termType = term.getType();
        if (this.type !== termType) {
          const message = `The '${termString}' term's '${termType}' type is not equal to '${namedParameterString}' named parameter's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${termString}' term with the '${namedParameterString}' named parameter.`);
      }
      compareNamedParameter(namedParameter, context2) {
        let namedParameterCompares;
        const namedParameterA = this, namedParameterB = namedParameter;
        const namedParameterAString = namedParameterA.getString(), namedParameterBString = namedParameterB.getString();
        context2.trace(`Comparing the '${namedParameterAString}' named parameter with the '${namedParameterBString}' named parameter...`);
        const name = namedParameter.getName(), type = namedParameter.getType();
        namedParameterCompares = this.name === name && this.type === type;
        if (namedParameterCompares) {
          context2.debug(`...compared the '${namedParameterAString}' named parameter with the '${namedParameterBString}' named parameter.`);
        }
        return namedParameterCompares;
      }
    }, __publicField(_a, "name", "NamedParameter"), _a));
  });

  // lib/element/assignment/array.js
  var require_array4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _term = require_term();
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, parameters) {
        super(context2, string, node);
        this.variable = variable;
        this.parameters = parameters;
      }
      getVariable() {
        return this.variable;
      }
      getParameters() {
        return this.parameters;
      }
      evaluate(context2) {
        const arrayAssignmentString = this.getString();
        context2.trace(`Evaluating the '${arrayAssignmentString}' array assignment...`);
        const term = this.variable.evaluate(context2), termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), nodes = primitiveValue, nodesLength = nodes.length, parametersLength = this.parameters.getLength();
        if (parametersLength > nodesLength) {
          const parametersString = this.parameters.getString(), nodesString = context2.nodesAsString(nodex), message = `The length of the '${parametersString}' parameters is greater than the length of the '${nodesString}' nodes.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.parameters.forEachParameter((parameter, index) => {
          if (parameter !== null) {
            const node = nodes[index], term2 = (0, _term.termFromNode)(node, context2);
            this.evaluateParameter(parameter, term2, context2);
          }
        });
        context2.debug(`...evaluated the '${arrayAssignmentString}' array assignment.`);
      }
      evaluateParameter(parameter, expression, context2) {
        const expressionString = expression.getString(), parameterString = parameter.getString();
        context2.trace(`Evaluating the '${parameterString}' parameter against the '${expressionString}' expression...`);
        const parameterType = parameter.getType();
        if (parameterType !== _types.NODE_TYPE) {
          const message = `The type of the '${parameterString}' parameter should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const {Variable} = _elements.default, variable = Variable.fromParameter(parameter, context2);
        variable.assign(expression, context2);
        context2.debug(`...evaluated the '${parameterString}' parameter against the '${expressionString}' expression.`);
      }
    }, __publicField(_a, "name", "ArrayAssignment"), _a));
  });

  // lib/element/statement/return.js
  var require_return = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term) {
        super(context2, string, node);
        this.term = term;
      }
      getExpression() {
        return this.term;
      }
      evaluate(context2) {
        let term;
        const returnStatementString = this.getString();
        context2.trace(`Evaluating the '${returnStatementString}' return statement...`);
        term = this.term.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${returnStatementString}' return statement as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ReturnStatement"), _a));
  });

  // lib/element/parameters/named.js
  var require_named2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getNamedParameter(index) {
        const namedParameter = this.array[index] || null;
        return namedParameter;
      }
      someNamedParameter(callback) {
        return this.array.some(callback);
      }
      forEachNamedParameter(callback) {
        this.array.forEach(callback);
      }
      compareTerms(terms, context2) {
        const termsString = terms.getString(), namedParametersString = this.getString();
        context2.trace(`Comparing the '${termsString}' terms with the '${namedParametersString}' named parameters...`);
        const termsLength = terms.getLength(), namedParametersLength = this.getLength();
        if (termsLength !== namedParametersLength) {
          const message = `The '${termsString}' terms and '${namedParametersString}' named parameters are not of the same length.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.forEachNamedParameter((namedParameter, index) => {
          if (namedParameter !== null) {
            const term = terms.getTerm(index);
            namedParameter.compareTerm(term, context2);
          }
        });
        context2.debug(`...compared the '${termsString}' terms with the '${namedParametersString}' named parameters.`);
      }
      compareNamedParameter(namedParameter, context2) {
        const namedParameterString = namedParameter.getString(), namedParametersString = this.getString();
        context2.trace(`Comparing the '${namedParameterString}' namedParameter with the '${namedParametersString}' named parameters...`);
        const namedParameterA = namedParameter, namedParameterCompares = this.someNamedParameter((namedParameter2) => {
          if (namedParameter2 !== null) {
            const namedParameterB = namedParameter2, namedParameterBComparesToNamedParameterA = namedParameterA.compareNamedParameter(namedParameterB, context2);
            if (namedParameterBComparesToNamedParameterA) {
              return true;
            }
          }
        });
        if (!namedParameterCompares) {
          const message = `The '${namedParameterString}' namedParameter does not compare to any of the '${namedParametersString}' named parameters.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${namedParameterString}' namedParameter with the '${namedParametersString}' named parameters.`);
      }
      compareNamedParameters(namedParameters, context2) {
        namedParameters.forEachNamedParameter((namedParameter) => {
          if (namedParameter !== null) {
            this.compareNamedParameter(namedParameter, context2);
          }
        });
      }
    }, __publicField(_a, "name", "NamedParameters"), _a));
  });

  // lib/nodeProperty.js
  var require_nodeProperty = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodeProperty;
      }
    });
    var _string = require_string5();
    var _NodeProperty = class {
      constructor(string, type, name) {
        this.string = string;
        this.type = type;
        this.name = name;
      }
      getString() {
        return this.string;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      compareNamedParameter(namedParameter, context2) {
        let namedParameterCompares;
        const nodePropertyString = this.string, namedParameterString = namedParameter.getString();
        context2.trace(`Comparing the '${nodePropertyString}' node property with the '${namedParameterString}' named parameter...`);
        const name = namedParameter.getName(), type = namedParameter.getType();
        namedParameterCompares = this.name === name && this.type === type;
        if (namedParameterCompares) {
          context2.debug(`...compared the '${nodePropertyString}' node property with the '${namedParameterString}' named parameter.`);
        }
        return namedParameterCompares;
      }
      static fromNameAndType(name, type) {
        const nodePropertyString = (0, _string.nodePropertyStringFromNameAndType)(name, type), string = nodePropertyString, nodeProperty = new _NodeProperty(string, type, name);
        return nodeProperty;
      }
    };
    var NodeProperty = _NodeProperty;
    __publicField(NodeProperty, "name", "Parameter");
  });

  // lib/parameterNames.js
  var require_parameterNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CHILD_NODES_PARAMETER_NAME() {
        return CHILD_NODES_PARAMETER_NAME;
      },
      get CONTENT_PARAMETER_NAME() {
        return CONTENT_PARAMETER_NAME;
      },
      get TERMINAL_PARAMETER_NAME() {
        return TERMINAL_PARAMETER_NAME;
      }
    });
    var CONTENT_PARAMETER_NAME = "content";
    var TERMINAL_PARAMETER_NAME = "terminal";
    var CHILD_NODES_PARAMETER_NAME = "childNodes";
  });

  // lib/nodeProperties.js
  var require_nodeProperties = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _nodeProperty = /* @__PURE__ */ _interop_require_default(require_nodeProperty());
    var _types = require_types3();
    var _string = require_string5();
    var _parameterNames = require_parameterNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NodeProperties = class {
      constructor(string, array) {
        this.string = string;
        this.array = array;
      }
      getString() {
        return this.string;
      }
      getArray() {
        return this.array;
      }
      someNodeProperty(callback) {
        return this.array.some(callback);
      }
      compareNamedParameter(namedParameter, context2) {
        const nodePropertiesString = this.string, namedParameterString = namedParameter.getString();
        context2.trace(`Comparing the '${namedParameterString}' named parameter with the '${nodePropertiesString}' node properties...`);
        const namedParametersCompare = this.someNodeProperty((nodeProperty) => {
          const namedParameterComparesToNodeProperty = nodeProperty.compareNamedParameter(namedParameter, context2);
          if (namedParameterComparesToNodeProperty) {
            return true;
          }
        });
        if (!namedParametersCompare) {
          const message = `The '${namedParameterString}' named parameter does not compmare to any of the '${nodePropertiesString}' node properties.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${namedParameterString}' named parameter with the '${nodePropertiesString}' node properties.`);
      }
      compareNamedParameters(namedParameters, context2) {
        namedParameters.forEachNamedParameter((namedParameter) => {
          this.compareNamedParameter(namedParameter, context2);
        });
      }
      static fromNothing() {
        const nodePropertiesArray = nodePropertiesArrayFromNothing(), string = (0, _string.nodePropertiesStringFromNodePropertiesArray)(nodePropertiesArray), array = nodePropertiesArray, nodeProperties2 = new NodeProperties(string, array);
        return nodeProperties2;
      }
    };
    var nodeProperties = NodeProperties.fromNothing();
    var _default = nodeProperties;
    function nodePropertiesArrayFromNothing() {
      const types = [
        _types.STRING_TYPE,
        _types.BOOLEAN_TYPE,
        _types.NODES_TYPE
      ], names = [
        _parameterNames.CONTENT_PARAMETER_NAME,
        _parameterNames.TERMINAL_PARAMETER_NAME,
        _parameterNames.CHILD_NODES_PARAMETER_NAME
      ], nodePropertiesArray = names.map((name, index) => {
        const type = types[index], nodeProperty = _nodeProperty.default.fromNameAndType(name, type);
        return nodeProperty;
      });
      return nodePropertiesArray;
    }
  });

  // lib/element/assignment/object.js
  var require_object2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _nodeProperties = /* @__PURE__ */ _interop_require_default(require_nodeProperties());
    var _stringLiteral = require_stringLiteral6();
    var _types = require_types3();
    var _term = require_term();
    var _parameterNames = require_parameterNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, namedParameters) {
        super(context2, string, node);
        this.variable = variable;
        this.namedParameters = namedParameters;
      }
      getVariable() {
        return this.variable;
      }
      getNamedParameters() {
        return this.namedParameters;
      }
      evaluate(context2) {
        const objectAssignmentString = this.getString();
        context2.trace(`Evaluating the '${objectAssignmentString}' object assignment...`);
        const term = this.variable.evaluate(context2), termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        _nodeProperties.default.compareNamedParameters(this.namedParameters, context2);
        this.namedParameters.forEachNamedParameter((namedParameter) => {
          this.evaluateNamedParameter(namedParameter, term, context2);
        });
        context2.debug(`...evaluated the '${objectAssignmentString}' object assignment.`);
      }
      evaluateNamedParameter(namedParameter, term, context2) {
        const termString = term.getString(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the '${namedParameterString}' named parameter against the '${termString}' term...`);
        const name = namedParameter.getName();
        switch (name) {
          case _parameterNames.CONTENT_PARAMETER_NAME: {
            term = this.evaluateContentNamedParameter(namedParameter, term, context2);
            break;
          }
          case _parameterNames.TERMINAL_PARAMETER_NAME: {
            term = this.evaluateTerminalNamedParameter(namedParameter, term, context2);
            break;
          }
          case _parameterNames.CHILD_NODES_PARAMETER_NAME: {
            term = this.evaluateChildNodesNamedParameter(namedParameter, term, context2);
            break;
          }
        }
        const {Variable} = _elements.default, variable = Variable.fromNamedParameter(namedParameter, context2);
        variable.assign(term, context2);
        context2.debug(`...evaluated the '${namedParameterString}' parameter named against the '${termString}' term.`);
      }
      evaluateContentNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the content '${namedParameterString}' named parameter...`);
        if (type !== _types.STRING_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.STRING_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeTerminalNode = node.isTerminalNode();
        if (!nodeTerminalNode) {
          const termString = term.getString(), message = `The '${termString}' term's node must be terminal.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const terminalNode = node, content = terminalNode.getContent(), string = content, stringLiteral = (0, _stringLiteral.stringLiteralFromString)(string);
        term = (0, _term.termFromStringLiteral)(stringLiteral, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the content '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
      evaluateTerminalNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the terminal '${namedParameterString}' named parameter...`);
        if (type !== _types.BOOLEAN_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeTerminalNode = node.isTerminalNode(), terminal = nodeTerminalNode;
        const boolean = terminal;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the terminal '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
      evaluateChildNodesNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the child nodes '${namedParameterString}' named parameter...`);
        if (type !== _types.NODES_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeNonTerminalNode = node.isNonTerminalNode();
        if (!nodeNonTerminalNode) {
          const termString = term.getString(), message = `The '${termString}' term's node must be non-terminal.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nonTerminalNode = node, childNodes = nonTerminalNode.getChildNodes(), nodes = childNodes;
        term = (0, _term.termFromNodes)(nodes, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the childNodes '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ObjectAssigment"), _a));
  });

  // lib/element/procedure/anonymous.js
  var require_anonymous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _procedure = require_procedure();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, parameters, returnBlock) {
        super(context2, string, node);
        this.type = type;
        this.parameters = parameters;
        this.returnBlock = returnBlock;
      }
      getType() {
        return this.type;
      }
      getParameters() {
        return this.parameters;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      async call(terms, context2) {
        const anonymousProcedureString = this.getString();
        context2.trace(`Calling the '${anonymousProcedureString}' anonymous procedure...`);
        this.parameters.compareTerms(terms, context2);
        const variables = (0, _procedure.variablesFromTermsAndParameters)(terms, this.parameters, context2), term = await this.returnBlock.evaluate(variables, context2), termType = term.getType();
        if (this.type !== termType) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type is not equal to the '${anonymousProcedureString}' anonymous procedure's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...called the '${anonymousProcedureString}' anonymous procedure.`);
        return term;
      }
    }, __publicField(_a, "name", "AnonymousProcedure"), _a));
  });

  // lib/element/assignment/variable.js
  var require_variable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, expression) {
        super(context2, string, node);
        this.variable = variable;
        this.expression = expression;
      }
      getVariable() {
        return this.variable;
      }
      getExpression() {
        return this.expression;
      }
      async evaluate(context2) {
        let term;
        const variableAssignmentString = this.getString();
        context2.trace(`Evaluating the '${variableAssignmentString}' variable assignment...`);
        term = await this.expression.evaluate(context2);
        this.variable.assign(term, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${variableAssignmentString}' variable assignment as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "VariableAssignment"), _a));
  });

  // lib/element/assignments/variable.js
  var require_variable3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var {asyncForEach} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      async evaluate(context2) {
        await this.break(context2);
        const variableAssignmentsString = this.getString();
        context2.trace(`Evaluating the '${variableAssignmentsString}' variable assignments...`);
        await asyncForEach(this.array, async (variableAssignment) => {
          await variableAssignment.evaluate(context2);
        });
        context2.debug(`...evaluated the '${variableAssignmentsString}' variable assignments.`);
      }
    }, __publicField(_a, "name", "VariableAssignments"), _a));
  });

  // lib/element/declaration/procedure.js
  var require_procedure2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, procedure) {
        super(context2, string, node);
        this.string = string;
        this.procedure = procedure;
      }
      getProcedure() {
        return this.procedure;
      }
      verify(context2) {
        const verifies = true;
        const procedureDeclarationString = this.getString();
        context2.trace(`Verifying the '${procedureDeclarationString}' procedure declaration...`);
        const procedure = this.getProcedure();
        context2.addProcedure(procedure);
        if (verifies) {
          context2.debug(`...verified the '${procedureDeclarationString}' procedure declaration.`);
        }
        return verifies;
      }
    }, __publicField(_a, "name", "ProcedureDeclaration"), _a));
  });

  // lib/preamble.js
  var require_preamble = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _step = /* @__PURE__ */ _interop_require_default(require_step());
    var _some = /* @__PURE__ */ _interop_require_default(require_some());
    var _term = /* @__PURE__ */ _interop_require_default(require_term2());
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms());
    var _label = /* @__PURE__ */ _interop_require_default(require_label());
    var _error = /* @__PURE__ */ _interop_require_default(require_error4());
    var _every = /* @__PURE__ */ _interop_require_default(require_every());
    var _reduce = /* @__PURE__ */ _interop_require_default(require_reduce());
    var _ternary = /* @__PURE__ */ _interop_require_default(require_ternary());
    var _variable = /* @__PURE__ */ _interop_require_default(require_variable());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive2());
    var _reference = /* @__PURE__ */ _interop_require_default(require_reference2());
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure());
    var _nodeQuery = /* @__PURE__ */ _interop_require_default(require_nodeQuery());
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter());
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters());
    var _nodesQuery = /* @__PURE__ */ _interop_require_default(require_nodesQuery());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression2());
    var _returnBlock = /* @__PURE__ */ _interop_require_default(require_returnBlock());
    var _negated = /* @__PURE__ */ _interop_require_default(require_negated());
    var _logical = /* @__PURE__ */ _interop_require_default(require_logical());
    var _bracketed = /* @__PURE__ */ _interop_require_default(require_bracketed());
    var _procedureCall = /* @__PURE__ */ _interop_require_default(require_procedureCall());
    var _comparison = /* @__PURE__ */ _interop_require_default(require_comparison());
    var _named = /* @__PURE__ */ _interop_require_default(require_named());
    var _array = /* @__PURE__ */ _interop_require_default(require_array4());
    var _return = /* @__PURE__ */ _interop_require_default(require_return());
    var _named1 = /* @__PURE__ */ _interop_require_default(require_named2());
    var _object = /* @__PURE__ */ _interop_require_default(require_object2());
    var _anonymous = /* @__PURE__ */ _interop_require_default(require_anonymous());
    var _variable1 = /* @__PURE__ */ _interop_require_default(require_variable2());
    var _variable2 = /* @__PURE__ */ _interop_require_default(require_variable3());
    var _procedure1 = /* @__PURE__ */ _interop_require_default(require_procedure2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/furtle/lexer.js
  var require_lexer14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleLexer;
      }
    });
    var _occamgrammars = require_lib11();
    var FurtleLexer = class extends _occamgrammars.FurtleLexer {
    };
  });

  // lib/ruleNames.js
  var require_ruleNames5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ANONYMOUS_PROCEDURE_RULE_NAME() {
        return ANONYMOUS_PROCEDURE_RULE_NAME;
      },
      get ARRAY_ASSIGNMENT_RULE_NAME() {
        return ARRAY_ASSIGNMENT_RULE_NAME;
      },
      get BRACKETED_TERM_RULE_NAME() {
        return BRACKETED_TERM_RULE_NAME;
      },
      get COMPARISON_TERM_RULE_NAME() {
        return COMPARISON_TERM_RULE_NAME;
      },
      get DOCUMENT_RULE_NAME() {
        return DOCUMENT_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get EVERY_RULE_NAME() {
        return EVERY_RULE_NAME;
      },
      get EXPRESSION_RULE_NAME() {
        return EXPRESSION_RULE_NAME;
      },
      get LABEL_RULE_NAME() {
        return LABEL_RULE_NAME;
      },
      get LOGICAL_TERM_RULE_NAME() {
        return LOGICAL_TERM_RULE_NAME;
      },
      get NAMED_PARAMETERS_RULE_NAME() {
        return NAMED_PARAMETERS_RULE_NAME;
      },
      get NAMED_PARAMETER_RULE_NAME() {
        return NAMED_PARAMETER_RULE_NAME;
      },
      get NEGATED_TERM_RULE_NAME() {
        return NEGATED_TERM_RULE_NAME;
      },
      get NODES_QUERY_RULE_NAME() {
        return NODES_QUERY_RULE_NAME;
      },
      get NODE_QUERY_RULE_NAME() {
        return NODE_QUERY_RULE_NAME;
      },
      get NONSENSE_RULE_NAME() {
        return NONSENSE_RULE_NAME;
      },
      get OBJECT_ASSIGNMENT_RULE_NAME() {
        return OBJECT_ASSIGNMENT_RULE_NAME;
      },
      get PARAMETERS_RULE_NAME() {
        return PARAMETERS_RULE_NAME;
      },
      get PARAMETER_RULE_NAME() {
        return PARAMETER_RULE_NAME;
      },
      get PRIMITIVE_RULE_NAME() {
        return PRIMITIVE_RULE_NAME;
      },
      get PROCEDURE_CALL_RULE_NAME() {
        return PROCEDURE_CALL_RULE_NAME;
      },
      get PROCEDURE_DECLARATION_RULE_NAME() {
        return PROCEDURE_DECLARATION_RULE_NAME;
      },
      get REDUCE_RULE_NAME() {
        return REDUCE_RULE_NAME;
      },
      get REFERENCE_RULE_NAME() {
        return REFERENCE_RULE_NAME;
      },
      get RETURN_BLOCK_RULE_NAME() {
        return RETURN_BLOCK_RULE_NAME;
      },
      get RETURN_STATEMENT_RULE_NAME() {
        return RETURN_STATEMENT_RULE_NAME;
      },
      get SOME_RULE_NAME() {
        return SOME_RULE_NAME;
      },
      get STEP_RULE_NAME() {
        return STEP_RULE_NAME;
      },
      get TERMS_RULE_NAME() {
        return TERMS_RULE_NAME;
      },
      get TERM_RULE_NAME() {
        return TERM_RULE_NAME;
      },
      get TERNARY_RULE_NAME() {
        return TERNARY_RULE_NAME;
      },
      get VARIABLE_ASSIGNMENTS_RULE_NAME() {
        return VARIABLE_ASSIGNMENTS_RULE_NAME;
      },
      get VARIABLE_ASSIGNMENT_RULE_NAME() {
        return VARIABLE_ASSIGNMENT_RULE_NAME;
      },
      get VARIABLE_RULE_NAME() {
        return VARIABLE_RULE_NAME;
      }
    });
    var STEP_RULE_NAME = "step";
    var SOME_RULE_NAME = "some";
    var TERM_RULE_NAME = "term";
    var TERMS_RULE_NAME = "terms";
    var EVERY_RULE_NAME = "every";
    var LABEL_RULE_NAME = "label";
    var ERROR_RULE_NAME = "error";
    var REDUCE_RULE_NAME = "reduce";
    var TERNARY_RULE_NAME = "ternary";
    var VARIABLE_RULE_NAME = "variable";
    var NONSENSE_RULE_NAME = "nonsense";
    var DOCUMENT_RULE_NAME = "document";
    var PRIMITIVE_RULE_NAME = "primitive";
    var REFERENCE_RULE_NAME = "reference";
    var PARAMETER_RULE_NAME = "parameter";
    var NODE_QUERY_RULE_NAME = "nodeQuery";
    var EXPRESSION_RULE_NAME = "expression";
    var PARAMETERS_RULE_NAME = "parameters";
    var NODES_QUERY_RULE_NAME = "nodesQuery";
    var RETURN_BLOCK_RULE_NAME = "returnBlock";
    var LOGICAL_TERM_RULE_NAME = "logicalTerm";
    var NEGATED_TERM_RULE_NAME = "negatedTerm";
    var BRACKETED_TERM_RULE_NAME = "bracketedTerm";
    var PROCEDURE_CALL_RULE_NAME = "procedureCall";
    var COMPARISON_TERM_RULE_NAME = "comparisonTerm";
    var NAMED_PARAMETER_RULE_NAME = "namedParameter";
    var NAMED_PARAMETERS_RULE_NAME = "namedParameters";
    var RETURN_STATEMENT_RULE_NAME = "returnStatement";
    var ARRAY_ASSIGNMENT_RULE_NAME = "arrayAssignment";
    var OBJECT_ASSIGNMENT_RULE_NAME = "objectAssignment";
    var VARIABLE_ASSIGNMENT_RULE_NAME = "variableAssignment";
    var ANONYMOUS_PROCEDURE_RULE_NAME = "anonymousProcedure";
    var VARIABLE_ASSIGNMENTS_RULE_NAME = "variableAssignments";
    var PROCEDURE_DECLARATION_RULE_NAME = "procedureDeclaration";
  });

  // lib/node/step.js
  var require_step2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StepNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var StepNode = class extends _occamlanguages.NonTerminalNode {
      getArrayAssignmentNode() {
        const ruleName = _ruleNames.ARRAY_ASSIGNMENT_RULE_NAME, arrayAssignmentNode = this.getNodeByRuleName(ruleName);
        return arrayAssignmentNode;
      }
      getObjectAssignmentNode() {
        const ruleName = _ruleNames.OBJECT_ASSIGNMENT_RULE_NAME, objectAssignmentNode = this.getNodeByRuleName(ruleName);
        return objectAssignmentNode;
      }
      getVariableAssignmentsNode() {
        const ruleName = _ruleNames.VARIABLE_ASSIGNMENTS_RULE_NAME, variableAssignmentsNode = this.getNodeByRuleName(ruleName);
        return variableAssignmentsNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(StepNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/some.js
  var require_some2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SomeNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var SomeNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variabloeNode = this.getNodeByRuleName(ruleName);
        return variabloeNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(SomeNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term.js
  var require_term3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TermNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var TermNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getPrimitiveNode() {
        const ruleName = _ruleNames.PRIMITIVE_RULE_NAME, primitiveNode = this.getNodeByRuleName(ruleName);
        return primitiveNode;
      }
      getNegatedTermNode() {
        const ruleName = _ruleNames.NEGATED_TERM_RULE_NAME, negatedTermNode = this.getNodeByRuleName(ruleName);
        return negatedTermNode;
      }
      getLogicalTermNode() {
        const ruleName = _ruleNames.LOGICAL_TERM_RULE_NAME, logicalTermRuleName = this.getNodeByRuleName(ruleName);
        return logicalTermRuleName;
      }
      getBracketedTermNode() {
        const ruleName = _ruleNames.BRACKETED_TERM_RULE_NAME, bracketedTermRuleName = this.getNodeByRuleName(ruleName);
        return bracketedTermRuleName;
      }
      getComparisonTermNode() {
        const ruleName = _ruleNames.COMPARISON_TERM_RULE_NAME, comparisonNode = this.getNodeByRuleName(ruleName);
        return comparisonNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = TermNode;
        }
        const termNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return termNode;
      }
    };
  });

  // lib/node/terms.js
  var require_terms2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TermNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var TermNode = class extends _occamlanguages.NonTerminalNode {
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(TermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/every.js
  var require_every2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EveryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var EveryNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(EveryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/tokenTypes.js
  var require_tokenTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN_TOKEN_TYPE() {
        return BOOLEAN_TOKEN_TYPE;
      },
      get NAME_TOKEN_TYPE() {
        return NAME_TOKEN_TYPE;
      },
      get NULL_TOKEN_TYPE() {
        return NULL_TOKEN_TYPE;
      },
      get NUMBER_TOKEN_TYPE() {
        return NUMBER_TOKEN_TYPE;
      },
      get SPECIAL_TOKEN_TYPE() {
        return SPECIAL_TOKEN_TYPE;
      },
      get STRING_LITERAL_TOKEN_TYPE() {
        return STRING_LITERAL_TOKEN_TYPE;
      },
      get TYPE_TOKEN_TYPE() {
        return TYPE_TOKEN_TYPE;
      }
    });
    var TYPE_TOKEN_TYPE = "type";
    var NAME_TOKEN_TYPE = "name";
    var NULL_TOKEN_TYPE = "null";
    var NUMBER_TOKEN_TYPE = "number";
    var SPECIAL_TOKEN_TYPE = "special";
    var BOOLEAN_TOKEN_TYPE = "boolean";
    var STRING_LITERAL_TOKEN_TYPE = "string-literal";
  });

  // lib/node/label.js
  var require_label2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LabelNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var LabelNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(LabelNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/error.js
  var require_error5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorNode;
      }
    });
    var _occamlanguages = require_lib14();
    var ErrorNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ErrorNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/reduce.js
  var require_reduce2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReduceNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ReduceNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getExpressionNode() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNode = this.getNodeByRuleName(ruleName);
        return expressionNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReduceNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/ternary.js
  var require_ternary2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TernaryNode;
      }
    });
    var _necessary = require_browser();
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var {first: first2, second} = _necessary.arrayUtilities;
    var TernaryNode = class extends _occamlanguages.NonTerminalNode {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      getExpressionNodes() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNodes = this.getNodesByRuleName(ruleName);
        return expressionNodes;
      }
      getIfExpressionNode() {
        const firstExpressionNode = this.getFirstExpressionNode(), ifExpressionNode = firstExpressionNode;
        return ifExpressionNode;
      }
      getElseExpressionNode() {
        const secondExpressionNode = this.getSecondExpressionNode(), elseExpressionNode = secondExpressionNode;
        return elseExpressionNode;
      }
      getFirstExpressionNode() {
        const expressionNodes = this.getExpressionNodes(), firstExpressionNode = first2(expressionNodes);
        return firstExpressionNode;
      }
      getSecondExpressionNode() {
        const expressionNodes = this.getExpressionNodes(), secondExpressionNode = second(expressionNodes);
        return secondExpressionNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(TernaryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/document.js
  var require_document5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentNode;
      }
    });
    var _occamlanguages = require_lib14();
    var DocumentNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(DocumentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/variable.js
  var require_variable4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var VariableNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(VariableNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/nonsense.js
  var require_nonsense = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonsenseNode;
      }
    });
    var _occamlanguages = require_lib14();
    var NonsenseNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NonsenseNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/primitive.js
  var require_primitive3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrimitiveNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _constants = require_constants13();
    var _types = require_types3();
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrimitiveNode = class extends _occamlanguages.NonTerminalNode {
      getType() {
        let type;
        const node = this.getNode(), number = this.getNumber(), boolean = this.getBoolean(), stringLiteral = this.getStringLiteral();
        if (false) {
        } else if (node !== null) {
          type = _types.NODE_TYPE;
        } else if (number !== null) {
          type = _types.NUMBER_TYPE;
        } else if (boolean !== null) {
          type = _types.BOOLEAN_TYPE;
        } else if (stringLiteral !== null) {
          type = _types.STRING_TYPE;
        }
        return type;
      }
      getValue() {
        let value;
        const node = this.getNode(), number = this.getNumber(), boolean = this.getBoolean(), stringLiteral = this.getStringLiteral();
        if (false) {
        } else if (node !== null) {
          value = node;
        } else if (number !== null) {
          value = number;
        } else if (boolean !== null) {
          value = boolean;
        } else if (stringLiteral !== null) {
          value = stringLiteral;
        }
        return value;
      }
      getNode() {
        let node = null;
        const tokenType = _tokenTypes.NULL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.NULL) {
            node = _nullNode.default;
            return true;
          }
        }, tokenType);
        return node;
      }
      getNumber() {
        let number = null;
        const tokenType = _tokenTypes.NUMBER_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.TRUE) {
            number = Number(content);
            return true;
          }
        }, tokenType);
        return number;
      }
      getBoolean() {
        let boolean = null;
        const tokenType = _tokenTypes.BOOLEAN_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.TRUE) {
            boolean = true;
            return true;
          }
          if (content === _constants.FALSE) {
            boolean = false;
            return true;
          }
        }, tokenType);
        return boolean;
      }
      getStringLiteral() {
        let stringLiteral = null;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(PrimitiveNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/reference.js
  var require_reference3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReferenceNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var ReferenceNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReferenceNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameter.js
  var require_parameter2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParamterNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var ParamterNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name = null;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      getType() {
        let type = null;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
          return true;
        }, tokenType);
        return type;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = ParamterNode;
        }
        const parameterNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return parameterNode;
      }
    };
  });

  // lib/node/nodeQuery.js
  var require_nodeQuery2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodeQueryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var _stringLiteral = require_stringLiteral6();
    var _tokenTypes = require_tokenTypes();
    var NodeQueryNode = class extends _occamlanguages.NonTerminalNode {
      getString() {
        const stringLiteral = this.getStringLiteral(), string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral);
        return string;
      }
      getStringLiteral() {
        let stringLiteral;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NodeQueryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/expression.js
  var require_expression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ExpressionNode = class extends _occamlanguages.NonTerminalNode {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      getSomeNode() {
        const ruleName = _ruleNames.SOME_RULE_NAME, someNode = this.getNodeByRuleName(ruleName);
        return someNode;
      }
      getEveryNode() {
        const ruleName = _ruleNames.EVERY_RULE_NAME, everyNode = this.getNodeByRuleName(ruleName);
        return everyNode;
      }
      getReduceNode() {
        const ruleName = _ruleNames.REDUCE_RULE_NAME, reduceNode = this.getNodeByRuleName(ruleName);
        return reduceNode;
      }
      getTernaryNode() {
        const ruleName = _ruleNames.TERNARY_RULE_NAME, ternaryNode = this.getNodeByRuleName(ruleName);
        return ternaryNode;
      }
      getNodeQueryNode() {
        const ruleName = _ruleNames.NODE_QUERY_RULE_NAME, nodeQueryNode = this.getNodeByRuleName(ruleName);
        return nodeQueryNode;
      }
      getNodesQueryNode() {
        const ruleName = _ruleNames.NODES_QUERY_RULE_NAME, nodeSQueryNode = this.getNodeByRuleName(ruleName);
        return nodeSQueryNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      getProcedureCallNode() {
        const ruleName = _ruleNames.PROCEDURE_CALL_RULE_NAME, procedureCallNode = this.getNodeByRuleName(ruleName);
        return procedureCallNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ExpressionNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameters.js
  var require_parameters2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParamtersNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ParamtersNode = class extends _occamlanguages.NonTerminalNode {
      getParameterNodes() {
        const ruleName = _ruleNames.PARAMETER_RULE_NAME, parameterNodes = this.getNodesByRuleName(ruleName);
        return parameterNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = ParamtersNode;
        }
        const parametersNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return parametersNode;
      }
    };
  });

  // lib/node/nodesQuery.js
  var require_nodesQuery2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodesQueryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var _stringLiteral = require_stringLiteral6();
    var _tokenTypes = require_tokenTypes();
    var NodesQueryNode = class extends _occamlanguages.NonTerminalNode {
      getString() {
        const stringLiteral = this.getStringLiteral(), string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral);
        return string;
      }
      getStringLiteral() {
        let stringLiteral = null;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NodesQueryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/returnBlock.js
  var require_returnBlock2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReturnBlockNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ReturnBlockNode = class extends _occamlanguages.NonTerminalNode {
      isNonsensical() {
        const nonsenseNodes = this.getNonsenseNodes(), nonsenseNodesLength = nonsenseNodes.length, nonsensical = nonsenseNodesLength > 0;
        return nonsensical;
      }
      getStepNodes() {
        const ruleName = _ruleNames.STEP_RULE_NAME, stepNodes = this.getNodesByRuleName(ruleName);
        return stepNodes;
      }
      getNonsenseNodes() {
        const ruleName = _ruleNames.NONSENSE_RULE_NAME, nonsenseNodes = this.getNodesByRuleName(ruleName);
        return nonsenseNodes;
      }
      getReturnStatementNode() {
        const ruleName = _ruleNames.RETURN_STATEMENT_RULE_NAME, returnStatement = this.getNodeByRuleName(ruleName);
        return returnStatement;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReturnBlockNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/logical.js
  var require_logical2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LogicalTermNode;
      }
    });
    var _necessary = require_browser();
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    var _tokenTypes = require_tokenTypes();
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, last} = _necessary.arrayUtilities;
    var LogicalTermNode = class extends _term.default {
      getOperator() {
        let operator = null;
        const tokenType = _tokenTypes.SPECIAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          operator = content;
          return true;
        }, tokenType);
        return operator;
      }
      isConjection() {
        const operator = this.getOperator(), conjection = operator === _constants.CONJUNCTION_OPERATOR;
        return conjection;
      }
      isDisjunction() {
        const operator = this.getOperator(), disjunction = operator === _constants.DISJUNCTION_OPERATOR;
        return disjunction;
      }
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      getLeftTermNode() {
        const firstExpresionNode = this.getFirstTermNode(), leftTermNode = firstExpresionNode;
        return leftTermNode;
      }
      getRightTermNode() {
        const lastTermNode = this.getLastTermNode(), rightTermNode = lastTermNode;
        return rightTermNode;
      }
      getLastTermNode() {
        const termNodes = this.getTermNodes(), lastTermNode = last(termNodes);
        return lastTermNode;
      }
      getFirstTermNode() {
        const termNodes = this.getTermNodes(), firstTermNode = first2(termNodes);
        return firstTermNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(LogicalTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/negated.js
  var require_negated2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NegatedTermNode;
      }
    });
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NegatedTermNode = class extends _term.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(NegatedTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedureCall.js
  var require_procedureCall2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureCallNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ProcedureCallNode = class extends _occamlanguages.NonTerminalNode {
      getTermsNode() {
        const ruleName = _ruleNames.TERMS_RULE_NAME, termsNode = this.getNodeByRuleName(ruleName);
        return termsNode;
      }
      getReferenceNode() {
        const ruleName = _ruleNames.REFERENCE_RULE_NAME, referenceNode = this.getNodeByRuleName(ruleName);
        return referenceNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ProcedureCallNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/bracketed.js
  var require_bracketed2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BracketedTermNode;
      }
    });
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BracketedTermNode = class extends _term.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(BracketedTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/comparison.js
  var require_comparison2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ComparisonTermNode;
      }
    });
    var _necessary = require_browser();
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _constants = require_constants13();
    var _ruleNames = require_ruleNames5();
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var ComparisonTermNode = class extends _term.default {
      isNegated() {
        let negated = false;
        const tokenType = _tokenTypes.SPECIAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.NOT_EQUAL_TO) {
            negated = true;
          }
          return true;
        }, tokenType);
        return negated;
      }
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      getLeftTermNode() {
        const firstTermNode = this.getFirstTermNode(), leftTermNode = firstTermNode;
        return leftTermNode;
      }
      getRightTermNode() {
        const secondTermNode = this.getSecondTermNode(), rightTermNode = secondTermNode;
        return rightTermNode;
      }
      getFirstTermNode() {
        const termNodes = this.getTermNodes(), firstTermNode = first2(termNodes);
        return firstTermNode;
      }
      getSecondTermNode() {
        const termNodes = this.getTermNodes(), secondTermNode = second(termNodes);
        return secondTermNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(ComparisonTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameter/named.js
  var require_named3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NamedParamterNode;
      }
    });
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter2());
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NamedParamterNode = class extends _parameter.default {
      getAlias() {
        let alias = null;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode, index) => {
          if (index === 3) {
            const content = terminalNode.getContent();
            alias = content;
            return true;
          }
        }, tokenType);
        return alias;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _parameter.default.fromRuleNameChildNodesOpacityAndPrecedence(NamedParamterNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameters/named.js
  var require_named4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NamedParamtersNode;
      }
    });
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters2());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NamedParamtersNode = class extends _parameters.default {
      getNamedParameterNodes() {
        const ruleName = _ruleNames.NAMED_PARAMETER_RULE_NAME, namedParamterNodes = this.getNodesByRuleName(ruleName);
        return namedParamterNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _parameters.default.fromRuleNameChildNodesOpacityAndPrecedence(NamedParamtersNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/statement.js
  var require_statement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StatementNode;
      }
    });
    var _occamlanguages = require_lib14();
    var StatementNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/statement/return.js
  var require_return2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReturnStatementNode;
      }
    });
    var _statement = /* @__PURE__ */ _interop_require_default(require_statement());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ReturnStatementNode = class extends _statement.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _statement.default.fromRuleNameChildNodesOpacityAndPrecedence(ReturnStatementNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment.js
  var require_assignment = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AssignmentrNode;
      }
    });
    var _occamlanguages = require_lib14();
    var AssignmentrNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/array.js
  var require_array5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ArrayAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ArrayAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(ArrayAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/object.js
  var require_object3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ObjectAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ObjectAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getNamedParametersNode() {
        const ruleName = _ruleNames.NAMED_PARAMETERS_RULE_NAME, namedParametersNode = this.getNodeByRuleName(ruleName);
        return namedParametersNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(ObjectAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedure.js
  var require_procedure3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureNode;
      }
    });
    var _occamlanguages = require_lib14();
    var ProcedureNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedure/anoymous.js
  var require_anoymous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AnonymousProcedureNode;
      }
    });
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure3());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AnonymousProcedureNode = class extends _procedure.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _procedure.default.fromRuleNameChildNodesOpacityAndPrecedence(AnonymousProcedureNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/variable.js
  var require_variable5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VariableAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getExpressionNode() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNode = this.getNodeByRuleName(ruleName);
        return expressionNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(VariableAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignments/variable.js
  var require_variable6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableAssignmentsNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VariableAssignmentsNode = class extends _assignment.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getVariableAssignmentNodes() {
        const ruleName = _ruleNames.VARIABLE_ASSIGNMENT_RULE_NAME, variableAssingnmentNodss = this.getNodesByRuleName(ruleName);
        return variableAssingnmentNodss;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(VariableAssignmentsNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/declaration.js
  var require_declaration2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DeclarationNode;
      }
    });
    var _occamlanguages = require_lib14();
    var DeclarationNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/declaration/procedure.js
  var require_procedure4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureDeclarationNode;
      }
    });
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration2());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ProcedureDeclarationNode = class extends _declaration.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getLabelNode() {
        const ruleName = _ruleNames.LABEL_RULE_NAME, labelNode = this.getNodeByRuleName(ruleName);
        return labelNode;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _declaration.default.fromRuleNameChildNodesOpacityAndPrecedence(ProcedureDeclarationNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _step = /* @__PURE__ */ _interop_require_default(require_step2());
    var _some = /* @__PURE__ */ _interop_require_default(require_some2());
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms2());
    var _every = /* @__PURE__ */ _interop_require_default(require_every2());
    var _label = /* @__PURE__ */ _interop_require_default(require_label2());
    var _error = /* @__PURE__ */ _interop_require_default(require_error5());
    var _reduce = /* @__PURE__ */ _interop_require_default(require_reduce2());
    var _ternary = /* @__PURE__ */ _interop_require_default(require_ternary2());
    var _document = /* @__PURE__ */ _interop_require_default(require_document5());
    var _variable = /* @__PURE__ */ _interop_require_default(require_variable4());
    var _nonsense = /* @__PURE__ */ _interop_require_default(require_nonsense());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive3());
    var _reference = /* @__PURE__ */ _interop_require_default(require_reference3());
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter2());
    var _nodeQuery = /* @__PURE__ */ _interop_require_default(require_nodeQuery2());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression3());
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters2());
    var _nodesQuery = /* @__PURE__ */ _interop_require_default(require_nodesQuery2());
    var _returnBlock = /* @__PURE__ */ _interop_require_default(require_returnBlock2());
    var _logical = /* @__PURE__ */ _interop_require_default(require_logical2());
    var _negated = /* @__PURE__ */ _interop_require_default(require_negated2());
    var _procedureCall = /* @__PURE__ */ _interop_require_default(require_procedureCall2());
    var _bracketed = /* @__PURE__ */ _interop_require_default(require_bracketed2());
    var _comparison = /* @__PURE__ */ _interop_require_default(require_comparison2());
    var _named = /* @__PURE__ */ _interop_require_default(require_named3());
    var _named1 = /* @__PURE__ */ _interop_require_default(require_named4());
    var _return = /* @__PURE__ */ _interop_require_default(require_return2());
    var _array = /* @__PURE__ */ _interop_require_default(require_array5());
    var _object = /* @__PURE__ */ _interop_require_default(require_object3());
    var _anoymous = /* @__PURE__ */ _interop_require_default(require_anoymous());
    var _variable1 = /* @__PURE__ */ _interop_require_default(require_variable5());
    var _variable2 = /* @__PURE__ */ _interop_require_default(require_variable6());
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure4());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeMap = {
      [_ruleNames.STEP_RULE_NAME]: _step.default,
      [_ruleNames.SOME_RULE_NAME]: _some.default,
      [_ruleNames.TERM_RULE_NAME]: _term.default,
      [_ruleNames.TERMS_RULE_NAME]: _terms.default,
      [_ruleNames.EVERY_RULE_NAME]: _every.default,
      [_ruleNames.LABEL_RULE_NAME]: _label.default,
      [_ruleNames.ERROR_RULE_NAME]: _error.default,
      [_ruleNames.REDUCE_RULE_NAME]: _reduce.default,
      [_ruleNames.TERNARY_RULE_NAME]: _ternary.default,
      [_ruleNames.VARIABLE_RULE_NAME]: _variable.default,
      [_ruleNames.NONSENSE_RULE_NAME]: _nonsense.default,
      [_ruleNames.DOCUMENT_RULE_NAME]: _document.default,
      [_ruleNames.PRIMITIVE_RULE_NAME]: _primitive.default,
      [_ruleNames.REFERENCE_RULE_NAME]: _reference.default,
      [_ruleNames.PARAMETER_RULE_NAME]: _parameter.default,
      [_ruleNames.NODE_QUERY_RULE_NAME]: _nodeQuery.default,
      [_ruleNames.EXPRESSION_RULE_NAME]: _expression.default,
      [_ruleNames.PARAMETERS_RULE_NAME]: _parameters.default,
      [_ruleNames.NODES_QUERY_RULE_NAME]: _nodesQuery.default,
      [_ruleNames.RETURN_BLOCK_RULE_NAME]: _returnBlock.default,
      [_ruleNames.LOGICAL_TERM_RULE_NAME]: _logical.default,
      [_ruleNames.NEGATED_TERM_RULE_NAME]: _negated.default,
      [_ruleNames.PROCEDURE_CALL_RULE_NAME]: _procedureCall.default,
      [_ruleNames.BRACKETED_TERM_RULE_NAME]: _bracketed.default,
      [_ruleNames.COMPARISON_TERM_RULE_NAME]: _comparison.default,
      [_ruleNames.NAMED_PARAMETER_RULE_NAME]: _named.default,
      [_ruleNames.NAMED_PARAMETERS_RULE_NAME]: _named1.default,
      [_ruleNames.RETURN_STATEMENT_RULE_NAME]: _return.default,
      [_ruleNames.ARRAY_ASSIGNMENT_RULE_NAME]: _array.default,
      [_ruleNames.OBJECT_ASSIGNMENT_RULE_NAME]: _object.default,
      [_ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME]: _anoymous.default,
      [_ruleNames.VARIABLE_ASSIGNMENT_RULE_NAME]: _variable1.default,
      [_ruleNames.VARIABLE_ASSIGNMENTS_RULE_NAME]: _variable2.default,
      [_ruleNames.PROCEDURE_DECLARATION_RULE_NAME]: _procedure.default
    };
    var _default = NonTerminalNodeMap;
  });

  // lib/furtle/parser.js
  var require_parser15 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleParser;
      }
    });
    var _occamlanguages = require_lib14();
    var _occamgrammars = require_lib11();
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap3());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FurtleParser = class extends _occamgrammars.FurtleParser {
    };
    __publicField(FurtleParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
    __publicField(FurtleParser, "defaultNonTerminalNode", _occamlanguages.NonTerminalNode);
  });

  // lib/utilities/element.js
  var require_element5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get aliasFromNamedParameterNode() {
        return aliasFromNamedParameterNode;
      },
      get anonymousProcedureFromAnonymousProcedureNode() {
        return anonymousProcedureFromAnonymousProcedureNode;
      },
      get anonymousProcedureFromEveryNode() {
        return anonymousProcedureFromEveryNode;
      },
      get anonymousProcedureFromReduceNode() {
        return anonymousProcedureFromReduceNode;
      },
      get anonymousProcedureFromSomeNode() {
        return anonymousProcedureFromSomeNode;
      },
      get arrayAssignmentFromArrayAssignmentNode() {
        return arrayAssignmentFromArrayAssignmentNode;
      },
      get arrayAssignmentFromStepNode() {
        return arrayAssignmentFromStepNode;
      },
      get bracketedTermFromBracketedTermNode() {
        return bracketedTermFromBracketedTermNode;
      },
      get bracketedTermFromTermNode() {
        return bracketedTermFromTermNode;
      },
      get comparisonTermFromComparisonTermNode() {
        return comparisonTermFromComparisonTermNode;
      },
      get comparisonTermFromTermNode() {
        return comparisonTermFromTermNode;
      },
      get disjunctionFromLogicalTermNode() {
        return disjunctionFromLogicalTermNode;
      },
      get elseExpressionFromTernaryNode() {
        return elseExpressionFromTernaryNode;
      },
      get errorFromErrorNode() {
        return errorFromErrorNode;
      },
      get everyFromEveryNode() {
        return everyFromEveryNode;
      },
      get everyFromExpressionNode() {
        return everyFromExpressionNode;
      },
      get expressionFromExpressionNode() {
        return expressionFromExpressionNode;
      },
      get expressionFromReduceNode() {
        return expressionFromReduceNode;
      },
      get expressionFromTypeAndVariableNode() {
        return expressionFromTypeAndVariableNode;
      },
      get expressionFromVariableAssignmentNode() {
        return expressionFromVariableAssignmentNode;
      },
      get expressionFromVariableNode() {
        return expressionFromVariableNode;
      },
      get ifExpressionFromTernaryNode() {
        return ifExpressionFromTernaryNode;
      },
      get initialExpressionFromReduceNode() {
        return initialExpressionFromReduceNode;
      },
      get labelFromLabelNode() {
        return labelFromLabelNode;
      },
      get labelFromProcedureDeclarationNode() {
        return labelFromProcedureDeclarationNode;
      },
      get leftTermFromCompzrisonTermNode() {
        return leftTermFromCompzrisonTermNode;
      },
      get leftTermFromLogicalTermNode() {
        return leftTermFromLogicalTermNode;
      },
      get logicalTermFromLogicalTermNode() {
        return logicalTermFromLogicalTermNode;
      },
      get logicalTermFromTermNode() {
        return logicalTermFromTermNode;
      },
      get nameFromLabelNode() {
        return nameFromLabelNode;
      },
      get nameFromNamedParameterNode() {
        return nameFromNamedParameterNode;
      },
      get nameFromParaneterNode() {
        return nameFromParaneterNode;
      },
      get nameFromReferenceNode() {
        return nameFromReferenceNode;
      },
      get nameFromVariableNode() {
        return nameFromVariableNode;
      },
      get namedParameterFromNamedParameterNode() {
        return namedParameterFromNamedParameterNode;
      },
      get namedParametersFromNamedParametersNode() {
        return namedParametersFromNamedParametersNode;
      },
      get namedParametersFromObjectAssignmentNode() {
        return namedParametersFromObjectAssignmentNode;
      },
      get namedParamtersArrayFromNamedParameterNodes() {
        return namedParamtersArrayFromNamedParameterNodes;
      },
      get negatedFromComparisonTermNode() {
        return negatedFromComparisonTermNode;
      },
      get negatedTermFromNegatedTermNode() {
        return negatedTermFromNegatedTermNode;
      },
      get negatedTermFromTermNode() {
        return negatedTermFromTermNode;
      },
      get nodeQueryFromExpressionNode() {
        return nodeQueryFromExpressionNode;
      },
      get nodeQueryFromNodeQueryNode() {
        return nodeQueryFromNodeQueryNode;
      },
      get nodesQueryFromExpressionNode() {
        return nodesQueryFromExpressionNode;
      },
      get nodesQueryFromNodesQueryNode() {
        return nodesQueryFromNodesQueryNode;
      },
      get nonsensicalFromReturnBlockNode() {
        return nonsensicalFromReturnBlockNode;
      },
      get objectAssignmentFromObjectAssignmentNode() {
        return objectAssignmentFromObjectAssignmentNode;
      },
      get objectAssignmentFromStepNode() {
        return objectAssignmentFromStepNode;
      },
      get parameterFromParameterNode() {
        return parameterFromParameterNode;
      },
      get parametersFromAnonymousProcedureNode() {
        return parametersFromAnonymousProcedureNode;
      },
      get parametersFromArrayAssignmentNode() {
        return parametersFromArrayAssignmentNode;
      },
      get parametersFromParametersNode() {
        return parametersFromParametersNode;
      },
      get parametersFromProcedureDeclarationNode() {
        return parametersFromProcedureDeclarationNode;
      },
      get paramtersArrayFromParametersNode() {
        return paramtersArrayFromParametersNode;
      },
      get primitiveFromPrimitiveNode() {
        return primitiveFromPrimitiveNode;
      },
      get primitiveFromTermNode() {
        return primitiveFromTermNode;
      },
      get procedureCallFromExpressionNode() {
        return procedureCallFromExpressionNode;
      },
      get procedureCallFromProcedureCallNode() {
        return procedureCallFromProcedureCallNode;
      },
      get procedureDeclarationFromProcedureDeclarationNode() {
        return procedureDeclarationFromProcedureDeclarationNode;
      },
      get procedureFromProcedureDeclarationNode() {
        return procedureFromProcedureDeclarationNode;
      },
      get queryFromNodeQueryNode() {
        return queryFromNodeQueryNode;
      },
      get queryFromNodesQueryNode() {
        return queryFromNodesQueryNode;
      },
      get reduceFromExpressionNode() {
        return reduceFromExpressionNode;
      },
      get reduceFromReduceNode() {
        return reduceFromReduceNode;
      },
      get referenceFromProcedureCallNode() {
        return referenceFromProcedureCallNode;
      },
      get referenceFromReferenceNode() {
        return referenceFromReferenceNode;
      },
      get returnBlockFromAnonymousProcedureNode() {
        return returnBlockFromAnonymousProcedureNode;
      },
      get returnBlockFromExpressionNode() {
        return returnBlockFromExpressionNode;
      },
      get returnBlockFromProcedureDeclarationNode() {
        return returnBlockFromProcedureDeclarationNode;
      },
      get returnBlockFromReturnBlockNode() {
        return returnBlockFromReturnBlockNode;
      },
      get returnStatementFromReturnBlockNode() {
        return returnStatementFromReturnBlockNode;
      },
      get returnStatementFromReturnStatementNode() {
        return returnStatementFromReturnStatementNode;
      },
      get rightTermFromCompzrisonTermNode() {
        return rightTermFromCompzrisonTermNode;
      },
      get rightTermFromLogicalTermNode() {
        return rightTermFromLogicalTermNode;
      },
      get someFromExpressionNode() {
        return someFromExpressionNode;
      },
      get someFromSomeNode() {
        return someFromSomeNode;
      },
      get stepFromStepNode() {
        return stepFromStepNode;
      },
      get stepsFromReturnBlockNode() {
        return stepsFromReturnBlockNode;
      },
      get termFromBracketedTermNode() {
        return termFromBracketedTermNode;
      },
      get termFromExpressionNode() {
        return termFromExpressionNode;
      },
      get termFromNegatedTermNode() {
        return termFromNegatedTermNode;
      },
      get termFromReturnStatementNode() {
        return termFromReturnStatementNode;
      },
      get termFromTermNode() {
        return termFromTermNode;
      },
      get termFromTernaryNode() {
        return termFromTernaryNode;
      },
      get termsArrayFromTermNodes() {
        return termsArrayFromTermNodes;
      },
      get termsFromProcedureCallNode() {
        return termsFromProcedureCallNode;
      },
      get termsFromTermsNode() {
        return termsFromTermsNode;
      },
      get ternaryFromExpressionNode() {
        return ternaryFromExpressionNode;
      },
      get ternaryFromTernaryNode() {
        return ternaryFromTernaryNode;
      },
      get typeFromLogicalTermNode() {
        return typeFromLogicalTermNode;
      },
      get typeFromNamedParameterNode() {
        return typeFromNamedParameterNode;
      },
      get typeFromNegatedTermNode() {
        return typeFromNegatedTermNode;
      },
      get typeFromParaneterNode() {
        return typeFromParaneterNode;
      },
      get typeFromPrimitiveNode() {
        return typeFromPrimitiveNode;
      },
      get typeFromProcedureAnonymousProcedureNode() {
        return typeFromProcedureAnonymousProcedureNode;
      },
      get typeFromProcedureDeclarationNode() {
        return typeFromProcedureDeclarationNode;
      },
      get typeFromVariableAssignmentsNode() {
        return typeFromVariableAssignmentsNode;
      },
      get typeFromVariableNode() {
        return typeFromVariableNode;
      },
      get valueFromPrimitiveNode() {
        return valueFromPrimitiveNode;
      },
      get variableAssignmentFromTypeAndVariableAssignmentNode() {
        return variableAssignmentFromTypeAndVariableAssignmentNode;
      },
      get variableAssignmentsArrayFromTypeAndVariableAssignmentsNode() {
        return variableAssignmentsArrayFromTypeAndVariableAssignmentsNode;
      },
      get variableAssignmentsFromStepNode() {
        return variableAssignmentsFromStepNode;
      },
      get variableAssignmentsFromVariableAssignmentsNode() {
        return variableAssignmentsFromVariableAssignmentsNode;
      },
      get variableFromArrayAssignmentNode() {
        return variableFromArrayAssignmentNode;
      },
      get variableFromEveryNode() {
        return variableFromEveryNode;
      },
      get variableFromNodeQueryNode() {
        return variableFromNodeQueryNode;
      },
      get variableFromNodesQueryNode() {
        return variableFromNodesQueryNode;
      },
      get variableFromObjectAssignmentNode() {
        return variableFromObjectAssignmentNode;
      },
      get variableFromReduceNode() {
        return variableFromReduceNode;
      },
      get variableFromSomeNode() {
        return variableFromSomeNode;
      },
      get variableFromTermNode() {
        return variableFromTermNode;
      },
      get variableFromTypeAndVariableAssignmentNode() {
        return variableFromTypeAndVariableAssignmentNode;
      },
      get variableFromTypeAndVariableNode() {
        return variableFromTypeAndVariableNode;
      },
      get variableFromVariableNode() {
        return variableFromVariableNode;
      }
    });
    var _occamquery = require_lib5();
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _types = require_types3();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function stepFromStepNode(stepNode, context2) {
      const {Step} = _elements.default, node = stepNode, string = context2.nodeAsString(node), arrayAssignment = arrayAssignmentFromStepNode(stepNode, context2), objectAssigment = objectAssignmentFromStepNode(stepNode, context2), variablesDeclaration = variableAssignmentsFromStepNode(stepNode, context2);
      context2 = null;
      const step = new Step(context2, string, node, arrayAssignment, objectAssigment, variablesDeclaration);
      return step;
    }
    function someFromSomeNode(someNode, context2) {
      const {Some} = _elements.default, node = someNode, variable = variableFromSomeNode(someNode, context2), anonymousProcedure = anonymousProcedureFromSomeNode(someNode, context2), someString = (0, _string.someStringFromVariableAndAnonymousProcedure)(variable, anonymousProcedure), string = someString;
      context2 = null;
      const some = new Some(context2, string, node, variable, anonymousProcedure);
      return some;
    }
    function termFromTermNode(termNode, context2) {
      const {Term} = _elements.default, node = termNode, variable = variableFromTermNode(termNode, context2), primitive = primitiveFromTermNode(termNode, context2), negatedTerm = negatedTermFromTermNode(termNode, context2), logicalTerm = logicalTermFromTermNode(termNode, context2), bracketedTerm = bracketedTermFromTermNode(termNode, context2), comparisonTerm = comparisonTermFromTermNode(termNode, context2), properties = [
        variable,
        primitive,
        negatedTerm,
        logicalTerm,
        bracketedTerm,
        comparisonTerm
      ], termString = (0, _string.termStringFromProperties)(properties, context2), string = termString;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm);
      return term;
    }
    function termsFromTermsNode(termsNode, context2) {
      const {Terms} = _elements.default, node = termsNode, string = context2.nodeAsString(node), termNodes = termsNode.getTermNodes(), termsArray = termsArrayFromTermNodes(termNodes, context2), array = termsArray;
      context2 = null;
      const terms = new Terms(context2, string, node, array);
      return terms;
    }
    function errorFromErrorNode(errorNode, context2) {
      const {Error: Error2} = _elements.default, node = errorNode, string = context2.nodeAsString(node);
      context2 = null;
      const error = new Error2(context2, string, node);
      return error;
    }
    function everyFromEveryNode(everyNode, context2) {
      const {Every} = _elements.default, node = everyNode, variable = variableFromEveryNode(everyNode, context2), anonymousProcedure = anonymousProcedureFromEveryNode(everyNode, context2), everyString = (0, _string.everyStringFromVariableAndAnonymousProcedure)(variable, anonymousProcedure), string = everyString;
      context2 = null;
      const every = new Every(context2, string, node, variable, anonymousProcedure);
      return every;
    }
    function labelFromLabelNode(labelNode, context2) {
      const {Label} = _elements.default, node = labelNode, string = context2.nodeAsString(node), name = nameFromLabelNode(labelNode, context2);
      context2 = null;
      const label = new Label(context2, string, node, name);
      return label;
    }
    function reduceFromReduceNode(reduceNode, context2) {
      const {Reduce} = _elements.default, node = reduceNode, variable = variableFromReduceNode(reduceNode, context2), initialExpression = initialExpressionFromReduceNode(reduceNode, context2), anonymousProcedure = anonymousProcedureFromReduceNode(reduceNode, context2), reduceString = (0, _string.reduceStringFromVariableInitialExpressionAndAnonymousProcedure)(variable, initialExpression, anonymousProcedure), string = reduceString;
      context2 = null;
      const reduce = new Reduce(context2, string, node, variable, initialExpression, anonymousProcedure);
      return reduce;
    }
    function ternaryFromTernaryNode(ternaryNode, context2) {
      const {Ternary} = _elements.default, node = ternaryNode, term = termFromTernaryNode(ternaryNode, context2), ifExpression = ifExpressionFromTernaryNode(ternaryNode, context2), elseExpression = elseExpressionFromTernaryNode(ternaryNode, context2), ternaryString = (0, _string.ternaryStringFromTerm)(term), string = ternaryString;
      context2 = null;
      const ternary = new Ternary(context2, string, node, term, ifExpression, elseExpression);
      return ternary;
    }
    function variableFromVariableNode(variableNode, context2) {
      const {Variable} = _elements.default, node = variableNode, string = context2.nodeAsString(node), type = typeFromVariableNode(variableNode, context2), name = nameFromVariableNode(variableNode, context2), expression = expressionFromVariableNode(variableNode, context2);
      context2 = null;
      const variable = new Variable(context2, string, node, type, name, expression);
      return variable;
    }
    function referenceFromReferenceNode(referenceNode, context2) {
      const {Reference} = _elements.default, node = referenceNode, string = context2.nodeAsString(node), name = nameFromReferenceNode(referenceNode, context2);
      context2 = null;
      const reference = new Reference(context2, string, node, name);
      return reference;
    }
    function parameterFromParameterNode(parameterNode, context2) {
      let parameter = null;
      const type = typeFromParaneterNode(parameterNode, context2);
      if (type !== null) {
        const {Parameter} = _elements.default, node = parameterNode, string = context2.nodeAsString(node), name = nameFromParaneterNode(parameterNode, context2);
        context2 = null;
        parameter = new Parameter(context2, string, node, type, name);
      }
      return parameter;
    }
    function nodeQueryFromNodeQueryNode(nodeQueryNode, context2) {
      const {NodeQuery} = _elements.default, node = nodeQueryNode, string = context2.nodeAsString(node), variable = variableFromNodeQueryNode(nodeQueryNode, context2), query = queryFromNodeQueryNode(nodeQueryNode, context2);
      context2 = null;
      const nodeQuery = new NodeQuery(context2, string, node, variable, query);
      return nodeQuery;
    }
    function primitiveFromPrimitiveNode(primitiveNode, context2) {
      const {Primitive} = _elements.default, node = primitiveNode, string = context2.nodeAsString(node), type = typeFromPrimitiveNode(primitiveNode, context2), value = valueFromPrimitiveNode(primitiveNode, context2);
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function nodesQueryFromNodesQueryNode(nodesQueryNode, context2) {
      const {NodesQuery} = _elements.default, node = nodesQueryNode, string = context2.nodeAsString(node), variable = variableFromNodesQueryNode(nodesQueryNode, context2), query = queryFromNodesQueryNode(nodesQueryNode, context2);
      context2 = null;
      const nodesQuery = new NodesQuery(context2, string, node, variable, query);
      return nodesQuery;
    }
    function parametersFromParametersNode(parametersNode, context2) {
      const {Parameters} = _elements.default, node = parametersNode, string = context2.nodeAsString(node), paramtersArray = paramtersArrayFromParametersNode(parametersNode, context2), array = paramtersArray;
      context2 = null;
      const parameters = new Parameters(context2, string, node, array);
      return parameters;
    }
    function expressionFromExpressionNode(expressionNode, context2) {
      const {Expression} = _elements.default, node = expressionNode, term = termFromExpressionNode(expressionNode, context2), some = someFromExpressionNode(expressionNode, context2), every = everyFromExpressionNode(expressionNode, context2), reduce = reduceFromExpressionNode(expressionNode, context2), ternary = ternaryFromExpressionNode(expressionNode, context2), nodeQuery = nodeQueryFromExpressionNode(expressionNode, context2), nodesQuery = nodesQueryFromExpressionNode(expressionNode, context2), returnBlock = returnBlockFromExpressionNode(expressionNode, context2), procedureCall = procedureCallFromExpressionNode(expressionNode, context2), properties = [
        term,
        some,
        every,
        reduce,
        ternary,
        nodeQuery,
        nodesQuery,
        returnBlock,
        procedureCall
      ], expressionString = (0, _string.expressionStringFromProperties)(properties, context2), string = expressionString;
      context2 = null;
      const expression = new Expression(context2, string, node, term, some, every, reduce, ternary, nodeQuery, nodesQuery, returnBlock, procedureCall);
      return expression;
    }
    function returnBlockFromReturnBlockNode(returnBlockNode, context2) {
      const {ReturnBlock} = _elements.default, node = returnBlockNode, steps = stepsFromReturnBlockNode(returnBlockNode, context2), nonsensical = nonsensicalFromReturnBlockNode(returnBlockNode, context2), returnStatement = returnStatementFromReturnBlockNode(returnBlockNode, context2), returnBlockString = (0, _string.returnBlockStringFromReturnStatementNode)(returnStatement), string = returnBlockString;
      context2 = null;
      const returnBlock = new ReturnBlock(context2, string, node, steps, nonsensical, returnStatement);
      return returnBlock;
    }
    function procedureCallFromProcedureCallNode(procedureCallNode, context2) {
      const {ProcedureCall} = _elements.default, node = procedureCallNode, string = context2.nodeAsString(node), reference = referenceFromProcedureCallNode(procedureCallNode, context2), terms = termsFromProcedureCallNode(procedureCallNode, context2);
      context2 = null;
      const procedureCall = new ProcedureCall(context2, string, node, reference, terms);
      return procedureCall;
    }
    function namedParameterFromNamedParameterNode(namedParameterNode, context2) {
      const {NamedParameter} = _elements.default, node = namedParameterNode, string = context2.nodeAsString(node), type = typeFromNamedParameterNode(namedParameterNode, context2), name = nameFromNamedParameterNode(namedParameterNode, context2), alias = aliasFromNamedParameterNode(namedParameterNode, context2);
      context2 = null;
      const namedParameter = new NamedParameter(context2, string, node, type, name, alias);
      return namedParameter;
    }
    function namedParametersFromNamedParametersNode(namedParametersNode, context2) {
      const {NamedParameters} = _elements.default, node = namedParametersNode, string = context2.nodeAsString(node), namedParameterNodes = namedParametersNode.getNamedParameterNodes(), namedParametersArray = namedParamtersArrayFromNamedParameterNodes(namedParameterNodes, context2), array = namedParametersArray;
      context2 = null;
      const namedParameters = new NamedParameters(context2, string, node, array);
      return namedParameters;
    }
    function arrayAssignmentFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const {ArrayAssignment} = _elements.default, node = arrayAssignmentNode, string = context2.nodeAsString(node), variable = variableFromArrayAssignmentNode(arrayAssignmentNode, context2), parameters = parametersFromArrayAssignmentNode(arrayAssignmentNode, context2);
      context2 = null;
      const arrayAssignment = new ArrayAssignment(context2, string, node, variable, parameters);
      return arrayAssignment;
    }
    function returnStatementFromReturnStatementNode(returnStatementNode, context2) {
      const {ReturnStatement} = _elements.default, node = returnStatementNode, string = context2.nodeAsString(node), term = termFromReturnStatementNode(returnStatementNode, context2);
      context2 = null;
      const returnStatement = new ReturnStatement(context2, string, node, term);
      return returnStatement;
    }
    function namedParametersFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const namedParametersNode = objectAssignmentNode.getNamedParametersNode(), namedParameters = namedParametersFromNamedParametersNode(namedParametersNode, context2);
      return namedParameters;
    }
    function objectAssignmentFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const {ObjectAssigment} = _elements.default, node = objectAssignmentNode, string = context2.nodeAsString(node), variable = variableFromObjectAssignmentNode(objectAssignmentNode, context2), namedParameters = namedParametersFromObjectAssignmentNode(objectAssignmentNode, context2);
      context2 = null;
      const objectAssignment = new ObjectAssigment(context2, string, node, variable, namedParameters);
      return objectAssignment;
    }
    function anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const {AnonymousProcedure} = _elements.default, node = anonymousProcedureNode, type = typeFromProcedureAnonymousProcedureNode(anonymousProcedureNode, context2), parameters = parametersFromAnonymousProcedureNode(anonymousProcedureNode, context2), returnBlock = returnBlockFromAnonymousProcedureNode(anonymousProcedureNode, context2), nonymousProcedureString = (0, _string.anonymousProcedureStringFromTypeParametersAndReturnBlock)(type, parameters, returnBlock), string = nonymousProcedureString;
      context2 = null;
      const anonymousProcedure = new AnonymousProcedure(context2, string, node, type, parameters, returnBlock);
      return anonymousProcedure;
    }
    function variableAssignmentsFromVariableAssignmentsNode(variableAssignmentsNode, context2) {
      const {VariableAssignments} = _elements.default, node = variableAssignmentsNode, type = typeFromVariableAssignmentsNode(variableAssignmentsNode, context2), variableAssignmentsArray = variableAssignmentsArrayFromTypeAndVariableAssignmentsNode(type, variableAssignmentsNode, context2), variableAssignmentString = (0, _string.variableAssignmentStringFromTypeAndVariableAssignmentsArray)(type, variableAssignmentsArray), array = variableAssignmentsArray, string = variableAssignmentString;
      context2 = null;
      const variableAssignments = new VariableAssignments(context2, string, node, array);
      return variableAssignments;
    }
    function procedureDeclarationFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const {ProcedureDeclaration} = _elements.default, node = procedureDeclarationNode, procedure = procedureFromProcedureDeclarationNode(procedureDeclarationNode, context2), procedureDeclarationString = (0, _string.procedureDeclarationStringFromProcedure)(procedure), string = procedureDeclarationString;
      context2 = null;
      const procedureDeclaration = new ProcedureDeclaration(context2, string, node, procedure);
      return procedureDeclaration;
    }
    function nameFromLabelNode(labelNode, context2) {
      const name = labelNode.getName();
      return name;
    }
    function termFromTernaryNode(ternaryNode, context2) {
      const termNode = ternaryNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function variableFromSomeNode(someNode, context2) {
      const variableNode = someNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function variableFromTermNode(termNode, context2) {
      let variable = null;
      const variableNode = termNode.getVariableNode();
      if (variableNode !== null) {
        variable = variableFromVariableNode(variableNode, context2);
      }
      return variable;
    }
    function nameFromVariableNode(variableNode) {
      const name = variableNode.getName();
      return name;
    }
    function typeFromVariableNode(variableNode, context2) {
      const type = null;
      return type;
    }
    function primitiveFromTermNode(termNode, context2) {
      let primitive = null;
      const primitiveNode = termNode.getPrimitiveNode();
      if (primitiveNode !== null) {
        primitive = primitiveFromPrimitiveNode(primitiveNode, context2);
      }
      return primitive;
    }
    function variableFromEveryNode(everyNode, context2) {
      const variableNode = everyNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromParaneterNode(parameterNode, context2) {
      const type = parameterNode.getType();
      return type;
    }
    function nameFromParaneterNode(parameterNode, context2) {
      const name = parameterNode.getName();
      return name;
    }
    function nameFromReferenceNode(referenceNode, context2) {
      const name = referenceNode.getName();
      return name;
    }
    function typeFromPrimitiveNode(primitiveNode, context2) {
      const type = primitiveNode.getType();
      return type;
    }
    function variableFromReduceNode(reduceNode, context2) {
      const variableNode = reduceNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function termFromExpressionNode(expressionNode, context2) {
      let term = null;
      const termNode = expressionNode.getTermNode();
      if (termNode !== null) {
        term = termFromTermNode(termNode, context2);
      }
      return term;
    }
    function someFromExpressionNode(expressionNode, context2) {
      let some = null;
      const someNode = expressionNode.getSomeNode();
      if (someNode !== null) {
        some = someFromSomeNode(someNode, context2);
      }
      return some;
    }
    function queryFromNodeQueryNode(nodeQueryNode, context2) {
      const string = nodeQueryNode.getString(), expressionString = string, query = _occamquery.Query.fromExpressionString(expressionString);
      return query;
    }
    function valueFromPrimitiveNode(primitiveNode, context2) {
      const value = primitiveNode.getValue();
      return value;
    }
    function queryFromNodesQueryNode(nodesQueryNode, context2) {
      const string = nodesQueryNode.getString(), expressionString = string, query = _occamquery.Query.fromExpressionString(expressionString);
      return query;
    }
    function everyFromExpressionNode(expressionNode, context2) {
      let every = null;
      const everyNode = expressionNode.getEveryNode();
      if (everyNode !== null) {
        every = everyFromEveryNode(everyNode, context2);
      }
      return every;
    }
    function negatedTermFromTermNode(termNode, context2) {
      let negatedTerm = null;
      const negatedTermNode = termNode.getNegatedTermNode();
      if (negatedTermNode !== null) {
        negatedTerm = negatedTermFromNegatedTermNode(negatedTermNode, context2);
      }
      return negatedTerm;
    }
    function logicalTermFromTermNode(termNode, context2) {
      let logicalTerm = null;
      const logicalTermNode = termNode.getLogicalTermNode();
      if (logicalTermNode !== null) {
        logicalTerm = logicalTermFromLogicalTermNode(logicalTermNode, context2);
      }
      return logicalTerm;
    }
    function typeFromLogicalTermNode(logicalTermNode, context2) {
      const type = _types.BOOLEAN_TYPE;
      return type;
    }
    function typeFromNegatedTermNode(logicalTermNode, context2) {
      const type = _types.BOOLEAN_TYPE;
      return type;
    }
    function termFromNegatedTermNode(negatedTermNode, context2) {
      const termNode = negatedTermNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function expressionFromReduceNode(reduceNode, context2) {
      const expressionNode = reduceNode.getExpressionNode(), expression = expressionFromExpressionNode(expressionNode, context2);
      return expression;
    }
    function reduceFromExpressionNode(expressionNode, context2) {
      let reduce = null;
      const reduceNode = expressionNode.getReduceNode();
      if (reduceNode !== null) {
        reduce = reduceFromReduceNode(reduceNode, context2);
      }
      return reduce;
    }
    function stepsFromReturnBlockNode(returnBlockNode, context2) {
      const stepNodes = returnBlockNode.getStepNodes(), steps = stepNodes.map((stepNode) => {
        const step = stepFromStepNode(stepNode, context2);
        return step;
      });
      return steps;
    }
    function variableFromNodeQueryNode(nodeQueryNode, context2) {
      const variableNode = nodeQueryNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function ternaryFromExpressionNode(expressionNode, context2) {
      let ternary = null;
      const ternaryNode = expressionNode.getTernaryNode();
      if (ternaryNode !== null) {
        ternary = ternaryFromTernaryNode(ternaryNode, context2);
      }
      return ternary;
    }
    function bracketedTermFromTermNode(termNode, context2) {
      let bracketedTerm = null;
      const bracketedTermNode = termNode.getBracketedTermNode();
      if (bracketedTermNode !== null) {
        bracketedTerm = bracketedTermFromBracketedTermNode(bracketedTermNode, context2);
      }
      return bracketedTerm;
    }
    function termFromBracketedTermNode(bracketedTermNode, context2) {
      const termNode = bracketedTermNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function comparisonTermFromTermNode(termNOde, context2) {
      let comparisonTerm = null;
      const comparisonTermNode = termNOde.getComparisonTermNode();
      if (comparisonTermNode !== null) {
        comparisonTerm = comparisonTermFromComparisonTermNode(comparisonTermNode, context2);
      }
      return comparisonTerm;
    }
    function expressionFromVariableNode(variableNode, context2) {
      const expression = null;
      return expression;
    }
    function variableFromNodesQueryNode(nodesQueryNode, context2) {
      const variableNode = nodesQueryNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function termsFromProcedureCallNode(procedureCallNode, context2) {
      const termsNode = procedureCallNode.getTermsNode(), terms = termsFromTermsNode(termsNode, context2);
      return terms;
    }
    function typeFromNamedParameterNode(namedParameterNode, context2) {
      const type = namedParameterNode.getType();
      return type;
    }
    function nameFromNamedParameterNode(namedParameterNode, context2) {
      const name = namedParameterNode.getName();
      return name;
    }
    function leftTermFromLogicalTermNode(logicalTermNode, context2) {
      const leftTermNode = logicalTermNode.getLeftTermNode(), leftTerm = termFromTermNode(leftTermNode, context2);
      return leftTerm;
    }
    function arrayAssignmentFromStepNode(stepNode, context2) {
      let arrayAssignment = null;
      const arrayAssignmentNode = stepNode.getArrayAssignmentNode();
      if (arrayAssignmentNode !== null) {
        arrayAssignment = arrayAssignmentFromArrayAssignmentNode(arrayAssignmentNode, context2);
      }
      return arrayAssignment;
    }
    function ifExpressionFromTernaryNode(ternaryNode, context2) {
      const ifExpressionNode = ternaryNode.getIfExpressionNode(), ifExpression = expressionFromExpressionNode(ifExpressionNode, context2);
      return ifExpression;
    }
    function nodeQueryFromExpressionNode(expressionNode, context2) {
      let nodeQuery = null;
      const nodeQueryNode = expressionNode.getNodeQueryNode();
      if (nodeQueryNode !== null) {
        nodeQuery = nodeQueryFromNodeQueryNode(nodeQueryNode, context2);
      }
      return nodeQuery;
    }
    function aliasFromNamedParameterNode(namedParameterNode, context2) {
      const alias = namedParameterNode.getAlias();
      return alias;
    }
    function termFromReturnStatementNode(returnStatementNode, context2) {
      const termNode = returnStatementNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function objectAssignmentFromStepNode(stepNode, context2) {
      let objectAssignment = null;
      const objectAssignmentNode = stepNode.getObjectAssignmentNode();
      if (objectAssignmentNode !== null) {
        objectAssignment = objectAssignmentFromObjectAssignmentNode(objectAssignmentNode, context2);
      }
      return objectAssignment;
    }
    function nodesQueryFromExpressionNode(expressionNode, context2) {
      let nodesQuery = null;
      const nodesQueryNode = expressionNode.getNodesQueryNode();
      if (nodesQueryNode !== null) {
        nodesQuery = nodesQueryFromNodesQueryNode(nodesQueryNode, context2);
      }
      return nodesQuery;
    }
    function rightTermFromLogicalTermNode(logicalTermNode, context2) {
      const rightTermNode = logicalTermNode.getRightTermNode(), rightTerm = termFromTermNode(rightTermNode, context2);
      return rightTerm;
    }
    function negatedFromComparisonTermNode(comparisonTermNode, context2) {
      const negated = comparisonTermNode.isNegated();
      return negated;
    }
    function elseExpressionFromTernaryNode(ternaryNode, context2) {
      const elseExpressionNode = ternaryNode.getElseExpressionNode(), elseExpression = expressionFromExpressionNode(elseExpressionNode, context2);
      return elseExpression;
    }
    function returnBlockFromExpressionNode(expressionNode, context2) {
      let returnBlock = null;
      const returnBlockNode = expressionNode.getReturnBlockNode();
      if (returnBlockNode !== null) {
        returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      }
      return returnBlock;
    }
    function anonymousProcedureFromSomeNode(someNode, context2) {
      const anonymousProcedureNode = someNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function nonsensicalFromReturnBlockNode(returnBlockNode, context2) {
      const nonsensical = returnBlockNode.isNonsensical();
      return nonsensical;
    }
    function referenceFromProcedureCallNode(procedureCallNode, context2) {
      const referenceNode = procedureCallNode.getReferenceNode(), reference = referenceFromReferenceNode(referenceNode, context2);
      return reference;
    }
    function leftTermFromCompzrisonTermNode(comparisonTermNode, context2) {
      const leftTermNode = comparisonTermNode.getLeftTermNode(), leftTerm = termFromTermNode(leftTermNode, context2);
      return leftTerm;
    }
    function disjunctionFromLogicalTermNode(logicalTermNode, context2) {
      const disjunction = logicalTermNode.isDisjunction();
      return disjunction;
    }
    function negatedTermFromNegatedTermNode(negatedTermNode, context2) {
      const {NegatedTerm} = _elements.default, node = negatedTermNode, string = context2.nodeAsString(node), termNode = negatedTermNode.getTermNode(), type = typeFromNegatedTermNode(termNode, context2), term = termFromNegatedTermNode(negatedTermNode, context2), negatedTerm = new NegatedTerm(context2, string, node, type, term);
      return negatedTerm;
    }
    function logicalTermFromLogicalTermNode(logicalTermNode, context2) {
      const {LogicalTerm} = _elements.default, node = logicalTermNode, string = context2.nodeAsString(node), type = typeFromLogicalTermNode(logicalTermNode, context2), disjunction = disjunctionFromLogicalTermNode(logicalTermNode, context2), leftTerm = leftTermFromLogicalTermNode(logicalTermNode, context2), rightTerm = rightTermFromLogicalTermNode(logicalTermNode, context2), logicalTerm = new LogicalTerm(context2, string, node, type, disjunction, leftTerm, rightTerm);
      return logicalTerm;
    }
    function variableFromTypeAndVariableNode(type, variableNode, context2) {
      const {Variable} = _elements.default, node = variableNode, name = nameFromVariableNode(variableNode), expression = expressionFromTypeAndVariableNode(type, variableNode, context2), variableString = (0, _string.variableStringFromName)(name), string = variableString, variable = new Variable(context2, string, node, type, name, expression);
      return variable;
    }
    function variableAssignmentsFromStepNode(stepNode, context2) {
      let variableAssignments = null;
      const variableAssignmentsNode = stepNode.getVariableAssignmentsNode();
      if (variableAssignmentsNode !== null) {
        variableAssignments = variableAssignmentsFromVariableAssignmentsNode(variableAssignmentsNode, context2);
      }
      return variableAssignments;
    }
    function anonymousProcedureFromEveryNode(everyNode, context2) {
      const anonymousProcedureNode = everyNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function initialExpressionFromReduceNode(reduceNode, context2) {
      const expression = expressionFromReduceNode(reduceNode, context2), initialExpression = expression;
      return initialExpression;
    }
    function procedureCallFromExpressionNode(expressionNode, context2) {
      let procedureCall = null;
      const procedureCallNode = expressionNode.getProcedureCallNode();
      if (procedureCallNode !== null) {
        procedureCall = procedureCallFromProcedureCallNode(procedureCallNode, context2);
      }
      return procedureCall;
    }
    function rightTermFromCompzrisonTermNode(comparisonTermNode, context2) {
      const rightTermNode = comparisonTermNode.getRightTermNode(), rightTerm = termFromTermNode(rightTermNode, context2);
      return rightTerm;
    }
    function variableFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const variableNode = arrayAssignmentNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromVariableAssignmentsNode(variableAssignmentsNode, context2) {
      const type = variableAssignmentsNode.getType();
      return type;
    }
    function anonymousProcedureFromReduceNode(reduceNode, context2) {
      const anonymousProcedureNode = reduceNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function variableFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const variableNode = objectAssignmentNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const type = procedureDeclarationNode.getType();
      return type;
    }
    function expressionFromTypeAndVariableNode(type, variableNode, context2) {
      const expression = null;
      return expression;
    }
    function parametersFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const parametersNode = arrayAssignmentNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function labelFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const labelNode = procedureDeclarationNode.getLabelNode(), label = labelFromLabelNode(labelNode, context2);
      return label;
    }
    function returnStatementFromReturnBlockNode(returnBlockNode, context2) {
      const returnStatementNode = returnBlockNode.getReturnStatementNode(), returnStatement = returnStatementFromReturnStatementNode(returnStatementNode, context2);
      return returnStatement;
    }
    function bracketedTermFromBracketedTermNode(bracketedTermNode, context2) {
      const {BracketedTerm} = _elements.default, node = bracketedTermNode, string = context2.nodeAsString(node), term = termFromBracketedTermNode(bracketedTermNode, context2), bracketedTerm = new BracketedTerm(context2, string, node, term);
      return bracketedTerm;
    }
    function expressionFromVariableAssignmentNode(variableAssigmentNode, context2) {
      const expressionNode = variableAssigmentNode.getExpressionNode(), expression = expressionFromExpressionNode(expressionNode, context2);
      return expression;
    }
    function parametersFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const parametersNode = anonymousProcedureNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function comparisonTermFromComparisonTermNode(comparisonTermNode, context2) {
      const {ComparisonTerm} = _elements.default, node = comparisonTermNode, string = context2.nodeAsString(node), negated = negatedFromComparisonTermNode(comparisonTermNode, context2), leftTerm = leftTermFromCompzrisonTermNode(comparisonTermNode, context2), rightTerm = rightTermFromCompzrisonTermNode(comparisonTermNode, context2), comparisonTerm = new ComparisonTerm(context2, string, node, negated, leftTerm, rightTerm);
      return comparisonTerm;
    }
    function returnBlockFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const returnBlockNode = anonymousProcedureNode.getReturnBlockNode(), returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      return returnBlock;
    }
    function procedureFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const {Procedure} = _elements.default, node = procedureDeclarationNode, type = typeFromProcedureDeclarationNode(procedureDeclarationNode, context2), label = labelFromProcedureDeclarationNode(procedureDeclarationNode, context2), parameters = parametersFromProcedureDeclarationNode(procedureDeclarationNode, context2), returnBlock = returnBlockFromProcedureDeclarationNode(procedureDeclarationNode, context2), procedureString = (0, _string.procedureStringFromTypeLabelParametersAndReturnBlock)(type, label, parameters, returnBlock), string = procedureString, procedure = new Procedure(context2, string, node, type, label, parameters, returnBlock);
      return procedure;
    }
    function parametersFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const parametersNode = procedureDeclarationNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function typeFromProcedureAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const type = anonymousProcedureNode.getType();
      return type;
    }
    function returnBlockFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const returnBlockNode = procedureDeclarationNode.getReturnBlockNode(), returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      return returnBlock;
    }
    function variableFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2) {
      const variableNode = variableAssignmentNode.getVariableNode(), variable = variableFromTypeAndVariableNode(type, variableNode, context2);
      return variable;
    }
    function variableAssignmentFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2) {
      const {VariableAssignment} = _elements.default, node = variableAssignmentNode, variable = variableFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2), expression = expressionFromVariableAssignmentNode(variableAssignmentNode, context2), variableAssignmentString = (0, _string.variableAssignmentStringFromTypeAndVariable)(type, variable, context2), string = variableAssignmentString, assignment = new VariableAssignment(context2, string, node, variable, expression);
      return assignment;
    }
    function termsArrayFromTermNodes(termNodes, context2) {
      const termsArray = termNodes.map((termNode) => {
        const term = termFromTermNode(termNode, context2);
        return term;
      });
      return termsArray;
    }
    function paramtersArrayFromParametersNode(parametersNode, context2) {
      const parameterNodes = parametersNode.getParameterNodes(), paramtersArray = parameterNodes.map((parameterNode) => {
        const parameter = parameterFromParameterNode(parameterNode, context2);
        return parameter;
      });
      return paramtersArray;
    }
    function namedParamtersArrayFromNamedParameterNodes(namedParameterNodes, context2) {
      const namedParamtersArray = namedParameterNodes.map((namedParameterNode) => {
        const namedParameter = namedParameterFromNamedParameterNode(namedParameterNode, context2);
        return namedParameter;
      });
      return namedParamtersArray;
    }
    function variableAssignmentsArrayFromTypeAndVariableAssignmentsNode(type, variableAssignmentsNode, context2) {
      const variableAssignmentNodes = variableAssignmentsNode.getVariableAssignmentNodes(), variableAssignmentsArray = variableAssignmentNodes.map((variableAssignmentNode) => {
        const variableAssignment = variableAssignmentFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2);
        return variableAssignment;
      });
      return variableAssignmentsArray;
    }
  });

  // lib/process/verify.js
  var require_verify2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "verifyFile", {
      enumerable: true,
      get: function() {
        return verifyFile;
      }
    });
    var _occamlanguages = require_lib14();
    var _element = require_element5();
    var {nodeQuery} = _occamlanguages.queryUtilities;
    var errorNodeQuery = nodeQuery("/error");
    var procedureDeclarationNodeQuery = nodeQuery("/procedureDeclaration");
    var TopLevelPass = class extends _occamlanguages.SimplePass {
    };
    __publicField(TopLevelPass, "maps", [
      {
        nodeQuery: errorNodeQuery,
        run: (errorNode, context2) => {
          let success = false;
          const error = (0, _element.errorFromErrorNode)(errorNode, context2), errorVerifies = error.verify(context2);
          if (errorVerifies) {
            success = true;
          }
          return success;
        }
      },
      {
        nodeQuery: procedureDeclarationNodeQuery,
        run: (procedureDeclarationNode, context2) => {
          let success = false;
          const procedureDeclaration = (0, _element.procedureDeclarationFromProcedureDeclarationNode)(procedureDeclarationNode, context2), procedureDeclarationVerifies = procedureDeclaration.verify(context2);
          if (procedureDeclarationVerifies) {
            success = true;
          }
          return success;
        }
      }
    ]);
    var topLevelPass = new TopLevelPass();
    function verifyFile(fileNode, context2) {
      let fileVerifies = false;
      const node = fileNode, sucess = topLevelPass.run(node, context2);
      if (sucess) {
        fileVerifies = true;
      }
      return fileVerifies;
    }
  });

  // lib/utilities/lexers.js
  var require_lexers2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get furtleLexerFromEntries() {
        return furtleLexerFromEntries;
      },
      get furtleLexerFromNothing() {
        return furtleLexerFromNothing;
      }
    });
    var _occamlexers = require_lib3();
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {lexerFromRules, rulesFromEntries} = _occamlexers.lexerUtilities;
    function furtleLexerFromNothing(Class) {
      if (Class === void 0) {
        Class = _lexer.default;
      }
      const {entries} = _lexer.default;
      let rules;
      rules = rulesFromEntries(entries);
      const furtleLexer = lexerFromRules(Class, rules);
      return furtleLexer;
    }
    function furtleLexerFromEntries(Class, entries) {
      if (entries === void 0) {
        entries = Class;
        Class = _lexer.default;
      }
      let rules;
      rules = rulesFromEntries(entries);
      const furtleLexer = lexerFromRules(Class, rules);
      return furtleLexer;
    }
    var _default = {
      furtleLexerFromEntries,
      furtleLexerFromNothing
    };
  });

  // lib/utilities/parsers.js
  var require_parsers2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get furtleParserFromBNF() {
        return furtleParserFromBNF;
      },
      get furtleParserFromBNFAndStartRuleName() {
        return furtleParserFromBNFAndStartRuleName;
      },
      get furtleParserFromNothing() {
        return furtleParserFromNothing;
      }
    });
    var _occamparsers = require_lib4();
    var _occamgrammarutilities = require_lib10();
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {rulesFromBNF, parserFromRules, parserFromRulesAndStartRuleName} = _occamparsers.parserUtilities;
    function furtleParserFromBNF(Class, bnf) {
      if (bnf === void 0) {
        bnf = Class;
        Class = _parser.default;
      }
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRules(Class, rules);
      return furtleParser;
    }
    function furtleParserFromNothing(Class) {
      if (Class === void 0) {
        Class = _parser.default;
      }
      const {bnf} = _parser.default;
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRules(Class, rules);
      return furtleParser;
    }
    function furtleParserFromBNFAndStartRuleName(Class, bnf, startRuleName) {
      if (startRuleName === void 0) {
        startRuleName = bnf;
        bnf = Class;
        Class = _parser.default;
      }
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return furtleParser;
    }
    var _default = {
      furtleParserFromBNF,
      furtleParserFromNothing,
      furtleParserFromBNFAndStartRuleName
    };
  });

  // lib/utilities/furtle.js
  var require_furtle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get furtleLexer() {
        return furtleLexer;
      },
      get furtleParser() {
        return furtleParser;
      }
    });
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    var _lexers = require_lexers2();
    var _parsers = require_parsers2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var furtleLexer = (0, _lexers.furtleLexerFromNothing)(_lexer.default);
    var furtleParser = (0, _parsers.furtleParserFromNothing)(_parser.default);
  });

  // lib/context/file/furtle.js
  var require_furtle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleFileContext;
      }
    });
    var _occamlanguages = require_lib14();
    var _verify = require_verify2();
    var _furtle = require_furtle();
    var FurtleFileContext = class extends _occamlanguages.FileContext {
      constructor(context2, fileContent, filePath, tokens, node, lexer, parser, procedures) {
        super(context2, fileContent, filePath, tokens, node);
        this.lexer = lexer;
        this.parser = parser;
        this.procedures = procedures;
      }
      getLexer() {
        return this.lexer;
      }
      getParser() {
        return this.parser;
      }
      getProcedures(includeRelease = true) {
        const procedures = includeRelease ? this.context.getProcedures() : this.procedures;
        return procedures;
      }
      getLabels(includeRelease = true) {
        const labels = [];
        return labels;
      }
      getTypes(includeRelease = true) {
        const types = [];
        return types;
      }
      getRules(includeRelease = true) {
        const rules = [];
        return rules;
      }
      getAxioms(includeRelease = true) {
        const axioms = [];
        return axioms;
      }
      getLemmas(includeRelease = true) {
        const lemmas = [];
        return lemmas;
      }
      getTheorems(includeRelease = true) {
        const theorems = [];
        return theorems;
      }
      getVariables(includeRelease = true) {
        const variables = [];
        return variables;
      }
      getMetaLemmas(includeRelease = true) {
        const metaLemmas = [];
        return metaLemmas;
      }
      getConjectures(includeRelease = true) {
        const conjectures = [];
        return conjectures;
      }
      getCombinators(includeRelease = true) {
        const combinators = [];
        return combinators;
      }
      getTypePrefixes(includeRelease = true) {
        const typePrefixes = [];
        return typePrefixes;
      }
      getConstructors(includeRelease = true) {
        const constructors = [];
        return constructors;
      }
      getMetatheorems(includeRelease = true) {
        const metatheorems = [];
        return metatheorems;
      }
      getMetavariables(includeRelease = true) {
        const metavariables = [];
        return metavariables;
      }
      addProcedure(procedure) {
        const procedureString = procedure.getString();
        this.procedures.push(procedure);
        const filePath = this.getFilePath();
        this.debug(`Added the '${procedureString}' procedure to the '${filePath}' file context.`);
      }
      findProcedureByProcedureName(procedureName) {
        const procedures = this.getProcedures(), procedure = procedures.find((procedure2) => {
          const procedureComparesToProcedureName = procedure2.compareProcedureName(procedureName);
          if (procedureComparesToProcedureName) {
            return true;
          }
        }) || null;
        return procedure;
      }
      isProcedurePresentByProcedureName(procedureName) {
        const procedure = this.findProcedureByProcedureName(procedureName), procedurePresent = procedure !== null;
        return procedurePresent;
      }
      clear() {
        this.procedures = [];
      }
      complete() {
      }
      async verifyFile() {
        const node = this.getNode(), context2 = this, fileNode = node, fileVerifies = (0, _verify.verifyFile)(fileNode, context2);
        return fileVerifies;
      }
      static fromFile(file, context2) {
        const lexer = _furtle.furtleLexer, parser = _furtle.furtleParser, procedures = [], furtleFileContext = _occamlanguages.FileContext.fromFile(FurtleFileContext, file, lexer, parser, procedures, context2);
        return furtleFileContext;
      }
      static fromJSON(json, context2) {
        const lexer = _furtle.furtleLexer, parser = _furtle.furtleParser, procedures = null, furtleFileContext = _occamlanguages.FileContext.fromJSON(FurtleFileContext, json, lexer, parser, procedures, context2);
        return furtleFileContext;
      }
    };
  });

  // lib/utilities/terms.js
  var require_terms3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get termsFromNodes() {
        return termsFromNodes;
      },
      get termsFromPrimitives() {
        return termsFromPrimitives;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _string = require_string5();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function termsFromNodes(nodes, context2) {
      const {Terms} = _elements.default, termsArray = termsArrayFromNodes(nodes, context2), termsString = (0, _string.termsStringFromTermsArray)(termsArray), string = termsString, array = termsArray, node = null;
      context2 = null;
      const terms = new Terms(context2, string, node, array);
      return terms;
    }
    function termsFromPrimitives(primitives) {
      const {Terms} = _elements.default, termsArray = termsArrayFromPrimitives(primitives), termsString = (0, _string.termsStringFromTermsArray)(termsArray), context2 = null, string = termsString, array = termsArray, node = null, terms = new Terms(context2, string, node, array);
      return terms;
    }
    var _default = {
      termsFromNodes,
      termsFromPrimitives
    };
    function termsArrayFromNodes(nodes, context2) {
      const termsArray = nodes.map((node) => {
        const term = (0, _term.termFromNode)(node, context2);
        return term;
      });
      return termsArray;
    }
    function termsArrayFromPrimitives(primitives) {
      const termsArray = primitives.map((primitive) => {
        const term = (0, _term.termFromPrimitive)(primitive);
        return term;
      });
      return termsArray;
    }
  });

  // lib/index.js
  var require_lib15 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get FurtleFileContext() {
        return _furtle.default;
      },
      get FurtleLexer() {
        return _lexer.default;
      },
      get FurtleParser() {
        return _parser.default;
      },
      get Terms() {
        return _terms.default;
      },
      get lexersUtilities() {
        return _lexers.default;
      },
      get parsersUtilities() {
        return _parsers.default;
      },
      get primitiveUtilities() {
        return _primitive.default;
      },
      get termUtilities() {
        return _term.default;
      },
      get termsUtilities() {
        return _terms1.default;
      }
    });
    require_preamble();
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    var _furtle = /* @__PURE__ */ _interop_require_default(require_furtle2());
    var _term = /* @__PURE__ */ _interop_require_default(require_term());
    var _terms1 = /* @__PURE__ */ _interop_require_default(require_terms3());
    var _lexers = /* @__PURE__ */ _interop_require_default(require_lexers2());
    var _parsers = /* @__PURE__ */ _interop_require_default(require_parsers2());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/example/view/subHeading.js
  var require_subHeading = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SubHeading = _easywithstyle.default.h2`

  margin: 1rem 0 0.5rem 0;
  font-size: 2rem;
  
  :first-of-type {
    margin-top: 0;
  }

`;
    var _default = SubHeading;
  });

  // lib/example/view/div/sizeable.js
  var require_sizeable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easylayout = require_lib9();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = (0, _easywithstyle.default)(_easylayout.SizeableDiv)`

  width: 80rem;
  min-width: 48rem;
  
`;
  });

  // lib/example/view/textarea.js
  var require_textarea2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = (0, _easywithstyle.default)(_easy.Textarea)`

  border: 1px solid darkgrey;
  height: 36rem;
  resize: vertical;
  padding: 0.25rem;
  font-size: 1.2rem;
  line-height: 1.5rem;
  white-space: pre;
  font-family: monospace;

`;
  });

  // lib/example/view/textarea/bnf.js
  var require_bnf14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BNFTextarea = class extends _textarea.default {
      getBNF() {
        const value = this.getValue(), bnf = value;
        return bnf;
      }
      setBNF(bnf) {
        const value = bnf;
        this.setValue(value);
      }
      parentContext() {
        const getBNF = this.getBNF.bind(this), setBNF = this.setBNF.bind(this);
        return {
          getBNF,
          setBNF
        };
      }
    };
    __publicField(BNFTextarea, "defaultProperties", {
      className: "bnf",
      spellCheck: "false"
    });
  });

  // lib/example/view/input/ruleName.js
  var require_ruleName8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameInput = class extends _easy.Input {
      getRuleName() {
        const value = this.getValue(), ruleName = value;
        return ruleName;
      }
      setRuleName(ruleName) {
        const value = ruleName;
        this.setValue(value);
      }
      parentContext() {
        const getRuleName = this.getRuleName.bind(this), setRuleName = this.setRuleName.bind(this);
        return {
          getRuleName,
          setRuleName
        };
      }
    };
    __publicField(RuleNameInput, "defaultProperties", {
      className: "rule-name",
      spellCheck: "false"
    });
    var _default = (0, _easywithstyle.default)(RuleNameInput)`

  border: 1px solid darkgrey;
  padding: 0.25rem;
  font-size: 1.2rem;
  font-family: monospace;
  
`;
  });

  // lib/example/view/textarea/tokens.js
  var require_tokens2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TokensTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TokensTextarea = class extends _textarea.default {
      setTokens(tokens) {
        let lineNumber = 1, previousToken = null;
        const html = tokens.reduce((html2, token) => {
          const tokenHTML = token.asHTML();
          if (previousToken === null) {
            html2 += `${lineNumber++}: `;
          } else {
            const previousTokenEndOfLineToken = previousToken.isEndOfLineToken();
            if (previousTokenEndOfLineToken) {
              html2 += `${lineNumber++}: `;
            }
          }
          html2 += tokenHTML;
          previousToken = token;
          return html2;
        }, _constants.EMPTY_STRING);
        this.html(html);
      }
      clearTokens() {
        const html = _constants.EMPTY_STRING;
        this.html(html);
      }
      parentContext() {
        const setTokens = this.setTokens.bind(this), clearTokens = this.clearTokens.bind(this);
        return {
          setTokens,
          clearTokens
        };
      }
    };
    __publicField(TokensTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/view/textarea/content.js
  var require_content4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ContentTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ContentTextarea = class extends _textarea.default {
      getContent() {
        const value = this.getValue(), content = value;
        return content;
      }
      setContent(content) {
        const value = content;
        this.setValue(value);
      }
      parentContext() {
        const getContent = this.getContent.bind(this), setContent = this.setContent.bind(this);
        return {
          getContent,
          setContent
        };
      }
    };
    __publicField(ContentTextarea, "defaultProperties", {
      className: "content",
      spellCheck: "false"
    });
  });

  // lib/example/view/textarea/parseTree.js
  var require_parseTree2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParseTreeTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ParseTreeTextarea = class extends _textarea.default {
      setParseTree(parseTree) {
        if (parseTree !== null) {
          parseTree.shiftLine();
          const parseTreeString = parseTree.asString(), value = parseTreeString;
          this.setValue(value);
        } else {
          this.clearParseTree();
        }
      }
      clearParseTree() {
        const value = _constants.EMPTY_STRING;
        this.setValue(value);
      }
      parentContext() {
        const setParseTree = this.setParseTree.bind(this), clearParseTree = this.clearParseTree.bind(this);
        return {
          setParseTree,
          clearParseTree
        };
      }
    };
    __publicField(ParseTreeTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/view/textarea/lexicalEntries.js
  var require_lexicalEntries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LexicalEntriesTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var LexicalEntriesTextarea = class extends _textarea.default {
      getLexicalEntries() {
        const value = this.getValue(), lexicalEntries = JSON.parse(value);
        return lexicalEntries;
      }
      setLexicalEntries(lexicalEntries) {
        const value = JSON.stringify(lexicalEntries, null, "  ");
        this.setValue(value);
      }
      parentContext() {
        const getLexicalEntries = this.getLexicalEntries.bind(this), setLexicalEntries = this.setLexicalEntries.bind(this);
        return {
          getLexicalEntries,
          setLexicalEntries
        };
      }
    };
    __publicField(LexicalEntriesTextarea, "defaultProperties", {
      className: "lexical-entries",
      spellCheck: "false"
    });
  });

  // lib/example/view.js
  var require_view = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _easylayout = require_lib9();
    var _index = require_lib15();
    var _subHeading = /* @__PURE__ */ _interop_require_default(require_subHeading());
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable2());
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf14());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName8());
    var _tokens = /* @__PURE__ */ _interop_require_default(require_tokens2());
    var _content = /* @__PURE__ */ _interop_require_default(require_content4());
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree2());
    var _lexicalEntries = /* @__PURE__ */ _interop_require_default(require_lexicalEntries());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {furtleParserFromBNF} = _index.parsersUtilities;
    var {furtleLexerFromEntries} = _index.lexersUtilities;
    var {bnf} = _index.FurtleParser;
    var {entries} = _index.FurtleLexer;
    var View = class extends _easy.Element {
      keyUpHandler = (event, element) => {
        const tokens = this.getTokens(), parseTree = this.getParseTree(tokens);
        this.setTokens(tokens);
        this.setParseTree(parseTree);
      };
      getTokens() {
        const lexicalEntries = this.getLexicalEntries(), entries2 = lexicalEntries, furtleLexer = furtleLexerFromEntries(entries2), lexer = furtleLexer, content = this.getContent(), tokens = lexer.tokenise(content);
        return tokens;
      }
      getParseTree(tokens) {
        let parseTree = null;
        const bnf2 = this.getBNF(), furtleParser = furtleParserFromBNF(bnf2), parser = furtleParser, ruleName = this.getRuleName(), ruleMap = parser.getRuleMap(), rule = ruleMap[ruleName], node = parser.parse(tokens, rule);
        if (node !== null) {
          parseTree = node.asParseTree(tokens);
        }
        return parseTree;
      }
      childElements() {
        return /* @__PURE__ */ React.createElement(_easylayout.ColumnsDiv, null, /* @__PURE__ */ React.createElement(_sizeable.default, null, /* @__PURE__ */ React.createElement(_easylayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Lexical entries"), /* @__PURE__ */ React.createElement(_lexicalEntries.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "BNF"), /* @__PURE__ */ React.createElement(_bnf.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Rule name"), /* @__PURE__ */ React.createElement(_ruleName.default, {
          onKeyUp: this.keyUpHandler
        }))), /* @__PURE__ */ React.createElement(_easylayout.VerticalSplitterDiv, null), /* @__PURE__ */ React.createElement(_easylayout.ColumnDiv, null, /* @__PURE__ */ React.createElement(_easylayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Content"), /* @__PURE__ */ React.createElement(_content.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Tokens"), /* @__PURE__ */ React.createElement(_tokens.default, null), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Parse tree"), /* @__PURE__ */ React.createElement(_parseTree.default, null))));
      }
      initialise() {
        this.assignContext();
        const {initialContent, initialRuleName} = this.constructor, content = initialContent, ruleName = initialRuleName, lexicalEntries = entries;
        this.setBNF(bnf);
        this.setContent(content);
        this.setRuleName(ruleName);
        this.setLexicalEntries(lexicalEntries);
        this.keyUpHandler();
      }
    };
    __publicField(View, "initialRuleName", "variableAssignment");
    __publicField(View, "initialContent", `Boolean variableBound = isVariableBound(termNode, statementNode);`);
    __publicField(View, "tagName", "div");
    __publicField(View, "defaultProperties", {
      className: "view"
    });
    var _default = (0, _easywithstyle.default)(View)`

  padding: 1rem;
 
`;
  });

  // lib/example.js
  var require_example3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_lib2();
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _view = /* @__PURE__ */ _interop_require_default(require_view());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {renderStyles} = _easywithstyle.default;
    renderStyles();
    var body = new _easy.Body();
    body.mount(/* @__PURE__ */ React.createElement(_view.default, null));
  });
  require_example3();
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL29mZnNldC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvYm91bmRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL29iamVjdC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9lbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdGV4dEVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9lbGVtZW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZXZlbnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2pzeC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2tleS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9tb3VzZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2NsaWNrLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvdG91Y2guanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9yZXNpemUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9mdWxsU2NyZWVuLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvYXN5bmMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9jdXN0b21FdmVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvcmVhY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21vdXNlQnV0dG9ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2lucHV0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZm9jdXMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zZWxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2RvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy93aW5kb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvYm9keS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9saW5rLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2lucHV0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2J1dHRvbi5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9zZWxlY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvY2hlY2tib3guanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvdGV4dGFyZWEuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9qdXh0YXBvc2Uvc3JjL2p1eHRhcG9zZS5qcyIsICJub2RlX21vZHVsZXMvanV4dGFwb3NlL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdGFnTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvbGV2ZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL21ldGhvZHMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvaGVhZGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9rZXlDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9lbmNvZGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY2hhcmFjdGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9zdGF0dXNDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9jb250ZW50VHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvc3RhdHVzTWVzc2FnZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvaHR0cC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy9hc3luY2hyb25vdXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvdXRpbGl0aWVzL2FqYXguanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2NvbnRlbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9zcGVjaWFsU3ltYm9scy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy91dGlsaXRpZXMvcnVsZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL2JuZi9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3V0aWxpdGllcy90b2tlbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9jb21tb24vbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvd2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9ibmYvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvYmFzaWMvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9weXRob25TdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9weXRob25TdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9iYXNpYy9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lL2NTdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvbWlkZGxlT2YvY1N0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jc3MvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ibmYvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL21peGlucy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnNlVHJlZS92ZXJ0aWNhbEJyYW5jaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvdXRpbGl0aWVzL3Rva2Vucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUvaG9yaXpvbnRhbEJyYW5jaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2NoaWxkTm9kZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnNlVHJlZS9ub25UZXJtaW5hbE5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9ydWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL3Rlcm1pbmFsTm9kZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS90ZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2Vwc2lsb25Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL3Rlcm1pbmFsL2Vwc2lsb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvdGVybWluYWwvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL3dpbGRjYXJkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2VuZE9mTGluZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvdGVybWluYWwvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0Q2hvaWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9wYXJ0Q2hvaWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9xdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvcGFyc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL2RlZmluaXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi90ZXJtaW5hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9ub25UZXJtaW5hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvc2VxdWVuY2VPZlBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL29wYWNpdHlNb2RpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL25vV2hpdGVzcGFjZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvdGVybWluYWwvbm9XaGl0ZXNwYWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL25vV2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvY2FsbEFoZWFkTW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvdGVybWluYWwvcmVndWxhckV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUvc3RhcnRPZkNvbnRlbnROb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zdGFydE9mQ29udGVudFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL29wdGlvbmFsUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvb25lT25lT3JNb3JlUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3plcm9PbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub25UZXJtaW5hbE5vZGVNYXAuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9taXhpbnMvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZXJyb3IuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vc3RyaW5nTGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9kb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL3BhcnRDaG9pY2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3BhcnRDaG9pY2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3F1YW50aWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL2RlZmluaXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9kZWZpbml0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvdGVybWluYWxQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3N0cmluZ0xpdGVyYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL25vblRlcm1pbmFsUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3NlcXVlbmNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9vcGFjaXR5TW9kaWZpZXJSdWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9vcGFjaXR5TW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9jYWxsQWhlYWRNb2RpZmllclJ1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL2NhbGxBaGVhZE1vZGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9yZWd1bGFyRXhwcmVzc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9xdWFudGlmaWVyUnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvb3B0aW9uYWxRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL3N0YXJ0T2ZDb250ZW50UGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvc3RhcnRPZkNvbnRlbnRQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9vbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi96ZXJvT3JNb3JlUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ydWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvYm5mL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvYmFzaWMvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9jb21tb24vcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9iYXNpYy9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL2JuZi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1xdWVyeS9zcmMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3NwcmVhZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3N1YkV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL2VudHJpZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1xdWVyeS9zcmMvZXhwcmVzc2lvbi9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL2V4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9kZWNsYXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvZGVjbGFyYXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0cy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvbWVkaWEuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL21lZGlhcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUva2V5ZnJhbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL2tleWZyYW1lcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUva2V5ZnJhbWVzcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9zdHlsZXMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzc05hbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS13aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktd2l0aC1zdHlsZS9zcmMvd2l0aFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvY3Vyc29ycy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2N1cnNvci5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9yb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvcm93cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9jb2x1bW4uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvY29sdW1ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvdXRpbGl0aWVzL3JlZmVyZW5jZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy91dGlsaXRpZXMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvY3VzdG9tRXZlbnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9taXhpbnMvZHJhZy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9taXhpbnMvZHJvcC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9lbGVtZW50L2RyYWcuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvZWxlbWVudC9kcm9wLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWRyYWctYW5kLWRyb3Avc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NpemVhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyL3ZlcnRpY2FsLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyL2hvcml6b250YWwuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2VsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvY29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvbGluZUluZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2NvbnRleHQvZmlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvYXN5bmNocm9ub3VzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy92ZXJpZnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvZ3JhbW1hck5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy92b2NhYnVsYXJ5TmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hci9kZWZhdWx0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9sZXhlci9leGFtcGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9wYXJzZXIvbm9uVGVybWluYWxOb2RlTWFwLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9wYXJzZXIvZXhhbXBsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2N5Y2xlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGlyZWN0ZWRHcmFwaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmVkdWNlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9ydWxlTmFtZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9jeWNsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9ub25Db25zdW1pbmcuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2VkZ2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcmVjdXJzaXZlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvbGFiZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL2RpcmVjdGVkR3JhcGguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ydWxlL3JlZHVjZWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9jcmVhdGVSZWR1Y2VkUnVsZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcHJlY2VkZW5jZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmVwZWF0ZWQvZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ub2RlL3JlcGVhdGVkL2luZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcmV3cml0ZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmV3cml0dGVuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9wYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3BhdGguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9kZWZpbml0aW9uL3Jld3JpdHRlbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3J1bGUvcmV3cml0dGVuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGVmaW5pdGlvbi9yZXBlYXRlZC9kaXJlY3RseS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9yZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvY3JlYXRlRGlyZWN0bHlSZXBlYXRlZFJ1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGVmaW5pdGlvbi9lcHNpbG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3BhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL25vblByb2R1Y2luZy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9jb21wbGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL29jY2x1ZGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL2NhbGxBaGVhZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9xdWFsaWZpZWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ydWxlL3JlcGVhdGVkL2luZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9jcmVhdGVJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2VsaW1pbmF0ZUxlZnRSZWN1cnNpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvcXVlcnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy90ZVgvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL3RlWC9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9mdXJ0bGUvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2Z1cnRsZS9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9wbGFpblRleHQvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL3BsYWluVGV4dC9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hclZvY2FidWxhcnkvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy90ZVgvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvdGVYL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvanNvbi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9mdXJ0bGUvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvZnVydGxlL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvbm9taW5hbC9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9wbGFpblRleHQvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvcGxhaW5UZXh0L3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hckJORi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvZ3JhbW1hci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvdm9jYWJ1bGFyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvbm9taW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy90eXBlc01hcC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvdmFsaWRhdGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hci9jb21iaW5lZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvbGV4ZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3V0aWxpdGllcy9wYXJzZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9maWxlQ29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9jb250ZXh0L3JlbGVhc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvbm9uVGVybWluYWxOb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvcGFzcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL3ppcC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL2FzeW5jLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3Bhc3Mvc2ltcGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3Bhc3MvZm9yd2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL2VxdWl2YWxlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9kZXBlbmRlbmN5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy92ZXJpZmljYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy90eXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZmlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2ZpbGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvbXVsdGlwbGVycy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdmVyc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2RpcmVjdG9yeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9uYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZmlsZU5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvbWl4aW5zL2JuZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9maWxlUGF0aC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9maWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9maWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2RlcGVuZGVuY3kuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy9zaG9ydGVuZWRWZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZGVwZW5kZW5jaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdXRpbGl0aWVzL3F1ZXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdXRpbGl0aWVzL3ZhbGlkYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvcHJvcGVydHlOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9tZXRhSlNPTi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9tZXRhSlNPTi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy92b2NhYnVsYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvcHJvamVjdC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3JlbGVhc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy9wcm9qZWN0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3JlbGVhc2VzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvdXRpbGl0aWVzL3JlbGVhc2VDb250ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2luZGV4LmpzIiwgInNyYy9lbGVtZW50cy5qcyIsICJzcmMvZWxlbWVudC9zdGVwLmpzIiwgInNyYy9leGNlcHRpb24uanMiLCAic3JjL3R5cGVzLmpzIiwgInNyYy9udWxsTm9kZS5qcyIsICJzcmMvY29uc3RhbnRzLmpzIiwgInNyYy91dGlsaXRpZXMvc3RyaW5nTGl0ZXJhbC5qcyIsICJzcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJzcmMvdXRpbGl0aWVzL3ByaW1pdGl2ZS5qcyIsICJzcmMvdXRpbGl0aWVzL3Rlcm0uanMiLCAic3JjL2VsZW1lbnQvc29tZS5qcyIsICJzcmMvZWxlbWVudC90ZXJtLmpzIiwgInNyYy9lbGVtZW50L3Rlcm1zLmpzIiwgInNyYy9lbGVtZW50L2xhYmVsLmpzIiwgInNyYy9lbGVtZW50L2Vycm9yLmpzIiwgInNyYy9lbGVtZW50L2V2ZXJ5LmpzIiwgInNyYy9lbGVtZW50L3JlZHVjZS5qcyIsICJzcmMvZWxlbWVudC90ZXJuYXJ5LmpzIiwgInNyYy9lbGVtZW50L3ZhcmlhYmxlLmpzIiwgInNyYy9lbGVtZW50L3ByaW1pdGl2ZS5qcyIsICJzcmMvZWxlbWVudC9yZWZlcmVuY2UuanMiLCAic3JjL2VsZW1lbnQvcHJvY2VkdXJlLmpzIiwgInNyYy9lbGVtZW50L25vZGVRdWVyeS5qcyIsICJzcmMvZWxlbWVudC9wYXJhbWV0ZXIuanMiLCAic3JjL2VsZW1lbnQvcGFyYW1ldGVycy5qcyIsICJzcmMvZWxlbWVudC9ub2Rlc1F1ZXJ5LmpzIiwgInNyYy9lbGVtZW50L2V4cHJlc3Npb24uanMiLCAic3JjL2NvbnRleHQvYmxvY2suanMiLCAic3JjL2VsZW1lbnQvcmV0dXJuQmxvY2suanMiLCAic3JjL2VsZW1lbnQvdGVybS9uZWdhdGVkLmpzIiwgInNyYy9lbGVtZW50L3Rlcm0vbG9naWNhbC5qcyIsICJzcmMvZWxlbWVudC90ZXJtL2JyYWNrZXRlZC5qcyIsICJzcmMvZWxlbWVudC9wcm9jZWR1cmVDYWxsLmpzIiwgInNyYy9lbGVtZW50L3Rlcm0vY29tcGFyaXNvbi5qcyIsICJzcmMvZWxlbWVudC9wYXJhbWV0ZXIvbmFtZWQuanMiLCAic3JjL2VsZW1lbnQvYXNzaWdubWVudC9hcnJheS5qcyIsICJzcmMvZWxlbWVudC9zdGF0ZW1lbnQvcmV0dXJuLmpzIiwgInNyYy9lbGVtZW50L3BhcmFtZXRlcnMvbmFtZWQuanMiLCAic3JjL25vZGVQcm9wZXJ0eS5qcyIsICJzcmMvcGFyYW1ldGVyTmFtZXMuanMiLCAic3JjL25vZGVQcm9wZXJ0aWVzLmpzIiwgInNyYy9lbGVtZW50L2Fzc2lnbm1lbnQvb2JqZWN0LmpzIiwgInNyYy9lbGVtZW50L3Byb2NlZHVyZS9hbm9ueW1vdXMuanMiLCAic3JjL2VsZW1lbnQvYXNzaWdubWVudC92YXJpYWJsZS5qcyIsICJzcmMvZWxlbWVudC9hc3NpZ25tZW50cy92YXJpYWJsZS5qcyIsICJzcmMvZWxlbWVudC9kZWNsYXJhdGlvbi9wcm9jZWR1cmUuanMiLCAic3JjL3ByZWFtYmxlLmpzIiwgInNyYy9mdXJ0bGUvbGV4ZXIuanMiLCAic3JjL3J1bGVOYW1lcy5qcyIsICJzcmMvbm9kZS9zdGVwLmpzIiwgInNyYy9ub2RlL3NvbWUuanMiLCAic3JjL25vZGUvdGVybS5qcyIsICJzcmMvbm9kZS90ZXJtcy5qcyIsICJzcmMvbm9kZS9ldmVyeS5qcyIsICJzcmMvdG9rZW5UeXBlcy5qcyIsICJzcmMvbm9kZS9sYWJlbC5qcyIsICJzcmMvbm9kZS9lcnJvci5qcyIsICJzcmMvbm9kZS9yZWR1Y2UuanMiLCAic3JjL25vZGUvdGVybmFyeS5qcyIsICJzcmMvbm9kZS9kb2N1bWVudC5qcyIsICJzcmMvbm9kZS92YXJpYWJsZS5qcyIsICJzcmMvbm9kZS9ub25zZW5zZS5qcyIsICJzcmMvbm9kZS9wcmltaXRpdmUuanMiLCAic3JjL25vZGUvcmVmZXJlbmNlLmpzIiwgInNyYy9ub2RlL3BhcmFtZXRlci5qcyIsICJzcmMvbm9kZS9ub2RlUXVlcnkuanMiLCAic3JjL25vZGUvZXhwcmVzc2lvbi5qcyIsICJzcmMvbm9kZS9wYXJhbWV0ZXJzLmpzIiwgInNyYy9ub2RlL25vZGVzUXVlcnkuanMiLCAic3JjL25vZGUvcmV0dXJuQmxvY2suanMiLCAic3JjL25vZGUvdGVybS9sb2dpY2FsLmpzIiwgInNyYy9ub2RlL3Rlcm0vbmVnYXRlZC5qcyIsICJzcmMvbm9kZS9wcm9jZWR1cmVDYWxsLmpzIiwgInNyYy9ub2RlL3Rlcm0vYnJhY2tldGVkLmpzIiwgInNyYy9ub2RlL3Rlcm0vY29tcGFyaXNvbi5qcyIsICJzcmMvbm9kZS9wYXJhbWV0ZXIvbmFtZWQuanMiLCAic3JjL25vZGUvcGFyYW1ldGVycy9uYW1lZC5qcyIsICJzcmMvbm9kZS9zdGF0ZW1lbnQuanMiLCAic3JjL25vZGUvc3RhdGVtZW50L3JldHVybi5qcyIsICJzcmMvbm9kZS9hc3NpZ25tZW50LmpzIiwgInNyYy9ub2RlL2Fzc2lnbm1lbnQvYXJyYXkuanMiLCAic3JjL25vZGUvYXNzaWdubWVudC9vYmplY3QuanMiLCAic3JjL25vZGUvcHJvY2VkdXJlLmpzIiwgInNyYy9ub2RlL3Byb2NlZHVyZS9hbm95bW91cy5qcyIsICJzcmMvbm9kZS9hc3NpZ25tZW50L3ZhcmlhYmxlLmpzIiwgInNyYy9ub2RlL2Fzc2lnbm1lbnRzL3ZhcmlhYmxlLmpzIiwgInNyYy9ub2RlL2RlY2xhcmF0aW9uLmpzIiwgInNyYy9ub2RlL2RlY2xhcmF0aW9uL3Byb2NlZHVyZS5qcyIsICJzcmMvbm9uVGVybWluYWxOb2RlTWFwLmpzIiwgInNyYy9mdXJ0bGUvcGFyc2VyLmpzIiwgInNyYy91dGlsaXRpZXMvZWxlbWVudC5qcyIsICJzcmMvcHJvY2Vzcy92ZXJpZnkuanMiLCAic3JjL3V0aWxpdGllcy9sZXhlcnMuanMiLCAic3JjL3V0aWxpdGllcy9wYXJzZXJzLmpzIiwgInNyYy91dGlsaXRpZXMvZnVydGxlLmpzIiwgInNyYy9jb250ZXh0L2ZpbGUvZnVydGxlLmpzIiwgInNyYy91dGlsaXRpZXMvdGVybXMuanMiLCAic3JjL2luZGV4LmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvc3ViSGVhZGluZy5qcyIsICJzcmMvZXhhbXBsZS92aWV3L2Rpdi9zaXplYWJsZS5qcyIsICJzcmMvZXhhbXBsZS92aWV3L3RleHRhcmVhLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvYm5mLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvaW5wdXQvcnVsZU5hbWUuanMiLCAic3JjL2V4YW1wbGUvdmlldy90ZXh0YXJlYS90b2tlbnMuanMiLCAic3JjL2V4YW1wbGUvdmlldy90ZXh0YXJlYS9jb250ZW50LmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvcGFyc2VUcmVlLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvbGV4aWNhbEVudHJpZXMuanMiLCAic3JjL2V4YW1wbGUvdmlldy5qcyIsICJzcmMvZXhhbXBsZS5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9mZnNldCB7XG4gIGNvbnN0cnVjdG9yKHRvcCwgbGVmdCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21ET01FbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCB9ID0gZG9tRWxlbWVudCxcbiAgICAgICAgICB0b3AgPSBvZmZzZXRUb3AsICAvLy9cbiAgICAgICAgICBsZWZ0ID0gb2Zmc2V0TGVmdCwgIC8vL1xuICAgICAgICAgIG9mZnNldCA9IG5ldyBPZmZzZXQodG9wLCBsZWZ0KTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm91bmRzIHtcbiAgY29uc3RydWN0b3IodG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKSB7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG5cbiAgZ2V0UmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHQ7XG4gIH1cblxuICBnZXRCb3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgY29uc3Qgd2lkdGggPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCk7XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBnZXRIZWlnaHQoKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdGhpcy50b3ApO1xuXG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuICBcbiAgc2V0VG9wKHRvcCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICB9XG5cbiAgc2V0TGVmdChsZWZ0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgfVxuXG4gIHNldFJpZ2h0KHJpZ2h0KSB7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB9XG5cbiAgc2V0Qm90dG9tKGJvdHRvbSkge1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG5cbiAgYXJlT3ZlcmxhcHBpbmcoYm91bmRzKSB7XG4gICAgY29uc3QgYm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICAgIHJpZ2h0ID0gYm91bmRzLmdldFJpZ2h0KCksXG4gICAgICAgICAgbGVmdCA9IGJvdW5kcy5nZXRMZWZ0KCksXG4gICAgICAgICAgdG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICAgIG92ZXJsYXBwaW5nID0gKCh0aGlzLnRvcCA8IGJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDwgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IHRvcCkpO1xuXG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nO1xuICB9XG5cbiAgYXJlT3ZlcmxhcHBpbmdCeVRvcEFuZExlZnQodG9wLCBsZWZ0KSB7XG4gICAgY29uc3Qgb3ZlcmxhcHBpbmcgPSAoKHRoaXMudG9wIDw9IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDw9IGxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IHRvcCkpO1xuXG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21ET01FbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHBhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCB9ID0gd2luZG93LFxuICAgICAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgd2luZG93U2Nyb2xsVG9wID0gcGFnZVlPZmZzZXQsIC8vL1xuICAgICAgICAgIHdpbmRvd1Njcm9sbExlZnQgPSBwYWdlWE9mZnNldCwgIC8vL1xuICAgICAgICAgIHRvcCA9IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyB3aW5kb3dTY3JvbGxUb3AsXG4gICAgICAgICAgbGVmdCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgd2luZG93U2Nyb2xsTGVmdCxcbiAgICAgICAgICByaWdodCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5yaWdodCArIHdpbmRvd1Njcm9sbExlZnQsXG4gICAgICAgICAgYm90dG9tID0gYm91bmRpbmdDbGllbnRSZWN0LmJvdHRvbSArIHdpbmRvd1Njcm9sbFRvcCxcbiAgICAgICAgICBib3VuZHMgPSBuZXcgQm91bmRzKHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSk7XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ub3BMZWZ0V2lkdGhBbmRIZWlnaHQodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0LFxuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoLFxuICAgICAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHModG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKTtcblxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7IHJldHVybiBhcnJheVswXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheTEsIGFycmF5MikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheTEsIGFycmF5Mik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnQoYXJyYXkxLCBhcnJheTIsIHRlc3QpIHtcbiAgYXJyYXkxID0gWyAuLi5hcnJheTEgXTsgLy8vXG5cbiAgYXJyYXkyLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheTEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGFycmF5LCBlbGVtZW50KSA9PiB7XG4gICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZWxlbWVudCk7ICAvLy9cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSwgW10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3VhcmFudGVlKGFycmF5T3JFbGVtZW50KSB7XG4gIGFycmF5T3JFbGVtZW50ID0gYXJyYXlPckVsZW1lbnQgfHwgW107XG5cbiAgcmV0dXJuIChhcnJheU9yRWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICBhcnJheU9yRWxlbWVudCA6XG4gICAgICAgICAgICAgIFthcnJheU9yRWxlbWVudF07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBGT1IgPSBcImZvclwiO1xuZXhwb3J0IGNvbnN0IEJPRFkgPSBcImJvZHlcIjtcbmV4cG9ydCBjb25zdCBOT05FID0gXCJub25lXCI7XG5leHBvcnQgY29uc3QgU1BBQ0UgPSBcIiBcIjtcbmV4cG9ydCBjb25zdCBDTEFTUyA9IFwiY2xhc3NcIjtcbmV4cG9ydCBjb25zdCBXSURUSCA9IFwid2lkdGhcIjtcbmV4cG9ydCBjb25zdCBCTE9DSyA9IFwiYmxvY2tcIjtcbmV4cG9ydCBjb25zdCBIRUlHSFQgPSBcImhlaWdodFwiO1xuZXhwb3J0IGNvbnN0IE9CSkVDVCA9IFwib2JqZWN0XCI7XG5leHBvcnQgY29uc3QgU1RSSU5HID0gXCJzdHJpbmdcIjtcbmV4cG9ydCBjb25zdCBESVNQTEFZID0gXCJkaXNwbGF5XCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuZXhwb3J0IGNvbnN0IERJU0FCTEVEID0gXCJkaXNhYmxlZFwiO1xuZXhwb3J0IGNvbnN0IEZVTkNUSU9OID0gXCJmdW5jdGlvblwiO1xuZXhwb3J0IGNvbnN0IFdJTERDQVJEID0gXCIqXCI7XG5leHBvcnQgY29uc3QgSFRNTF9GT1IgPSBcImh0bWxGb3JcIjtcbmV4cG9ydCBjb25zdCBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FID0gXCJjbGFzc05hbWVcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IFNWR19OQU1FU1BBQ0VfVVJJID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPUEVSVElFUyA9IFwiZGVmYXVsdFByb3BlcnRpZXNcIjtcbmV4cG9ydCBjb25zdCBJR05PUkVEX1BST1BFUlRJRVMgPSBcImlnbm9yZWRQcm9wZXJ0aWVzXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJPT0xFQU4gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKHRhcmdldCwgc291cmNlID0ge30pIHtcbiAgdGFyZ2V0ID0geyAgLy8vXG4gICAgLi4udGFyZ2V0XG4gIH07XG5cbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyAgLy8vXG5cbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W25hbWVdLFxuICAgICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW25hbWVdLFxuICAgICAgICAgIHRhcmdldEhhc093blByb3BlcnR5ID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpO1xuXG4gICAgdGFyZ2V0W25hbWVdID0gdGFyZ2V0SGFzT3duUHJvcGVydHkgP1xuICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZhbHVlcyh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU7IC8vL1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmUodGFyZ2V0LCBuYW1lcyA9IFtdKSB7XG4gIHRhcmdldCA9IHsgIC8vL1xuICAgIC4uLnRhcmdldFxuICB9O1xuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB0YXJnZXRIYXNPd25Qcm9wZXJ0eSA9IHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcblxuICAgIGlmICh0YXJnZXRIYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgZGVsZXRlIHRhcmdldFtuYW1lXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVWYWx1ZXModGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gIGNvbnN0IHRhcmdldFZhbHVlQm9vbGVhbiA9IGlzVmFsdWVCb29sZWFuKHRhcmdldFZhbHVlKSxcbiAgICAgICAgc291cmNlVmFsdWVCb29sZWFuID0gaXNWYWx1ZUJvb2xlYW4oc291cmNlVmFsdWUpLFxuICAgICAgICBjb21iaW5lZFZhbHVlID0gKHRhcmdldFZhbHVlQm9vbGVhbiAmJiBzb3VyY2VWYWx1ZUJvb2xlYW4pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgOiAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0YXJnZXRWYWx1ZX0gJHtzb3VyY2VWYWx1ZX1gO1xuXG4gIHJldHVybiBjb21iaW5lZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbHVlQm9vbGVhbih2YWx1ZSkge1xuICBjb25zdCB2YWx1ZUJvb2xlYW4gPSAodHlwZW9mIHZhbHVlID09PSBCT09MRUFOKTtcblxuICByZXR1cm4gdmFsdWVCb29sZWFuO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxDYXNlVG9TbmFrZUNhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKykvZywgKG1hdGNoLCBjaGFyYWN0ZXJzKSA9PiB7XG4gICAgY29uc3QgdXBwZXJDYXNlQ2hhcmFjdGVycyA9IGNoYXJhY3RlcnMudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBzbmFrZUNhc2VDaGFyYWN0ZXJzID0gYC0ke3VwcGVyQ2FzZUNoYXJhY3RlcnN9YDtcblxuICAgIHJldHVybiBzbmFrZUNhc2VDaGFyYWN0ZXJzO1xuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZHVGFnTmFtZSh0YWdOYW1lKSB7XG4gIHJldHVybiBzdmdUYWdOYW1lcy5pbmNsdWRlcyh0YWdOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZHQXR0cmlidXRlTmFtZShhdHRyaWJ1dGVOYW1lKSB7XG4gIHJldHVybiBzdmdBdHRyaWJ1dGVOYW1lcy5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICByZXR1cm4gaHRtbEF0dHJpYnV0ZU5hbWVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpO1xufVxuXG5jb25zdCBzdmdUYWdOYW1lcyA9IFtcbiAgICAgICAgXCJhbHRHbHlwaFwiLCBcImFuaW1hdGVcIiwgXCJhbmltYXRlQ29sb3JcIiwgXCJhbmltYXRlTW90aW9uXCIsIFwiYW5pbWF0ZVRyYW5zZm9ybVwiLCBcImFuaW1hdGlvblwiLCBcImF1ZGlvXCIsXG4gICAgICAgIFwiY2lyY2xlXCIsIFwiY2xpcFBhdGhcIiwgXCJjb2xvci1wcm9maWxlXCIsIFwiY3Vyc29yXCIsXG4gICAgICAgIFwiZGVmc1wiLCBcImRlc2NcIiwgXCJkaXNjYXJkXCIsXG4gICAgICAgIFwiZWxsaXBzZVwiLFxuICAgICAgICBcImZlQmxlbmRcIiwgXCJmZUNvbG9yTWF0cml4XCIsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLCBcImZlQ29tcG9zaXRlXCIsIFwiZmVDb252b2x2ZU1hdHJpeFwiLCBcImZlRGlmZnVzZUxpZ2h0aW5nXCIsIFwiZmVEaXNwbGFjZW1lbnRNYXBcIiwgXCJmZURpc3RhbnRMaWdodFwiLCBcImZlRHJvcFNoYWRvd1wiLCBcImZlRmxvb2RcIiwgXCJmZUZ1bmNBXCIsIFwiZmVGdW5jQlwiLCBcImZlRnVuY0dcIiwgXCJmZUZ1bmNSXCIsIFwiZmVHYXVzc2lhbkJsdXJcIiwgXCJmZUltYWdlXCIsIFwiZmVNZXJnZVwiLCBcImZlTWVyZ2VOb2RlXCIsIFwiZmVNb3JwaG9sb2d5XCIsIFwiZmVPZmZzZXRcIiwgXCJmZVBvaW50TGlnaHRcIiwgXCJmZVNwZWN1bGFyTGlnaHRpbmdcIiwgXCJmZVNwb3RMaWdodFwiLCBcImZlVGlsZVwiLCBcImZlVHVyYnVsZW5jZVwiLCBcImZpbHRlclwiLCBcImZvbnRcIiwgXCJmb250LWZhY2VcIiwgXCJmb250LWZhY2UtZm9ybWF0XCIsIFwiZm9udC1mYWNlLW5hbWVcIiwgXCJmb250LWZhY2UtdXJpXCIsIFwiZm9yZWlnbk9iamVjdFwiLFxuICAgICAgICBcImdcIiwgXCJnbHlwaFwiLCBcImdseXBoUmVmXCIsXG4gICAgICAgIFwiaGFuZGxlclwiLCBcImhhdGNoXCIsIFwiaGF0Y2hwYXRoXCIsIFwiaGtlcm5cIixcbiAgICAgICAgXCJpbWFnZVwiLCBcImxpbmVcIiwgXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgICAgICBcImxpc3RlbmVyXCIsXG4gICAgICAgIFwibWFya2VyXCIsIFwibWFza1wiLCBcIm1lc2hcIiwgXCJtZXNoZ3JhZGllbnRcIiwgXCJtZXNocGF0Y2hcIiwgXCJtZXNocm93XCIsIFwibWV0YWRhdGFcIiwgXCJtaXNzaW5nLWdseXBoXCIsIFwibXBhdGhcIixcbiAgICAgICAgXCJwYXRoXCIsIFwicGF0dGVyblwiLCBcInBvbHlnb25cIiwgXCJwb2x5bGluZVwiLCBcInByZWZldGNoXCIsXG4gICAgICAgIFwicmFkaWFsR3JhZGllbnRcIiwgXCJyZWN0XCIsXG4gICAgICAgIFwic2NyaXB0XCIsIFwic2V0XCIsIFwic29saWRjb2xvclwiLCBcInN0b3BcIiwgXCJzdHlsZVwiLCBcInN2Z1wiLCBcInN3aXRjaFwiLCBcInN5bWJvbFwiLFxuICAgICAgICBcInRicmVha1wiLCBcInRleHRcIiwgXCJ0ZXh0QXJlYVwiLCBcInRleHRQYXRoXCIsIFwidGl0bGVcIiwgXCJ0cmVmXCIsIFwidHNwYW5cIixcbiAgICAgICAgXCJ1bmtub3duXCIsIFwidXNlXCIsXG4gICAgICAgIFwidmlkZW9cIiwgXCJ2aWV3XCIsIFwidmtlcm5cIlxuICAgICAgXSxcbiAgICAgIHN2Z0F0dHJpYnV0ZU5hbWVzID0gW1xuICAgICAgICBcImFjY2VudC1oZWlnaHRcIiwgXCJhY2N1bXVsYXRlXCIsIFwiYWRkaXRpdmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJhbHBoYWJldGljXCIsIFwiYW1wbGl0dWRlXCIsIFwiYXJhYmljLWZvcm1cIiwgXCJhc2NlbnRcIiwgXCJhdHRyaWJ1dGVOYW1lXCIsIFwiYXR0cmlidXRlVHlwZVwiLCBcImF6aW11dGhcIixcbiAgICAgICAgXCJiYW5kd2lkdGhcIiwgXCJiYXNlRnJlcXVlbmN5XCIsIFwiYmFzZVByb2ZpbGVcIiwgXCJiYXNlbGluZS1zaGlmdFwiLCBcImJib3hcIiwgXCJiZWdpblwiLCBcImJpYXNcIiwgXCJieVwiLFxuICAgICAgICBcImNhbGNNb2RlXCIsIFwiY2FwLWhlaWdodFwiLCBcImNsaXBcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGlwLXBhdGhcIiwgXCJjbGlwLXJ1bGVcIiwgXCJjbGlwUGF0aFVuaXRzXCIsIFwiY29sb3JcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwiY29sb3ItcHJvZmlsZVwiLCBcImNvbG9yLXJlbmRlcmluZ1wiLCBcImNvbnRlbnRTY3JpcHRUeXBlXCIsIFwiY29udGVudFN0eWxlVHlwZVwiLCBcImNyb3Nzb3JpZ2luXCIsIFwiY3Vyc29yXCIsIFwiY3hcIiwgXCJjeVwiLFxuICAgICAgICBcImRcIiwgXCJkZWZhdWx0QWN0aW9uXCIsIFwiZGVzY2VudFwiLCBcImRpZmZ1c2VDb25zdGFudFwiLCBcImRpcmVjdGlvblwiLCBcImRpc3BsYXlcIiwgXCJkaXZpc29yXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJkb3dubG9hZFwiLCBcImR1clwiLCBcImR4XCIsIFwiZHlcIixcbiAgICAgICAgXCJlZGdlTW9kZVwiLCBcImVkaXRhYmxlXCIsIFwiZWxldmF0aW9uXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIiwgXCJlbmRcIiwgXCJldmVudFwiLCBcImV4cG9uZW50XCIsIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxuICAgICAgICBcImZpbGxcIiwgXCJmaWxsLW9wYWNpdHlcIiwgXCJmaWxsLXJ1bGVcIiwgXCJmaWx0ZXJcIiwgXCJmaWx0ZXJSZXNcIiwgXCJmaWx0ZXJVbml0c1wiLCBcImZsb29kLWNvbG9yXCIsIFwiZmxvb2Qtb3BhY2l0eVwiLCBcImZvY3VzSGlnaGxpZ2h0XCIsIFwiZm9jdXNhYmxlXCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXNpemUtYWRqdXN0XCIsIFwiZm9udC1zdHJldGNoXCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9ybWF0XCIsIFwiZnJcIiwgXCJmcm9tXCIsIFwiZnhcIiwgXCJmeVwiLFxuICAgICAgICBcImcxXCIsIFwiZzJcIiwgXCJnbHlwaC1uYW1lXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCIsIFwiZ2x5cGhSZWZcIiwgXCJncmFkaWVudFRyYW5zZm9ybVwiLCBcImdyYWRpZW50VW5pdHNcIixcbiAgICAgICAgXCJoYW5kbGVyXCIsIFwiaGFuZ2luZ1wiLCBcImhhdGNoQ29udGVudFVuaXRzXCIsIFwiaGF0Y2hVbml0c1wiLCBcImhlaWdodFwiLCBcImhvcml6LWFkdi14XCIsIFwiaG9yaXotb3JpZ2luLXhcIiwgXCJob3Jpei1vcmlnaW4teVwiLCBcImhyZWZcIiwgXCJocmVmbGFuZ1wiLFxuICAgICAgICBcImlkXCIsIFwiaWRlb2dyYXBoaWNcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIiwgXCJpblwiLCBcImluMlwiLCBcImluaXRpYWxWaXNpYmlsaXR5XCIsIFwiaW50ZXJjZXB0XCIsXG4gICAgICAgIFwia1wiLCBcImsxXCIsIFwiazJcIiwgXCJrM1wiLCBcIms0XCIsIFwia2VybmVsTWF0cml4XCIsIFwia2VybmVsVW5pdExlbmd0aFwiLCBcImtlcm5pbmdcIiwgXCJrZXlQb2ludHNcIiwgXCJrZXlTcGxpbmVzXCIsIFwia2V5VGltZXNcIixcbiAgICAgICAgXCJsZW5ndGhBZGp1c3RcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLCBcImxpZ2h0aW5nLWNvbG9yXCIsIFwibGltaXRpbmdDb25lQW5nbGVcIiwgXCJsb2NhbFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIiwgXCJtYXJrZXItbWlkXCIsIFwibWFya2VyLXN0YXJ0XCIsIFwibWFya2VySGVpZ2h0XCIsIFwibWFya2VyVW5pdHNcIiwgXCJtYXJrZXJXaWR0aFwiLCBcIm1hc2tcIiwgXCJtYXNrQ29udGVudFVuaXRzXCIsIFwibWFza1VuaXRzXCIsIFwibWF0aGVtYXRpY2FsXCIsIFwibWF4XCIsIFwibWVkaWFcIiwgXCJtZWRpYUNoYXJhY3RlckVuY29kaW5nXCIsIFwibWVkaWFDb250ZW50RW5jb2RpbmdzXCIsIFwibWVkaWFTaXplXCIsIFwibWVkaWFUaW1lXCIsIFwibWV0aG9kXCIsIFwibWluXCIsIFwibW9kZVwiLFxuICAgICAgICBcIm5hbWVcIiwgXCJuYXYtZG93blwiLCBcIm5hdi1kb3duLWxlZnRcIiwgXCJuYXYtZG93bi1yaWdodFwiLCBcIm5hdi1sZWZ0XCIsIFwibmF2LW5leHRcIiwgXCJuYXYtcHJldlwiLCBcIm5hdi1yaWdodFwiLCBcIm5hdi11cFwiLCBcIm5hdi11cC1sZWZ0XCIsIFwibmF2LXVwLXJpZ2h0XCIsIFwibnVtT2N0YXZlc1wiLFxuICAgICAgICBcIm9ic2VydmVyXCIsIFwib2Zmc2V0XCIsIFwib3BhY2l0eVwiLCBcIm9wZXJhdG9yXCIsIFwib3JkZXJcIiwgXCJvcmllbnRcIiwgXCJvcmllbnRhdGlvblwiLCBcIm9yaWdpblwiLCBcIm92ZXJmbG93XCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCIsXG4gICAgICAgIFwicGFub3NlLTFcIiwgXCJwYXRoXCIsIFwicGF0aExlbmd0aFwiLCBcInBhdHRlcm5Db250ZW50VW5pdHNcIiwgXCJwYXR0ZXJuVHJhbnNmb3JtXCIsIFwicGF0dGVyblVuaXRzXCIsIFwicGhhc2VcIiwgXCJwaXRjaFwiLCBcInBsYXliYWNrT3JkZXJcIiwgXCJwbGF5YmFja29yZGVyXCIsIFwicG9pbnRlci1ldmVudHNcIiwgXCJwb2ludHNcIiwgXCJwb2ludHNBdFhcIiwgXCJwb2ludHNBdFlcIiwgXCJwb2ludHNBdFpcIiwgXCJwcmVzZXJ2ZUFscGhhXCIsIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcInByaW1pdGl2ZVVuaXRzXCIsIFwicHJvcGFnYXRlXCIsXG4gICAgICAgIFwiclwiLCBcInJhZGl1c1wiLCBcInJlZlhcIiwgXCJyZWZZXCIsIFwicmVuZGVyaW5nLWludGVudFwiLCBcInJlcGVhdENvdW50XCIsIFwicmVwZWF0RHVyXCIsIFwicmVxdWlyZWRFeHRlbnNpb25zXCIsIFwicmVxdWlyZWRGZWF0dXJlc1wiLCBcInJlcXVpcmVkRm9udHNcIiwgXCJyZXF1aXJlZEZvcm1hdHNcIiwgXCJyZXN0YXJ0XCIsIFwicmVzdWx0XCIsIFwicm90YXRlXCIsIFwicnhcIiwgXCJyeVwiLFxuICAgICAgICBcInNjYWxlXCIsIFwic2VlZFwiLCBcInNoYXBlLXJlbmRlcmluZ1wiLCBcInNpZGVcIiwgXCJzbG9wZVwiLCBcInNuYXBzaG90VGltZVwiLCBcInNwYWNpbmdcIiwgXCJzcGVjdWxhckNvbnN0YW50XCIsIFwic3BlY3VsYXJFeHBvbmVudFwiLCBcInNwcmVhZE1ldGhvZFwiLCBcInNyY1wiLCBcInN0YXJ0T2Zmc2V0XCIsIFwic3RkRGV2aWF0aW9uXCIsIFwic3RlbWhcIiwgXCJzdGVtdlwiLCBcInN0aXRjaFRpbGVzXCIsIFwic3RvcC1jb2xvclwiLCBcInN0b3Atb3BhY2l0eVwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiLCBcInN0cmluZ1wiLCBcInN0cm9rZVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBcInN0cm9rZS1saW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVqb2luXCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiLCBcInN0eWxlXCIsIFwic3VyZmFjZVNjYWxlXCIsIFwic3luY0JlaGF2aW9yXCIsIFwic3luY0JlaGF2aW9yRGVmYXVsdFwiLCBcInN5bmNNYXN0ZXJcIiwgXCJzeW5jVG9sZXJhbmNlXCIsIFwic3luY1RvbGVyYW5jZURlZmF1bHRcIiwgXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICBcInRhYmxlVmFsdWVzXCIsIFwidGFyZ2V0XCIsIFwidGFyZ2V0WFwiLCBcInRhcmdldFlcIiwgXCJ0ZXh0LWFuY2hvclwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtcmVuZGVyaW5nXCIsIFwidGV4dExlbmd0aFwiLCBcInRpbWVsaW5lQmVnaW5cIiwgXCJ0aW1lbGluZWJlZ2luXCIsIFwidGl0bGVcIiwgXCJ0b1wiLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybUJlaGF2aW9yXCIsIFwidHlwZVwiLFxuICAgICAgICBcInUxXCIsIFwidTJcIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCIsIFwidW5pY29kZVwiLCBcInVuaWNvZGUtYmlkaVwiLCBcInVuaWNvZGUtcmFuZ2VcIiwgXCJ1bml0cy1wZXItZW1cIixcbiAgICAgICAgXCJ2LWFscGhhYmV0aWNcIiwgXCJ2LWhhbmdpbmdcIiwgXCJ2LWlkZW9ncmFwaGljXCIsIFwidi1tYXRoZW1hdGljYWxcIiwgXCJ2YWx1ZXNcIiwgXCJ2ZXJzaW9uXCIsIFwidmVydC1hZHYteVwiLCBcInZlcnQtb3JpZ2luLXhcIiwgXCJ2ZXJ0LW9yaWdpbi15XCIsIFwidmlld0JveFwiLCBcInZpZXdUYXJnZXRcIiwgXCJ2aXNpYmlsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIiwgXCJ3aWR0aHNcIiwgXCJ3b3JkLXNwYWNpbmdcIiwgXCJ3cml0aW5nLW1vZGVcIixcbiAgICAgICAgXCJ4XCIsIFwieC1oZWlnaHRcIiwgXCJ4MVwiLCBcIngyXCIsIFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICBcInlcIiwgXCJ5MVwiLCBcInkyXCIsIFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICBcInpcIiwgXCJ6b29tQW5kUGFuXCJcbiAgICAgIF0sXG4gICAgICBodG1sQXR0cmlidXRlTmFtZXMgPSBbXG4gICAgICAgIFwiYWNjZXB0XCIsIFwiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2Vzc0tleVwiLCBcImFjdGlvblwiLCBcImFsbG93XCIsIFwiYWxsb3dGdWxsU2NyZWVuXCIsIFwiYWxsb3dUcmFuc3BhcmVuY3lcIiwgXCJhbHRcIiwgXCJhc3luY1wiLCBcImF1dG9Db21wbGV0ZVwiLCBcImF1dG9Gb2N1c1wiLCBcImF1dG9QbGF5XCIsXG4gICAgICAgIFwiY2FwdHVyZVwiLCBcImNlbGxQYWRkaW5nXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjaGFsbGVuZ2VcIiwgXCJjaGFyU2V0XCIsIFwiY2hlY2tlZFwiLCBcImNpdGVcIiwgXCJjbGFzc0lEXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sU3BhblwiLCBcImNvbHNcIiwgXCJjb250ZW50XCIsIFwiY29udGVudEVkaXRhYmxlXCIsIFwiY29udGV4dE1lbnVcIiwgXCJjb250cm9sc1wiLCBcImNvb3Jkc1wiLCBcImNyb3NzT3JpZ2luXCIsXG4gICAgICAgIFwiZGF0YVwiLCBcImRhdGVUaW1lXCIsIFwiZGVmYXVsdFwiLCBcImRlZmVyXCIsIFwiZGlyXCIsIFwiZGlzYWJsZWRcIiwgXCJkb3dubG9hZFwiLCBcImRyYWdnYWJsZVwiLFxuICAgICAgICBcImVuY1R5cGVcIixcbiAgICAgICAgXCJmb3JtXCIsIFwiZm9ybUFjdGlvblwiLCBcImZvcm1FbmNUeXBlXCIsIFwiZm9ybU1ldGhvZFwiLCBcImZvcm1Ob1ZhbGlkYXRlXCIsIFwiZm9ybVRhcmdldFwiLCBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgIFwiaGVhZGVyc1wiLCBcImhlaWdodFwiLCBcImhpZGRlblwiLCBcImhpZ2hcIiwgXCJocmVmXCIsIFwiaHJlZkxhbmdcIiwgXCJodG1sRm9yXCIsIFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIFwiaWNvblwiLCBcImlkXCIsIFwiaW5wdXRNb2RlXCIsIFwiaW50ZWdyaXR5XCIsIFwiaXNcIixcbiAgICAgICAgXCJrZXlQYXJhbXNcIiwgXCJrZXlUeXBlXCIsIFwia2luZFwiLFxuICAgICAgICBcImxhYmVsXCIsIFwibGFuZ1wiLCBcImxpc3RcIiwgXCJsb29wXCIsIFwibG93XCIsXG4gICAgICAgIFwibWFuaWZlc3RcIiwgXCJtYXJnaW5IZWlnaHRcIiwgXCJtYXJnaW5XaWR0aFwiLCBcIm1heFwiLCBcIm1heExlbmd0aFwiLCBcIm1lZGlhXCIsIFwibWVkaWFHcm91cFwiLCBcIm1ldGhvZFwiLCBcIm1pblwiLCBcIm1pbkxlbmd0aFwiLCBcIm11bHRpcGxlXCIsIFwibXV0ZWRcIixcbiAgICAgICAgXCJuYW1lXCIsIFwibm9WYWxpZGF0ZVwiLCBcIm5vbmNlXCIsXG4gICAgICAgIFwib3BlblwiLCBcIm9wdGltdW1cIixcbiAgICAgICAgXCJwYXR0ZXJuXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJwb3N0ZXJcIiwgXCJwcmVsb2FkXCIsIFwicHJvZmlsZVwiLFxuICAgICAgICBcInJhZGlvR3JvdXBcIiwgXCJyZWFkT25seVwiLCBcInJlbFwiLCBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJyb2xlXCIsIFwicm93U3BhblwiLCBcInJvd3NcIixcbiAgICAgICAgXCJzYW5kYm94XCIsIFwic2NvcGVcIiwgXCJzY29wZWRcIiwgXCJzY3JvbGxpbmdcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCIsIFwic2hhcGVcIiwgXCJzaXplXCIsIFwic2l6ZXNcIiwgXCJzcGFuXCIsIFwic3BlbGxDaGVja1wiLCBcInNyY1wiLCBcInNyY0RvY1wiLCBcInNyY0xhbmdcIiwgXCJzcmNTZXRcIiwgXCJzdGFydFwiLCBcInN0ZXBcIiwgXCJzdHlsZVwiLCBcInN1bW1hcnlcIixcbiAgICAgICAgXCJ0YWJJbmRleFwiLCBcInRhcmdldFwiLCBcInRpdGxlXCIsIFwidHlwZVwiLFxuICAgICAgICBcInVzZU1hcFwiLFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJ3bW9kZVwiLFxuICAgICAgICBcIndyYXBcIlxuICAgICAgXTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEVsZW1lbnQoZWxlbWVudCwgZG9tRWxlbWVudCkge1xuICBlbGVtZW50LmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG4gIGRvbUVsZW1lbnQuX19lbGVtZW50X18gPSBlbGVtZW50OyAvLy9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgZGVzY2VuZGFudEVsZW1lbnRzID0gZWxlbWVudC5nZXREZXNjZW5kYW50RWxlbWVudHMoKSxcbiAgICAgICAgZWxlbWVudHMgPSBbXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAuLi5kZXNjZW5kYW50RWxlbWVudHNcbiAgICAgICAgXTtcblxuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZ2V0RE9NRWxlbWVudCgpO1xuXG4gICAgZGVsZXRlIGVsZW1lbnQuZG9tRWxlbWVudDtcblxuICAgIGRlbGV0ZSBkb21FbGVtZW50Ll9fZWxlbWVudF9fO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IGRlc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnQuZ2V0RGVzY2VuZGFudEVsZW1lbnRzKCksXG4gICAgICAgIGVsZW1lbnRzID0gW1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgLi4uZGVzY2VuZGFudEVsZW1lbnRzXG4gICAgICAgIF07XG5cbiAgZWxlbWVudHMucmV2ZXJzZSgpOyAvLy9cblxuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgZWxlbWVudC5kaWRNb3VudCAmJiBlbGVtZW50LmRpZE1vdW50KCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudEVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50LmdldERlc2NlbmRhbnRFbGVtZW50cygpLFxuICAgICAgICBlbGVtZW50cyA9IFtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIC4uLmRlc2NlbmRhbnRFbGVtZW50c1xuICAgICAgICBdO1xuXG4gIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICBlbGVtZW50LndpbGxVbm1vdW50ICYmIGVsZW1lbnQud2lsbFVubW91bnQoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29uc3RydWN0RWxlbWVudCxcbiAgZGVzdHJveUVsZW1lbnQsXG4gIG1vdW50RWxlbWVudCxcbiAgdW5tb3VudEVsZW1lbnRcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHB1c2ggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBXSUxEQ0FSRCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGRvbUVsZW1lbnRzKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnRzV2l0aEVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXMoZG9tRWxlbWVudHMsIChkb21FbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKChkb21FbGVtZW50Ll9fZWxlbWVudF9fKSkgeyAvLy9cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGVsZW1lbnRzID0gZG9tRWxlbWVudHNXaXRoRWxlbWVudHMubWFwKChkb21FbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvbUVsZW1lbnQuX19lbGVtZW50X187IC8vL1xuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUoZG9tTm9kZSwgaGVpZ2h0LCBhc2NlbmRhbnRET01Ob2RlcyA9IFtdKSB7XG4gIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IGRvbU5vZGUucGFyZW50RWxlbWVudDsgIC8vL1xuXG4gICAgaWYgKHBhcmVudERPTU5vZGUgIT09IG51bGwpIHtcbiAgICAgIGFzY2VuZGFudERPTU5vZGVzLnB1c2gocGFyZW50RE9NTm9kZSk7XG5cbiAgICAgIGhlaWdodC0tO1xuXG4gICAgICBhc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKHBhcmVudERPTU5vZGUsIGhlaWdodCwgYXNjZW5kYW50RE9NTm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhc2NlbmRhbnRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoLCBkZXNjZW5kYW50RE9NTm9kZXMgPSBbXSkge1xuICBpZiAoZGVwdGggPiAwKSB7XG4gICAgY29uc3QgY2hpbGRET01Ob2RlcyA9IGRvbU5vZGUuY2hpbGROb2RlczsgIC8vL1xuXG4gICAgcHVzaChkZXNjZW5kYW50RE9NTm9kZXMsIGNoaWxkRE9NTm9kZXMpO1xuXG4gICAgZGVwdGgtLTtcblxuICAgIGNoaWxkRE9NTm9kZXMuZm9yRWFjaCgoY2hpbGRET01Ob2RlKSA9PiB7XG4gICAgICBkZXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShjaGlsZERPTU5vZGUsIGRlcHRoLCBkZXNjZW5kYW50RE9NTm9kZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzQnlTZWxlY3Rvcihkb21Ob2Rlcywgc2VsZWN0b3IpIHtcbiAgY29uc3QgZmlsdGVyZWRET01Ob2RlcyA9IGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCAoZG9tTm9kZSkgPT4ge1xuICAgIGlmIChkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKGRvbU5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvbU5vZGVNYXRjaGVzU2VsZWN0b3IoZG9tTm9kZSwgc2VsZWN0b3IpIHtcbiAgY29uc3QgZG9tTm9kZVR5cGUgPSBkb21Ob2RlLm5vZGVUeXBlOyAvLy9cblxuICBzd2l0Y2ggKGRvbU5vZGVUeXBlKSB7XG4gICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvbU5vZGU7IC8vL1xuXG4gICAgICByZXR1cm4gZG9tRWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCB0ZXN0KSB7XG4gIGNvbnN0IGZpbHRlcmVkRE9NTm9kZXMgPSBbXSxcbiAgICAgICAgZG9tTm9kZXNMZW5ndGggPSBkb21Ob2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRvbU5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZG9tTm9kZSA9IGRvbU5vZGVzW2luZGV4XSxcbiAgICAgICAgICByZXN1bHQgPSB0ZXN0KGRvbU5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgZmlsdGVyZWRET01Ob2Rlcy5wdXNoKGRvbU5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZERPTU5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFdJTERDQVJEIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG9tTm9kZU1hdGNoZXNTZWxlY3RvciwgZWxlbWVudHNGcm9tRE9NRWxlbWVudHMsIGZpbHRlckRPTU5vZGVzQnlTZWxlY3RvciwgYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZSwgZGVzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2RvbVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwYXJlbnRFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwYXJlbnRET01FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7IC8vL1xuXG4gIGlmIChwYXJlbnRET01FbGVtZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKHBhcmVudERPTUVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgIGNvbnN0IHBhcmVudERPTUVsZW1lbnRzID0gW1xuICAgICAgICAgICAgICBwYXJlbnRET01FbGVtZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGFyZW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhwYXJlbnRET01FbGVtZW50cyksXG4gICAgICAgICAgICBmaXJzdFBhcmVudEVsZW1lbnQgPSBmaXJzdChwYXJlbnRFbGVtZW50cyk7XG5cbiAgICAgIHBhcmVudEVsZW1lbnQgPSBmaXJzdFBhcmVudEVsZW1lbnQgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50RWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkRWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBjb25zdCBjaGlsZERPTU5vZGVzID0gdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXMsIC8vL1xuICAgICAgICBjaGlsZERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGNoaWxkRE9NTm9kZXMsIHNlbGVjdG9yKSxcbiAgICAgICAgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGNoaWxkRE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBjaGlsZEVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bUhlaWdodCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IGhlaWdodCA9IG1heGltdW1IZWlnaHQsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGFzY2VuZGFudERPTU5vZGVzID0gYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShkb21Ob2RlLCBoZWlnaHQpLFxuICAgICAgICBhc2NlbmRhbnRET01FbGVtZW50cyA9IGZpbHRlckRPTU5vZGVzQnlTZWxlY3Rvcihhc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBhc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGFzY2VuZGFudERPTUVsZW1lbnRzKTtcblxuICByZXR1cm4gYXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bURlcHRoID0gSW5maW5pdHkpIHtcbiAgY29uc3QgZGVwdGggPSBtYXhpbXVtRGVwdGgsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGRlc2NlbmRhbnRET01Ob2RlcyA9IGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoKSxcbiAgICAgICAgZGVzY2VuZGFudERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGRlc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhkZXNjZW5kYW50RE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBkZXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0U2libGluZ0VsZW1lbnQoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBsZXQgbmV4dFNpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBuZXh0U2libGluZ0RPTU5vZGUgPSB0aGlzLmRvbUVsZW1lbnQubmV4dFNpYmxpbmc7IC8vL1xuXG4gIGlmICgobmV4dFNpYmxpbmdET01Ob2RlICE9PSBudWxsKSAmJiBkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKG5leHRTaWJsaW5nRE9NTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgbmV4dFNpYmxpbmdFbGVtZW50ID0gbmV4dFNpYmxpbmdET01Ob2RlLl9fZWxlbWVudF9fIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gbmV4dFNpYmxpbmdFbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwcmV2aW91c1NpYmxpbmdET01Ob2RlID0gdGhpcy5kb21FbGVtZW50LnByZXZpb3VzU2libGluZzsgIC8vL1xuXG4gIGlmICgocHJldmlvdXNTaWJsaW5nRE9NTm9kZSAhPT0gbnVsbCkgJiYgZG9tTm9kZU1hdGNoZXNTZWxlY3RvcihwcmV2aW91c1NpYmxpbmdET01Ob2RlLCBzZWxlY3RvcikpIHtcbiAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gcHJldmlvdXNTaWJsaW5nRE9NTm9kZS5fX2VsZW1lbnRfXyB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzU2libGluZ0VsZW1lbnQ7XG59XG5cbmNvbnN0IGVsZW1lbnRNaXhpbnMgPSB7XG4gIGdldFBhcmVudEVsZW1lbnQsXG4gIGdldENoaWxkRWxlbWVudHMsXG4gIGdldEFzY2VuZGFudEVsZW1lbnRzLFxuICBnZXREZXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudE1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE9mZnNldCBmcm9tIFwiLi9vZmZzZXRcIjtcbmltcG9ydCBCb3VuZHMgZnJvbSBcIi4vYm91bmRzXCI7XG5cbmltcG9ydCB7IGNvbnN0cnVjdEVsZW1lbnQsIGRlc3Ryb3lFbGVtZW50IH0gZnJvbSBcIi4vdXRpbGl0aWVzL2VsZW1lbnRcIjtcbmltcG9ydCB7IGdldFBhcmVudEVsZW1lbnQsIGdldEFzY2VuZGFudEVsZW1lbnRzLCBnZXROZXh0U2libGluZ0VsZW1lbnQsIGdldFByZXZpb3VzU2libGluZ0VsZW1lbnQgfSBmcm9tIFwiLi9taXhpbnMvZWxlbWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcywgLy8vXG4gICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpOyAvLy9cblxuICAgIGNvbnN0cnVjdEVsZW1lbnQoZWxlbWVudCwgZG9tRWxlbWVudCk7XG4gIH1cblxuICBnZXRET01FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gT2Zmc2V0LmZyb21ET01FbGVtZW50KHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IEJvdW5kcy5mcm9tRE9NRWxlbWVudCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50Lm9mZnNldFdpZHRoOyB9ICAvLy9cblxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyB9ICAvLy9cblxuICBnZXRUZXh0KCkge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuZG9tRWxlbWVudC5ub2RlVmFsdWUsXG4gICAgICAgICAgdGV4dCA9IG5vZGVWYWx1ZTsgLy8vXG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHNldFRleHQodGV4dCkge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRleHQ7IC8vL1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lm5vZGVWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIGFwcGVuZFRvKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5hcHBlbmQodGhpcyk7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgcmVtb3ZlRnJvbShwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucmVtb3ZlKHRoaXMpOyB9XG5cbiAgaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSwgLy8vXG4gICAgICAgICAgc2libGluZ0RPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSwgLy8vXG4gICAgICAgICAgc2libGluZ0RPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50Lm5leHRTaWJsaW5nKTsgIC8vL1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgZGVzdHJveUVsZW1lbnQoZWxlbWVudCk7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0RWxlbWVudC5wcm90b3R5cGUsIHtcbiAgZ2V0UGFyZW50RWxlbWVudCxcbiAgZ2V0QXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0RWxlbWVudCBmcm9tIFwiLi4vdGV4dEVsZW1lbnRcIjtcblxuaW1wb3J0IHsgU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmFsc2V5RWxlbWVudHMoZWxlbWVudHMpIHtcbiAgZWxlbWVudHMgPSBlbGVtZW50cy5yZWR1Y2UoKGVsZW1lbnRzLCBlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gIGVsZW1lbnRzID0gZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiB7ICAvLy9cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFNUUklORykge1xuICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQsICAvLy9cbiAgICAgICAgICAgIHRleHRFbGVtZW50ID0gbmV3IFRleHRFbGVtZW50KHRleHQpO1xuXG4gICAgICBlbGVtZW50ID0gdGV4dEVsZW1lbnQ7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcblxuICByZXR1cm4gZWxlbWVudHM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDVVRfRVZFTlRfVFlQRSA9IFwiY3V0XCI7XG5leHBvcnQgY29uc3QgQ09QWV9FVkVOVF9UWVBFID0gXCJjb3B5XCI7XG5leHBvcnQgY29uc3QgQkxVUl9FVkVOVF9UWVBFID0gXCJibHVyXCI7XG5leHBvcnQgY29uc3QgRVJST1JfRVZFTlRfVFlQRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBQQVNURV9FVkVOVF9UWVBFID0gXCJwYXN0ZVwiO1xuZXhwb3J0IGNvbnN0IFdIRUVMX0VWRU5UX1RZUEUgPSBcIndoZWVsXCI7XG5leHBvcnQgY29uc3QgSU5QVVRfRVZFTlRfVFlQRSA9IFwiaW5wdXRcIjtcbmV4cG9ydCBjb25zdCBGT0NVU19FVkVOVF9UWVBFID0gXCJmb2N1c1wiO1xuZXhwb3J0IGNvbnN0IENMSUNLX0VWRU5UX1RZUEUgPSBcImNsaWNrXCI7XG5leHBvcnQgY29uc3QgS0VZVVBfRVZFTlRfVFlQRSA9IFwia2V5dXBcIjtcbmV4cG9ydCBjb25zdCBTRUxFQ1RfRVZFTlRfVFlQRSA9IFwic2VsZWN0XCI7XG5leHBvcnQgY29uc3QgQ0hBTkdFX0VWRU5UX1RZUEUgPSBcImNoYW5nZVwiO1xuZXhwb3J0IGNvbnN0IFJFU0laRV9FVkVOVF9UWVBFID0gXCJyZXNpemVcIjtcbmV4cG9ydCBjb25zdCBTQ1JPTExfRVZFTlRfVFlQRSA9IFwic2Nyb2xsXCI7XG5leHBvcnQgY29uc3QgS0VZRE9XTl9FVkVOVF9UWVBFID0gXCJrZXlkb3duXCI7XG5leHBvcnQgY29uc3QgTU9VU0VVUF9FVkVOVF9UWVBFID0gXCJtb3VzZXVwXCI7XG5leHBvcnQgY29uc3QgQVVYQ0xJQ0tfRVZFTlRfVFlQRSA9IFwiYXV4Y2xpY2tcIjtcbmV4cG9ydCBjb25zdCBNT1VTRU9VVF9FVkVOVF9UWVBFID0gXCJtb3VzZW91dFwiO1xuZXhwb3J0IGNvbnN0IERCTENMSUNLX0VWRU5UX1RZUEUgPSBcImRibGNsaWNrXCI7XG5leHBvcnQgY29uc3QgVE9VQ0hFTkRfRVZFTlRfVFlQRSA9IFwidG91Y2hlbmRcIjtcbmV4cG9ydCBjb25zdCBUT1VDSE1PVkVfRVZFTlRfVFlQRSA9IFwidG91Y2htb3ZlXCI7XG5leHBvcnQgY29uc3QgTU9VU0VPVkVSX0VWRU5UX1RZUEUgPSBcIm1vdXNlb3ZlclwiO1xuZXhwb3J0IGNvbnN0IE1PVVNFRE9XTl9FVkVOVF9UWVBFID0gXCJtb3VzZWRvd25cIjtcbmV4cG9ydCBjb25zdCBNT1VTRU1PVkVfRVZFTlRfVFlQRSA9IFwibW91c2Vtb3ZlXCI7XG5leHBvcnQgY29uc3QgVE9VQ0hTVEFSVF9FVkVOVF9UWVBFID0gXCJ0b3VjaHN0YXJ0XCI7XG5leHBvcnQgY29uc3QgQ09OVEVYVE1FTlVfRVZFTlRfVFlQRSA9IFwiY29udGV4dG1lbnVcIjtcbmV4cG9ydCBjb25zdCBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRSA9IFwic2VsZWN0aW9uY2hhbmdlXCI7XG5leHBvcnQgY29uc3QgRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFID0gXCJmdWxsc2NyZWVuY2hhbmdlXCI7XG5leHBvcnQgY29uc3QgVU5IQU5ETEVEUkVKRUNUSU9OX0VWRU5UX1RZUEUgPSBcInVuaGFuZGxlZHJlamVjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIENVVF9FVkVOVF9UWVBFLFxuICBDT1BZX0VWRU5UX1RZUEUsXG4gIEJMVVJfRVZFTlRfVFlQRSxcbiAgRVJST1JfRVZFTlRfVFlQRSxcbiAgUEFTVEVfRVZFTlRfVFlQRSxcbiAgV0hFRUxfRVZFTlRfVFlQRSxcbiAgSU5QVVRfRVZFTlRfVFlQRSxcbiAgRk9DVVNfRVZFTlRfVFlQRSxcbiAgQ0xJQ0tfRVZFTlRfVFlQRSxcbiAgS0VZVVBfRVZFTlRfVFlQRSxcbiAgU0VMRUNUX0VWRU5UX1RZUEUsXG4gIENIQU5HRV9FVkVOVF9UWVBFLFxuICBSRVNJWkVfRVZFTlRfVFlQRSxcbiAgU0NST0xMX0VWRU5UX1RZUEUsXG4gIEtFWURPV05fRVZFTlRfVFlQRSxcbiAgTU9VU0VVUF9FVkVOVF9UWVBFLFxuICBBVVhDTElDS19FVkVOVF9UWVBFLFxuICBNT1VTRU9VVF9FVkVOVF9UWVBFLFxuICBEQkxDTElDS19FVkVOVF9UWVBFLFxuICBUT1VDSEVORF9FVkVOVF9UWVBFLFxuICBUT1VDSE1PVkVfRVZFTlRfVFlQRSxcbiAgTU9VU0VPVkVSX0VWRU5UX1RZUEUsXG4gIE1PVVNFRE9XTl9FVkVOVF9UWVBFLFxuICBNT1VTRU1PVkVfRVZFTlRfVFlQRSxcbiAgVE9VQ0hTVEFSVF9FVkVOVF9UWVBFLFxuICBDT05URVhUTUVOVV9FVkVOVF9UWVBFLFxuICBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRSxcbiAgRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFLFxuICBVTkhBTkRMRURSRUpFQ1RJT05fRVZFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VhcmFudGVlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgY29tYmluZSwgcHJ1bmUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL29iamVjdFwiO1xuaW1wb3J0IHsgY2FtZWxDYXNlVG9TbmFrZUNhc2UgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgaXNIVE1MQXR0cmlidXRlTmFtZSwgaXNTVkdBdHRyaWJ1dGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9uYW1lXCI7XG5pbXBvcnQgeyByZW1vdmVGYWxzZXlFbGVtZW50cywgcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9lbGVtZW50c1wiO1xuaW1wb3J0IHsgREJMQ0xJQ0tfRVZFTlRfVFlQRSwgU0VMRUNUSU9OQ0hBTkdFX0VWRU5UX1RZUEUsIEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5pbXBvcnQgeyBGT1IsIENMQVNTLCBPQkpFQ1QsIEhUTUxfRk9SLCBDTEFTU19OQU1FLCBCT09MRUFOLCBGVU5DVElPTiwgU1ZHX05BTUVTUEFDRV9VUkkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IERPVUJMRV9DTElDS19FVkVOVF9UWVBFID0gXCJkb3VibGVjbGlja1wiLFxuICAgICAgU0VMRUNUSU9OX0NIQU5HRV9FVkVOVF9UWVBFID0gXCJzZWxlY3Rpb25DaGFuZ2VcIixcbiAgICAgIEZVTExfU0NSRUVOX0NIQU5HRV9FVkVOVF9UWVBFID0gXCJmdWxsU2NyZWVuQ2hhbmdlXCI7XG5cbmZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gY29tYmluZShwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcyk7XG5cbiAgcHJvcGVydGllcyA9IHBydW5lKHRoaXMucHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpOyAvLy9cblxuICBjb25zdCBuYW1lc3BhY2VVUkkgPSB0aGlzLmRvbUVsZW1lbnQubmFtZXNwYWNlVVJJLFxuICAgICAgICBzdmcgPSAobmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFX1VSSSksIC8vL1xuICAgICAgICBwcm9wZXJ0aWVzS2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLFxuICAgICAgICBuYW1lcyA9IHByb3BlcnRpZXNLZXlzOyAgLy8vPVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbbmFtZV0sXG4gICAgICAgICAgbmFtZUhhbmRsZXJOYW1lID0gaXNOYW1lSGFuZGxlck5hbWUobmFtZSksXG4gICAgICAgICAgbmFtZUN1c3RvbUhhbmRsZXJOYW1lID0gaXNOYW1lQ3VzdG9tSGFuZGxlck5hbWUobmFtZSk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobmFtZUhhbmRsZXJOYW1lKSB7XG4gICAgICBhZGRIYW5kbGVyKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWVDdXN0b21IYW5kbGVyTmFtZSkge1xuICAgICAgYWRkQ3VzdG9tSGFuZGxlcih0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVBdHRyaWJ1dGVOYW1lID0gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpO1xuXG4gICAgICBpZiAobmFtZUF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgYWRkQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGNoaWxkRWxlbWVudHMgPSBjaGlsZEVsZW1lbnRzRnJvbUVsZW1lbnQodGhpcykgfHwgcHJvcGVydGllcy5jaGlsZEVsZW1lbnRzLCAgLy8vXG4gICAgICAgIGNvbnRleHQgPSB7fTtcblxuICBjaGlsZEVsZW1lbnRzLmZvckVhY2goKGNoaWxkRWxlbWVudCkgPT4ge1xuICAgIHVwZGF0ZUNvbnRleHQoY2hpbGRFbGVtZW50LCBjb250ZXh0KTtcblxuICAgIHRoaXMuYWRkKGNoaWxkRWxlbWVudCk7XG4gIH0pO1xuXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXMoKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNvbnRleHQobmFtZXMpIHtcbiAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29udGV4dClcbiAgfVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29udGV4dFtuYW1lXSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBuYW1lLCAgLy8vXG4gICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRbbmFtZV07XG4gIH0pO1xufVxuXG5jb25zdCBqc3hNaXhpbnMgPSB7XG4gIGFwcGx5UHJvcGVydGllcyxcbiAgZ2V0UHJvcGVydGllcyxcbiAgZ2V0Q29udGV4dCxcbiAgYXNzaWduQ29udGV4dFxufTtcblxuZXhwb3J0IGRlZmF1bHQganN4TWl4aW5zO1xuXG5mdW5jdGlvbiBjaGlsZEVsZW1lbnRzRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICBsZXQgY2hpbGRFbGVtZW50cyA9IG51bGw7XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50LmNoaWxkRWxlbWVudHMgPT09IEZVTkNUSU9OKSB7XG4gICAgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnQuY2hpbGRFbGVtZW50cy5jYWxsKGVsZW1lbnQpO1xuXG4gICAgY2hpbGRFbGVtZW50cyA9IGd1YXJhbnRlZShjaGlsZEVsZW1lbnRzKTtcblxuICAgIGNoaWxkRWxlbWVudHMgPSByZW1vdmVGYWxzZXlFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTtcblxuICAgIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRFbGVtZW50cztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChjaGlsZEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9ICh0eXBlb2YgY2hpbGRFbGVtZW50LnBhcmVudENvbnRleHQgPT09IEZVTkNUSU9OKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudC5wYXJlbnRDb250ZXh0KCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudC5jb250ZXh0OyAvLy9cblxuICBPYmplY3QuYXNzaWduKGNvbnRleHQsIHBhcmVudENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGxldCBldmVudFR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpOyAvLy9cblxuICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgIGNhc2UgRE9VQkxFX0NMSUNLX0VWRU5UX1RZUEU6IHtcbiAgICAgIGV2ZW50VHlwZSA9IERCTENMSUNLX0VWRU5UX1RZUEU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgU0VMRUNUSU9OX0NIQU5HRV9FVkVOVF9UWVBFOiB7XG4gICAgICBldmVudFR5cGUgPSBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBGVUxMX1NDUkVFTl9DSEFOR0VfRVZFTlRfVFlQRToge1xuICAgICAgZXZlbnRUeXBlID0gRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZXIgPSB2YWx1ZTsgIC8vL1xuXG4gIGVsZW1lbnQub25FdmVudChldmVudFR5cGUsIGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRDdXN0b21IYW5kbGVyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IGNhbWVsQ2FzZVRvU25ha2VDYXNlKG5hbWUpLnJlcGxhY2UoL29uLWN1c3RvbS0vLCBcIlwiKSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHZhbHVlOyAgLy8vXG5cbiAgZWxlbWVudC5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBpZiAobmFtZSA9PT0gQ0xBU1NfTkFNRSkge1xuICAgIG5hbWUgPSBDTEFTUztcbiAgfVxuXG4gIGlmIChuYW1lID09PSBIVE1MX0ZPUikge1xuICAgIG5hbWUgPSBGT1I7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBPQkpFQ1QpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtuYW1lXVtrZXldID0gdmFsdWVba2V5XTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IEJPT0xFQU4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmFtZTsgLy8vXG5cbiAgICAgIGVsZW1lbnQuYWRkQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5hZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTmFtZUhhbmRsZXJOYW1lKG5hbWUpIHtcbiAgY29uc3QgbmFtZUhhbmRsZXJOYW1lID0gIC9eb24oPyFDdXN0b20pLy50ZXN0KG5hbWUpOyAgLy8vXG5cbiAgcmV0dXJuIG5hbWVIYW5kbGVyTmFtZTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpIHtcbiAgY29uc3QgbmFtZUF0dHJpYnV0ZU5hbWUgPSBzdmcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NWR0F0dHJpYnV0ZU5hbWUobmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSFRNTEF0dHJpYnV0ZU5hbWUobmFtZSk7XG5cbiAgcmV0dXJuIG5hbWVBdHRyaWJ1dGVOYW1lO1xufVxuXG5mdW5jdGlvbiBpc05hbWVDdXN0b21IYW5kbGVyTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVDdXN0b21IYW5kbGVyTmFtZSA9IC9eb25DdXN0b20vLnRlc3QobmFtZSk7XG5cbiAgcmV0dXJuIG5hbWVDdXN0b21IYW5kbGVyTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgS0VZVVBfRVZFTlRfVFlQRSwgS0VZRE9XTl9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25LZXlVcChrZXlVcEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEtFWVVQX0VWRU5UX1RZUEUsIGtleVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmS2V5VXAoa2V5VXBIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoS0VZVVBfRVZFTlRfVFlQRSwga2V5VXBIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEtFWURPV05fRVZFTlRfVFlQRSwga2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChLRVlET1dOX0VWRU5UX1RZUEUsIGtleURvd25IYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5jb25zdCBrZXlNaXhpbnMgPSB7XG4gIG9uS2V5VXAsXG4gIG9mZktleVVwLFxuICBvbktleURvd24sXG4gIG9mZktleURvd25cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtleU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlO1xufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICh0aGlzLnN0YXRlID09PSB1bmRlZmluZWQpID9cbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgOlxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCBzdGF0ZSk7XG59XG5cbmNvbnN0IHN0YXRlTWl4aW5zID0ge1xuICBnZXRTdGF0ZSxcbiAgc2V0U3RhdGUsXG4gIHVwZGF0ZVN0YXRlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdGF0ZU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgU1BBQ0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBSRVNJWkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uRXZlbnQoZXZlbnRUeXBlcywgaGFuZGxlciwgZWxlbWVudCA9IHRoaXMpIHtcbiAgZXZlbnRUeXBlcyA9IGV2ZW50VHlwZXMuc3BsaXQoU1BBQ0UpOyAvLy9cblxuICBldmVudFR5cGVzLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgIGlmIChldmVudFR5cGUgPT09IFJFU0laRV9FVkVOVF9UWVBFKSB7XG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc2l6ZUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kRXZlbnRMaXN0ZW5lcnMoUkVTSVpFX0VWRU5UX1RZUEUpO1xuXG4gICAgICAgICAgcmVzaXplRXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgocmVzaXplRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICByZXNpemVFdmVudExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tRWxlbWVudClcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZFdmVudChldmVudFR5cGVzLCBoYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBldmVudFR5cGVzID0gZXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGV2ZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gUkVTSVpFX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICBkZWxldGUgdGhpcy5yZXNpemVPYnNlcnZlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gIH1cblxuICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmZpbmRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCksXG4gICAgICAgIGluZGV4ID0gdGhpcy5ldmVudExpc3RlbmVycy5pbmRleE9mKGV2ZW50TGlzdGVuZXIpLFxuICAgICAgICBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gMTtcblxuICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB0aGlzLmV2ZW50TGlzdGVuZXJzO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGZpbmRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVycy5maW5kKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgaWYgKChldmVudExpc3RlbmVyLmVsZW1lbnQgPT09IGVsZW1lbnQpICYmIChldmVudExpc3RlbmVyLmhhbmRsZXIgPT09IGhhbmRsZXIpICYmIChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmluZEV2ZW50TGlzdGVuZXJzKGV2ZW50VHlwZSkge1xuICBjb25zdCBldmVudExpc3RlbmVycyA9IFtdO1xuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgICBjb25zdCBmb3VuZCA9IChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKTtcblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGxldCBldmVudExpc3RlbmVyO1xuXG4gIGNvbnN0IGhhbmRsZXJFbGVtZW50ID0gZWxlbWVudDsgLy8vXG5cbiAgZXZlbnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oZXZlbnRMaXN0ZW5lciwge1xuICAgIGVsZW1lbnQsXG4gICAgaGFuZGxlcixcbiAgICBldmVudFR5cGVcbiAgfSk7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmNvbnN0IGV2ZW50TWl4aW5zID0ge1xuICBvbkV2ZW50LFxuICBvZmZFdmVudCxcbiAgYWRkRXZlbnRMaXN0ZW5lcixcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcixcbiAgZmluZEV2ZW50TGlzdGVuZXIsXG4gIGZpbmRFdmVudExpc3RlbmVycyxcbiAgY3JlYXRlRXZlbnRMaXN0ZW5lclxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXZlbnRNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE1PVVNFVVBfRVZFTlRfVFlQRSwgTU9VU0VPVVRfRVZFTlRfVFlQRSwgTU9VU0VET1dOX0VWRU5UX1RZUEUsIE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBNT1VTRU1PVkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoTU9VU0VVUF9FVkVOVF9UWVBFLCBtb3VzZVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFVVBfRVZFTlRfVFlQRSwgbW91c2VVcEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdXQobW91c2VPdXRIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChNT1VTRU9VVF9FVkVOVF9UWVBFLCBtb3VzZU91dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFT1VUX0VWRU5UX1RZUEUsIG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBtb3VzZU92ZXJIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZNb3VzZU92ZXIobW91c2VPdmVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBtb3VzZU92ZXJIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbk1vdXNlTW92ZShtb3VzZU1vdmVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuY29uc3QgbW91c2VNaXhpbnMgPSB7XG4gIG9uTW91c2VVcCxcbiAgb2ZmTW91c2VVcCxcbiAgb25Nb3VzZU91dCxcbiAgb2ZmTW91c2VPdXQsXG4gIG9uTW91c2VEb3duLFxuICBvZmZNb3VzZURvd24sXG4gIG9uTW91c2VPdmVyLFxuICBvZmZNb3VzZU92ZXIsXG4gIG9uTW91c2VNb3ZlLFxuICBvZmZNb3VzZU1vdmVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdXNlTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDTElDS19FVkVOVF9UWVBFLCBEQkxDTElDS19FVkVOVF9UWVBFLCBBVVhDTElDS19FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25DbGljayhjbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KENMSUNLX0VWRU5UX1RZUEUsIGNsaWNrSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ2xpY2soY2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoQ0xJQ0tfRVZFTlRfVFlQRSwgY2xpY2tIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbkF1eENsaWNrKGF1eENsaWNrSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQVVYQ0xJQ0tfRVZFTlRfVFlQRSwgYXV4Q2xpY2tIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZBdXhDbGljayhhdXhDbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChBVVhDTElDS19FVkVOVF9UWVBFLCBhdXhDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZG91YmxlQ2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChEQkxDTElDS19FVkVOVF9UWVBFLCBkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9IC8vL1xuXG5mdW5jdGlvbiBvZmZEb3VibGVDbGljayhkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChEQkxDTElDS19FVkVOVF9UWVBFLCBkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9IC8vL1xuXG5jb25zdCBjbGlja01peGlucyA9IHtcbiAgb25DbGljayxcbiAgb2ZmQ2xpY2ssXG4gIG9uQXV4Q2xpY2ssXG4gIG9mZkF1eENsaWNrLFxuICBvbkRvdWJsZUNsaWNrLFxuICBvZmZEb3VibGVDbGlja1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpY2tNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFRPVUNIU1RBUlRfRVZFTlRfVFlQRSwgVE9VQ0hNT1ZFX0VWRU5UX1RZUEUsIFRPVUNIRU5EX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vbkV2ZW50KFRPVUNIU1RBUlRfRVZFTlRfVFlQRSwgdG91Y2hTdGFydEhhbmRsZXIpOyB9XG5cbmZ1bmN0aW9uIG9mZlRvdWNoU3RhcnQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vZmZFdmVudChUT1VDSFNUQVJUX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvblRvdWNoTW92ZSh0b3VjaFN0YXJ0SGFuZGxlcikgeyB0aGlzLm9uRXZlbnQoVE9VQ0hNT1ZFX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvZmZUb3VjaE1vdmUodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vZmZFdmVudChUT1VDSE1PVkVfRVZFTlRfVFlQRSwgdG91Y2hTdGFydEhhbmRsZXIpOyB9XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vbkV2ZW50KFRPVUNIRU5EX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvZmZUb3VjaEVuZCh0b3VjaFN0YXJ0SGFuZGxlcikgeyB0aGlzLm9mZkV2ZW50KFRPVUNIRU5EX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5jb25zdCBjbGlja01peGlucyA9IHtcbiAgb25Ub3VjaFN0YXJ0LFxuICBvZmZUb3VjaFN0YXJ0LFxuICBvblRvdWNoTW92ZSxcbiAgb2ZmVG91Y2hNb3ZlLFxuICBvblRvdWNoRW5kLFxuICBvZmZUb3VjaEVuZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpY2tNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNDUk9MTF9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9uU2Nyb2xsKHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KFNDUk9MTF9FVkVOVF9UWVBFLCBzY3JvbGxIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZmU2Nyb2xsKHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChTQ1JPTExfRVZFTlRfVFlQRSwgc2Nyb2xsSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0KSB7IHRoaXMuZG9tRWxlbWVudC5zY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApOyB9IC8vL1xuXG5mdW5jdGlvbiBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsVG9wOyB9XG5cbmZ1bmN0aW9uIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsTGVmdDsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxXaWR0aCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5zY3JvbGxXaWR0aDsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsSGVpZ2h0OyB9XG5cbmZ1bmN0aW9uIHNldFNjcm9sbFRvcChzY3JvbGxUb3ApIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDsgfVxuXG5mdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KHNjcm9sbExlZnQpIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0OyB9XG5cbmNvbnN0IHNjcm9sbE1peGlucyA9IHtcbiAgb25TY3JvbGwsXG4gIG9mZlNjcm9sbCxcbiAgc2Nyb2xsVG8sXG4gIGdldFNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsTGVmdCxcbiAgZ2V0U2Nyb2xsV2lkdGgsXG4gIGdldFNjcm9sbEhlaWdodCxcbiAgc2V0U2Nyb2xsVG9wLFxuICBzZXRTY3JvbGxMZWZ0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzY3JvbGxNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJFU0laRV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25SZXNpemUocmVzaXplSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmNvbnN0IHJlc2l6ZU1peGlucyA9IHtcbiAgb25SZXNpemUsXG4gIG9mZlJlc2l6ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVzaXplTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBGVUxMU0NSRUVOQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbkZ1bGxTY3JlZW5DaGFuZ2UoZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSwgZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9ICAvLy9cblxuZnVuY3Rpb24gb2ZmRnVsbFNjcmVlbkNoYW5nZShmdWxsU2NyZWVuQ2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSwgZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9ICAvLy9cblxuZnVuY3Rpb24gcmVxdWVzdEZ1bGxTY3JlZW4oZXJyb3JIYW5kbGVyKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB0aGlzLmdldERPTUVsZW1lbnQoKTtcblxuICBkb21FbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gZXhpdEZ1bGxTY3JlZW4oKSB7XG4gIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVsbFNjcmVlbigpIHtcbiAgY29uc3QgeyBmdWxsc2NyZWVuRWxlbWVudCB9ID0gZG9jdW1lbnQsXG4gICAgICAgIGZ1bGxTY3JlZW4gPSAoZnVsbHNjcmVlbkVsZW1lbnQgIT09IG51bGwpO1xuXG4gIHJldHVybiBmdWxsU2NyZWVuO1xufVxuXG5jb25zdCBmdWxsc2NyZWVuTWl4aW5zID0ge1xuICBvbkZ1bGxTY3JlZW5DaGFuZ2UsXG4gIG9mZkZ1bGxTY3JlZW5DaGFuZ2UsXG4gIHJlcXVlc3RGdWxsU2NyZWVuLFxuICBleGl0RnVsbFNjcmVlbixcbiAgaXNGdWxsU2NyZWVuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdWxsc2NyZWVuTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChhcnJheSwgb3BlcmF0aW9uLCBkb25lLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xuXG4gIGxldCBjb3VudCA9IC0xO1xuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgY291bnQrKztcblxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xuICAgICAgICAgICAgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNQQUNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNcIjtcblxuZnVuY3Rpb24gb25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGVzLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBjdXN0b21FdmVudFR5cGVzID0gY3VzdG9tRXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGN1c3RvbUV2ZW50VHlwZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnRUeXBlKSA9PiB7XG4gICAgdGhpcy5hZGRDdXN0b21FdmVudExpc3RlbmVyKGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGVzLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBjdXN0b21FdmVudFR5cGVzID0gY3VzdG9tRXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGN1c3RvbUV2ZW50VHlwZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnRUeXBlKSA9PiB7XG4gICAgdGhpcy5yZW1vdmVDdXN0b21FdmVudExpc3RlbmVyKGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQ3VzdG9tSGFuZGxlcnMoY3VzdG9tRXZlbnRUeXBlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmZpbmRDdXN0b21FdmVudExpc3RlbmVycyhjdXN0b21FdmVudFR5cGUpO1xuXG4gIGN1c3RvbUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQ6IGN1c3RvbUhhbmRsZXJFbGVtZW50IH0gPSBjdXN0b21FdmVudExpc3RlbmVyOyAvLy9cblxuICAgIGN1c3RvbUhhbmRsZXIuY2FsbChjdXN0b21IYW5kbGVyRWxlbWVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxDdXN0b21IYW5kbGVyc0FzeW5jKGN1c3RvbUV2ZW50VHlwZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMoY3VzdG9tRXZlbnRUeXBlKSxcbiAgICAgICAgZG9uZSA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKTsgIC8vL1xuXG4gIGZvckVhY2goY3VzdG9tRXZlbnRMaXN0ZW5lcnMsIChjdXN0b21FdmVudExpc3RlbmVyLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b21IYW5kbGVyLCBlbGVtZW50OiBjdXN0b21IYW5kbGVyRWxlbWVudCB9ID0gY3VzdG9tRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgICBkb25lID0gbmV4dDsgIC8vL1xuXG4gICAgY3VzdG9tSGFuZGxlci5jYWxsKGN1c3RvbUhhbmRsZXJFbGVtZW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMsIGRvbmUpO1xuICB9LCBkb25lKTtcbn1cblxuZnVuY3Rpb24gYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lciA9IHRoaXMuY3JlYXRlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gIGlmICghdGhpcy5jdXN0b21FdmVudExpc3RlbmVycykge1xuICAgIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMucHVzaChjdXN0b21FdmVudExpc3RlbmVyKTtcblxuICByZXR1cm4gY3VzdG9tRXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lciA9IHRoaXMuZmluZEN1c3RvbUV2ZW50TGlzdGVuZXIoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY3VzdG9tRXZlbnRMaXN0ZW5lciksXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG5cbiAgaWYgKHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnM7XG4gIH1cblxuICByZXR1cm4gY3VzdG9tRXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmluZEN1c3RvbUV2ZW50TGlzdGVuZXIoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXIgPSB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmZpbmQoKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBpZiAoKGN1c3RvbUV2ZW50TGlzdGVuZXIuZWxlbWVudCA9PT0gZWxlbWVudCkgJiYgKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tSGFuZGxlciA9PT0gY3VzdG9tSGFuZGxlcikgJiYgKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tRXZlbnRUeXBlID09PSBjdXN0b21FdmVudFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMoY3VzdG9tRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgaWYgKHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgIGNvbnN0IGZvdW5kID0gKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tRXZlbnRUeXBlID09PSBjdXN0b21FdmVudFR5cGUpO1xuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY3VzdG9tRXZlbnRMaXN0ZW5lcnMucHVzaChjdXN0b21FdmVudExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgbGV0IGN1c3RvbUV2ZW50TGlzdGVuZXI7XG5cbiAgY3VzdG9tRXZlbnRMaXN0ZW5lciA9ICgpID0+IHt9OyAvLy9cblxuICBPYmplY3QuYXNzaWduKGN1c3RvbUV2ZW50TGlzdGVuZXIsIHtcbiAgICBlbGVtZW50LFxuICAgIGN1c3RvbUhhbmRsZXIsXG4gICAgY3VzdG9tRXZlbnRUeXBlXG4gIH0pO1xuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVyO1xufVxuXG5jb25zdCBjdXN0b21FdmVudE1peGlucyA9IHtcbiAgb25DdXN0b21FdmVudCxcbiAgb2ZmQ3VzdG9tRXZlbnQsXG4gIGNhbGxDdXN0b21IYW5kbGVycyxcbiAgY2FsbEN1c3RvbUhhbmRsZXJzQXN5bmMsXG4gIGFkZEN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIHJlbW92ZUN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIGZpbmRDdXN0b21FdmVudExpc3RlbmVyLFxuICBmaW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMsXG4gIGNyZWF0ZUN1c3RvbUV2ZW50TGlzdGVuZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbUV2ZW50TWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgT2Zmc2V0IGZyb20gXCIuL29mZnNldFwiO1xuaW1wb3J0IEJvdW5kcyBmcm9tIFwiLi9ib3VuZHNcIjtcbmltcG9ydCBqc3hNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2pzeFwiO1xuaW1wb3J0IGtleU1peGlucyBmcm9tIFwiLi9taXhpbnMva2V5XCI7XG5pbXBvcnQgc3RhdGVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3N0YXRlXCI7XG5pbXBvcnQgZXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2V2ZW50XCI7XG5pbXBvcnQgbW91c2VNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL21vdXNlXCI7XG5pbXBvcnQgY2xpY2tNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2NsaWNrXCI7XG5pbXBvcnQgdG91Y2hNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3RvdWNoXCI7XG5pbXBvcnQgc2Nyb2xsTWl4aW5zIGZyb20gXCIuL21peGlucy9zY3JvbGxcIjtcbmltcG9ydCByZXNpemVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3Jlc2l6ZVwiO1xuaW1wb3J0IGVsZW1lbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2VsZW1lbnRcIjtcbmltcG9ydCBmdWxsU2NyZWVuTWl4aW5zIGZyb20gXCIuL21peGlucy9mdWxsU2NyZWVuXCI7XG5pbXBvcnQgY3VzdG9tRXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2N1c3RvbUV2ZW50XCI7XG5cbmltcG9ydCB7IGF1Z21lbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tIFwiLi91dGlsaXRpZXMvb2JqZWN0XCI7XG5pbXBvcnQgeyBpc1NWR1RhZ05hbWUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbmFtZVwiO1xuaW1wb3J0IHsgY29uc3RydWN0RWxlbWVudCwgZGVzdHJveUVsZW1lbnQsIG1vdW50RWxlbWVudCwgdW5tb3VudEVsZW1lbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudFwiO1xuaW1wb3J0IHsgTk9ORSxcbiAgICAgICAgIEJMT0NLLFxuICAgICAgICAgV0lEVEgsXG4gICAgICAgICBTVFJJTkcsXG4gICAgICAgICBIRUlHSFQsXG4gICAgICAgICBESVNQTEFZLFxuICAgICAgICAgRElTQUJMRUQsXG4gICAgICAgICBFTVBUWV9TVFJJTkcsXG4gICAgICAgICBTVkdfTkFNRVNQQUNFX1VSSSxcbiAgICAgICAgIERFRkFVTFRfUFJPUEVSVElFUyxcbiAgICAgICAgIElHTk9SRURfUFJPUEVSVElFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPXRoaXMsICAvLy9cbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgICAgY29uc3RydWN0RWxlbWVudChlbGVtZW50LCBkb21FbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBnZXRET01FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gT2Zmc2V0LmZyb21ET01FbGVtZW50KHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IEJvdW5kcy5mcm9tRE9NRWxlbWVudCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50Lm9mZnNldFdpZHRoOyB9ICAvLy9cblxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyB9ICAvLy9cblxuICBnZXRJbm5lcldpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmNsaWVudFdpZHRoOyB9IC8vL1xuXG4gIGdldElubmVySGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmNsaWVudEhlaWdodDsgfSAvLy9cblxuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIHdpZHRoID0gYCR7d2lkdGh9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoV0lEVEgsIHdpZHRoKTtcbiAgfVxuXG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBgJHtoZWlnaHR9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoSEVJR0hULCBoZWlnaHQpO1xuICB9XG5cbiAgaGFzQXR0cmlidXRlKG5hbWUpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZSk7IH1cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfVxuXG4gIGNsZWFyQXR0cmlidXRlKG5hbWUpIHsgdGhpcy5kb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIGFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7IH1cblxuICByZW1vdmVBdHRyaWJ1dGUobmFtZSkgeyB0aGlzLmNsZWFyQXR0cmlidXRlKG5hbWUpOyB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7IH1cblxuICBzZXRDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkgeyB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpOyB9XG5cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH1cblxuICB0b2dnbGVDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTsgfVxuXG4gIHJlbW92ZUFsbENsYXNzZXMoKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc05hbWUgPSBFTVBUWV9TVFJJTkc7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgYXBwZW5kVG8ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LmFwcGVuZCh0aGlzKTsgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIHJlbW92ZUZyb20ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LnJlbW92ZSh0aGlzKTsgfVxuXG4gIGluc2VydChlbGVtZW50KSB7IHRoaXMuYXBwZW5kKGVsZW1lbnQpOyB9XG5cbiAgYWRkKGVsZW1lbnQpIHsgdGhpcy5hcHBlbmQoZWxlbWVudCk7IH1cblxuICByZW1vdmUoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZSgpO1xuICB9XG5cbiAgcHJlcGVuZChlbGVtZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZG9tRWxlbWVudCxcbiAgICAgICAgICByZWZlcmVuY2VET01FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50LmZpcnN0Q2hpbGQ7ICAvLy9cblxuICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZG9tRWxlbWVudCwgcmVmZXJlbmNlRE9NRWxlbWVudCk7XG4gIH1cblxuICBhcHBlbmQoZWxlbWVudCkge1xuICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBlbGVtZW50LmRvbUVsZW1lbnQsXG4gICAgICAgICAgcmVmZXJlbmNlRE9NRWxlbWVudCA9IG51bGw7IC8vL1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZShkb21FbGVtZW50LCByZWZlcmVuY2VET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEJlZm9yZShzaWJsaW5nRWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGUgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50LnBhcmVudE5vZGUsIC8vL1xuICAgICAgICAgIHJlZmVyZW5jZURPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHJlZmVyZW5jZURPTUVsZW1lbnQpO1xuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnRET01Ob2RlID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5wYXJlbnROb2RlLCAvLy9cbiAgICAgICAgICByZWZlcmVuY2VET01FbGVtZW50ID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5uZXh0U2libGluZzsgIC8vL1xuXG4gICAgcGFyZW50RE9NTm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21FbGVtZW50LCByZWZlcmVuY2VET01FbGVtZW50KTtcbiAgfVxuXG4gIG1vdW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLmFkZChlbGVtZW50KTtcblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHVubW91bnQoZWxlbWVudCkge1xuICAgIHVubW91bnRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gIH1cblxuICBtb3VudEJlZm9yZShzaWJsaW5nRWxlbWVudCkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIG1vdW50QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICB0aGlzLmluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHNob3coZGlzcGxheVN0eWxlID0gQkxPQ0spIHsgdGhpcy5kaXNwbGF5KGRpc3BsYXlTdHlsZSk7IH1cblxuICBoaWRlKCkgeyB0aGlzLnN0eWxlKERJU1BMQVksIE5PTkUpOyB9XG5cbiAgZGlzcGxheShkaXNwbGF5KSB7IHRoaXMuc3R5bGUoRElTUExBWSwgZGlzcGxheSk7IH1cblxuICBlbmFibGUoKSB7IHRoaXMuY2xlYXJBdHRyaWJ1dGUoRElTQUJMRUQpOyB9XG5cbiAgZGlzYWJsZSgpIHsgdGhpcy5zZXRBdHRyaWJ1dGUoRElTQUJMRUQsIERJU0FCTEVEKTsgfVxuXG4gIGlzRW5hYmxlZCgpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpLFxuICAgICAgICAgIGVuYWJsZWQgPSAhZGlzYWJsZWQ7XG5cbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZShESVNBQkxFRCk7XG5cbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cbiAgXG4gIGlzRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLmNzcyhESVNQTEFZKSxcbiAgICAgICAgICBkaXNwbGF5ZWQgPSAoZGlzcGxheSAhPT0gTk9ORSk7XG4gICAgXG4gICAgcmV0dXJuIGRpc3BsYXllZDtcbiAgfVxuXG4gIGlzU2hvd2luZygpIHtcbiAgICBjb25zdCBkaXNwbGF5ZWQgPSB0aGlzLmlzRGlzcGxheWVkKCksXG4gICAgICAgICAgc2hvd2luZyA9IGRpc3BsYXllZDsgIC8vL1xuXG4gICAgcmV0dXJuIHNob3dpbmc7XG4gIH1cblxuICBpc0hpZGRlbigpIHtcbiAgICBjb25zdCBkaXNwbGF5ZWQgPSB0aGlzLmlzRGlzcGxheWVkKCksXG4gICAgICAgICAgaGlkZGVuID0gIWRpc3BsYXllZDtcblxuICAgIHJldHVybiBoaWRkZW47XG4gIH1cblxuICBzdHlsZShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGVbbmFtZV07XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBodG1sKGh0bWwgPSBudWxsKSB7XG4gICAgaWYgKGh0bWwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGlubmVySFRNTCA9IGh0bWw7IC8vL1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gaW5uZXJIVE1MXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbm5lckhUTUwgPSB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuXG4gICAgaHRtbCA9IGlubmVySFRNTDsgLy8vXG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGNzcyhjc3MgPSBudWxsKSB7XG4gICAgaWYgKGNzcyA9PT0gbnVsbCkge1xuICAgICAgY3NzID0ge307XG5cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpOyAvLy9cblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbXB1dGVkU3R5bGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZXNbaW5kZXhdLFxuICAgICAgICAgICAgICBuYW1lID0gY29tcHV0ZWRTdHlsZSwgIC8vL1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUobmFtZSk7IC8vL1xuXG4gICAgICAgIGNzc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNzcyA9PT0gU1RSSU5HKSB7XG4gICAgICBsZXQgbmFtZSA9IGNzczsgLy8vXG5cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpLCAvLy9cbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTsgLy8vXG5cbiAgICAgIGNzcyA9IHZhbHVlOyAgLy8vXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoY3NzKTsgLy8vXG5cbiAgICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgdGhpcy5zdHlsZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICBkZXN0cm95RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ2xhc3MoQ2xhc3MsIHByb3BlcnRpZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGNvbnN0IHsgdGFnTmFtZSB9ID0gQ2xhc3MsXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSxcbiAgICAgICAgICBkZWZhdWx0UHJvcGVydGllcyA9IGRlZmF1bHRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzKSxcbiAgICAgICAgICBpZ25vcmVkUHJvcGVydGllcyA9IGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzKTtcblxuICAgIGVsZW1lbnQuYXBwbHlQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGRlZmF1bHRQcm9wZXJ0aWVzLCBpZ25vcmVkUHJvcGVydGllcyk7XG5cbiAgICBlbGVtZW50LmluaXRpYWxpc2UgJiYgZWxlbWVudC5pbml0aWFsaXNlKCk7IC8vL1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRhZ05hbWUodGFnTmFtZSwgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSBFbGVtZW50LCAgLy8vXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSxcbiAgICAgICAgICBkZWZhdWx0UHJvcGVydGllcyA9IHt9LCAvLy9cbiAgICAgICAgICBpZ25vcmVkUHJvcGVydGllcyA9IFtdOyAvLy9cblxuICAgIGVsZW1lbnQuYXBwbHlQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGRlZmF1bHRQcm9wZXJ0aWVzLCBpZ25vcmVkUHJvcGVydGllcyk7XG5cbiAgICBlbGVtZW50LmluaXRpYWxpc2UgJiYgZWxlbWVudC5pbml0aWFsaXNlKCk7IC8vL1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwganN4TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBtb3VzZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzdGF0ZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBldmVudE1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCB0b3VjaE1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzY3JvbGxNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgcmVzaXplTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGVsZW1lbnRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgZnVsbFNjcmVlbk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBjdXN0b21FdmVudE1peGlucyk7XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gbnVsbCxcbiAgICAgICAgZWxlbWVudCA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChDbGFzcywgbnVsbCwgc2VsZWN0b3IsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykpLFxuICAgICAgICBkb21FbGVtZW50ID0gaXNTVkdUYWdOYW1lKHRhZ05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0VfVVJJLCB0YWdOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBjb25zdHJ1Y3RFbGVtZW50KGVsZW1lbnQsIGRvbUVsZW1lbnQpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhDbGFzcywgZGVmYXVsdFByb3BlcnRpZXMgPSB7fSkge1xuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoREVGQVVMVF9QUk9QRVJUSUVTKSkge1xuICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0gY29tYmluZShkZWZhdWx0UHJvcGVydGllcywgQ2xhc3NbREVGQVVMVF9QUk9QRVJUSUVTXSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTsgIC8vL1xuXG4gIGlmIChzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgZGVmYXVsdFByb3BlcnRpZXMgPSBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhzdXBlckNsYXNzLCBkZWZhdWx0UHJvcGVydGllcyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzLCBpZ25vcmVkUHJvcGVydGllcyA9IFtdKSB7XG4gIGlmIChDbGFzcy5oYXNPd25Qcm9wZXJ0eShJR05PUkVEX1BST1BFUlRJRVMpKSB7XG4gICAgaWdub3JlZFByb3BlcnRpZXMgPSBhdWdtZW50KGlnbm9yZWRQcm9wZXJ0aWVzLCBDbGFzc1tJR05PUkVEX1BST1BFUlRJRVNdLCAoaWdub3JlZFByb3BlcnR5KSA9PiB7XG4gICAgICBpZiAoIWlnbm9yZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKGlnbm9yZWRQcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTtcblxuICBpZiAoc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIGlnbm9yZWRQcm9wZXJ0aWVzID0gaWdub3JlZFByb3BlcnRpZXNGcm9tQ2xhc3Moc3VwZXJDbGFzcywgaWdub3JlZFByb3BlcnRpZXMpO1xuICB9XG5cbiAgcmV0dXJuIGlnbm9yZWRQcm9wZXJ0aWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi9lbGVtZW50XCI7XG5cbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFNUUklORywgRlVOQ1RJT04gfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHJlbW92ZUZhbHNleUVsZW1lbnRzLCByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudHNcIjtcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChmaXJzdEFyZ3VtZW50LCBwcm9wZXJ0aWVzLCAuLi5jaGlsZEVsZW1lbnRzKSB7XG4gIGxldCBlbGVtZW50ID0gbnVsbDtcblxuICBpZiAoZmlyc3RBcmd1bWVudCkge1xuICAgIGNoaWxkRWxlbWVudHMgPSBzYW5pdGlzZUNoaWxkRWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG5cbiAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjaGlsZEVsZW1lbnRzXG4gICAgfSwgcHJvcGVydGllcyk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAoaXNTdWJjbGFzc09mKGZpcnN0QXJndW1lbnQsIEVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBDbGFzcyA9IGZpcnN0QXJndW1lbnQ7ICAvLy9cblxuICAgICAgZWxlbWVudCA9IENsYXNzLmZyb21DbGFzcyhDbGFzcywgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmd1bWVudCA9PT0gU1RSSU5HKSB7XG4gICAgICBjb25zdCB0YWdOYW1lID0gZmlyc3RBcmd1bWVudDsgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBFbGVtZW50LmZyb21UYWdOYW1lKHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJndW1lbnQgPT09IEZVTkNUSU9OKSB7XG4gICAgICBjb25zdCBlbGVtZW50RnVuY3Rpb24gPSBmaXJzdEFyZ3VtZW50OyAgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50RnVuY3Rpb24ocHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmNvbnN0IFJlYWN0ID0ge1xuICBjcmVhdGVFbGVtZW50XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWFjdDtcblxuZnVuY3Rpb24gc2FuaXRpc2VDaGlsZEVsZW1lbnRzKGNoaWxkRWxlbWVudHMpIHtcbiAgY2hpbGRFbGVtZW50cyA9IGZsYXR0ZW4oY2hpbGRFbGVtZW50cyk7IC8vL1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZW1vdmVGYWxzZXlFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTsgIC8vL1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7ICAvLy9cblxuICByZXR1cm4gY2hpbGRFbGVtZW50cztcbn1cblxuXG5mdW5jdGlvbiBpc1N1YmNsYXNzT2YoYXJndW1lbnQsIENsYXNzKSB7XG4gIGNvbnN0IHN1YmNsYXNzT2YgPSAoYXJndW1lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQ2xhc3MpO1xuXG4gIHJldHVybiBzdWJjbGFzc09mO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgTEVGVF9NT1VTRV9CVVRUT04gPSAwO1xuZXhwb3J0IGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7XG5leHBvcnQgY29uc3QgTUlERExFX01PVVNFX0JVVFRPTiA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEVGVF9NT1VTRV9CVVRUT04sXG4gIFJJR0hUX01PVVNFX0JVVFRPTixcbiAgTUlERExFX01PVVNFX0JVVFRPTlxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgSU5QVVRfRVZFTlRfVFlQRSwgQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbklucHV0KGlucHV0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoSU5QVVRfRVZFTlRfVFlQRSwgaW5wdXRIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZJbnB1dChpbnB1dEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChJTlBVVF9FVkVOVF9UWVBFLCBpbnB1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlKGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KENIQU5HRV9FVkVOVF9UWVBFLCBjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZDaGFuZ2UoY2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KENIQU5HRV9FVkVOVF9UWVBFLCBjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC52YWx1ZTsgfVxuXG5mdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQudmFsdWUgPSB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBpc1JlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnJlYWRPbmx5OyB9XG5cbmZ1bmN0aW9uIHNldFJlYWRPbmx5KHJlYWRPbmx5KSB7IHRoaXMuZG9tRWxlbWVudC5yZWFkT25seSA9IHJlYWRPbmx5OyB9XG5cbmNvbnN0IGlucHV0TWl4aW5zID0ge1xuICBvbklucHV0LFxuICBvZmZJbnB1dCxcbiAgb25DaGFuZ2UsXG4gIG9mZkNoYW5nZSxcbiAgZ2V0VmFsdWUsXG4gIHNldFZhbHVlLFxuICBpc1JlYWRPbmx5LFxuICBzZXRSZWFkT25seVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5wdXRNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJMVVJfRVZFTlRfVFlQRSwgRk9DVVNfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uQmx1cihibHVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQkxVUl9FVkVOVF9UWVBFLCBibHVySGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQmx1cihibHVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEJMVVJfRVZFTlRfVFlQRSwgYmx1ckhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uRm9jdXMoZm9jdXNIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChGT0NVU19FVkVOVF9UWVBFLCBmb2N1c0hhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZkZvY3VzKGZvY3VzSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEZPQ1VTX0VWRU5UX1RZUEUsIGZvY3VzSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gYmx1cigpIHsgdGhpcy5kb21FbGVtZW50LmJsdXIoKTsgfVxuXG5mdW5jdGlvbiBmb2N1cygpIHsgdGhpcy5kb21FbGVtZW50LmZvY3VzKCk7IH1cblxuZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gIGNvbnN0IGZvY3VzID0gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZG9tRWxlbWVudCk7ICAvLy9cblxuICByZXR1cm4gZm9jdXM7XG59XG5cbmNvbnN0IGZvY3VzTWl4aW5zID0ge1xuICBvbkJsdXIsXG4gIG9mZkJsdXIsXG4gIG9uRm9jdXMsXG4gIG9mZkZvY3VzLFxuICBibHVyLFxuICBmb2N1cyxcbiAgaGFzRm9jdXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvY3VzTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDVVRfRVZFTlRfVFlQRSwgQ09QWV9FVkVOVF9UWVBFLCBQQVNURV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25DdXQoY3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQ1VUX0VWRU5UX1RZUEUsIGN1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZkN1dChjdXRIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoQ1VUX0VWRU5UX1RZUEUsIGN1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uQ29weShjb3B5SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQ09QWV9FVkVOVF9UWVBFLCBjb3B5SGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ29weShjb3B5SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KENPUFlfRVZFTlRfVFlQRSwgY29weUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uUGFzdGUocGFzdGVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChQQVNURV9FVkVOVF9UWVBFLCBwYXN0ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlBhc3RlKHBhc3RlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KFBBU1RFX0VWRU5UX1RZUEUsIHBhc3RlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uU3RhcnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7IH1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRW5kKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNlbGVjdGlvbkVuZDsgfVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25TdGFydChzZWxlY3Rpb25TdGFydCkgeyB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDsgfVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25FbmQoc2VsZWN0aW9uRW5kKSB7IHRoaXMuZG9tRWxlbWVudC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7IH1cblxuZnVuY3Rpb24gc2VsZWN0KCkgeyB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0KCk7IH1cblxuY29uc3Qgc2VsZWN0aW9uTWl4aW5zID0ge1xuICBvbkN1dCxcbiAgb2ZmQ3V0LFxuICBvbkNvcHksXG4gIG9mZkNvcHksXG4gIG9uUGFzdGUsXG4gIG9mZlBhc3RlLFxuICBnZXRTZWxlY3Rpb25TdGFydCxcbiAgZ2V0U2VsZWN0aW9uRW5kLFxuICBzZXRTZWxlY3Rpb25TdGFydCxcbiAgc2V0U2VsZWN0aW9uRW5kLFxuICBzZWxlY3Rcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdGlvbk1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGtleU1peGlucyBmcm9tIFwiLi9taXhpbnMva2V5XCI7XG5pbXBvcnQgZXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2V2ZW50XCI7XG5pbXBvcnQgbW91c2VNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL21vdXNlXCI7XG5pbXBvcnQgY2xpY2tNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2NsaWNrXCI7XG5cbmltcG9ydCB7IFVOREVGSU5FRCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgU0VMRUNUSU9OQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi9ldmVudFR5cGVzXCI7XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQ7IC8vL1xuICB9XG5cbiAgZ2V0RE9NRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50O1xuICB9XG5cbiAgZ2V0U2VsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldFNlbGVjdGlvbigpOyB9XG5cbiAgY3JlYXRlUmFuZ2UoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuY3JlYXRlUmFuZ2UoKTsgfVxuXG4gIGNyZWF0ZVRleHROb2RlKGRhdGEpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTsgfVxuXG4gIG9uU2VsZWN0aW9uQ2hhbmdlKHNlbGVjdGlvbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfSAvLy9cblxuICBvZmZTZWxlY3Rpb25DaGFuZ2Uoc2VsZWN0aW9uQ2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfSAvLy9cblxuICBjcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICAgIGxldCBldmVudExpc3RlbmVyO1xuXG4gICAgY29uc3QgaGFuZGxlckVsZW1lbnQgPSBlbGVtZW50OyAvLy9cblxuICAgIGV2ZW50TGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFKSB7XG4gICAgICAgIGNvbnN0IHsgZG9tRWxlbWVudCB9ID0gaGFuZGxlckVsZW1lbnQsXG4gICAgICAgICAgICAgIHsgY3VycmVudFRhcmdldCB9ID0gZXZlbnQsXG4gICAgICAgICAgICAgIHsgYWN0aXZlRWxlbWVudCB9ID0gY3VycmVudFRhcmdldDtcblxuICAgICAgICBpZiAoZG9tRWxlbWVudCAhPT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKGV2ZW50TGlzdGVuZXIsIHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBoYW5kbGVyLFxuICAgICAgZXZlbnRUeXBlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwga2V5TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRG9jdW1lbnQucHJvdG90eXBlLCBldmVudE1peGlucyk7XG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihEb2N1bWVudC5wcm90b3R5cGUsIGNsaWNrTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiBkb2N1bWVudCA9PT0gVU5ERUZJTkVEKSA/IHVuZGVmaW5lZCA6IG5ldyBEb2N1bWVudCgpOyAgLy8vXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBrZXlNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2tleVwiO1xuaW1wb3J0IGV2ZW50TWl4aW5zIGZyb20gXCIuL21peGlucy9ldmVudFwiO1xuaW1wb3J0IG1vdXNlTWl4aW5zIGZyb20gXCIuL21peGlucy9tb3VzZVwiO1xuaW1wb3J0IGNsaWNrTWl4aW5zIGZyb20gXCIuL21peGlucy9jbGlja1wiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuL21peGlucy9mb2N1c1wiO1xuXG5pbXBvcnQgeyBVTkRFRklORUQgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJFU0laRV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4vZXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgb25TY3JvbGwsIG9mZlNjcm9sbCB9IGZyb20gXCIuL21peGlucy9zY3JvbGxcIjtcblxuY2xhc3MgV2luZG93IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gd2luZG93OyAvLy9cbiAgfVxuXG4gIGdldERPTUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudDtcbiAgfVxuXG4gIGFzc2lnbiguLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kb21FbGVtZW50OyAvLy9cblxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKTtcbiAgfVxuXG4gIHJlbG9hZCgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7IC8vL1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuaW5uZXJXaWR0aDsgfSAvLy9cbiAgXG4gIGdldEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5pbm5lckhlaWdodDsgfSAvLy9cblxuICBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQucGFnZVlPZmZzZXQ7IH0gIC8vL1xuXG4gIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQucGFnZVhPZmZzZXQ7IH0gLy8vXG5cbiAgZ2V0U2VsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldFNlbGVjdGlvbigpOyB9XG5cbiAgZ2V0U2NyZWVuV2lkdGgoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2NyZWVuLndpZHRoOyB9XG5cbiAgZ2V0U2NyZWVuSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNjcmVlbi5oZWlnaHQ7IH1cblxuICBzY3JvbGxUbyhzY3JvbGxUb3AsIHNjcm9sbExlZnQpIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7IH1cblxuICBvblJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gUkVTSVpFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gUkVTSVpFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGV2ZW50TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihXaW5kb3cucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwge1xuICBvblNjcm9sbCxcbiAgb2ZmU2Nyb2xsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiB3aW5kb3cgPT09IFVOREVGSU5FRCkgPyB1bmRlZmluZWQgOiBuZXcgV2luZG93KCk7ICAvLy9cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcblxuaW1wb3J0IHsgQk9EWSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm9keSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihzZWxlY3RvciA9IEJPRFkpIHtcbiAgICBzdXBlcihzZWxlY3Rvcik7XG4gIH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYm9keVwiO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vZWxlbWVudFwiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZm9jdXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluayBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRIUmVmKCkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpOyB9XG5cbiAgc2V0SFJlZihocmVmKSB7IHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgaHJlZik7IH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYVwiO1xufVxuXG5PYmplY3QuYXNzaWduKExpbmsucHJvdG90eXBlLCBmb2N1c01peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgaW5wdXRNaXhpbnMgZnJvbSBcIi4uL21peGlucy9pbnB1dFwiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZm9jdXNcIjtcbmltcG9ydCBzZWxlY3Rpb25NaXhpbnMgZnJvbSBcIi4uL21peGlucy9zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG59XG5cbk9iamVjdC5hc3NpZ24oSW5wdXQucHJvdG90eXBlLCBpbnB1dE1peGlucyk7XG5PYmplY3QuYXNzaWduKElucHV0LnByb3RvdHlwZSwgZm9jdXNNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihJbnB1dC5wcm90b3R5cGUsIHNlbGVjdGlvbk1peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImJ1dHRvblwiO1xufVxuXG5PYmplY3QuYXNzaWduKEJ1dHRvbi5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBpbnB1dE1peGlucyBmcm9tIFwiLi4vbWl4aW5zL2lucHV0XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcInNlbGVjdFwiO1xufVxuXG5PYmplY3QuYXNzaWduKFNlbGVjdC5wcm90b3R5cGUsIGlucHV0TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oU2VsZWN0LnByb3RvdHlwZSwgZm9jdXNNaXhpbnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vZWxlbWVudFwiO1xuaW1wb3J0IGlucHV0TWl4aW5zIGZyb20gXCIuLi9taXhpbnMvaW5wdXRcIjtcbmltcG9ydCBmb2N1c01peGlucyBmcm9tIFwiLi4vbWl4aW5zL2ZvY3VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgRWxlbWVudCB7XG4gIGlzQ2hlY2tlZCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jaGVja2VkOyB9XG5cbiAgY2hlY2soY2hlY2tlZCA9IHRydWUpIHsgdGhpcy5kb21FbGVtZW50LmNoZWNrZWQgPSBjaGVja2VkOyB9XG5cbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIHR5cGU6IFwiY2hlY2tib3hcIlxuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKENoZWNrYm94LnByb3RvdHlwZSwgaW5wdXRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihDaGVja2JveC5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBpbnB1dE1peGlucyBmcm9tIFwiLi4vbWl4aW5zL2lucHV0XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuaW1wb3J0IHNlbGVjdGlvbk1peGlucyBmcm9tIFwiLi4vbWl4aW5zL3NlbGVjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0YXJlYSBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwidGV4dGFyZWFcIjtcbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0YXJlYS5wcm90b3R5cGUsIGlucHV0TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oVGV4dGFyZWEucHJvdG90eXBlLCBmb2N1c01peGlucyk7XG5PYmplY3QuYXNzaWduKFRleHRhcmVhLnByb3RvdHlwZSwgc2VsZWN0aW9uTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFjdCB9IGZyb20gXCIuL3JlYWN0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJvdW5kcyB9IGZyb20gXCIuL2JvdW5kc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRUeXBlcyB9IGZyb20gXCIuL2V2ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbW91c2VCdXR0b25zIH0gZnJvbSBcIi4vbW91c2VCdXR0b25zXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVsZW1lbnRVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnB1dE1peGlucyB9IGZyb20gXCIuL21peGlucy9pbnB1dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmb2N1c01peGlucyB9IGZyb20gXCIuL21peGlucy9mb2N1c1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZWxlY3Rpb25NaXhpbnMgfSBmcm9tIFwiLi9taXhpbnMvc2VsZWN0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGN1c3RvbUV2ZW50TWl4aW5zIH0gZnJvbSBcIi4vbWl4aW5zL2N1c3RvbUV2ZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZW1lbnQgfSBmcm9tIFwiLi9lbGVtZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRFbGVtZW50IH0gZnJvbSBcIi4vdGV4dEVsZW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZG9jdW1lbnQgfSBmcm9tIFwiLi9kb2N1bWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aW5kb3cgfSBmcm9tIFwiLi93aW5kb3dcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm9keSB9IGZyb20gXCIuL2VsZW1lbnQvYm9keVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5rIH0gZnJvbSBcIi4vZWxlbWVudC9saW5rXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0IH0gZnJvbSBcIi4vZWxlbWVudC9pbnB1dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b24gfSBmcm9tIFwiLi9lbGVtZW50L2J1dHRvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QgfSBmcm9tIFwiLi9lbGVtZW50L3NlbGVjdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVja2JveCB9IGZyb20gXCIuL2VsZW1lbnQvY2hlY2tib3hcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dGFyZWEgfSBmcm9tIFwiLi9lbGVtZW50L3RleHRhcmVhXCI7XG5cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSZWFjdCB9IGZyb20gXCJlYXN5XCI7XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywge1xuICBSZWFjdFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcIi4vanV4dGFwb3NlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHRhZ05hbWVzID0gW1xuICBcImFcIiwgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFzaWRlXCIsIFwiYXVkaW9cIixcbiAgXCJiXCIsIFwiYmFzZVwiLCBcImJkaVwiLCBcImJkb1wiLCBcImJsb2NrcXVvdGVcIiwgXCJib2R5XCIsIFwiYnJcIiwgXCJidXR0b25cIixcbiAgXCJjYW52YXNcIiwgXCJjYXB0aW9uXCIsIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJjb2xcIiwgXCJjb2xncm91cFwiLFxuICBcImRhdGFcIiwgXCJkYXRhbGlzdFwiLCBcImRkXCIsIFwiZGVsXCIsIFwiZGV0YWlsc1wiLCBcImRmblwiLCBcImRpYWxvZ1wiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImVtYmVkXCIsIFwiZmllbGRzZXRcIiwgXCJmaWdjYXB0aW9uXCIsIFwiZmlndXJlXCIsIFwiZm9vdGVyXCIsIFwiZm9ybVwiLFxuICBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcImhlYWRcIiwgXCJoZWFkZXJcIiwgXCJoclwiLCBcImh0bWxcIixcbiAgXCJpXCIsIFwiaWZyYW1lXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibGlua1wiLFxuICBcIm1haW5cIiwgXCJtYXBcIiwgXCJtYXJrXCIsIFwibWV0YVwiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwibm9zY3JpcHRcIixcbiAgXCJvYmplY3RcIiwgXCJvbFwiLCBcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwib3V0cHV0XCIsXG4gIFwicFwiLCBcInBhcmFtXCIsIFwicGljdHVyZVwiLCBcInByZVwiLCBcInByb2dyZXNzXCIsXG4gIFwicVwiLCBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsXG4gIFwic1wiLCBcInNhbXBcIiwgXCJzY3JpcHRcIiwgXCJzZWN0aW9uXCIsIFwic2VsZWN0XCIsIFwic21hbGxcIiwgXCJzb3VyY2VcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3R5bGVcIiwgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsIFwic3VwXCIsIFwic3ZnXCIsXG4gIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGVtcGxhdGVcIiwgXCJ0ZXh0YXJlYVwiLCBcInRmb290XCIsIFwidGhcIiwgXCJ0aGVhZFwiLCBcInRpbWVcIiwgXCJ0aXRsZVwiLCBcInRyXCIsIFwidHJhY2tcIixcbiAgXCJ1XCIsIFwidWxcIixcbiAgXCJ2YXJcIiwgXCJ2aWRlb1wiLFxuICBcIndiclwiXG5dO1xuXG5leHBvcnQgZGVmYXVsdCB0YWdOYW1lcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRSQUNFX0xFVkVMID0gXCJ0cmFjZVwiO1xuZXhwb3J0IGNvbnN0IERFQlVHX0xFVkVMID0gXCJkZWJ1Z1wiO1xuZXhwb3J0IGNvbnN0IElORk9fTEVWRUwgPSBcImluZm9cIjtcbmV4cG9ydCBjb25zdCBXQVJOSU5HX0xFVkVMID0gXCJ3YXJuaW5nXCI7XG5leHBvcnQgY29uc3QgRVJST1JfTEVWRUwgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgRkFUQUxfTEVWRUwgPSBcImZhdGFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTCxcbiAgRkFUQUxfTEVWRUxcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBHRVRfTUVUSE9EID0gXCJHRVRcIjtcbmV4cG9ydCBjb25zdCBQT1NUX01FVEhPRCA9IFwiUE9TVFwiO1xuZXhwb3J0IGNvbnN0IFBBVENIX01FVEhPRCA9IFwiUEFUQ0hcIjtcbmV4cG9ydCBjb25zdCBERUxFVEVfTUVUSE9EID0gXCJERUxFVEVcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05TX01FVEhPRCA9IFwiT1BUSU9OU1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEdFVF9NRVRIT0QsXG4gIFBPU1RfTUVUSE9ELFxuICBQQVRDSF9NRVRIT0QsXG4gIERFTEVURV9NRVRIT0QsXG4gIE9QVElPTlNfTUVUSE9EXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgUFJBR01BX0hFQURFUiA9IFwicHJhZ21hXCI7XG5leHBvcnQgY29uc3QgQUNDRVBUX0hFQURFUiA9IFwiYWNjZXB0XCI7XG5leHBvcnQgY29uc3QgTE9DQVRJT05fSEVBREVSID0gXCJsb2NhdGlvblwiO1xuZXhwb3J0IGNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gXCJ1c2VyLWFnZW50XCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9IFwiY29udGVudC10eXBlXCI7XG5leHBvcnQgY29uc3QgQVVUSE9SSVpBVElPTl9IRUFERVIgPSBcImF1dGhvcml6YXRpb25cIjtcbmV4cG9ydCBjb25zdCBDQUNIRV9DT05UUk9MX0hFQURFUiA9IFwiY2FjaGUtY29udHJvbFwiO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfTEVOR1RIX0hFQURFUiA9IFwiY29udGVudC1sZW5ndGhcIjtcbmV4cG9ydCBjb25zdCBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIgPSBcInRyYW5zZmVyLWVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9ESVNQT1NJVElPTl9IRUFERVIgPSBcImNvbnRlbnQtZGlzcG9zaXRpb25cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1vcmlnaW5cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUiA9IFwiYWNjZXNzLWNvbnRyb2wtYWxsb3ctbWV0aG9kc1wiO1xuZXhwb3J0IGNvbnN0IEFDQ0VTU19DT05UUk9MX0FMTE9XX0hFQURFUlNfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzXCI7XG5leHBvcnQgY29uc3QgQUNDRVNTX0NPTlRST0xfUkVRVUVTVF9NRVRIT0RfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSQUdNQV9IRUFERVIsXG4gIEFDQ0VQVF9IRUFERVIsXG4gIExPQ0FUSU9OX0hFQURFUixcbiAgVVNFUl9BR0VOVF9IRUFERVIsXG4gIENPTlRFTlRfVFlQRV9IRUFERVIsXG4gIEFVVEhPUklaQVRJT05fSEVBREVSLFxuICBDQUNIRV9DT05UUk9MX0hFQURFUixcbiAgQ09OVEVOVF9MRU5HVEhfSEVBREVSLFxuICBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIsXG4gIENPTlRFTlRfRElTUE9TSVRJT05fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUixcbiAgQUNDRVNTX0NPTlRST0xfQUxMT1dfSEVBREVSU19IRUFERVIsXG4gIEFDQ0VTU19DT05UUk9MX1JFUVVFU1RfTUVUSE9EX0hFQURFUlxufTsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUQUJfS0VZX0NPREUgPSA5O1xuZXhwb3J0IGNvbnN0IFNISUZUX0tFWV9DT0RFID0gMTY7XG5leHBvcnQgY29uc3QgRU5URVJfS0VZX0NPREUgPSAxMztcbmV4cG9ydCBjb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcbmV4cG9ydCBjb25zdCBERUxFVEVfS0VZX0NPREUgPSA0NjtcbmV4cG9ydCBjb25zdCBCQUNLU1BBQ0VfS0VZX0NPREUgPSA4O1xuZXhwb3J0IGNvbnN0IEFSUk9XX1VQX0tFWV9DT0RFID0gMzg7XG5leHBvcnQgY29uc3QgQVJST1dfRE9XTl9LRVlfQ09ERSA9IDQwO1xuZXhwb3J0IGNvbnN0IEFSUk9XX0xFRlRfS0VZX0NPREUgPSAzNztcbmV4cG9ydCBjb25zdCBBUlJPV19SSUdIVF9LRVlfQ09ERSA9IDM5O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRBQl9LRVlfQ09ERSxcbiAgU0hJRlRfS0VZX0NPREUsXG4gIEVOVEVSX0tFWV9DT0RFLFxuICBFU0NBUEVfS0VZX0NPREUsXG4gIERFTEVURV9LRVlfQ09ERSxcbiAgQkFDS1NQQUNFX0tFWV9DT0RFLFxuICBBUlJPV19VUF9LRVlfQ09ERSxcbiAgQVJST1dfRE9XTl9LRVlfQ09ERSxcbiAgQVJST1dfTEVGVF9LRVlfQ09ERSxcbiAgQVJST1dfUklHSFRfS0VZX0NPREVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVVEY4X0VOQ09ESU5HID0gXCJ1dGY4XCI7XG5leHBvcnQgY29uc3QgVVRGXzhfRU5DT0RJTkcgPSBcInV0Zi04XCI7XG5leHBvcnQgY29uc3QgQkFTRTY0X0VOQ09ESU5HID0gXCJiYXNlNjRcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBVVEY4X0VOQ09ESU5HLFxuICBVVEZfOF9FTkNPRElORyxcbiAgQkFTRTY0X0VOQ09ESU5HXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgVVBfQ0hBUkFDVEVSID0gXCJcdTAwMWJbQVwiO1xuZXhwb3J0IGNvbnN0IEVUWF9DSEFSQUNURVIgPSBcIlxcdTAwMDNcIjtcbmV4cG9ydCBjb25zdCBCQVJfQ0hBUkFDVEVSID0gXCJ8XCI7XG5leHBvcnQgY29uc3QgSEFUX0NIQVJBQ1RFUiA9IFwiXlwiO1xuZXhwb3J0IGNvbnN0IFBMVVNfQ0hBUkFDVEVSID0gXCIrXCI7XG5leHBvcnQgY29uc3QgREFTSF9DSEFSQUNURVIgPSBcIi1cIjtcbmV4cG9ydCBjb25zdCBET1dOX0NIQVJBQ1RFUiA9IFwiXHUwMDFiW0JcIjtcbmV4cG9ydCBjb25zdCBMRUZUX0NIQVJBQ1RFUiA9IFwiXHUwMDFiW0RcIjtcbmV4cG9ydCBjb25zdCBSSUdIVF9DSEFSQUNURVIgPSBcIlx1MDAxYltDXCI7XG5leHBvcnQgY29uc3QgU1BBQ0VfQ0hBUkFDVEVSID0gXCIgXCI7XG5leHBvcnQgY29uc3QgQ09NTUFfQ0hBUkFDVEVSID0gXCIsXCI7XG5leHBvcnQgY29uc3QgQ09MT05fQ0hBUkFDVEVSID0gXCI6XCI7XG5leHBvcnQgY29uc3QgUEVSSU9EX0NIQVJBQ1RFUiA9IFwiLlwiO1xuZXhwb3J0IGNvbnN0IERPTExBUl9DSEFSQUNURVIgPSBcIiRcIjtcbmV4cG9ydCBjb25zdCBDVFJMX0NfQ0hBUkFDVEVSID0gXCJeQ1wiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRV9DSEFSQUNURVIgPSBcIlxcdTAwMWJcIjtcbmV4cG9ydCBjb25zdCBBU1RFUklTS19DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBCQUNLVElDS19ERUxJTUlURVIgPSBcImBcIjtcbmV4cG9ydCBjb25zdCBORVdfTElORV9DSEFSQUNURVIgPSBcIlxcblwiO1xuZXhwb3J0IGNvbnN0IEFNUEVSU0FORF9DSEFSQUNURVIgPSBcIiZcIjtcbmV4cG9ydCBjb25zdCBCQUNLU0xBU0hfQ0hBUkFDVEVSID0gXCJcXFxcXCI7XG5leHBvcnQgY29uc3QgQkFDS1NQQUNFX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbmV4cG9ydCBjb25zdCBRVUVTVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiP1wiO1xuZXhwb3J0IGNvbnN0IEZPUldBUkRfU0xBU0hfQ0hBUkFDVEVSID0gXCIvXCI7XG5leHBvcnQgY29uc3QgT1BFTklOR19CUkFDS0VUX0NIQVJBQ1RFUiA9IFwiKFwiO1xuZXhwb3J0IGNvbnN0IENMT1NJTkdfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIilcIjtcbmV4cG9ydCBjb25zdCBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSID0gXCJcXHJcIjtcbmV4cG9ydCBjb25zdCBFWENMQU1BVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiIVwiO1xuZXhwb3J0IGNvbnN0IE9QRU5JTkdfQ1VSTFlfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIntcIjtcbmV4cG9ydCBjb25zdCBDTE9TSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSID0gXCJ9XCI7XG5leHBvcnQgY29uc3QgT1BFTklOR19TUVVBUkVfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIltcIjtcbmV4cG9ydCBjb25zdCBDTE9TSU5HX1NRVUFSRV9CUkFDS0VUX0NIQVJBQ1RFUiA9IFwiXVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVQX0NIQVJBQ1RFUixcbiAgRVRYX0NIQVJBQ1RFUixcbiAgQkFSX0NIQVJBQ1RFUixcbiAgSEFUX0NIQVJBQ1RFUixcbiAgUExVU19DSEFSQUNURVIsXG4gIERBU0hfQ0hBUkFDVEVSLFxuICBET1dOX0NIQVJBQ1RFUixcbiAgTEVGVF9DSEFSQUNURVIsXG4gIFJJR0hUX0NIQVJBQ1RFUixcbiAgU1BBQ0VfQ0hBUkFDVEVSLFxuICBDT01NQV9DSEFSQUNURVIsXG4gIENPTE9OX0NIQVJBQ1RFUixcbiAgUEVSSU9EX0NIQVJBQ1RFUixcbiAgRE9MTEFSX0NIQVJBQ1RFUixcbiAgQ1RSTF9DX0NIQVJBQ1RFUixcbiAgRVNDQVBFX0NIQVJBQ1RFUixcbiAgQVNURVJJU0tfQ0hBUkFDVEVSLFxuICBXSUxEQ0FSRF9DSEFSQUNURVIsXG4gIEJBQ0tUSUNLX0RFTElNSVRFUixcbiAgTkVXX0xJTkVfQ0hBUkFDVEVSLFxuICBBTVBFUlNBTkRfQ0hBUkFDVEVSLFxuICBCQUNLU0xBU0hfQ0hBUkFDVEVSLFxuICBCQUNLU1BBQ0VfQ0hBUkFDVEVSLFxuICBRVUVTVElPTl9NQVJLX0NIQVJBQ1RFUixcbiAgRk9SV0FSRF9TTEFTSF9DSEFSQUNURVIsXG4gIE9QRU5JTkdfQlJBQ0tFVF9DSEFSQUNURVIsXG4gIENMT1NJTkdfQlJBQ0tFVF9DSEFSQUNURVIsXG4gIENBUlJJQUdFX1JFVFVSTl9DSEFSQUNURVIsXG4gIEVYQ0xBTUFUSU9OX01BUktfQ0hBUkFDVEVSLFxuICBPUEVOSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSLFxuICBDTE9TSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSLFxuICBPUEVOSU5HX1NRVUFSRV9CUkFDS0VUX0NIQVJBQ1RFUixcbiAgQ0xPU0lOR19TUVVBUkVfQlJBQ0tFVF9DSEFSQUNURVJcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBaRVJPXzBfU1RBVFVTX0NPREUgPSAwO1xuZXhwb3J0IGNvbnN0IE9LXzIwMF9TVEFUVVNfQ09ERSA9IDIwMDtcbmV4cG9ydCBjb25zdCBGT1VORF8zMDJfU1RBVFVTX0NPREUgPSAzMDI7XG5leHBvcnQgY29uc3QgQ1JFQVRFRF8yMDFfU1RBVFVTX0NPREUgPSAyMDE7XG5leHBvcnQgY29uc3QgQ09ORkxJQ1RfNDA5X1NUQVRVU19DT0RFID0gNDA5O1xuZXhwb3J0IGNvbnN0IFNFRV9PVEhFUl8zMDNfU1RBVFVTX0NPREUgPSAzMDM7XG5leHBvcnQgY29uc3QgRk9SQklEREVOXzQwM19TVEFUVVNfQ09ERSA9IDQwMztcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkRfNDA0X1NUQVRVU19DT0RFID0gNDA0O1xuZXhwb3J0IGNvbnN0IE5PX0NPTlRFTlRfMjA0X1NUQVRVU19DT0RFID0gMjA0O1xuZXhwb3J0IGNvbnN0IEJBRF9HQVRFV0FZXzUwMl9TVEFUVVNfQ09ERSA9IDUwMjtcbmV4cG9ydCBjb25zdCBCQURfUkVRVUVTVF80MDBfU1RBVFVTX0NPREUgPSA0MDA7XG5leHBvcnQgY29uc3QgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfQ09ERSA9IDQwMTtcbmV4cG9ydCBjb25zdCBOT1RfQUNDRVBUQUJMRV80MDZfU1RBVFVTX0NPREUgPSA0MDY7XG5leHBvcnQgY29uc3QgUkVRVUVTVF9USU1FT1VUXzQwOF9TVEFUVVNfQ09ERSA9IDQwODtcbmV4cG9ydCBjb25zdCBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX0NPREUgPSA0Mjk7XG5leHBvcnQgY29uc3QgTUVUSE9EX05PVF9BTExPV0VEXzQwNV9TVEFUVVNfQ09ERSA9IDQwNTtcbmV4cG9ydCBjb25zdCBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfQ09ERSA9IDUwMztcbmV4cG9ydCBjb25zdCBVTlBST0NFU1NBQkxFX0VOVElUWV80MjJfU1RBVFVTX0NPREUgPSA0MjI7XG5leHBvcnQgY29uc3QgSU5URVJOQUxfU0VSVkVSX0VSUk9SXzUwMF9TVEFUVVNfQ09ERSA9IDUwMDtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFpFUk9fMF9TVEFUVVNfQ09ERSxcbiAgT0tfMjAwX1NUQVRVU19DT0RFLFxuICBGT1VORF8zMDJfU1RBVFVTX0NPREUsXG4gIENSRUFURURfMjAxX1NUQVRVU19DT0RFLFxuICBDT05GTElDVF80MDlfU1RBVFVTX0NPREUsXG4gIFNFRV9PVEhFUl8zMDNfU1RBVFVTX0NPREUsXG4gIEZPUkJJRERFTl80MDNfU1RBVFVTX0NPREUsXG4gIE5PVF9GT1VORF80MDRfU1RBVFVTX0NPREUsXG4gIE5PX0NPTlRFTlRfMjA0X1NUQVRVU19DT0RFLFxuICBCQURfR0FURVdBWV81MDJfU1RBVFVTX0NPREUsXG4gIEJBRF9SRVFVRVNUXzQwMF9TVEFUVVNfQ09ERSxcbiAgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfQ09ERSxcbiAgTk9UX0FDQ0VQVEFCTEVfNDA2X1NUQVRVU19DT0RFLFxuICBSRVFVRVNUX1RJTUVPVVRfNDA4X1NUQVRVU19DT0RFLFxuICBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX0NPREUsXG4gIE1FVEhPRF9OT1RfQUxMT1dFRF80MDVfU1RBVFVTX0NPREUsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEVfNTAzX1NUQVRVU19DT0RFLFxuICBVTlBST0NFU1NBQkxFX0VOVElUWV80MjJfU1RBVFVTX0NPREUsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUl81MDBfU1RBVFVTX0NPREVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBURVhUX0hUTUxfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWxcIjtcbmV4cG9ydCBjb25zdCBURVhUX1BMQUlOX0NPTlRFTlRfVFlQRSA9IFwidGV4dC9wbGFpblwiO1xuZXhwb3J0IGNvbnN0IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5leHBvcnQgY29uc3QgVEVYVF9IVE1MX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLThcIjtcbmV4cG9ydCBjb25zdCBURVhUX1BMQUlOX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fT0NURVRfU1RSRUFNX0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fWF9XV1dfRk9STV9FTkNPREVEX0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fSlNPTl9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuZXhwb3J0IGNvbnN0IEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVEVYVF9IVE1MX0NPTlRFTlRfVFlQRSxcbiAgVEVYVF9QTEFJTl9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFLFxuICBURVhUX0hUTUxfQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIFRFWFRfUExBSU5fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX09DVEVUX1NUUkVBTV9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFpFUk9fMF9TVEFUVVNfTUVTU0FHRSA9IFwiXCI7XG5leHBvcnQgY29uc3QgT0tfMjAwX1NUQVRVU19NRVNTQUdFID0gXCJPS1wiO1xuZXhwb3J0IGNvbnN0IEZPVU5EXzMwMl9TVEFUVVNfTUVTU0FHRSA9IFwiRm91bmRcIjtcbmV4cG9ydCBjb25zdCBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSA9IFwiQ3JlYXRlZFwiO1xuZXhwb3J0IGNvbnN0IENPTkZMSUNUXzQwOV9TVEFUVVNfTUVTU0FHRSA9IFwiQ29uZmxpY3RcIjtcbmV4cG9ydCBjb25zdCBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFID0gXCJTZWUgb3RoZXJcIjtcbmV4cG9ydCBjb25zdCBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFID0gXCJGb3JiaWRkZW5cIjtcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFID0gXCJOb3QgZm91bmRcIjtcbmV4cG9ydCBjb25zdCBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSA9IFwiTm8gY29udGVudFwiO1xuZXhwb3J0IGNvbnN0IEJBRF9HQVRFV0FZXzUwMl9TVEFUVVNfTUVTU0FHRSA9IFwiQmFkIGdhdGV3YXlcIjtcbmV4cG9ydCBjb25zdCBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UgPSBcIkJhZCByZXF1ZXN0XCI7XG5leHBvcnQgY29uc3QgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfTUVTU0FHRSA9IFwiVW5hdXRob3JpemVkXCI7XG5leHBvcnQgY29uc3QgTk9UX0FDQ0VQVEFCTEVfNDA2X1NUQVRVU19NRVNTQUdFID0gXCJOb3QgQWNjZXB0YWJsZVwiO1xuZXhwb3J0IGNvbnN0IFJFUVVFU1RfVElNRU9VVF80MDhfU1RBVFVTX01FU1NBR0UgPSBcIlJlcXVlc3QgdGltZW91dFwiO1xuZXhwb3J0IGNvbnN0IFRPT19NQU5ZX1JFUVVFU1RTXzQyOV9TVEFUVVNfTUVTU0FHRSA9IFwiVG9vIG1hbnkgcmVxdWVzdHNcIjtcbmV4cG9ydCBjb25zdCBNRVRIT0RfTk9UX0FMTE9XRURfNDA1X1NUQVRVU19NRVNTQUdFID0gXCJNZXRob2Qgbm90IGFsbG93ZWRcIjtcbmV4cG9ydCBjb25zdCBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfTUVTU0FHRSA9IFwiU2VydmljZSB1bmF2YWlsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IFVOUFJPQ0VTU0FCTEVfRU5USVRZXzQyMl9TVEFUVVNfTUVTU0FHRSA9IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIjtcbmV4cG9ydCBjb25zdCBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19NRVNTQUdFID0gXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBaRVJPXzBfU1RBVFVTX01FU1NBR0UsXG4gIE9LXzIwMF9TVEFUVVNfTUVTU0FHRSxcbiAgRk9VTkRfMzAyX1NUQVRVU19NRVNTQUdFLFxuICBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSxcbiAgQ09ORkxJQ1RfNDA5X1NUQVRVU19NRVNTQUdFLFxuICBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFLFxuICBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFLFxuICBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFLFxuICBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSxcbiAgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19NRVNTQUdFLFxuICBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UsXG4gIFVOQVVUSE9SSVpFRF80MDFfU1RBVFVTX01FU1NBR0UsXG4gIE5PVF9BQ0NFUFRBQkxFXzQwNl9TVEFUVVNfTUVTU0FHRSxcbiAgUkVRVUVTVF9USU1FT1VUXzQwOF9TVEFUVVNfTUVTU0FHRSxcbiAgVE9PX01BTllfUkVRVUVTVFNfNDI5X1NUQVRVU19NRVNTQUdFLFxuICBNRVRIT0RfTk9UX0FMTE9XRURfNDA1X1NUQVRVU19NRVNTQUdFLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfTUVTU0FHRSxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFlfNDIyX1NUQVRVU19NRVNTQUdFLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19NRVNTQUdFXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgWkVSTyA9IFwiMFwiO1xuZXhwb3J0IGNvbnN0IERBVEEgPSBcImRhdGFcIjtcbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBTVFJJTkcgPSBcInN0cmluZ1wiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUiA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFQgPSBcImRlZmF1bHRcIjtcbmV4cG9ydCBjb25zdCBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVCA9IFwiRU5WSVJPTk1FTlRcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IERPVUJMRV9TUEFDRSA9IFwiICBcIjtcbmV4cG9ydCBjb25zdCBQQUNLQUdFX0pTT04gPSBcInBhY2thZ2UuanNvblwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzBdO31cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZChhcnJheSkgeyByZXR1cm4gYXJyYXlbMV07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkKGFycmF5KSB7IHJldHVybiBhcnJheVsyXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZm91cnRoKGFycmF5KSB7IHJldHVybiBhcnJheVszXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlmdGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzRdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXh0aChhcnJheSkgeyByZXR1cm4gYXJyYXlbNV07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldmVudGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzZdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBlaWdodGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzddOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBuaW50aChhcnJheSkgeyByZXR1cm4gYXJyYXlbOF07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbnRoKGFycmF5KSB7IHJldHVybiBhcnJheVs5XTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RMYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vjb25kTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMl07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gM107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvdXJ0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDRdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWZ0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDVdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXh0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDZdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXZlbnRoTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gN107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGVpZ2h0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDhdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBuaW50aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDldOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCwgMSk7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDEpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZShhcnJheS5sZW5ndGggLSAxKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbnQoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDAsIE1hdGgubWF4KDEsIGFycmF5Lmxlbmd0aCAtIDEpKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheUEsIGFycmF5QikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheUEsIGFycmF5Qik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2hpZnQoYXJyYXlBLCBhcnJheUIpIHsgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYXJyYXlBLCBhcnJheUIpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoYXJyYXlBLCBlbGVtZW50T3JBcnJheTIpIHtcbiAgY29uc3QgYXJyYXlCID0gKGVsZW1lbnRPckFycmF5MiBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRPckFycmF5MiA6XG4gICAgICAgICAgICAgICAgICAgICBbIGVsZW1lbnRPckFycmF5MiBdO1xuICBcbiAgcHVzaChhcnJheUEsIGFycmF5Qik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihhcnJheSkge1xuICBjb25zdCBzdGFydCA9IDA7XG4gIFxuICByZXR1cm4gYXJyYXkuc3BsaWNlKHN0YXJ0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoYXJyYXlBLCBhcnJheUIpIHtcbiAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICBkZWxldGVDb3VudCA9IGFycmF5Qi5sZW5ndGg7ICAvLy9cbiAgXG4gIHNwbGljZShhcnJheUEsIHN0YXJ0LCBkZWxldGVDb3VudCwgYXJyYXlCKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKGFycmF5QSwgYXJyYXlCKSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFycmF5QSwgYXJyYXlCKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2goYXJyYXlBLCBhcnJheUIsIGNhbGxiYWNrKSB7XG4gIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aCxcbiAgICAgICAgYXJyYXlCTGVuZ3RoID0gYXJyYXlCLmxlbmd0aDtcblxuICBpZiAoYXJyYXlBTGVuZ3RoID09PSBhcnJheUJMZW5ndGgpIHtcbiAgICBtYXRjaGVzID0gYXJyYXlBLmV2ZXJ5KChlbGVtZW50QSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRCID0gYXJyYXlCW2luZGV4XSxcbiAgICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBLCBlbGVtZW50QiwgaW5kZXgpO1xuXG4gICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBsZXQgY291cGxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGFycmF5QUxlbmd0aCA9IGFycmF5QS5sZW5ndGgsXG4gICAgICAgIGFycmF5Qkxlbmd0aCA9IGFycmF5Qi5sZW5ndGg7XG5cbiAgaWYgKGFycmF5QUxlbmd0aCA9PT0gYXJyYXlCTGVuZ3RoKSB7XG4gICAgYXJyYXlCID0gWyAgLy8vXG4gICAgICAuLi5hcnJheUJcbiAgICBdO1xuXG4gICAgY291cGxlZCA9IGFycmF5QS5ldmVyeSgoZWxlbWVudEEsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50QiA9IGV4dHJhY3QoYXJyYXlCLCAoZWxlbWVudEIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudEEsIGVsZW1lbnRCKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pIHx8IG51bGw7XG5cbiAgICAgIGlmIChlbGVtZW50QiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3VwbGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29ycmVsYXRlKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheUIgPSBbICAvLy9cbiAgICAuLi5hcnJheUJcbiAgXTtcblxuICBjb25zdCBjb3JyZWxhdGVzID0gYXJyYXlBLmV2ZXJ5KChlbGVtZW50QSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRCID0gZXh0cmFjdChhcnJheUIsIChlbGVtZW50QikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudEEsIGVsZW1lbnRCKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsO1xuXG4gICAgaWYgKGVsZW1lbnRCICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb3JyZWxhdGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShhcnJheUEsIGFycmF5QiwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc29sdmVkO1xuXG4gIGFycmF5QSA9IFsgIC8vL1xuICAgIC4uLmFycmF5QVxuICBdO1xuXG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBhcnJheUFMZW5ndGggPSBhcnJheUEubGVuZ3RoO1xuXG4gICAgaWYgKGFycmF5QUxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICBhcnJheUEuZm9yRWFjaCgoZWxlbWVudEEpID0+IHtcbiAgICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBKTtcblxuICAgICAgaWYgKHBhc3NlZCkge1xuICAgICAgICBjb25zdCBlbGVtZW50QiA9IGVsZW1lbnRBOyAgLy8vXG5cbiAgICAgICAgYXJyYXlCLnB1c2goZWxlbWVudEIpO1xuXG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZpbHRlcihhcnJheUEsIChlbGVtZW50QSkgPT4ge1xuICAgICAgY29uc3QgYXJyYXlCSW5jbHVkZXNFbGVtZW50QSA9IGFycmF5Qi5pbmNsdWRlcyhlbGVtZW50QSk7XG5cbiAgICAgIGlmICghYXJyYXlCSW5jbHVkZXNFbGVtZW50QSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGFycmF5QUxlbmd0aCA9IGFycmF5QS5sZW5ndGg7XG5cbiAgcmVzb2x2ZWQgPSAoYXJyYXlBTGVuZ3RoID09PSAwKTtcblxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gIGZvcndhcmRzRm9yRWFjaChhcnJheSwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2UoYXJyYXksIGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIGxldCBzdGFydDtcbiAgXG4gIGNvbnN0IGZvdW5kID0gYXJyYXkuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBzdGFydCA9IGluZGV4OyAgLy8vXG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIFxuICBpZiAoZm91bmQpIHtcbiAgICBjb25zdCBkZWxldGVDb3VudCA9IDE7XG5cbiAgICBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGljZShhcnJheUEsIHN0YXJ0LCBkZWxldGVDb3VudCA9IEluZmluaXR5LCBhcnJheUIgPSBbXSkge1xuICBjb25zdCBhcmdzID0gWyBzdGFydCwgZGVsZXRlQ291bnQsIC4uLmFycmF5QiBdLFxuICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGFycmF5QSwgYXJncyk7XG5cbiAgcmV0dXJuIGRlbGV0ZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgZGVsZXRlZEVsZW1lbnRzID0gW107XG4gIFxuICBiYWNrd2FyZHNGb3JFYWNoKGFycmF5LCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpbmRleCwgIC8vL1xuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxLFxuICAgICAgICAgICAgZGVsZXRlZEVsZW1lbnRzID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCksXG4gICAgICAgICAgICBmaXJzdERlbGV0ZWRFbGVtZW50ID0gZmlyc3QoZGVsZXRlZEVsZW1lbnRzKTtcbiAgICAgIFxuICAgICAgZGVsZXRlZEVsZW1lbnRzLnVuc2hpZnQoZmlyc3REZWxldGVkRWxlbWVudCk7ICAvLy9cbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGRlbGV0ZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lKGFycmF5LCBjYWxsYmFjaykge1xuICBsZXQgZGVsZXRlZEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gIFxuICBhcnJheS5zb21lKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgICAgICBkZWxldGVDb3VudCA9IDEsXG4gICAgICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSxcbiAgICAgICAgICAgIGZpcnN0RGVsZXRlZEVsZW1lbnQgPSBmaXJzdChkZWxldGVkRWxlbWVudHMpO1xuICAgICAgXG4gICAgICBkZWxldGVkRWxlbWVudCA9IGZpcnN0RGVsZXRlZEVsZW1lbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBkZWxldGVkRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGxldCBkZWxldGVkRWxlbWVudCA9IHVuZGVmaW5lZDtcblxuICBhcnJheS5zb21lKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMSxcbiAgICAgICAgICAgIGRlbGV0ZWRFbGVtZW50cyA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpLFxuICAgICAgICAgICAgZmlyc3REZWxldGVkRWxlbWVudCA9IGZpcnN0KGRlbGV0ZWRFbGVtZW50cyk7XG5cbiAgICAgIGRlbGV0ZWRFbGVtZW50ID0gZmlyc3REZWxldGVkRWxlbWVudDsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWxldGVkRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoKGFycmF5LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICBjb25zdCBmb3VuZCA9IGFycmF5LnNvbWUoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuXG4gIGlmIChmb3VuZCkge1xuICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZm91bmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzcyhhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IGluZGV4MSA9IDAsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4MSA8IGxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnRCID0gYXJyYXlbaW5kZXgxXTtcblxuICAgIGZvciAobGV0IGluZGV4MiA9IGxlbmd0aCAtIDE7IGluZGV4MiA+IGluZGV4MTsgaW5kZXgyLS0pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRBID0gYXJyYXlbaW5kZXgyXSxcbiAgICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBLCBlbGVtZW50Qik7XG5cbiAgICAgIGlmICghcGFzc2VkKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgyLCAvLy9cbiAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgICAgIGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4MSsrO1xuXG4gICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheSA9IFtcbiAgICAuLi5hcnJheUEsXG4gICAgLi4uYXJyYXlCXG4gIF07XG5cbiAgY29tcHJlc3MoYXJyYXksIGNhbGxiYWNrKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gIGFycmF5ID0gWyAvLy9cbiAgICAuLi5hcnJheVxuICBdLnJldmVyc2UoKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdWdtZW50KGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheUIuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheUEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGUoYXJyYXksIGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIHBhc3NlZCA/XG4gICAgICBhcnJheUEucHVzaChlbGVtZW50KSA6XG4gICAgICAgIGFycmF5Qi5wdXNoKGVsZW1lbnQpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRmluZChhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcbiAgICBcbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzRXZlcnkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNSZWR1Y2UoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlOyAvLy9cblxuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzUmVkdWNlKGFycmF5LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTsgLy8vXG5cbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSBhcnJheUxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpcnN0LFxuICBzZWNvbmQsXG4gIHRoaXJkLFxuICBmb3VydGgsXG4gIGZpZnRoLFxuICBzaXh0aCxcbiAgc2V2ZW50aCxcbiAgZWlnaHRoLFxuICBuaW50aCxcbiAgZmlyc3RMYXN0LFxuICBzZWNvbmRMYXN0LFxuICB0aGlyZExhc3QsXG4gIGZvdXJ0aExhc3QsXG4gIGZpZnRoTGFzdCxcbiAgc2l4dGhMYXN0LFxuICBzZXZlbnRoTGFzdCxcbiAgZWlnaHRoTGFzdCxcbiAgbmludGhMYXN0LFxuICBsYXN0LFxuICBoZWFkLFxuICB0YWlsLFxuICBiYWNrLFxuICBmcm9udCxcbiAgcHVzaCxcbiAgdW5zaGlmdCxcbiAgY29uY2F0LFxuICBjbGVhcixcbiAgY29weSxcbiAgbWVyZ2UsXG4gIG1hdGNoLFxuICBjb21wYXJlLFxuICBjb3JyZWxhdGUsXG4gIHJlc29sdmUsXG4gIGZpbmQsXG4gIHJlcGxhY2UsXG4gIHNwbGljZSxcbiAgZmlsdGVyLFxuICBwcnVuZSxcbiAgZXh0cmFjdCxcbiAgcGF0Y2gsXG4gIGNvbXByZXNzLFxuICBjb21iaW5lLFxuICByZXZlcnNlLFxuICBhdWdtZW50LFxuICBzZXBhcmF0ZSxcbiAgZm9yd2FyZHNGaW5kLFxuICBiYWNrd2FyZHNGaW5kLFxuICBmb3J3YXJkc1NvbWUsXG4gIGJhY2t3YXJkc1NvbWUsXG4gIGZvcndhcmRzRXZlcnksXG4gIGJhY2t3YXJkc0V2ZXJ5LFxuICBmb3J3YXJkc1JlZHVjZSxcbiAgYmFja3dhcmRzUmVkdWNlLFxuICBmb3J3YXJkc0ZvckVhY2gsXG4gIGJhY2t3YXJkc0ZvckVhY2gsXG4gIGZvcndhcmRzRmluZEluZGV4LFxuICBiYWNrd2FyZHNGaW5kSW5kZXhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQsIGxhc3QgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhOYW1lKHBhdGgpIHtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIEVNUFRZX1NUUklORykucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7IC8vL1xuXG4gIGNvbnN0IHBhdGhOYW1lID0gKC9cXC8vLnRlc3QocGF0aCkgPT09IGZhbHNlKTtcblxuICByZXR1cm4gcGF0aE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhUb3Btb3N0TmFtZShwYXRoKSB7XG4gIGNvbnN0IHBhdGhOYW1lID0gaXNQYXRoTmFtZShwYXRoKSxcbiAgICAgICAgcGF0aEFic29sdXRlUGF0aCA9IGlzUGF0aEFic29sdXRlUGF0aChwYXRoKSxcbiAgICAgICAgcGF0aFRvcG1vc3ROYW1lID0gKHBhdGhOYW1lICYmIHBhdGhBYnNvbHV0ZVBhdGgpO1xuXG4gIHJldHVybiBwYXRoVG9wbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhSZWxhdGl2ZVBhdGgocGF0aCkge1xuICBjb25zdCBwYXRoUmVsYXRpdmVQYXRoID0gIS9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoUmVsYXRpdmVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXRoQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgY29uc3QgcGF0aEFic29sdXRlUGF0aCA9IC9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoQWJzb2x1dGVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoKHRvcG1vc3ROYW1lLCBhYnNvbHV0ZVBhdGgpIHtcbiAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXiR7dG9wbW9zdE5hbWV9KD86XFxcXC8uKyk/JGApLFxuICAgICAgICB0b3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoID0gcmVnRXhwLnRlc3QoYWJzb2x1dGVQYXRoKTtcblxuICByZXR1cm4gdG9wbW9zdE5hbWVJbkFic29sdXRlUGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVBhdGhzKHBhdGgsIHJlbGF0aXZlUGF0aCkge1xuICBsZXQgY29tYmluZWRQYXRoID0gbnVsbDtcblxuICBjb25zdCBwYXRoTmFtZXMgPSBwYXRoLnNwbGl0KC9cXC8vKSxcbiAgICAgICAgcmVsYXRpdmVQYXRoTmFtZXMgPSByZWxhdGl2ZVBhdGguc3BsaXQoL1xcLy8pO1xuXG4gIGxldCBsYXN0UGF0aE5hbWUsXG4gICAgICBmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPSBmaXJzdChyZWxhdGl2ZVBhdGhOYW1lcyk7XG5cbiAgaWYgKGZpcnN0UmVsYXRpdmVQYXRoTmFtZSA9PT0gXCIuXCIpIHtcbiAgICByZWxhdGl2ZVBhdGhOYW1lcy5zaGlmdCgpO1xuICB9XG5cbiAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICBsYXN0UGF0aE5hbWUgPSBsYXN0KHBhdGhOYW1lcyk7XG5cbiAgd2hpbGUgKChmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPT09IFwiLi5cIikgJiYgKGxhc3RQYXRoTmFtZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHJlbGF0aXZlUGF0aE5hbWVzLnNoaWZ0KCk7XG4gICAgcGF0aE5hbWVzLnBvcCgpO1xuXG4gICAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICAgIGxhc3RQYXRoTmFtZSA9IGxhc3QocGF0aE5hbWVzKTtcbiAgfVxuXG4gIGlmIChsYXN0UGF0aE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbWJpbmVkUGF0aE5hbWVzID0gW10uY29uY2F0KHBhdGhOYW1lcykuY29uY2F0KHJlbGF0aXZlUGF0aE5hbWVzKTtcblxuICAgIGNvbWJpbmVkUGF0aCA9IGNvbWJpbmVkUGF0aE5hbWVzLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkUGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgbGV0IGNvbmNhdGVuYXRlZFBhdGg7XG5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7ICAvLy9cblxuICBjb25jYXRlbmF0ZWRQYXRoID0gYCR7cGF0aH0vJHtyZWxhdGl2ZVBhdGh9YDtcblxuICBjb25zdCByZW1haW5pbmdBQXJndW1lbnRzTGVuZ3RoID0gcmVtYWluaW5nQXJndW1lbnRzLmxlbmd0aDtcblxuICBpZiAocmVtYWluaW5nQUFyZ3VtZW50c0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXRoID0gY29uY2F0ZW5hdGVkUGF0aCwgIC8vL1xuICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5zaGlmdCgpO1xuXG4gICAgY29uY2F0ZW5hdGVkUGF0aCA9IGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZFBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IGJvdHRvbW1vc3ROYW1lID0gbnVsbDtcblxuICBjb25zdCBtYXRjaGVzID0gcGF0aC5tYXRjaCgvXi4qXFwvKFteXFwvXStcXC8/KSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgYm90dG9tbW9zdE5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGJvdHRvbW1vc3ROYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4rKVxcL1teXFwvXStcXC8/JC8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgdG9wbW9zdERpcmVjdG9yeVBhdGggPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aChwYXRoKSB7XG4gIGxldCB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL14oW15cXC9dKylcXC8uKyQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWUgPSBudWxsO1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4qKVxcL1teXFwvXStcXC8/JC8pO1xuXG4gIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBwYXRoV2l0aG91dEJvdHRvbW1vc3ROYW1lID0gc2Vjb25kTWF0Y2g7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL15bXlxcL10rXFwvKC4rKSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IHNlY29uZE1hdGNoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0VG9wbW9zdERpcmVjdG9yeU5hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNQYXRoTmFtZSxcbiAgaXNQYXRoVG9wbW9zdE5hbWUsXG4gIGlzUGF0aFJlbGF0aXZlUGF0aCxcbiAgaXNQYXRoQWJzb2x1dGVQYXRoLFxuICBpc1RvcG1vc3ROYW1lSW5BYnNvbHV0ZVBhdGgsXG4gIGNvbWJpbmVQYXRocyxcbiAgY29uY2F0ZW5hdGVQYXRocyxcbiAgYm90dG9tbW9zdE5hbWVGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aCxcbiAgcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoLFxuICBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNlY29uZCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IENPTE9OX0NIQVJBQ1RFUiwgQU1QRVJTQU5EX0NIQVJBQ1RFUiB9IGZyb20gXCIuLi9jaGFyYWN0ZXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVyd3JpdGUoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgZXhpc3RpbmdOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLCAgLy8vXG4gICAgICAgIGV4aXN0aW5nTmFtZSA9IGV4aXN0aW5nTmFtZXMuZmluZCgoZXhpc3RpbmdOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdMb3dlckNhc2VOYW1lID0gZXhpc3RpbmdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAoZXhpc3RpbmdMb3dlckNhc2VOYW1lID09PSBsb3dlckNhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IG51bGw7XG5cbiAgaWYgKGV4aXN0aW5nTmFtZSAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbZXhpc3RpbmdOYW1lXSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmRlcndyaXRlKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGxvd2VyQ2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGV4aXN0aW5nTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKSwgIC8vL1xuICAgICAgICBleGlzdGluZ05hbWUgPSBleGlzdGluZ05hbWVzLmZpbmQoKGV4aXN0aW5nTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTG93ZXJDYXNlTmFtZSA9IGV4aXN0aW5nTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKGV4aXN0aW5nTG93ZXJDYXNlTmFtZSA9PT0gbG93ZXJDYXNlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChleGlzdGluZ05hbWUgPT09IG51bGwpIHtcbiAgICBoZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcnRGcm9tSG9zdChob3N0KSB7XG4gIGxldCBwb3J0O1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKC9eaHR0cHM/OlxcL1xcLyhbXlxcL10rKS8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgaW5kZXggPSBzZWNvbmRNYXRjaC5pbmRleE9mKENPTE9OX0NIQVJBQ1RFUik7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIGNvbnN0IHNlY3VyZSA9IHNlY3VyZUZyb21Ib3N0KGhvc3QpO1xuXG4gICAgcG9ydCA9IHNlY3VyZSA/IDQ0MyA6IDgwOyAvLy9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGFydCA9IGluZGV4ICsgMSxcbiAgICAgICAgICBwb3J0U3RyaW5nID0gc2Vjb25kTWF0Y2guc3Vic3RyaW5nKHN0YXJ0KTtcblxuICAgIHBvcnQgPSBOdW1iZXIocG9ydFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gcG9ydDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY3VyZUZyb21Ib3N0KGhvc3QpIHtcbiAgY29uc3Qgc2VjdXJlID0gL15odHRwczpcXC9cXC8vLnRlc3QoaG9zdCk7XG5cbiAgcmV0dXJuIHNlY3VyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvc3RuYW1lRnJvbUhvc3QoaG9zdCkge1xuICBjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146XFwvXSspLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpLFxuICAgICAgICBob3N0bmFtZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICByZXR1cm4gaG9zdG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVN0cmluZ0Zyb21RdWVyeShxdWVyeSkge1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHF1ZXJ5KSxcbiAgICAgICAgbmFtZXNMZW5ndGggPSBuYW1lcy5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IG5hbWVzTGVuZ3RoIC0gMSxcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBuYW1lcy5yZWR1Y2UoKHF1ZXJ5U3RyaW5nLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlbbmFtZV0sXG4gICAgICAgICAgICAgICAgZW5jb2RlZE5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSksXG4gICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhbXBlcnNhbmRPck5vdGhpbmcgPSAoaW5kZXggIT09IGxhc3RJbmRleCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQU1QRVJTQU5EX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORztcbiAgXG4gICAgICAgICAgcXVlcnlTdHJpbmcgKz0gYCR7ZW5jb2RlZE5hbWV9PSR7ZW5jb2RlZFZhbHVlfSR7YW1wZXJzYW5kT3JOb3RoaW5nfWA7XG4gIFxuICAgICAgICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcXVlcnlTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxGcm9tSG9zdFVSSUFuZFF1ZXJ5KGhvc3QsIHVyaSwgcXVlcnkpIHtcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZ0Zyb21RdWVyeShxdWVyeSksXG4gICAgICAgIHVybCA9IChxdWVyeVN0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSA/XG4gICAgICAgICAgICAgICAgYCR7aG9zdH0ke3VyaX1gIDpcbiAgICAgICAgICAgICAgICAgIGAke2hvc3R9JHt1cml9PyR7cXVlcnlTdHJpbmd9YDtcblxuICByZXR1cm4gdXJsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG92ZXJ3cml0ZSxcbiAgdW5kZXJ3cml0ZSxcbiAgcG9ydEZyb21Ib3N0LFxuICBzZWN1cmVGcm9tSG9zdCxcbiAgaG9zdG5hbWVGcm9tSG9zdCxcbiAgcXVlcnlTdHJpbmdGcm9tUXVlcnksXG4gIHVybEZyb21Ib3N0VVJJQW5kUXVlcnlcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmxlbihzdHJpbmcpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXG4gIGxldCBjaGFyYWN0ZXIgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFjaGFyYWN0ZXIuZG9uZSkge1xuICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgIGxlbmd0aCsrXG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyY21wKHN0cmluZ0EsIHN0cmluZ0IpIHtcbiAgbGV0IGRpZmZlcmVuY2U7XG5cbiAgY29uc3QgaXRlcmF0b3JBID0gc3RyaW5nQVtTeW1ib2wuaXRlcmF0b3JdKCksIC8vL1xuICAgICAgICBpdGVyYXRvckIgPSBzdHJpbmdCW1N5bWJvbC5pdGVyYXRvcl0oKTsgLy8vXG5cbiAgbGV0IGNoYXJhY3RlckEgPSBpdGVyYXRvckEubmV4dCgpLFxuICAgICAgY2hhcmFjdGVyQiA9IGl0ZXJhdG9yQi5uZXh0KCksXG4gICAgICBjb2RlUG9pbnRBLFxuICAgICAgY29kZVBvaW50QjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvZGVQb2ludEEgPSBjaGFyYWN0ZXJBLnZhbHVlID8gLy8vXG4gICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQS52YWx1ZS5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAwO1xuICAgIGNvZGVQb2ludEIgPSBjaGFyYWN0ZXJCLnZhbHVlID8gLy8vXG4gICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQi52YWx1ZS5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgZGlmZmVyZW5jZSA9IGNvZGVQb2ludEIgLSBjb2RlUG9pbnRBO1xuXG4gICAgaWYgKGRpZmZlcmVuY2UgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjaGFyYWN0ZXJBLmRvbmUgfHwgY2hhcmFjdGVyQi5kb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGFyYWN0ZXJBID0gaXRlcmF0b3JBLm5leHQoKTtcbiAgICBjaGFyYWN0ZXJCID0gaXRlcmF0b3JCLm5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICBsZXQgaW5kZXggPSAtMSxcbiAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgY29uc3Qgc2VhcmNoU3RyaW5nTGVuZ3RoID0gc3RybGVuKHNlYXJjaFN0cmluZyk7XG5cbiAgaWYgKHNlYXJjaFN0cmluZ0xlbmd0aCA+IDApIHtcbiAgICBsZXQgY2hhcmFjdGVyO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICAgIHNlYXJjaEl0ZXJhdG9yID0gc2VhcmNoU3RyaW5nW1N5bWJvbC5pdGVyYXRvcl0oKSxcbiAgICAgICAgICBzZWFyY2hDaGFyYWN0ZXIgPSBzZWFyY2hJdGVyYXRvci5uZXh0KCk7XG5cbiAgICBjaGFyYWN0ZXIgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICBpbmRleCsrO1xuXG4gICAgd2hpbGUgKCFjaGFyYWN0ZXIuZG9uZSkge1xuICAgICAgaWYgKGNoYXJhY3Rlci52YWx1ZSA9PT0gc2VhcmNoQ2hhcmFjdGVyLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBzZWFyY2hTdHJpbmdMZW5ndGgsXG4gICAgICAgICAgICAgIHN1YlN0cmluZyA9IHN1YnN0cmluZyhzdHJpbmcsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICBkaWZmZXJlbmNlID0gc3RyY21wKHN1YlN0cmluZywgc2VhcmNoU3RyaW5nKTtcblxuICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaW5kZXgrK1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQpIHtcbiAgICBpbmRleCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic3RyaW5nKHN0cmluZywgc3RhcnQsIGVuZCA9IEluZmluaXR5KSB7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICBjaGFyYWN0ZXJzID0gW107XG5cbiAgbGV0IGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICB3aGlsZSAoIWNoYXJhY3Rlci5kb25lKSB7XG4gICAgaWYgKGluZGV4ID09PSBlbmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBzdGFydCkge1xuICAgICAgY2hhcmFjdGVycy5wdXNoKGNoYXJhY3Rlci52YWx1ZSk7IC8vL1xuICAgIH1cblxuICAgIGluZGV4KytcblxuICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfVxuXG4gIGNvbnN0IHN1YnN0cmluZyA9IGNoYXJhY3RlcnMuam9pbihFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdWJzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RyY21wLFxuICBzdHJsZW4sXG4gIGluZGV4T2YsXG4gIHN1YnN0cmluZ1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGUoanNvbiwgbWlncmF0aW9uTWFwLCBsYXRlc3RWZXJzaW9uKSB7XG4gIGxldCB7IHZlcnNpb24gfSA9IGpzb247XG5cbiAgd2hpbGUgKHZlcnNpb24gIT09IGxhdGVzdFZlcnNpb24pIHtcbiAgICBjb25zdCBtaWdyYXRlRnVuY3Rpb24gPSBtaWdyYXRpb25NYXBbdmVyc2lvbl07XG5cbiAgICBqc29uID0gbWlncmF0ZUZ1bmN0aW9uKGpzb24pO1xuXG4gICAgKHsgdmVyc2lvbiB9ID0ganNvbik7XG4gIH1cblxuICByZXR1cm4ganNvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtaWdyYXRlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdoaWxzdChvcGVyYXRpb24sIGRvbmUsIGNvbnRleHQpIHtcclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSBjb3VudDsgIC8vL1xyXG5cclxuICAgIG9wZXJhdGlvbihuZXh0LCBkb25lLCBjb250ZXh0LCBpbmRleCk7XHJcbiAgfVxyXG5cclxuICBuZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBvcGVyYXRpb24sIGRvbmUsIGNvbnRleHQpIHtcclxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7ICAvLy9cclxuXHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY291bnQsICAvLy9cclxuICAgICAgICAgICAgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcclxuXHJcbiAgICAgIG9wZXJhdGlvbihlbGVtZW50LCBuZXh0LCBkb25lLCBjb250ZXh0LCBpbmRleCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW5jZShvcGVyYXRpb25zLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9ucy5sZW5ndGg7ICAvLy9cclxuXHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY291bnQsICAvLy9cclxuICAgICAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpbmRleF07XHJcblxyXG4gICAgICBvcGVyYXRpb24obmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXZlbnR1YWxseShvcGVyYXRpb25zLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9ucy5sZW5ndGg7ICAvLy9cclxuXHJcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgZG9uZSgpO1xyXG5cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGxldCBjb3VudCA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9wZXJhdGlvbnMuZm9yRWFjaCgob3BlcmF0aW9uLCBpbmRleCkgPT4ge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdGVkbHkob3BlcmF0aW9uLCBsZW5ndGgsIGRvbmUsIGNvbnRleHQpIHtcclxuICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICBkb25lKCk7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSBsZW5ndGgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc0ZvckVhY2goYXJyYXksIG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xyXG5cclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSBsZW5ndGgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkc0ZvckVhY2goYXJyYXksIG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xyXG5cclxuICBsZXQgY291bnQgPSBsZW5ndGg7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudC0tO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gLTEpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHdoaWxzdCxcclxuICBmb3JFYWNoLFxyXG4gIHNlcXVlbmNlLFxyXG4gIGV2ZW50dWFsbHksXHJcbiAgcmVwZWF0ZWRseSxcclxuICBmb3J3YXJkc0ZvckVhY2gsXHJcbiAgYmFja3dhcmRzRm9yRWFjaFxyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNUUklORywgRlVOQ1RJT04gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBHRVRfTUVUSE9ELCBQT1NUX01FVEhPRCB9IGZyb20gXCIuLi9tZXRob2RzXCI7XG5pbXBvcnQgeyBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSB9IGZyb20gXCIuLi9jb250ZW50VHlwZXNcIjtcbmltcG9ydCB7IEFDQ0VQVF9IRUFERVIsIENPTlRFTlRfVFlQRV9IRUFERVIgfSBmcm9tIFwiLi4vaGVhZGVyc1wiO1xuaW1wb3J0IHsgdW5kZXJ3cml0ZSwgdXJsRnJvbUhvc3RVUklBbmRRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvaHR0cFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGhvc3QsIHVyaSwgcXVlcnksIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSBGVU5DVElPTikge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG5cbiAgICByZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZVR5cGUgPT09IEZVTkNUSU9OKSB7XG4gICAgY2FsbGJhY2sgPSByZXNwb25zZVR5cGU7ICAvLy9cblxuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gU1RSSU5HKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBoZWFkZXJzOyAvLy9cblxuICAgICAgaGVhZGVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gR0VUX01FVEhPRCxcbiAgICAgICAgYWNjZXB0ID0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUsXG4gICAgICAgIGNvbnRlbnQgPSBudWxsO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICByZXF1ZXN0KGhvc3QsIHVyaSwgcXVlcnksIG1ldGhvZCwgY29udGVudCwgaGVhZGVycywgcmVzcG9uc2VUeXBlLCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0KGhvc3QsIHVyaSwgcXVlcnksIGNvbnRlbnQsIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSBGVU5DVElPTikge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG5cbiAgICByZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZVR5cGUgPT09IEZVTkNUSU9OKSB7XG4gICAgY2FsbGJhY2sgPSByZXNwb25zZVR5cGU7ICAvLy9cblxuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gU1RSSU5HKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBoZWFkZXJzOyAvLy9cblxuICAgICAgaGVhZGVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gUE9TVF9NRVRIT0QsXG4gICAgICAgIGFjY2VwdCA9IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFLFxuICAgICAgICBjb250ZW50VHlwZSA9IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICB1bmRlcndyaXRlQ29udGVudFR5cGVIZWFkZXIoaGVhZGVycywgY29udGVudFR5cGUpO1xuXG4gIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBjb250ZW50LCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBjb250ZW50LCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHVybCA9IHVybEZyb21Ib3N0VVJJQW5kUXVlcnkoaG9zdCwgdXJpLCBxdWVyeSksXG4gICAgICAgIGFjY2VwdCA9IGhlYWRlcnNbQUNDRVBUX0hFQURFUl0gfHwgbnVsbCxcbiAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdIHx8IG51bGwsXG4gICAgICAgIHhtbEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgaWYgKGNvbnRlbnRUeXBlID09PSBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSkge1xuICAgIGNvbnN0IGpzb24gPSBjb250ZW50LCAgLy8vXG4gICAgICAgICAganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXG4gICAgY29udGVudCA9IGpzb25TdHJpbmc7ICAvLy9cbiAgfVxuXG4gIGlmIChyZXNwb25zZVR5cGUgIT09IG51bGwpIHtcbiAgICBPYmplY3QuYXNzaWduKHhtbEh0dHBSZXF1ZXN0LCB7XG4gICAgICByZXNwb25zZVR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIHhtbEh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHJlYWR5U3RhdGUsIHN0YXR1cywgcmVzcG9uc2UgfSA9IHhtbEh0dHBSZXF1ZXN0LFxuICAgICAgICAgIHN0YXR1c0NvZGUgPSBzdGF0dXM7XG5cbiAgICBpZiAocmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICBsZXQgY29udGVudCA9IHJlc3BvbnNlO1xuXG4gICAgICBpZiAoYWNjZXB0ID09PSBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBjb250ZW50LCAgLy8vXG4gICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG5cbiAgICAgICAgICBjb250ZW50ID0ganNvbjsgIC8vL1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGNvbnRlbnQsIHN0YXR1c0NvZGUpO1xuICAgIH1cbiAgfTtcblxuICB4bWxIdHRwUmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsKTtcblxuICBpZiAoYWNjZXB0ICE9PSBudWxsKSB7XG4gICAgeG1sSHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihBQ0NFUFRfSEVBREVSLCBhY2NlcHQpO1xuICB9XG5cbiAgaWYgKGNvbnRlbnRUeXBlICE9PSBudWxsKSB7XG4gICAgeG1sSHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihDT05URU5UX1RZUEVfSEVBREVSLCBjb250ZW50VHlwZSk7XG4gIH1cblxuICAoY29udGVudCAhPT0gbnVsbCkgP1xuICAgIHhtbEh0dHBSZXF1ZXN0LnNlbmQoY29udGVudCkgOlxuICAgICAgeG1sSHR0cFJlcXVlc3Quc2VuZCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCxcbiAgcG9zdCxcbiAgcmVxdWVzdFxufVxuXG5mdW5jdGlvbiB1bmRlcndyaXRlQWNjZXB0SGVhZGVyKGhlYWRlcnMsIGFjY2VwdCkge1xuICBjb25zdCBuYW1lID0gQUNDRVBUX0hFQURFUiwgIC8vL1xuICAgICAgICB2YWx1ZSA9IGFjY2VwdDsgLy8vXG5cbiAgdW5kZXJ3cml0ZShoZWFkZXJzLCBuYW1lLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVyd3JpdGVDb250ZW50VHlwZUhlYWRlcihoZWFkZXJzLCBjb250ZW50VFlwZSkge1xuICBjb25zdCBuYW1lID0gQ09OVEVOVF9UWVBFX0hFQURFUiwgIC8vL1xuICAgICAgICB2YWx1ZSA9IGNvbnRlbnRUWXBlOyAvLy9cblxuICB1bmRlcndyaXRlKGhlYWRlcnMsIG5hbWUsIHZhbHVlKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXZlbHMgfSBmcm9tIFwiLi9sZXZlbHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWV0aG9kcyB9IGZyb20gXCIuL21ldGhvZHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaGVhZGVycyB9IGZyb20gXCIuL2hlYWRlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMga2V5Q29kZXMgfSBmcm9tIFwiLi9rZXlDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbmNvZGluZ3MgfSBmcm9tIFwiLi9lbmNvZGluZ3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2hhcmFjdGVycyB9IGZyb20gXCIuL2NoYXJhY3RlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzQ29kZXMgfSBmcm9tIFwiLi9zdGF0dXNDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb250ZW50VHlwZXMgfSBmcm9tIFwiLi9jb250ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzTWVzc2FnZXMgfSBmcm9tIFwiLi9zdGF0dXNNZXNzYWdlc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcGF0aFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBodHRwVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2h0dHBcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3ZlcnNpb25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGFqYXhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYWpheFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgViA9IFwidlwiO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9BTVBFUlNBTkQgPSBcIiZhbXA7XCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9MRVNTX1RIQU4gPSBcIiZsdDtcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0dSRUFURVJfVEhBTiA9IFwiJmd0O1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFU0NBUEVEX0FNUEVSU0FORCwgRVNDQVBFRF9MRVNTX1RIQU4sIEVTQ0FQRURfR1JFQVRFUl9USEFOIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3Qgc2FuaXRpc2VkQ29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgRVNDQVBFRF9BTVBFUlNBTkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIEVTQ0FQRURfTEVTU19USEFOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBFU0NBUEVEX0dSRUFURVJfVEhBTik7XG5cbiAgcmV0dXJuIHNhbml0aXNlZENvbnRlbnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCB0eXBlVHlwZSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IG5hbWVUeXBlID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgbnVtYmVyVHlwZSA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgY29tbWVudFR5cGUgPSBcImNvbW1lbnRcIjtcbmV4cG9ydCBjb25zdCBlbmRPZkxpbmVUeXBlID0gXCJlbmQtb2YtbGluZVwiO1xuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2VUeXBlID0gXCJ3aGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3Qgc3RyaW5nTGl0ZXJhbFR5cGUgPSBcInN0cmluZy1saXRlcmFsXCI7XG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lQ29tbWVudFR5cGUgPSBgJHtlbmRPZkxpbmVUeXBlfSAke2NvbW1lbnRUeXBlfWA7XG5leHBvcnQgY29uc3Qgc2luZ2xlTGluZUNvbW1lbnRUeXBlID0gYHNpbmdsZS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCByZWd1bGFyRXhwcmVzc2lvblR5cGUgPSBcInJlZ3VsYXItZXhwcmVzc2lvblwiO1xuZXhwb3J0IGNvbnN0IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgPSBgZW5kLW9mLW11bHRpLWxpbmUgJHtjb21tZW50VHlwZX1gO1xuZXhwb3J0IGNvbnN0IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZSA9IGBzdGFydC1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlID0gYG1pZGRsZS1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB0eXBlVHlwZSxcbiAgbmFtZVR5cGUsXG4gIG51bWJlclR5cGUsXG4gIGNvbW1lbnRUeXBlLFxuICBlbmRPZkxpbmVUeXBlLFxuICB3aGl0ZXNwYWNlVHlwZSxcbiAgc3RyaW5nTGl0ZXJhbFR5cGUsXG4gIGVuZE9mTGluZUNvbW1lbnRUeXBlLFxuICBzaW5nbGVMaW5lQ29tbWVudFR5cGUsXG4gIHJlZ3VsYXJFeHByZXNzaW9uVHlwZSxcbiAgZW5kT2ZNdWx0aUxpbmVDb21tZW50VHlwZSxcbiAgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlLFxuICBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcywgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBzYW5pdGlzZUNvbnRlbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvY29udGVudFwiO1xuaW1wb3J0IHsgY29tbWVudFR5cGUsIGVuZE9mTGluZVR5cGUsIHdoaXRlc3BhY2VUeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHN0cmxlbiB9ID0gc3RyaW5nVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNvbnRlbnQsIHNpZ25pZmljYW50KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMuc2lnbmlmaWNhbnQgPSBzaWduaWZpY2FudDtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBcbiAgZ2V0Q29udGVudExlbmd0aChuYWl2ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IG5haXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmxlbih0aGlzLmNvbnRlbnQpOyAvLy9cblxuICAgIHJldHVybiBjb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgaXNTaWduaWZpY2FudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudDtcbiAgfVxuICBcbiAgaXNDb21tZW50VG9rZW4oKSB7XG4gICAgY29uc3QgdHlwZUluY2x1ZGVzQ29tbWVudFR5cGUgPSB0aGlzLnR5cGUuaW5jbHVkZXMoY29tbWVudFR5cGUpLFxuICAgICAgICAgIGNvbW1lbnRUb2tlbiA9IHR5cGVJbmNsdWRlc0NvbW1lbnRUeXBlOyAvLy9cblxuICAgIHJldHVybiBjb21tZW50VG9rZW47XG4gIH1cblxuICBpc0VuZE9mTGluZVRva2VuKCkge1xuICAgIGNvbnN0IHR5cGVFbmRPZkxpbmVUeXBlID0gKHRoaXMudHlwZS5pbmNsdWRlcyhlbmRPZkxpbmVUeXBlKSksXG4gICAgICAgICAgZW5kT2ZMaW5lVG9rZW4gPSB0eXBlRW5kT2ZMaW5lVHlwZTsgLy8vXG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lVG9rZW47XG4gIH1cblxuICBpc1doaXRlc3BhY2VUb2tlbigpIHtcbiAgICBjb25zdCB0eXBlV2hpdGVzcGFjZVR5cGUgPSAodGhpcy50eXBlID09PSB3aGl0ZXNwYWNlVHlwZSksXG4gICAgICAgICAgd2hpdGVzcGFjZVRva2VuID0gdHlwZVdoaXRlc3BhY2VUeXBlOyAvLy9cblxuICAgIHJldHVybiB3aGl0ZXNwYWNlVG9rZW47XG4gIH1cblxuICBtYXRjaCh0b2tlbikge1xuICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICBpZiAodG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0b2tlbi5nZXRUeXBlKCksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgc2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgICAgIG1hdGNoZXMgPSAoKHRoaXMudHlwZSA9PT0gdHlwZSkgJiYgKHRoaXMuY29udGVudCA9PT0gY29udGVudCkgJiYgKHRoaXMuc2lnbmlmaWNhbnQgPT09IHNpZ25pZmljYW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBhc0hUTUwoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy50eXBlLCAvLy9cbiAgICAgICAgICBzYW5pdGlzZWRDb250ZW50ID0gc2FuaXRpc2VDb250ZW50KHRoaXMuY29udGVudCksXG4gICAgICAgICAgaHRtbCA9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPiR7c2FuaXRpc2VkQ29udGVudH08L3NwYW4+YDtcblxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgICAgICBzaWduaWZpY2FudCA9IHRoaXMuc2lnbmlmaWNhbnQsXG4gICAgICAgICAgdG9rZW4gPSBuZXcgQ2xhc3ModHlwZSwgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdG9rZW4gPSBudWxsO1xuXG4gICAgY29uc3QgeyByZWd1bGFyRXhwcmVzc2lvbiB9ID0gQ2xhc3MsXG4gICAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2gocmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoZXM7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE1hdGNoID0gZmlyc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgLy8vXG5cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBDbGFzcztcblxuICAgICAgICAgIHRva2VuID0gbmV3IENsYXNzKHR5cGUsIGNvbnRlbnQsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBDbGFzcyxcbiAgICAgICAgICB0b2tlbiA9IG5ldyBDbGFzcyh0eXBlLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgcmV0dXJuIG5ldyBDbGFzcyh0eXBlLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL3Rva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChDbGFzcywgY29udGVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHR5cGUgPSBjb250ZW50OyAvLy9cblxuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW47XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBTaWduaWZpY2FudFRva2VuIGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IFYgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCByZWd1bGFyRXhwcmVzc2lvbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWd1bGFyRXhwcmVzc2lvbiA9IHJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG4gIFxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbiAgXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG5cbiAgbWF0Y2goY29udGVudCkge1xuICAgIGxldCBzaWduaWZpY2FudFRva2VuID0gbnVsbDtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKHRoaXMucmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoZXM7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE1hdGNoID0gZmlyc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgLy8vXG5cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IFNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnRBbmRUeXBlKGNvbnRlbnQsIHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuICBcbiAgc3RhdGljIGZyb21Ub2tlbihUb2tlbikge1xuICAgIGNvbnN0IHsgdHlwZSwgcmVndWxhckV4cHJlc3Npb24gfSA9IFRva2VuLFxuICAgICAgICAgIHJ1bGUgPSBuZXcgUnVsZSh0eXBlLCByZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRW50cnkoZW50cnkpIHtcbiAgICBjb25zdCBlbnRyeUtleXMgPSBPYmplY3Qua2V5cyhlbnRyeSksXG4gICAgICAgICAgZmlyc3RFbnRyeUtleSA9IGZpcnN0KGVudHJ5S2V5cyksXG4gICAgICAgICAgdHlwZSA9IGZpcnN0RW50cnlLZXksIC8vL1xuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiA9IGVudHJ5W3R5cGVdLFxuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb25Gcm9tUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksXG4gICAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgXG4gICAgcmV0dXJuIHJ1bGU7IFxuICB9XG5cbiAgc3RhdGljIGZyb21UeXBlQW5kUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybikge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb25Gcm9tUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksXG4gICAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcblxuICAgIHJldHVybiBydWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ3VsYXJFeHByZXNzaW9uRnJvbVJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybihyZWd1bGFyRXhwcmVzc2lvblBhdHRlcm4pIHtcbiAgY29uc3QgZmxhZ3MgPSBWLCAgLy8vXG4gICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAocmVndWxhckV4cHJlc3Npb25QYXR0ZXJuLCBmbGFncyksXG4gICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uID0gcmVnRXhwOyAvLy9cblxuICByZXR1cm4gcmVndWxhckV4cHJlc3Npb247XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnQgY29uc3QgcGx1cyA9IFwiK1wiO1xyXG5leHBvcnQgY29uc3Qgb3BhcXVlID0gXCIuXCI7XHJcbmV4cG9ydCBjb25zdCBlcHNpbG9uID0gJ1x1MDNCNSc7XHJcbmV4cG9ydCBjb25zdCB3aWxkY2FyZCA9IFwiLlwiO1xyXG5leHBvcnQgY29uc3QgYXN0ZXJpc2sgPSBcIipcIjtcclxuZXhwb3J0IGNvbnN0IGVsbGlwc2lzID0gXCIuLi5cIjtcclxuZXhwb3J0IGNvbnN0IHNlcGFyYXRvciA9IFwiOjo9XCI7XHJcbmV4cG9ydCBjb25zdCBzZW1pT3BhcXVlID0gXCIuLlwiO1xyXG5leHBvcnQgY29uc3QgdGVybWluYXRvciA9IFwiO1wiO1xyXG5leHBvcnQgY29uc3QgdmVydGljYWxCYXIgPSBcInxcIjtcclxuZXhwb3J0IGNvbnN0IG9wZW5CcmFja2V0ID0gXCIoXCI7XHJcbmV4cG9ydCBjb25zdCBjbG9zZUJyYWNrZXQgPSBcIilcIjtcclxuZXhwb3J0IGNvbnN0IHF1ZXN0aW9uTWFyayA9IFwiP1wiO1xyXG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lID0gXCI8RU5EX09GX0xJTkU+XCI7XHJcbmV4cG9ydCBjb25zdCBub1doaXRlc3BhY2UgPSBcIjxOT19XSElURVNQQUNFPlwiO1xyXG5leHBvcnQgY29uc3Qgc3RhcnRPZkNvbnRlbnQgPSBcIjxTVEFSVF9PRl9DT05URU5UPlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHBsdXMsXHJcbiAgb3BhcXVlLFxyXG4gIGVwc2lsb24sXHJcbiAgd2lsZGNhcmQsXHJcbiAgYXN0ZXJpc2ssXHJcbiAgZWxsaXBzaXMsXHJcbiAgc2VwYXJhdG9yLFxyXG4gIHNlbWlPcGFxdWUsXHJcbiAgdGVybWluYXRvcixcclxuICB2ZXJ0aWNhbEJhcixcclxuICBvcGVuQnJhY2tldCxcclxuICBjbG9zZUJyYWNrZXQsXHJcbiAgcXVlc3Rpb25NYXJrLFxyXG4gIGVuZE9mTGluZSxcclxuICBub1doaXRlc3BhY2UsXHJcbiAgc3RhcnRPZkNvbnRlbnRcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNBc0VudHJpZXMocnVsZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHJ1bGVzLm1hcCgocnVsZSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gcnVsZUFzRW50cnkocnVsZSk7XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH0pO1xuXG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJ1bGVzQXNFbnRyaWVzXG59O1xuXG5mdW5jdGlvbiBydWxlQXNFbnRyeShydWxlKSB7XG4gIGNvbnN0IHR5cGUgPSBydWxlLmdldFR5cGUoKSxcbiAgICAgICAgcmVndWxhckV4cHJlc3Npb24gPSBydWxlLmdldFJlZ3VsYXJFeHByZXNzaW9uKCksXG4gICAgICAgIHsgc291cmNlIH0gPSByZWd1bGFyRXhwcmVzc2lvbixcbiAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgW3R5cGVdOiBzb3VyY2VcbiAgICAgICAgfTtcblxuICByZXR1cm4gZW50cnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi9ydWxlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0Zyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgY29uc3QgcnVsZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICBjb25zdCBydWxlID0gUnVsZS5mcm9tRW50cnkoZW50cnkpO1xuXG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0pO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcykge1xuICBjb25zdCBJbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcyksXG4gICAgICAgIE5vdEluQ29tbWVudENsYXNzZXMgPSBOb3RJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSxcbiAgICAgICAgbGV4ZXIgPSBuZXcgQ2xhc3MocnVsZXMsIEluQ29tbWVudENsYXNzZXMsIE5vdEluQ29tbWVudENsYXNzZXMpO1xuXG4gIHJldHVybiBsZXhlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0Zyb21FbnRyaWVzLFxuICBsZXhlckZyb21SdWxlc1xufTtcblxuZnVuY3Rpb24gSW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcykge1xuICBjb25zdCB7IEVuZE9mTGluZUNvbW1lbnRUb2tlbiwgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gPSBDbGFzcztcblxuICBjb25zdCBJbkNvbW1lbnRDbGFzc2VzID0gW1xuICAgIEVuZE9mTGluZUNvbW1lbnRUb2tlbixcbiAgICBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcbiAgICBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlblxuICBdO1xuXG4gIHJldHVybiBJbkNvbW1lbnRDbGFzc2VzO1xufVxuXG5mdW5jdGlvbiBOb3RJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSB7XG4gIGNvbnN0IHsgRW5kT2ZMaW5lVG9rZW4sXG4gICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxuICAgICAgICAgIFNpbmdsZUxpbmVDb21tZW50VG9rZW4sXG4gICAgICAgICAgUmVndWxhckV4cHJlc3Npb25Ub2tlbixcbiAgICAgICAgICBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxuICAgICAgICAgIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSA9IENsYXNzO1xuXG4gIGNvbnN0IE5vdEluQ29tbWVudENsYXNzZXMgPSBbXG4gICAgRW5kT2ZMaW5lVG9rZW4sXG4gICAgV2hpdGVzcGFjZVRva2VuLFxuICAgIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXG4gICAgU2luZ2xlTGluZUNvbW1lbnRUb2tlbixcbiAgICBSZWd1bGFyRXhwcmVzc2lvblRva2VuLFxuICAgIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW5cbiAgXTtcblxuICByZXR1cm4gTm90SW5Db21tZW50Q2xhc3Nlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OlxcXFx8fFxcXFwofFxcXFwpfFxcXFw/fFxcXFwqfFxcXFwrfFxcXFwuXFxcXC5cXFxcLnxcXFxcLlxcXFwufFxcXFwufDo6PXw7fFx1MDNCNXw8U1RBUlRfT0ZfQ09OVEVOVD58PE5PX1dISVRFU1BBQ0U+fDxFTkRfT0ZfTElORT4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibnVtYmVyXCI6IFwiXig/OjB8WzEtOV1bMC05XSopXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIl5bXFxcXHd+XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ0eXBlXCI6IFwiXlxcXFxbW15cXFxcXV0rXFxcXF1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5Db21tZW50RnJvbVRva2VuQW5kSW5Db21tZW50KHRva2VuLCBpbkNvbW1lbnQpIHtcbiAgY29uc3QgdG9rZW5Db21tZW50VG9rZW4gPSB0b2tlbi5pc0NvbW1lbnRUb2tlbigpO1xuXG4gIGlmICh0b2tlbkNvbW1lbnRUb2tlbikge1xuICAgIGNvbnN0IGNvbW1lbnRUb2tlbiA9IHRva2VuLCAvLy9cbiAgICAgICAgICBjb21tZW50VG9rZW5JbkNvbW1lbnRQcmVzZXJ2aW5nID0gY29tbWVudFRva2VuLmlzSW5Db21tZW50UHJlc2VydmluZygpO1xuXG4gICAgaW5Db21tZW50ID0gY29tbWVudFRva2VuSW5Db21tZW50UHJlc2VydmluZzsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGluQ29tbWVudDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgaW5Db21tZW50RnJvbVRva2VuQW5kSW5Db21tZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy90b2tlblwiO1xyXG5pbXBvcnQgeyBydWxlc0Zyb21FbnRyaWVzLCBsZXhlckZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvbGV4ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbW1vbkxleGVyIHtcclxuICBjb25zdHJ1Y3RvcihydWxlcywgSW5Db21tZW50Q2xhc3NlcywgTm90SW5Db21tZW50Q2xhc3Nlcykge1xyXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG4gICAgdGhpcy5JbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3NlcztcclxuICAgIHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcyA9IE5vdEluQ29tbWVudENsYXNzZXM7XHJcbiAgfVxyXG4gIFxyXG4gIGdldFJ1bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucnVsZXM7XHJcbiAgfVxyXG5cclxuICBnZXRJbkNvbW1lbnRDbGFzc2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuSW5Db21tZW50Q2xhc3NlcztcclxuICB9XHJcblxyXG4gIGdldE5vdEluQ29tbWVudENsYXNzZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5Ob3RJbkNvbW1lbnRDbGFzc2VzO1xyXG4gIH1cclxuXHJcbiAgdG9rZW5pc2UoY29udGVudCwgaW5Db21tZW50ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChjb250ZW50ICE9PSBFTVBUWV9TVFJJTkcpIHtcclxuICAgICAgbGV0IHRva2VuID0gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IENsYXNzZXMgPSBpbkNvbW1lbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkluQ29tbWVudENsYXNzZXMgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcztcclxuXHJcbiAgICAgIENsYXNzZXMuc29tZSgoQ2xhc3MpID0+IHtcclxuICAgICAgICBpZiAoQ2xhc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgIHRva2VuID0gQ2xhc3MubWF0Y2goY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHRva2VuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcclxuICAgICAgICBsZXQgc2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMucnVsZXMuc29tZSgocnVsZSkgPT4ge1xyXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IHJ1bGUubWF0Y2goY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBzaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjb250ZW50ICcke2NvbnRlbnR9JyBjYW5ub3QgYmUgdG9rZW5pc2VkLmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICBpbkNvbW1lbnQgPSBpbkNvbW1lbnRGcm9tVG9rZW5BbmRJbkNvbW1lbnQodG9rZW4sIGluQ29tbWVudCk7XHJcblxyXG4gICAgICBjb25zdCBuYWl2ZSA9IHRydWUsXHJcbiAgICAgICAgICAgIHRva2VuQ29udGVudExlbmd0aCA9IHRva2VuLmdldENvbnRlbnRMZW5ndGgobmFpdmUpLFxyXG4gICAgICAgICAgICBzdGFydCA9IHRva2VuQ29udGVudExlbmd0aDsgLy8vXHJcblxyXG4gICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b2tlbnM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MpIHtcclxuICAgIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXHJcbiAgICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyksXHJcbiAgICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XHJcblxyXG4gICAgcmV0dXJuIGxleGVyO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcclxuICAgIGNvbnN0IGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcclxuXHJcbiAgICByZXR1cm4gbGV4ZXI7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoQ2xhc3MsIGVudHJpZXMpIHtcclxuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tRW50cmllcyhlbnRyaWVzKSxcclxuICAgICAgICAgIGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcclxuXHJcbiAgICByZXR1cm4gbGV4ZXI7XHJcbiAgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRva2VuIGZyb20gXCIuLi90b2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25TaWduaWZpY2FudFRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudCA9IGZhbHNlLFxuICAgICAgICAgIG5vblNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQpO1xuXG4gICAgcmV0dXJuIG5vblNpZ25pZmljYW50VG9rZW47XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudCA9IGZhbHNlLFxuICAgICAgICAgIG5vblNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQpO1xuXG4gICAgcmV0dXJuIG5vblNpZ25pZmljYW50VG9rZW47XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSBmYWxzZSxcbiAgICAgICAgICBub25TaWduaWZpY2FudFRva2VuID0gVG9rZW4uZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlLCBzaWduaWZpY2FudCk7XG5cbiAgICByZXR1cm4gbm9uU2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgd2hpdGVzcGFjZVR5cGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hpdGVzcGFjZVRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIHN0YXRpYyB0eXBlID0gd2hpdGVzcGFjZVR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL15bXFx0XFx2IF0rLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChXaGl0ZXNwYWNlVG9rZW4sIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoV2hpdGVzcGFjZVRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgcmVndWxhckV4cHJlc3Npb25UeXBlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gZXh0ZW5kcyBTaWduaWZpY2FudFRva2VuIHtcbiAgc3RhdGljIHR5cGUgPSByZWd1bGFyRXhwcmVzc2lvblR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL15cXC8oPzpcXFxcW15cXHNdfFteXFwvXFxyXFxuXFxmXSkqXFwvLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChSZWd1bGFyRXhwcmVzc2lvblRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVUeXBlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgYXNIVE1MKCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBodG1sID0gY29udGVudDsgLy8vXG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lVHlwZTtcblxuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXig/OlxcclxcbnxcXHJ8XFxufFxcZikvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBOb25TaWduaWZpY2FudFRva2VuLm1hdGNoKEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgc3RyaW5nTGl0ZXJhbFR5cGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuY29uc3QgeyBzdWJzdHJpbmcgfSA9IHN0cmluZ1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nTGl0ZXJhbFRva2VuIGV4dGVuZHMgU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGdldFN0cmluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksXG4gICAgICAgICAgY29udGVudExlbmd0aCA9IHRoaXMuZ2V0Q29udGVudExlbmd0aCgpLFxuICAgICAgICAgIHN0YXJ0ID0gMSxcbiAgICAgICAgICBlbmQgPSBjb250ZW50TGVuZ3RoIC0gMSxcbiAgICAgICAgICBzdHJpbmcgPSBzdWJzdHJpbmcoY29udGVudCwgc3RhcnQsIGVuZCk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBzdHJpbmdMaXRlcmFsVHlwZTtcblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIFNpZ25pZmljYW50VG9rZW4ubWF0Y2goQ2xhc3MsIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFRva2VuIGZyb20gXCIuLi8uLi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiBleHRlbmRzIFN0cmluZ0xpdGVyYWxUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eXCIoPzpcXFxcW15cXHNdfFteXCJcXFxcXFxyXFxuXSkqXCIvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTdHJpbmdMaXRlcmFsVG9rZW4ubWF0Y2goRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTdHJpbmdMaXRlcmFsVG9rZW4uZnJvbUNvbnRlbnQoRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5pbXBvcnQgQ29tbW9uTGV4ZXIgZnJvbSBcIi4uL2NvbW1vbi9sZXhlclwiO1xyXG5pbXBvcnQgV2hpdGVzcGFjZVRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCI7XHJcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblRva2VuIGZyb20gXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCTkZMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICB0b2tlbnNGcm9tQk5GKGJuZikge1xyXG4gICAgY29uc3QgY29udGVudCA9IGJuZiwgIC8vL1xyXG4gICAgICAgICAgdG9rZW5zID0gc3VwZXIudG9rZW5pc2UoY29udGVudCk7XHJcblxyXG4gICAgcmV0dXJuIHRva2VucztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoQk5GTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhCTkZMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhCTkZMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwiZGlnaXRcIjogXCJeXFxcXGQrXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYnJhY2tldFwiOiBcIl4oPzpcXFxcKHxcXFxcKSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJvcGVyYXRvclwiOiBcIl4oPzpcXFxcK3wtfFxcXFwqfFxcXFwvKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc11cIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0cmluZ0xpdGVyYWxUb2tlbiBmcm9tIFwiLi4vLi4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZXh0ZW5kcyBTdHJpbmdMaXRlcmFsVG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXicoPzpcXFxcW15cXHNdfFteJ1xcXFxcXHJcXG5dKSonLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU3RyaW5nTGl0ZXJhbFRva2VuLm1hdGNoKFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RyaW5nTGl0ZXJhbFRva2VuLmZyb21Db250ZW50KFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IHNpbmdsZUxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICBjb25zdCBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gZmFsc2U7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gc2luZ2xlTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTaW5nbGVMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eI1teXFxyXFxuXFxmXSovO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTaW5nbGVMaW5lQ29tbWVudFRva2VuLm1hdGNoKFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2luZ2xlTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiBleHRlbmRzIE5vblNpZ25pZmljYW50VG9rZW4ge1xuICBpc0luQ29tbWVudFByZXNlcnZpbmcoKSB7XG4gICAgY29uc3QgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lQ29tbWVudFR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5mcm9tQ29udGVudChFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgIGNvbnN0IGluQ29tbWVudFByZXNlcnZpbmcgPSBmYWxzZTtcblxuICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBlbmRPZk11bHRpTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14jIyMvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5tYXRjaChQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgIGNvbnN0IGluQ29tbWVudFByZXNlcnZpbmcgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZTtcblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4ubWF0Y2goQ2xhc3MsIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7IHJldHVybiBOb25TaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14jIyMvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICBjb25zdCBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gdHJ1ZTtcblxuICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvbWlkZGxlT2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpbXlxcclxcblxcZl0rPyg/PSMjIyl8W15cXHJcXG5cXGZdKykvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5tYXRjaChQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5pbXBvcnQgQ29tbW9uTGV4ZXIgZnJvbSBcIi4uL2NvbW1vbi9sZXhlclwiO1xyXG5pbXBvcnQgV2hpdGVzcGFjZVRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCI7XHJcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblRva2VuIGZyb20gXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvc2luZ2x5UXVvdGVkXCI7XHJcbmltcG9ydCBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZS9weXRob25TdHlsZVwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZi9weXRob25TdHlsZVwiO1xyXG5pbXBvcnQgUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL3B5dGhvblN0eWxlXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9weXRob25TdHlsZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKEJhc2ljTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhCYXNpY0xleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEJhc2ljTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgZW5kT2ZMaW5lVHlwZSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuIGV4dGVuZHMgU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGFzSFRNTCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksXG4gICAgICAgICAgaHRtbCA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IGVuZE9mTGluZVR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi90b2tlbi9zaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiBleHRlbmRzIFNpZ25pZmljYW50VG9rZW4ge1xuICBpc0luQ29tbWVudFByZXNlcnZpbmcoKSB7XG4gICAgY29uc3QgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lQ29tbWVudFR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5mcm9tQ29udGVudChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFNpbmdsZUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eXFwvXFwvW15cXHJcXG5cXGZdKi87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIFNpbmdsZUxpbmVDb21tZW50VG9rZW4ubWF0Y2goQ1N0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2luZ2xlTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcKlxcLy87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcL1xcKi87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ubWF0Y2goQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXig/OlteXFxyXFxuXFxmXSs/KD89XFwqXFwvKXxbXlxcclxcblxcZl0rKS87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSdWxlIH0gZnJvbSBcIi4vcnVsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0eXBlcyB9IGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIi4vc3BlY2lhbFN5bWJvbHNcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBydWxlc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9ydWxlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXhlclV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJORkxleGVyIH0gZnJvbSBcIi4vYm5mL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2ljTGV4ZXIgfSBmcm9tIFwiLi9iYXNpYy9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25MZXhlciB9IGZyb20gXCIuL2NvbW1vbi9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50L2VuZE9mTGluZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L2VuZE9mTGluZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFdoaXRlc3BhY2VUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L3doaXRlc3BhY2VcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2YvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL3B5dGhvblN0eWxlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwibWVkaWFcIjogXCJeQG1lZGlhXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwia2V5ZnJhbWVzXCI6IFwiXkBrZXlmcmFtZXNcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJjb2xvdXJcIjogXCJeIyg/OlswLTlhLWZBLUZdezZ9fFswLTlhLWZBLUZdezN9KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImltcG9ydGFudFwiOiBcIl4haW1wb3J0YW50XCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicGVyY2VudGFnZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspJVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImZyZXF1ZW5jeVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86aHp8a2h6KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImZyYWN0aW9uXCI6IFwiXlsxLTldWzAtOV0qP2ZyXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibGVuZ3RoXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKykoPzpweHxjbXxtbXxpbnxwdHxwYylcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJhbmdsZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86ZGVnfHJhZHxncmFkKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInRpbWVcIjogXCJeKD86WzAtOV0rfFswLTldKlxcXFwuWzAtOV0rKSg/OnN8bXMpXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicmVtc1wiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspcmVtXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiZW1zXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKyllbVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl5bMC05XSt8WzAtOV0qXFxcXC5bMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXjt8Ojp8OnxcXFxcLnwsfFxcXFx8PXx+PXw9fD58XFxcXHt8XFxcXH18XFxcXCh8XFxcXCl8XFxcXFt8XFxcXF1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZGVudGlmaWVyXCI6IFwiXltfYS16QS1aMC05XFxcXC1dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImxvZ2ljYWwtb3BlcmF0b3JcIjogXCJeKD86YW5kfG5vdCkkXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicGx1cy1vci1taW51c1wiOiBcIl5bXFxcXCtcXFxcLV1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDsgLy8vXHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsOyAvLy9cclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKENTU0xleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoQ1NTTGV4ZXIsIHJ1bGVzKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoQ1NTTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICAgIGRvY3VtZW50ICAgICAgICAgICAgICAgICA6Oj0gICggcnVsZSB8IGVycm9yICkrIDtcblxuICAgICAgcnVsZSAgICAgICAgICAgICAgICAgICAgIDo6PSAgbmFtZSBvcGFjaXR5TW9kaWZpZXI/IFwiOjo9XCIgZGVmaW5pdGlvbnMgXCI7XCIgO1xuXG4gICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBkZWZpbml0aW9ucyAgICAgICAgICAgICAgOjo9ICBkZWZpbml0aW9uICggXCJ8XCIgZGVmaW5pdGlvbiApKiA7XG5cbiAgICAgIGRlZmluaXRpb24gICAgICAgICAgICAgICA6Oj0gIHBhcnQrIHByZWNlZGVuY2U/IDtcbiBcbiAgICAgIHBhcnQgICAgICAgICAgICAgICAgICAgICA6Oj0gIG5vblRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtaW5hbFBhcnQgcXVhbnRpZmllcipcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBub25UZXJtaW5hbFBhcnQgICAgICAgICAgOjo9ICBjaG9pY2VPZlBhcnRzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNlcXVlbmNlT2ZQYXJ0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBydWxlTmFtZSBjYWxsQWhlYWRNb2RpZmllcj9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICB0ZXJtaW5hbFBhcnQgICAgICAgICAgICAgOjo9ICBzaWduaWZpY2FudFRva2VuVHlwZVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJlZ3VsYXJFeHByZXNzaW9uXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdHJpbmdMaXRlcmFsXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgZW5kT2ZMaW5lXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgd2lsZGNhcmRcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlcHNpbG9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vV2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGFydE9mQ29udGVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgIHNlcXVlbmNlT2ZQYXJ0cyAgICAgICAgICA6Oj0gIFwiKFwiIHBhcnQgcGFydCsgXCIpXCIgO1xuXG4gICAgICBjaG9pY2VPZlBhcnRzICAgICAgICAgICAgOjo9ICBcIihcIiBwYXJ0Q2hvaWNlICggXCJ8XCIgcGFydENob2ljZSApKyBcIilcIiA7XG5cbiAgICAgIHBhcnRDaG9pY2UgICAgICAgICAgICAgICA6Oj0gIHBhcnQgcHJlY2VkZW5jZT8gO1xuXG4gICAgICBydWxlTmFtZSAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBzaWduaWZpY2FudFRva2VuVHlwZSAgICAgOjo9ICBbdHlwZV0gO1xuXG4gICAgICByZWd1bGFyRXhwcmVzc2lvbiAgICAgICAgOjo9ICBbcmVndWxhci1leHByZXNzaW9uXSA7XG5cbiAgICAgIHN0cmluZ0xpdGVyYWwgICAgICAgICAgICA6Oj0gIFtzdHJpbmctbGl0ZXJhbF0gO1xuXG4gICAgICBwcmVjZWRlbmNlICAgICAgICAgICAgICAgOjo9ICBcIihcIiBbbnVtYmVyXT8gXCIpXCIgO1xuICAgICAgXG4gICAgICBlbmRPZkxpbmUgICAgICAgICAgICAgICAgOjo9ICBcIjxFTkRfT0ZfTElORT5cIiA7XG4gICAgICBcbiAgICAgIHdpbGRjYXJkICAgICAgICAgICAgICAgICA6Oj0gIFwiLlwiIDtcblxuICAgICAgZXBzaWxvbiAgICAgICAgICAgICAgICAgIDo6PSAgXCJcdTAzQjVcIiA7XG5cbiAgICAgIG5vV2hpdGVzcGFjZSAgICAgICAgICAgICA6Oj0gIFwiPE5PX1dISVRFU1BBQ0U+XCIgOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICBzdGFydE9mQ29udGVudCAgICAgICAgICAgOjorICBcIjxTVEFSVF9PRl9DT05URU5UPlwiOyBcbiAgICAgIFxuICAgICAgcXVhbnRpZmllciAgICAgICAgICAgICAgIDo6PSAgb3B0aW9uYWxRdWFudGlmaWVyXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvbmVPck1vcmVRdWFudGlmaWVyXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgemVyb09yTW9yZVF1YW50aWZpZXJcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgIG9wYWNpdHlNb2RpZmllciAgICAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPiggXCIuXCIgfCBcIi4uXCIgKTtcbiAgICAgIFxuICAgICAgY2FsbEFoZWFkTW9kaWZpZXIgICAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIuLi5cIiA7XG5cbiAgICAgIG9wdGlvbmFsUXVhbnRpZmllciAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiP1wiIDtcblxuICAgICAgb25lT3JNb3JlUXVhbnRpZmllciAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIrXCIgO1xuXG4gICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllciAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIipcIiA7XG5cbiAgICAgIGVycm9yLiAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRURfQkFDS1NMQVNIID1cIlxcXFxcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0RPVUJMRV9RVU9URSA9IFwiXFxcIlwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFkZGluZ0Zyb21QYWRkaW5nTGVuZ3RoKHBhZGRpbmdMZW5ndGgpIHtcbiAgbGV0IHBhZGRpbmcgPSBFTVBUWV9TVFJJTkc7XG5cbiAgZm9yIChsZXQgcG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IHBhZGRpbmdMZW5ndGg7IHBvc2l0aW9uKyspIHtcbiAgICBwYWRkaW5nICs9IFNQQUNFX0NIQVJBQ1RFUjtcbiAgfVxuXG4gIHJldHVybiBwYWRkaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcbmltcG9ydCB7IHBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aCB9IGZyb20gXCIuL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuY29uc3QgeyBjbGVhciB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IG9wYXF1ZTogb3BhcXVlU3BlY2lhbFN5bWJvbCwgc2VtaU9wYXF1ZTogc2VtaU9wYXF1ZVNwZWNpYWxTeW1ib2wgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZ2V0RGVmaW5pdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbnM7XG4gIH1cblxuICBzZXROYW1lKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgfVxuXG4gIHNldERlZmluaXRpb25zKGRlZmluaXRpb25zKSB7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICB9XG5cbiAgaXNPcGFxdWUoKSB7XG4gICAgY29uc3Qgb3BhcXVlID0gKHRoaXMub3BhY2l0eSA9PT0gb3BhcXVlU3BlY2lhbFN5bWJvbCk7XG5cbiAgICByZXR1cm4gb3BhcXVlO1xuICB9XG5cbiAgaXNTZW1pT3BhcXVlKCkge1xuICAgIGNvbnN0IHNlbWlPcGFxdWUgPSAodGhpcy5vcGFjaXR5ID09PSBzZW1pT3BhcXVlU3BlY2lhbFN5bWJvbCk7XG5cbiAgICByZXR1cm4gc2VtaU9wYXF1ZTtcbiAgfVxuXG4gIGlzVHJhbnNwYXJlbnQoKSB7XG4gICAgY29uc3Qgc2VtaU9wYXF1ZSA9ICh0aGlzLm9wYWNpdHkgPT09IG51bGwpO1xuXG4gICAgcmV0dXJuIHNlbWlPcGFxdWU7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRoaXMubmFtZSwgLy8vXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IFtdLFxuICAgICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHRoaXMuTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lLCBzdGF0ZSksXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSksXG4gICAgICAgICAgc2F2ZWRQcmVjZWRlbmNlID0gc3RhdGUuZ2V0U2F2ZWRQcmVjZWRlbmNlKCk7XG5cbiAgICBsZXQgbm9kZSA9IG5vblRlcm1pbmFsTm9kZTsgLy8vXG5cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuXG4gICAgcGFyc2VkID0gdGhpcy5kZWZpbml0aW9ucy5zb21lKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICBjbGVhcihjaGlsZE5vZGVzKTtcblxuICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IGRlZmluaXRpb24uZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgICBzdGF0ZS5zZXRQcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuXG4gICAgICBjYWxsYmFjayA9ICgpID0+IHsgIC8vL1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5nZXRQcmVjZWRlbmNlKCk7XG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG5cbiAgICAgICAgcGFyc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgbm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV3cml0dGVuTm9uVGVybWluYWxOb2RlID0gbm9uVGVybWluYWxOb2RlLnJld3JpdGUoc3RhdGUpO1xuXG4gICAgICAgIGlmIChyZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcblxuICAgICAgICAgICAgbm9kZSA9IHJld3JpdHRlbk5vblRlcm1pbmFsTm9kZTsgLy8vXG5cbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIGNvbnN0IGVtcHR5ID0gbm9kZS5pc0VtcHR5KCk7XG5cbiAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICBjb25zdCB1bnByZWNlZGVudGVkID0gbm9kZS5pc1VucHJlY2VkZW50ZWQoKTtcblxuICAgICAgICAgIGlmICh1bnByZWNlZGVudGVkKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgaWYgKGNhbGxBaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSk7XG5cbiAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuXG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgbm9kZS5yZXNldENoaWxkTm9kZXNQYXJlbnROb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfTtcblxuICAgICAgcGFyc2VkID0gZGVmaW5pdGlvbi5wYXJzZShjaGlsZE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHN0YXRlLnJlc2V0UHJlY2VkZW5jZShzYXZlZFByZWNlZGVuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIG5vZGVzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmIChjYWxsQWhlYWQgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLnJlc2V0UHJlY2VkZW5jZShzYXZlZFByZWNlZGVuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5Ob25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUpOyB9XG5cbiAgYXNTdHJpbmcobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBtdWx0aUxpbmUgPSB0cnVlKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbnNMZW5ndGggPSB0aGlzLmRlZmluaXRpb25zLmxlbmd0aDtcblxuICAgIG11bHRpTGluZSA9IG11bHRpTGluZSAmJiAoZGVmaW5pdGlvbnNMZW5ndGggPiAxKTsgIC8vL1xuXG4gICAgY29uc3QgbWF4aW11bVBhZGRpbmcgPSBwYWRkaW5nRnJvbVBhZGRpbmdMZW5ndGgobWF4aW11bVJ1bGVOYW1lTGVuZ3RoKSxcbiAgICAgICAgICBkZWZpbml0aW9uc1N0cmluZyA9IHRoaXMuZGVmaW5pdGlvbnMucmVkdWNlKChkZWZpbml0aW9uc1N0cmluZywgZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zU3RyaW5nID09PSBFTVBUWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbnNTdHJpbmcgPSBkZWZpbml0aW9uU3RyaW5nOyAvLy9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZmluaXRpb25zU3RyaW5nID0gbXVsdGlMaW5lID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZGVmaW5pdGlvbnNTdHJpbmd9XG5cbiR7bWF4aW11bVBhZGRpbmd9ICAgfCAke2RlZmluaXRpb25TdHJpbmd9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZGVmaW5pdGlvbnNTdHJpbmd9IHwgJHtkZWZpbml0aW9uU3RyaW5nfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uc1N0cmluZztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5uYW1lLCAvLy9cbiAgICAgICAgICBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aCxcbiAgICAgICAgICBvcGFjaXR5U3RyaW5nID0gKHRoaXMub3BhY2l0eSA9PT0gbnVsbCk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSwgLy8vXG4gICAgICAgICAgb3BhY2l0eVN0cmluZ0xlbmd0aCA9IG9wYWNpdHlTdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmdMZW5ndGggPSBtYXhpbXVtUnVsZU5hbWVMZW5ndGggLSBydWxlTmFtZUxlbmd0aCAtIG9wYWNpdHlTdHJpbmdMZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IHBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aChwYWRkaW5nTGVuZ3RoKTtcblxuICAgIGNvbnN0IHNlbWljb2xvblN0cmluZyA9IG11bHRpTGluZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcblxuJHttYXhpbXVtUGFkZGluZ30gICA7YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgO1wiLFxuICAgICAgICAgIHN0cmluZyA9IGBcblxuJHt0aGlzLm5hbWV9JHtvcGFjaXR5U3RyaW5nfSR7cGFkZGluZ30gOjo9ICR7ZGVmaW5pdGlvbnNTdHJpbmd9JHtzZW1pY29sb25TdHJpbmd9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWVPcGFjaXR5QW5kRGVmaW5pdGlvbnMoQ2xhc3MsIG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKSB7XG4gICAgaWYgKGRlZmluaXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmluaXRpb25zID0gb3BhY2l0eTsgIC8vL1xuXG4gICAgICBvcGFjaXR5ID0gbmFtZTsgLy8vXG5cbiAgICAgIG5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gUnVsZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcnVsZSA9IG5ldyBDbGFzcyhuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBwdXNoLCBmaXJzdCwgZm9yd2FyZHNTb21lLCBiYWNrd2FyZHNTb21lIH0gPSBhcnJheVV0aWxpdGllcztcblxuZnVuY3Rpb24gZ2V0TXVsdGlwbGljaXR5KCkge1xuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgbXVsdGlwbGljaXR5ID0gY2hpbGROb2Rlc0xlbmd0aDsgIC8vL1xuXG4gIHJldHVybiBtdWx0aXBsaWNpdHk7XG59XG5cbmZ1bmN0aW9uIG1hcENoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcChjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gc29tZUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLnNvbWUoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maW5kKGNhbGxiYWNrKTsgfVxuXG5mdW5jdGlvbiBldmVyeUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLmV2ZXJ5KGNhbGxiYWNrKTsgfVxuXG5mdW5jdGlvbiBmaWx0ZXJDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maWx0ZXIoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIHJlZHVjZUNoaWxkTm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXMucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZE5vZGUoY2FsbGJhY2spIHsgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZvcndhcmRzU29tZUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gZm9yd2FyZHNTb21lKHRoaXMuY2hpbGROb2RlcywgY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIGJhY2t3YXJkc1NvbWUodGhpcy5jaGlsZE5vZGVzLCBjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gaW5kZXhPZkNoaWxkTm9kZShjaGlsZE5vZGUpIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkTm9kZSk7IH1cblxuZnVuY3Rpb24gc2V0Q2hpbGROb2Rlc1BhcmVudE5vZGUoY2hpbGROb2Rlcykge1xuICBpZiAoY2hpbGROb2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2hpbGROb2RlcyA9IFtcbiAgICAgIC4uLnRoaXMuY2hpbGROb2Rlc1xuICAgIF07XG4gIH1cblxuICBjb25zdCBwYXJlbnROb2RlID0gdGhpcztcblxuICBjaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNoaWxkTm9kZS5zZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZShjaGlsZE5vZGVzKSB7XG4gIGlmIChjaGlsZE5vZGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZE5vZGVzID0gW1xuICAgICAgLi4udGhpcy5jaGlsZE5vZGVzXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgY2hpbGROb2RlLnNldFBhcmVudE5vZGUocGFyZW50Tm9kZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZE5vZGUoYWRkZWRDaGlsZE5vZGUsIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgYWRkZWRDaGlsZE5vZGVzID0gW1xuICAgIGFkZGVkQ2hpbGROb2RlXG4gIF07XG5cbiAgdGhpcy5hZGRDaGlsZE5vZGVzKGFkZGVkQ2hpbGROb2Rlcywgc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkTm9kZXMoYWRkZWRDaGlsZE5vZGVzLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IGRlbGV0ZUNvdW50ID0gMDtcblxuICB0aGlzLnNwbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIGFkZGVkQ2hpbGROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkTm9kZShyZW1vdmVkQ2hpbGROb2RlKSB7XG4gIGxldCByZW1vdmVkQ2hpbGROb2RlcztcblxuICByZW1vdmVkQ2hpbGROb2RlcyA9IFtcbiAgICByZW1vdmVkQ2hpbGROb2RlXG4gIF07XG5cbiAgcmVtb3ZlZENoaWxkTm9kZXMgPSB0aGlzLnJlbW92ZUNoaWxkTm9kZXMocmVtb3ZlZENoaWxkTm9kZXMpO1xuXG4gIHJldHVybiByZW1vdmVkQ2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGROb2RlcyhyZW1vdmVkQ2hpbGROb2Rlcykge1xuICBpZiAocmVtb3ZlZENoaWxkTm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlbW92ZWRDaGlsZE5vZGVzID0gW1xuICAgICAgLi4udGhpcy5jaGlsZE5vZGVzXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IHJlbW92ZWRDaGlsZE5vZGVzTGVuZ3RoID0gcmVtb3ZlZENoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGlmIChyZW1vdmVkQ2hpbGROb2Rlc0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdFJlcGxhY2VkQ2hpbGROb2RlID0gZmlyc3QocmVtb3ZlZENoaWxkTm9kZXMpLFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihmaXJzdFJlcGxhY2VkQ2hpbGROb2RlKSwgLy8vXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSByZW1vdmVkQ2hpbGROb2Rlc0xlbmd0aCwgLy8vXG4gICAgICAgICAgYWRkZWRDaGlsZE5vZGVzID0gW107XG5cbiAgICByZW1vdmVkQ2hpbGROb2RlcyA9IHRoaXMuc3BsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBkZWxldGVDb3VudCwgYWRkZWRDaGlsZE5vZGVzKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkQ2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkTm9kZShyZXBsYWNlZENoaWxkTm9kZSwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKSB7XG4gIGNvbnN0IHJlcGxhY2VkQ2hpbGROb2RlcyA9IFtcbiAgICByZXBsYWNlZENoaWxkTm9kZVxuICBdO1xuXG4gIHRoaXMucmVwbGFjZUNoaWxkTm9kZXMocmVwbGFjZWRDaGlsZE5vZGVzLCByZXBsYWNlbWVudENoaWxkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGROb2RlcyhyZXBsYWNlZENoaWxkTm9kZXMsIHJlcGxhY2VtZW50Q2hpbGROb2Rlcykge1xuICBjb25zdCByZXBsYWNlZENoaWxkTm9kZXNMZW5ndGggPSByZXBsYWNlZENoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICBmaXJzdFJlcGxhY2VkQ2hpbGROb2RlID0gZmlyc3QocmVwbGFjZWRDaGlsZE5vZGVzKSxcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGZpcnN0UmVwbGFjZWRDaGlsZE5vZGUpLCAvLy9cbiAgICAgICAgZGVsZXRlQ291bnQgPSByZXBsYWNlZENoaWxkTm9kZXNMZW5ndGg7IC8vL1xuXG4gIHRoaXMuc3BsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBkZWxldGVDb3VudCwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGROb2RlKGFwcGVuZGVkQ2hpbGROb2RlKSB7XG4gIGNvbnN0IGFwcGVuZGVkQ2hpbGROb2RlcyA9IFtcbiAgICBhcHBlbmRlZENoaWxkTm9kZVxuICBdO1xuXG4gIHRoaXMuYXBwZW5kQ2hpbGROb2RlcyhhcHBlbmRlZENoaWxkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZE5vZGVzKGFwcGVuZGVkQ2hpbGROb2Rlcykge1xuICBjb25zdCBhZGRlZENoaWxkTm9kZXMgPSBhcHBlbmRlZENoaWxkTm9kZXMsIC8vL1xuICAgICAgICBtdWx0aXBsaWNpdHkgPSB0aGlzLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICBzdGFydEluZGV4ID0gbXVsdGlwbGljaXR5OyAgLy8vXG5cbiAgdGhpcy5hZGRDaGlsZE5vZGVzKGFkZGVkQ2hpbGROb2Rlcywgc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZE5vZGUocHJlcGVuZGVkQ2hpbGROb2RlKSB7XG4gIGNvbnN0IHByZXBlbmRlZENoaWxkTm9kZXMgPSBbXG4gICAgcHJlcGVuZGVkQ2hpbGROb2RlXG4gIF07XG5cbiAgdGhpcy5wcmVwZW5kQ2hpbGROb2RlcyhwcmVwZW5kZWRDaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZENoaWxkTm9kZXMocHJlcGVuZGVkQ2hpbGROb2Rlcykge1xuICBjb25zdCBhZGRlZENoaWxkTm9kZXMgPSBwcmVwZW5kZWRDaGlsZE5vZGVzLCAgLy8vXG4gICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuXG4gIHRoaXMuYWRkQ2hpbGROb2RlcyhhZGRlZENoaWxkTm9kZXMsIHN0YXJ0SW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzcGxpY2VDaGlsZE5vZGVzKHN0YXJ0SW5kZXgsIGRlbGV0ZUNvdW50LCBhZGRlZENoaWxkTm9kZXMgPSBbXSkge1xuICBjb25zdCByZW1vdmVkQ2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2Rlcy5zcGxpY2Uoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIC4uLmFkZGVkQ2hpbGROb2Rlcyk7XG5cbiAgdGhpcy5yZXNldENoaWxkTm9kZXNQYXJlbnROb2RlKHJlbW92ZWRDaGlsZE5vZGVzKTtcblxuICB0aGlzLnNldENoaWxkTm9kZXNQYXJlbnROb2RlKGFkZGVkQ2hpbGROb2Rlcyk7XG5cbiAgcmV0dXJuIHJlbW92ZWRDaGlsZE5vZGVzO1xufVxuXG5mdW5jdGlvbiBzbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZW5kSW5kZXggPSBJbmZpbml0eSkge1xuICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblxuICByZXR1cm4gY2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JOb2RlcygpIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IFtdO1xuXG4gIGxldCBhbmNlc3Rvck5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vL1xuXG4gIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICBhbmNlc3Rvck5vZGVzLnB1c2goYW5jZXN0b3JOb2RlKTtcblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGFuY2VzdG9yTm9kZXM7XG59XG5cbmZ1bmN0aW9uIG1hcEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgcmV0dXJuIGFuY2VzdG9yTm9kZXMubWFwKGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gc29tZUFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgbGV0IGluZGV4ID0gMCxcbiAgICAgIGFuY2VzdG9yTm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8vXG5cbiAgd2hpbGUgKGFuY2VzdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7IC8vL1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yTm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBhbmNlc3Rvck5vZGUgPSBwYXJlbnROb2RlOyAgLy8vXG5cbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgaW5kZXggPSAwLFxuICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3JOb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIGFuY2VzdG9yTm9kZSA9IHVuZGVmaW5lZDtcblxuICByZXR1cm4gYW5jZXN0b3JOb2RlO1xufVxuXG5mdW5jdGlvbiBldmVyeUFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBsZXQgaW5kZXggPSAwLFxuICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gISFjYWxsYmFjayhhbmNlc3Rvck5vZGUsIGluZGV4KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGFuY2VzdG9yTm9kZSA9IHBhcmVudE5vZGU7ICAvLy9cblxuICAgIGluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gIHJldHVybiBhbmNlc3Rvck5vZGVzLmZpbHRlcihjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUFuY2VzdG9yTm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGFuY2VzdG9yTm9kZXMgPSB0aGlzLmdldEFuY2VzdG9yTm9kZXMoKTtcblxuICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gIGFuY2VzdG9yTm9kZXMuZm9yRWFjaChjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldERlc2NlbmRhbnROb2RlcyhkZXNjZW5kYW50Tm9kZXMgPSBbXSkge1xuICBwdXNoKGRlc2NlbmRhbnROb2RlcywgdGhpcy5jaGlsZE5vZGVzKTtcblxuICB0aGlzLmZvckVhY2hDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNoaWxkTm9kZS5nZXREZXNjZW5kYW50Tm9kZXMoZGVzY2VuZGFudE5vZGVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcztcbn1cblxuZnVuY3Rpb24gbWFwRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgZGVzY2VuZGFudE5vZGVzID0gdGhpcy5nZXREZXNjZW5kYW50Tm9kZXMoKTtcblxuICByZXR1cm4gZGVzY2VuZGFudE5vZGVzLm1hcChjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHNvbWVEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNoaWxkTm9kZXNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgIGRlc2NlbmRhbnROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soZGVzY2VuZGFudE5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hpbGROb2RlLnNvbWVEZXNjZW5kYW50Tm9kZShjYWxsYmFjayk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgbGV0IGRlc2NlbmRhbnROb2RlID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjaGlsZE5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpbmRleF07XG5cbiAgICBkZXNjZW5kYW50Tm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICByZXN1bHQgPSBjYWxsYmFjayhkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXNjZW5kYW50Tm9kZSA9IGNoaWxkTm9kZS5maW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjZW5kYW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXZlcnlEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2hpbGROb2Rlc0xlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgcmVzdWx0ID0gISFjYWxsYmFjayhkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hpbGROb2RlLmV2ZXJ5RGVzY2VuZGFudE5vZGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckRlc2NlbmRhbnROb2RlKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGRlc2NlbmRhbnROb2RlcyA9IHRoaXMuZ2V0RGVzY2VuZGFudE5vZGVzKCk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEZXNjZW5kYW50Tm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGRlc2NlbmRhbnROb2RlcyA9IHRoaXMuZ2V0RGVzY2VuZGFudE5vZGVzKCk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBjb25zdCBkZXNjZW5kYW50Tm9kZXMgPSB0aGlzLmdldERlc2NlbmRhbnROb2RlcygpO1xuXG4gIGRlc2NlbmRhbnROb2Rlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbn1cblxuY29uc3Qgbm9kZU1peGlucyA9IHtcbiAgZ2V0TXVsdGlwbGljaXR5LFxuICBtYXBDaGlsZE5vZGUsXG4gIHNvbWVDaGlsZE5vZGUsXG4gIGZpbmRDaGlsZE5vZGUsXG4gIGV2ZXJ5Q2hpbGROb2RlLFxuICBmaWx0ZXJDaGlsZE5vZGUsXG4gIHJlZHVjZUNoaWxkTm9kZSxcbiAgZm9yRWFjaENoaWxkTm9kZSxcbiAgZm9yd2FyZHNTb21lQ2hpbGROb2RlLFxuICBiYWNrd2FyZHNTb21lQ2hpbGROb2RlLFxuICBpbmRleE9mQ2hpbGROb2RlLFxuICBzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSxcbiAgcmVzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSxcbiAgYWRkQ2hpbGROb2RlLFxuICBhZGRDaGlsZE5vZGVzLFxuICByZW1vdmVDaGlsZE5vZGUsXG4gIHJlbW92ZUNoaWxkTm9kZXMsXG4gIHJlcGxhY2VDaGlsZE5vZGUsXG4gIHJlcGxhY2VDaGlsZE5vZGVzLFxuICBhcHBlbmRDaGlsZE5vZGUsXG4gIGFwcGVuZENoaWxkTm9kZXMsXG4gIHByZXBlbmRDaGlsZE5vZGUsXG4gIHByZXBlbmRDaGlsZE5vZGVzLFxuICBzcGxpY2VDaGlsZE5vZGVzLFxuICBzbGljZUNoaWxkTm9kZXMsXG4gIGdldEFuY2VzdG9yTm9kZXMsXG4gIG1hcEFuY2VzdG9yTm9kZSxcbiAgc29tZUFuY2VzdG9yTm9kZSxcbiAgZmluZEFuY2VzdG9yTm9kZSxcbiAgZXZlcnlBbmNlc3Rvck5vZGUsXG4gIGZpbHRlckFuY2VzdG9yTm9kZSxcbiAgcmVkdWNlQW5jZXN0b3JOb2RlLFxuICBmb3JFYWNoQW5jZXN0b3JOb2RlLFxuICBnZXREZXNjZW5kYW50Tm9kZXMsXG4gIG1hcERlc2NlbmRhbnROb2RlLFxuICBzb21lRGVzY2VuZGFudE5vZGUsXG4gIGZpbmREZXNjZW5kYW50Tm9kZSxcbiAgZXZlcnlEZXNjZW5kYW50Tm9kZSxcbiAgZmlsdGVyRGVzY2VuZGFudE5vZGUsXG4gIHJlZHVjZURlc2NlbmRhbnROb2RlLFxuICBmb3JFYWNoRGVzY2VuZGFudE5vZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMsIGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBsYXN0IH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgTkVXX0xJTkVfQ0hBUkFDVEVSLCBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlVHJlZSB7XG4gIGNvbnN0cnVjdG9yKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKCksICAvLy9cbiAgICAgICAgICBwYXJzZVRyZWUgPSBuZXcgUGFyc2VUcmVlKGxpbmVzKTtcblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBnZXRXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGg7XG5cbiAgICBsZXQgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aDtcblxuICAgIGlmIChsaW5lc0xlbmd0aCA9PT0gMCkge1xuICAgICAgd2lkdGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0TGluZSA9IGxhc3QodGhpcy5saW5lcyksXG4gICAgICAgICAgICBsYXN0TGluZUxlbmd0aCA9IGxhc3RMaW5lLmxlbmd0aDtcblxuICAgICAgd2lkdGggPSBsYXN0TGluZUxlbmd0aDsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0RGVwdGgoKSB7XG4gICAgY29uc3QgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aCxcbiAgICAgICAgICBkZXB0aCA9IGxpbmVzTGVuZ3RoOyAgLy8vXG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBmb3JFYWNoTGluZShjYWxsYmFjaykge1xuICAgIHRoaXMubGluZXMuZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cblxuICBhcHBlbmRUb1RvcChwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUpID0+IHtcbiAgICAgIHRoaXMubGluZXMudW5zaGlmdChsaW5lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZFRvTGVmdChwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLmxpbmVzW2luZGV4XSA9IGxpbmUgKyB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZFRvUmlnaHQocGFyc2VUcmVlKSB7XG4gICAgcGFyc2VUcmVlLmZvckVhY2hMaW5lKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIGxpbmU7XG4gICAgfSk7XG4gIH1cblxuICBhcHBlbmRUb0JvdHRvbShwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUpID0+IHtcbiAgICAgIHRoaXMubGluZXMucHVzaChsaW5lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZFRvcE1hcmdpbih0b3BNYXJnaW5EZXB0aCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIHRvcE1hcmdpbldpZHRoID0gd2lkdGgsICAvLy9cbiAgICAgICAgICB0b3BNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgodG9wTWFyZ2luV2lkdGgpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRvcE1hcmdpbkRlcHRoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzLnVuc2hpZnQodG9wTWFyZ2luU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBhZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCkge1xuICAgIGNvbnN0IGxlZnRNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgobGVmdE1hcmdpbldpZHRoKSxcbiAgICAgICAgICBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpbmVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzW2luZGV4XSA9IGxlZnRNYXJnaW5TdHJpbmcgKyB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICB9XG4gIH1cblxuICBhZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKSB7XG4gICAgY29uc3QgcmlnaHRNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgocmlnaHRNYXJnaW5XaWR0aCksXG4gICAgICAgICAgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsaW5lc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIHJpZ2h0TWFyZ2luU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGFkZEJvdHRvbU1hcmdpbihib3R0b21NYXJnaW5EZXB0aCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIGJvdHRvbU1hcmdpbldpZHRoID0gd2lkdGgsICAvLy9cbiAgICAgICAgICBib3R0b21NYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgoYm90dG9tTWFyZ2luV2lkdGgpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGJvdHRvbU1hcmdpbkRlcHRoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzLnB1c2goYm90dG9tTWFyZ2luU3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgXG4gIHBvcExpbmUoKSB7IHJldHVybiB0aGlzLmxpbmVzLnBvcCgpOyB9XG4gIFxuICBzaGlmdExpbmUoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNoaWZ0KCk7IH1cbiAgXG4gIHB1c2hMaW5lKGxpbmUpIHsgdGhpcy5saW5lcy5wdXNoKGxpbmUpOyB9XG4gIFxuICB1bnNoaWZ0TGluZShsaW5lKSB7IHRoaXMubGluZXMudW5zaGlmdChsaW5lKTsgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMubGluZXMucmVkdWNlKChzdHJpbmcsIGxpbmUpID0+IHtcbiAgICAgIHN0cmluZyArPSBsaW5lICsgTkVXX0xJTkVfQ0hBUkFDVEVSO1xuXG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmdpblN0cmluZ0Zyb21NYXJnaW5XaWR0aChtYXJnaW5XaWR0aCwgc3BhY2VDaGFyYWN0ZXIpIHtcbiAgc3BhY2VDaGFyYWN0ZXIgPSBzcGFjZUNoYXJhY3RlciB8fCBTUEFDRV9DSEFSQUNURVI7XG5cbiAgbGV0IG1hcmdpblN0cmluZyA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWFyZ2luV2lkdGg7IGluZGV4KyspIHtcbiAgICBtYXJnaW5TdHJpbmcgKz0gc3BhY2VDaGFyYWN0ZXI7XG4gIH1cblxuICByZXR1cm4gbWFyZ2luU3RyaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUGFyc2VUcmVlIGZyb20gXCIuLi9wYXJzZVRyZWVcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IEJBUl9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGV4dGVuZHMgUGFyc2VUcmVlIHtcbiAgY29uc3RydWN0b3IobGluZXMsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICBzdXBlcihsaW5lcyk7XG4gICAgXG4gICAgdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgfVxuICBcbiAgZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICB9XG5cbiAgYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpIHtcbiAgICBzdXBlci5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG5cbiAgICB0aGlzLnZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gbGVmdE1hcmdpbldpZHRoOyAvLy9cbiAgfVxuXG4gIHN0YXRpYyBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBCQVJfQ0hBUkFDVEVSLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSAwLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oVmVydGljYWxCcmFuY2hQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbiksXG4gICAgICAgICAgbGVmdE1hcmdpbldpZHRoID0gTWF0aC5mbG9vcih3aWR0aC8yKSxcbiAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGggLSAxO1xuXG4gICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuXG4gICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICB9XG5cbiAgc3RhdGljIGZyb21EZXB0aEFuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oQ2xhc3MsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGluZXMgPSBsaW5lc0Zyb21EZXB0aChkZXB0aCksXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBuZXcgQ2xhc3MobGluZXMsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICB9XG5cbiAgc3RhdGljIGZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENsYXNzLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gc3RyaW5nOyAgLy8vXG5cbiAgICAgIHN0cmluZyA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJzZVRyZWU7ICAvLy9cbiAgICB9XG4gICAgXG4gICAgY29uc3QgbGluZSA9IHN0cmluZywgLy8vXG4gICAgICAgICAgbGluZXMgPSBbXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgXSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IG5ldyBDbGFzcyhsaW5lcywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gdmVydGljYWxCcmFuY2hQYXJzZVRyZWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluZXNGcm9tRGVwdGgoZGVwdGgpIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcblxuICBsZXQgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IGRlcHRoKSB7XG4gICAgbGluZXNbaW5kZXgrK10gPSBFTVBUWV9TVFJJTkc7XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2Vucyh0b2tlbkluZGV4LCB0b2tlbnMpIHtcbiAgbGV0IGxpbmVJbmRleCA9IG51bGw7XG5cbiAgaWYgKHRva2VuSW5kZXggIT09IG51bGwpIHtcbiAgICBsaW5lSW5kZXggPSAwO1xuXG4gICAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICAgIGVuZCA9IHRva2VuSW5kZXg7XG5cbiAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgY29uc3QgdG9rZW5FbmRPZkxpbmVUb2tlbiA9IHRva2VuLmlzRW5kT2ZMaW5lVG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgbGluZUluZGV4Kys7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGluZUluZGV4O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdG9rZW5zXCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZVBhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21Ob25UZXJtaW5hbE5vZGVBbmRUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIG9wYWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgZmlyc3RMaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyhmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgdG9rZW5zKSxcbiAgICAgICAgICBsYXN0TGluZUluZGV4ID0gbGluZUluZGV4RnJvbVRva2VuSW5kZXhBbmRUb2tlbnMobGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgdG9rZW5zKTtcblxuICAgIGxldCBsaW5lSW5kZXhlcztcblxuICAgIGlmIChmaXJzdExpbmVJbmRleCA9PT0gbGFzdExpbmVJbmRleCkge1xuICAgICAgY29uc3QgbGluZUluZGV4ID0gZmlyc3RMaW5lSW5kZXg7IC8vL1xuXG4gICAgICBpZiAobGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIGxpbmVJbmRleGVzID0gRU1QVFlfU1RSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZUluZGV4ZXMgPSBgIFske2xpbmVJbmRleH1dYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vL1xuICAgICAgfSBlbHNlIGlmIChmaXJzdExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7bGFzdExpbmVJbmRleH1dYDtcbiAgICAgIH0gZWxzZSBpZiAobGFzdExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7Zmlyc3RMaW5lSW5kZXh9XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7Zmlyc3RMaW5lSW5kZXh9LSR7bGFzdExpbmVJbmRleH1dYFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdHJpbmcgPSBgJHtydWxlTmFtZX1gO1xuXG4gICAgaWYgKG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgIHN0cmluZyA9IGAke3N0cmluZ30ke29wYWNpdHl9YDtcbiAgICB9XG5cbiAgICBzdHJpbmcgPSBgJHtzdHJpbmd9JHtsaW5lSW5kZXhlc31gO1xuXG4gICAgbGV0IHByZWNlZGVuY2UgPSBub25UZXJtaW5hbE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgaWYgKHByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmVjZWRlbmNlID09PSBJbmZpbml0eSkge1xuICAgICAgICBwcmVjZWRlbmNlID0gU1BBQ0VfQ0hBUkFDVEVSO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBgJHtzdHJpbmd9ICgke3ByZWNlZGVuY2V9KWA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oUnVsZU5hbWVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICBydWxlTmFtZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJzZVRyZWU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFBhcnNlVHJlZSBmcm9tIFwiLi4vcGFyc2VUcmVlXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBEQVNIX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSBleHRlbmRzIFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdGcm9tQ2hhcmFjdGVyc1dpZHRoKHdpZHRoLCBEQVNIX0NIQVJBQ1RFUiksXG4gICAgICAgICAgbGluZSA9IHN0cmluZywgLy8vXG4gICAgICAgICAgbGluZXMgPSBbXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgXSxcbiAgICAgICAgICBob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlID0gbmV3IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUobGluZXMpO1xuXG4gICAgcmV0dXJuIGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nRnJvbUNoYXJhY3RlcnNXaWR0aChjaGFyYWN0ZXJzV2lkdGgsIGNoYXJhY3Rlcikge1xuICBsZXQgc3RyaW5nID0gRU1QVFlfU1RSSU5HO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjaGFyYWN0ZXJzV2lkdGg7IGluZGV4KyspIHtcbiAgICBzdHJpbmcgKz0gY2hhcmFjdGVyO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuaW1wb3J0IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUgZnJvbSBcIi4vaG9yaXpvbnRhbEJyYW5jaFwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hpbGROb2Rlc1BhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21DaGlsZE5vZGVzQW5kVG9rZW5zKGNoaWxkTm9kZXMsIHRva2Vucykge1xuICAgIGxldCBjaGlsZE5vZGVzUGFyc2VUcmVlID0gbnVsbDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlcyA9IGNoaWxkTm9kZXMucmVkdWNlKChjaGlsZE5vZGVQYXJzZVRyZWVzLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlID0gY2hpbGROb2RlLmFzUGFyc2VUcmVlKHRva2Vucyk7XG5cbiAgICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlcy5wdXNoKGNoaWxkTm9kZVBhcnNlVHJlZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVBhcnNlVHJlZXM7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID0gY2hpbGROb2RlUGFyc2VUcmVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlID0gZmlyc3QoY2hpbGROb2RlUGFyc2VUcmVlcyk7XG5cbiAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlOyAgLy8vXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uLFxuICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSAwLFxuICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoID0gMCxcbiAgICAgICAgICAgIGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCA9IDA7XG5cbiAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlcy5mb3JFYWNoKChjaGlsZE5vZGVQYXJzZVRyZWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlV2lkdGggPSBjaGlsZE5vZGVQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZVBhcnNlVHJlZSxcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gZmlyc3RDaGlsZE5vZGVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gY2hpbGROb2RlUGFyc2VUcmVlc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUgPSBjaGlsZE5vZGVQYXJzZVRyZWUsXG4gICAgICAgICAgICAgICAgICBsYXN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArPSBsYXN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG4gICAgICAgICAgICBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArPSAxO1xuXG4gICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG5cbiAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGggPSBNYXRoLm1heChjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGgsIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiAtIGZpcnN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArIDEsXG4gICAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSA9IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgICAgbGVmdE1hcmdpbldpZHRoID0gZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uLFxuICAgICAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoIC0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGg7XG5cbiAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5hZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKTtcbiAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZS5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG4gICAgICAgIGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG5cbiAgICAgICAgY29uc3QgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICAgICAgZGVwdGggPSBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGg7IC8vL1xuXG4gICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tRGVwdGhBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENoaWxkTm9kZXNQYXJzZVRyZWUsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzLmZvckVhY2goKGNoaWxkTm9kZVBhcnNlVHJlZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpLFxuICAgICAgICAgICAgICAgIGNsb25lZENoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZVBhcnNlVHJlZS5jbG9uZSgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgY2hpbGROb2RlUGFyc2VUcmVlc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TWFyZ2luV2lkdGggPSAxO1xuXG4gICAgICAgICAgICBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoIDwgY2hpbGROb2RlUGFyc2VUcmVlc0RlcHRoKSB7XG4gICAgICAgICAgICBjb25zdCBib3R0b21NYXJnaW5EZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCAtIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoO1xuXG4gICAgICAgICAgICBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUuYWRkQm90dG9tTWFyZ2luKGJvdHRvbU1hcmdpbkRlcHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQoY2xvbmVkQ2hpbGROb2RlUGFyc2VUcmVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZS5hcHBlbmRUb1RvcChob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlKTtcblxuICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGROb2Rlc1BhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZU5hbWVQYXJzZVRyZWUgZnJvbSBcIi4vcnVsZU5hbWVcIjtcbmltcG9ydCBDaGlsZE5vZGVzUGFyc2VUcmVlIGZyb20gXCIuL2NoaWxkTm9kZXNcIjtcbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gICAgbGV0IG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZTtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlID0gUnVsZU5hbWVQYXJzZVRyZWUuZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2VucyksXG4gICAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IENoaWxkTm9kZXNQYXJzZVRyZWUuZnJvbUNoaWxkTm9kZXNBbmRUb2tlbnMoY2hpbGROb2RlcywgdG9rZW5zKTtcblxuICAgIGlmIChjaGlsZE5vZGVzUGFyc2VUcmVlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnNlVHJlZURlcHRoID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0RGVwdGgoKSxcbiAgICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHJ1bGVOYW1lUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24sIC8vL1xuICAgICAgICAgICAgZGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZURlcHRoOyAvLy9cblxuICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbURlcHRoQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQocnVsZU5hbWVQYXJzZVRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuXG4gICAgICBjb25zdCBjaGlsZE5vZGVzUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlID0gcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uIC0gY2hpbGROb2Rlc1BhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb247XG5cbiAgICAgIGxldCBsZWZ0TWFyZ2luV2lkdGg7XG5cbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAvLy9cbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSAtdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuXG4gICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlLmFkZExlZnRNYXJnaW4obGVmdE1hcmdpbldpZHRoKTtcbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlID4gMCkge1xuICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSArdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuXG4gICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBydWxlTmFtZVBhcnNlVHJlZVdpZHRoID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWVXaWR0aCA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHdpZHRoc0RpZmZlcmVuY2UgPSBydWxlTmFtZVBhcnNlVHJlZVdpZHRoIC0gY2hpbGROb2Rlc1BhcnNlVHJlZVdpZHRoO1xuXG4gICAgICBsZXQgcmlnaHRNYXJnaW5XaWR0aDtcblxuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vL1xuICAgICAgfSBlbHNlIGlmICh3aWR0aHNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICByaWdodE1hcmdpbldpZHRoID0gLXdpZHRoc0RpZmZlcmVuY2U7XG5cbiAgICAgICAgcnVsZU5hbWVQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoc0RpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgIHJpZ2h0TWFyZ2luV2lkdGggPSArd2lkdGhzRGlmZmVyZW5jZTtcblxuICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZS5nZXREZXB0aCgpLFxuICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHJ1bGVOYW1lUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiwgLy8vXG4gICAgICAgICAgICBkZXB0aCA9IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGg7IC8vL1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tRGVwdGhBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgZGVwdGgsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9SaWdodChydWxlTmFtZVBhcnNlVHJlZSk7XG5cbiAgICAgIG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb0JvdHRvbShjaGlsZE5vZGVzUGFyc2VUcmVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBub2RlTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvbm9kZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vcGFyc2VUcmVlL25vblRlcm1pbmFsTm9kZVwiO1xuXG5jb25zdCB7IGZpcnN0LCBtYXRjaCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IG9wYXF1ZTogb3BhcXVlU3BlY2lhbFN5bWJvbCAsIHNlbWlPcGFxdWU6IHNlbWlPcGFxdWVTcGVjaWFsU3ltYm9sIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uVGVybWluYWxOb2RlIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWUsIHBhcmVudE5vZGUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFJ1bGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICB9XG5cbiAgZ2V0UGFyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICB9XG5cbiAgZ2V0Q2hpbGROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZ2V0UHJlY2VkZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVjZWRlbmNlO1xuICB9XG5cbiAgc2V0UnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cblxuICBzZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuICB9XG5cbiAgc2V0Q2hpbGROb2RlcyhjaGlsZE5vZGVzKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IDAsXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSBJbmZpbml0eSxcbiAgICAgICAgICBhZGRlZENoaWxkTm9kZXMgPSBjaGlsZE5vZGVzOyAgLy8vXG5cbiAgICB0aGlzLnNwbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIGFkZGVkQ2hpbGROb2Rlcyk7XG4gIH1cblxuICBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICB9XG5cbiAgc2V0UHJlY2VkZW5jZShwcmVjZWRlbmNlKSB7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGlzT3BhcXVlKCkge1xuICAgIGNvbnN0IG9wYXF1ZSA9ICh0aGlzLm9wYWNpdHkgPT09IG9wYXF1ZVNwZWNpYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIG9wYXF1ZTtcbiAgfVxuXG4gIGlzU2VtaU9wYXF1ZSgpIHtcbiAgICBjb25zdCBzZW1pT3BhcXVlID0gKHRoaXMub3BhY2l0eSA9PT0gc2VtaU9wYXF1ZVNwZWNpYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIHNlbWlPcGFxdWU7XG4gIH1cblxuICBpc1RyYW5zcGFyZW50KCkge1xuICAgIGNvbnN0IHNlbWlPcGFxdWUgPSAodGhpcy5vcGFjaXR5ID09PSBudWxsKTtcblxuICAgIHJldHVybiBzZW1pT3BhcXVlO1xuICB9XG5cbiAgaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdHJ1ZTtcblxuICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBnZXREZXNjZW5kYW50Tm9kZXMoZGVzY2VuZGFudE5vZGVzKSB7XG4gICAgcmV0dXJuIGRlc2NlbmRhbnROb2RlcztcbiAgfVxuXG4gIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2Vucykge1xuICAgIGxldCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleDtcblxuICAgIHRoaXMuZm9yd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKTtcblxuICAgICAgaWYgKGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleDtcblxuICAgIHRoaXMuYmFja3dhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gICAgICBpZiAobGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0U2lnbmlmaWNhbnRUb2tlbnMoc2lnbmlmaWNhbnRUb2tlbnMgPSBbXSkge1xuICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNoaWxkTm9kZS5nZXRTaWduaWZpY2FudFRva2VucyhzaWduaWZpY2FudFRva2Vucyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbnM7XG4gIH1cblxuICBnZXRNdWx0aXBsaWNpdHkoKSB7XG4gICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgbXVsdGlwbGljaXR5ID0gY2hpbGROb2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgcmV0dXJuIG11bHRpcGxpY2l0eTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgY29uc3QgbXVsdGlwbGljaXR5ID0gdGhpcy5nZXRNdWx0aXBsaWNpdHkoKSxcbiAgICAgICAgICBlbXB0eSA9IChtdWx0aXBsaWNpdHkgPT09IDApO1xuXG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgaXNTaW5ndWxhcigpIHtcbiAgICBjb25zdCBtdWx0aXBsaWNpdHkgPSB0aGlzLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICAgIHNpbmd1bGFyID0gKG11bHRpcGxpY2l0eSA9PT0gMSk7XG5cbiAgICByZXR1cm4gc2luZ3VsYXI7XG4gIH1cblxuICBpc0xvd2VyUHJlY2VkZW5jZShydWxlTmFtZSwgcHJlY2VkZW5jZSkge1xuICAgIGxldCBsb3dlclByZWNlZGVuY2U7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjZWRlbmNlID09PSBudWxsKSB7XG4gICAgICBsb3dlclByZWNlZGVuY2UgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGROb2RlID0gZmlyc3QodGhpcy5jaGlsZE5vZGVzKTtcblxuICAgICAgbG93ZXJQcmVjZWRlbmNlID0gZmlyc3RDaGlsZE5vZGUuaXNMb3dlclByZWNlZGVuY2UocnVsZU5hbWUsIHByZWNlZGVuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3dlclByZWNlZGVuY2UgPSAoKHRoaXMucnVsZU5hbWUgPT09IHJ1bGVOYW1lKSAmJiAodGhpcy5wcmVjZWRlbmNlIDwgcHJlY2VkZW5jZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsb3dlclByZWNlZGVuY2U7XG4gIH1cblxuICBpc1VucHJlY2VkZW50ZWQoKSB7XG4gICAgbGV0IHVucHJlY2VkZW50ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIHVucHJlY2VkZW50ZWQgPSB0aGlzLmNoaWxkTm9kZXMuc29tZSgoY2hpbGROb2RlKSA9PiB7ICAvLy9cbiAgICAgICAgY29uc3QgY2hpbGROb2RlTG93ZXJQcmVjZWRlbmNlID0gY2hpbGROb2RlLmlzTG93ZXJQcmVjZWRlbmNlKHRoaXMucnVsZU5hbWUsIHRoaXMucHJlY2VkZW5jZSk7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5wcmVjZWRlbnRlZDtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHRoaXMsICAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUuZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2VucyksXG4gICAgICAgICAgcGFyc2VUcmVlID0gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlOyAgLy8vXG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgbWF0Y2gobm9kZSwgZGVwdGggPSBJbmZpbml0eSwgZXhhY3RseSA9IGZhbHNlKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgICBpZiAodGhpcy5ydWxlTmFtZSA9PT0gbm9uVGVybWluYWxOb2RlUnVsZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlT3BhY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRPcGFjaXR5KCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3BhY2l0eSA9PT0gbm9uVGVybWluYWxOb2RlT3BhY2l0eSkge1xuICAgICAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSB0aGlzLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICAgICAgICBub25UZXJtaW5hbE5vZGVQcmVjZWRlbmNlID0gbm9uVGVybWluYWxOb2RlLmdldFByZWNlZGVuY2UoKTtcblxuICAgICAgICAgIGlmIChwcmVjZWRlbmNlID09PSBub25UZXJtaW5hbE5vZGVQcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBkZXB0aC0tO1xuXG4gICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKTtcblxuICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2godGhpcy5jaGlsZE5vZGVzLCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzLCAoY2hpbGROb2RlLCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVNYXRjaGVzTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlID0gY2hpbGROb2RlLm1hdGNoKG5vblRlcm1pbmFsTm9kZUNoaWxkTm9kZSwgZGVwdGgsIGV4YWN0bHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZU1hdGNoZXNOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICByZXdyaXRlKHN0YXRlKSB7XG4gICAgY29uc3QgcmV3cml0dGVuTm9uVGVybWluYWxOb2RlID0gbnVsbDtcblxuICAgIHJldHVybiByZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZm9yRWFjaENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjaGlsZE5vZGUuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5ydWxlTmFtZSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gY2xvbmVDaGlsZE5vZGVzKHRoaXMuY2hpbGROb2RlcyksXG4gICAgICAgICAgb3BhY2l0eSA9IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gdGhpcy5wcmVjZWRlbmNlLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhydWxlTmFtZSwgcGFyZW50Tm9kZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBpZiAocHJlY2VkZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmVjZWRlbmNlID0gb3BhY2l0eTsgLy8vXG5cbiAgICAgIG9wYWNpdHkgPSBjaGlsZE5vZGVzOyAvLy9cblxuICAgICAgY2hpbGROb2RlcyA9IHJ1bGVOYW1lOyAgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IE5vblRlcm1pbmFsTm9kZTsgIC8vL1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhydWxlTmFtZSwgcGFyZW50Tm9kZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKE5vblRlcm1pbmFsTm9kZS5wcm90b3R5cGUsIG5vZGVNaXhpbnMpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkTm9kZXMoY2hpbGROb2Rlcykge1xuICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5tYXAoKGNoaWxkTm9kZSkgPT4geyAgLy8vXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNsb25lKCk7ICAvLy9cblxuICAgIHJldHVybiBjaGlsZE5vZGU7XG4gIH0pO1xuXG4gIHJldHVybiBjaGlsZE5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQWhlYWQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY2FsbEFoZWFkID0gY2FsbEFoZWFkO1xuICB9XG4gIFxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBpc0NhbGxBaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsQWhlYWQ7XG4gIH1cblxuICBpc05vblRlcm1pbmFsUGFydCgpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbFBhcnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IGZhbHNlO1xuICAgIFxuICAgIHJldHVybiB0ZXJtaW5hbFBhcnQ7XG4gIH1cblxuICBpc1J1bGVOYW1lUGFydCgpIHtcbiAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBmYWxzZTtcblxuICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFJ1bGVOYW1lUGFydFR5cGUgPSBcInJ1bGVOYW1lUGFydFwiO1xuZXhwb3J0IGNvbnN0IE9wdGlvbmFsUGFydFBhcnRUeXBlID0gXCJvcHRpb25hbFBhcnRcIjtcbmV4cG9ydCBjb25zdCBDaG9pY2VPZlBhcnRzUGFydFR5cGUgPSBcImNob2ljZU9mUGFydHNcIjtcbmV4cG9ydCBjb25zdCBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlID0gXCJvbmVPck1vcmVQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlID0gXCJ6ZXJvT3JNb3JlUGFydHNcIjtcbmV4cG9ydCBjb25zdCBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSA9IFwic2VxdWVuY2VPZlBhcnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBPcHRpb25hbFBhcnRQYXJ0VHlwZSB9IGZyb20gXCIuLi8uLi9wYXJ0VHlwZXNcIjtcblxuXG5jb25zdCB7IHF1ZXN0aW9uTWFyayB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbmFsUGFydFBhcnQgZXh0ZW5kcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQWhlYWQsIHBhcnQpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuXG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgfVxuXG4gIGdldFBhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydDtcbiAgfVxuXG4gIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgcGFyc2VkID0gcGFyc2VPcHRpb25hbFBhcnQodGhpcy5wYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm9kZXNMZW5ndGg7ICAvLy9cblxuICAgICAgbm9kZXMuc3BsaWNlKHN0YXJ0KTtcblxuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgICAgc3RyaW5nID0gYCR7cGFydFN0cmluZ30ke3F1ZXN0aW9uTWFya31gO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydChwYXJ0KSB7XG4gICAgY29uc3QgdHlwZSA9IE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbmFsUGFydFBhcnQgPSBuZXcgT3B0aW9uYWxQYXJ0UGFydCh0eXBlLCBjYWxsQWhlYWQsIHBhcnQpO1xuXG4gICAgcmV0dXJuIG9wdGlvbmFsUGFydFBhcnQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlT3B0aW9uYWxQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIGlmIChjYWxsQWhlYWQgPT09IG51bGwpIHtcbiAgICBwYXJzZWQgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cblxuXG5cblxuICAgIHBhcnNlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG5cblxuXG5cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIH0gZnJvbSBcIi4uLy4uL3BhcnRUeXBlc1wiO1xuXG5cbmNvbnN0IHsgYXN0ZXJpc2sgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaZXJvT3JNb3JlUGFydHNQYXJ0IGV4dGVuZHMgTm9uVGVybWluYWxQYXJ0IHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KSB7XG4gICAgc3VwZXIodHlwZSwgY2FsbEFoZWFkKTtcblxuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gIH1cblxuICBnZXRQYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHBhcnNlZCA9IHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydCh0aGlzLnBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuXG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRTdHJpbmcgPSB0aGlzLnBhcnQuYXNTdHJpbmcoKSxcbiAgICAgICAgICBzdHJpbmcgPSBgJHtwYXJ0U3RyaW5nfSR7YXN0ZXJpc2t9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnQocGFydCkge1xuICAgIGNvbnN0IHR5cGUgPSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gbmV3IFplcm9Pck1vcmVQYXJ0c1BhcnQodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KTtcblxuICAgIHJldHVybiB6ZXJvT3JNb3JlUGFydHNQYXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVplcm9Pck1vcmVQYXJ0c1BhcnQocGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgaWYgKGNhbGxBaGVhZCA9PT0gbnVsbCkge1xuICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgcGFyc2VkID0gcGFyc2VaZXJvT3JNb3JlUGFydHNQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IE9uZU9yTW9yZVBhcnRzUGFydFR5cGUgfSBmcm9tIFwiLi4vLi4vcGFydFR5cGVzXCI7XG5pbXBvcnQgeyBwYXJzZVplcm9Pck1vcmVQYXJ0c1BhcnQgfSBmcm9tIFwiLi96ZXJvT3JNb3JlUGFydHNcIjtcblxuY29uc3QgeyBwbHVzIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT25lT3JNb3JlUGFydHNQYXJ0IGV4dGVuZHMgTm9uVGVybWluYWxQYXJ0IHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KSB7XG4gICAgc3VwZXIodHlwZSwgY2FsbEFoZWFkKTtcblxuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gIH1cblxuICBnZXRQYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHBhcnNlZCA9IHBhcnNlT25lT3JNb3JlUGFydHNQYXJ0KHRoaXMucGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICAgIG5vZGVzLnNwbGljZShzdGFydCk7XG5cbiAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3QgcGFydFN0cmluZyA9IHRoaXMucGFydC5hc1N0cmluZygpLFxuICAgICAgICAgIHN0cmluZyA9IGAke3BhcnRTdHJpbmd9JHtwbHVzfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXJ0KHBhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICBvbmVPck1vcmVQYXJ0c1BhcnQgPSBuZXcgT25lT3JNb3JlUGFydHNQYXJ0KHR5cGUsIGNhbGxBaGVhZCwgcGFydCk7XG5cbiAgICByZXR1cm4gb25lT3JNb3JlUGFydHNQYXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9uZU9yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBpZiAoY2FsbEFoZWFkID09PSBudWxsKSB7XG4gICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcGFyc2VaZXJvT3JNb3JlUGFydHNQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG4gICAgfVxuXG5cbiAgfSBlbHNlIHtcblxuXG5cbiAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgKCkgPT4ge1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE5BTUVfUlVMRV9OQU1FID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgUEFSVF9SVUxFX05BTUUgPSBcInBhcnRcIjtcbmV4cG9ydCBjb25zdCBSVUxFX1JVTEVfTkFNRSA9IFwicnVsZVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SX1JVTEVfTkFNRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBFUFNJTE9OX1JVTEVfTkFNRSA9IFwiZXBzaWxvblwiO1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1JVTEVfTkFNRSA9IFwiZG9jdW1lbnRcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9SVUxFX05BTUUgPSBcIndpbGRjYXJkXCI7XG5leHBvcnQgY29uc3QgUlVMRV9OQU1FX1JVTEVfTkFNRSA9IFwicnVsZU5hbWVcIjtcbmV4cG9ydCBjb25zdCBERUZJTklUSU9OX1JVTEVfTkFNRSA9IFwiZGVmaW5pdGlvblwiO1xuZXhwb3J0IGNvbnN0IFBSRUNFREVOQ0VfUlVMRV9OQU1FID0gXCJwcmVjZWRlbmNlXCI7XG5leHBvcnQgY29uc3QgUVVBTlRJRklFUl9SVUxFX05BTUUgPSBcInF1YW50aWZpZXJcIjtcbmV4cG9ydCBjb25zdCBFTkRfT0ZfTElORV9SVUxFX05BTUUgPSBcImVuZE9mTGluZVwiO1xuZXhwb3J0IGNvbnN0IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSA9IFwicGFydENob2ljZVwiO1xuZXhwb3J0IGNvbnN0IERFRklOSVRJT05TX1JVTEVfTkFNRSA9IFwiZGVmaW5pdGlvbnNcIjtcbmV4cG9ydCBjb25zdCBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSA9IFwidGVybWluYWxQYXJ0XCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FID0gXCJzdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgY29uc3QgQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRSA9IFwiY2hvaWNlT2ZQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FID0gXCJvcGFjaXR5TW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUgPSBcIm5vblRlcm1pbmFsUGFydFwiO1xuZXhwb3J0IGNvbnN0IFNFUVVFTkNFX09GX1BBUlRTX1JVTEVfTkFNRSA9IFwic2VxdWVuY2VPZlBhcnRzXCI7XG5leHBvcnQgY29uc3QgTk9fV0hJVEVTUEFDRV9QQVJUX1JVTEVfTkFNRSA9IFwibm9XaGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3QgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSA9IFwicmVndWxhckV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSA9IFwiY2FsbEFoZWFkTW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwib3B0aW9uYWxRdWFudGlmaWVyXCI7XG5leHBvcnQgY29uc3QgU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRSA9IFwic3RhcnRPZkNvbnRlbnRcIjtcbmV4cG9ydCBjb25zdCBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRSA9IFwic2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcbmV4cG9ydCBjb25zdCBPTkVfT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwib25lT3JNb3JlUXVhbnRpZmllclwiO1xuZXhwb3J0IGNvbnN0IFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwiemVyb09yTW9yZVF1YW50aWZpZXJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IFJVTEVfTkFNRV9SVUxFX05BTUUsIFFVQU5USUZJRVJfUlVMRV9OQU1FLCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDaG9pY2VOb2RlKG5vZGUpIHtcbiAgbGV0IG5vZGVOb0Nob2ljZU5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgbm9kZU5vQ2hvaWNlTm9kZSA9ICh0ZXJtaW5hbE5vZGVDb250ZW50ID09PSBcInxcIik7XG4gIH1cblxuICByZXR1cm4gbm9kZU5vQ2hvaWNlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVJ1bGVOYW1lTm9kZShub2RlKSB7XG4gIGxldCBub2RlUnVsZU5hbWVOb2RlID0gZmFsc2U7XG5cbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgbm9kZU5vblRlcm1pbmFsTm9kZSA9ICFub2RlVGVybWluYWxOb2RlO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgIG5vZGVSdWxlTmFtZU5vZGUgPSAobm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPT09IFJVTEVfTkFNRV9SVUxFX05BTUUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVSdWxlTmFtZU5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVRdWFudGlmaWVyTm9kZShub2RlKSB7XG4gIGxldCBub2RlUXVhbnRpZmllck5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZVF1YW50aWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gUVVBTlRJRklFUl9SVUxFX05BTUUpO1xuXG4gICAgbm9kZVF1YW50aWZpZXJOb2RlID0gcnVsZU5hbWVRdWFudGlmaWVyUnVsZU5hbWU7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlUXVhbnRpZmllck5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDYWxsQWhlYWRNb2RpZmllck5vZGUobm9kZSkge1xuICBsZXQgbm9kZUNhbGxBaGVhZE1vZGlmaWVyTm9kZSA9IGZhbHNlO1xuXG4gIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lQ2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUUpO1xuXG4gICAgbm9kZUNhbGxBaGVhZE1vZGlmaWVyTm9kZSA9IHJ1bGVOYW1lQ2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG5vZGVDYWxsQWhlYWRNb2RpZmllck5vZGU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbVF1YW50aWZpZXJOb2RlKHF1YW50aWZpZXJOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcXVhbnRpZmllck5vZGU7IC8vL1xuXG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpO1xuXG4gIG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgY29uc3QgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBPbmVPck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIjtcbmltcG9ydCBaZXJvT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiO1xuXG5pbXBvcnQgeyBpc05vZGVRdWFudGlmaWVyTm9kZSwgcnVsZU5hbWVGcm9tUXVhbnRpZmllck5vZGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2JuZlwiO1xuaW1wb3J0IHsgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgbGFzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBub2RlcyA9IGNoaWxkTm9kZXMuc2xpY2UoKSxcbiAgICAgICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5mdW5jdGlvbiBwYXJ0RnJvbU5vZGVzKG5vZGVzKSB7XG4gIGxldCBwYXJ0O1xuXG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGlmIChub2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZTtcblxuICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3ROb2RlUXVhbnRpZmllck5vZGUgPSBpc0xhc3ROb2RlUXVhbnRpZmllck5vZGUobm9kZXMpO1xuXG4gICAgaWYgKGxhc3ROb2RlUXVhbnRpZmllck5vZGUpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKSxcbiAgICAgICAgICAgIHF1YW50aWZpZXJOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG5cbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZU5hbWVGcm9tUXVhbnRpZmllck5vZGUocXVhbnRpZmllck5vZGUpLFxuICAgICAgICAgICAgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gY29sbGVjdGlvbk9mUGFydHNQYXJ0RnJvbVBhcnRBbmRSdWxlTmFtZShwYXJ0LCBydWxlTmFtZSk7XG5cbiAgICAgIHBhcnQgPSBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7IC8vL1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5zaGlmdCgpO1xuXG4gICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnQ7XG59XG5cbmZ1bmN0aW9uIGlzTGFzdE5vZGVRdWFudGlmaWVyTm9kZShub2Rlcykge1xuICBjb25zdCBsYXN0Tm9kZSA9IGxhc3Qobm9kZXMpLFxuICAgICAgICBsYXN0Tm9kZVF1YW50aWZpZXJOb2RlID0gaXNOb2RlUXVhbnRpZmllck5vZGUobGFzdE5vZGUpO1xuXG4gIHJldHVybiBsYXN0Tm9kZVF1YW50aWZpZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnRGcm9tUGFydEFuZFJ1bGVOYW1lKHBhcnQsIHJ1bGVOYW1lKSB7XG4gIGxldCBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7XG5cbiAgc3dpdGNoIChydWxlTmFtZSkge1xuICAgIGNhc2UgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUgOlxuICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQocGFydCk7XG5cbiAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IG9wdGlvbmFsUGFydFBhcnQ7IC8vL1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FIDpcbiAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IE9uZU9yTW9yZVBhcnRzUGFydC5mcm9tUGFydChwYXJ0KTtcblxuICAgICAgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0OyAvLy9cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgOlxuICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocGFydCk7XG5cbiAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQ7ICAvLy9cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb25PZlBhcnRzUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hbWVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgZmlyc3RDaGlsZE5vZGUgPSBmaXJzdChjaGlsZE5vZGVzKSxcbiAgICAgICAgICB0ZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIG5hbWUgPSB0ZXJtaW5hbE5vZGVDb250ZW50OyAvLy9cbiAgICBcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGNoaWxkTm9kZXMuc29tZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lID0gKG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBydWxlTmFtZSk7XG5cbiAgICAgIGlmIChub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpIHtcbiAgY29uc3Qgbm9kZXMgPSBjaGlsZE5vZGVzLmZpbHRlcigoY2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lID0gKG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBydWxlTmFtZSk7XG5cbiAgICAgIGlmIChub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBPUEFDSVRZX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZExhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlUnVsZShSdWxlKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpLFxuICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IHRoaXMuZ2VuZXJhdGVEZWZpbml0aW9ucygpLFxuICAgICAgICAgIHJ1bGUgPSBSdWxlLmZyb21OYW1lT3BhY2l0eUFuZERlZmluaXRpb25zKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBydWxlO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBsZXQgb3BhY2l0eSA9IG51bGw7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgaWYgKG9wYWNpdHlNb2RpZmllckJORk5vZGUgIT09IG51bGwpIHtcbiAgICAgIG9wYWNpdHkgPSBvcGFjaXR5TW9kaWZpZXJCTkZOb2RlLmdldE9wYWNpdHkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgbmFtZUJORk5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIG5hbWUgPSBuYW1lQk5GTm9kZS5nZXROYW1lKCk7XG4gICAgXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgXG4gIGdlbmVyYXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHNlY29uZExhc3RDaGlsZE5vZGUgPSBzZWNvbmRMYXN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIGRlZmluaXRpb25zQk5GTm9kZSA9IHNlY29uZExhc3RDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnNCTkZOb2RlLmdlbmVyYXRlRGVmaW5pdGlvbnMoKTtcbiAgICBcbiAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJ1bGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEVycm9yQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsUGFydCB7XG4gIGlzQ2FsbEFoZWFkKCkge1xuICAgIGNvbnN0IGNhbGxBaGVhZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGNhbGxBaGVhZDtcbiAgfVxuXG4gIGlzTm9uVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIHRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzTm9XaGl0ZXNwYWNlUGFydCgpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VQYXJ0ID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgfVxuXG4gIGlzU3RhcnRPZkNvbnRlbnRQYXJ0KCkge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50UGFydDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUgZnJvbSBcIi4vdmVydGljYWxCcmFuY2hcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgbGluZUluZGV4RnJvbVRva2VuSW5kZXhBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rva2Vuc1wiO1xuXG5jb25zdCB7IE5FV19MSU5FX0NIQVJBQ1RFUiwgQ0FSUklBR0VfUkVUVVJOX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxOb2RlUGFyc2VUcmVlIGV4dGVuZHMgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUge1xuICBzdGF0aWMgZnJvbVRlcm1pbmFsTm9kZUFuZFRva2Vucyh0ZXJtaW5hbE5vZGUsIHRva2Vucykge1xuICAgIGxldCBjb250ZW50O1xuXG4gICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9bXFxyXFxuXS9nLCAobWF0Y2gpID0+IHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG5cbiAgICAgICAgY2FzZSBORVdfTElORV9DSEFSQUNURVI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGUgPSB0ZXJtaW5hbE5vZGUuZ2V0VHlwZSgpLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRlcm1pbmFsTm9kZS5nZXRTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyhzaWduaWZpY2FudFRva2VuSW5kZXgsIHRva2Vucyk7XG5cbiAgICBsZXQgbGluZUluZGV4ZXM7XG5cbiAgICBpZiAobGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICBsaW5lSW5kZXhlcyA9IEVNUFRZX1NUUklORztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZUluZGV4ZXMgPSBgIFske2xpbmVJbmRleH1dYDtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpbmcgPSBgXCIke2NvbnRlbnR9XCJbJHt0eXBlfV0ke2xpbmVJbmRleGVzfWAsXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKFRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXJtaW5hbE5vZGVQYXJzZVRyZWUgZnJvbSBcIi4uL3BhcnNlVHJlZS90ZXJtaW5hbE5vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxOb2RlIHtcbiAgY29uc3RydWN0b3IocGFyZW50Tm9kZSwgc2lnbmlmaWNhbnRUb2tlbikge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgdGhpcy5zaWduaWZpY2FudFRva2VuID0gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIGdldFBhcmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGdldFNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHNldFBhcmVudE5vZGUocGFyZW50Tm9kZSkge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cblxuICBzZXRTaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pIHtcbiAgICB0aGlzLnNpZ25pZmljYW50VG9rZW4gPSBzaWduaWZpY2FudFRva2VuO1xuICB9XG5cbiAgaXNTdGFydE9mQ29udGVudE5vZGUoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnROb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnROb2RlO1xuICB9XG5cbiAgaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGUgPSBmYWxzZTtcblxuICAgIHJldHVybiBub1doaXRlc3BhY2VOb2RlO1xuICB9XG5cbiAgaXNFcHNpbG9uTm9kZSgpIHtcbiAgICBjb25zdCBlcHNpbG9uTm9kZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlO1xuICB9XG5cbiAgaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gdHJ1ZTtcbiAgICBcbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHsgcmV0dXJuIHRoaXMuc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7IH1cblxuICBnZXRDb250ZW50KCkgeyByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuLmdldENvbnRlbnQoKTsgfVxuXG4gIGdldFByZWNlZGVuY2UoKSAge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsO1xuXG4gICAgcmV0dXJuIHByZWNlZGVuY2U7XG4gIH1cblxuICBpc0xvd2VyUHJlY2VkZW5jZShwYXJlbnRSdWxlTmFtZSwgcGFyZW50UHJlY2VkZW5jZSkge1xuICAgIGNvbnN0IGxvd2VyUHJlY2VkZW5jZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGxvd2VyUHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2Vucykge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRoaXMuZ2V0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSBzaWduaWZpY2FudFRva2VuSW5kZXg7IC8vL1xuXG4gICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuSW5kZXggPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpLFxuICAgICAgICAgIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSBzaWduaWZpY2FudFRva2VuSW5kZXg7IC8vL1xuXG4gICAgcmV0dXJuIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXg7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSB7XG4gICAgbGV0IHNpZ25pZmljYW50VG9rZW5JbmRleCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICBzaWduaWZpY2FudFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZih0aGlzLnNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuSW5kZXg7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VucyhzaWduaWZpY2FudFRva2VucyA9IFtdKSB7XG4gICAgaWYgKHRoaXMuc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgc2lnbmlmaWNhbnRUb2tlbnMucHVzaCh0aGlzLnNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VucztcbiAgfVxuXG4gIGdldEFuY2VzdG9yTm9kZXMoKSB7XG4gICAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IFtdO1xuXG4gICAgbGV0IGFuY2VzdG9yTm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8vXG5cbiAgICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgICBhbmNlc3Rvck5vZGVzLnB1c2goYW5jZXN0b3JOb2RlKTtcblxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yTm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgIGFuY2VzdG9yTm9kZSA9IHBhcmVudE5vZGU7ICAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2RlcztcbiAgfVxuXG4gIG1hcEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGFuY2VzdG9yTm9kZXMgPSB0aGlzLmdldEFuY2VzdG9yTm9kZXMoKTtcblxuICAgIHJldHVybiBhbmNlc3Rvck5vZGVzLm1hcChjYWxsYmFjayk7XG4gIH1cblxuICBzb21lQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgbGV0IGluZGV4ID0gMCxcbiAgICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICAgIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7IC8vL1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaW5kQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IGluZGV4ID0gMCxcbiAgICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICAgIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKGFuY2VzdG9yTm9kZSwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBhbmNlc3Rvck5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICBhbmNlc3Rvck5vZGUgPSBwYXJlbnROb2RlOyAgLy8vXG5cbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JOb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGFuY2VzdG9yTm9kZTtcbiAgfVxuXG4gIGV2ZXJ5QW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICBsZXQgaW5kZXggPSAwLFxuICAgICAgICBhbmNlc3Rvck5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vL1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gISFjYWxsYmFjayhhbmNlc3Rvck5vZGUsIGluZGV4KTsgLy8vXG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaWx0ZXJBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xuICB9XG5cbiAgcmVkdWNlQW5jZXN0b3JOb2RlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBmb3JFYWNoQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gICAgYW5jZXN0b3JOb2Rlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGdldERlc2NlbmRhbnROb2RlcyhkZXNjZW5kYW50Tm9kZXMgPSBbXSkge1xuICAgIHJldHVybiBkZXNjZW5kYW50Tm9kZXM7XG4gIH1cblxuICBzb21lRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgICBsZXQgZGVzY2VuZGFudE5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVzY2VuZGFudE5vZGU7XG4gIH1cblxuICBldmVyeURlc2NlbmRhbnROb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gdGhpcywgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFRlcm1pbmFsTm9kZVBhcnNlVHJlZS5mcm9tVGVybWluYWxOb2RlQW5kVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBtYXRjaChub2RlLCBkZXB0aCA9IEluZmluaXR5LCBleGFjdGx5ID0gZmFsc2UpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICBzaWduaWZpY2FudFRva2VuID0gdGVybWluYWxOb2RlLmdldFNpZ25pZmljYW50VG9rZW4oKTtcblxuICAgICAgbWF0Y2hlcyA9IGV4YWN0bHkgP1xuICAgICAgICAgICAgICAgICAgKHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9PT0gc2lnbmlmaWNhbnRUb2tlbikgOlxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduaWZpY2FudFRva2VuLm1hdGNoKHNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSB0aGlzLnNpZ25pZmljYW50VG9rZW4sXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGlmIChDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBDbGFzcyA9IFRlcm1pbmFsTm9kZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG51bGwsXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IG51bGwsXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21TaWduaWZpY2FudFRva2VuKENsYXNzLCBzaWduaWZpY2FudFRva2VuLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduaWZpY2FudFRva2VuID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IFRlcm1pbmFsTm9kZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG51bGwsXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgXG4gICAgcmV0dXJuIHRlcm1pbmFsTm9kZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuLi9wYXJzZVRyZWUvdmVydGljYWxCcmFuY2hcIjtcblxuY29uc3QgeyBlcHNpbG9uIH0gPSBzcGVjaWFsU3ltYm9scztcblxuY2xhc3MgRXBzaWxvbk5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBlcHNpbG9uLCAvLy9cbiAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGggPSBzdHJpbmdMZW5ndGgsIC8vL1xuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGgpLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCksXG4gICAgICAgICAgdGVybWluYWxOb2RlUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oRXBzaWxvbk5vZGVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9Ub3AodmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuXG4gICAgY29uc3QgZXBzaWxvbk5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlUGFyc2VUcmVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXBzaWxvbk5vZGVQYXJzZVRyZWU7IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vdGVybWluYWxcIjtcbmltcG9ydCBFcHNpbG9uTm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vLi4vcGFyc2VUcmVlL2Vwc2lsb25Ob2RlXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25Ob2RlIGV4dGVuZHMgVGVybWluYWxOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBjb25zdCB0eXBlID0gbnVsbDsgIC8vL1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBlcHNpbG9uOyAgLy8vXG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlzRXBzaWxvbk5vZGUoKSB7XG4gICAgY29uc3QgZXBzaWxvbk5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlO1xuICB9XG5cbiAgYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgY29uc3QgZXBzaWxvbk5vZGVQYXJzZVRyZWUgPSBFcHNpbG9uTm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IGVwc2lsb25Ob2RlUGFyc2VUcmVlOyAgLy8vXG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgbWF0Y2gobm9kZSwgZGVwdGgpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICB0ZXJtaW5hbE5vZGVFcHNpbG9uTm9kZSA9IHRlcm1pbmFsTm9kZS5pc0Vwc2lsb25Ob2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVFcHNpbG9uTm9kZSkge1xuICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIFRlcm1pbmFsTm9kZS5mcm9tTm90aGluZyhFcHNpbG9uTm9kZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBFcHNpbG9uQk5GTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9lcHNpbG9uXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25QYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgZXBzaWxvbkJORk5vZGUgPSBFcHNpbG9uQk5GTm9kZS5mcm9tTm90aGluZygpO1xuXG4gICAgcGFyc2VkID0gKGVwc2lsb25CTkZOb2RlICE9PSBudWxsKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIG5vZGVzLnB1c2goZXBzaWxvbkJORk5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGVwc2lsb247IC8vL1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlcHNpbG9uUGFydCA9IG5ldyBFcHNpbG9uUGFydCgpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25QYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFcHNpbG9uUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbC9lcHNpbG9uXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25CTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGVwc2lsb25QYXJ0ID0gRXBzaWxvblBhcnQuZnJvbU5vdGhpbmcoKTtcblxuICAgIHJldHVybiBlcHNpbG9uUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXBzaWxvbkJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb21cIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgUlVMRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVSdWxlcyhSdWxlKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSVUxFX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcnVsZUJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICBydWxlcyA9IHJ1bGVCTkZOb2Rlcy5tYXAoKHJ1bGVCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZUJORk5vZGUuZ2VuZXJhdGVSdWxlKFJ1bGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKERvY3VtZW50Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJ1bGVOYW1lUGFydFR5cGUgfSBmcm9tIFwiLi4vLi4vcGFydFR5cGVzXCI7XG5cbmNvbnN0IHsgZWxsaXBzaXMgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZVBhcnQgZXh0ZW5kcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQUFoZWFkLCBydWxlTmFtZSkge1xuICAgIHN1cGVyKHR5cGUsIGNhbGxBQWhlYWQpO1xuXG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICB9XG4gIFxuICBnZXRSdWxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZTtcbiAgfVxuXG4gIGlzUnVsZU5hbWVQYXJ0KCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IHRydWU7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG5cbiAgZmluZFJ1bGUoc3RhdGUpIHtcbiAgICBjb25zdCBydWxlTWFwID0gc3RhdGUuZ2V0UnVsZU1hcCgpLFxuICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3RoaXMucnVsZU5hbWVdIHx8IG51bGw7ICAvLy9cblxuICAgIHJldHVybiBydWxlO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmZpbmRSdWxlKHN0YXRlKTtcblxuICAgIHBhcnNlZCA9IChydWxlICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICBydWxlLnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkgOlxuICAgICAgICAgICAgICAgICBmYWxzZTtcblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBjYWxsQUFoZWFkID0gdGhpcy5pc0NhbGxBaGVhZCgpLFxuICAgICAgICAgIGNhbGxBQWhlYWRTdHJpbmcgPSBjYWxsQUFoZWFkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbGlwc2lzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HLFxuICAgICAgICAgIHN0cmluZyA9IGAke3RoaXMucnVsZU5hbWV9JHtjYWxsQUFoZWFkU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZShydWxlTmFtZSkge1xuICAgIGNvbnN0IHR5cGUgPSBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICBydWxlTmFtZVBhcnQgPSBuZXcgUnVsZU5hbWVQYXJ0KHR5cGUsIGNhbGxBQWhlYWQsIHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUNhbGxBaGVhZEFuZFJ1bGVOYW1lKGNhbGxBQWhlYWQsIHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IFJ1bGVOYW1lUGFydFR5cGUsXG4gICAgICAgICAgcnVsZU5hbWVQYXJ0ID0gbmV3IFJ1bGVOYW1lUGFydCh0eXBlLCBjYWxsQUFoZWFkLCBydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZUJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVDb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQsIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tQ2FsbEFoZWFkQW5kUnVsZU5hbWUoY2FsbEFoZWFkLCBydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSdWxlTmFtZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiO1xuXG5jb25zdCB7IHdpbGRjYXJkIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lsZGNhcmRQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGxldCB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuXHRcdFx0XHRcdHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgdGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlLmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHdpbGRjYXJkOyAgLy8vXG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHdpbGRjYXJkUGFydCA9IG5ldyBXaWxkY2FyZFBhcnQoKTtcblxuICAgIHJldHVybiB3aWxkY2FyZFBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFdpbGRjYXJkUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbC93aWxkY2FyZFwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWxkY2FyZEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgd2lsZGNhcmRQYXJ0ID0gV2lsZGNhcmRQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gd2lsZGNhcmRQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShXaWxkY2FyZEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuL3ZlcnRpY2FsQnJhbmNoXCI7XG5cbmNvbnN0IHsgZW5kT2ZMaW5lIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGVuZE9mTGluZSwgLy8vXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKEVuZE9mTGluZU5vZGVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9Ub3AodmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuXG4gICAgY29uc3QgZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSA9IHRlcm1pbmFsTm9kZVBhcnNlVHJlZTsgLy8vXG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi90ZXJtaW5hbFwiO1xuaW1wb3J0IEVuZE9mTGluZU5vZGVQYXJzZVRyZWUgZnJvbSBcIi4uLy4uL3BhcnNlVHJlZS9lbmRPZkxpbmVOb2RlXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lTm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XG4gIGdldENvbnRlbnQoZmFpdGhmdWwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmYWl0aGZ1bCA/XG4gICAgICAgICAgICAgICAgICAgICAgc3VwZXIuZ2V0Q29udGVudCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORzsgLy8vXG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IGVuZE9mTGluZU5vZGVQYXJzZVRyZWUgPSBFbmRPZkxpbmVOb2RlUGFyc2VUcmVlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFyc2VUcmVlID0gZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZTsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKSB7IHJldHVybiBUZXJtaW5hbE5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oRW5kT2ZMaW5lTm9kZSwgc2lnbmlmaWNhbnRUb2tlbik7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBFbmRPZkxpbmVOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1pbmFsL2VuZE9mTGluZVwiO1xuXG5jb25zdCB7IGVuZE9mTGluZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZE9mTGluZVBhcnQgZXh0ZW5kcyBUZXJtaW5hbFBhcnQge1xuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IGVuZE9mTGluZU5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlbkVuZE9mTGluZVRva2VuID0gc2lnbmlmaWNhbnRUb2tlbi5pc0VuZE9mTGluZVRva2VuKCk7XG5cbiAgICAgIGlmIChzaWduaWZpY2FudFRva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgZW5kT2ZMaW5lTm9kZSA9IEVuZE9mTGluZU5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKGVuZE9mTGluZU5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaChlbmRPZkxpbmVOb2RlKTtcblxuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBpZiAoY2FsbEFoZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBlbmRPZkxpbmU7IC8vL1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlbmRPZkxpbmVQYXJ0ID0gbmV3IEVuZE9mTGluZVBhcnQoKTtcblxuICAgIHJldHVybiBlbmRPZkxpbmVQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbmRPZkxpbmVQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGVuZE9mTGluZVBhcnQgPSBFbmRPZkxpbmVQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRW5kT2ZMaW5lQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0Q2hvaWNlIHtcbiAgY29uc3RydWN0b3IocGFydCwgcHJlY2VkZW5jZSkge1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFBhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydDtcbiAgfVxuXG4gIGdldFByZWNlZGVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZTtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmc7XG5cbiAgICBjb25zdCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCk7XG5cbiAgICBzdHJpbmcgPSBwYXJ0U3RyaW5nOyAgLy8vXG5cbiAgICBpZiAodGhpcy5wcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQQUNFX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZTtcblxuICAgICAgc3RyaW5nID0gYCR7c3RyaW5nfSAoJHtwcmVjZWRlbmNlfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnQocGFydCkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHBhcnRDaG9pY2UgPSBuZXcgUGFydENob2ljZShwYXJ0LCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJ0Q2hvaWNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXJ0QW5kUHJlY2VkZW5jZShwYXJ0LCBwcmVjZWRlbmNlKSB7XG4gICAgY29uc3QgcGFydENob2ljZSA9IG5ldyBQYXJ0Q2hvaWNlKHBhcnQsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHBhcnRDaG9pY2U7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFBhcnRDaG9pY2UgZnJvbSBcIi4uLy4uL3BhcnRDaG9pY2VcIjtcbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydENob2ljZUJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnRDaG9pY2UoY2FsbEFoZWFkKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgcnVsZU5hbWUgPSBQQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHBhcnRCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBQUkVDRURFTkNFX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHByZWNlZGVuY2VCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgY2FsbEFoZWFkID0gZmFsc2U7ICAvLy9cblxuICAgIGNvbnN0IHBhcnQgPSBwYXJ0Qk5GTm9kZS5nZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gKHByZWNlZGVuY2VCTkZOb2RlID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VCTkZOb2RlLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICBkZWZpbml0aW9uID0gUGFydENob2ljZS5mcm9tUGFydEFuZFByZWNlZGVuY2UocGFydCwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUGFydENob2ljZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZWNlZGVuY2VCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0UHJlY2VkZW5jZSgpIHtcbiAgICBsZXQgcHJlY2VkZW5jZSA9IEluZmluaXR5O1xuXG4gICAgY29uc3QgbXVsdGlwbGljaXR5ID0gdGhpcy5nZXRNdWx0aXBsaWNpdHkoKTtcblxuICAgIGlmIChtdWx0aXBsaWNpdHkgPT09IDMpIHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICAgIHNlY29uZENoaWxkTm9kZSA9IHNlY29uZChjaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHByZWNlZGVuY2UgPSBOdW1iZXIoY29udGVudCk7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBwcmVjZWRlbmNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcmVjZWRlbmNlQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhbnRpZmllckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFF1YW50aWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBjb25zdCBpbmRleCA9IDAsXG4gICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgIHBhcnRcbiAgICAgICAgXTtcblxuICBwYXJzZWQgPSBwYXJzZVBhcnRPZlBhcnRzKGluZGV4LCBwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJ0cyhwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgY29uc3QgaW5kZXggPSAwO1xuXG4gIHBhcnNlZCA9IHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBjb25zdCBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICBpZiAoaW5kZXggPT09IHBhcnRzTGVuZ3RoKSB7XG4gICAgcGFyc2VkID0gKGNhbGxiYWNrICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICBjYWxsYmFjaygpIDpcbiAgICAgICAgICAgICAgICAgdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbaW5kZXhdLFxuICAgICAgICAgIHBhcnRDYWxsQWhlYWQgPSAoY2FsbEFoZWFkID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pc0NhbGxBaGVhZCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWU7XG5cbiAgICBpbmRleCsrO1xuXG4gICAgcGFyc2VkID0gcGFydENhbGxBaGVhZCA/XG4gICAgICAgICAgICAgICBwYXJzZVBhcnRXaXRoQ2FsbEFoZWFkKHBhcnQsIGluZGV4LCBwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSA6XG4gICAgICAgICAgICAgICAgIHBhcnNlUGFydFdpdGhvdXRDYWxsQWhlYWQocGFydCwgaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0V2l0aENhbGxBaGVhZChwYXJ0LCBpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGNhbGxBaGVhZCA9ICgpID0+IHsgLy8vXG4gICAgbGV0IHBhcnNlZDtcblxuICAgIHBhcnNlZCA9IHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfTtcblxuICBwYXJzZWQgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgaWYgKCFwYXJzZWQpIHtcbiAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0V2l0aG91dENhbGxBaGVhZChwYXJ0LCBpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICBpZiAocGFyc2VkKSB7XG4gICAgcGFyc2VkID0gcGFyc2VQYXJ0T2ZQYXJ0cyhpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBwYXJzZVBhcnRzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlXCI7XG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJ0cywgcHJlY2VkZW5jZSkge1xuICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICB9XG5cbiAgZ2V0UGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cblxuICBnZXRQcmVjZWRlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2U7XG4gIH1cblxuICBwYXJzZShjaGlsZE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBjb25zdCBub2RlcyA9IGNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCk7XG5cbiAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBsZXQgc3RyaW5nO1xuXG4gICAgY29uc3QgcGFydHNTdHJpbmcgPSB0aGlzLnBhcnRzLnJlZHVjZSgocGFydHNTdHJpbmcsIHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRTdHJpbmcgPSBwYXJ0LmFzU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1N0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gcGFydFN0cmluZzsgLy8vXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJ0c1N0cmluZyA9IGAke3BhcnRzU3RyaW5nfSAke3BhcnRTdHJpbmd9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzU3RyaW5nO1xuICAgICAgICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICBzdHJpbmcgPSBwYXJ0c1N0cmluZzsgLy8vXG5cbiAgICBpZiAodGhpcy5wcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQQUNFX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZTtcblxuICAgICAgc3RyaW5nID0gYCR7c3RyaW5nfSAoJHtwcmVjZWRlbmNlfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnRzKENsYXNzLCBwYXJ0cykge1xuICAgIGlmIChwYXJ0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cyA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gRGVmaW5pdGlvbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IG5ldyBDbGFzcyhwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydHNBbmRQcmVjZWRlbmNlKENsYXNzLCBwYXJ0cywgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBwYXJ0czsgLy8vXG5cbiAgICAgIHBhcnRzID0gQ2xhc3M7ICAvLy9cblxuICAgICAgQ2xhc3MgPSBEZWZpbml0aW9uOyAvLy9cbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gbmV3IENsYXNzKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lLCBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZURlZmluaXRpb24oKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgcnVsZU5hbWUgPSBQQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHBhcnRCTkZOb2RlcyA9IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZUJORk5vZGUgPSBub2RlRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSksXG4gICAgICAgICAgY2FsbEFoZWFkID0gZmFsc2UsICAvLy9cbiAgICAgICAgICBwYXJ0cyA9IHBhcnRCTkZOb2Rlcy5tYXAoKHBhcnRCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydEJORk5vZGUuZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCk7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IChwcmVjZWRlbmNlQk5GTm9kZSA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlQk5GTm9kZS5nZXRQcmVjZWRlbmNlKCksXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IERlZmluaXRpb24uZnJvbVBhcnRzQW5kUHJlY2VkZW5jZShwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGVmaW5pdGlvbkJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IERFRklOSVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25zQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBERUZJTklUSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgZGVmaW5pdGlvbkJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IGRlZmluaXRpb25CTkZOb2Rlcy5tYXAoKGRlZmluaXRpb25CTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmaW5pdGlvbkJORk5vZGUuZ2VuZXJhdGVEZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGVmaW5pdGlvbnNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsUGFydEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgbm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCk7XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVGVybWluYWxQYXJ0Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgcGFyc2VQYXJ0IH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wYXJzZVwiO1xuaW1wb3J0IHsgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlIH0gZnJvbSBcIi4uLy4uL3BhcnRUeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzUGFydCBleHRlbmRzIE5vblRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNhbGxBaGVhZCwgcGFydENob2ljZXMpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuICAgIFxuICAgIHRoaXMucGFydENob2ljZXMgPSBwYXJ0Q2hvaWNlcztcbiAgfVxuICBcbiAgZ2V0UGFydENob2ljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydENob2ljZXM7XG4gIH1cblxuICBnZXRQYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFydENob2ljZXMubWFwKChwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydENob2ljZS5nZXRQYXJ0KCk7XG5cbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHNhdmVkUHJlY2VkZW5jZSA9IHN0YXRlLmdldFNhdmVkUHJlY2VkZW5jZSgpO1xuXG4gICAgcGFyc2VkID0gdGhpcy5wYXJ0Q2hvaWNlcy5zb21lKChwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICBjb25zdCBwYXJ0ID0gcGFydENob2ljZS5nZXRQYXJ0KCksXG4gICAgICAgICAgICBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHBhcnRDaG9pY2UuZ2V0UHJlY2VkZW5jZSgpLFxuICAgICAgICAgICAgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChwcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrID0gKGNhbGxBaGVhZCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgIHBhcnNlZCA9IHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICAgICAgbm9kZXMuc3BsaWNlKHN0YXJ0KTtcblxuICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUucmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRDaG9pY2VzU3RyaW5nID0gdGhpcy5wYXJ0Q2hvaWNlcy5yZWR1Y2UoKHBhcnRDaG9pY2VzU3RyaW5nLCBwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q2hvaWNlU3RyaW5nID0gcGFydENob2ljZS5hc1N0cmluZygpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHBhcnRDaG9pY2VzU3RyaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnRDaG9pY2VzU3RyaW5nID0gcGFydENob2ljZVN0cmluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnRDaG9pY2VzU3RyaW5nID0gYCR7cGFydENob2ljZXNTdHJpbmd9IHwgJHtwYXJ0Q2hvaWNlU3RyaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcGFydENob2ljZXNTdHJpbmc7XG4gICAgICAgICAgfSwgbnVsbCksXG4gICAgICAgICAgc3RyaW5nID0gYCggJHtwYXJ0Q2hvaWNlc1N0cmluZ30gKWA7XG4gICAgXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydENob2ljZXMocGFydENob2ljZXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIGNob2ljZU9mUGFydHNQYXJ0ID0gbmV3IENob2ljZU9mUGFydHNQYXJ0KHR5cGUsIGNhbGxBaGVhZCwgcGFydENob2ljZXMpO1xuXG4gICAgcmV0dXJuIGNob2ljZU9mUGFydHNQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBDaG9pY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9jaG9pY2VPZlBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlUGFydChjYWxsQWhlYWQpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcGFydENob2ljZUJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKTtcblxuICAgIGNhbGxBaGVhZCA9IGZhbHNlOyAgLy8vXG5cbiAgICBjb25zdCBwYXJ0Q2hvaWNlcyA9IHBhcnRDaG9pY2VCTkZOb2Rlcy5tYXAoKHBhcnRDaG9pY2VCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q2hvaWNlID0gcGFydENob2ljZUJORk5vZGUuZ2VuZXJhdGVQYXJ0Q2hvaWNlKGNhbGxBaGVhZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q2hvaWNlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNob2ljZU9mUGFydHNQYXJ0ID0gQ2hvaWNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRDaG9pY2VzKHBhcnRDaG9pY2VzKSxcbiAgICAgICAgICBwYXJ0ID0gY2hvaWNlT2ZQYXJ0c1BhcnQ7IC8vL1xuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENob2ljZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IHRlcm1pbmFsTm9kZSA9IG51bGw7XG4gICAgXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBuZXh0U2lnbmlmaWNhbnRUb2tlbiA9IHN0YXRlLmdldE5leHRTaWduaWZpY2FudFRva2VuKCksXG5cdFx0XHRcdFx0c2lnbmlmaWNhbnRUb2tlbiA9IG5leHRTaWduaWZpY2FudFRva2VuOyAvLy9cblxuICAgIGlmIChzaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlLmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBcbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC5yZXBsYWNlKC9cXFxcLywgXCJcXFxcXFxcXFwiKSxcbiAgICAgICAgICBzdHJpbmcgPSBgXCIke2NvbnRlbnR9XCJgO1xuICAgIFxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWxQYXJ0ID0gbmV3IFN0cmluZ0xpdGVyYWxQYXJ0KGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBFU0NBUEVEX0JBQ0tTTEFTSCwgRVNDQVBFRF9ET1VCTEVfUVVPVEUgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmluZ0xpdGVyYWxCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmVndWxhckV4cHJlc3Npb24gPSAvXlwiKCg/OlxcXFwufFteXCJcXFxcXSkqKVwiJC87XG5cbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxQYXJ0O1xuICB9XG5cbiAgZ2V0Q29udGVudCgpIHtcbiAgICBsZXQgY29udGVudDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZUNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbiksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBjb250ZW50ID0gc2Vjb25kTWF0Y2g7ICAvLy9cblxuICAgIGNvbnRlbnQgPSBzYW5pdGlzZUNvbnRlbnQoY29udGVudCk7XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU3RyaW5nTGl0ZXJhbEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGlzZUNvbnRlbnQoY29udGVudCkge1xuICBjb250ZW50ID0gY29udGVudFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgRVNDQVBFRF9CQUNLU0xBU0gpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgRVNDQVBFRF9ET1VCTEVfUVVPVEUpO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKTtcblxuICAgIGlmICghY2FsbEFoZWFkKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgICBjYWxsQWhlYWQgPSAoY2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIG5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKE5vblRlcm1pbmFsUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IHBhcnNlUGFydHMgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3BhcnNlXCI7XG5pbXBvcnQgeyBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSB9IGZyb20gXCIuLi8uLi9wYXJ0VHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VxdWVuY2VPZlBhcnRzUGFydCBleHRlbmRzIE5vblRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNhbGxBaGVhZCwgcGFydHMpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuXG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgZ2V0UGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGNhbGxiYWNrID0gKGNhbGxBaGVhZCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICgpID0+IHsgIC8vL1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuXG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRzU3RyaW5nID0gdGhpcy5wYXJ0cy5yZWR1Y2UoKHBhcnRzU3RyaW5nLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0U3RyaW5nID0gcGFydC5hc1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAocGFydHNTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFydHNTdHJpbmcgPSBwYXJ0U3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFydHNTdHJpbmcgPSBgJHtwYXJ0c1N0cmluZ30gJHtwYXJ0U3RyaW5nfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0c1N0cmluZztcbiAgICAgICAgICB9LCBudWxsKSxcbiAgICAgICAgICBzdHJpbmcgPSBgKCAke3BhcnRzU3RyaW5nfSApYDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgY29uc3QgdHlwZSA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBuZXcgU2VxdWVuY2VPZlBhcnRzUGFydCh0eXBlLCBjYWxsQWhlYWQsIHBhcnRzKTtcblxuICAgIHJldHVybiBzZXF1ZW5jZU9mUGFydHNQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBTZXF1ZW5jZU9mUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBQQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHBhcnRCTkZOb2RlcyA9IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSk7XG5cbiAgICBjYWxsQWhlYWQgPSBmYWxzZTsgIC8vL1xuXG4gICAgY29uc3QgcGFydHMgPSBwYXJ0Qk5GTm9kZXMubWFwKChwYXJ0Qk5GTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRCTkZOb2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gU2VxdWVuY2VPZlBhcnRzUGFydC5mcm9tUGFydHMocGFydHMpLFxuICAgICAgICAgIHBhcnQgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0OyAvLy9cblxuICAgIHJldHVybiBwYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTZXF1ZW5jZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgc2Vjb25kQ2hpbGROb2RlID0gc2Vjb25kKGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgb3BhY2l0eSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQ7ICAvLy9cblxuICAgIHJldHVybiBvcGFjaXR5O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPcGFjaXR5TW9kaWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5jb25zdCB7IG5vV2hpdGVzcGFjZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBub1doaXRlc3BhY2UsIC8vL1xuICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWVXaWR0aCA9IHN0cmluZ0xlbmd0aCwgLy8vXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tV2lkdGgodmVydGljYWxCcmFuY2hQYXJzZVRyZWVXaWR0aCksXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgdGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcblxuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vdGVybWluYWxcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlIGZyb20gXCIuLi8uLi9wYXJzZVRyZWUvbm9XaGl0ZXNwYWNlTm9kZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZU5vZGUgZXh0ZW5kcyBUZXJtaW5hbE5vZGUge1xuICBnZXRUeXBlKCkge1xuICAgIGNvbnN0IHR5cGUgPSBudWxsOyAgLy8vXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgY29uc3QgY29udGVudCA9IEVNUFRZX1NUUklORztcblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZU5vZGU7XG4gIH1cblxuICBhc1BhcnNlVHJlZSh0b2tlbnMpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlID0gTm9XaGl0ZXNwYWNlTm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBtYXRjaChub2RlLCBkZXB0aCkge1xuICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGUsICAvLy9cbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZU5vV2hpdGVzcGFjZU5vZGUgPSB0ZXJtaW5hbE5vZGUuaXNOb1doaXRlc3BhY2VOb2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVOb1doaXRlc3BhY2VOb2RlKSB7XG4gICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gVGVybWluYWxOb2RlLmZyb21Ob3RoaW5nKE5vV2hpdGVzcGFjZU5vZGUpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcblxuY29uc3QgeyBub1doaXRlc3BhY2UgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb1doaXRlc3BhY2VQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgaXNOb1doaXRlc3BhY2VQYXJ0KCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IG5vV2hpdGVzcGFjZU5vZGUgPSBudWxsO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBzdGF0ZS5pc05leHRUb2tlbldoaXRlc3BhY2VUb2tlbigpO1xuXG4gICAgaWYgKCFuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4pIHtcbiAgICAgIG5vV2hpdGVzcGFjZU5vZGUgPSBOb1doaXRlc3BhY2VOb2RlLmZyb21Ob3RoaW5nKCk7XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKG5vV2hpdGVzcGFjZU5vZGUgIT09IG51bGwpXG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBub2Rlcy5wdXNoKG5vV2hpdGVzcGFjZU5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IG5vV2hpdGVzcGFjZTsgLy8vXG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSBuZXcgTm9XaGl0ZXNwYWNlUGFydCgpO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSBOb1doaXRlc3BhY2VQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbGxBaGVhZE1vZGlmaWVyQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBUZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvdGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVndWxhckV4cHJlc3Npb24gPSByZWd1bGFyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGxldCB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuXHRcdFx0XHRcdHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHNpZ25pZmljYW50VG9rZW4uZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBmaXJzdChtYXRjaGVzKTtcblxuICAgICAgICBpZiAoZmlyc3RNYXRjaCA9PT0gY29udGVudCkge1xuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IFRlcm1pbmFsTm9kZS5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nID0gdGhpcy5yZWd1bGFyRXhwcmVzc2lvbi50b1N0cmluZygpLFxuXHRcdCAgICAgIHN0cmluZyA9IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nOyAvLy9cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlZ3VsYXJFeHByZXNzaW9uKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgY29uc3QgcmVndWxhckV4cHJlc3Npb25QYXJ0ID0gbmV3IFJlZ3VsYXJFeHByZXNzaW9uUGFydChyZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25QYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgUmVndWxhckV4cHJlc3Npb25QYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3JlZ3VsYXJFeHByZXNzaW9uXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJlZ3VsYXJFeHByZXNzaW9uID0gL15cXC8oKD86XFxcXC58W15cXC9dKSopXFwvJC87XG5cbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uID0gdGhpcy5nZXRSZWd1bGFyRXhwcmVzc2lvbigpLFxuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUGFydCA9IFJlZ3VsYXJFeHByZXNzaW9uUGFydC5mcm9tUmVndWxhckV4cHJlc3Npb24ocmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgcmV0dXJuIHJlZ3VsYXJFeHByZXNzaW9uUGFydDtcbiAgfVxuXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZUNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbiksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyksXG4gICAgICAgICAgcGF0dGVybiA9IHNlY29uZE1hdGNoLCAvLy9cbiAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocGF0dGVybik7ICAvLy9cblxuICAgIHJldHVybiByZWd1bGFyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuL3ZlcnRpY2FsQnJhbmNoXCI7XG5cbmNvbnN0IHsgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFydE9mQ29udGVudE5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBzdGFydE9mQ29udGVudCwgLy8vXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICBjb25zdCBzdGFydE9mQ29udGVudE5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi90ZXJtaW5hbFwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vLi4vcGFyc2VUcmVlL3N0YXJ0T2ZDb250ZW50Tm9kZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50Tm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgY29uc3QgdHlwZSA9IG51bGw7ICAvLy9cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0Q29udGVudCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpc1N0YXJ0T2ZDb250ZW50Tm9kZSgpIHtcbiAgICBjb25zdCBzdGFydE9mQ29udGVudE5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50Tm9kZTtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSA9IFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZTsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIG1hdGNoKG5vZGUsIGRlcHRoKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgICAgdGVybWluYWxOb2RlU3RhcnRPZkNvbnRlbnROb2RlID0gdGVybWluYWxOb2RlLmlzU3RhcnRPZkNvbnRlbnROb2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVTdGFydE9mQ29udGVudE5vZGUpIHtcbiAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBUZXJtaW5hbE5vZGUuZnJvbU5vdGhpbmcoU3RhcnRPZkNvbnRlbnROb2RlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50Tm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9zdGFydE9mQ29udGVudFwiO1xuXG5jb25zdCB7IHN0YXJ0T2ZDb250ZW50IH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhcnRPZkNvbnRlbnRQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgaXNTdGFydE9mQ29udGVudFBhcnQoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gdHJ1ZTtcblxuICAgIHJldHVybiBzdGFydE9mQ29udGVudFBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IHN0YXJ0T2ZDb250ZW50Tm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIGF0U3RhcnRPZkNvbnRlbnQgPSBzdGF0ZS5pc0F0U3RhcnRPZkNvbnRlbnQoKTtcblxuICAgIGlmIChhdFN0YXJ0T2ZDb250ZW50KSB7XG4gICAgICBzdGFydE9mQ29udGVudE5vZGUgPSBTdGFydE9mQ29udGVudE5vZGUuZnJvbU5vdGhpbmcoKTtcbiAgICB9XG5cbiAgICBwYXJzZWQgPSAoc3RhcnRPZkNvbnRlbnROb2RlICE9PSBudWxsKVxuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaChzdGFydE9mQ29udGVudE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHN0YXJ0T2ZDb250ZW50OyAvLy9cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gbmV3IFN0YXJ0T2ZDb250ZW50UGFydCgpO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50UGFydDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgU3RhcnRPZkNvbnRlbnRQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50UGFydEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gU3RhcnRPZkNvbnRlbnRQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTdGFydE9mQ29udGVudFBhcnRCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPbmVPck1vcmVRdWFudGlmaWVyQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoT25lT3JNb3JlUXVhbnRpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCI7XG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHNpZ25pZmljYW50VG9rZW5UeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlblR5cGU7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VuVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZTtcbiAgfVxuXG4gIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBsZXQgdGVybWluYWxOb2RlID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIG5leHRTaWduaWZpY2FudFRva2VuID0gc3RhdGUuZ2V0TmV4dFNpZ25pZmljYW50VG9rZW4oKSxcblx0XHRcdFx0XHRzaWduaWZpY2FudFRva2VuID0gbmV4dFNpZ25pZmljYW50VG9rZW47IC8vL1xuXG4gICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7XG5cbiAgICAgIGlmIChzaWduaWZpY2FudFRva2VuVHlwZSA9PT0gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZSkge1xuICAgICAgICB0ZXJtaW5hbE5vZGUgPSBUZXJtaW5hbE5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKHRlcm1pbmFsTm9kZSAhPT0gbnVsbCk7XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBub2Rlcy5wdXNoKHRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgaWYgKGNhbGxBaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gYFske3RoaXMuc2lnbmlmaWNhbnRUb2tlblR5cGV9XWA7XG4gICAgXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBuZXcgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KHNpZ25pZmljYW50VG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuY29uc3QgeyBmaXJzdCwgc2Vjb25kIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcWyhbXlxcXV0rKV0kLztcblxuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5UeXBlKCksXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0O1xuICB9XG5cbiAgZ2V0U2lnbmlmaWNhbnRUb2tlblR5cGUoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVDb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBtYXRjaGVzID0gdGVybWluYWxOb2RlQ29udGVudC5tYXRjaCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKSxcbiAgICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGU7XG5cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFplcm9yT3JNb3JlUXVhbnRpZmllckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFplcm9yT3JNb3JlUXVhbnRpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFydEJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvcGFydFwiO1xuaW1wb3J0IE5hbWVCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL25hbWVcIjtcbmltcG9ydCBSdWxlQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ydWxlXCI7XG5pbXBvcnQgRXJyb3JCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL2Vycm9yXCI7XG5pbXBvcnQgRXBzaWxvbkJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZXBzaWxvblwiO1xuaW1wb3J0IERvY3VtZW50Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9kb2N1bWVudFwiO1xuaW1wb3J0IFJ1bGVOYW1lQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ydWxlTmFtZVwiO1xuaW1wb3J0IFdpbGRjYXJkQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi93aWxkY2FyZFwiO1xuaW1wb3J0IEVuZE9mTGluZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgUGFydENob2ljZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvcGFydENob2ljZVwiO1xuaW1wb3J0IFByZWNlZGVuY2VCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3ByZWNlZGVuY2VcIjtcbmltcG9ydCBRdWFudGlmaWVyQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9xdWFudGlmaWVyXCI7XG5pbXBvcnQgRGVmaW5pdGlvbkJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZGVmaW5pdGlvblwiO1xuaW1wb3J0IERlZmluaXRpb25zQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9kZWZpbml0aW9uc1wiO1xuaW1wb3J0IFRlcm1pbmFsUGFydEJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvdGVybWluYWxQYXJ0XCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0JORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCBCb25UZXJtaW5hbFBhcnRCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL25vblRlcm1pbmFsUGFydFwiO1xuaW1wb3J0IFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvc2VxdWVuY2VPZlBhcnRzXCI7XG5pbXBvcnQgT3BhY2l0eU1vZGlmaWVyQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9vcGFjaXR5TW9kaWZpZXJcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VQYXJ0Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5pbXBvcnQgQ2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL2NhbGxBaGVhZE1vZGlmaWVyXCI7XG5pbXBvcnQgUmVndWxhckV4cHJlc3Npb25CTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uXCI7XG5pbXBvcnQgU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9zdGFydE9mQ29udGVudFBhcnRcIjtcbmltcG9ydCBPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL29wdGlvbmFsUXVhbnRpZmllclwiO1xuaW1wb3J0IE9uZU9yTW9yZVF1YW50aWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL29uZU9uZU9yTW9yZVF1YW50aWZpZXJcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcbmltcG9ydCBaZXJvT3JNb3JlUXVhbnRpZmllckJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvemVyb09uZU9yTW9yZVF1YW50aWZpZXJcIjtcblxuaW1wb3J0IHsgTkFNRV9SVUxFX05BTUUsXG4gICAgICAgICBQQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFJVTEVfUlVMRV9OQU1FLFxuICAgICAgICAgRVJST1JfUlVMRV9OQU1FLFxuICAgICAgICAgRVBTSUxPTl9SVUxFX05BTUUsXG4gICAgICAgICBET0NVTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBXSUxEQ0FSRF9SVUxFX05BTUUsXG4gICAgICAgICBSVUxFX05BTUVfUlVMRV9OQU1FLFxuICAgICAgICAgREVGSU5JVElPTl9SVUxFX05BTUUsXG4gICAgICAgICBQUkVDRURFTkNFX1JVTEVfTkFNRSxcbiAgICAgICAgIFFVQU5USUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgRU5EX09GX0xJTkVfUlVMRV9OQU1FLFxuICAgICAgICAgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgREVGSU5JVElPTlNfUlVMRV9OQU1FLFxuICAgICAgICAgVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBTVFJJTkdfTElURVJBTF9SVUxFX05BTUUsXG4gICAgICAgICBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FLFxuICAgICAgICAgT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUUsXG4gICAgICAgICBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUsXG4gICAgICAgICBOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FLFxuICAgICAgICAgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsXG4gICAgICAgICBTVEFSVF9PRl9DT05URU5UX1BBUlRfUlVMRV9OQU1FLFxuICAgICAgICAgU0lHTklGSUNBTlRfVE9LRU5fVFlQRV9SVUxFX05BTUUsXG4gICAgICAgICBPTkVfT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSxcbiAgICAgICAgIFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuXG5jb25zdCBOb25UZXJtaW5hbE5vZGVNYXAgPSB7XG4gIFtOQU1FX1JVTEVfTkFNRV06IE5hbWVCTkZOb2RlLFxuICBbUEFSVF9SVUxFX05BTUVdOiBQYXJ0Qk5GTm9kZSxcbiAgW1JVTEVfUlVMRV9OQU1FXTogUnVsZUJORk5vZGUsXG4gIFtFUlJPUl9SVUxFX05BTUVdOiBFcnJvckJORk5vZGUsXG4gIFtFUFNJTE9OX1JVTEVfTkFNRV06IEVwc2lsb25CTkZOb2RlLFxuICBbRE9DVU1FTlRfUlVMRV9OQU1FXTogRG9jdW1lbnRCTkZOb2RlLFxuICBbV0lMRENBUkRfUlVMRV9OQU1FXTogV2lsZGNhcmRCTkZOb2RlLFxuICBbUlVMRV9OQU1FX1JVTEVfTkFNRV06IFJ1bGVOYW1lQk5GTm9kZSxcbiAgW0RFRklOSVRJT05fUlVMRV9OQU1FXTogRGVmaW5pdGlvbkJORk5vZGUsXG4gIFtQUkVDRURFTkNFX1JVTEVfTkFNRV06IFByZWNlZGVuY2VCTkZOb2RlLFxuICBbUVVBTlRJRklFUl9SVUxFX05BTUVdOiBRdWFudGlmaWVyQk5GTm9kZSxcbiAgW0VORF9PRl9MSU5FX1JVTEVfTkFNRV06IEVuZE9mTGluZUJORk5vZGUsXG4gIFtQQVJUX0NIT0lDRV9SVUxFX05BTUVdOiBQYXJ0Q2hvaWNlQk5GTm9kZSxcbiAgW0RFRklOSVRJT05TX1JVTEVfTkFNRV06IERlZmluaXRpb25zQk5GTm9kZSxcbiAgW1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FXTogVGVybWluYWxQYXJ0Qk5GTm9kZSxcbiAgW1NUUklOR19MSVRFUkFMX1JVTEVfTkFNRV06IFN0cmluZ0xpdGVyYWxCTkZOb2RlLFxuICBbQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRV06IENob2ljZU9mUGFydHNCTkZOb2RlLFxuICBbT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUVdOiBPcGFjaXR5TW9kaWZpZXJCTkZOb2RlLFxuICBbTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FXTogQm9uVGVybWluYWxQYXJ0Qk5GTm9kZSxcbiAgW1NFUVVFTkNFX09GX1BBUlRTX1JVTEVfTkFNRV06IFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUsXG4gIFtOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FXTogTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsXG4gIFtSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FXTogUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLFxuICBbQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUVdOiBDYWxsQWhlYWRNb2RpZmllckJORk5vZGUsXG4gIFtPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRV06IE9wdGlvbmFsUXVhbnRpZmllckJORk5vZGUsXG4gIFtTVEFSVF9PRl9DT05URU5UX1BBUlRfUlVMRV9OQU1FXTogU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GTm9kZSxcbiAgW1NJR05JRklDQU5UX1RPS0VOX1RZUEVfUlVMRV9OQU1FXTogU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLFxuICBbT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUVdOiBPbmVPck1vcmVRdWFudGlmaWVyQk5GTm9kZSxcbiAgW1pFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRV06IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GTm9kZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9uVGVybWluYWxOb2RlTWFwOyIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcihpbmRleCwgdG9rZW5zLCBydWxlTWFwLCBwcmVjZWRlbmNlLCBzdGFydE9mQ29udGVudCwgTm9uVGVybWluYWxOb2RlTWFwLCBkZWZhdWx0Tm9uVGVybWluYWxOb2RlKSB7XG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIHRoaXMucnVsZU1hcCA9IHJ1bGVNYXA7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgICB0aGlzLnN0YXJ0T2ZDb250ZW50ID0gc3RhcnRPZkNvbnRlbnQ7XG4gICAgdGhpcy5Ob25UZXJtaW5hbE5vZGVNYXAgPSBOb25UZXJtaW5hbE5vZGVNYXA7XG4gICAgdGhpcy5kZWZhdWx0Tm9uVGVybWluYWxOb2RlID0gZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4O1xuICB9XG5cbiAgZ2V0VG9rZW5zKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIGdldFJ1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU1hcDtcbiAgfVxuXG4gIGdldFByZWNlZGVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFN0YXJ0T2ZDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZDb250ZW50O1xuICB9XG5cbiAgZ2V0Tm9uVGVybWluYWxOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLk5vblRlcm1pbmFsTm9kZU1hcDtcbiAgfVxuXG4gIGdldERlZmF1bHROb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHNldEluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgc2V0VG9rZW5zKHRva2Vucykge1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgc2V0UnVsZU1hcChydWxlTWFwKSB7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIHNldFByZWNlZGVuY2UocHJlY2VkZW5jZSkge1xuICAgIHRoaXMucHJlY2VkZW5jZSA9IHByZWNlZGVuY2U7XG4gIH1cblxuICBzZXRTdGFydE9mQ29udGVudChzdGFydE9mQ29udGVudCkge1xuICAgIHRoaXMuc3RhcnRPZkNvbnRlbnQgPSBzdGFydE9mQ29udGVudDtcbiAgfVxuXG4gIGdldFNhdmVkUHJlY2VkZW5jZSgpIHtcbiAgICBjb25zdCBzYXZlZFByZWNlZGVuY2UgPSB0aGlzLnByZWNlZGVuY2U7XG5cbiAgICByZXR1cm4gc2F2ZWRQcmVjZWRlbmNlO1xuICB9XG5cbiAgZ2V0U2F2ZWRJbmRleCgpIHtcbiAgICBjb25zdCBzYXZlZEluZGV4ID0gdGhpcy5pbmRleDsgLy8vXG4gIFxuICAgIHJldHVybiBzYXZlZEluZGV4O1xuICB9XG5cbiAgZ2V0TmV4dFRva2VuKCkge1xuICAgIGxldCBuZXh0VG9rZW4gPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgICAgIG5leHRUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXgrK107XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRUb2tlbjtcbiAgfVxuXG4gIGlzQXRTdGFydE9mQ29udGVudCgpIHtcbiAgICBjb25zdCBhdFN0YXJ0T2ZDb250ZW50ID0gdGhpcy5zdGFydE9mQ29udGVudCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pbmRleCA9PT0gMCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuXG4gICAgcmV0dXJuIGF0U3RhcnRPZkNvbnRlbnQ7XG4gIH1cblxuICBnZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpIHtcblx0XHRsZXQgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBudWxsO1xuXG4gIFx0Y29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgXHRcdGNvbnN0IHRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5pbmRleCsrXSxcblx0XHRcdFx0XHRcdHRva2VuU2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgXHRcdGlmICh0b2tlblNpZ25pZmljYW50KSB7XG4gIFx0XHQgIGNvbnN0IHNpZ25pZmljYW50VG9rZW4gPSB0b2tlbjsgLy8vXG5cblx0XHRcdFx0bmV4dFNpZ25pZmljYW50VG9rZW4gPSBzaWduaWZpY2FudFRva2VuO1x0Ly8vXG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG4gIFx0fVxuXG5cdFx0cmV0dXJuIG5leHRTaWduaWZpY2FudFRva2VuO1xuICB9XG5cbiAgaXNOZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4oKSB7XG4gICAgbGV0IG5leHRUb2tlbldoaXRlc3BhY2VUb2tlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXhdO1xuXG4gICAgICBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBuZXh0VG9rZW4uaXNXaGl0ZXNwYWNlVG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRva2VuV2hpdGVzcGFjZVRva2VuO1xuICB9XG5cblx0YmFja3RyYWNrKHNhdmVkSW5kZXgpIHtcblx0XHR0aGlzLmluZGV4ID0gc2F2ZWRJbmRleDsgIC8vL1xuXHR9XG5cbiAgcmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSkge1xuICAgIHRoaXMucHJlY2VkZW5jZSA9IHNhdmVkUHJlY2VkZW5jZTsgIC8vL1xuICB9XG5cbiAgTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gT2JqZWN0Lmhhc093bih0aGlzLk5vblRlcm1pbmFsTm9kZU1hcCwgcnVsZU5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTm9uVGVybWluYWxOb2RlTWFwW3J1bGVOYW1lXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRva2Vuc1J1bGVNYXBTdGFydE9mQ29udGVudE5vblRlcm1pbmFsTm9kZU1hcEFuZERlZmF1bHROb25UZXJtaW5hbE5vZGUodG9rZW5zLCBydWxlTWFwLCBzdGFydE9mQ29udGVudCwgTm9uVGVybWluYWxOb2RlTWFwLCBkZWZhdWx0Tm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgaW5kZXggPSAwLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuXHRcdFx0XHRcdHN0YXRlID0gbmV3IFN0YXRlKGluZGV4LCB0b2tlbnMsIHJ1bGVNYXAsIHByZWNlZGVuY2UsIHN0YXJ0T2ZDb250ZW50LCBOb25UZXJtaW5hbE5vZGVNYXAsIGRlZmF1bHROb25UZXJtaW5hbE5vZGUpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5mdW5jdGlvbiBwYXJzZSh0b2tlbnMsIHJ1bGUgPSB0aGlzLnN0YXJ0UnVsZSwgc3RhcnRPZkNvbnRlbnQgPSB0cnVlKSB7XG4gIGxldCBub2RlID0gbnVsbDtcblxuICBjb25zdCBub2RlcyA9IFtdLFxuICAgICAgICB7IE5vblRlcm1pbmFsTm9kZU1hcCwgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgc3RhdGUgPSBTdGF0ZS5mcm9tVG9rZW5zUnVsZU1hcFN0YXJ0T2ZDb250ZW50Tm9uVGVybWluYWxOb2RlTWFwQW5kRGVmYXVsdE5vblRlcm1pbmFsTm9kZSh0b2tlbnMsIHRoaXMucnVsZU1hcCwgc3RhcnRPZkNvbnRlbnQsIE5vblRlcm1pbmFsTm9kZU1hcCwgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSksXG4gICAgICAgIGNhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY2FsbEFoZWFkID0gbnVsbCxcbiAgICAgICAgcGFyc2VkID0gcnVsZS5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gIGlmIChwYXJzZWQpIHtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBmaXJzdChub2Rlcyk7XG5cbiAgICBub2RlID0gZmlyc3ROb2RlOyAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5jb25zdCBwYXJzZXJNaXhpbnMgPSB7XG4gIHBhcnNlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZXJNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5jb25zdCB7IG5hbWVUeXBlIH0gPSB0eXBlcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmFtZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gbmFtZVR5cGUsICAvLy9cbiAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBuYW1lRGVmaW5pdGlvbiA9IG5ldyBOYW1lRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gbmFtZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9uYW1lXCI7XG5cbmltcG9ydCB7IE5BTUVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZURlZmluaXRpb24gPSBOYW1lRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBOQU1FX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG5hbWVSdWxlID0gbmV3IE5hbWVCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBuYW1lUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFFVQU5USUZJRVJfUlVMRV9OQU1FLCBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUVVBTlRJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBxdWFudGlmaWVyUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFRFUk1JTkFMX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgdGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocXVhbnRpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IG5ldyBUZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gdGVybWluYWxQYXJ0UnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBaZXJvT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiO1xuXG5pbXBvcnQgeyBRVUFOVElGSUVSX1JVTEVfTkFNRSwgTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgcnVsZU5hbWUgPSBRVUFOVElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHF1YW50aWZpZXJSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocXVhbnRpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IG5ldyBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG4gICAgXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWxcIjtcbmltcG9ydCBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9wYXJ0UnVsZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBQQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBQQVJUX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uID0gVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IE5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBwYXJ0UnVsZSA9IG5ldyBQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcGFydFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmltcG9ydCB7IE5BTUVfUlVMRV9OQU1FLCBERUZJTklUSU9OU19SVUxFX05BTUUsIE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHNlcGFyYXRvciwgdGVybWluYXRvciB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBjb25zdCBzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCA9IHNlcGFyYXRvciwgLy8vXG4gICAgICAgICAgdGVybWluYXRvclN0cmluZ0xpdGVyYWxDb250ZW50ID0gdGVybWluYXRvcjsgLy8vXG5cbiAgICBydWxlTmFtZSA9IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgb3BhY2l0eU1vZGlmaWVyUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IE5BTUVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgbmFtZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsT3BhY2l0eVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KG9wYWNpdHlNb2RpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCk7XG5cbiAgICBydWxlTmFtZSA9IERFRklOSVRJT05TX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IGRlZmluaXRpb25zUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgdGVybWluYXRvclN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQodGVybWluYXRvclN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbE9wYWNpdHlSdWxlTmFtZVBhcnRQYXJ0LFxuICAgICAgICAgICAgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICAgICAgICBkZWZpbml0aW9uc1J1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIHRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgcnVsZURlZmluaXRpb24gPSBuZXcgUnVsZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHJ1bGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcnVsZVwiO1xuXG5pbXBvcnQgeyBSVUxFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHJ1bGVEZWZpbml0aW9uID0gUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gUlVMRV9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlUnVsZSA9IG5ldyBSdWxlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZVJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBXaWxkY2FyZFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCB3aWxkY2FyZFBhcnQgPSBXaWxkY2FyZFBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHdpbGRjYXJkUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgZXJyb3JEZWZpbml0aW9uID0gbmV3IEVycm9yRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZXJyb3JEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IEVycm9yRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9lcnJvclwiO1xuXG5pbXBvcnQgeyBFUlJPUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgb3BhcXVlIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlcnJvckRlZmluaXRpb24gPSBFcnJvckRlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gRVJST1JfUlVMRV9OQU1FLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gb3BhcXVlLCAvLy9cbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVycm9yRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXJyb3JSdWxlID0gbmV3IEVycm9yQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZXJyb3JSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbERlZmluaXRpb24gPSBuZXcgU3RyaW5nTGl0ZXJhbERlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3N0cmluZ0xpdGVyYWxcIjtcblxuaW1wb3J0IHsgRVBTSUxPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25CTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZXBzaWxvbiwgLy8vXG4gICAgICAgICAgZXBzaWxvblN0cmluZ0xpdGVyYWxEZWZpbml0aW9uID0gU3RyaW5nTGl0ZXJhbERlZmluaXRpb24uZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgbmFtZSA9IEVQU0lMT05fUlVMRV9OQU1FLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVwc2lsb25TdHJpbmdMaXRlcmFsRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXBzaWxvblJ1bGUgPSBuZXcgRXBzaWxvbkJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUGFydENob2ljZSBmcm9tIFwiLi4vcGFydENob2ljZVwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IENob2ljZU9mUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL2Nob2ljZU9mUGFydHNcIjtcbmltcG9ydCBPbmVPck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIjtcblxuaW1wb3J0IHsgUlVMRV9SVUxFX05BTUUsIEVSUk9SX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBydWxlTmFtZSA9IFJVTEVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcnVsZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBFUlJPUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBlcnJvclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHJ1bGVSdWxlTmFtZVBhcnRDaG9pY2UgPSBQYXJ0Q2hvaWNlLmZyb21QYXJ0KHJ1bGVSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIGVycm9yUnVsZU5hbWVQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChlcnJvclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydENob2ljZXMgPSBbXG4gICAgICAgICAgICBydWxlUnVsZU5hbWVQYXJ0Q2hvaWNlLFxuICAgICAgICAgICAgZXJyb3JSdWxlTmFtZVBhcnRDaG9pY2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZU9mUnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzUGFydCA9IENob2ljZU9mUGFydHNQYXJ0LmZyb21QYXJ0Q2hvaWNlcyhwYXJ0Q2hvaWNlcyksXG4gICAgICAgICAgb25lT3JNb3JlQ2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0c1BhcnQgPSBPbmVPck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQoY2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9uZU9yTW9yZUNob2ljZU9mUnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkb2N1bWVudERlZmluaXRpb24gPSBuZXcgRG9jdW1lbnREZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkb2N1bWVudERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEb2N1bWVudERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZG9jdW1lbnRcIjtcblxuaW1wb3J0IHsgRE9DVU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGRvY3VtZW50RGVmaW5pdGlvbiA9IERvY3VtZW50RGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBET0NVTUVOVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGRvY3VtZW50RGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZG9jdW1lbnRSdWxlID0gbmV3IERvY3VtZW50Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZG9jdW1lbnRSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgTmFtZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vbmFtZVwiO1xuXG5pbXBvcnQgeyBSVUxFX05BTUVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWVEZWZpbml0aW9uID0gTmFtZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gUlVMRV9OQU1FX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb24gIC8vL1xuICAgICAgICAgIF0sXG4gICAgICAgICAgcnVsZU5hbWVSdWxlID0gbmV3IFJ1bGVOYW1lQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3N0cmluZ0xpdGVyYWxcIjtcblxuaW1wb3J0IHsgV0lMRENBUkRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHdpbGRjYXJkIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lsZGNhcmRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gd2lsZGNhcmQsIC8vL1xuICAgICAgICAgIHdpbGRjYXJkU3RyaW5nTGl0ZXJhbERlZmluaXRpb24gPSBTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbi5mcm9tQ29udGVudChjb250ZW50KSxcbiAgICAgICAgICBuYW1lID0gV0lMRENBUkRfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICB3aWxkY2FyZFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICB3aWxkY2FyZFJ1bGUgPSBuZXcgV2lsZGNhcmRCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiB3aWxkY2FyZFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBFTkRfT0ZfTElORV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZW5kT2ZMaW5lIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgY29udGVudCA9IGVuZE9mTGluZSxcbiAgICAgICAgICBlbmRPZkxpbmVTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbiA9IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uLmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIG5hbWUgPSBFTkRfT0ZfTElORV9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZW5kT2ZMaW5lU3RyaW5nTGl0ZXJhbERlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGVuZE9mTGluZVJ1bGUgPSBuZXcgRW5kT2ZMaW5lQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydENob2ljZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KHByZWNlZGVuY2VSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uID0gbmV3IFBhcnRDaG9pY2VEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJ0Q2hvaWNlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFBhcnRDaG9pY2VEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3BhcnRDaG9pY2VcIjtcblxuaW1wb3J0IHsgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0Q2hvaWNlQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uID0gUGFydENob2ljZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZpbml0aW9uUnVsZSA9IG5ldyBQYXJ0Q2hvaWNlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvblJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICBjb25zdCBydWxlTmFtZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBSdWxlTmFtZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHJ1bGVOYW1lRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFJ1bGVOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ydWxlTmFtZVwiO1xuXG5pbXBvcnQgeyBRVUFOVElGSUVSX1JVTEVfTkFNRSwgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG4gICAgY29uc3QgbmFtZSA9IFFVQU5USUZJRVJfUlVMRV9OQU1FOyAgLy8vXG5cbiAgICBydWxlTmFtZSA9IE9QVElPTkFMX1FVQU5USUZJRVJfUlVMRV9OQU1FXG5cbiAgICBjb25zdCBvcHRpb25hbFF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBvcHRpb25hbFF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHF1YW50aWZpZXJSdWxlID0gbmV3IFF1YW50aWZpZXJCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBxdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkRlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9uZU9yTW9yZVJ1bGVOYW1lUGFydHNQYXJ0ID0gT25lT3JNb3JlUGFydHNQYXJ0LmZyb21QYXJ0KHBhcnRSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KHByZWNlZGVuY2VSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgb25lT3JNb3JlUnVsZU5hbWVQYXJ0c1BhcnQsXG4gICAgICAgICAgICBvcHRpb25hbFByZWNlZGVuY2VSdWxlTmFtZVBhcnRQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9uRGVmaW5pdGlvbiA9IG5ldyBEZWZpbml0aW9uRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbkRlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEZWZpbml0aW9uRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9kZWZpbml0aW9uXCI7XG5cbmltcG9ydCB7IERFRklOSVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IERFRklOSVRJT05fUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgZGVmaW5pdGlvbkRlZmluaXRpb24gPSBEZWZpbml0aW9uRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvbkRlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlZmluaXRpb25SdWxlID0gbmV3IERlZmluaXRpb25CTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB0eXBlcywgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmNvbnN0IHsgbnVtYmVyVHlwZSB9ID0gdHlwZXMsXG4gICAgICB7IG9wZW5CcmFja2V0LCBjbG9zZUJyYWNrZXQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVjZWRlbmNlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBudW1iZXJUeXBlLCAgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQpLFxuICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQpLFxuICAgICAgICAgIG51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydCA9IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydC5mcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpLFxuICAgICAgICAgIG9wdGlvbmFsTnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQobnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbE51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydFBhcnQsXG4gICAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgcHJlY2VkZW5jZURlZmluaXRpb24gPSBuZXcgUHJlY2VkZW5jZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHByZWNlZGVuY2VEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUHJlY2VkZW5jZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcHJlY2VkZW5jZVwiO1xuXG5pbXBvcnQgeyBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlY2VkZW5jZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBQUkVDRURFTkNFX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHByZWNlZGVuY2VEZWZpbml0aW9uID0gUHJlY2VkZW5jZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHByZWNlZGVuY2VEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlUnVsZSA9IG5ldyBQcmVjZWRlbmNlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcHJlY2VkZW5jZVJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIjtcblxuaW1wb3J0IHsgREVGSU5JVElPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgdmVydGljYWxCYXIgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uc0RlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBwYXJ0cztcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lID0gREVGSU5JVElPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZGVmaW5pdGlvblJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KTtcblxuICAgIHBhcnRzID0gW1xuICAgICAgdmVydGljYWxCYXJTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgIGRlZmluaXRpb25SdWxlTmFtZVBhcnRcbiAgICBdO1xuXG4gICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRzKHBhcnRzKSxcbiAgICAgICAgICB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQoc2VxdWVuY2VPZlBhcnRzUGFydCk7XG5cbiAgICBwYXJ0cyA9IFtcbiAgICAgIGRlZmluaXRpb25SdWxlTmFtZVBhcnQsXG4gICAgICB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydFxuICAgIF07XG5cbiAgICBjb25zdCBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9uc0RlZmluaXRpb24gPSBuZXcgRGVmaW5pdGlvbnNEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uc0RlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEZWZpbml0aW9uc0RlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZGVmaW5pdGlvbnNcIjtcblxuaW1wb3J0IHsgREVGSU5JVElPTlNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uc0JORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGRlZmluaXRpb25zRGVmaW5pdGlvbiA9IERlZmluaXRpb25zRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBERUZJTklUSU9OU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvbnNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZpbml0aW9uc1J1bGUgPSBuZXcgRGVmaW5pdGlvbnNCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uc1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBSdWxlTmFtZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcnVsZU5hbWVcIjtcblxuaW1wb3J0IHsgRVBTSUxPTl9SVUxFX05BTUUsXG4gICAgICAgICBXSUxEQ0FSRF9SVUxFX05BTUUsXG4gICAgICAgICBFTkRfT0ZfTElORV9SVUxFX05BTUUsXG4gICAgICAgICBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFNUUklOR19MSVRFUkFMX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFNJR05JRklDQU5UX1RPS0VOX1RZUEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtaW5hbFBhcnRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBjb25zdCBuYW1lID0gVEVSTUlOQUxfUEFSVF9SVUxFX05BTUU7XG5cbiAgICBydWxlTmFtZSA9IEVQU0lMT05fUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgZXBzaWxvblJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBXSUxEQ0FSRF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCB3aWxkY2FyZFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBFTkRfT0ZfTElORV9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBlbmRPZkxpbmVSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgc3RyaW5nTGl0ZXJhbFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgbm9XaGl0ZXNwYWNlUGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcmVndWxhckV4cHJlc3Npb25SdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGVuZE9mTGluZVJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHdpbGRjYXJkUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgZXBzaWxvblJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnRSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGUgPSBuZXcgVGVybWluYWxQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIjtcblxuaW1wb3J0IHsgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHZlcnRpY2FsQmFyLCBvcGVuQnJhY2tldCwgY2xvc2VCcmFja2V0IH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBwYXJ0cztcblxuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSVF9DSE9JQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbENvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgcGFydENob2ljZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudCh2ZXJ0aWNhbEJhclN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQob3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCksXG4gICAgICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCk7XG5cbiAgICBwYXJ0cyA9IFtcbiAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICBwYXJ0Q2hvaWNlUnVsZU5hbWVQYXJ0XG4gICAgXTtcblxuICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBTZXF1ZW5jZU9mUGFydHNQYXJ0LmZyb21QYXJ0cyhwYXJ0cyksXG4gICAgICAgICAgb25lT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IE9uZU9yTW9yZVBhcnRzUGFydC5mcm9tUGFydChzZXF1ZW5jZU9mUGFydHNQYXJ0KTtcblxuICAgIHBhcnRzID0gW1xuICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgIHBhcnRDaG9pY2VSdWxlTmFtZVBhcnQsXG4gICAgICBvbmVPck1vcmVTZXF1ZW5jZU9mUGFydHNQYXJ0LFxuICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnRcbiAgICBdO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgY2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gPSBuZXcgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIGNob2ljZU9mUGFydHNEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vY2hvaWNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IENIT0lDRV9PRl9QQVJUU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIGNob2ljZU9mUGFydHNEZWZpbml0aW9uID0gQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNob2ljZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjaG9pY2VPZlBhcnRzUnVsZSA9IG5ldyBDaG9pY2VPZlBhcnRzQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gY2hvaWNlT2ZQYXJ0c1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQuZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uID0gbmV3IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5pbXBvcnQgeyBTVFJJTkdfTElURVJBTF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgc3RyaW5nTGl0ZXJhbFR5cGUgfSA9IHR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBzdHJpbmdMaXRlcmFsVHlwZSwgIC8vL1xuICAgICAgICAgIHN0cmluZ0xpdGVyYWxTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzdHJpbmdMaXRlcmFsU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUnVsZSA9IG5ldyBTdHJpbmdMaXRlcmFsQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uLy4uLy4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uLy4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBPcHRpb25hbFBhcnRQYXJ0IGZyb20gXCIuLi8uLi8uLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuXG5pbXBvcnQgeyBSVUxFX05BTUVfUlVMRV9OQU1FLCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgcnVsZU5hbWUgPSBSVUxFX05BTUVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcnVsZU5hbWVSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBjYWxsQWhlYWRNb2RpZmllclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsQ2FsbEFoZWFkUnVsZU5hbWVQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQoY2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbENhbGxBaGVhZFJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSBuZXcgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFJ1bGVOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ydWxlTmFtZVwiO1xuaW1wb3J0IFJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcblxuaW1wb3J0IHsgQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRSwgU0VRVUVOQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FLCBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vblRlcm1pbmFsUGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIGNvbnN0IG5hbWUgPSBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUU7IC8vL1xuXG4gICAgcnVsZU5hbWUgPSBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUU7XG5cbiAgICBjb25zdCBzZXF1ZW5jZU9mUGFydHNSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICBydWxlTmFtZU5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uID0gUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG5vblRlcm1pbmFsUGFydFJ1bGUgPSBuZXcgTm9uVGVybWluYWxQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IG9wZW5CcmFja2V0LCBjbG9zZUJyYWNrZXQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUlRfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBvbmVPck1vcmVQYXJ0UnVsZU5hbWVQYXJ0c1BhcnQgPSBPbmVPck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocGFydFJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0LFxuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIG9uZU9yTW9yZVBhcnRSdWxlTmFtZVBhcnRzUGFydCxcbiAgICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24gPSBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNSdWxlID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNlcXVlbmNlT2ZQYXJ0c1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUGFydENob2ljZSBmcm9tIFwiLi4vcGFydENob2ljZVwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3N0cmluZ0xpdGVyYWxcIjtcblxuY29uc3QgeyBvcGFxdWUsIHNlbWlPcGFxdWUgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG5cbiAgICBjb250ZW50ID0gb3BhcXVlOyAvLy9cblxuICAgIGNvbnN0IG9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCk7XG5cbiAgICBjb250ZW50ID0gc2VtaU9wYXF1ZTsgLy8vXG5cbiAgICBjb25zdCBzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KTtcblxuICAgIGNvbnN0IG9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChvcGFxdWVTdHJpbmdMaXRlcmFsUGFydCksXG4gICAgICAgICAgc2VtaU9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnQpLFxuICAgICAgICAgIHBhcnRDaG9pY2VzID0gW1xuICAgICAgICAgICAgb3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnRDaG9pY2UsXG4gICAgICAgICAgICBzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnRDaG9pY2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZU9mT3BhcXVlU3RyaW5nTGl0ZXJhbEFuZFNlbWlPcGFxdWVTdHJpbmdMaXRlcmFsUGFydHNQYXJ0ID0gQ2hvaWNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRDaG9pY2VzKHBhcnRDaG9pY2VzKSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0ID0gTm9XaGl0ZXNwYWNlUGFydC5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCxcbiAgICAgICAgICAgIGNob2ljZU9mT3BhcXVlU3RyaW5nTGl0ZXJhbEFuZFNlbWlPcGFxdWVTdHJpbmdMaXRlcmFsUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gb3BhY2l0eU1vZGlmaWVyUnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9vcGFjaXR5TW9kaWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHlNb2RpZmllclJ1bGVEZWZpbml0aW9uID0gT3BhY2l0eU1vZGlmaWVyUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG9wYWNpdHlNb2RpZmllclJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJSdWxlID0gbmV3IE9wYWNpdHlNb2RpZmllckJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIG9wYWNpdHlNb2RpZmllclJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5jb25zdCB7IG5vV2hpdGVzcGFjZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gbm9XaGl0ZXNwYWNlLCAgLy8vXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiA9IG5ldyBOb1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5cbmltcG9ydCB7IE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiA9IE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgbmFtZSA9IE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0UnVsZSA9IG5ldyBOb1doaXRlc3BhY2VQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmNvbnN0IHsgZWxsaXBzaXMgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsQWhlYWRNb2RpZmllclJ1bGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZWxsaXBzaXMsICAvLy9cbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0ID0gTm9XaGl0ZXNwYWNlUGFydC5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0LFxuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gPSBuZXcgQ2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gY2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IENhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vY2FsbEFoZWFkTW9kaWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsQWhlYWRNb2RpZmllckJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSwgLy8vXG4gICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IENhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZSA9IG5ldyBDYWxsQWhlYWRNb2RpZmllckJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGNhbGxBaGVhZE1vZGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuaW1wb3J0IHsgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyByZWd1bGFyRXhwcmVzc2lvblR5cGUgfSA9IHR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWd1bGFyRXhwcmVzc2lvbkJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gcmVndWxhckV4cHJlc3Npb25UeXBlLCAgLy8vXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25TaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSwgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvblNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25SdWxlID0gbmV3IFJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVNwZWNpYWxTeW1ib2woc3BlY2lhbFN5bWJvbCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzcGVjaWFsU3ltYm9sLCAgLy8vXG4gICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCA9IE5vV2hpdGVzcGFjZVBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCxcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBxdWFudGlmaWVyUnVsZURlZmluaXRpb24gPSBuZXcgUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBxdWFudGlmaWVyUnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3F1YW50aWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IE9QVElPTkFMX1FVQU5USUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHF1ZXN0aW9uTWFyayB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbmFsUXVhbnRpZmllckJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHNwZWNpYWxTeW1ib2wgPSBxdWVzdGlvbk1hcmssIC8vL1xuICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uLmZyb21TcGVjaWFsU3ltYm9sKHNwZWNpYWxTeW1ib2wpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGUgPSBuZXcgT3B0aW9uYWxRdWFudGlmaWVyQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gb3B0aW9uYWxRdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmNvbnN0IHsgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFydE9mQ29udGVudFBhcnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gc3RhcnRPZkNvbnRlbnQsICAvLy9cbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gPSBuZXcgU3RhcnRPZkNvbnRlbnRQYXJ0RGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0RGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc3RhcnRPZkNvbnRlbnRQYXJ0XCI7XG5cbmltcG9ydCB7IFNUQVJUX09GX0NPTlRFTlRfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50UGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gPSBTdGFydE9mQ29udGVudFBhcnREZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgbmFtZSA9IFNUQVJUX09GX0NPTlRFTlRfUEFSVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydFJ1bGUgPSBuZXcgU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIjtcblxuaW1wb3J0IHsgT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgcGx1cyB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIHNwZWNpYWxTeW1ib2wgPSBwbHVzLCAvLy9cbiAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb24gPSBRdWFudGlmaWVyUnVsZURlZmluaXRpb24uZnJvbVNwZWNpYWxTeW1ib2woc3BlY2lhbFN5bWJvbCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IE9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBvbmVPck1vcmVRdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIjtcblxuaW1wb3J0IHsgWkVST19PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IGFzdGVyaXNrIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWmVyb09yTW9yZVF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gWkVST19PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgc3BlY2lhbFN5bWJvbCA9IGFzdGVyaXNrLCAvLy9cbiAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uLmZyb21TcGVjaWFsU3ltYm9sKHNwZWNpYWxTeW1ib2wpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gemVyb09yTW9yZVF1YW50aWZpZXJSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5pbXBvcnQgeyBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyB0eXBlVHlwZSB9ID0gdHlwZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW5UeXBlQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0eXBlVHlwZSwgIC8vL1xuICAgICAgICAgIHR5cGVTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gU0lHTklGSUNBTlRfVE9LRU5fVFlQRV9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHR5cGVTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSA9IG5ldyBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCwgcHJ1bmUgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0FzU3RyaW5nKHJ1bGVzLCBtdWx0aUxpbmUpIHtcbiAgY29uc3QgbWF4aW11bVJ1bGVOYW1lTGVuZ3RoID0gcnVsZXMucmVkdWNlKChtYXhpbXVtUnVsZU5hbWVMZW5ndGgsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpO1xuXG4gICAgICAgIGxldCBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aDtcblxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG9wYWNpdHlMZW5ndGggPSBvcGFjaXR5Lmxlbmd0aDtcblxuICAgICAgICAgIHJ1bGVOYW1lTGVuZ3RoICs9IG9wYWNpdHlMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBtYXhpbXVtUnVsZU5hbWVMZW5ndGggPSBNYXRoLm1heChtYXhpbXVtUnVsZU5hbWVMZW5ndGgsIHJ1bGVOYW1lTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gbWF4aW11bVJ1bGVOYW1lTGVuZ3RoO1xuICAgICAgfSwgMCksXG4gICAgICBydWxlc1N0cmluZyA9IHJ1bGVzLnJlZHVjZSgocnVsZXNTdHJpbmcsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcnVsZVN0cmluZyA9IHJ1bGUuYXNTdHJpbmcobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBtdWx0aUxpbmUpO1xuXG4gICAgICAgIHJ1bGVzU3RyaW5nICs9IHJ1bGVTdHJpbmc7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzU3RyaW5nO1xuICAgICAgfSwgRU1QVFlfU1RSSU5HKS5yZXBsYWNlKC9eXFxuXFxuLywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcnVsZXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSB7XG4gIGNvbnN0IHJ1bGVNYXAgPSB7fTtcblxuICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKTtcblxuICAgIHJ1bGVNYXBbcnVsZU5hbWVdID0gcnVsZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVNYXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpIHtcbiAgY29uc3QgZmlyc3RSdWxlID0gZmlyc3QocnVsZXMpLFxuICAgICAgICBzdGFydFJ1bGUgPSBmaXJzdFJ1bGU7ICAvLy9cblxuICByZXR1cm4gc3RhcnRSdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcChzdGFydFJ1bGUsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZXMgPSBPYmplY3QudmFsdWVzKHJ1bGVNYXApLFxuICAgICAgICBzdGFydFJ1bGVOYW1lID0gc3RhcnRSdWxlLmdldE5hbWUoKTtcblxuICBzdGFydFJ1bGUgPSBwcnVuZShydWxlcywgKHJ1bGUpID0+IHsgIC8vL1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBpZiAocnVsZU5hbWUgIT09IHN0YXJ0UnVsZU5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZXMudW5zaGlmdChzdGFydFJ1bGUpO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUocnVsZXMsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgbGV0IHN0YXJ0UnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHtcbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgaWYgKHJ1bGVOYW1lID09PSBzdGFydFJ1bGVOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIHx8IG51bGw7IC8vL1xuXG4gIGlmIChzdGFydFJ1bGUgPT09IG51bGwpIHtcbiAgICBzdGFydFJ1bGUgPSBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0UnVsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0FzU3RyaW5nLFxuICBydWxlTWFwRnJvbVJ1bGVzLFxuICBzdGFydFJ1bGVGcm9tUnVsZXMsXG4gIHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAsXG4gIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vcnVsZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZU1hcCBmcm9tIFwiLi4vbm9uVGVybWluYWxOb2RlTWFwXCI7XG5pbXBvcnQgcGFyc2VyTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvcGFyc2VyXCI7XG5pbXBvcnQgTmFtZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL25hbWVcIjtcbmltcG9ydCBQYXJ0Qk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcGFydFwiO1xuaW1wb3J0IFJ1bGVCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9ydWxlXCI7XG5pbXBvcnQgRXJyb3JCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9lcnJvclwiO1xuaW1wb3J0IEVwc2lsb25CTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9lcHNpbG9uXCI7XG5pbXBvcnQgRG9jdW1lbnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9kb2N1bWVudFwiO1xuaW1wb3J0IFJ1bGVOYW1lQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcnVsZU5hbWVcIjtcbmltcG9ydCBXaWxkY2FyZEJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3dpbGRjYXJkXCI7XG5pbXBvcnQgRW5kT2ZMaW5lQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgUGFydENob2ljZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3BhcnRDaG9pY2VcIjtcbmltcG9ydCBRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcXVhbnRpZmllclwiO1xuaW1wb3J0IERlZmluaXRpb25CTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUHJlY2VkZW50c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3ByZWNlZGVuY2VcIjtcbmltcG9ydCBEZWZpbml0aW9uc0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL2RlZmluaXRpb25zXCI7XG5pbXBvcnQgVGVybWluYWxQYXJ0Qk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvdGVybWluYWxQYXJ0XCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL2Nob2ljZU9mUGFydHNcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IE5vblRlcm1pbmFsUGFydEJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL25vblRlcm1pbmFsUGFydFwiO1xuaW1wb3J0IFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuaW1wb3J0IE9wYWNpdHlNb2RpZmllckJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL29wYWNpdHlNb2RpZmllclwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5pbXBvcnQgQ2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9jYWxsQWhlYWRNb2RpZmllclwiO1xuaW1wb3J0IFJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcmVndWxhckV4cHJlc3Npb25cIjtcbmltcG9ydCBPcHRpb25hbFF1YW50aWZpZXJCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9vcHRpb25hbFF1YW50aWZpZXJcIjtcbmltcG9ydCBTdGFydE9mQ29udGVudFBhcnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9zdGFydE9mQ29udGVudFBhcnRcIjtcbmltcG9ydCBPbmVPck1vcmVRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvb25lT3JNb3JlUXVhbnRpZmllclwiO1xuaW1wb3J0IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvemVyb09yTW9yZVF1YW50aWZpZXJcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmltcG9ydCB7IHJ1bGVNYXBGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQk5GUGFyc2VyIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIGdldFN0YXJ0UnVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gIH1cblxuICBnZXRSdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gIH1cblxuXHRydWxlc0Zyb21Ub2tlbnModG9rZW5zKSB7XG5cdCAgbGV0IHJ1bGVzO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2UodG9rZW5zKTtcblxuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUuYCk7XG4gICAgfVxuXG4gICAgcnVsZXMgPSBub2RlLmdlbmVyYXRlUnVsZXMoUnVsZSk7XG5cbiAgICBjb25zdCBydWxlc0xlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcblxuICAgIGlmIChydWxlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBhcmUgbm8gcnVsZXMuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgc3RhdGljIE5vblRlcm1pbmFsTm9kZU1hcCA9IE5vblRlcm1pbmFsTm9kZU1hcDtcblxuICBzdGF0aWMgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSA9IG51bGw7XG5cbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZUJORlJ1bGUgPSBOYW1lQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnRCTkZSdWxlID0gUGFydEJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBydWxlQk5GUnVsZSA9IFJ1bGVCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgZXJyb3JCTkZSdWxlID0gRXJyb3JCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgZXBzaWxvbkJORlJ1bGUgPSBFcHNpbG9uQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGRvY3VtZW50Qk5GUnVsZSA9IERvY3VtZW50Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHJ1bGVOYW1lQk5GUnVsZSA9IFJ1bGVOYW1lQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHdpbGRjYXJkQk5GUnVsZSA9IFdpbGRjYXJkQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGVuZE9mTGluZUJORlJ1bGUgPSBFbmRPZkxpbmVCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFydENob2ljZUJORlJ1bGUgPSBQYXJ0Q2hvaWNlQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHF1YW50aWZpZXJCTkZSdWxlID0gUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBkZWZpbml0aW9uQk5GUnVsZSA9IERlZmluaXRpb25CTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcHJlY2VkZW50c0JORlJ1bGUgPSBQcmVjZWRlbnRzQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGRlZmluaXRpb25zQk5GUnVsZSA9IERlZmluaXRpb25zQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHRlcm1pbmFsUGFydEJORlJ1bGUgPSBUZXJtaW5hbFBhcnRCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgY2hvaWNlT2ZQYXJ0c0JORlJ1bGUgPSBDaG9pY2VPZlBhcnRzQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZ0xpdGVyYWxCTkZSdWxlID0gU3RyaW5nTGl0ZXJhbEJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRCTkZSdWxlID0gTm9uVGVybWluYWxQYXJ0Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgPSBTZXF1ZW5jZU9mUGFydHNCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eU1vZGlmaWVyQk5GUnVsZSA9IE9wYWNpdHlNb2RpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0Qk5GUnVsZSA9IE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25CTkZSdWxlID0gUmVndWxhckV4cHJlc3Npb25CTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlID0gQ2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyQk5GUnVsZSA9IE9wdGlvbmFsUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRCTkZSdWxlID0gU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlID0gT25lT3JNb3JlUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUgPSBaZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBydWxlcyA9IFtcbiAgICAgICAgICAgIGRvY3VtZW50Qk5GUnVsZSxcbiAgICAgICAgICAgIHJ1bGVCTkZSdWxlLFxuICAgICAgICAgICAgbmFtZUJORlJ1bGUsXG4gICAgICAgICAgICBkZWZpbml0aW9uc0JORlJ1bGUsXG4gICAgICAgICAgICBkZWZpbml0aW9uQk5GUnVsZSxcbiAgICAgICAgICAgIHBhcnRCTkZSdWxlLFxuICAgICAgICAgICAgbm9uVGVybWluYWxQYXJ0Qk5GUnVsZSxcbiAgICAgICAgICAgIHRlcm1pbmFsUGFydEJORlJ1bGUsXG4gICAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRCTkZSdWxlLFxuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydEJORlJ1bGUsXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNCTkZSdWxlLFxuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c0JORlJ1bGUsXG4gICAgICAgICAgICBwYXJ0Q2hvaWNlQk5GUnVsZSxcbiAgICAgICAgICAgIHJ1bGVOYW1lQk5GUnVsZSxcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlQk5GUnVsZSxcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZSxcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxCTkZSdWxlLFxuICAgICAgICAgICAgcHJlY2VkZW50c0JORlJ1bGUsXG4gICAgICAgICAgICBlbmRPZkxpbmVCTkZSdWxlLFxuICAgICAgICAgICAgd2lsZGNhcmRCTkZSdWxlLFxuICAgICAgICAgICAgZXBzaWxvbkJORlJ1bGUsXG4gICAgICAgICAgICBxdWFudGlmaWVyQk5GUnVsZSxcbiAgICAgICAgICAgIG9wYWNpdHlNb2RpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBjYWxsQWhlYWRNb2RpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBvcHRpb25hbFF1YW50aWZpZXJCTkZSdWxlLFxuICAgICAgICAgICAgb25lT3JNb3JlUXVhbnRpZmllckJORlJ1bGUsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBlcnJvckJORlJ1bGVcbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXJ0UnVsZSA9IHN0YXJ0UnVsZUZyb21SdWxlcyhydWxlcyksXG4gICAgICAgICAgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICAgIGJuZlBhcnNlciA9IG5ldyBCTkZQYXJzZXIoc3RhcnRSdWxlLCBydWxlTWFwKTtcbiAgICBcbiAgICByZXR1cm4gYm5mUGFyc2VyO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oQk5GUGFyc2VyLnByb3RvdHlwZSwgcGFyc2VyTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYFxuXG4gICAgZXhwcmVzc2lvbnMgIDo6PSAgZXhwcmVzc2lvbisgO1xuXG4gICAgZXhwcmVzc2lvbiAgIDo6PSAgdGVybS4uLiBcIi5cIiA7XG4gICAgXG4gICAgdGVybSAgICAgICAgIDo6PSAgdGVybV8gdGVybX4qIDtcbiAgICBcbiAgICBvcGVyYXRvciAgICAgOjo9ICBcIitcIlxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFwiLVwiXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgXCIqXCJcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gICAgXG4gICAgbnVtYmVyICAgICAgIDo6PSAgL1xcXFxkKy8gO1xuICAgIFxuICAgIHRlcm1fICAgICAgICA6Oj0gIFwiKFwiIHRlcm0gXCIpXCJcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBudW1iZXJcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gICAgXG4gICAgdGVybX50ZXJtICAgIDo6PSAgb3BlcmF0b3IgdGVybSA7XG4gICAgXG4gICAgdGVybX4gICAgICAgIDo6PSAgdGVybX50ZXJtIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBCTkZMZXhlciB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IEJORlBhcnNlciBmcm9tIFwiLi4vYm5mL3BhcnNlclwiO1xuXG5pbXBvcnQgeyBydWxlTWFwRnJvbVJ1bGVzLCBzdGFydFJ1bGVGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVzXCI7XG5cbmNvbnN0IGJuZkxleGVyID0gQk5GTGV4ZXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgIGJuZlBhcnNlciA9IEJORlBhcnNlci5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGcm9tQk5GKGJuZikge1xuICBjb25zdCB0b2tlbnMgPSBibmZMZXhlci50b2tlbnNGcm9tQk5GKGJuZiksXG4gICAgICAgIHJ1bGVzID0gYm5mUGFyc2VyLnJ1bGVzRnJvbVRva2Vucyh0b2tlbnMpO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcbiAgY29uc3Qgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzKHJ1bGVzKSxcbiAgICAgICAgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBwYXJzZXIgPSBuZXcgQ2xhc3Moc3RhcnRSdWxlLCBydWxlTWFwKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgY29uc3Qgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShydWxlcywgc3RhcnRSdWxlTmFtZSksXG4gICAgICAgIHJ1bGVNYXAgPSBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSxcbiAgICAgICAgcGFyc2VyID0gbmV3IENsYXNzKHN0YXJ0UnVsZSwgcnVsZU1hcCk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0Zyb21CTkYsXG4gIHBhcnNlckZyb21SdWxlcyxcbiAgcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHBhcnNlck1peGlucyBmcm9tIFwiLi4vbWl4aW5zL3BhcnNlclwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IHJ1bGVzRnJvbUJORiwgcGFyc2VyRnJvbVJ1bGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJzZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tbW9uUGFyc2VyIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIGdldFN0YXJ0UnVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gIH1cblxuICBnZXRSdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gIH1cblxuICBzdGF0aWMgTm9uVGVybWluYWxOb2RlTWFwID0ge307XG5cbiAgc3RhdGljIGRlZmF1bHROb25UZXJtaW5hbE5vZGUgPSBOb25UZXJtaW5hbE5vZGU7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKENsYXNzKSB7XG4gICAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZiksXG4gICAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgc3RhdGljIGZyb21CTkYoQ2xhc3MsIGJuZikge1xuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZiksXG4gICAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICAgIHJldHVybiBwYXJzZXI7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihDb21tb25QYXJzZXIucHJvdG90eXBlLCBwYXJzZXJNaXhpbnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuaW1wb3J0IENvbW1vblBhcnNlciBmcm9tIFwiLi4vY29tbW9uL3BhcnNlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEJhc2ljUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoQmFzaWNQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKEJhc2ljUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVwc2lsb25QYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvZXBzaWxvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgV2lsZGNhcmRQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIjtcbmltcG9ydCBFbmRPZkxpbmVQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IENob2ljZU9mUGFydHNQYXJ0IGZyb20gXCIuL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IE9uZU9yTW9yZVBhcnRzUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4vcGFydC9ub25UZXJtaW5hbC96ZXJvT3JNb3JlUGFydHNcIjtcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblBhcnQgZnJvbSBcIi4vcGFydC90ZXJtaW5hbC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBmcm9tIFwiLi9wYXJ0L3Rlcm1pbmFsL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRXBzaWxvblBhcnQsXG4gIFJ1bGVOYW1lUGFydCxcbiAgV2lsZGNhcmRQYXJ0LFxuICBFbmRPZkxpbmVQYXJ0LFxuICBPcHRpb25hbFBhcnRQYXJ0LFxuICBDaG9pY2VPZlBhcnRzUGFydCxcbiAgU3RyaW5nTGl0ZXJhbFBhcnQsXG4gIE9uZU9yTW9yZVBhcnRzUGFydCxcbiAgU2VxdWVuY2VPZlBhcnRzUGFydCxcbiAgWmVyb09yTW9yZVBhcnRzUGFydCxcbiAgUmVndWxhckV4cHJlc3Npb25QYXJ0LFxuICBTaWduaWZpY2FudFRva2VuVHlwZVBhcnRcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQk5GUGFyc2VyIH0gZnJvbSBcIi4vYm5mL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNpY1BhcnNlciB9IGZyb20gXCIuL2Jhc2ljL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25QYXJzZXIgfSBmcm9tIFwiLi9jb21tb24vcGFyc2VyXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9kZU1peGlucyB9IGZyb20gXCIuL21peGlucy9ub2RlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgcnVsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcnVsZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2VyVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bGUgfSBmcm9tIFwiLi9ydWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRzIH0gZnJvbSBcIi4vcGFydHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydFR5cGVzIH0gZnJvbSBcIi4vcGFydFR5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRDaG9pY2UgfSBmcm9tIFwiLi9wYXJ0Q2hvaWNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlZmluaXRpb24gfSBmcm9tIFwiLi9kZWZpbml0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVwc2lsb25Ob2RlIH0gZnJvbSBcIi4vbm9kZS90ZXJtaW5hbC9lcHNpbG9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL25vZGUvdGVybWluYWxcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBzdHlsZXNoZWV0ICAgICAgICAgICAgICAgICA6Oj0gKCBtZWRpYSB8IHJ1bGVTZXQgfCBrZXlmcmFtZXMgfCBkZWNsYXJhdGlvbiB8IGVycm9yICkrIDtcblxuXG4gICAgbWVkaWEgICAgICAgICAgICAgICAgICAgICAgOjo9IFwiQG1lZGlhXCIgbWVkaWFRdWVyaWVzIFwie1wiICggcnVsZVNldCB8IGRlY2xhcmF0aW9uICkqIFwifVwiIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgcnVsZVNldCAgICAgICAgICAgICAgICAgICAgOjo9ICBzZWxlY3RvcnMgXCJ7XCIgZGVjbGFyYXRpb24qIFwifVwiIDtcbiAgICBcbiAgICBcbiAgICBrZXlmcmFtZXMgICAgICAgICAgICAgICAgICA6Oj0gXCJAa2V5ZnJhbWVzXCIgW2lkZW50aWZpZXJdIFwie1wiIGtleWZyYW1lKyBcIn1cIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlY2xhcmF0aW9uICAgICAgICAgICAgICAgIDo6PSAgcHJvcGVydHlOYW1lIFwiOlwiIHByb3BlcnR5VmFsdWVzIGltcG9ydGFudD8gXCI7XCIgO1xuXG5cbiAgICBlcnJvci4gICAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5cbiAgICBwcm9wZXJ0eVZhbHVlcyAgICAgICAgICAgICA6Oj0gIHByb3BlcnR5VmFsdWUgKCBcIixcIiBwcm9wZXJ0eVZhbHVlICkqIDtcblxuXG4gICAgbWVkaWFRdWVyaWVzICAgICAgICAgICAgICAgOjo9ICBtZWRpYVF1ZXJ5ICggKCBcIixcIiB8IFwib3JcIiApIG1lZGlhUXVlcnkgKSogO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgc2VsZWN0b3JzICAgICAgICAgICAgICAgICAgOjo9ICBzZWxlY3RvciAoIFwiLFwiIHNlbGVjdG9yICkqIDtcblxuXG4gICAga2V5ZnJhbWUgICAgICAgICAgICAgICAgICAgOjo9ICBbcGVyY2VudGFnZV0gXCJ7XCIgZGVjbGFyYXRpb24rIFwifVwiIDtcbiAgICBcbiAgICBcbiAgICBtZWRpYVF1ZXJ5ICAgICAgICAgICAgICAgICA6Oj0gICggXCJub3RcIj8gbWVkaWFUeXBlIFwiYW5kXCIgKT8gbWVkaWFGZWF0dXJlcyBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFwibm90XCI/IG1lZGlhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIG1lZGlhVHlwZSAgICAgICAgICAgICAgICAgIDo6PSAgXCJhbGxcIiB8IFwicHJpbnRcIiB8IFwic2NyZWVuXCIgfCBcInNwZWVjaFwiIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIG1lZGlhRmVhdHVyZXMgICAgICAgICAgICAgIDo6PSAgKCBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGZWF0dXJlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCIoXCIgXCJub3RcIiBtZWRpYUZlYXR1cmUgXCIpXCIgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmVhdHVyZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCIoXCIgXCJub3RcIiBtZWRpYUZlYXR1cmUgXCIpXCIgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBtZWRpYUZlYXR1cmUgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIFtpZGVudGlmaWVyXSAoIFwiOlwiIHByb3BlcnR5VmFsdWUgKT8gXCIpXCIgO1xuXG5cbiAgICBwcm9wZXJ0eVZhbHVlICAgICAgICAgICAgICA6Oj0gIHRlcm0gKCBcIixcIj8gdGVybSApKiA7XG5cblxuICAgIHByb3BlcnR5TmFtZSAgICAgICAgICAgICAgIDo6PSAgW2lkZW50aWZpZXJdIDtcblxuXG4gICAgaW1wb3J0YW50ICAgICAgICAgICAgICAgICAgOjo9ICBcIiFpbXBvcnRhbnRcIiA7XG5cblxuICAgIHNlbGVjdG9yICAgICAgICAgICAgICAgICAgIDo6PSAgKCBjbGFzcyB8IHBzZXVkb0NsYXNzIHwgcHNldWRvRWxlbWVudCB8IGF0dHJpYnV0ZSApKyA7XG5cblxuICAgIGNsYXNzICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCIuXCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBzZXVkb0NsYXNzICAgICAgICAgICAgICAgIDo6PSAgXCI6XCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBzZXVkb0VsZW1lbnQgICAgICAgICAgICAgIDo6PSAgXCI6OlwiPE5PX1dISVRFU1BBQ0U+W2lkZW50aWZpZXJdIHBhcmVudGhlc2lzZWRTZWxlY3Rvcj8gO1xuXG5cbiAgICBwYXJlbnRoZXNpc2VkU2VsZWN0b3IgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiKFwiIHNlbGVjdG9yIDxOT19XSElURVNQQUNFPlwiKVwiIDtcblxuXG4gICAgYXR0cmlidXRlICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCI9XCIgfCBcIn49XCIgfCBcInw9XCIgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW2lkZW50aWZpZXJdIHwgW3N0cmluZy1saXRlcmFsXSApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG4gICAgdGVybSAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBbcGx1cy1vci1taW51c10/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFtwZXJjZW50YWdlXSB8IFtmcmVxdWVuY3ldIHwgW2ZyYWN0aW9uXSB8IFtsZW5ndGhdIHwgW2FuZ2xlXSB8IFtyZW1zXSB8IFtlbXNdIHwgW3RpbWVdIHwgW251bWJlcl0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0cmluZy1saXRlcmFsXStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbG91cl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIHVyaSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJ1cmxcIjxOT19XSElURVNQQUNFPlwiKFwiIFtzdHJpbmctbGl0ZXJhbF0gXCIpXCIgO1xuXG5cbiAgICBmdW5jdGlvbiAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXTxOT19XSElURVNQQUNFPlwiKFwiIHByb3BlcnR5VmFsdWUgXCIpXCIgO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTU1BhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKENTU1BhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKENTU1BhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoQ1NTUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEVSUk9SX1JVTEVfTkFNRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBJTkRFWF9SVUxFX05BTUUgPSBcImluZGV4XCI7XG5leHBvcnQgY29uc3QgVU5JUVVFX1JVTEVfTkFNRSA9IFwidW5pcXVlXCI7XG5leHBvcnQgY29uc3QgU1BSRUFEX1JVTEVfTkFNRSA9IFwic3ByZWFkXCI7XG5leHBvcnQgY29uc3QgRU5EX0lOREVYX1JVTEVfTkFNRSA9IFwiZW5kSW5kZXhcIjtcbmV4cG9ydCBjb25zdCBSVUxFX05BTUVfUlVMRV9OQU1FID0gXCJydWxlTmFtZVwiO1xuZXhwb3J0IGNvbnN0IFRPS0VOX1RZUEVfUlVMRV9OQU1FID0gXCJ0b2tlblR5cGVcIjtcbmV4cG9ydCBjb25zdCBTVEFSVF9JTkRFWF9SVUxFX05BTUUgPSBcInN0YXJ0SW5kZXhcIjtcbmV4cG9ydCBjb25zdCBTVUJfRVhQUkVTU0lPTl9SVUxFX05BTUUgPSBcInN1YkV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBJTkZJTklURV9ERVNDRU5UX1JVTEVfTkFNRSA9IFwiaW5maW5pdGVEZXNjZW50XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVSUk9SX1JVTEVfTkFNRSxcbiAgICAgICAgIElOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFVOSVFVRV9SVUxFX05BTUUsXG4gICAgICAgICBTUFJFQURfUlVMRV9OQU1FLFxuICAgICAgICAgRU5EX0lOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFJVTEVfTkFNRV9SVUxFX05BTUUsXG4gICAgICAgICBUT0tFTl9UWVBFX1JVTEVfTkFNRSxcbiAgICAgICAgIFNUQVJUX0lOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFNVQl9FWFBSRVNTSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIElORklOSVRFX0RFU0NFTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhGcm9tSW5kZXhOb2RlKGluZGV4Tm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbmRleE5vZGUsIC8vL1xuICAgICAgICBpbmRleCA9IGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChmaXJzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgICAgICAgaW5kZXggPSBOdW1iZXIoY29udGVudCk7XG5cbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lc0Zyb21QYXRoTm9kZShwYXRoTm9kZSkge1xuICBjb25zdCBzZWxlY3Rvck5vZGVzID0gc2VsZWN0b3JOb2Rlc0Zyb21QYXRoTm9kZShwYXRoTm9kZSksXG4gICAgICAgIHJ1bGVOYW1lTm9kZXMgPSBzZWxlY3Rvck5vZGVzLnJlZHVjZSgocnVsZU5hbWVOb2Rlcywgc2VsZWN0b3JOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2VsZWN0b3JOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICBydWxlTmFtZU5vZGUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBydWxlTmFtZU5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBSVUxFX05BTUVfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVOYW1lUnVsZU5hbWVSdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZU5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZU5hbWVOb2RlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJ1bGVOYW1lTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVsZU5hbWVOb2Rlcy5wdXNoKHJ1bGVOYW1lTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lTm9kZXM7XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgcnVsZU5hbWVzID0gcnVsZU5hbWVOb2Rlcy5tYXAoKHJ1bGVOYW1lTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHJ1bGVOYW1lTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gY29udGVudDsgLy8vXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuVHlwZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0b3JOb2RlcyA9IHNlbGVjdG9yTm9kZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICB0b2tlblR5cGVOb2RlcyA9IHNlbGVjdG9yTm9kZXMucmVkdWNlKCh0b2tlblR5cGVOb2Rlcywgc2VsZWN0b3JOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2VsZWN0b3JOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICB0b2tlblR5cGVOb2RlID0gZnJvbUZpcnN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGZpcnN0Q2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgdG9rZW5UeXBlTm9kZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZVRva2VuVHlwZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBUT0tFTl9UWVBFX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChydWxlTmFtZVRva2VuVHlwZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZU5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5UeXBlTm9kZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0b2tlblR5cGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlblR5cGVOb2Rlcy5wdXNoKHRva2VuVHlwZU5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b2tlblR5cGVOb2RlcztcbiAgICAgICAgfSwgW10pLFxuICAgICAgICB0b2tlblR5cGVzID0gdG9rZW5UeXBlTm9kZXMubWFwKCh0b2tlblR5cGVOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdG9rZW5UeXBlTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgIHRva2VuVHlwZSA9IGZyb21UaGlyZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsICh0aGlyZENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gdGhpcmRDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlID0gY29udGVudDsgIC8vL1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRva2VuVHlwZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHRva2VuVHlwZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rvck5vZGVzRnJvbVBhdGhOb2RlKHBhdGhOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcGF0aE5vZGU7IC8vL1xuXG4gIGNvbnN0IHNlbGVjdG9yc05vZGUgPSBmcm9tTGFzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChsYXN0Q2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3JzTm9kZSA9IGxhc3RDaGlsZE5vZGU7ICAvLy9cblxuICAgIHJldHVybiBzZWxlY3RvcnNOb2RlO1xuICB9KTtcblxuICBub25UZXJtaW5hbE5vZGUgPSBzZWxlY3RvcnNOb2RlOyAgLy8vXG5cbiAgY29uc3Qgc2VsZWN0b3JOb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5maWx0ZXJDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VsZWN0b3JOb2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZmluaXRlRGVzY2VudEZyb21QYXRoTm9kZShwYXRoTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBwYXRoTm9kZSwgLy8vXG4gICAgICAgIGluZmluaXRlRGVzY2VudCA9IGZyb21TZWNvbmRDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoc2Vjb25kQ2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZUluZmluaXRlRGVzY2VudFJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBJTkZJTklURV9ERVNDRU5UX1JVTEVfTkFNRSksXG4gICAgICAgICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gcnVsZU5hbWVJbmZpbml0ZURlc2NlbnRSdWxlTmFtZTsgIC8vL1xuXG4gICAgICAgICAgcmV0dXJuIGluZmluaXRlRGVzY2VudDtcbiAgICAgICAgfSkgfHwgZmFsc2U7XG5cbiAgcmV0dXJuIGluZmluaXRlRGVzY2VudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ByZWFkTm9kZSxcbiAgICAgICAgdW5pcXVlID0gZnJvbUZpcnN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGZpcnN0Q2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgbGV0IHVuaXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgaWYgKGZpcnN0Q2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgcnVsZU5hbWVVbmlxdWVSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gVU5JUVVFX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGlmIChydWxlTmFtZVVuaXF1ZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHVuaXF1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuaXF1ZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHVuaXF1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4RnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSkge1xuICBsZXQgaW5kZXggPSBudWxsO1xuXG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNwcmVhZE5vZGUsIC8vL1xuICAgICAgICBpbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZUluZGV4UnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IElOREVYX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGlmIChydWxlTmFtZUluZGV4UnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChpbmRleE5vZGUgIT09IG51bGwpIHtcbiAgICBpbmRleCA9IGluZGV4RnJvbUluZGV4Tm9kZShpbmRleE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kSW5kZXhGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKSB7XG4gIGxldCBlbmRJbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNwcmVhZE5vZGUsIC8vL1xuICAgICAgICBlbmRJbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZUVuZEluZGV4UnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IEVORF9JTkRFWF9SVUxFX05BTUUpO1xuXG4gICAgICAgICAgICBpZiAocnVsZU5hbWVFbmRJbmRleFJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoZW5kSW5kZXhOb2RlICE9PSBudWxsKSB7XG4gICAgZW5kSW5kZXggPSBpbmRleEZyb21JbmRleE5vZGUoZW5kSW5kZXhOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBlbmRJbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SW5kZXhGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKSB7XG4gIGxldCBzdGFydEluZGV4ID0gMDtcblxuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBzcHJlYWROb2RlLCAvLy9cbiAgICAgICAgc3RhcnRJbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZVN0YXJ0SW5kZXhSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1RBUlRfSU5ERVhfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVOYW1lU3RhcnRJbmRleFJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoc3RhcnRJbmRleE5vZGUgIT09IG51bGwpIHtcbiAgICBzdGFydEluZGV4ID0gaW5kZXhGcm9tSW5kZXhOb2RlKHN0YXJ0SW5kZXhOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGFydEluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBwYXRoTm9kZSA9IGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChmaXJzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGhOb2RlID0gZmlyc3RDaGlsZE5vZGU7ICAvLy9cblxuICAgICAgICAgIHJldHVybiBwYXRoTm9kZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHBhdGhOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkTm9kZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIHNwcmVhZE5vZGUgPSBmcm9tU2Vjb25kQ2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKHNlY29uZENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGxldCBzcHJlYWROb2RlID0gbnVsbDtcblxuICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgcnVsZU5hbWVTcHJlYWRSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1BSRUFEX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICBpZiAocnVsZU5hbWVTcHJlYWRSdWxlTmFtZSkge1xuICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNlY29uZENoaWxkTm9kZTsgIC8vL1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzcHJlYWROb2RlO1xuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIHJldHVybiBzcHJlYWROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JOb2Rlc0Zyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIGVycm9yTm9kZXMgPSBub25UZXJtaW5hbE5vZGUucmVkdWNlQ2hpbGROb2RlKChlcnJvck5vZGVzLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lRXJyb3JSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gRVJST1JfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVOYW1lRXJyb3JSdWxlTmFtZSkge1xuICAgICAgICAgICAgICBjb25zdCBlcnJvck5vZGUgPSBub25UZXJtaW5hbE5vZGU7ICAvLy9cblxuICAgICAgICAgICAgICBlcnJvck5vZGVzLnB1c2goZXJyb3JOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXJyb3JOb2RlcztcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBlcnJvck5vZGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbk5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgbGV0IHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIG11bHRpcGxpY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRNdWx0aXBsaWNpdHkoKTtcblxuICBpZiAobXVsdGlwbGljaXR5ID4gMSkge1xuICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gZnJvbUxhc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAobGFzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgbGV0IHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbGFzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJ1bGVOYW1lU3ViRXhwcmVzc2lvblJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBTVUJfRVhQUkVTU0lPTl9SVUxFX05BTUUpO1xuXG4gICAgICBpZiAocnVsZU5hbWVTdWJFeHByZXNzaW9uUnVsZU5hbWUpIHtcbiAgICAgICAgc3ViRXhwcmVzc2lvbk5vZGUgPSBsYXN0Q2hpbGROb2RlOyAgLy8vXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJFeHByZXNzaW9uTm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdWJFeHByZXNzaW9uTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhOb2RlRnJvbVN1YkV4cHJlc3Npb25Ob2RlKHN1YkV4cHJlc3Npb25Ob2RlKSB7XG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlLCAvLy9cbiAgICAgICAgcGF0aE5vZGUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXRoTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgICAgICAgICByZXR1cm4gcGF0aE5vZGU7XG4gICAgICAgIH0pXG5cbiAgcmV0dXJuIHBhdGhOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZShzdWJFeHByZXNzaW9uTm9kZSkge1xuICBsZXQgc3ByZWFkTm9kZSA9IG51bGw7XG5cbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ViRXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCk7XG5cbiAgaWYgKG11bHRpcGxpY2l0eSA+IDEpIHtcbiAgICBzcHJlYWROb2RlID0gZnJvbVNlY29uZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChzZWNvbmRDaGlsZE5vZGUpID0+IHtcbiAgICAgIGxldCBzcHJlYWROb2RlID0gbnVsbDtcblxuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgcnVsZU5hbWVTcHJlYWRSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1BSRUFEX1JVTEVfTkFNRSk7XG5cbiAgICAgIGlmIChydWxlTmFtZVNwcmVhZFJ1bGVOYW1lKSB7XG4gICAgICAgIHNwcmVhZE5vZGUgPSBzZWNvbmRDaGlsZE5vZGU7ICAvLy9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwcmVhZE5vZGU7XG4gICAgfSkgfHwgbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzcHJlYWROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbk5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ViRXhwcmVzc2lvbk5vZGU7IC8vL1xuXG4gIHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCk7XG5cbiAgaWYgKG11bHRpcGxpY2l0eSA+IDEpIHtcbiAgICBzdWJFeHByZXNzaW9uTm9kZSA9IGZyb21MYXN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGxhc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgIGxldCBzdWJFeHByZXNzaW9uTm9kZSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9lID0gbGFzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9lLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBydWxlTmFtZVN1YkV4cHJlc3Npb25SdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1VCX0VYUFJFU1NJT05fUlVMRV9OQU1FKTtcblxuICAgICAgaWYgKHJ1bGVOYW1lU3ViRXhwcmVzc2lvblJ1bGVOYW1lKSB7XG4gICAgICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gbGFzdENoaWxkTm9kZTsgIC8vL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ViRXhwcmVzc2lvbk5vZGU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3ViRXhwcmVzc2lvbk5vZGU7XG59XG5cbmZ1bmN0aW9uIGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3QgZmlyc3RJbmRleCA9IDA7XG5cbiAgbm9uVGVybWluYWxOb2RlLmZvcndhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gZmlyc3RJbmRleCkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayhmaXJzdENoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZnJvbVNlY29uZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3Qgc2Vjb25kSW5kZXggPSAxO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5mb3J3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IHNlY29uZEluZGV4KSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkTm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGZpcnN0Q2hpbGROb2RlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmcm9tVGhpcmRDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0O1xuXG4gIGNvbnN0IHRoaXJkSW5kZXggPSAyO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5mb3J3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXJkSW5kZXgpIHtcbiAgICAgIGNvbnN0IHRoaXJkQ2hpbGROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodGhpcmRDaGlsZE5vZGUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZyb21MYXN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdDtcblxuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCksXG4gICAgICAgIGxhc3RJbmRleCA9IG11bHRpcGxpY2l0eSAtIDE7XG5cbiAgbm9uVGVybWluYWxOb2RlLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgY29uc3QgdGhpcmRDaGlsZE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh0aGlyZENoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbVBhdGhOb2RlLCB0b2tlblR5cGVzRnJvbVBhdGhOb2RlLCBpbmZpbml0ZURlc2NlbnRGcm9tUGF0aE5vZGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWVzLCB0b2tlblR5cGVzLCBpbmZpbml0ZURlc2NlbnQpIHtcbiAgICB0aGlzLnJ1bGVOYW1lcyA9IHJ1bGVOYW1lcztcbiAgICB0aGlzLnRva2VuVHlwZXMgPSB0b2tlblR5cGVzO1xuICAgIHRoaXMuaW5maW5pdGVEZXNjZW50ID0gaW5maW5pdGVEZXNjZW50O1xuICB9XG5cbiAgZ2V0UnVsZU5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lcztcbiAgfVxuXG4gIGdldFRva2VuVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5UeXBlcztcbiAgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXRlRGVzY2VudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGF0aE5vZGUocGF0aE5vZGUpIHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgIHRva2VuVHlwZXMgPSB0b2tlblR5cGVzRnJvbVBhdGhOb2RlKHBhdGhOb2RlKSxcbiAgICAgICAgICBpbmZpbml0ZURlc2NlbnQgPSBpbmZpbml0ZURlc2NlbnRGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChydWxlTmFtZXMsIHRva2VuVHlwZXMsIGluZmluaXRlRGVzY2VudCk7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuZXhwb3J0IGNvbnN0IHsgY2xlYXIsIHB1c2gsIGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBmb3VydGgsIGZpZnRoLCBsYXN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oYXJyYXksIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgLy8vXG5cbiAgICBzdGFydEluZGV4ID0gbGVuZ3RoICsgc3RhcnRJbmRleDsgLy8vXG5cbiAgICBlbmRJbmRleCA9IGxlbmd0aCArIGVuZEluZGV4OyAvLy9cbiAgfVxuXG4gIGlmIChlbmRJbmRleCAhPT0gSW5maW5pdHkpIHtcbiAgICBjb25zdCBzdGFydCA9IGVuZEluZGV4ICsgMTtcblxuICAgIGFycmF5LnNwbGljZShzdGFydCk7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IDAsXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gc3RhcnRJbmRleDsgLy8vXG5cbiAgYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgLi4uZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IGFycmF5LmluY2x1ZGVzKGVsZW1lbnQpKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgY2xlYXIsIHRyaW0sIHNlY29uZCwgdGhpcmQsIGZvdXJ0aCB9IGZyb20gXCIuL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgaW5kZXhGcm9tU3ByZWFkTm9kZSxcbiAgICAgICAgIHVuaXF1ZUZyb21TcHJlYWROb2RlLFxuICAgICAgICAgZW5kSW5kZXhGcm9tU3ByZWFkTm9kZSxcbiAgICAgICAgIHN0YXJ0SW5kZXhGcm9tU3ByZWFkTm9kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcmVhZCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpIHtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICB0aGlzLnVuaXF1ZSA9IHVuaXF1ZTtcbiAgfVxuXG4gIGFkanVzdE5vZGVzKG5vZGVzKSB7XG4gICAgaWYgKHRoaXMudW5pcXVlKSB7XG4gICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVzTGVuZ3RoID4gMSkge1xuICAgICAgICBjbGVhcihub2Rlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaW0obm9kZXMsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5lbmRJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgIGVuZEluZGV4ID0gSW5maW5pdHksXG4gICAgICAgICAgdW5pcXVlID0gZmFsc2UsXG4gICAgICAgICAgc3ByZWFkID0gbmV3IFNwcmVhZChzdGFydEluZGV4LCBlbmRJbmRleCwgdW5pcXVlKTtcblxuICAgIHJldHVybiBzcHJlYWQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSkge1xuICAgIGxldCBzdGFydEluZGV4ID0gMCxcbiAgICAgICAgZW5kSW5kZXggPSBJbmZpbml0eSxcbiAgICAgICAgdW5pcXVlID0gZmFsc2U7XG5cbiAgICBpZiAoc3ByZWFkTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleEZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4OyAvLy9cblxuICAgICAgICBlbmRJbmRleCA9IGluZGV4OyAvLy9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4RnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSk7XG5cbiAgICAgICAgZW5kSW5kZXggPSBlbmRJbmRleEZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuICAgICAgfVxuXG4gICAgICB1bmlxdWUgPSB1bmlxdWVGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcHJlYWQgPSBuZXcgU3ByZWFkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpO1xuXG4gICAgcmV0dXJuIHNwcmVhZDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3ByZWFkRXhwcmVzc2lvbihzcHJlYWRFeHByZXNzaW9uKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICBlbmRJbmRleCA9IEluZmluaXR5LFxuICAgICAgICB1bmlxdWUgPSBmYWxzZTtcblxuICAgIGlmIChzcHJlYWRFeHByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoc3ByZWFkRXhwcmVzc2lvbiA9PT0gRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVIpIHtcbiAgICAgICAgdW5pcXVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9IC9cXFsoLT9cXGQrKT8oXFwuXFwuXFwuKT8oLT9cXGQrKT9dLyxcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHNwcmVhZEV4cHJlc3Npb24ubWF0Y2gocmVnRXhwKSxcbiAgICAgICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcykgfHwgbnVsbCxcbiAgICAgICAgICAgICAgdGhpcmRNYXRjaCA9IHRoaXJkKG1hdGNoZXMpIHx8IG51bGwsXG4gICAgICAgICAgICAgIGZvdXJ0aE1hdGNoID0gZm91cnRoKG1hdGNoZXMpIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKHNlY29uZE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHBhcnNlSW50KHNlY29uZE1hdGNoKTtcblxuICAgICAgICAgIGlmICh0aGlyZE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7ICAvLy9cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91cnRoTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICBlbmRJbmRleCA9IHBhcnNlSW50KGZvdXJ0aE1hdGNoKTtcblxuICAgICAgICAgIGlmICh0aGlyZE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gZW5kSW5kZXg7ICAvLy9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcHJlYWQgPSBuZXcgU3ByZWFkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpO1xuXG4gICAgcmV0dXJuIHNwcmVhZDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGF0aCBmcm9tIFwiLi9wYXRoXCI7XG5pbXBvcnQgU3ByZWFkIGZyb20gXCIuL3NwcmVhZFwiO1xuXG5pbXBvcnQgeyBwYXRoTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZSwgc3ByZWFkTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZSwgc3ViRXhwcmVzc2lvbk5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGF0aCwgc3ByZWFkLCBzdWJFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnNwcmVhZCA9IHNwcmVhZDtcbiAgICB0aGlzLnN1YkV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG5cbiAgZ2V0U3ByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnNwcmVhZDtcbiAgfVxuXG4gIGdldFN1YkV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFJ1bGVOYW1lcygpIHsgcmV0dXJuIHRoaXMucGF0aC5nZXRSdWxlTmFtZXMoKTsgfVxuXG4gIGdldFRva2VuVHlwZXMoKSB7IHJldHVybiB0aGlzLnBhdGguZ2V0VG9rZW5UeXBlcygpOyB9XG5cbiAgaXNJbmZpbml0ZURlc2NlbnQoKSB7IHJldHVybiB0aGlzLnBhdGguaXNJbmZpbml0ZURlc2NlbnQoKTsgfVxuXG4gIHN0YXRpYyBmcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpIHtcbiAgICBsZXQgc3ViRXhwcmVzc2lvbiA9IG51bGw7XG5cbiAgICBpZiAoc3ViRXhwcmVzc2lvbk5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhdGhOb2RlID0gcGF0aE5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlRnJvbVN1YkV4cHJlc3Npb25Ob2RlKHN1YkV4cHJlc3Npb25Ob2RlKTsgIC8vL1xuXG4gICAgICBjb25zdCBwYXRoID0gUGF0aC5mcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbi5mcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uID0gbmV3IFN1YkV4cHJlc3Npb24ocGF0aCwgc3ByZWFkLCBzdWJFeHByZXNzaW9uKTsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YkV4cHJlc3Npb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OkB8IXxcXFxcKnxcXFxcfHxcXFxcL3xcXFxcW3xcXFxcXXxcXFxcLlxcXFwuXFxcXC4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIl5bYS16QS1aXFxcXC1dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl5bMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXi5cIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHByZXNzaW9uTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoRXhwcmVzc2lvbkxleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoRXhwcmVzc2lvbkxleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEV4cHJlc3Npb25MZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGV4cHJlc3Npb24gICAgICAgOjo9ICBwYXRoIHNwcmVhZD8gc3ViRXhwcmVzc2lvbj8gICBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgfCAgZXJyb3IrIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIDtcbiAgXG4gICAgcGF0aCAgICAgICAgICAgICA6Oj0gIFwiL1wiIGluZmluaXRlRGVzY2VudD8gc2VsZWN0b3JzIDtcbiAgICBcbiAgICBzdWJFeHByZXNzaW9uICAgIDo6PSAgcGF0aCBzcHJlYWQ/IHN1YkV4cHJlc3Npb24/O1xuXG4gICAgaW5maW5pdGVEZXNjZW50ICA6Oj0gIFwiL1wiIDtcbiAgICBcbiAgICBzZWxlY3RvcnMgICAgICAgIDo6PSAgc2VsZWN0b3IgKCBcInxcIiBzZWxlY3RvciApKiA7XG5cbiAgICBzcHJlYWQgICAgICAgICAgIDo6PSAgdW5pcXVlXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgIHwgIFwiW1wiIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzdGFydEluZGV4IFwiLi4uXCIgZW5kSW5kZXggKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggc3RhcnRJbmRleCBcIi4uLlwiICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFwiLi4uXCIgZW5kSW5kZXggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICApICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiIDtcblxuICAgIHNlbGVjdG9yICAgICAgICAgOjo9ICBydWxlTmFtZSB8IHRva2VuVHlwZSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHJ1bGVOYW1lICAgICAgICAgOjo9ICBbbmFtZV0gfCBcIipcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHRva2VuVHlwZSAgICAgICAgOjo9ICBcIkBcIjxOT19XSElURVNQQUNFPiggW25hbWVdIHwgXCIqXCIgKSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHN0YXJ0SW5kZXggICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGVuZEluZGV4ICAgICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGluZGV4ICAgICAgICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHVuaXF1ZSAgICAgICAgICAgOjo9ICBcIiFcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuXG5cbiAgICBlcnJvci4gICAgICAgICAgIDo6PSAgLiA7XG4gICAgXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhFeHByZXNzaW9uUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoRXhwcmVzc2lvblBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoRXhwcmVzc2lvblBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQYXRoIGZyb20gXCIuL3BhdGhcIjtcbmltcG9ydCBTcHJlYWQgZnJvbSBcIi4vc3ByZWFkXCI7XG5pbXBvcnQgU3ViRXhwcmVzc2lvbiBmcm9tIFwiLi9zdWJFeHByZXNzaW9uXCI7XG5pbXBvcnQgRXhwcmVzc2lvbkxleGVyIGZyb20gXCIuL2V4cHJlc3Npb24vbGV4ZXJcIjtcbmltcG9ydCBFeHByZXNzaW9uUGFyc2VyIGZyb20gXCIuL2V4cHJlc3Npb24vcGFyc2VyXCI7XG5cbmltcG9ydCB7IHBhdGhOb2RlRnJvbUV4cHJlc3Npb25Ob2RlLFxuICAgICAgICAgc3ByZWFkTm9kZUZyb21FeHByZXNzaW9uTm9kZSxcbiAgICAgICAgIGVycm9yTm9kZXNGcm9tRXhwcmVzc2lvbk5vZGUsXG4gICAgICAgICBzdWJFeHByZXNzaW9uTm9kZUZyb21FeHByZXNzaW9uTm9kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IGV4cHJlc3Npb25MZXhlciA9IEV4cHJlc3Npb25MZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgZXhwcmVzc2lvblBhcnNlciA9IEV4cHJlc3Npb25QYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIHNwcmVhZCwgc3ViRXhwcmVzc2lvbikge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJFeHByZXNzaW9uID0gc3ViRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGdldFNwcmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcHJlYWQ7XG4gIH1cblxuICBnZXRTdWJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN1YkV4cHJlc3Npb247XG4gIH1cblxuICBnZXRSdWxlTmFtZXMoKSB7IHJldHVybiB0aGlzLnBhdGguZ2V0UnVsZU5hbWVzKCk7IH1cblxuICBnZXRUb2tlblR5cGVzKCkgeyByZXR1cm4gdGhpcy5wYXRoLmdldFRva2VuVHlwZXMoKTsgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkgeyByZXR1cm4gdGhpcy5wYXRoLmlzSW5maW5pdGVEZXNjZW50KCk7IH1cblxuICBzdGF0aWMgZnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSB7XG4gICAgY29uc3QgcGF0aE5vZGUgPSBwYXRoTm9kZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gc3ViRXhwcmVzc2lvbk5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHBhdGggPSBQYXRoLmZyb21QYXRoTm9kZShwYXRoTm9kZSksXG4gICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpLFxuICAgICAgICAgIHN1YkV4cHJlc3Npb24gPSBTdWJFeHByZXNzaW9uLmZyb21TdWJFeHByZXNzaW9uTm9kZShzdWJFeHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKHBhdGgsIHNwcmVhZCwgc3ViRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gICAgY29uc3QgbGV4ZXIgPSBleHByZXNzaW9uTGV4ZXIsICAvLy9cbiAgICAgICAgICBwYXJzZXIgPSBleHByZXNzaW9uUGFyc2VyLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IGV4cHJlc3Npb25TdHJpbmcsIC8vL1xuICAgICAgICAgIHRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIG5vZGUgPSBwYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgZXJyb3JOb2RlcyA9IGVycm9yTm9kZXNGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgZXJyb3JOb2Rlc0xlbmd0aCA9IGVycm9yTm9kZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZXJyb3JOb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBwYXRoTm9kZSA9IHBhdGhOb2RlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgICBzdWJFeHByZXNzaW9uTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICAgICAgcGF0aCA9IFBhdGguZnJvbVBhdGhOb2RlKHBhdGhOb2RlKSxcbiAgICAgICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpLFxuICAgICAgICAgICAgICBzdWJFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbi5mcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICAgIGV4cHJlc3Npb24gPSBuZXcgRXhwcmVzc2lvbihwYXRoLCBzcHJlYWQsIHN1YkV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuL2V4cHJlc3Npb25cIjtcblxuaW1wb3J0IHsgcHVzaCwgY2xlYXIsIGluY2x1ZGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmNvbnN0IHsgV0lMRENBUkRfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKHNwcmVhZCwgc3ViUXVlcnksIHJ1bGVOYW1lcywgdG9rZW5UeXBlcywgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKSB7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJRdWVyeSA9IHN1YlF1ZXJ5O1xuICAgIHRoaXMucnVsZU5hbWVzID0gcnVsZU5hbWVzO1xuICAgIHRoaXMudG9rZW5UeXBlcyA9IHRva2VuVHlwZXM7XG4gICAgdGhpcy5tYXhpbXVtRGVwdGggPSBtYXhpbXVtRGVwdGg7XG4gICAgdGhpcy5pbmZpbml0ZURlc2NlbnQgPSBpbmZpbml0ZURlc2NlbnQ7XG4gICAgdGhpcy5pbnRlcm1lZGlhdGVOb2RlcyA9IGludGVybWVkaWF0ZU5vZGVzO1xuICB9XG5cbiAgZ2V0U3ByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnNwcmVhO1xuICB9XG5cbiAgZ2V0U3ViUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViUXVlcnk7XG4gIH1cblxuICBnZXRSdWxlTmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWVzO1xuICB9XG5cbiAgZ2V0VG9rZW5UeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlblR5cGVzO1xuICB9XG5cbiAgZ2V0TWF4aW11bURlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLm1heGltdW1EZXB0aDtcbiAgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXRlRGVzY2VudDtcbiAgfVxuXG4gIGdldEludGVybWVkaWF0ZU5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybWVkaWF0ZU5vZGVzO1xuICB9XG5cbiAgZXhlY3V0ZShub2RlLCBkZXB0aCA9IDAsIG1heGltdW1EZXB0aCA9IHRoaXMubWF4aW11bURlcHRoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuZmluZChub2RlLCBkZXB0aCwgbWF4aW11bURlcHRoKTtcblxuICAgIHRoaXMuYXBwbHkobm9kZXMsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXIodGhpcy5pbnRlcm1lZGlhdGVOb2Rlcyk7XG4gIH1cblxuICBmaW5kKG5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBtYXhpbXVtRGVwdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIG5vZGVOb25UZXJtaW5hbE5vZGUgPSAhbm9kZVRlcm1pbmFsTm9kZTtcblxuICAgIGxldCBmb3VuZDtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICB0eXBlcyA9IHRoaXMudG9rZW5UeXBlcywgIC8vL1xuICAgICAgICAgICAgdHlwZSA9IHRlcm1pbmFsTm9kZS5nZXRUeXBlKCk7XG5cbiAgICAgIGZvdW5kID0gaW5jbHVkZXModHlwZXMsIHR5cGUsIFdJTERDQVJEX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgICAgZm91bmQgPSBpbmNsdWRlcyh0aGlzLnJ1bGVOYW1lcywgcnVsZU5hbWUsIFdJTERDQVJEX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGVOb2RlID0gbm9kZTsgLy8vXG5cbiAgICAgIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMucHVzaChpbnRlcm1lZGlhdGVOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmZpbml0ZURlc2NlbnQpIHtcbiAgICAgIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgLy8vXG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlLmZvckVhY2hDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCkge1xuICAgIHRoaXMuc3ByZWFkLmFkanVzdE5vZGVzKHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgaWYgKHRoaXMuc3ViUXVlcnkgPT09IG51bGwpIHtcbiAgICAgIHB1c2gobm9kZXMsIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVybWVkaWF0ZU5vZGVzLmZvckVhY2goKGludGVybWVkaWF0ZU5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSA9IGludGVybWVkaWF0ZU5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbnRlcm1lZGlhdGVOb2RlOyAvLy9cblxuICAgICAgICAgIHRoaXMuc3ViUXVlcnkuY2xlYXIoKTtcblxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZS5mb3JFYWNoQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViUXVlcnkuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5zdWJRdWVyeS5hcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvbihleHByZXNzaW9uLCBtYXhpbXVtRGVwdGggPSBJbmZpbml0eSkge1xuICAgIGNvbnN0IHNwcmVhZCA9IGV4cHJlc3Npb24uZ2V0U3ByZWFkKCksXG4gICAgICAgICAgc3ViUXVlcnkgPSBzdWJRdWVyeUZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pLFxuICAgICAgICAgIHJ1bGVOYW1lcyA9IGV4cHJlc3Npb24uZ2V0UnVsZU5hbWVzKCksXG4gICAgICAgICAgdG9rZW5UeXBlcyA9IGV4cHJlc3Npb24uZ2V0VG9rZW5UeXBlcygpLFxuICAgICAgICAgIGluZmluaXRlRGVzY2VudCA9IGV4cHJlc3Npb24uaXNJbmZpbml0ZURlc2NlbnQoKSxcbiAgICAgICAgICBpbnRlcm1lZGlhdGVOb2RlcyA9IFtdLFxuICAgICAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHNwcmVhZCwgc3ViUXVlcnksIHJ1bGVOYW1lcywgdG9rZW5UeXBlcywgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3ViRXhwcmVzc2lvbihzdWJFeHByZXNzaW9uKSB7XG4gICAgY29uc3Qgc3ByZWFkID0gc3ViRXhwcmVzc2lvbi5nZXRTcHJlYWQoKSxcbiAgICAgICAgICBzdWJRdWVyeSA9IHN1YlF1ZXJ5RnJvbVN1YkV4cHJlc3Npb24oc3ViRXhwcmVzc2lvbiksXG4gICAgICAgICAgcnVsZU5hbWVzID0gc3ViRXhwcmVzc2lvbi5nZXRSdWxlTmFtZXMoKSxcbiAgICAgICAgICB0b2tlblR5cGVzID0gc3ViRXhwcmVzc2lvbi5nZXRUb2tlblR5cGVzKCksXG4gICAgICAgICAgbWF4aW11bURlcHRoID0gSW5maW5pdHksXG4gICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gc3ViRXhwcmVzc2lvbi5pc0luZmluaXRlRGVzY2VudCgpLFxuICAgICAgICAgIGludGVybWVkaWF0ZU5vZGVzID0gW10sXG4gICAgICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoc3ByZWFkLCBzdWJRdWVyeSwgcnVsZU5hbWVzLCB0b2tlblR5cGVzLCBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgc3RhdGljIGZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcsIG1heGltdW1EZXB0aCA9IEluZmluaXR5KSB7XG4gICAgbGV0IHF1ZXJ5ID0gbnVsbDtcblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBFeHByZXNzaW9uLmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gICAgaWYgKGV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNwcmVhZCA9IGV4cHJlc3Npb24uZ2V0U3ByZWFkKCksXG4gICAgICAgICAgICBzdWJRdWVyeSA9IHN1YlF1ZXJ5RnJvbUV4cHJlc3Npb24oZXhwcmVzc2lvbiksXG4gICAgICAgICAgICBydWxlTmFtZXMgPSBleHByZXNzaW9uLmdldFJ1bGVOYW1lcygpLFxuICAgICAgICAgICAgdG9rZW5UeXBlcyA9IGV4cHJlc3Npb24uZ2V0VG9rZW5UeXBlcygpLFxuICAgICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gZXhwcmVzc2lvbi5pc0luZmluaXRlRGVzY2VudCgpLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlTm9kZXMgPSBbXTtcblxuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoc3ByZWFkLCBzdWJRdWVyeSwgcnVsZU5hbWVzLCB0b2tlblR5cGVzLCBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJRdWVyeUZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgbGV0IHN1YlF1ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBzdWJFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5nZXRTdWJFeHByZXNzaW9uKCk7XG5cbiAgaWYgKHN1YkV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21TdWJFeHByZXNzaW9uKHN1YkV4cHJlc3Npb24pO1xuXG4gICAgc3ViUXVlcnkgPSBxdWVyeTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3ViUXVlcnk7XG59XG5cbmZ1bmN0aW9uIHN1YlF1ZXJ5RnJvbVN1YkV4cHJlc3Npb24oc3ViRXhwcmVzc2lvbikge1xuICBsZXQgc3ViUXVlcnkgPSBudWxsO1xuXG4gIHN1YkV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uLmdldFN1YkV4cHJlc3Npb24oKTsgLy8vXG5cbiAgaWYgKHN1YkV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21TdWJFeHByZXNzaW9uKHN1YkV4cHJlc3Npb24pO1xuXG4gICAgc3ViUXVlcnkgPSBxdWVyeTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3ViUXVlcnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBRdWVyeSBmcm9tIFwiLi4vcXVlcnlcIjtcbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuLi9leHByZXNzaW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUJ5RXhwcmVzc2lvblN0cmluZyhub2RlLCBleHByZXNzaW9uU3RyaW5nLCBtYXhpbXVtRGVwdGgpIHtcbiAgbGV0IG5vZGVzID0gbnVsbDtcblxuICBjb25zdCBleHByZXNzaW9uID0gRXhwcmVzc2lvbi5mcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKTtcblxuICBpZiAoZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbWF4aW11bURlcHRoKTtcblxuICAgIG5vZGVzID0gcXVlcnkuZXhlY3V0ZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBxdWVyeUJ5RXhwcmVzc2lvblN0cmluZ1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBRdWVyeSB9IGZyb20gXCIuL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cHJlc3Npb24gfSBmcm9tIFwiLi9leHByZXNzaW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHF1ZXJ5VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cHJlc3Npb25MZXhlciB9IGZyb20gXCIuL2V4cHJlc3Npb24vbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gXCIuL2V4cHJlc3Npb24vcGFyc2VyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBIRUFEID0gXCJoZWFkXCI7XG5leHBvcnQgY29uc3QgU1RZTEUgPSBcInN0eWxlXCI7XG5leHBvcnQgY29uc3QgQ0hBUkFDVEVSUyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuZXhwb3J0IGNvbnN0IFRXT19TUEFDRVMgPSBcIiAgXCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FX0xFTkdUSCA9IDY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMocXVlcnksIG5vZGUsIHRva2Vucykge1xuICBsZXQgY29udGVudCA9IG51bGw7XG5cbiAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICBpZiAobm9kZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3Qobm9kZXMpO1xuXG4gICAgbm9kZSA9IGZpcnN0Tm9kZTsgLy8vXG5cbiAgICBjb250ZW50ID0gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICBjb25zdCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSxcbiAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gIGxldCBjb250ZW50ID0gRU1QVFlfU1RSSU5HO1xuXG4gIGZvciAobGV0IGluZGV4ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXg7IGluZGV4IDw9IGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXg7IGluZGV4KyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpbmRleF0sXG4gICAgICAgICAgdG9rZW5Db250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpO1xuXG4gICAgY29udGVudCArPSB0b2tlbkNvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HLCBUV09fU1BBQ0VTIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcblxuY29uc3QgaW1wb3J0YW50UXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi8qL2ltcG9ydGFudFwiKSxcbiAgICAgIHByb3BlcnR5TmFtZVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9wcm9wZXJ0eU5hbWVcIiksXG4gICAgICBwcm9wZXJ0eVZhbHVlc1F1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9wcm9wZXJ0eVZhbHVlc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eVZhbHVlcywgcHJvcGVydHlOYW1lLCBpbXBvcnRhbnQpIHtcbiAgICB0aGlzLnByb3BlcnR5VmFsdWVzID0gcHJvcGVydHlWYWx1ZXM7XG4gICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQ7XG4gIH1cblxuICBnZXRQcm9wZXJ0eVZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eVZhbHVlcztcbiAgfVxuXG4gIGdldFByb3BlcnR5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eU5hbWU7XG4gIH1cblxuICBnZXRJbXBvcnRhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wb3J0YW50O1xuICB9XG5cbiAgbWF0Y2hQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9ICh0aGlzLnByb3BlcnR5TmFtZSA9PT0gcHJvcGVydHlOYW1lKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgbWF0Y2hEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGRlY2xhcmF0aW9uLmdldFByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLm1hdGNoUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSk7IC8vL1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBtYXRjaERlY2xhcmF0aW9ucyhkZWNsYXJhdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gZGVjbGFyYXRpb25zLnNvbWVEZWNsYXJhdGlvbigoZGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm1hdGNoRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50ICsgVFdPX1NQQUNFUztcblxuICAgIGNvbnN0IGNzcyA9IGAke2luZGVudH0ke3RoaXMucHJvcGVydHlOYW1lfTogJHt0aGlzLnByb3BlcnR5VmFsdWVzfSR7dGhpcy5pbXBvcnRhbnR9O1xcbmA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHByb3BlcnR5VmFsdWVzQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKHByb3BlcnR5VmFsdWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcHJvcGVydHlOYW1lQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKHByb3BlcnR5TmFtZVF1ZXJ5LCBub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGltcG9ydGFudENvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhpbXBvcnRhbnRRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwcm9wZXJ0eVZhbHVlcyA9IHByb3BlcnR5VmFsdWVzQ29udGVudCwgLy8vXG4gICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lQ29udGVudCwgLy8vXG4gICAgICAgICAgaW1wb3J0YW50ID0gKGltcG9ydGFudENvbnRlbnQgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgYCAke2ltcG9ydGFudENvbnRlbnR9YCxcbiAgICAgICAgICBkZWNsYXJhdGlvbiA9IG5ldyBEZWNsYXJhdGlvbihwcm9wZXJ0eVZhbHVlcywgcHJvcGVydHlOYW1lLCBpbXBvcnRhbnQpO1xuXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmb3J3YXJkc0ZvckVhY2gsIGJhY2t3YXJkc0ZvckVhY2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5jb25zdCBkZWNsYXJhdGlvblF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9kZWNsYXJhdGlvblwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb25zIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBzb21lRGVjbGFyYXRpb24oY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICBmb3J3YXJkc0ZvckVhY2hEZWNsYXJhdGlvbihjYWxsYmFjaykgeyBmb3J3YXJkc0ZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2spOyB9XG5cbiAgYmFja3dhcmRzRm9yRWFjaERlY2xhcmF0aW9uKGNhbGxiYWNrKSB7IGJhY2t3YXJkc0ZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2spOyB9XG5cbiAgdW5zaGlmdChkZWNsYXJhdGlvbnMpIHtcbiAgICBkZWNsYXJhdGlvbnMuYmFja3dhcmRzRm9yRWFjaERlY2xhcmF0aW9uKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGRlY2xhcmF0aW9uLm1hdGNoRGVjbGFyYXRpb25zKHRoaXMpOyAvLy9cblxuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChkZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uc0NTUyA9IHRoaXMuYXJyYXkucmVkdWNlKChkZWNsYXJhdGlvbnNDU1MsIGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbkNTUyA9IGRlY2xhcmF0aW9uLmFzQ1NTKGluZGVudCk7XG5cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyArPSBkZWNsYXJhdGlvbkNTUztcblxuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uc0NTUztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIGNzcyA9IChjbGFzc05hbWUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyA6ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ge1xuJHtkZWNsYXJhdGlvbnNDU1N9JHtpbmRlbnR9fVxuXG5gO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGVzID0gZGVjbGFyYXRpb25RdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGFycmF5ID0gZGVjbGFyYXRpb25Ob2Rlcy5tYXAoKGRlY2xhcmF0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGRlY2xhcmF0aW9uTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBuZXcgRGVjbGFyYXRpb25zKGFycmF5KTtcblxuICAgIHJldHVybiBkZWNsYXJhdGlvbnM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9ucyBmcm9tIFwiLi9kZWNsYXJhdGlvbnNcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcblxuY29uc3Qgc2VsZWN0b3JzUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi8vc2VsZWN0b3JzXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2V0IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3JzLCBkZWNsYXJhdGlvbnMpIHtcbiAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RvcnM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zO1xuICB9XG5cbiAgdW5zaGlmdChydWxlU2V0KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gcnVsZVNldC5nZXREZWNsYXJhdGlvbnMoKTtcblxuICAgIHRoaXMuZGVjbGFyYXRpb25zLnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgfVxuXG4gIGZpbmRNYXRjaGluZ1J1bGVTZXQocnVsZVNldHMpIHtcbiAgICBjb25zdCBtYXRjaGluZ1J1bGVTZXQgPSBydWxlU2V0cy5maW5kKChydWxlU2V0KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSBydWxlU2V0LmdldFNlbGVjdG9ycygpLFxuICAgICAgICAgICAgc2VsZWN0b3JzTWF0Y2ggPSAoc2VsZWN0b3JzID09PSB0aGlzLnNlbGVjdG9ycyksXG4gICAgICAgICAgICBydWxlU2V0c01hdGNoID0gc2VsZWN0b3JzTWF0Y2g7IC8vL1xuXG4gICAgICBpZiAocnVsZVNldHNNYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBtYXRjaGluZ1J1bGVTZXQ7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGxldCBjc3MgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhudWxsLCBpbmRlbnQpO1xuXG4gICAgaWYgKGRlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgY3NzID0gYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ke3RoaXMuc2VsZWN0b3JzfSB7XG4ke2RlY2xhcmF0aW9uc0NTU30ke2luZGVudH19XG5cbmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWxlY3RvcnNGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHJ1bGVTZXQgPSBuZXcgUnVsZVNldChzZWxlY3RvcnMsIGRlY2xhcmF0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZVNldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RvcnNGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3Qgc2VsZWN0b3JzTm9kZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhzZWxlY3RvcnNRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgc2VsZWN0b3JzID0gYCR7c2VsZWN0b3JzTm9kZUNvbnRlbnR9YDtcblxuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1xdWVyeVwiO1xuXG5pbXBvcnQgUnVsZVNldCBmcm9tIFwiLi9ydWxlU2V0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgcnVsZVNldFF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9ydWxlU2V0XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2V0cyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChydWxlU2V0cykge1xuICAgIHJ1bGVTZXRzLmZvckVhY2goKHJ1bGVTZXQpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nUnVsZVNldCA9IHJ1bGVTZXQuZmluZE1hdGNoaW5nUnVsZVNldCh0aGlzLmFycmF5KTsgLy8vXG5cbiAgICAgIChtYXRjaGluZ1J1bGVTZXQgPT09IG51bGwpID9cbiAgICAgICAgdGhpcy5hcnJheS51bnNoaWZ0KHJ1bGVTZXQpIDpcbiAgICAgICAgICBtYXRjaGluZ1J1bGVTZXQudW5zaGlmdChydWxlU2V0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spO1xuICB9XG5cbiAgYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpIHtcbiAgICBjb25zdCBjc3MgPSB0aGlzLmFycmF5LnJlZHVjZSgoY3NzLCBydWxlU2V0KSA9PiB7XG4gICAgICBjb25zdCBydWxlU2V0Q1NTID0gcnVsZVNldC5hc0NTUyhjbGFzc05hbWUsIGluZGVudCk7XG5cbiAgICAgIGNzcyArPSBydWxlU2V0Q1NTO1xuXG4gICAgICByZXR1cm4gY3NzO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHJ1bGVTZXROb2RlcyA9IHJ1bGVTZXRRdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGFycmF5ID0gcnVsZVNldE5vZGVzLm1hcCgocnVsZVNldE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBydWxlU2V0Tm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBydWxlU2V0ID0gUnVsZVNldC5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcnVsZVNldDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBydWxlU2V0cyA9IG5ldyBSdWxlU2V0cyhhcnJheSk7XG5cbiAgICByZXR1cm4gcnVsZVNldHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcbiAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1tcXG5cXHJdJC9nLCBFTVBUWV9TVFJJTkcpOyAgLy8vXG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3J1bGVTZXRzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyB0cmltIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcbmltcG9ydCB7IFRXT19TUEFDRVMsIEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IHF1ZXJpZXNRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiL21lZGlhL21lZGlhUXVlcmllc1wiKTsgLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhIHtcbiAgY29uc3RydWN0b3IoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgcXVlcmllcykge1xuICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgICB0aGlzLnF1ZXJpZXMgPSBxdWVyaWVzO1xuICB9XG5cbiAgZ2V0RGVjbGFyYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFJ1bGVTZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVTZXRzO1xuICB9XG5cbiAgZ2V0UXVlcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyaWVzO1xuICB9XG5cbiAgYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpIHtcbiAgICBpbmRlbnQgPSBpbmRlbnQgKyBUV09fU1BBQ0VTO1xuXG4gICAgbGV0IGNzcyA9IEVNUFRZX1NUUklORztcblxuICAgIGNvbnN0IHJ1bGVTZXRzQ1NTID0gdGhpcy5ydWxlU2V0cy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgZGVjbGFyYXRpb25zQ1NTID0gdGhpcy5kZWNsYXJhdGlvbnMuYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpO1xuXG4gICAgbGV0IHJ1bGVTZXRzRGVjbGFyYXRpb25zQ1NTID0gYCR7ZGVjbGFyYXRpb25zQ1NTfSR7cnVsZVNldHNDU1N9YDtcblxuICAgIGlmIChydWxlU2V0c0RlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICBydWxlU2V0c0RlY2xhcmF0aW9uc0NTUyA9IHRyaW0ocnVsZVNldHNEZWNsYXJhdGlvbnNDU1MpO1xuXG4gICAgICBjc3MgPSBgQG1lZGlhICR7dGhpcy5xdWVyaWVzfSB7XG4ke3J1bGVTZXRzRGVjbGFyYXRpb25zQ1NTfX1cblxuYDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHJ1bGVTZXRzID0gUnVsZVNldHMuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBxdWVyaWVzID0gcXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgbWVkaWEgPSBuZXcgTWVkaWEoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgcXVlcmllcyk7XG5cbiAgICByZXR1cm4gbWVkaWE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICBjb25zdCBxdWVyaWVzTm9kZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhxdWVyaWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgIHF1ZXJpZXMgPSBgJHtxdWVyaWVzTm9kZUNvbnRlbnR9YDtcblxuICByZXR1cm4gcXVlcmllcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IE1lZGlhIGZyb20gXCIuL21lZGlhXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgbWVkaWFRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiL3N0eWxlc2hlZXQvbWVkaWFcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChtZWRpYXMpIHtcbiAgICBtZWRpYXMuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChtZWRpYSk7XG4gICAgfSk7XG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgY29uc3QgY3NzID0gdGhpcy5hcnJheS5yZWR1Y2UoKGNzcywgbWVkaWEpID0+IHtcbiAgICAgIGNvbnN0IG1lZGlhQ1NTID0gbWVkaWEuYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpO1xuXG4gICAgICBjc3MgKz0gbWVkaWFDU1M7XG5cbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgbWVkaWFOb2RlcyA9IG1lZGlhUXVlcnkuZXhlY3V0ZShub2RlKSxcbiAgICAgICAgICBhcnJheSA9IG1lZGlhTm9kZXMubWFwKChtZWRpYU5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBtZWRpYU5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgbWVkaWEgPSBNZWRpYS5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWVkaWE7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFzID0gbmV3IE1lZGlhcyhhcnJheSk7XG5cbiAgICByZXR1cm4gbWVkaWFzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IHBlcmNlbnRhZ2VRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiLyovQHBlcmNlbnRhZ2VcIiksXG4gICAgICBkZWNsYXJhdGlvblF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9kZWNsYXJhdGlvblwiKTtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleWZyYW1lIHtcbiAgY29uc3RydWN0b3IocGVyY2VudGFnZSwgZGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgfVxuXG4gIGdldFBlcmNlbnRhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyY2VudGFnZTtcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25DU1MgPSB0aGlzLmRlY2xhcmF0aW9uLmFzQ1NTKGluZGVudCksXG4gICAgICAgICAgY3NzID0gYCR7aW5kZW50fSR7dGhpcy5wZXJjZW50YWdlfSB7IFxuJHtkZWNsYXJhdGlvbkNTU30ke2luZGVudH19XFxuYDtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgcGVyY2VudGFnZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhwZXJjZW50YWdlUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcGVyY2VudGFnZSA9IHBlcmNlbnRhZ2VDb250ZW50LCAvLy9cbiAgICAgICAgICBkZWNsYXJhdGlvbk5vZGVzID0gZGVjbGFyYXRpb25RdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGZpcnN0RGVjbGFyYXRpb25Ob2RlID0gZmlyc3QoZGVjbGFyYXRpb25Ob2RlcyksXG4gICAgICAgICAgZGVjbGFyYXRpb25Ob2RlID0gZmlyc3REZWNsYXJhdGlvbk5vZGU7IC8vL1xuXG4gICAgbm9kZSA9IGRlY2xhcmF0aW9uTm9kZTsgLy8vXG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAga2V5ZnJhbWUgPSBuZXcgS2V5ZnJhbWUocGVyY2VudGFnZSwgZGVjbGFyYXRpb24pO1xuXG4gICAgcmV0dXJuIGtleWZyYW1lO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmltcG9ydCBLZXlmcmFtZSBmcm9tIFwiLi9rZXlmcmFtZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcsIFRXT19TUEFDRVMgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29udGVudFwiO1xuXG5jb25zdCBrZXlmcmFtZVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIva2V5ZnJhbWVzL2tleWZyYW1lXCIpLFxuICAgICAgaWRlbnRpZmllclF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIva2V5ZnJhbWVzL0BpZGVudGlmaWVyXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlmcmFtZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSwgaWRlbnRpZmllcikge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICB9XG5cbiAgZ2V0SWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50ICsgVFdPX1NQQUNFUztcblxuICAgIGNvbnN0IGtleWZyYW1lc0NTUyA9IHRoaXMuYXJyYXkucmVkdWNlKChrZXlmcmFtZXNDU1MsIGtleWZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZUNTUyA9IGtleWZyYW1lLmFzQ1NTKGluZGVudCk7XG5cbiAgICAgICAgICAgIGtleWZyYW1lc0NTUyArPSBrZXlmcmFtZUNTUztcblxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lc0NTUztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIGNzcyA9IGBAa2V5ZnJhbWVzICR7dGhpcy5pZGVudGlmaWVyfSB7XG4ke2tleWZyYW1lc0NTU319XG5cbmA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGtleWZyYW1lTm9kZXMgPSBrZXlmcmFtZVF1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBrZXlmcmFtZU5vZGVzLm1hcCgoa2V5ZnJhbWVOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0ga2V5ZnJhbWVOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lID0gS2V5ZnJhbWUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGlkZW50aWZpZXJDb250ZW50ID0gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMoaWRlbnRpZmllclF1ZXJ5LCBub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyQ29udGVudCwgLy8vXG4gICAgICAgICAga2V5ZnJhbWVzID0gbmV3IEtleWZyYW1lcyhhcnJheSwgaWRlbnRpZmllcik7XG5cbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmltcG9ydCBLZXlmcmFtZXMgZnJvbSBcIi4va2V5ZnJhbWVzXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3Qga2V5ZnJhbWVzUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi9zdHlsZXNoZWV0L2tleWZyYW1lc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5ZnJhbWVzcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChrZXlmcmFtZXNzKSB7XG4gICAgLy8vXG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgY29uc3QgY3NzID0gdGhpcy5hcnJheS5yZWR1Y2UoKGNzcywga2V5ZnJhbWVzKSA9PiB7XG4gICAgICBjb25zdCBrZXlmcmFtZXNDU1MgPSBrZXlmcmFtZXMuYXNDU1MoaW5kZW50KTtcblxuICAgICAgY3NzICs9IGtleWZyYW1lc0NTUztcblxuICAgICAgcmV0dXJuIGNzcztcbiAgICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBrZXlmcmFtZXNOb2RlcyA9IGtleWZyYW1lc1F1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBrZXlmcmFtZXNOb2Rlcy5tYXAoKGtleWZyYW1lc05vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBrZXlmcmFtZXNOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcyA9IEtleWZyYW1lcy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBuZXcgS2V5ZnJhbWVzcyhhcnJheSk7XG5cbiAgICByZXR1cm4ga2V5ZnJhbWVzcztcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWVkaWFzIGZyb20gXCIuL3N0eWxlL21lZGlhc1wiO1xuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3N0eWxlL3J1bGVTZXRzXCI7XG5pbXBvcnQgS2V5ZnJhbWVzcyBmcm9tIFwiLi9zdHlsZS9rZXlmcmFtZXNzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL3N0eWxlL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3R5bGUge1xuICBjb25zdHJ1Y3RvcihkZWNsYXJhdGlvbnMsIGtleWZyYW1lc3MsIHJ1bGVTZXRzLCBtZWRpYXMpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgICB0aGlzLmtleWZyYW1lc3MgPSBrZXlmcmFtZXNzO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgICB0aGlzLm1lZGlhcyA9IG1lZGlhcztcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnM7XG4gIH1cblxuICBnZXRLZXlmcmFtZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmtleWZyYW1lc3M7XG4gIH1cblxuICBnZXRSdWxlU2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlU2V0cztcbiAgfVxuXG4gIGdldE1lZGlhcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZWRpYXM7XG4gIH1cblxuICBleHRlbmRzKHN1cGVyU3R5bGUpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBzdXBlclN0eWxlLmdldERlY2xhcmF0aW9ucygpLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBzdXBlclN0eWxlLmdldEtleWZyYW1lc3MoKSxcbiAgICAgICAgICBydWxlU2V0cyA9IHN1cGVyU3R5bGUuZ2V0UnVsZVNldHMoKSxcbiAgICAgICAgICBtZWRpYXMgPSBzdXBlclN0eWxlLmdldE1lZGlhcygpO1xuXG4gICAgdGhpcy51bnNoaWZ0KGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcyk7XG4gIH1cblxuICB1bnNoaWZ0KGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcykge1xuICAgIHRoaXMuZGVjbGFyYXRpb25zLnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgICB0aGlzLmtleWZyYW1lc3MudW5zaGlmdChrZXlmcmFtZXNzKTtcbiAgICB0aGlzLnJ1bGVTZXRzLnVuc2hpZnQocnVsZVNldHMpO1xuICAgIHRoaXMubWVkaWFzLnVuc2hpZnQobWVkaWFzKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IGluZGVudCA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAga2V5ZnJhbWVzc0NTUyA9IHRoaXMua2V5ZnJhbWVzcy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgcnVsZVNldHNDU1MgPSB0aGlzLnJ1bGVTZXRzLmFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSxcbiAgICAgICAgICBtZWRpYXNDU1MgPSB0aGlzLm1lZGlhcy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgY3NzID0gYCR7ZGVjbGFyYXRpb25zQ1NTfSR7a2V5ZnJhbWVzc0NTU30ke3J1bGVTZXRzQ1NTfSR7bWVkaWFzQ1NTfWA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBLZXlmcmFtZXNzLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcnVsZVNldHMgPSBSdWxlU2V0cy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIG1lZGlhcyA9IE1lZGlhcy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHN0eWxlID0gbmV3IFN0eWxlKGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcyk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0eWxlIGZyb20gXCIuLi9zdHlsZVwiO1xuaW1wb3J0IENTU0xleGVyIGZyb20gXCIuLi9jc3MvbGV4ZXJcIjtcbmltcG9ydCBDU1NQYXJzZXIgZnJvbSBcIi4uL2Nzcy9wYXJzZXJcIjtcblxuaW1wb3J0IHsgSEVBRCwgU1RZTEUsIEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgY3NzTGV4ZXIgPSBDU1NMZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgY3NzUGFyc2VyID0gQ1NTUGFyc2VyLmZyb21Ob3RoaW5nKCk7XG5cbmlmICghZ2xvYmFsVGhpcy5zdHlsZU1hcCkge1xuICBnbG9iYWxUaGlzLnN0eWxlTWFwID0ge307XG59XG5cbmNvbnN0IHsgc3R5bGVNYXAgfSA9IGdsb2JhbFRoaXM7XG5cbmZ1bmN0aW9uIHJlbmRlclN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IGhlYWRET01FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihIRUFEKSxcbiAgICAgICAgc3R5bGVET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChTVFlMRSksXG4gICAgICAgIGlubmVySFRNTCA9IGAgICAgICAgIFxuJHtzdHlsZX1cbmA7XG5cbiAgT2JqZWN0LmFzc2lnbihzdHlsZURPTUVsZW1lbnQsIHtcbiAgICBpbm5lckhUTUxcbiAgfSk7XG5cbiAgaGVhZERPTUVsZW1lbnQuYXBwZW5kQ2hpbGQoc3R5bGVET01FbGVtZW50KTtcblxuICByZXR1cm4gc3R5bGVET01FbGVtZW50O1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdHlsZXMoKSB7XG4gIGNvbnN0IHN0eWxlc0NTUyA9IHJldHJpZXZlU3R5bGVzQ1NTKCksXG4gICAgICAgIHN0eWxlID0gc3R5bGVzQ1NTOyAgLy8vXG5cbiAgcmVuZGVyU3R5bGUoc3R5bGUpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSwgc3VwZXJTdHlsZSA9IG51bGwpIHtcbiAgY29uc3Qgc3RyaW5ncyA9IGFyZ3Muc2hpZnQoKSxcdC8vL1xuICAgICAgICBjb250ZW50ID0gc3RyaW5ncy5yZWR1Y2UoKGNvbnRlbnQsIHN0cmluZywgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XSB8fCBudWxsO1xuXG4gICAgICAgICAgY29udGVudCA9IChhcmcgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICBgJHtjb250ZW50fSR7c3RyaW5nfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7Y29udGVudH0ke3N0cmluZ30ke2FyZ31gO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0sIEVNUFRZX1NUUklORyksXG4gICAgICAgIHRva2VucyA9IGNzc0xleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3NzUGFyc2VyLnBhcnNlKHRva2VucyksXG4gICAgICAgIHN0eWxlID0gU3R5bGUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICBpZiAoc3VwZXJTdHlsZSAhPT0gbnVsbCkge1xuICAgIHN0eWxlLmV4dGVuZHMoc3VwZXJTdHlsZSk7XG4gIH1cblxuICBzdHlsZU1hcFtjbGFzc05hbWVdID0gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlU3R5bGUoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVNYXBbY2xhc3NOYW1lXSB8fCBudWxsO1xuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzLFxuICBnZW5lcmF0ZVN0eWxlLFxuICByZXRyaWV2ZVN0eWxlXG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZVN0eWxlc0NTUygpIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlTWFwKSxcbiAgICAgICAgc3R5bGVzQ1NTID0gY2xhc3NOYW1lcy5yZWR1Y2UoKHN0eWxlc0NTUywgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgc3R5bGVDU1MgPSBzdHlsZS5hc0NTUyhjbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3R5bGVzQ1NTICs9IHN0eWxlQ1NTO1xuXG4gICAgICAgICAgcmV0dXJuIHN0eWxlc0NTUztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gc3R5bGVzQ1NTO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDSEFSQUNURVJTLCBFTVBUWV9TVFJJTkcsIENMQVNTX05BTUVfTEVOR1RIIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCBsZW5ndGggPSBDTEFTU19OQU1FX0xFTkdUSCxcbiAgICAgIGNoYXJhY3RlcnMgPSBDSEFSQUNURVJTLFxuICAgICAgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuXG5jb25zdCBjbGFzc05hbWVzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNsYXNzTmFtZSgpIHtcbiAgbGV0IGNsYXNzTmFtZSA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgbGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXJzW2luZGV4XTtcblxuICAgIGNsYXNzTmFtZSArPSBjaGFyYWN0ZXI7XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUgPSBjbGFzc05hbWVzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG5cbiAgaWYgKCFjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlQ2xhc3NOYW1lKGVsZW1lbnQpIHtcbiAgY29uc3QgeyBjbGFzc05hbWUgfSA9IGVsZW1lbnQucmVhY3RGdW5jdGlvbiB8fCBlbGVtZW50LnJlYWN0Q29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2VuZXJhdGVDbGFzc05hbWUsXG4gIHJldHJpZXZlQ2xhc3NOYW1lXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHRhZ05hbWVzIH0gZnJvbSBcIi4vdGFnTmFtZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTTGV4ZXIgfSBmcm9tIFwiLi9jc3MvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTUGFyc2VyIH0gZnJvbSBcIi4vY3NzL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHlsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3R5bGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsYXNzTmFtZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc05hbWVcIjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGFzcyhhcmd1bWVudCkgeyByZXR1cm4gaXNTdWJjbGFzc09mKGFyZ3VtZW50LCBFbGVtZW50KTsgfSAgLy8vXG5cbmZ1bmN0aW9uIGlzU3ViY2xhc3NPZihhcmd1bWVudCwgQ2xhc3MpIHtcbiAgY29uc3Qgc3ViY2xhc3NPZiA9IChhcmd1bWVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBDbGFzcyk7XG5cbiAgcmV0dXJuIHN1YmNsYXNzT2Y7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FID0gXCJjbGFzc05hbWVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUmVhY3QgfSBmcm9tIFwiZWFzeVwiO1xuaW1wb3J0IHsgdGFnTmFtZXMsIHN0eWxlc1V0aWxpdGllcywgY2xhc3NOYW1lVXRpbGl0aWVzIH0gZnJvbSBcIndpdGgtc3R5bGVcIjtcblxuaW1wb3J0IHsgaXNDbGFzcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc1wiO1xuaW1wb3J0IHsgQ0xBU1NfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IGdlbmVyYXRlQ2xhc3NOYW1lIH0gPSBjbGFzc05hbWVVdGlsaXRpZXMsXG4gICAgICB7IHJlbmRlclN0eWxlLCByZW5kZXJTdHlsZXMsIGdlbmVyYXRlU3R5bGUsIHJldHJpZXZlU3R5bGUgfSA9IHN0eWxlc1V0aWxpdGllcztcblxuZnVuY3Rpb24gd2l0aFN0eWxlKENsYXNzT3JGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYXJncyA9IFsgLi4uYXJndW1lbnRzIF07ICAvLy9cblxuICAgIGxldCB7IGNsYXNzTmFtZSA9IG51bGwgfSA9IENsYXNzT3JGdW5jdGlvbjtcblxuICAgIGNvbnN0IHN1cGVyU3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSk7XG5cbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuXG4gICAgZ2VuZXJhdGVTdHlsZShhcmdzLCBjbGFzc05hbWUsIHN1cGVyU3R5bGUpO1xuXG4gICAgY29uc3QgQ2xhc3NPckZ1bmN0aW9uQ2xhc3MgPSBpc0NsYXNzKENsYXNzT3JGdW5jdGlvbik7XG5cbiAgICBpZiAoQ2xhc3NPckZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgIGNvbnN0IENsYXNzID0gQ2xhc3NPckZ1bmN0aW9uOyAgLy8vXG5cbiAgICAgIENsYXNzT3JGdW5jdGlvbiA9IGNsYXNzIGV4dGVuZHMgQ2xhc3Mge1xuICAgICAgICBzdGF0aWMgZnJvbUNsYXNzKF9DbGFzcywgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgcmV0dXJuIENsYXNzLmZyb21DbGFzcyhfQ2xhc3MsIHByb3BlcnRpZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgRnVuY3Rpb24gPSBDbGFzc09yRnVuY3Rpb247IC8vL1xuXG4gICAgICBDbGFzc09yRnVuY3Rpb24gPSAocHJvcGVydGllcykgPT4ge1xuICAgICAgICBwcm9wZXJ0aWVzID0gYXBwZW5kQ2xhc3NOYW1lVG9Qcm9wZXJ0aWVzKGNsYXNzTmFtZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKHByb3BlcnRpZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKENsYXNzT3JGdW5jdGlvbiwge1xuICAgICAgY2xhc3NOYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ2xhc3NPckZ1bmN0aW9uO1xuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKHdpdGhTdHlsZSwge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlO1xuXG50YWdOYW1lcy5mb3JFYWNoKCh0YWdOYW1lKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aXRoU3R5bGUsIHRhZ05hbWUsIHtcbiAgICBnZXQ6ICgpID0+IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYXJncyA9IFsuLi5hcmd1bWVudHNdLCAgLy8vXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuXG4gICAgICBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSk7XG5cbiAgICAgIGNvbnN0IEZ1bmN0aW9uID0gKHByb3BlcnRpZXMpID0+IHtcbiAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmFzc2lnbihGdW5jdGlvbiwge1xuICAgICAgICBjbGFzc05hbWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gRnVuY3Rpb247XG4gICAgfVxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBhcHBlbmRDbGFzc05hbWVUb1Byb3BlcnRpZXMoY2xhc3NOYW1lLCBwcm9wZXJ0aWVzKSB7XG4gIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KENMQVNTX05BTUUpID8gcHJvcGVydGllcyA6IHsgLi4ucHJvcGVydGllcywgY2xhc3NOYW1lIH07IC8vL1xuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCIuL3dpdGhTdHlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDVVJTT1IgPSBcImN1cnNvclwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgQVVUT19DVVJTT1IgPSBcImF1dG9cIjtcbmV4cG9ydCBjb25zdCBQT0lOVEVSX0NVUlNPUiA9IFwicG9pbnRlclwiO1xuZXhwb3J0IGNvbnN0IENPTF9SRVNJWkVfQ1VSU09SID0gXCJjb2wtcmVzaXplXCI7XG5leHBvcnQgY29uc3QgUk9XX1JFU0laRV9DVVJTT1IgPSBcInJvdy1yZXNpemVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQm9keSB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCB7IENVUlNPUiB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQVVUT19DVVJTT1IsIFBPSU5URVJfQ1VSU09SLCBDT0xfUkVTSVpFX0NVUlNPUiwgUk9XX1JFU0laRV9DVVJTT1IgfSBmcm9tIFwiLi9jdXJzb3JzXCI7XG5cbmNvbnN0IGJvZHkgPSBuZXcgQm9keSgpO1xuXG5sZXQgcHJldmlvdXNDdXJzb3I7ICAvLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9DdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IEFVVE9fQ1VSU09SO1xuXG4gIHVwZGF0ZUN1cnNvcihjdXJzb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDdXJzb3IoKSB7XG4gIHNldEN1cnNvcihwcmV2aW91c0N1cnNvcik7IC8vL1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlckN1cnNvcigpIHtcbiAgY29uc3QgY3Vyc29yID0gUE9JTlRFUl9DVVJTT1I7XG5cbiAgdXBkYXRlQ3Vyc29yKGN1cnNvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3dSZXNpemVDdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IFJPV19SRVNJWkVfQ1VSU09SO1xuXG4gIHVwZGF0ZUN1cnNvcihjdXJzb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sdW1uUmVzaXplQ3Vyc29yKCkge1xuICBjb25zdCBjdXJzb3IgPSBDT0xfUkVTSVpFX0NVUlNPUjtcblxuICB1cGRhdGVDdXJzb3IoY3Vyc29yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhdXRvQ3Vyc29yLFxuICByZXNldEN1cnNvcixcbiAgcG9pbnRlckN1cnNvcixcbiAgcm93UmVzaXplQ3Vyc29yLFxuICBjb2x1bW5SZXNpemVDdXJzb3Jcbn1cblxuZnVuY3Rpb24gc2V0Q3Vyc29yKGN1cnNvcikge1xuICBjb25zdCBjc3MgPSB7XG4gICAgY3Vyc29yXG4gIH07XG5cbiAgYm9keS5jc3MoY3NzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKGN1cnNvcikge1xuICBjb25zdCBjdXJyZW50Q3Vyc29yID0gZ2V0Q3VycmVudEN1cnNvcigpO1xuXG4gIGlmIChjdXJyZW50Q3Vyc29yICE9PSBjdXJzb3IpIHtcbiAgICBwcmV2aW91c0N1cnNvciA9IGN1cnJlbnRDdXJzb3I7IC8vL1xuXG4gICAgc2V0Q3Vyc29yKGN1cnNvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEN1cnNvcigpIHtcbiAgY29uc3QgY3VycmVudEN1cnNvciA9IGJvZHkuY3NzKENVUlNPUikgfHwgQVVUT19DVVJTT1I7XG5cbiAgcmV0dXJuIGN1cnJlbnRDdXJzb3I7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBSb3dEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwicm93XCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFJvd0RpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgUm93c0RpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJyb3dzXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFJvd3NEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZ3JvdzogMTtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmNsYXNzIENvbHVtbkRpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb2x1bW5cIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoQ29sdW1uRGl2KWBcblxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWdyb3c6IDE7XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBDb2x1bW5zRGl2IGV4dGVuZHMgRWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImNvbHVtbnNcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoQ29sdW1uc0RpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfRFJBR0dJTkdfREVMQVkgPSAxNzU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50KGRyYWdFbGVtZW50LCBkcm9wRWxlbWVudCkge1xuICBjb25zdCByZWZlcmVuY2UgPSBkcm9wRWxlbWVudC5nZXRSZWZlcmVuY2UoKSxcbiAgICAgICAgcmVmZXJlbmNlcyA9IGRyYWdFbGVtZW50LmdldFJlZmVyZW5jZXMoKSxcbiAgICAgICAgcmVmZXJlbmNlc0luY2x1ZGVzUmVmZXJlbmNlID0gcmVmZXJlbmNlcy5pbmNsdWRlcyhyZWZlcmVuY2UpLFxuICAgICAgICBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9ICFyZWZlcmVuY2VzSW5jbHVkZXNSZWZlcmVuY2U7XG5cbiAgcmV0dXJuIGRyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50O1xufSIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdXNlVG9wRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IHsgcGFnZVkgfSA9IGV2ZW50LFxuICAgICAgICBtb3VzZVRvcCA9IHBhZ2VZOyAvLy9cblxuICByZXR1cm4gbW91c2VUb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VzZUxlZnRGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgeyBwYWdlWCB9ID0gZXZlbnQsXG4gICAgICAgIG1vdXNlTGVmdCA9IHBhZ2VYOyAgLy8vXG5cbiAgcmV0dXJuIG1vdXNlTGVmdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcImRyYWdcIjtcbmV4cG9ydCBjb25zdCBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFID0gXCJkcm9wXCI7XG5leHBvcnQgY29uc3QgRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcImRyYWctb3V0XCI7XG5leHBvcnQgY29uc3QgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFID0gXCJkcmFnLW92ZXJcIjtcbmV4cG9ydCBjb25zdCBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcInN0b3AtZHJhZ1wiO1xuZXhwb3J0IGNvbnN0IFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcInN0YXJ0LWRyYWdcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBEUkFHX09VVF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gIFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGtleUNvZGVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiIDtcbmltcG9ydCB7IHdpbmRvdywgbW91c2VCdXR0b25zIH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IHsgU1RBUlRfRFJBR0dJTkdfREVMQVkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9yZWZlcmVuY2VcIjtcbmltcG9ydCB7IG1vdXNlVG9wRnJvbUV2ZW50LCBtb3VzZUxlZnRGcm9tRXZlbnQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2V2ZW50XCI7XG5pbXBvcnQgeyBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLCBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsIFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vY3VzdG9tRXZlbnRUeXBlc1wiO1xuXG5jb25zdCB7IEVTQ0FQRV9LRVlfQ09ERSB9ID0ga2V5Q29kZXMsXG4gICAgICB7IExFRlRfTU9VU0VfQlVUVE9OIH0gPSBtb3VzZUJ1dHRvbnM7XG5cbmZ1bmN0aW9uIGdldERyYWdFbGVtZW50KCkge1xuICBjb25zdCB7IGRyYWdFbGVtZW50IH0gPSBnbG9iYWxUaGlzO1xuXG4gIHJldHVybiBkcmFnRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gc2V0RHJhZ0VsZW1lbnQoZHJhZ0VsZW1lbnQpIHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gICAgZHJhZ0VsZW1lbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0RHJhZ0VsZW1lbnQoKSB7XG4gIGNvbnN0IGRyYWdFbGVtZW50ID0gbnVsbDtcblxuICBzZXREcmFnRWxlbWVudChkcmFnRWxlbWVudCk7XG59XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywge1xuICBnZXREcmFnRWxlbWVudCxcbiAgc2V0RHJhZ0VsZW1lbnQsXG4gIHJlc2V0RHJhZ0VsZW1lbnRcbn0pO1xuXG5yZXNldERyYWdFbGVtZW50KCk7XG5cbmZ1bmN0aW9uIGVuYWJsZURyYWcoKSB7XG4gIGNvbnN0IHRpbWVvdXQgPSBudWxsLFxuICAgICAgICB0b3BPZmZzZXQgPSBudWxsLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgZHJhZ0VuYWJsZWQgPSB0cnVlLFxuICAgICAgICBzdGFydE1vdXNlVG9wID0gbnVsbCxcbiAgICAgICAgc3RhcnRNb3VzZUxlZnQgPSBudWxsO1xuXG4gIHRoaXMub25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgdGltZW91dCxcbiAgICB0b3BPZmZzZXQsXG4gICAgbGVmdE9mZnNldCxcbiAgICBkcmFnRW5hYmxlZCxcbiAgICBzdGFydE1vdXNlVG9wLFxuICAgIHN0YXJ0TW91c2VMZWZ0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlRHJhZygpIHtcbiAgY29uc3QgZHJhZ0VuYWJsZWQgPSBmYWxzZTtcblxuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBkcmFnRW5hYmxlZFxuICB9KTtcblxuICB0aGlzLm9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25DdXN0b21EcmFnKGRyYWdDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnKGRyYWdDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub2ZmQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb25DdXN0b21TdG9wRHJhZyhzdG9wRHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RPUF9EUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gc3RvcERyYWdDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZkN1c3RvbVN0b3BEcmFnKHN0b3BEcmFnQ3VzdG9tSGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBjdXN0b21FdmVudFR5cGUgPSBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBzdG9wRHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9uQ3VzdG9tU3RhcnREcmFnKHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RBUlRfRFJBR19DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9uQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb2ZmQ3VzdG9tU3RhcnREcmFnKHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RBUlRfRFJBR19DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzRHJhZ0VuYWJsZWQoKSB7XG4gIGNvbnN0IHsgZHJhZ0VuYWJsZWQgPSBmYWxzZSB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBkcmFnRW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmhhc0NsYXNzKFwiZHJhZ2dpbmdcIik7XG5cbiAgcmV0dXJuIGRyYWdnaW5nO1xufVxuXG5mdW5jdGlvbiBzdGFydERyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgYm91bmRzVG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICBib3VuZHNMZWZ0ID0gYm91bmRzLmdldExlZnQoKSxcbiAgICAgICAgYm91bmRzUmlnaHQgPSBib3VuZHMuZ2V0UmlnaHQoKSxcbiAgICAgICAgYm91bmRzQm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kc1JpZ2h0IC0gYm91bmRzTGVmdCxcbiAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzQm90dG9tIC0gYm91bmRzVG9wLFxuICAgICAgICB0b3BPZmZzZXQgPSBNYXRoLmZsb29yKGJvdW5kc0hlaWdodCAvIDIpLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gTWF0aC5mbG9vcihib3VuZHNXaWR0aCAvIDIpLFxuICAgICAgICBkcmFnRWxlbWVudCA9IHRoaXMsIC8vL1xuICAgICAgICBzdGFydE1vdXNlVG9wID0gbW91c2VUb3AsIC8vL1xuICAgICAgICBzdGFydE1vdXNlTGVmdCA9IG1vdXNlTGVmdCwgLy8vXG4gICAgICAgIGN1c3RvbUV2ZW50VHlwZSA9IFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEU7XG5cbiAgd2luZG93Lm9uS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9uTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIHRoaXMpO1xuXG4gIHRoaXMuYWRkQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICBzZXREcmFnRWxlbWVudChkcmFnRWxlbWVudCk7XG5cbiAgdGhpcy5zZXRUb3BPZmZzZXQodG9wT2Zmc2V0KTtcblxuICB0aGlzLnNldExlZnRPZmZzZXQobGVmdE9mZnNldCk7XG5cbiAgdGhpcy5zZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApO1xuXG4gIHRoaXMuc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpO1xuXG4gIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQpO1xuXG4gIHRoaXMuZHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BEcmFnKGV2ZW50LCBlbGVtZW50LCBhYm9ydGVkKSB7XG4gIGNvbnN0IGRyb3BFbGVtZW50ID0gZ2V0RHJvcEVsZW1lbnQoKSxcbiAgICAgICAgY3VzdG9tRXZlbnRUeXBlID0gU1RPUF9EUkFHX0NVU1RPTV9FVkVOVF9UWVBFO1xuXG4gIHRoaXMucmVtb3ZlQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICB3aW5kb3cub2ZmS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9mZk1vdXNlTW92ZShtb3VzZU1vdmVIYW5kbGVyLCB0aGlzKTtcblxuICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzQXN5bmMoY3VzdG9tRXZlbnRUeXBlLCBldmVudCwgZWxlbWVudCwgZHJvcEVsZW1lbnQsIGFib3J0ZWQsICgpID0+IHtcbiAgICAgIHJlc2V0RHJhZ0VsZW1lbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkcm9wRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxldCBkcmFnRWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgY29uc3QgZHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQgPSBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50KGRyYWdFbGVtZW50LCBkcm9wRWxlbWVudCk7XG5cbiAgICBpZiAoZHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQpIHtcbiAgICAgIGRyYWdFbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkcm9wRWxlbWVudC5kcm9wKGV2ZW50LCBlbGVtZW50LCBkcmFnRWxlbWVudCwgYWJvcnRlZCwgZG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LmdldFNjcm9sbFRvcCgpLFxuICAgICAgICBzY3JvbGxMZWZ0ID0gd2luZG93LmdldFNjcm9sbExlZnQoKSxcbiAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICBzdGFydE1vdXNlVG9wID0gdGhpcy5nZXRTdGFydE1vdXNlVG9wKCksXG4gICAgICAgIHN0YXJ0TW91c2VMZWZ0ID0gdGhpcy5nZXRTdGFydE1vdXNlTGVmdCgpLFxuICAgICAgICBjdXN0b21FdmVudFR5cGUgPSBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICByZWxhdGl2ZU1vdXNlVG9wID0gbW91c2VUb3AgLSBzdGFydE1vdXNlVG9wLFxuICAgICAgICByZWxhdGl2ZU1vdXNlTGVmdCA9IG1vdXNlTGVmdCAtIHN0YXJ0TW91c2VMZWZ0O1xuXG4gIGxldCB0b3AgPSBzdGFydE1vdXNlVG9wICsgcmVsYXRpdmVNb3VzZVRvcCAtIHRvcE9mZnNldCAtIHNjcm9sbFRvcCxcbiAgICAgIGxlZnQgPSBzdGFydE1vdXNlTGVmdCArIHJlbGF0aXZlTW91c2VMZWZ0IC0gbGVmdE9mZnNldCAtIHNjcm9sbExlZnQ7XG5cbiAgdG9wID0gYCR7dG9wfXB4YDsgLy8vXG4gIGxlZnQgPSBgJHtsZWZ0fXB4YDsgLy8vXG5cbiAgY29uc3QgY3NzID0ge1xuICAgIHRvcCxcbiAgICBsZWZ0XG4gIH07XG5cbiAgdGhpcy5jc3MoY3NzKTtcblxuICB0aGlzLmNhbGxDdXN0b21IYW5kbGVycyhjdXN0b21FdmVudFR5cGUsIGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2FpdGluZ1RvRHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCkge1xuICBsZXQgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ID09PSBudWxsKSB7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcblxuICAgICAgdGhpcy5zdGFydERyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpO1xuICAgIH0sIFNUQVJUX0RSQUdHSU5HX0RFTEFZKTtcblxuICAgIHRoaXMudXBkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV2FpdGluZ1RvRHJhZygpIHtcbiAgY29uc3QgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0KCkge1xuICBjb25zdCB7IHRpbWVvdXQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICByZXR1cm4gdGltZW91dDtcbn1cblxuZnVuY3Rpb24gcmVzZXRUaW1lb3V0KCkge1xuICBjb25zdCB0aW1lb3V0ID0gbnVsbDtcblxuICB0aGlzLnVwZGF0ZVRpbWVvdXQodGltZW91dCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVvdXQodGltZW91dCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0aW1lb3V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BPZmZzZXQoKSB7XG4gIGNvbnN0IHsgdG9wT2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIHRvcE9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCgpIHtcbiAgY29uc3QgeyBsZWZ0T2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIGxlZnRPZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0TW91c2VUb3AoKSB7XG4gIGNvbnN0IHsgc3RhcnRNb3VzZVRvcCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlVG9wO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydE1vdXNlTGVmdCgpIHtcbiAgY29uc3QgeyBzdGFydE1vdXNlTGVmdCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlTGVmdDtcbn1cblxuZnVuY3Rpb24gc2V0VG9wT2Zmc2V0KHRvcE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0b3BPZmZzZXRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldExlZnRPZmZzZXQobGVmdE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBsZWZ0T2Zmc2V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZVRvcFxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZUxlZnRcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW5hYmxlRHJhZyxcbiAgZGlzYWJsZURyYWcsXG4gIG9uQ3VzdG9tRHJhZyxcbiAgb2ZmQ3VzdG9tRHJhZyxcbiAgb25DdXN0b21TdG9wRHJhZyxcbiAgb2ZmQ3VzdG9tU3RvcERyYWcsXG4gIG9uQ3VzdG9tU3RhcnREcmFnLFxuICBvZmZDdXN0b21TdGFydERyYWcsXG4gIGlzRHJhZ0VuYWJsZWQsXG4gIGlzRHJhZ2dpbmcsXG4gIHN0YXJ0RHJhZyxcbiAgc3RvcERyYWcsXG4gIGRyYWcsXG4gIHN0YXJ0V2FpdGluZ1RvRHJhZyxcbiAgc3RvcFdhaXRpbmdUb0RyYWcsXG4gIGdldFRpbWVvdXQsXG4gIHJlc2V0VGltZW91dCxcbiAgdXBkYXRlVGltZW91dCxcbiAgZ2V0VG9wT2Zmc2V0LFxuICBnZXRMZWZ0T2Zmc2V0LFxuICBnZXRTdGFydE1vdXNlVG9wLFxuICBnZXRTdGFydE1vdXNlTGVmdCxcbiAgc2V0VG9wT2Zmc2V0LFxuICBzZXRMZWZ0T2Zmc2V0LFxuICBzZXRTdGFydE1vdXNlVG9wLFxuICBzZXRTdGFydE1vdXNlTGVmdFxufTtcblxuZnVuY3Rpb24ga2V5RG93bkhhbmRsZXIoZXZlbnQsIGVsZW1lbnQpIHtcbiAgY29uc3QgeyBrZXlDb2RlIH0gPSBldmVudCxcbiAgICAgICAgZXNjYXBlS2V5ID0gKGtleUNvZGUgPT09IEVTQ0FQRV9LRVlfQ09ERSksXG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuXG4gIGlmIChlc2NhcGVLZXkpIHtcbiAgICB0aGlzLnN0b3BEcmFnKGV2ZW50LCBlbGVtZW50LCBhYm9ydGVkKTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNlVXBIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCksXG4gICAgICAgIGFib3J0ZWQgPSBmYWxzZTtcblxuICBkcmFnZ2luZyA/XG4gICAgdGhpcy5zdG9wRHJhZyhldmVudCwgZWxlbWVudCwgYWJvcnRlZCkgOlxuICAgICAgdGhpcy5zdG9wV2FpdGluZ1RvRHJhZygpO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIHdpbmRvdy5vZmZCbHVyKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTsgIC8vL1xuXG4gIHdpbmRvdy5vZmZNb3VzZVVwKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gbW91c2VEb3duSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCB7IGJ1dHRvbiB9ID0gZXZlbnQ7XG5cbiAgaWYgKGJ1dHRvbiA9PT0gTEVGVF9NT1VTRV9CVVRUT04pIHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpO1xuXG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgY29uc3QgbW91c2VUb3AgPSBtb3VzZVRvcEZyb21FdmVudChldmVudCksXG4gICAgICAgICAgICBtb3VzZUxlZnQgPSBtb3VzZUxlZnRGcm9tRXZlbnQoZXZlbnQpO1xuXG4gICAgICB0aGlzLnN0YXJ0V2FpdGluZ1RvRHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gICAgfVxuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgd2luZG93Lm9uQmx1cihtb3VzZVVwSGFuZGxlciwgdGhpcyk7IC8vL1xuXG4gIHdpbmRvdy5vbk1vdXNlVXAobW91c2VVcEhhbmRsZXIsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBtb3VzZU1vdmVIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XG5cbiAgaWYgKGRyYWdnaW5nKSB7XG4gICAgY29uc3QgbW91c2VUb3AgPSBtb3VzZVRvcEZyb21FdmVudChldmVudCksXG4gICAgICAgICAgbW91c2VMZWZ0ID0gbW91c2VMZWZ0RnJvbUV2ZW50KGV2ZW50KTtcblxuICAgIHRoaXMuZHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hlY2tEcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFLCBEUkFHX09VVF9DVVNUT01fRVZFTlRfVFlQRSwgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2N1c3RvbUV2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gZ2V0RHJvcEVsZW1lbnQoKSB7XG4gIGNvbnN0IHsgZHJvcEVsZW1lbnQgfSA9IGdsb2JhbFRoaXM7XG5cbiAgcmV0dXJuIGRyb3BFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBzZXREcm9wRWxlbWVudChkcm9wRWxlbWVudCkge1xuICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgICBkcm9wRWxlbWVudFxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXREcm9wRWxlbWVudCgpIHtcbiAgY29uc3QgZHJvcEVsZW1lbnQgPSBudWxsO1xuXG4gIHNldERyb3BFbGVtZW50KGRyb3BFbGVtZW50KTtcbn1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gIGdldERyb3BFbGVtZW50LFxuICBzZXREcm9wRWxlbWVudCxcbiAgcmVzZXREcm9wRWxlbWVudFxufSk7XG5cbnJlc2V0RHJvcEVsZW1lbnQoKTtcblxuZnVuY3Rpb24gZHJvcChldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQsIGFib3J0ZWQsIGRvbmUpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRTtcblxuICB0aGlzLmNhbGxDdXN0b21IYW5kbGVyc0FzeW5jKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50LCBhYm9ydGVkLCBkb25lKTtcbn1cblxuZnVuY3Rpb24gZHJhZ091dChldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEU7XG5cbiAgdGhpcy5jYWxsQ3VzdG9tSGFuZGxlcnMoY3VzdG9tRXZlbnRUeXBlLCBldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBkcmFnT3ZlcihldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFO1xuXG4gIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRHJvcCgpIHtcbiAgdGhpcy5vbk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gIHRoaXMub25Nb3VzZU92ZXIobW91c2VPdmVySGFuZGxlciwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVEcm9wKCkge1xuICB0aGlzLm9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gIHRoaXMub2ZmTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkN1c3RvbURyb3AoZHJvcEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyb3BDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZkN1c3RvbURyb3AoZHJvcEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyb3BDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvbkN1c3RvbURyYWdPdXQoZHJhZ091dEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnT3V0Q3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnT3V0KGRyYWdPdXRDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfT1VUX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gZHJhZ091dEN1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9uQ3VzdG9tRHJhZ092ZXIoZHJhZ092ZXJDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfT1ZFUl9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyYWdPdmVyQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnT3ZlcihkcmFnT3ZlckN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gZHJhZ092ZXJDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyb3AsXG4gIGRyYWdPdXQsXG4gIGRyYWdPdmVyLFxuICBlbmFibGVEcm9wLFxuICBkaXNhYmxlRHJvcCxcbiAgb25DdXN0b21Ecm9wLFxuICBvZmZDdXN0b21Ecm9wLFxuICBvbkN1c3RvbURyYWdPdXQsXG4gIG9mZkN1c3RvbURyYWdPdXQsXG4gIG9uQ3VzdG9tRHJhZ092ZXIsXG4gIG9mZkN1c3RvbURyYWdPdmVyXG59XG5cbmZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnRWxlbWVudCA9IGdldERyYWdFbGVtZW50KCk7XG5cbiAgaWYgKGRyYWdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcmVzZXREcm9wRWxlbWVudCgpO1xuXG4gICAgdGhpcy5kcmFnT3V0KGV2ZW50LCBlbGVtZW50LCBkcmFnRWxlbWVudCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnRWxlbWVudCA9IGdldERyYWdFbGVtZW50KCk7XG5cbiAgaWYgKGRyYWdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgZHJvcEVsZW1lbnQgPSB0aGlzLCAvLy9cbiAgICAgICAgICBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9IGNoZWNrRHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQoZHJhZ0VsZW1lbnQsIGRyb3BFbGVtZW50KTtcblxuICAgIGlmIChkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldERyb3BFbGVtZW50KGRyb3BFbGVtZW50KTtcblxuICAgIHRoaXMuZHJhZ092ZXIoZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50KTtcbiAgfVxuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBkcmFnTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZHJhZ1wiO1xuXG5jbGFzcyBEcmFnRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRSZWZlcmVuY2VzKCkge1xuICAgIGNvbnN0IHsgcmVmZXJlbmNlcyA9IFtdIH0gPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgfVxuXG4gIGRpZE1vdW50KCkge1xuICAgIHRoaXMuZW5hYmxlRHJhZygpO1xuICB9XG5cbiAgd2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlRHJhZygpO1xuICB9XG5cbiAgc3RhdGljIGlnbm9yZWRQcm9wZXJ0aWVzID0gW1xuICAgIFwicmVmZXJlbmNlc1wiXG4gIF07XG59XG5cbk9iamVjdC5hc3NpZ24oRHJhZ0VsZW1lbnQucHJvdG90eXBlLCBkcmFnTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKERyYWdFbGVtZW50KWBcblxuICAuZHJhZ2dpbmcge1xuICAgIHotaW5kZXg6IDE7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBkcm9wTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZHJvcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRSZWZlcmVuY2UoKSB7XG4gICAgY29uc3QgeyByZWZlcmVuY2UgPSBudWxsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlO1xuICB9XG5cbiAgZGlkTW91bnQoKSB7XG4gICAgdGhpcy5lbmFibGVEcm9wKCk7XG4gIH1cblxuICB3aWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGVEcm9wKCk7XG4gIH1cblxuICBzdGF0aWMgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgXCJyZWZlcmVuY2VcIlxuICBdO1xufVxuXG5PYmplY3QuYXNzaWduKERyb3BFbGVtZW50LnByb3RvdHlwZSwgZHJvcE1peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJhZ01peGlucyB9IGZyb20gXCIuL21peGlucy9kcmFnXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BNaXhpbnMgfSBmcm9tIFwiLi9taXhpbnMvZHJvcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcmFnRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnQvZHJhZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcm9wRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnQvZHJvcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjdXN0b21FdmVudFR5cGVzIH0gZnJvbSBcIi4vY3VzdG9tRXZlbnRUeXBlc1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgU2l6ZWFibGVEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwic2l6ZWFibGVcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoU2l6ZWFibGVEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5pbXBvcnQgeyBkcmFnTWl4aW5zIH0gZnJvbSBcImVhc3ktZHJhZy1hbmQtZHJvcFwiO1xuXG5pbXBvcnQgU2l6ZWFibGVEaXYgZnJvbSBcIi4uL2Rpdi9zaXplYWJsZVwiO1xuXG5pbXBvcnQgeyByZXNldEN1cnNvciB9IGZyb20gXCIuLi9jdXJzb3JcIjtcblxuY2xhc3MgU3BsaXR0ZXJEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RvcERyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCBkcm9wRWxlbWVudCwgYWJvcnRlZCwgZG9uZSkgPT4ge1xuICAgIHJlc2V0Q3Vyc29yKCk7XG5cbiAgICBkb25lKCk7XG4gIH1cblxuICBtb3VzZU91dEhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICByZXNldEN1cnNvcigpO1xuICB9XG5cbiAgZ2V0U2l6ZWFibGVEaXYoKSB7XG4gICAgbGV0IHNpemVhYmxlRGl2O1xuXG4gICAgY29uc3QgbmV4dFNpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXROZXh0U2libGluZ0VsZW1lbnQoKSxcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmdFbGVtZW50KCksXG4gICAgICAgICAgbmV4dFNpYmxpbmdFbGVtZW50U2l6ZWFibGVEaXYgPSAobmV4dFNpYmxpbmdFbGVtZW50IGluc3RhbmNlb2YgU2l6ZWFibGVEaXYpLFxuICAgICAgICAgIHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdiA9IChwcmV2aW91c1NpYmxpbmdFbGVtZW50IGluc3RhbmNlb2YgU2l6ZWFibGVEaXYpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nRWxlbWVudFNpemVhYmxlRGl2KSB7XG4gICAgICBzaXplYWJsZURpdiA9IG5leHRTaWJsaW5nRWxlbWVudDsgLy8vXG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgc2l6ZWFibGVEaXYgPSBwcmV2aW91c1NpYmxpbmdFbGVtZW50OyAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZWFibGVEaXY7XG4gIH1cblxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgbGV0IGRpcmVjdGlvbjtcblxuICAgIGNvbnN0IG5leHRTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdFbGVtZW50KCksXG4gICAgICAgICAgcHJldmlvdXNTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudCgpLFxuICAgICAgICAgIG5leHRTaWJsaW5nRWxlbWVudFNpemVhYmxlRGl2ID0gKG5leHRTaWJsaW5nRWxlbWVudCBpbnN0YW5jZW9mIFNpemVhYmxlRGl2KSxcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50U2l6ZWFibGVEaXYgPSAocHJldmlvdXNTaWJsaW5nRWxlbWVudCBpbnN0YW5jZW9mIFNpemVhYmxlRGl2KTtcblxuICAgIGlmIChuZXh0U2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgZGlyZWN0aW9uID0gKzE7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIGdldFJlZmVyZW5jZXMoKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICBlbmFibGUoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKTtcblxuICAgIGlmICghZHJhZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuZW5hYmxlRHJhZygpO1xuXG4gICAgICB0aGlzLm9uQ3VzdG9tRHJhZyh0aGlzLmRyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vbkN1c3RvbVN0b3BEcmFnKHRoaXMuc3RvcERyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vbkN1c3RvbVN0YXJ0RHJhZyh0aGlzLnN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKTtcblxuICAgIGlmIChkcmFnRW5hYmxlZCkge1xuICAgICAgdGhpcy5vZmZDdXN0b21TdGFydERyYWcodGhpcy5zdGFydERyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vZmZDdXN0b21TdG9wRHJhZyh0aGlzLnN0b3BEcmFnQ3VzdG9tSGFuZGxlcik7XG5cbiAgICAgIHRoaXMub2ZmQ3VzdG9tRHJhZyh0aGlzLmRyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5kaXNhYmxlRHJhZygpO1xuICAgIH1cbiAgfVxuXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKSxcbiAgICAgICAgICBkaXNhYmxlZCA9ICFkcmFnRW5hYmxlZDtcblxuICAgIHJldHVybiBkaXNhYmxlZDtcbiAgfVxuXG4gIGRpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQgPSBmYWxzZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uTW91c2VPdmVyKHRoaXMubW91c2VPdmVySGFuZGxlcik7XG5cbiAgICB0aGlzLm9uTW91c2VPdXQodGhpcy5tb3VzZU91dEhhbmRsZXIpO1xuICB9XG5cbiAgd2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKTtcblxuICAgIHRoaXMub2ZmTW91c2VPdXQodGhpcy5tb3VzZU91dEhhbmRsZXIpO1xuXG4gICAgdGhpcy5vZmZNb3VzZU92ZXIodGhpcy5tb3VzZU92ZXJIYW5kbGVyKTtcblxuICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpc2UoKSB7XG4gICAgdGhpcy5zZXRJbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgXCJkaXNhYmxlZFwiXG4gIF07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJzcGxpdHRlclwiXG4gIH07XG59XG5cbk9iamVjdC5hc3NpZ24oU3BsaXR0ZXJEaXYucHJvdG90eXBlLCBkcmFnTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFNwbGl0dGVyRGl2KWBcblxuICBmbGV4LXNocmluazogMDtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IFNwbGl0dGVyIGZyb20gXCIuLi9zcGxpdHRlclwiO1xuXG5pbXBvcnQgeyBjb2x1bW5SZXNpemVDdXJzb3IgfSBmcm9tIFwiLi4vLi4vY3Vyc29yXCI7XG5cbmNsYXNzIFZlcnRpY2FsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gc2l6ZWFibGVEaXYuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSBzaXplYWJsZURpdldpZHRoOyAgLy8vXG5cbiAgICB0aGlzLnNldFByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aChwcmV2aW91c1NpemVhYmxlRGl2V2lkdGgpO1xuXG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIGRyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdldpZHRoID0gdGhpcy5nZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSxcbiAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gcHJldmlvdXNTaXplYWJsZURpdldpZHRoIC0gZGlyZWN0aW9uICogcmVsYXRpdmVNb3VzZUxlZnQsXG4gICAgICAgICAgd2lkdGggPSBzaXplYWJsZURpdldpZHRoOyAvLy9cblxuICAgIHNpemVhYmxlRGl2LnNldFdpZHRoKHdpZHRoKTtcbiAgfVxuXG4gIG1vdXNlT3ZlckhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICB0aGlzLnNldEN1cnNvcigpO1xuICB9XG5cbiAgc2V0Q3Vyc29yKCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5pc0Rpc2FibGVkKCk7XG5cbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICBjb2x1bW5SZXNpemVDdXJzb3IoKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSB7XG4gICAgY29uc3QgeyBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIHJldHVybiBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGg7XG4gIH1cblxuICBzZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgocHJldmlvdXNTaXplYWJsZURpdldpZHRoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGhcbiAgICB9KTtcbiAgfVxuXG4gIHNldEluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSBudWxsO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGhcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwidmVydGljYWxcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVmVydGljYWxTcGxpdHRlcilgXG5cbiAgd2lkdGg6IDFyZW07XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCBTcGxpdHRlciBmcm9tIFwiLi4vc3BsaXR0ZXJcIjtcblxuaW1wb3J0IHsgcm93UmVzaXplQ3Vyc29yIH0gZnJvbSBcIi4uLy4uL2N1cnNvclwiO1xuXG5jbGFzcyBIb3Jpem9udGFsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICBzaXplYWJsZURpdkhlaWdodCA9IHNpemVhYmxlRGl2LmdldEhlaWdodCgpLFxuICAgICAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgPSBzaXplYWJsZURpdkhlaWdodDsgIC8vL1xuXG4gICAgdGhpcy5zZXRQcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQpO1xuXG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIGRyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IHRoaXMuZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpLFxuICAgICAgICAgIHNpemVhYmxlRGl2SGVpZ2h0ID0gcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCAtIGRpcmVjdGlvbiAqIHJlbGF0aXZlTW91c2VUb3AsXG4gICAgICAgICAgaGVpZ2h0ID0gc2l6ZWFibGVEaXZIZWlnaHQ7IC8vL1xuXG4gICAgc2l6ZWFibGVEaXYuc2V0SGVpZ2h0KGhlaWdodCk7XG4gIH1cblxuICBtb3VzZU92ZXJIYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50KSA9PiB7XG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIHNldEN1cnNvcigpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgcm93UmVzaXplQ3Vyc29yKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpIHtcbiAgICBjb25zdCB7IHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIHJldHVybiBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0O1xuICB9XG5cbiAgc2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodChwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBzZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiaG9yaXpvbnRhbFwiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShIb3Jpem9udGFsU3BsaXR0ZXIpYFxuXG4gIGhlaWdodDogMXJlbTtcblxuYDtcbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3Vyc29yIH0gZnJvbSBcIi4vY3Vyc29yXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm93RGl2IH0gZnJvbSBcIi4vZGl2L3Jvd1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb3dzRGl2IH0gZnJvbSBcIi4vZGl2L3Jvd3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sdW1uRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2x1bW5zRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtbnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2l6ZWFibGVEaXYgfSBmcm9tIFwiLi9kaXYvc2l6ZWFibGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmVydGljYWxTcGxpdHRlckRpdiB9IGZyb20gXCIuL2Rpdi9zcGxpdHRlci92ZXJ0aWNhbFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIb3Jpem9udGFsU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXIvaG9yaXpvbnRhbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBsZXZlbHMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmV4cG9ydCBjb25zdCB7IFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwgfSA9IGxldmVscztcblxuZXhwb3J0IGNvbnN0IExFVkVMUyA9IFtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTFxuXTtcblxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgU0lOR0xFX1NQQUNFID0gXCIgXCI7XG5leHBvcnQgY29uc3QgRE9VQkxFX1NQQUNFID0gXCIgIFwiO1xuZXhwb3J0IGNvbnN0IEJSRUFLX01FU1NBR0UgPSBcIjo6IEJSRUFLIDo6XCI7XG5leHBvcnQgY29uc3QgTEVWRUxfTUFYSU1VTV9MRU5HVEggPSA3O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBMRVZFTFMsIFNJTkdMRV9TUEFDRSwgRU1QVFlfU1RSSU5HLCBMRVZFTF9NQVhJTVVNX0xFTkdUSCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCBbIFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwgXSA9IExFVkVMUztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZXMsIGxvZ0xldmVsLCBmb2xsb3cpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgIHRoaXMuZm9sbG93ID0gZm9sbG93O1xuICB9XG5cbiAgZ2V0TWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XG4gIH1cblxuICBnZXRMb2dMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dMZXZlbDtcbiAgfVxuXG4gIGdldEZvbGxvdygpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xsb3c7XG4gIH1cblxuICB0cmFjZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBUUkFDRV9MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gREVCVUdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGluZm8obWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gSU5GT19MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd2FybmluZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBXQVJOSU5HX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZShsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBlcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBFUlJPUl9MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd3JpdGUobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoID0gbnVsbCwgbGluZUluZGV4ID0gbnVsbCkge1xuICAgIGNvbnN0IGxldmVsSW5kZXggPSBMRVZFTFMuaW5kZXhPZihsZXZlbCksXG4gICAgICAgICAgbG9nTGV2ZWxJbmRleCA9IExFVkVMUy5pbmRleE9mKHRoaXMubG9nTGV2ZWwpO1xuXG4gICAgaWYgKGxldmVsSW5kZXggPCBsb2dMZXZlbEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpOyAgLy8vXG5cbiAgICB0aGlzLmZvbGxvdyA/XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKSA6XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IG51bGwsXG4gICAgICAgICAgbG9nTGV2ZWwgPSBUUkFDRV9MRVZFTCxcbiAgICAgICAgICBmb2xsb3cgPSB0cnVlLFxuICAgICAgICAgIGxvZyA9IG5ldyBMb2cobWVzc2FnZXMsIGxvZ0xldmVsLCBmb2xsb3cpO1xuXG4gICAgcmV0dXJuIGxvZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRm9sbG93QW5kTG9nTGV2ZWwoZm9sbG93LCBsb2dMZXZlbCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gZm9sbG93ID9cbiAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgbG9nID0gbmV3IExvZyhtZXNzYWdlcywgbG9nTGV2ZWwsIGZvbGxvdyk7XG5cbiAgICByZXR1cm4gbG9nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpIHtcbiAgbGV0IGZvcm1hdHRlZE1lc3NhZ2UgPSBFTVBUWV9TVFJJTkc7XG5cbiAgY29uc3QgbGVmdFBhZGRlZExldmVsID0gbGVmdFBhZExldmVsKGxldmVsKSxcbiAgICAgICAgdXBwZXJDYXNlTGVmdFBhZGRlZExldmVsID0gbGVmdFBhZGRlZExldmVsLnRvVXBwZXJDYXNlKCk7XG5cbiAgZm9ybWF0dGVkTWVzc2FnZSArPSBgJHt1cHBlckNhc2VMZWZ0UGFkZGVkTGV2ZWx9OiBgO1xuXG4gIGlmIChmaWxlUGF0aCAhPT0gbnVsbCkge1xuICAgIGZvcm1hdHRlZE1lc3NhZ2UgKz0gYCR7ZmlsZVBhdGh9IGA7XG4gIH1cblxuICBpZiAobGluZUluZGV4ICE9PSBudWxsKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgWyR7bGluZUluZGV4fV0gYDtcbiAgfVxuXG4gIGlmICgoZmlsZVBhdGggIT09IG51bGwpIHx8IChsaW5lSW5kZXggIT09IG51bGwpKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgLSBgO1xuICB9XG5cbiAgZm9ybWF0dGVkTWVzc2FnZSArPSBtZXNzYWdlO1xuXG4gIG1lc3NhZ2UgPSBmb3JtYXR0ZWRNZXNzYWdlOyAvLy9cblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZExldmVsKGxldmVsKSB7XG4gIGNvbnN0IG1heGltdW1MZW5ndGggPSBMRVZFTF9NQVhJTVVNX0xFTkdUSCxcbiAgICAgICAgbGVmdFBhZGRlZExldmVsID0gbGVmdFBhZChsZXZlbCwgbWF4aW11bUxlbmd0aCk7XG5cbiAgcmV0dXJuIGxlZnRQYWRkZWRMZXZlbDtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZChzdHJpbmcsIG1heGltdW1MZW5ndGgpIHtcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgbGVuZ3RoID0gbWF4aW11bUxlbmd0aCAtIHN0cmluZ0xlbmd0aCxcbiAgICAgICAgaW5kZW50ID0gU0lOR0xFX1NQQUNFLnJlcGVhdChsZW5ndGgpLFxuICAgICAgICBsZWZ0UGFkZGVkU3RyaW5nID0gYCR7aW5kZW50fSR7c3RyaW5nfWA7XG5cbiAgcmV0dXJuIGxlZnRQYWRkZWRTdHJpbmc7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgfVxuXG4gIGdldFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gIH1cblxuICBnZXROb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgc2V0U3RyaW5nKHN0cmluZykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICB9XG5cbiAgc2V0Tm9kZShub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGFzeW5jIGJyZWFrKGNvbnRleHQpIHtcbiAgICBhd2FpdCBjb250ZXh0LmJyZWFrKHRoaXMubm9kZSk7XG4gIH1cblxuICBtYXRjaE5vZGUobm9kZSkgeyByZXR1cm4gdGhpcy5ub2RlLm1hdGNoKG5vZGUpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERPVUJMRV9TUEFDRSwgVFJBQ0VfTEVWRUwsIERFQlVHX0xFVkVMLCBJTkZPX0xFVkVMLCBFUlJPUl9MRVZFTCwgV0FSTklOR19MRVZFTCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICBnZXREZXB0aCgpIHtcbiAgICBsZXQgZGVwdGggPSB0aGlzLmNvbnRleHQuZ2V0RGVwdGgoKTtcblxuICAgIGRlcHRoKys7XG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBnZXRSZWxlYXNlQ29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRSZWxlYXNlQ29udGV4dCgpOyB9XG5cbiAgbm9kZXNBc1N0cmluZyhub2RlKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZXNBc1N0cmluZyhub2RlKTsgfVxuXG4gIG5vZGVBc1N0cmluZyhub2RlKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpOyB9XG5cbiAgdHJhY2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gVFJBQ0VfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gREVCVUdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgaW5mbyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBJTkZPX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHdhcm5pbmcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gV0FSTklOR19MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBlcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBFUlJPUl9MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICB3cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZGVwdGggPSB0aGlzLmdldERlcHRoKCksXG4gICAgICAgICAgaW5kZW50ID0gRE9VQkxFX1NQQUNFLnJlcGVhdChkZXB0aCk7XG5cbiAgICBtZXNzYWdlID0gYCR7aW5kZW50fSR7bWVzc2FnZX1gOyAgLy8vXG5cbiAgICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHRoaXMuZ2V0UmVsZWFzZUNvbnRleHQoKTtcblxuICAgIHJlbGVhc2VDb250ZXh0LndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsobm9kZSkgeyBhd2FpdCB0aGlzLmNvbnRleHQuYnJlYWsobm9kZSk7IH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBjb250ZXh0ID0gcmVtYWluaW5nQXJndW1lbnRzLnBvcCgpO1xuXG4gICAgY29udGV4dCA9IG5ldyBDbGFzcyhjb250ZXh0LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpOyAgLy8vXG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZUluZGV4RnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gIGxldCBsaW5lSW5kZXggPSAwO1xuXG4gIGNvbnN0IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9kZS5nZXRGaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gIHRva2Vucy5zb21lKCh0b2tlbiwgdG9rZW5JbmRleCkgPT4ge1xuICAgIGNvbnN0IHRva2VuRW5kT2ZMaW5lVG9rZW4gPSB0b2tlbi5pc0VuZE9mTGluZVRva2VuKCk7XG5cbiAgICBpZiAodG9rZW5FbmRPZkxpbmVUb2tlbikge1xuICAgICAgbGluZUluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuSW5kZXggPT09IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsaW5lSW5kZXg7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVBc1N0cmluZyhub2RlLCB0b2tlbnMpIHtcbiAgbGV0IHN0cmluZztcblxuICB0b2tlbnMgPSBub2RlQXNUb2tlbnMobm9kZSwgdG9rZW5zKTsgIC8vL1xuXG4gIHN0cmluZyA9IHRva2Vuc0FzU3RyaW5nKHRva2Vucyk7XG5cbiAgc3RyaW5nID0gdHJpbVN0cmluZyhzdHJpbmcpOyAgLy8vXG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzQXNTdHJpbmcobm9kZXMsIHRva2Vucykge1xuICBjb25zdCBzdHJpbmcgPSBub2Rlcy5yZWR1Y2UoKHN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IG5vZGVTdHJpbmcgPSBub2RlQXNTdHJpbmcobm9kZSwgdG9rZW5zKTtcblxuICAgIHN0cmluZyA9IChzdHJpbmcgPT09IG51bGwpID9cbiAgICAgIG5vZGVTdHJpbmcgOlxuICAgICAgYCR7c3RyaW5nfSwgJHtub2RlU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBudWxsKTtcblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5vZGVBc1N0cmluZyxcbiAgbm9kZXNBc1N0cmluZyxcbn07XG5cbmZ1bmN0aW9uIHRyaW1TdHJpbmcoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXHMrJC8sIEVNUFRZX1NUUklORyk7ICAvLy9cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b2tlbnNBc1N0cmluZyh0b2tlbnMpIHtcbiAgY29uc3Qgc3RyaW5nID0gdG9rZW5zLnJlZHVjZSgoc3RyaW5nLCB0b2tlbikgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0b2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICBzdHJpbmcgPSBgJHtzdHJpbmd9JHtjb250ZW50fWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIG5vZGVBc1Rva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgIHRva2VucyA9IHRlcm1pbmFsTm9kZUFzVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlOyAvLy9cblxuICAgIHRva2VucyA9IG5vblRlcm1pbmFsTm9kZUFzVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIHRlcm1pbmFsTm9kZUFzVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gIGNvbnN0IHNpZ25pZmljYW50VG9rZW4gPSB0ZXJtaW5hbE5vZGUuZ2V0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICB0b2tlbiA9IHNpZ25pZmljYW50VG9rZW47IC8vL1xuXG4gIHRva2VucyA9IFsgIC8vL1xuICAgIHRva2VuXG4gIF07XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gbm9uVGVybWluYWxOb2RlQXNUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgY29uc3QgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgIHN0YXJ0ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgsIC8vL1xuICAgICAgICBlbmQgPSBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICsgMTtcblxuICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICByZXR1cm4gdG9rZW5zO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQ29udGV4dCBmcm9tICcuLi9jb250ZXh0JztcblxuaW1wb3J0IHsgbGluZUluZGV4RnJvbU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2xpbmVJbmRleFwiO1xuaW1wb3J0IHsgbm9kZUFzU3RyaW5nLCBub2Rlc0FzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIGZpbGVDb250ZW50LCBmaWxlUGF0aCwgdG9rZW5zLCBub2RlKSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG5cbiAgICB0aGlzLmZpbGVDb250ZW50ID0gZmlsZUNvbnRlbnQ7XG4gICAgdGhpcy5maWxlUGF0aCA9IGZpbGVQYXRoO1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH1cblxuICBnZXRGaWxlQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlQ29udGVudDtcbiAgfVxuXG4gIGdldEZpbGVQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVQYXRoO1xuICB9XG5cbiAgZ2V0VG9rZW5zKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIGdldE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGdldExleGVyKCkge1xuICAgIGNvbnN0IGxleGVyID0gbnVsbDtcblxuICAgIHJldHVybiBsZXhlcjtcbiAgfVxuXG4gIGdldFBhcnNlcigpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIHBhcnNlcjtcbiAgfVxuXG4gIGdldFR5cGVQcmVmaXgoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgIHR5cGVQcmVmaXggPSBjb250ZXh0LmdldFR5cGVQcmVmaXgoKTtcblxuICAgIHJldHVybiB0eXBlUHJlZml4O1xuICB9XG5cbiAgbWF0Y2hGaWxlUGF0aChmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVQYXRoTWF0Y2hlcyA9ICh0aGlzLmZpbGVQYXRoID09PSBmaWxlUGF0aCk7XG5cbiAgICByZXR1cm4gZmlsZVBhdGhNYXRjaGVzO1xuICB9XG5cbiAgbm9kZUFzU3RyaW5nKG5vZGUpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBub2RlQXNTdHJpbmcobm9kZSwgdGhpcy50b2tlbnMpO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIG5vZGVzQXNTdHJpbmcobm9kZXMpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBub2Rlc0FzU3RyaW5nKG5vZGVzLCB0aGlzLnRva2Vucyk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgcHJlcGFyZSgpIHtcbiAgICBpZiAodGhpcy50b2tlbnMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsZXhlciA9IHRoaXMuZ2V0TGV4ZXIoKSxcbiAgICAgICAgICBwYXJzZXIgPSB0aGlzLmdldFBhcnNlcigpLFxuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmZpbGVDb250ZW50OyAvLy9cblxuICAgIHRoaXMudG9rZW5zID0gbGV4ZXIudG9rZW5pc2UoY29udGVudCk7XG5cbiAgICB0aGlzLm5vZGUgPSBwYXJzZXIucGFyc2UodGhpcy50b2tlbnMpO1xuICB9XG5cbiAgaW5pdGlhbGlzZShqc29uKSB7XG4gICAgY29uc3QgeyBjb250ZW50IH0gPSBqc29uLFxuICAgICAgICAgIGxleGVyID0gdGhpcy5nZXRMZXhlcigpLFxuICAgICAgICAgIHBhcnNlciA9IHRoaXMuZ2V0UGFyc2VyKCk7XG5cbiAgICB0aGlzLnRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpO1xuXG4gICAgdGhpcy5ub2RlID0gcGFyc2VyLnBhcnNlKHRoaXMudG9rZW5zKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuYWRkUHJvY2VkdXJlcygpO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsobm9kZSkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBsaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0aGlzLnRva2VucyksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLmdldFJlbGVhc2VDb250ZXh0KCk7XG5cbiAgICBhd2FpdCByZWxlYXNlQ29udGV4dC5icmVhayhmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSgpIHtcbiAgICBsZXQgdmVyaWZpZXMgPSBmYWxzZTtcblxuICAgIHRoaXMucHJlcGFyZSgpO1xuXG4gICAgaWYgKHRoaXMubm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy53YXJuaW5nKGBVbmFibGUgdG8gdmVyaWZ5IHRoZSAnJHt0aGlzLmZpbGVQYXRofScgZmlsZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBwYXJzZWQuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoYFZlcmlmeWluZyB0aGUgJyR7dGhpcy5maWxlUGF0aH0nIGZpbGUuLi5gKTtcblxuICAgICAgY29uc3QgZmlsZVZlcmlmaWVzID0gYXdhaXQgdGhpcy52ZXJpZnlGaWxlKCk7XG5cbiAgICAgIGlmIChmaWxlVmVyaWZpZXMpIHtcbiAgICAgICAgdmVyaWZpZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2ZXJpZmllcyA/XG4gICAgICAgIHRoaXMuY29tcGxldGUoKSA6XG4gICAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICBpZiAodmVyaWZpZXMpIHtcbiAgICAgICAgdGhpcy5pbmZvKGAuLi52ZXJpZmllZCB0aGUgJyR7dGhpcy5maWxlUGF0aH0nIGZpbGUuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcmlmaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21GaWxlKENsYXNzLCBmaWxlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgdG9rZW5zID0gbnVsbCxcbiAgICAgICAgICBub2RlID0gbnVsbCxcbiAgICAgICAgICBjb250ZXh0ID0gcmVtYWluaW5nQXJndW1lbnRzLnBvcCgpLCAvLy9cbiAgICAgICAgICBmaWxlQ29udGV4dCA9IG5ldyBDbGFzcyhjb250ZXh0LCBmaWxlQ29udGVudCwgZmlsZVBhdGgsIHRva2Vucywgbm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiBmaWxlQ29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihDbGFzcywganNvbiwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyBmaWxlQ29udGVudCwgZmlsZVBhdGggfSA9IGpzb24sXG4gICAgICAgICAgdG9rZW5zID0gbnVsbCxcbiAgICAgICAgICBub2RlID0gbnVsbCxcbiAgICAgICAgICBjb250ZXh0ID0gcmVtYWluaW5nQXJndW1lbnRzLnBvcCgpLCAvLy9cbiAgICAgICAgICBmaWxlQ29udGV4dCA9IG5ldyBDbGFzcyhjb250ZXh0LCBmaWxlQ29udGVudCwgZmlsZVBhdGgsIHRva2Vucywgbm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiBmaWxlQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaWx0ZXIgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgsIGFycmF5KTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0V2ZXJ5KGFycmF5LCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICByZXN1bHQgPSBhd2FpdCBjYWxsYmFjayhlbGVtZW50LCBpbmRleCwgYXJyYXkpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1JlZHVjZShhcnJheSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7IC8vL1xuXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgIHZhbHVlID0gYXdhaXQgY2FsbGJhY2sodmFsdWUsIGVsZW1lbnQsIGluZGV4LCBhcnJheSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0ZvckVhY2goYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgIGF3YWl0IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4LCBhcnJheSk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jUmVzb2x2ZShhcnJheUEsIGFycmF5QiwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc29sdmVkO1xuXG4gIGFycmF5QSA9IFsgIC8vL1xuICAgIC4uLmFycmF5QVxuICBdO1xuXG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBhcnJheUFMZW5ndGggPSBhcnJheUEubGVuZ3RoO1xuXG4gICAgaWYgKGFycmF5QUxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICBhd2FpdCBhc3luY0ZvckVhY2goYXJyYXlBLCBhc3luYyAoZWxlbWVudEEsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXNzZWQgPSBhd2FpdCBjYWxsYmFjayhlbGVtZW50QSwgaW5kZXgsIGFycmF5QSk7XG5cbiAgICAgIGlmIChwYXNzZWQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudEIgPSBlbGVtZW50QTsgIC8vL1xuXG4gICAgICAgIGFycmF5Qi5wdXNoKGVsZW1lbnRCKTtcblxuICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmaWx0ZXIoYXJyYXlBLCAoZWxlbWVudEEpID0+IHtcbiAgICAgIGNvbnN0IGFycmF5QkluY2x1ZGVzRWxlbWVudEEgPSBhcnJheUIuaW5jbHVkZXMoZWxlbWVudEEpO1xuXG4gICAgICBpZiAoIWFycmF5QkluY2x1ZGVzRWxlbWVudEEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBhcnJheUFMZW5ndGggPSBhcnJheUEubGVuZ3RoO1xuXG4gIHJlc29sdmVkID0gKGFycmF5QUxlbmd0aCA9PT0gMCk7XG5cbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNGb3J3YXJkc0V2ZXJ5KGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgsIGFycmF5KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0JhY2t3YXJkc0V2ZXJ5KGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSBsZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBhd2FpdCBjYWxsYmFjayhlbGVtZW50LCBpbmRleCwgYXJyYXkpO1xuXG4gICAgaWYgKCFwYXNzZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhc3luY1NvbWUsXG4gIGFzeW5jRXZlcnksXG4gIGFzeW5jUmVkdWNlLFxuICBhc3luY0ZvckVhY2gsXG4gIGFzeW5jUmVzb2x2ZSxcbiAgYXN5bmNGb3J3YXJkc0V2ZXJ5LFxuICBhc3luY0JhY2t3YXJkc0V2ZXJ5XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgYXN5bmNSZXNvbHZlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hc3luY2hyb25vdXNcIjtcblxuY29uc3QgeyBmaXJzdCwgZmlsdGVyLCBjb21wcmVzcyB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlGaWxlQ29udGV4dHMoZmlsZUNvbnRleHRzLCB2ZXJpZmllZEZpbGVDb250ZXh0cykge1xuICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IGFzeW5jUmVzb2x2ZShmaWxlQ29udGV4dHMsIHZlcmlmaWVkRmlsZUNvbnRleHRzLCBhc3luYyAoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlQ29udGV4dFZlcmlmaWVzID0gYXdhaXQgZmlsZUNvbnRleHQudmVyaWZ5KCk7XG5cbiAgICAgICAgICBpZiAoZmlsZUNvbnRleHRWZXJpZmllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZmlsZUNvbnRleHRzVmVyaWZ5ID0gcmVzb2x2ZWQ7ICAvLy9cblxuICByZXR1cm4gZmlsZUNvbnRleHRzVmVyaWZ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZVByZWZpeGVzKHR5cGVQcmVmaXhlcywgcmVsZWFzZUNvbnRleHQpIHtcbiAgbGV0IHR5cGVQcmVmaXhlc1ZlcmlmeSA9IHRydWU7XG5cbiAgY29uc3QgdHlwZVByZWZpeGVzTGVuZ3RoID0gdHlwZVByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgY29tcHJlc3NlZFR5cGVQcmVmaXhlcyA9IFsgIC8vL1xuICAgICAgICAgIC4uLnR5cGVQcmVmaXhlcyxcbiAgICAgICAgXTtcblxuICBjb21wcmVzcyhjb21wcmVzc2VkVHlwZVByZWZpeGVzLCAodHlwZVByZWZpeEEsIHR5cGVQcmVmaXhCKSA9PiB7XG4gICAgY29uc3QgdHlwZVByZWZpeEFOYW1lID0gdHlwZVByZWZpeEEuZ2V0TmFtZSgpLFxuICAgICAgICAgIHR5cGVQcmVmaXhCTmFtZSA9IHR5cGVQcmVmaXhCLmdldE5hbWUoKTtcblxuICAgIGlmICh0eXBlUHJlZml4QU5hbWUgIT09IHR5cGVQcmVmaXhCTmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBjb21wcmVzc1R5cGVQcmVmaXhlc0xlbmd0aCA9IGNvbXByZXNzZWRUeXBlUHJlZml4ZXMubGVuZ3RoO1xuXG4gIGlmICh0eXBlUHJlZml4ZXNMZW5ndGggPiBjb21wcmVzc1R5cGVQcmVmaXhlc0xlbmd0aCkge1xuICAgIGZpbHRlcihjb21wcmVzc2VkVHlwZVByZWZpeGVzLCAodHlwZVByZWZpeCkgPT4ge1xuICAgICAgY29uc3QgdHlwZVByZWZpeGVzSW5jbHVkZXNUeXBlUHJlZml4ID0gdHlwZVByZWZpeGVzLmluY2x1ZGVzKHR5cGVQcmVmaXgpO1xuXG4gICAgICBpZiAoIXR5cGVQcmVmaXhlc0luY2x1ZGVzVHlwZVByZWZpeCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGZpcnN0VHlwZVByZWZpeCA9IGZpcnN0KHR5cGVQcmVmaXhlcyksXG4gICAgICAgICAgdHlwZVByZWZpeCA9IGZpcnN0VHlwZVByZWZpeCwgLy8vXG4gICAgICAgICAgdHlwZVByZWZpeFN0cmluZyA9IHR5cGVQcmVmaXguZ2V0U3RyaW5nKCk7XG5cbiAgICByZWxlYXNlQ29udGV4dC5pbmZvKGBUaGUgJyR7dHlwZVByZWZpeFN0cmluZ30nIHR5cGUgcHJlZml4IGlzIGR1cGxpY2F0ZWQuYClcblxuICAgIHR5cGVQcmVmaXhlc1ZlcmlmeSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVQcmVmaXhlc1ZlcmlmeTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ1VTVE9NX0dSQU1NQVJfTkFNRSA9IFwiRGVmYXVsdFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgVEVSTV9SVUxFX05BTUUgPSBcInRlcm1cIjtcbmV4cG9ydCBjb25zdCBTVEFURU1FTlRfUlVMRV9OQU1FID0gXCJzdGF0ZW1lbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBURVJNX1JVTEVfTkFNRSxcbiAgU1RBVEVNRU5UX1JVTEVfTkFNRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRZUEVfVk9DQUJVTEFSWV9OQU1FID0gXCJ0eXBlXCI7XG5leHBvcnQgY29uc3QgU1lNQk9MX1ZPQ0FCVUxBUllfTkFNRSA9IFwic3ltYm9sXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVFlQRV9WT0NBQlVMQVJZX05BTUUsXG4gIFNZTUJPTF9WT0NBQlVMQVJZX05BTUVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IFZFUlRJQ0FMX0JBUiA9IFwifFwiO1xuZXhwb3J0IGNvbnN0IFZFUlRJQ0FMX1NQQUNFID0gYFxuXG5gXG5leHBvcnQgY29uc3QgVU5BU1NJR05FRF9UWVBFID0gXCJ1bmFzc2lnbmVkXCI7XG5leHBvcnQgY29uc3QgU1RVRkZfUlVMRV9OQU1FID0gXCJzdHVmZlwiO1xuZXhwb3J0IGNvbnN0IEJBU0VfVFlQRV9TWU1CT0wgPSBcIjw+XCI7XG5leHBvcnQgY29uc3QgTk9OU0VOU0VfUlVMRV9OQU1FID0gXCJub25zZW5zZVwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IERFRkFVTFRfQ1VTVE9NX0dSQU1NQVJfTkFNRSB9IGZyb20gXCIuL2dyYW1tYXJOYW1lc1wiO1xuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUsIFNUQVRFTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IFRZUEVfVk9DQUJVTEFSWV9OQU1FLCBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FIH0gZnJvbSBcIi4vdm9jYWJ1bGFyeU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRlcm1CTkYgPSB0ZXJtQk5GO1xuICAgIHRoaXMuc3RhdGVtZW50Qk5GID0gc3RhdGVtZW50Qk5GO1xuICAgIHRoaXMudHlwZVZvY2FidWxhcnkgPSB0eXBlVm9jYWJ1bGFyeTtcbiAgICB0aGlzLnN5bWJvbFZvY2FidWxhcnkgPSBzeW1ib2xWb2NhYnVsYXJ5O1xuICB9XG4gIFxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRUZXJtQk5GKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm1CTkY7XG4gIH1cblxuICBnZXRTdGF0ZW1lbnRCTkYoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVtZW50Qk5GO1xuICB9XG5cbiAgZ2V0VHlwZVZvY2FidWxhcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZVZvY2FidWxhcnk7XG4gIH1cblxuICBnZXRTeW1ib2xWb2NhYnVsYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnN5bWJvbFZvY2FidWxhcnk7XG4gIH1cblxuICBnZXRCTkYocnVsZU5hbWUpIHtcbiAgICBsZXQgYm5mO1xuXG4gICAgc3dpdGNoIChydWxlTmFtZSkge1xuICAgICAgY2FzZSBURVJNX1JVTEVfTkFNRTogYm5mID0gdGhpcy50ZXJtQk5GOyBicmVhaztcbiAgICAgIGNhc2UgU1RBVEVNRU5UX1JVTEVfTkFNRTogYm5mID0gdGhpcy5zdGF0ZW1lbnRCTkY7IGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBibmY7XG4gIH1cblxuICBnZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lKSB7XG4gICAgbGV0IHZvY2FidWxhcnk7XG5cbiAgICBzd2l0Y2ggKHZvY2FidWxhcnlOYW1lKSB7XG4gICAgICBjYXNlIFRZUEVfVk9DQUJVTEFSWV9OQU1FOiB2b2NhYnVsYXJ5ID0gdGhpcy50eXBlVm9jYWJ1bGFyeTsgYnJlYWs7XG4gICAgICBjYXNlIFNZTUJPTF9WT0NBQlVMQVJZX05BTUU6IHZvY2FidWxhcnkgPSB0aGlzLnN5bWJvbFZvY2FidWxhcnk7IGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB2b2NhYnVsYXJ5O1xuICB9XG5cbiAgZ2V0Vm9jYWJ1bGFyaWVzKCkge1xuICAgIGNvbnN0IHZvY2FidWxhcmllcyA9IFtcbiAgICAgIHRoaXMudHlwZVZvY2FidWxhcnksXG4gICAgICB0aGlzLnN5bWJvbFZvY2FidWxhcnlcbiAgICBdO1xuXG4gICAgcmV0dXJuIHZvY2FidWxhcmllcztcbiAgfVxuXG4gIGlzRGVmYXVsdEN1c3RvbUdyYW1tYXIoKSB7XG4gICAgY29uc3QgZGVmYXVsdEN1c3RvbUdyYW1tYXIgPSAodGhpcy5uYW1lID09PSBERUZBVUxUX0NVU1RPTV9HUkFNTUFSX05BTUUpO1xuXG4gICAgcmV0dXJuIGRlZmF1bHRDdXN0b21HcmFtbWFyO1xuICB9XG5cbiAgc2V0TmFtZShuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIHNldEJORihydWxlTmFtZSwgYm5mKSB7XG4gICAgc3dpdGNoIChydWxlTmFtZSkge1xuICAgICAgY2FzZSBURVJNX1JVTEVfTkFNRTpcbiAgICAgICAgdGhpcy50ZXJtQk5GID0gYm5mO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNUQVRFTUVOVF9SVUxFX05BTUU6XG4gICAgICAgIHRoaXMuc3RhdGVtZW50Qk5GID0gYm5mO1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNldFZvY2FidWxhcnkodm9jYWJ1bGFyeU5hbWUsIHZvY2FidWxhcnkpIHtcbiAgICBzd2l0Y2ggKHZvY2FidWxhcnlOYW1lKSB7XG4gICAgICBjYXNlIFRZUEVfVk9DQUJVTEFSWV9OQU1FOlxuICAgICAgICB0aGlzLnR5cGVWb2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FOlxuICAgICAgICB0aGlzLnN5bWJvbFZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5O1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0Qk5GKHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgYm5mID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgdGhpcy5zZXRCTkYocnVsZU5hbWUsIGJuZik7XG4gIH1cblxuICByZXNldFZvY2FidWxhcnkodm9jYWJ1bGFyeU5hbWUpIHtcbiAgICBjb25zdCB2b2NhYnVsYXJ5ID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgdGhpcy5zZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lLCB2b2NhYnVsYXJ5KTtcbiAgfVxuXG4gIHVwZGF0ZShydWxlTmFtZSwgYm5mLCB2b2NhYnVsYXJ5TmFtZSwgdm9jYWJ1bGFyeSkge1xuICAgIHRoaXMuc2V0Qk5GKHJ1bGVOYW1lLCBibmYpO1xuXG4gICAgdGhpcy5zZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lLCB2b2NhYnVsYXJ5KTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIHRlcm1CTkYgPSB0aGlzLnRlcm1CTkYsXG4gICAgICAgICAgc3RhdGVtZW50Qk5GID0gdGhpcy5zdGF0ZW1lbnRCTkYsXG4gICAgICAgICAgdHlwZVZvY2FidWxhcnkgPSB0aGlzLnR5cGVWb2NhYnVsYXJ5LFxuICAgICAgICAgIHN5bWJvbFZvY2FidWxhcnkgPSB0aGlzLnN5bWJvbFZvY2FidWxhcnksXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0ZXJtQk5GLFxuICAgICAgICAgICAgc3RhdGVtZW50Qk5GLFxuICAgICAgICAgICAgdHlwZVZvY2FidWxhcnksXG4gICAgICAgICAgICBzeW1ib2xWb2NhYnVsYXJ5XG4gICAgICAgICAgfTtcbiAgICBcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgeyBuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5IH0gPSBqc29uLFxuICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBuZXcgQ3VzdG9tR3JhbW1hcihuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5KTtcblxuICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lKG5hbWUpIHtcbiAgICBjb25zdCB0ZXJtQk5GID0gRU1QVFlfU1RSSU5HLFxuICAgICAgICAgIHN0YXRlbWVudEJORiA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICB0eXBlVm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBzeW1ib2xWb2NhYnVsYXJ5ID0gRU1QVFlfU1RSSU5HLFxuICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBuZXcgQ3VzdG9tR3JhbW1hcihuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5KTtcblxuICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lVGVybUJORlN0YXRlbWVudEJORlR5cGVWb2NhYnVsYXJ5QW5kU3ltYm9sVm9jYWJ1bGFyeShuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5KSB7XG4gICAgY29uc3QgY3VzdG9tR3JhbW1hciA9IG5ldyBDdXN0b21HcmFtbWFyKG5hbWUsIHRlcm1CTkYsIHN0YXRlbWVudEJORiwgdHlwZVZvY2FidWxhcnksIHN5bWJvbFZvY2FidWxhcnkpO1xuXG4gICAgcmV0dXJuIGN1c3RvbUdyYW1tYXI7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXJcIjtcblxuaW1wb3J0IHsgREVGQVVMVF9DVVNUT01fR1JBTU1BUl9OQU1FIH0gZnJvbSBcIi4uL2dyYW1tYXJOYW1lc1wiO1xuXG5leHBvcnQgY29uc3QgdGVybUJORiA9IGB0ZXJtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIihcIiBhcmd1bWVudCBcIilcIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB2YXJpYWJsZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO2A7XG5cbmV4cG9ydCBjb25zdCBzdGF0ZW1lbnRCTkYgPSBgc3RhdGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCIoXCIgbWV0YUFyZ3VtZW50IFwiKVwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIGVxdWFsaXR5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIGp1ZGdlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0eXBlQXNzZXJ0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIGRlZmluZWRBc3NlcnRpb24gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBjb250YWluZWRBc3NlcnRpb24gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzYXRpc2ZpZXNBc3NlcnRpb25cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgc3VicHJvb2ZBc3NlcnRpb24gICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcHJvcGVydHlBc3NlcnRpb24gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBtZXRhdmFyaWFibGUgKCBmcmFtZVN1YnN0aXR1dGlvbiB8IHRlcm1TdWJzdGl0dXRpb24gKT9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5lcXVhbGl0eSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICB0ZXJtIFwiPVwiIHRlcm0gO1xuXG50eXBlQXNzZXJ0aW9uICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICB0ZXJtIFwiOlwiIHR5cGUgO1xuXG5kZWZpbmVkQXNzZXJ0aW9uICAgICAgICAgICAgICAgICAgICAgOjo9ICAoIGZyYW1lIHwgdGVybSApIFwiaXNcIiAoIFwiZGVmaW5lZFwiIHwgXCJ1bmRlZmluZWRcIiApO1xuXG5jb250YWluZWRBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgOjo9ICAoIGZyYW1lIHwgdGVybSApIFwiaXNcIiAoIFwicHJlc2VudFwiIHwgXCJtaXNzaW5nXCIgKSBcImluXCIgc3RhdGVtZW50IDtcblxuc2F0aXNmaWVzQXNzZXJ0aW9uICAgICAgICAgICAgICAgICAgIDo6PSAgc2lnbmF0dXJlIFwic2F0aXNmaWVzXCIgbWV0YXZhcmlhYmxlIDsgIFxuXG5zdWJwcm9vZkFzc2VydGlvbiAgICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIiBzdGF0ZW1lbnQgKCBcIixcIiBzdGF0ZW1lbnQgKSogXCJdXCIgXCIuLi5cIiBzdGF0ZW1lbnQgO1xuXG5wcm9wZXJ0eUFzc2VydGlvbiAgICAgICAgICAgICAgICAgICAgOjo9ICB0ZXJtIFwiaXNcIiAoIFwiYVwiIHwgXCJhblwiICkgcHJvcGVydHlSZWxhdGlvbiA7XG5cbnByb3BlcnR5UmVsYXRpb24gICAgICAgICAgICAgICAgICAgICA6Oj0gIHByb3BlcnR5IFwib2ZcIiB0ZXJtIDtcblxuanVkZ2VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgZnJhbWUgXCJ8XCI8Tk9fV0hJVEVTUEFDRT5cIi1cIiBhc3N1bXB0aW9uIDtcblxuZnJhbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgKCAoIGFzc3VtcHRpb24gKCBcIixcIiBhc3N1bXB0aW9uICkqICkgfCBtZXRhdmFyaWFibGUgKSBcIl1cIiA7XG4gXG5hc3N1bXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBtZXRhdmFyaWFibGUgXCI6OlwiIHN0YXRlbWVudCA7XG5cbnRlcm1TdWJzdGl0dXRpb24gICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiIHRlcm0gXCJmb3JcIiB0ZXJtIFwiXVwiO1xuXG5mcmFtZVN1YnN0aXR1dGlvbiAgICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIiBmcmFtZSBcImZvclwiIGZyYW1lIFwiXVwiO1xuXG5zdGF0ZW1lbnRTdWJzdGl0dXRpb24gICAgICAgICAgICAgICAgOjo9ICBcIltcIiBzdGF0ZW1lbnQgXCJmb3JcIiBzdGF0ZW1lbnQgXCJdXCI7XG5cbnJlZmVyZW5jZVN1YnN0aXR1dGlvbiAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiIHJlZmVyZW5jZSBcImZvclwiIHJlZmVyZW5jZSBcIl1cIjtgO1xuXG5leHBvcnQgY29uc3QgdHlwZVZvY2FidWxhcnkgPSBcIlwiO1xuXG5leHBvcnQgY29uc3Qgc3ltYm9sVm9jYWJ1bGFyeSA9IFwiXCI7XG5cbmNvbnN0IG5hbWUgPSBERUZBVUxUX0NVU1RPTV9HUkFNTUFSX05BTUUsXG4gICAgICBqc29uID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0ZXJtQk5GLFxuICAgICAgICBzdGF0ZW1lbnRCTkYsXG4gICAgICAgIHR5cGVWb2NhYnVsYXJ5LFxuICAgICAgICBzeW1ib2xWb2NhYnVsYXJ5XG4gICAgICB9O1xuXG5jb25zdCBkZWZhdWx0Q3VzdG9tR3JhbW1hciA9IEN1c3RvbUdyYW1tYXIuZnJvbUpTT04oanNvbik7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRDdXN0b21HcmFtbWFyO1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4YW1wbGVMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEV4YW1wbGVMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNsYXNzIEEgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEEsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBCIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShCLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgQyBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIEQgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEQsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBFIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShFLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgRiBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRiwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIFMgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFMsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBUIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShULCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgViBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoViwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNvbnN0IE5vblRlcm1pbmFsTm9kZU1hcCA9IHtcbiAgQSxcbiAgQixcbiAgQyxcbiAgRCxcbiAgRSxcbiAgRixcbiAgUyxcbiAgVCxcbiAgVlxufVxuXG5leHBvcnQgZGVmYXVsdCBOb25UZXJtaW5hbE5vZGVNYXA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGVNYXAgZnJvbSBcIi4vbm9uVGVybWluYWxOb2RlTWFwXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4YW1wbGVQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgTm9uVGVybWluYWxOb2RlTWFwID0gTm9uVGVybWluYWxOb2RlTWFwO1xufSIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBDT01NQV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN5Y2xlIHtcbiAgY29uc3RydWN0b3IoZWRnZXMpIHtcbiAgICB0aGlzLmVkZ2VzID0gZWRnZXM7XG4gIH1cblxuICBnZXRFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcztcbiAgfVxuXG4gIGdldExlbmd0aCgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmVkZ2VzLmxlbmd0aDtcblxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICBnZXRFZGdlKGluZGV4KSB7XG4gICAgY29uc3QgZWRnZSA9IHRoaXMuZWRnZXNbaW5kZXhdO1xuXG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cblxuICBnZXRWZXJ0ZXhlcygpIHtcbiAgICBjb25zdCB2ZXJ0ZXhlcyA9IHRoaXMubWFwRWRnZSgoZWRnZSkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlVmVydGV4ID0gZWRnZS5nZXRTb3VyY2VWZXJ0ZXgoKSxcbiAgICAgICAgICAgIHZlcnRleCA9IHNvdXJjZVZlcnRleDsgIC8vL1xuXG4gICAgICByZXR1cm4gdmVydGV4O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZlcnRleGVzO1xuICB9XG5cbiAgbWFwRWRnZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5lZGdlcy5tYXAoY2FsbGJhY2spOyB9XG5cbiAgZXZlcnlFZGdlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmVkZ2VzLmV2ZXJ5KGNhbGxiYWNrKTsgfVxuXG4gIGZvckVhY2hFZGdlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmVkZ2VzLmZvckVhY2goY2FsbGJhY2spOyB9XG5cbiAgaXNFcXVhbFRvKGN5Y2xlKSB7XG4gICAgbGV0IGVxdWFsVG8gPSBmYWxzZTtcblxuICAgIGNvbnN0IGN5Y2xlQSA9IHRoaXMsICAvLy9cbiAgICAgICAgICBjeWNsZUIgPSBjeWNsZSwgIC8vL1xuICAgICAgICAgIGN5Y2xlQUxlbmd0aCA9IGN5Y2xlQS5nZXRMZW5ndGgoKSxcbiAgICAgICAgICBjeWNsZUJMZW5ndGggPSBjeWNsZUIuZ2V0TGVuZ3RoKCk7XG5cbiAgICBpZiAoY3ljbGVBTGVuZ3RoID09PSBjeWNsZUJMZW5ndGgpIHtcbiAgICAgIGVxdWFsVG8gPSBjeWNsZUEuZXZlcnlFZGdlKChlZGdlQSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZWRnZUIgPSBjeWNsZUIuZ2V0RWRnZShpbmRleCksXG4gICAgICAgICAgICAgIG1hdGNoZXMgPSBlZGdlQS5tYXRjaChlZGdlQik7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVxdWFsVG87XG4gIH1cblxuICBwZXJtdXRlZCgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuZWRnZXMuc2xpY2UoKSwgLy8vXG4gICAgICAgICAgZWRnZSA9IGVkZ2VzLnBvcCgpO1xuXG4gICAgZWRnZXMudW5zaGlmdChlZGdlKTtcblxuICAgIGNvbnN0IGN5Y2xlID0gbmV3IEN5Y2xlKGVkZ2VzKTtcblxuICAgIHJldHVybiBjeWNsZTtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHZlcnRleGVzID0gdGhpcy5nZXRWZXJ0ZXhlcygpLFxuICAgICAgICAgIHN0cmluZyA9IHZlcnRleGVzLmpvaW4oQ09NTUFfQ0hBUkFDVEVSKTtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbUVkZ2UoZWRnZSkge1xuICAgIGNvbnN0IGVkZ2VzID0gW1xuICAgICAgICAgICAgZWRnZVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY3ljbGUgPSBuZXcgQ3ljbGUoZWRnZXMpO1xuXG4gICAgcmV0dXJuIGN5Y2xlO1xuICB9XG5cbiAgc3RhdGljIGZyb21FZGdlcyhlZGdlcykge1xuICAgIGNvbnN0IGN5Y2xlID0gbmV3IEN5Y2xlKGVkZ2VzKTtcblxuICAgIHJldHVybiBjeWNsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IEN5Y2xlIGZyb20gXCIuL2N5Y2xlXCI7XG5cbmNvbnN0IHsgbGFzdCwgZmluZCwgY29tcHJlc3MgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RlZEdyYXBoIHtcbiAgY29uc3RydWN0b3IoZWRnZXMsIHN0YXJ0VmVydGV4KSB7XG4gICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICAgIHRoaXMuc3RhcnRWZXJ0ZXggPSBzdGFydFZlcnRleDtcbiAgfVxuXG4gIGdldEVkZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVkZ2VzO1xuICB9XG5cbiAgZ2V0U3RhcnRWZXJ0ZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRWZXJ0ZXg7XG4gIH1cblxuICBhZGRFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gZWRnZXNNYXRjaEVkZ2UodGhpcy5lZGdlcywgZWRnZSk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRoaXMuZWRnZXMucHVzaChlZGdlKTtcbiAgICB9XG4gIH1cblxuICBhZGRFZGdlcyhlZGdlcykge1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgIHRoaXMuYWRkRWRnZShlZGdlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUVkZ2UoZWRnZSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5lZGdlcy5pbmRleE9mKGVkZ2UpLFxuICAgICAgICAgIHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICBkZWxldGVDb3VudCA9IDE7XG5cbiAgICB0aGlzLmVkZ2VzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuICB9XG5cbiAgZGVwdGhGaXJzdFNlYXJjaCh2ZXJ0ZXgsIHZlcnRleGVzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHByZXZpb3VzVmVydGV4ZXMgPSB2ZXJ0ZXhlcywgIC8vL1xuICAgICAgICAgIHN1Y2Nlc3NvclZlcnRleGVzID0gdGhpcy5maW5kU3VjY2Vzc29yVmVydGV4ZXModmVydGV4KTtcblxuICAgIHN1Y2Nlc3NvclZlcnRleGVzLmZvckVhY2goKHN1Y2Nlc3NvclZlcnRleCkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNWZXJ0ZXhlc0luY2x1ZGVzU3VjY2Vzc29yVmVydGV4ID0gcHJldmlvdXNWZXJ0ZXhlcy5pbmNsdWRlcyhzdWNjZXNzb3JWZXJ0ZXgpLFxuICAgICAgICAgICAgdmVydGV4ZXMgPSBbXG4gICAgICAgICAgICAgIC4uLnByZXZpb3VzVmVydGV4ZXMsXG4gICAgICAgICAgICAgIHN1Y2Nlc3NvclZlcnRleFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHZlcnRleCA9IHN1Y2Nlc3NvclZlcnRleDsgIC8vL1xuXG4gICAgICBpZiAocHJldmlvdXNWZXJ0ZXhlc0luY2x1ZGVzU3VjY2Vzc29yVmVydGV4KSB7XG4gICAgICAgIGNhbGxiYWNrKHZlcnRleGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwdGhGaXJzdFNlYXJjaCh2ZXJ0ZXgsIHZlcnRleGVzLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmaW5kQ3ljbGVzKCkge1xuICAgIGNvbnN0IHRyaXZpYWxDeWNsZXMgPSB0aGlzLmZpbmRUcml2aWFsQ3ljbGVzKCksXG4gICAgICAgICAgbm9uVHJpdmlhbEN5Y2xlcyA9IHRoaXMuZmluZE5vblRyaXZpYWxDeWNsZXMoKSxcbiAgICAgICAgICBjeWNsZXMgPSBbXG4gICAgICAgICAgICAuLi50cml2aWFsQ3ljbGVzLFxuICAgICAgICAgICAgLi4ubm9uVHJpdmlhbEN5Y2xlc1xuICAgICAgICAgIF07XG5cbiAgICBjb21wcmVzcyhjeWNsZXMsIChjeWNsZUEsIGN5Y2xlQikgPT4ge1xuICAgICAgY29uc3QgY3ljbGVzQ29pbmNpZGVudCA9IGFyZUN5Y2xlc0NvaW5jaWRlbnQoY3ljbGVBLCBjeWNsZUIpO1xuXG4gICAgICBpZiAoIWN5Y2xlc0NvaW5jaWRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3ljbGVzO1xuICB9XG5cbiAgZmluZFRyaXZpYWxDeWNsZXMoKSB7XG4gICAgY29uc3QgdHJpdmlhbGx5Q3ljbGljRWRnZXMgPSB0aGlzLmZpbmRUcml2aWFsbHlDeWNsaWNFZGdlcygpLFxuICAgICAgICAgIHRyaXZpYWxDeWNsZXMgPSB0cml2aWFsbHlDeWNsaWNFZGdlcy5tYXAoKHRyaXZpYWxseUN5Y2xpY0VkZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSB0cml2aWFsbHlDeWNsaWNFZGdlLCAgLy8vXG4gICAgICAgICAgICAgICAgICBjeWNsZSA9IEN5Y2xlLmZyb21FZGdlKGVkZ2UpLFxuICAgICAgICAgICAgICAgICAgdHJpdmlhbEN5Y2xlID0gY3ljbGU7IC8vL1xuXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbEN5Y2xlO1xuICAgICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyaXZpYWxDeWNsZXM7XG4gIH1cblxuICBmaW5kTm9uVHJpdmlhbEN5Y2xlcygpIHtcbiAgICBjb25zdCBub25Ucml2aWFsQ3ljbGVzID0gW10sXG4gICAgICAgICAgZGlyZWN0ZWRHcmFwaCA9IHRoaXMsIC8vL1xuICAgICAgICAgIHZlcnRleCA9IHRoaXMuc3RhcnRWZXJ0ZXgsIC8vL1xuICAgICAgICAgIHZlcnRleGVzID0gW1xuICAgICAgICAgICAgdmVydGV4XG4gICAgICAgICAgXTtcblxuICAgIHRoaXMuZGVwdGhGaXJzdFNlYXJjaCh2ZXJ0ZXgsIHZlcnRleGVzLCAodmVydGV4ZXMpID0+IHtcbiAgICAgIGNvbnN0IG5vblRyaXZpYWxDeWNsZSA9IG5vblRyaXZpYWxDeWNsZUZyb21WZXJ0ZXhlcyh2ZXJ0ZXhlcywgZGlyZWN0ZWRHcmFwaCk7XG5cbiAgICAgIG5vblRyaXZpYWxDeWNsZXMucHVzaChub25Ucml2aWFsQ3ljbGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vblRyaXZpYWxDeWNsZXM7XG4gIH1cblxuICBmaW5kU3VjY2Vzc29yRWRnZXModmVydGV4KSB7XG4gICAgY29uc3Qgc291cmNlVmVydGV4ID0gdmVydGV4LCAgLy8vXG4gICAgICAgICAgZWRnZXMgPSB0aGlzLmZpbmRFZGdlc0J5U291cmNlVmVydGV4KHNvdXJjZVZlcnRleCksXG4gICAgICAgICAgc3VjY2Vzc29yRWRnZXMgPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFZlcnRleCA9IGVkZ2UuZ2V0VGFyZ2V0VmVydGV4KCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRWZXJ0ZXggIT09IHNvdXJjZVZlcnRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgIHJldHVybiBzdWNjZXNzb3JFZGdlcztcbiAgfVxuXG4gIGZpbmRTdWNjZXNzb3JWZXJ0ZXhlcyh2ZXJ0ZXgpIHtcbiAgICBjb25zdCBzdWNjZXNzb3JFZGdlcyA9IHRoaXMuZmluZFN1Y2Nlc3NvckVkZ2VzKHZlcnRleCksXG4gICAgICAgICAgc3VjY2Vzc29yVmVydGV4ZXMgPSBzdWNjZXNzb3JFZGdlcy5tYXAoKHN1Y2Nlc3NvckVkZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NvckVkZ2VUYXJnZXRWZXJ0ZXggPSBzdWNjZXNzb3JFZGdlLmdldFRhcmdldFZlcnRleCgpLFxuICAgICAgICAgICAgICAgICAgc3VjY2Vzc29yVmVydGV4ID0gc3VjY2Vzc29yRWRnZVRhcmdldFZlcnRleDsgIC8vL1xuXG4gICAgICAgICAgICByZXR1cm4gc3VjY2Vzc29yVmVydGV4O1xuICAgICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHN1Y2Nlc3NvclZlcnRleGVzO1xuICB9XG5cbiAgZmluZEVkZ2VzQnlTb3VyY2VWZXJ0ZXgoc291cmNlVmVydGV4KSB7XG4gICAgY29uc3QgZWRnZXMgPSBmaW5kKHRoaXMuZWRnZXMsIChlZGdlKSA9PiB7IC8vL1xuICAgICAgY29uc3QgZWRnZU1hdGNoZXNTb3VyY2VWZXJ0ZXggPSBlZGdlLm1hdGNoU291cmNlVmVydGV4KHNvdXJjZVZlcnRleCk7XG5cbiAgICAgIGlmIChlZGdlTWF0Y2hlc1NvdXJjZVZlcnRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlZGdlcztcbiAgfVxuXG4gIGZpbmRUcml2aWFsbHlDeWNsaWNFZGdlcygpIHtcbiAgICBjb25zdCB0cml2aWFsbHlDeWNsaWNFZGdlcyA9IGZpbmQodGhpcy5lZGdlcywgKGVkZ2UpID0+IHtcbiAgICAgIGNvbnN0IGVkZ2VUcml2aWFsbHlDeWNsaWMgPSBlZGdlLmlzVHJpdmlhbGx5Q3ljbGljKCk7XG5cbiAgICAgIGlmIChlZGdlVHJpdmlhbGx5Q3ljbGljKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyaXZpYWxseUN5Y2xpY0VkZ2VzO1xuICB9XG5cbiAgZmluZEVkZ2VCeVNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmVkZ2VzLmZpbmQoKGVkZ2UpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBlZGdlLm1hdGNoU291cmNlVmVydGV4QW5kVGFyZ2V0VmVydGV4KHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkgfHwgbnVsbDtcblxuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgc3RhdGljIGZyb21FZGdlc0FuZFN0YXJ0VmVydGV4KGVkZ2VzLCBzdGFydFZlcnRleCkge1xuICAgIGNvbnN0IGRpcmVjdGVkR3JhcGggPSBuZXcgRGlyZWN0ZWRHcmFwaChlZGdlcywgc3RhcnRWZXJ0ZXgpO1xuXG4gICAgcmV0dXJuIGRpcmVjdGVkR3JhcGg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VzTWF0Y2hFZGdlKGVkZ2VzLCBlZGdlKSB7XG4gIGNvbnN0IGVkZ2VBID0gZWRnZSwgLy8vXG4gICAgICAgIG1hdGNoZXMgPSBlZGdlcy5zb21lKChlZGdlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZWRnZUIgPSBlZGdlLCAvLy9cbiAgICAgICAgICAgICAgICBlZGdlQU1hdGNoZXNFZGdlQiA9IGVkZ2VBLm1hdGNoKGVkZ2VCKTtcblxuICAgICAgICAgIGlmIChlZGdlQU1hdGNoZXNFZGdlQikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZnVuY3Rpb24gbm9uVHJpdmlhbEN5Y2xlRnJvbVZlcnRleGVzKHZlcnRleGVzLCBkaXJlY3RlZEdyYXBoKSB7XG4gIGNvbnN0IGxhc3RWZXJ0ZXggPSBsYXN0KHZlcnRleGVzKSxcbiAgICAgICAgaW5kZXggPSB2ZXJ0ZXhlcy5pbmRleE9mKGxhc3RWZXJ0ZXgpLFxuICAgICAgICBzdGFydCA9IGluZGV4OyAgLy8vXG5cbiAgdmVydGV4ZXMgPSB2ZXJ0ZXhlcy5zbGljZShzdGFydCk7IC8vL1xuXG4gIHZlcnRleGVzLnBvcCgpO1xuXG4gIGNvbnN0IGxlbmd0aCA9IHZlcnRleGVzLmxlbmd0aCxcbiAgICAgICAgZWRnZXMgPSB2ZXJ0ZXhlcy5tYXAoKHZlcnRleCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoaW5kZXggKyAxKSAlIGxlbmd0aCxcbiAgICAgICAgICAgICAgICBuZXh0VmVydGV4ID0gdmVydGV4ZXNbbmV4dEluZGV4XSxcbiAgICAgICAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSB2ZXJ0ZXgsICAvLy9cbiAgICAgICAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSBuZXh0VmVydGV4LCAvLy9cbiAgICAgICAgICAgICAgICBlZGdlID0gZGlyZWN0ZWRHcmFwaC5maW5kRWRnZUJ5U291cmNlVmVydGV4QW5kVGFyZ2V0VmVydGV4KHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICB9KSxcbiAgICAgICAgY3ljbGUgPSBDeWNsZS5mcm9tRWRnZXMoZWRnZXMpO1xuXG4gIHJldHVybiBjeWNsZTtcbn1cblxuZnVuY3Rpb24gc29tZUN5Y2xlUGVybXV0YXRpb24oY3ljbGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICBjb25zdCBsZW5ndGggPSBjeWNsZS5nZXRMZW5ndGgoKTtcblxuICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgcmVzdWx0ID0gY2FsbGJhY2soY3ljbGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY3ljbGUgPSBjeWNsZS5wZXJtdXRlZCgpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXJlQ3ljbGVzQ29pbmNpZGVudChjeWNsZUEsIGN5Y2xlQikge1xuICBsZXQgY3ljbGVzQ29pbmNpZGVudCA9IGZhbHNlO1xuXG4gIGNvbnN0IGN5Y2xlQUxlbmd0aCA9IGN5Y2xlQS5nZXRMZW5ndGgoKSxcbiAgICAgICAgY3ljbGVCTGVuZ3RoID0gY3ljbGVCLmdldExlbmd0aCgpO1xuXG4gIGlmIChjeWNsZUFMZW5ndGggPT09IGN5Y2xlQkxlbmd0aCkge1xuICAgIGN5Y2xlc0NvaW5jaWRlbnQgPSBzb21lQ3ljbGVQZXJtdXRhdGlvbihjeWNsZUEsIChjeWNsZUEpID0+IHtcbiAgICAgIGNvbnN0IGN5Y2xlQUVxdWFsVG8gPSBjeWNsZUEuaXNFcXVhbFRvKGN5Y2xlQik7XG5cbiAgICAgIGlmIChjeWNsZUFFcXVhbFRvKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGN5Y2xlc0NvaW5jaWRlbnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZHVjZWROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSZWR1Y2VkTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gYCR7cnVsZU5hbWV9X2A7XG5cbiAgcmV0dXJuIHJlZHVjZWRSdWxlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUpIHtcbiAgY29uc3QgcnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWUucmVwbGFjZSgvXyQvZywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gYCR7cnVsZU5hbWV9fmA7XG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUucmVwbGFjZSgvfi4rJC9nLCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBydWxlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVSdWxlTmFtZUZyb21JbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSkge1xuICBjb25zdCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZS5yZXBsYWNlKC9eW15+XSt+L2csIEVNUFRZX1NUUklORyk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBgJHtydWxlTmFtZX1+JHtsZWZ0UmVjdXJzaXZlUnVsZU5hbWV9YDtcblxuICByZXR1cm4gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IHB1c2gsIGNvbXByZXNzIH0gPSBhcnJheVV0aWxpdGllcztcblxuaW1wb3J0IHsgcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlTmFtZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDeWNsZUlycmVkdWNpYmxlKGN5Y2xlLCBydWxlTWFwKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSksXG4gICAgICAgIHJlZHVjZWRSdWxlcyA9IHJ1bGVOYW1lcy5yZWR1Y2UoKHJlZHVjZWRSdWxlcywgcnVsZU5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VkUnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgICAgICAgIHJlZHVjZWRSdWxlID0gcnVsZU1hcFtyZWR1Y2VkUnVsZU5hbWVdIHx8IG51bGw7XG5cbiAgICAgICAgICBpZiAocmVkdWNlZFJ1bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZHVjZWRSdWxlcy5wdXNoKHJlZHVjZWRSdWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVkdWNlZFJ1bGVzO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHJlZHVjZWRSdWxlc0xlbmd0aCA9IHJlZHVjZWRSdWxlcy5sZW5ndGgsXG4gICAgICAgIGN5Y2xlSXJyZWR1Y2libGUgPSAocmVkdWNlZFJ1bGVzTGVuZ3RoID09PSAwKTsgLy8vXG5cbiAgcmV0dXJuIGN5Y2xlSXJyZWR1Y2libGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUsIHJ1bGVOYW1lcyA9IFtdKSB7XG4gIGNvbnN0IGN5Y2xlVmVydGV4ZXMgPSBjeWNsZS5nZXRWZXJ0ZXhlcygpLFxuICAgICAgICBjeWNsZVJ1bGVOYW1lcyA9IGN5Y2xlVmVydGV4ZXM7IC8vL1xuXG4gIHB1c2gocnVsZU5hbWVzLCBjeWNsZVJ1bGVOYW1lcyk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lc0Zyb21DeWNsZXMoY3ljbGVzLCBydWxlTmFtZXMgPSBbXSkge1xuICBjeWNsZXMuZm9yRWFjaCgoY3ljbGUpID0+IHtcbiAgICBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUsIHJ1bGVOYW1lcyk7XG4gIH0pO1xuXG4gIGNvbXByZXNzKHJ1bGVOYW1lcywgKHJ1bGVOYW1lQSwgcnVsZU5hbWVCKSA9PiB7XG4gICAgaWYgKHJ1bGVOYW1lQSAhPT0gcnVsZU5hbWVCKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBydWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlQ3ljbGVzRnJvbVJ1bGVOYW1lQW5kQ3ljbGVzKHJ1bGVOYW1lLCBjeWNsZXMpIHtcbiAgY29uc3QgcnVsZUN5Y2xlcyA9IGN5Y2xlcy5yZWR1Y2UoKHJ1bGVDeWNsZXMsIGN5Y2xlKSA9PiB7XG4gICAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlKSxcbiAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVSdWxlTmFtZSkge1xuICAgICAgY29uc3QgcnVsZUN5Y2xlID0gY3ljbGU7ICAvLy9cblxuICAgICAgcnVsZUN5Y2xlcy5wdXNoKHJ1bGVDeWNsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVDeWNsZXM7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gcnVsZUN5Y2xlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFydFR5cGVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5jb25zdCB7IGVwc2lsb24sIG5vV2hpdGVzcGFjZSwgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzLFxuICAgICAgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVsZU5vbkNvbnN1bWluZyhydWxlLCBydWxlTWFwLCBydWxlTmFtZXMgPSBbXSkge1xuICBsZXQgcnVsZU5vbkNvbnN1bWluZyA9IGZhbHNlO1xuXG4gIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gIGlmICghcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgIHJ1bGVOYW1lcyA9IFsgLy8vXG4gICAgICAuLi5ydWxlTmFtZXMsXG4gICAgICBydWxlTmFtZVxuICAgIF07XG5cbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKSxcbiAgICAgICAgICBkZWZpbml0aW9uc05vbkNvbnN1bWluZyA9IGFyZURlZmluaXRpb25zTm9uQ29uc3VtaW5nKGRlZmluaXRpb25zLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgcnVsZU5vbkNvbnN1bWluZyA9IGRlZmluaXRpb25zTm9uQ29uc3VtaW5nOyAvLy9cbiAgfVxuXG4gIHJldHVybiBydWxlTm9uQ29uc3VtaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJ0Tm9uQ29uc3VtaW5nKHBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyA9IFtdKSB7XG4gIGxldCBwYXJ0Tm9uQ29uc3VtaW5nO1xuXG4gIGNvbnN0IHBhclRlcm1pbmFsUGFydCA9IHBhcnQuaXNUZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFyVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3QgdGVybWluYWxQYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsUGFydE5vbkNvbnN1bWluZyA9IGlzVGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nKHRlcm1pbmFsUGFydCk7XG5cbiAgICBwYXJ0Tm9uQ29uc3VtaW5nID0gdGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nOyAvLy9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5QYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgIG5vblRlcm1pbmFsUGFydE5vbkNvbnN1bWluZyA9IGlzTm9uVGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nKG5vblRlcm1pbmFsTlBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICBwYXJ0Tm9uQ29uc3VtaW5nID0gbm9uVGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nOyAvLy9cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uQ29uc3VtaW5nO1xufVxuXG5mdW5jdGlvbiBhcmVEZWZpbml0aW9uc05vbkNvbnN1bWluZyhkZWZpbml0aW9ucywgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGNvbnN0IGRlZmluaXRpb25zTm9uQ29uc3VtaW5nID0gZGVmaW5pdGlvbnMuc29tZSgoZGVmaW5pdGlvbikgPT4ge1xuICAgIGNvbnN0IGRlZmluaXRpb25Ob25Db25zdW1pbmcgPSBpc0RlZmluaXRpb25Ob25Db25zdW1pbmcoZGVmaW5pdGlvbiwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIGlmIChkZWZpbml0aW9uTm9uQ29uc3VtaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWZpbml0aW9uc05vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gaXNEZWZpbml0aW9uTm9uQ29uc3VtaW5nKGRlZmluaXRpb24sIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgcGFydHNOb25Db25zdW1pbmcgPSBhcmVQYXJ0c05vbkNvbnN1bWluZyhwYXJ0cywgcnVsZU1hcCwgcnVsZU5hbWVzKSxcbiAgICAgICAgZGVmaW5pdGlvbk5vbkNvbnN1bWluZyA9IHBhcnRzTm9uQ29uc3VtaW5nOyAvLy9cblxuICByZXR1cm4gZGVmaW5pdGlvbk5vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gYXJlUGFydHNOb25Db25zdW1pbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0c05vbkNvbnN1bWluZyA9IHBhcnRzLmV2ZXJ5KChwYXJ0KSA9PiB7XG4gICAgY29uc3QgcGFydE5vbkNvbnN1bWluZyA9IGlzUGFydE5vbkNvbnN1bWluZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgaWYgKHBhcnROb25Db25zdW1pbmcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnRzTm9uQ29uc3VtaW5nO1xufVxuXG5mdW5jdGlvbiBpc1Rlcm1pbmFsUGFydE5vbkNvbnN1bWluZyh0ZXJtaW5hbFBhcnQpIHtcbiAgbGV0IHRlcm1pbmFsUGFydE5vbkNvbnN1bWluZztcblxuICBjb25zdCB0ZXJtaW5hbFBhcnRTdHJpbmcgPSB0ZXJtaW5hbFBhcnQuYXNTdHJpbmcoKTtcblxuICBzd2l0Y2ggKHRlcm1pbmFsUGFydFN0cmluZykge1xuICAgIGNhc2UgZXBzaWxvbjpcbiAgICBjYXNlIG5vV2hpdGVzcGFjZTpcbiAgICBjYXNlIHN0YXJ0T2ZDb250ZW50OiB7XG4gICAgICB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmcgPSB0cnVlO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmcgPSBmYWxzZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRlcm1pbmFsUGFydE5vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gaXNOb25UZXJtaW5hbFBhcnROb25Db25zdW1pbmcobm9uVGVybWluYWxQYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgbGV0IHBhcnROb25Db25zdW1pbmcgPSBmYWxzZTtcblxuICBjb25zdCB0eXBlID0gbm9uVGVybWluYWxQYXJ0LmdldFR5cGUoKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSB8fCBudWxsO1xuXG4gICAgICBpZiAocnVsZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBydWxlTm9uQ29uc3VtaW5nID0gaXNSdWxlTm9uQ29uc3VtaW5nKHJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgICAgcGFydE5vbkNvbnN1bWluZyA9IHJ1bGVOb25Db25zdW1pbmc7ICAvLy9cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgcGFydE5vbkNvbnN1bWluZyA9IHRydWU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3Qgb25lT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgcGFydE5vbkNvbnN1bWluZyA9IGlzUGFydE5vbkNvbnN1bWluZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBwYXJ0Tm9uQ29uc3VtaW5nID0gdHJ1ZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IHNlcXVlbmNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKSxcbiAgICAgICAgICAgIHBhcnRzTm9uQ29uc3VtaW5nID0gYXJlUGFydHNOb25Db25zdW1pbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSBwYXJ0c05vbkNvbnN1bWluZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBjb25zdCBjaG9pY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IGNob2ljZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c05vbkNvbnN1bWluZyA9IHBhcnRzLnNvbWUoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydE5vbkNvbnN1bWluZyA9IGlzUGFydE5vbkNvbnN1bWluZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0Tm9uQ29uc3VtaW5nO1xuICAgICAgICAgICAgfSlcblxuICAgICAgcGFydE5vbkNvbnN1bWluZyA9IHBhcnRzTm9uQ29uc3VtaW5nOyAvLy9cblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnROb25Db25zdW1pbmc7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgaXNQYXJ0Tm9uQ29uc3VtaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ub25Db25zdW1pbmdcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IFJ1bGVOYW1lUGFydFR5cGUsXG4gICAgICAgIE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICAgICAgICBDaG9pY2VPZlBhcnRzUGFydFR5cGUsXG4gICAgICAgIE9uZU9yTW9yZVBhcnRzUGFydFR5cGUsXG4gICAgICAgIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSB9ID0gcGFydFR5cGVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZShkZWZpbml0aW9uLCBydWxlTWFwKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBwYXJ0c0xlZnRSZWN1cnNpdmUgPSBhcmVQYXJ0c0xlZnRSZWN1cnNpdmUocGFydHMsIHJ1bGVNYXApLFxuICAgICAgICBkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSA9IHBhcnRzTGVmdFJlY3Vyc2l2ZTsgLy8vXG5cbiAgcmV0dXJuIGRlZmluaXRpb25MZWZ0UmVjdXJzaXZlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21SdWxlKHJ1bGUsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBbXSkge1xuICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICBkZWZpbml0aW9ucy5mb3JFYWNoKChkZWZpbml0aW9uKSA9PiB7XG4gICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uKGRlZmluaXRpb24sIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuICB9KTtcblxuICByZXR1cm4gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCk7XG5cbiAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0cyhwYXJ0cywgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGFyZVBhcnRzTGVmdFJlY3Vyc2l2ZShwYXJ0cywgcnVsZU1hcCkge1xuICBjb25zdCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0cyhwYXJ0cywgcnVsZU1hcCksXG4gICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNMZW5ndGggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmxlbmd0aCxcbiAgICAgICAgcGFydHNMZWZ0UmVjdXJzaXZlID0gKGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNMZW5ndGggPiAwKTtcblxuICByZXR1cm4gcGFydHNMZWZ0UmVjdXJzaXZlO1xufVxuXG5mdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUnVsZU5hbWVQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAoIWxlZnRSZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gcnVsZU5hbWU7IC8vL1xuXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5wdXNoKGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgWmVyb09yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgICBwYXJ0cyA9IHNlcXVlbmNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKSxcbiAgICAgICAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICAgICAgICBwYXJ0ID0gZmlyc3RQYXJ0OyAvLy9cblxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IGNob2ljZU9mUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydHMgPSBjaG9pY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpO1xuXG4gICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydHMocGFydHMsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBbXSkge1xuICBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgIGNvbnN0IHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCk7XG5cbiAgICBpZiAoIXBhcnROb25Db25zdW1pbmcpIHtcbiAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRnZSB7XG4gIGNvbnN0cnVjdG9yKGxhYmVsLHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMuc291cmNlVmVydGV4ID0gc291cmNlVmVydGV4O1xuICAgIHRoaXMudGFyZ2V0VmVydGV4ID0gdGFyZ2V0VmVydGV4O1xuICB9XG5cbiAgZ2V0TGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gIH1cblxuICBnZXRTb3VyY2VWZXJ0ZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlVmVydGV4O1xuICB9XG5cbiAgZ2V0VGFyZ2V0VmVydGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldFZlcnRleDtcbiAgfVxuXG4gIGlzVHJpdmlhbGx5Q3ljbGljKCkge1xuICAgIGNvbnN0IHRyaXZpYWxseUN5Y2xpYyA9ICh0aGlzLnNvdXJjZVZlcnRleCA9PT0gdGhpcy50YXJnZXRWZXJ0ZXgpO1xuXG4gICAgcmV0dXJuIHRyaXZpYWxseUN5Y2xpYztcbiAgfVxuXG4gIG1hdGNoKGVkZ2UpIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWwoKSxcbiAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSBlZGdlLmdldFNvdXJjZVZlcnRleCgpLFxuICAgICAgICAgIHRhcmdldFZlcnRleCA9IGVkZ2UuZ2V0VGFyZ2V0VmVydGV4KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRoaXMubWF0Y2hMYWJlbFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBtYXRjaFNvdXJjZVZlcnRleChzb3VyY2VWZXJ0ZXgpIHtcbiAgICBjb25zdCBtYXRjaGVzU291cmNlVmVydGV4ID0gKHRoaXMuc291cmNlVmVydGV4ID09PSBzb3VyY2VWZXJ0ZXgpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXNTb3VyY2VWZXJ0ZXg7XG4gIH1cblxuICBtYXRjaFRhcmdldFZlcnRleCh0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBtYXRjaGVzVGFyZ2V0VmVydGV4ID0gKHRoaXMudGFyZ2V0VmVydGV4ID09PSB0YXJnZXRWZXJ0ZXgpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXNUYXJnZXRWZXJ0ZXg7XG4gIH1cblxuICBtYXRjaFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoKHRoaXMuc291cmNlVmVydGV4ID09PSBzb3VyY2VWZXJ0ZXgpICYmICh0aGlzLnRhcmdldFZlcnRleCA9PT0gdGFyZ2V0VmVydGV4KSk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIG1hdGNoTGFiZWxTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9ICgodGhpcy5sYWJlbCA9PT0gbGFiZWwpICYmICh0aGlzLnNvdXJjZVZlcnRleCA9PT0gc291cmNlVmVydGV4KSAmJiAodGhpcy50YXJnZXRWZXJ0ZXggPT09IHRhcmdldFZlcnRleCkpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbUxhYmVsU291cmNlVmVydGV4QW5kVGFyZ2V0VmVydGV4KGxhYmVsLCBzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIGNvbnN0IGVkZ2UgPSBuZXcgRWRnZShsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpO1xuXG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFydFR5cGVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuY29uc3QgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21SdWxlKHJ1bGUsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IFtdKSB7XG4gIGNvbnN0IGRlZmluaXRpb25zID0gcnVsZS5nZXREZWZpbml0aW9ucygpO1xuXG4gIGRlZmluaXRpb25zLmZvckVhY2goKGRlZmluaXRpb24pID0+IHtcbiAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuICB9KTtcblxuICByZXR1cm4gcmVjdXJzaXZlUnVsZU5hbWVzO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCByZWN1cnNpdmVSdWxlTmFtZXMgPSBbXSkge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKTtcblxuICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydHMocGFydHMsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgcmV0dXJuIHJlY3Vyc2l2ZVJ1bGVOYW1lcztcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnRzKHBhcnRzLCByZWN1cnNpdmVSdWxlTmFtZXMgPSBbXSkge1xuICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlY3Vyc2l2ZVJ1bGVOYW1lcztcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKSB7XG4gIGNvbnN0IHBhcnROb25UZXJtaW5hbFBhcnQgPSBwYXJ0LmlzTm9uVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhcnROb25UZXJtaW5hbFBhcnQpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbFBhcnQgPSBwYXJ0LCAvLy9cbiAgICAgICAgICB0eXBlID0gbm9uVGVybWluYWxQYXJ0LmdldFR5cGUoKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSdWxlTmFtZVBhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgICBydWxlTmFtZSA9IHJ1bGVOYW1lUGFydC5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcmVjdXJzaXZlUnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAoIXJlY3Vyc2l2ZVJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICBjb25zdCByZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lOyAvLy9cblxuICAgICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lcy5wdXNoKHJlY3Vyc2l2ZVJ1bGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIE9wdGlvbmFsUGFydFBhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUGFydFBhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gb3B0aW9uYWxQYXJ0UGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHplcm9Pck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gemVyb09yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7ICAvLy9cblxuICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydHMgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0LmdldFBhcnRzKCk7XG5cbiAgICAgICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIENob2ljZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBjaG9pY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gY2hvaWNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKTtcblxuICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKVxuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFJFQ1VSU0lWRV9MQUJFTCA9IFwicmVjdXJzaXZlXCI7XG5leHBvcnQgY29uc3QgTEVGVF9SRUNVUlNJVkVfTEFCRUwgPSBcImxlZnQtcmVjdXJzaXZlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFZGdlIGZyb20gXCIuLi9lZGdlXCI7XG5cbmltcG9ydCB7IGVkZ2VzTWF0Y2hFZGdlIH0gZnJvbSBcIi4uL2RpcmVjdGVkR3JhcGhcIjtcbmltcG9ydCB7IHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21SdWxlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9yZWN1cnNpdmVcIjtcbmltcG9ydCB7IFJFQ1VSU0lWRV9MQUJFTCwgTEVGVF9SRUNVUlNJVkVfTEFCRUwgfSBmcm9tIFwiLi4vbGFiZWxzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGdlc0Zyb21SdWxlTmFtZXMocnVsZU5hbWVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJ1bGVOYW1lcy5sZW5ndGgsXG4gICAgICAgIGVkZ2VzID0gcnVsZU5hbWVzLm1hcCgocnVsZU5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBsZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV4dFJ1bGVOYW1lID0gcnVsZU5hbWVzW25leHRJbmRleF0sXG4gICAgICAgICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gbmV4dFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgICAgICAgICBlZGdlID0gZWRnZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKTtcblxuICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGdlc0Zyb21TdGFydFJ1bGUoc3RhcnRSdWxlLCBydWxlTWFwLCBydWxlTmFtZXNNYXApIHtcbiAgY29uc3QgcnVsZSA9IHN0YXJ0UnVsZSwgLy8vXG4gICAgICAgIGVkZ2VzID0gW10sXG4gICAgICAgIHZlcnRleGVzID0gW107XG5cbiAgZWRnZXNGcm9tUnVsZShydWxlLCBlZGdlcywgdmVydGV4ZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IGxhYmVsID0gTEVGVF9SRUNVUlNJVkVfTEFCRUwsXG4gICAgICAgIHNvdXJjZVZlcnRleCA9IHJ1bGVOYW1lLCAgLy8vXG4gICAgICAgIHRhcmdldFZlcnRleCA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgLy8vXG4gICAgICAgIGVkZ2UgPSBFZGdlLmZyb21MYWJlbFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpO1xuXG4gIHJldHVybiBlZGdlO1xufVxuXG5mdW5jdGlvbiBlZGdlc0Zyb21SdWxlKHJ1bGUsIGVkZ2VzLCB2ZXJ0ZXhlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgIHZlcnRleCA9IHJ1bGVOYW1lLCAgLy8vXG4gICAgICAgIHZlcnRleGVzSW5jbHVkZXNWZXJ0ZXggPSB2ZXJ0ZXhlcy5pbmNsdWRlcyh2ZXJ0ZXgpO1xuXG4gIGlmICh2ZXJ0ZXhlc0luY2x1ZGVzVmVydGV4KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmVydGV4ZXMgPSBbXG4gICAgLi4udmVydGV4ZXMsXG4gICAgdmVydGV4XG4gIF07XG5cbiAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzID0gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVJ1bGUocnVsZSksXG4gICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBydWxlTmFtZXM7IC8vL1xuXG4gIHJlY3Vyc2l2ZVJ1bGVOYW1lcy5mb3JFYWNoKChyZWN1cnNpdmVSdWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1JlY3Vyc2l2ZVJ1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5pbmNsdWRlcyhyZWN1cnNpdmVSdWxlTmFtZSksXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gcmVjdXJzaXZlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgICBsYWJlbCA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1JlY3Vyc2l2ZVJ1bGVOYW1lID9cbiAgICAgICAgICAgICAgICAgICAgTEVGVF9SRUNVUlNJVkVfTEFCRUwgOlxuICAgICAgICAgICAgICAgICAgICAgIFJFQ1VSU0lWRV9MQUJFTCxcbiAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSBydWxlTmFtZSwgIC8vL1xuICAgICAgICAgIHRhcmdldFZlcnRleCA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgLy8vXG4gICAgICAgICAgZWRnZSA9IEVkZ2UuZnJvbUxhYmVsU291cmNlVmVydGV4QW5kVGFyZ2V0VmVydGV4KGxhYmVsLCBzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCksXG4gICAgICAgICAgbWF0Y2hlcyA9IGVkZ2VzTWF0Y2hFZGdlKGVkZ2VzLCBlZGdlKTtcblxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgZWRnZXMucHVzaChlZGdlKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWN1cnNpdmVSdWxlID0gcnVsZU1hcFtyZWN1cnNpdmVSdWxlTmFtZV0gfHwgbnVsbDtcblxuICAgIGlmIChyZWN1cnNpdmVSdWxlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBydWxlID0gcmVjdXJzaXZlUnVsZTsgLy8vXG5cbiAgICAgIGVkZ2VzRnJvbVJ1bGUocnVsZSwgZWRnZXMsIHZlcnRleGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuICAgIH1cbiAgfSk7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUnVsZSB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBSZWR1Y2VkTm9kZSBmcm9tIFwiLi4vbm9kZS9yZWR1Y2VkXCI7XG5cbmltcG9ydCB7IGVkZ2VzTWF0Y2hFZGdlIH0gZnJvbSBcIi4uL2RpcmVjdGVkR3JhcGhcIjtcbmltcG9ydCB7IHJ1bGVOYW1lc0Zyb21DeWNsZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvY3ljbGVcIjtcbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcbmltcG9ydCB7IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbiB9IGZyb20gXCIuLi91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZVwiO1xuaW1wb3J0IHsgZWRnZXNGcm9tUnVsZU5hbWVzLCBlZGdlRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9kaXJlY3RlZEdyYXBoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZHVjZWRSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIE5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSwgc3RhdGUpIHtcbiAgICBjb25zdCBOb25UZXJtaW5hbE5vZGUgPSBSZWR1Y2VkTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzLCBydWxlTWFwKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKTtcblxuICAgIGxldCByZWR1Y2VkUnVsZSA9IG51bGwsXG4gICAgICAgIGRlZmluaXRpb25zID0gcnVsZS5nZXREZWZpbml0aW9ucygpO1xuXG4gICAgZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucy5maWx0ZXIoKGRlZmluaXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGRlZmluaXRpb25MZWZ0UmVkdWNpYmxlID0gaXNEZWZpbml0aW9uUmVkdWNpYmxlKGRlZmluaXRpb24sIHJ1bGVOYW1lLCBjeWNsZXMsIHJ1bGVNYXApO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbkxlZnRSZWR1Y2libGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBkZWZpbml0aW9uc0xlbmd0aCA9IGRlZmluaXRpb25zLmxlbmd0aDtcblxuICAgIGlmIChkZWZpbml0aW9uc0xlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgICByZWR1Y2VkUnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgICAgbmFtZSA9IHJlZHVjZWRSdWxlTmFtZSwgLy8vXG4gICAgICAgICAgICBvcGFjaXR5ID0gcnVsZS5nZXRPcGFjaXR5KCk7XG5cbiAgICAgIHJlZHVjZWRSdWxlID0gbmV3IFJlZHVjZWRSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkdWNlZFJ1bGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNEZWZpbml0aW9uUmVkdWNpYmxlKGRlZmluaXRpb24sIHJ1bGVOYW1lLCBjeWNsZXMsIHJ1bGVNYXApIHtcbiAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCBydWxlTWFwKSxcbiAgICAgICAgZGVmaW5pdGlvblJlZHVjaWJsZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMuZXZlcnkoKGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN5Y2xlc0luY2x1ZGVSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGN5Y2xlcy5zb21lKChjeWNsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3ljbGVJbmNsdWRlc1J1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gZG9lc0N5Y2xlSW5jbHVkZVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKGN5Y2xlLCBydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGN5Y2xlSW5jbHVkZXNSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghY3ljbGVzSW5jbHVkZVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBkZWZpbml0aW9uUmVkdWNpYmxlO1xufVxuXG5mdW5jdGlvbiBkb2VzQ3ljbGVJbmNsdWRlUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUoY3ljbGUsIHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlKSxcbiAgICAgICAgZWRnZSA9IGVkZ2VGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSksXG4gICAgICAgIGVkZ2VzID0gZWRnZXNGcm9tUnVsZU5hbWVzKHJ1bGVOYW1lcyksXG4gICAgICAgIG1hdGNoZXMgPSBlZGdlc01hdGNoRWRnZShlZGdlcywgZWRnZSksXG4gICAgICAgIGN5Y2xlSW5jbHVkZXNSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IG1hdGNoZXM7ICAvLy9cblxuICByZXR1cm4gY3ljbGVJbmNsdWRlc1J1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUmVkdWNlZFJ1bGUgZnJvbSBcIi4vcnVsZS9yZWR1Y2VkXCI7XG5cbmltcG9ydCB7IHJ1bGVOYW1lc0Zyb21DeWNsZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvY3ljbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUmVkdWNlZFJ1bGVzKGN5Y2xlcywgcnVsZU1hcCkge1xuICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGVzKGN5Y2xlcyk7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICAgIHJlZHVjZWRSdWxlID0gUmVkdWNlZFJ1bGUuZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzLCBydWxlTWFwKTtcblxuICAgIGlmIChyZWR1Y2VkUnVsZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgICBydWxlTWFwW3JlZHVjZWRSdWxlTmFtZV0gPSByZWR1Y2VkUnVsZTtcbiAgICB9XG4gIH0pO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkKG5vblRlcm1pbmFsTm9kZSkge1xuICBsZXQgbm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZDtcblxuICBjb25zdCBjaGlsZE5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQgPSBub25UZXJtaW5hbE5vZGUuc29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBjaGlsZE5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQgPSBpc05vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQoY2hpbGROb25UZXJtaW5hbE5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgaWYgKGNoaWxkTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZCkge1xuICAgIG5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBub25UZXJtaW5hbE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgaWYgKHByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCk7XG5cbiAgICAgIG5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQgPSBub25UZXJtaW5hbE5vZGUuc29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7ICAvLy9cbiAgICAgICAgY29uc3QgY2hpbGROb2RlTG93ZXJQcmVjZWRlbmNlID0gY2hpbGROb2RlLmlzTG93ZXJQcmVjZWRlbmNlKHJ1bGVOYW1lLCBwcmVjZWRlbmNlKTtcblxuICAgICAgICBpZiAoY2hpbGROb2RlTG93ZXJQcmVjZWRlbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgeyByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9yZXdyaXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdGx5UmVwZWF0ZWROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmV3cml0ZShzdGF0ZSkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIHJld3JpdGVEaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBzdGF0ZSk7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShEaXJlY3RseVJlcGVhdGVkTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVwc2lsb25Ob2RlLCBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmRpcmVjdGx5UmVwZWF0ZWROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgaXNOdWxsYXJ5KCkge1xuICAgIGxldCBudWxsYXJ5ID0gZmFsc2U7XG5cbiAgICBjb25zdCBzaW5ndWxhciA9IHRoaXMuaXNTaW5ndWxhcigpO1xuXG4gICAgaWYgKHNpbmd1bGFyKSB7XG4gICAgICBudWxsYXJ5ID0gdGhpcy5ldmVyeUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBFcHNpbG9uTm9kZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbGFyeTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoSW5kaXJlY3RseVJlcGVhdGVkTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUmVkdWNlZE5vZGUgZnJvbSBcIi4uL25vZGUvcmVkdWNlZFwiO1xuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWROb2RlIGZyb20gXCIuLi9ub2RlL3JlcGVhdGVkL2RpcmVjdGx5XCI7XG5pbXBvcnQgSW5kaXJlY3RseVJlcGVhdGVkTm9kZSBmcm9tIFwiLi4vbm9kZS9yZXBlYXRlZC9pbmRpcmVjdGx5XCI7XG5cbmltcG9ydCB7IHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZSwgcnVsZU5hbWVGcm9tSW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZUZyb21JbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuY29uc3QgeyBwdXNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHJld3JpdGVSZWR1Y2VkTm9kZXMobm9uVGVybWluYWxOb2RlLCBzdGF0ZSkge1xuICBsZXQgcmVkdWNlZENoaWxkTm9kZTtcblxuICBjb25zdCBmaXJzdENoaWxkTm9kZVJlZHVjZWROb2RlID0gbm9uVGVybWluYWxOb2RlLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGlmIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBSZWR1Y2VkTm9kZSkge1xuICAgICAgICByZWR1Y2VkQ2hpbGROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgaWYgKCFmaXJzdENoaWxkTm9kZVJlZHVjZWROb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50Tm9kZSA9IG5vblRlcm1pbmFsTm9kZSwgLy8vXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlID0gcmVkdWNlZENoaWxkTm9kZSwgLy8vXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlT3BhY2l0eSA9IHJlcGxhY2VkQ2hpbGROb2RlLmdldE9wYWNpdHkoKSxcbiAgICAgICAgcmVwbGFjZWRDaGlsZE5vZGVSdWxlTmFtZSA9IHJlcGxhY2VkQ2hpbGROb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlUHJlY2VkZW5jZSA9IHJlcGxhY2VkQ2hpbGROb2RlLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgcmVwbGFjZWRDaGlsZE5vZGVDaGlsZE5vZGVzID0gcmVwbGFjZWRDaGlsZE5vZGUucmVtb3ZlQ2hpbGROb2RlcygpLFxuICAgICAgICBwYXJlbnROb2RlUnVsZU5hbWUgPSBwYXJlbnROb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgIHJlZHVjZWRSdWxlTmFtZSA9IHJlcGxhY2VkQ2hpbGROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgcGFyZW50UnVsZU5hbWUgPSBwYXJlbnROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgcHJlY2VkZW5jZSA9IHJlcGxhY2VkQ2hpbGROb2RlUHJlY2VkZW5jZSwgLy8vXG4gICAgICAgIG9wYWNpdHkgPSByZXBsYWNlZENoaWxkTm9kZU9wYWNpdHksIC8vL1xuICAgICAgICBydWxlTmFtZSA9IHJ1bGVOYW1lRnJvbVJlZHVjZWRSdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUpO1xuXG4gIGxldCByZXBsYWNlbWVudENoaWxkTm9kZXM7XG5cbiAgaWYgKHJ1bGVOYW1lID09PSBwYXJlbnRSdWxlTmFtZSkge1xuICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlcyA9IHJlcGxhY2VkQ2hpbGROb2RlQ2hpbGROb2RlczsgIC8vL1xuXG4gICAgcGFyZW50Tm9kZS5zZXRQcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSByZXBsYWNlZENoaWxkTm9kZUNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHN0YXRlLk5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSksXG4gICAgICAgICAgcmVwbGFjZW1lbnRDaGlsZE5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuXG4gICAgcmVwbGFjZW1lbnRDaGlsZE5vZGVzID0gW1xuICAgICAgcmVwbGFjZW1lbnRDaGlsZE5vZGVcbiAgICBdO1xuICB9XG5cbiAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGROb2RlKHJlcGxhY2VkQ2hpbGROb2RlLCByZXBsYWNlbWVudENoaWxkTm9kZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZURpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUsIHN0YXRlKSB7XG4gIGxldCBkaXJlY3RseVJlcGVhdGVkTm9kZXNSZXBsYWNlZDtcblxuICBkaXJlY3RseVJlcGVhdGVkTm9kZXNSZXBsYWNlZCA9IHJlcGxhY2VEaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlKTtcblxuICB3aGlsZSAoZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQpIHtcbiAgICBkaXJlY3RseVJlcGVhdGVkTm9kZXNSZXBsYWNlZCA9IHJlcGxhY2VEaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZUluZGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpIHtcbiAgbGV0IHBhcmVudE5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuXG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVzID0gZmluZEluZGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZXMuZm9yRWFjaCgoaW5kaXJlY3RseVJlcGVhdGVkTm9kZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVOb2RlID0gbGVmdFJlY3Vyc2l2ZU5vZGVGcm9tUGFyZW50Tm9kZUFuZEluZGlyZWN0bHlSZXBlYXRlZE5vZGUocGFyZW50Tm9kZSwgaW5kaXJlY3RseVJlcGVhdGVkTm9kZSwgc3RhdGUpLFxuICAgICAgICAgIGNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzRnJvbUxlZnRSZWN1cnNpdmVOb2RlTm9kZUFuZEluZGlyZWN0bHlSZXBlYXRlZE5vZGUobGVmdFJlY3Vyc2l2ZU5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpO1xuXG4gICAgYWRqdXN0UGFyZW50Tm9kZVByZWNlZGVuY2UocGFyZW50Tm9kZSwgaW5kaXJlY3RseVJlcGVhdGVkTm9kZSk7XG5cbiAgICBwYXJlbnROb2RlLnNldENoaWxkTm9kZXMoY2hpbGROb2Rlcyk7XG5cbiAgICBwYXJlbnROb2RlID0gbGVmdFJlY3Vyc2l2ZU5vZGU7IC8vL1xuICB9KTtcblxuICByZXR1cm4gcGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZFJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBSZXBlYXRlZE5vZGUpIHtcbiAgbGV0IHJlcGVhdGVkTm9kZXM7XG5cbiAgbGV0IGVuZEluZGV4ID0gLTE7XG5cbiAgbm9uVGVybWluYWxOb2RlLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZE5vZGVSZXBlYXRlZE5vZGUgPSAoY2hpbGROb2RlIGluc3RhbmNlb2YgUmVwZWF0ZWROb2RlKTtcblxuICAgIGlmIChjaGlsZE5vZGVSZXBlYXRlZE5vZGUpIHtcbiAgICAgIGVuZEluZGV4ID0gaW5kZXggKyAxO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgICByZXBlYXRlZE5vZGVzID0gW107XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0YXJ0SW5kZXg7XG5cbiAgICBub25UZXJtaW5hbE5vZGUuYmFja3dhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGROb2RlUmVwZWF0ZWROb2RlID0gKGNoaWxkTm9kZSBpbnN0YW5jZW9mIFJlcGVhdGVkTm9kZSk7XG5cbiAgICAgIGlmICghY2hpbGROb2RlUmVwZWF0ZWROb2RlKSB7XG4gICAgICAgIGlmIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnRJbmRleCA9IGluZGV4OyAvLy9cbiAgICB9KTtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuc2xpY2VDaGlsZE5vZGVzKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblxuICAgIHJlcGVhdGVkTm9kZXMgPSBjaGlsZE5vZGVzOyAvLy9cbiAgfVxuXG4gIHJldHVybiByZXBlYXRlZE5vZGVzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVGcm9udENoaWxkTm9kZXMocGFyZW50Tm9kZSkge1xuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBwYXJlbnROb2RlLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICBkZWxldGVDb3VudCA9IG11bHRpcGxpY2l0eSAtIDEsXG4gICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgcmVtb3ZlZEZyb250Q2hpbGROb2RlcyA9IHBhcmVudE5vZGUuc3BsaWNlQ2hpbGROb2RlcyhzdGFydCwgZGVsZXRlQ291bnQpO1xuXG4gIHJldHVybiByZW1vdmVkRnJvbnRDaGlsZE5vZGVzO1xufVxuXG5mdW5jdGlvbiBmaW5kRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSkge1xuICBjb25zdCBkaXJlY3RseVJlcGVhdGVkTm9kZXMgPSBmaW5kUmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUsIERpcmVjdGx5UmVwZWF0ZWROb2RlKTtcblxuICByZXR1cm4gZGlyZWN0bHlSZXBlYXRlZE5vZGVzO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVzID0gZmluZFJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKTtcblxuICBpbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIGluZGlyZWN0bHlSZXBlYXRlZE5vZGVzO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSkge1xuICBsZXQgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSBmYWxzZTtcblxuICBjb25zdCBkaXJlY3RseVJlcGVhdGVkTm9kZXMgPSBmaW5kRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSksXG4gICAgICAgIGRpcmVjdGx5UmVwZWF0ZWROb2Rlc0xlbmd0aCA9IGRpcmVjdGx5UmVwZWF0ZWROb2Rlcy5sZW5ndGg7XG5cbiAgaWYgKGRpcmVjdGx5UmVwZWF0ZWROb2Rlc0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9uVGVybWluYWxOb2RlLCAvLy9cbiAgICAgICAgICByZXBsYWNlZENoaWxkTm9kZXMgPSBkaXJlY3RseVJlcGVhdGVkTm9kZXMsIC8vL1xuICAgICAgICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlcyA9IFtdOyAvLy9cblxuICAgIGRpcmVjdGx5UmVwZWF0ZWROb2Rlcy5mb3JFYWNoKChkaXJlY3RseVJlcGVhdGVkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZE5vZGVzQ2hpbGROb2RlcyA9IGRpcmVjdGx5UmVwZWF0ZWROb2RlLnJlbW92ZUNoaWxkTm9kZXMoKTtcblxuICAgICAgcHVzaChyZXBsYWNlbWVudENoaWxkTm9kZXMsIGRpcmVjdGx5UmVwZWF0ZWROb2Rlc0NoaWxkTm9kZXMpO1xuICAgIH0pO1xuXG4gICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGROb2RlcyhyZXBsYWNlZENoaWxkTm9kZXMsIHJlcGxhY2VtZW50Q2hpbGROb2Rlcyk7XG5cbiAgICBkaXJlY3RseVJlcGVhdGVkTm9kZXNSZXBsYWNlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQ7XG59XG5cbmZ1bmN0aW9uIGFkanVzdFBhcmVudE5vZGVQcmVjZWRlbmNlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpIHtcbiAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkTm9kZVJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVSdWxlTmFtZSwgIC8vL1xuICAgICAgICBwYXJlbnROb2RlTm9kZVJ1bGVOYW1lID0gcGFyZW50Tm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICBydWxlTmFtZSA9IHJ1bGVOYW1lRnJvbUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKTtcblxuICBpZiAocGFyZW50Tm9kZU5vZGVSdWxlTmFtZSA9PT0gcnVsZU5hbWUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gaW5kaXJlY3RseVJlcGVhdGVkTm9kZS5nZXRQcmVjZWRlbmNlKCk7XG5cbiAgICBwYXJlbnROb2RlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVmdFJlY3Vyc2l2ZU5vZGVGcm9tUGFyZW50Tm9kZUFuZEluZGlyZWN0bHlSZXBlYXRlZE5vZGUocGFyZW50Tm9kZSwgaW5kaXJlY3RseVJlcGVhdGVkTm9kZSwgc3RhdGUpIHtcbiAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkTm9kZVJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlT3BhY2l0eSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVSdWxlTmFtZSwgIC8vL1xuICAgICAgICByZW1vdmVkRnJvbnRDaGlsZE5vZGVzID0gcmVtb3ZlRnJvbnRDaGlsZE5vZGVzKHBhcmVudE5vZGUpLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVGcm9tSW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUoaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUpLFxuICAgICAgICBydWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgLy8vXG4gICAgICAgIGNoaWxkTm9kZXMgPSByZW1vdmVkRnJvbnRDaGlsZE5vZGVzLCAgLy8vXG4gICAgICAgIG9wYWNpdHkgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlT3BhY2l0eSwgIC8vL1xuICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgTm9uVGVybWluYWxOb2RlID0gc3RhdGUuTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSksXG4gICAgICAgIGxlZnRSZWN1cnNpdmVOb2RlID0gbm9uVGVybWluYWxOb2RlOyAgLy8vXG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVOb2RlO1xufVxuXG5mdW5jdGlvbiBjaGlsZE5vZGVzRnJvbUxlZnRSZWN1cnNpdmVOb2RlTm9kZUFuZEluZGlyZWN0bHlSZXBlYXRlZE5vZGUobGVmdFJlY3Vyc2l2ZU5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpIHtcbiAgY29uc3QgY2hpbGROb2RlcyA9IFtcbiAgICAgICAgICBsZWZ0UmVjdXJzaXZlTm9kZVxuICAgICAgICBdLFxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlTnVsbGFyeSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuaXNOdWxsYXJ5KCk7XG5cbiAgaWYgKCFpbmRpcmVjdGx5UmVwZWF0ZWROb2RlTnVsbGFyeSkge1xuICAgIGNvbnN0IHJlbW92ZWRDaGlsZE5vZGVzID0gaW5kaXJlY3RseVJlcGVhdGVkTm9kZS5yZW1vdmVDaGlsZE5vZGVzKCk7XG5cbiAgICBwdXNoKGNoaWxkTm9kZXMsIHJlbW92ZWRDaGlsZE5vZGVzKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZE5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgeyBpc05vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ByZWNlZGVuY2VcIjtcbmltcG9ydCB7IHJld3JpdGVSZWR1Y2VkTm9kZXMsIHJld3JpdGVEaXJlY3RseVJlcGVhdGVkTm9kZXMsIHJld3JpdGVJbmRpcmVjdGx5UmVwZWF0ZWROb2RlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmV3cml0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXdyaXR0ZW5Ob2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmV3cml0ZShzdGF0ZSkge1xuICAgIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IHRoaXMuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBOb25UZXJtaW5hbE5vZGUgPSBzdGF0ZS5Ob25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgbm9uVGVybWluYWxOb2RlID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgY29uc3Qgb3BhY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRPcGFjaXR5KCksXG4gICAgICAgICAgY2hpbGROb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRQcmVjZWRlbmNlKCk7XG5cbiAgICBub25UZXJtaW5hbE5vZGUgPSBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTtcblxuICAgIHJld3JpdGVEaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBzdGF0ZSk7XG5cbiAgICBjb25zdCBwYXJlbnROb2RlID0gcmV3cml0ZUluZGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuXG4gICAge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gcGFyZW50Tm9kZTsgLy8vXG5cbiAgICAgIHJld3JpdGVSZWR1Y2VkTm9kZXMobm9uVGVybWluYWxOb2RlLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIGlzVW5wcmVjZWRlbnRlZCgpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSB0aGlzLCAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gaXNOb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkKG5vblRlcm1pbmFsTm9kZSksXG4gICAgICAgICAgdW5wcmVjZWRlbnRlZCA9IG5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQ7IC8vL1xuXG4gICAgcmV0dXJuIHVucHJlY2VkZW50ZWQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJld3JpdHRlbk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcGVybXV0ZVJ1bGVOYW1lcyhydWxlTmFtZXMsIHJ1bGVOYW1lKSB7XG4gIGxldCBzdGFydCxcbiAgICAgICAgZW5kO1xuXG4gIGNvbnN0IGluZGV4ID0gcnVsZU5hbWVzLmluZGV4T2YocnVsZU5hbWUpO1xuXG4gIHN0YXJ0ID0gMDtcblxuICBlbmQgPSBpbmRleDsgIC8vL1xuXG4gIGNvbnN0IGxlYWRpbmdSdWxlTmFtZXMgPSBydWxlTmFtZXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgc3RhcnQgPSBpbmRleDsgIC8vL1xuXG4gIGNvbnN0IHRyYWlsaW5nUnVsZU5hbWVzID0gcnVsZU5hbWVzLnNsaWNlKHN0YXJ0KSxcbiAgICAgICAgcGVybXV0ZWRSdWxlTmFtZXMgPSBbXG4gICAgICAgICAgLi4udHJhaWxpbmdSdWxlTmFtZXMsXG4gICAgICAgICAgLi4ubGVhZGluZ1J1bGVOYW1lc1xuICAgICAgICBdO1xuXG4gIHJldHVybiBwZXJtdXRlZFJ1bGVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJ1bGVOYW1lc0xlbmd0aCA9IHJ1bGVOYW1lcy5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IHJ1bGVOYW1lc0xlbmd0aCAtIDE7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5leHRJbmRleCA9IChpbmRleCA9PT0gbGFzdEluZGV4KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lc1tuZXh0SW5kZXhdO1xuXG4gICAgY2FsbGJhY2socnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgaW5kZXgpO1xuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUGFydHMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IFJ1bGVOYW1lUGFydCwgWmVyb09yTW9yZVBhcnRzUGFydCB9ID0gUGFydHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgY29uc3QgcnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lUGFydDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm9Pck1vcmVQYXJ0c1BhcnRGcm9tUGFydChwYXJ0KSB7XG4gIGNvbnN0IHplcm9Pck1vcmVQYXJ0c1BhcnQgPSBaZXJvT3JNb3JlUGFydHNQYXJ0LmZyb21QYXJ0KHBhcnQpO1xuXG4gIHJldHVybiB6ZXJvT3JNb3JlUGFydHNQYXJ0O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgcGVybXV0ZVJ1bGVOYW1lcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5pbXBvcnQgeyBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhcnRcIjtcbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuY29uc3QgeyBsYXN0LCBtYXRjaCwgY29tcHJlc3MgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gYXJlUGF0aHNFcXVhbChwYXRoQSwgcGF0aEIpIHtcbiAgY29uc3QgcnVsZU5hbWVzQSA9IHBhdGhBLCAvLy9cbiAgICAgICAgcnVsZU5hbWVzQiA9IHBhdGhCLCAvLy9cbiAgICAgICAgcnVsZU5hbWVzTWF0Y2ggPSBtYXRjaChydWxlTmFtZXNBLCBydWxlTmFtZXNCLCAocnVsZU5hbWVBLCBydWxlTmFtZUIpID0+IHtcbiAgICAgICAgICBpZiAocnVsZU5hbWVBID09PSBydWxlTmFtZUIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHBhdGhzRXF1YWwgPSBydWxlTmFtZXNNYXRjaDsgIC8vL1xuXG4gIHJldHVybiBwYXRoc0VxdWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZmVyZW5jZUZyb21QYXRocyhwYXRoQSwgcGF0aEIsIHJ1bGVOYW1lLCBydWxlTWFwLCBydWxlTmFtZXNNYXApIHtcbiAgbGV0IGRpZmZlcmVuY2U7XG5cbiAgY29uc3QgcGF0aEFMZW5ndGggPSBwYXRoQS5sZW5ndGgsXG4gICAgICAgIHBhdGhCTGVuZ3RoID0gcGF0aEIubGVuZ3RoO1xuXG4gIGlmIChmYWxzZSkge1xuICAgIC8vL1xuICB9IGVsc2UgaWYgKChwYXRoQUxlbmd0aCA9PT0gMSkpIHtcbiAgICBkaWZmZXJlbmNlID0gLTE7XG4gIH0gZWxzZSBpZiAoKHBhdGhCTGVuZ3RoID09PSAxKSkge1xuICAgIGRpZmZlcmVuY2UgPSArMTtcbiAgfSBlbHNlIGlmICgocGF0aEFMZW5ndGggPT09IDApICYmIChwYXRoQkxlbmd0aCA9PT0gMCkpIHtcbiAgICBkaWZmZXJlbmNlID0gMDtcbiAgfSBlbHNlIGlmICgocGF0aEFMZW5ndGggPT09IDApKSB7XG4gICAgZGlmZmVyZW5jZSA9ICsxO1xuICB9IGVsc2UgaWYgKChwYXRoQkxlbmd0aCA9PT0gMCkpIHtcbiAgICBkaWZmZXJlbmNlID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcnVsZU5hbWVzQSA9IHBhdGhBLnNsaWNlKCksXG4gICAgICAgICAgcnVsZU5hbWVzQiA9IHBhdGhCLnNsaWNlKCksXG4gICAgICAgICAgcnVsZU5hbWVBID0gcnVsZU5hbWVzQS5zaGlmdCgpLFxuICAgICAgICAgIHJ1bGVOYW1lQiA9IHJ1bGVOYW1lc0Iuc2hpZnQoKTtcblxuICAgIGlmIChydWxlTmFtZUEgPT09IHJ1bGVOYW1lQikge1xuICAgICAgcGF0aEEgPSBydWxlTmFtZXNBOyAvLy9cblxuICAgICAgcGF0aEIgPSBydWxlTmFtZXNCOyAvLy9cblxuICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZUE7IC8vL1xuXG4gICAgICBkaWZmZXJlbmNlID0gZGlmZmVyZW5jZUZyb21QYXRocyhwYXRoQSwgcGF0aEIsIHJ1bGVOYW1lLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNNYXBbcnVsZU5hbWVdLFxuICAgICAgICAgICAgaW5kZXhBID0gcnVsZU5hbWVzLmluZGV4T2YocnVsZU5hbWVBKSxcbiAgICAgICAgICAgIGluZGV4QiA9IHJ1bGVOYW1lcy5pbmRleE9mKHJ1bGVOYW1lQik7XG5cbiAgICAgIGRpZmZlcmVuY2UgPSAoaW5kZXhBIC0gaW5kZXhCKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlmZmVyZW5jZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZWRSdWxlTmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gcGF0aCwgLy8vXG4gICAgICAgIGxhc3RSdWxlTmFtZSA9IGxhc3QocnVsZU5hbWVzKSxcbiAgICAgICAgcnVsZU5hbWUgPSBsYXN0UnVsZU5hbWUsIC8vL1xuICAgICAgICByZWR1Y2VkUnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gIHJldHVybiByZWR1Y2VkUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoc0Zyb21SdWxlTmFtZUFuZEN5Y2xlcyhydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApIHtcbiAgY29uc3QgcGF0aHMgPSBjeWNsZXMucmVkdWNlKChwYXRocywgY3ljbGUpID0+IHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpLFxuICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgIGNvbnN0IHBlcm11dGVkUnVsZU5hbWVzID0gcGVybXV0ZVJ1bGVOYW1lcyhydWxlTmFtZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICAgIHBhdGggPSBwZXJtdXRlZFJ1bGVOYW1lczsgLy8vXG5cbiAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9LCBbXSk7XG5cbiAgbGV0IGxlbmd0aDtcblxuICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gMSkge1xuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoKTsgIC8vL1xuXG4gICAgICBwYXRoLnBvcCgpO1xuXG4gICAgICBwYXRocy5wdXNoKHBhdGgpO1xuXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbXByZXNzKHBhdGhzLCAocGF0aEEsIHBhdGhCKSA9PiB7XG4gICAgY29uc3QgcGF0aHNFcXVhbCA9IGFyZVBhdGhzRXF1YWwocGF0aEEsIHBhdGhCKTtcblxuICAgIGlmICghcGF0aHNFcXVhbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBydWxlTmFtZSA9IG51bGw7XG5cbiAgcGF0aHMuc29ydCgocGF0aEEsIHBhdGhCKSA9PiB7XG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VGcm9tUGF0aHMocGF0aEEsIHBhdGhCLCBydWxlTmFtZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcblxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xuICB9KTtcblxuICByZXR1cm4gcGF0aHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VkUnVsZU5hbWVQYXJ0RnJvbVBhdGgocGF0aCkge1xuICBjb25zdCByZWR1Y2VkUnVsZU5hbWUgPSByZWR1Y2VkUnVsZU5hbWVGcm9tUGF0aChwYXRoKSxcbiAgICAgICAgcmVkdWNlZFJ1bGVOYW1lUGFydCA9IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZShyZWR1Y2VkUnVsZU5hbWUpO1xuXG4gIHJldHVybiByZWR1Y2VkUnVsZU5hbWVQYXJ0O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBEZWZpbml0aW9uIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgcmVkdWNlZFJ1bGVOYW1lRnJvbVBhdGgsIHJlZHVjZWRSdWxlTmFtZVBhcnRGcm9tUGF0aCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGF0aFwiO1xuaW1wb3J0IHsgcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lLCB6ZXJvT3JNb3JlUGFydHNQYXJ0RnJvbVBhcnQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhcnRcIjtcbmltcG9ydCB7IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZSwgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXdyaXR0ZW5EZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tUGF0aChwYXRoLCBydWxlTWFwKSB7XG4gICAgbGV0IHJld3JpdHRlbkRlZmluaXRpb24gPSBudWxsO1xuXG4gICAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVBhdGgocGF0aCksXG4gICAgICAgICAgcmVkdWNlZFJ1bGUgPSBydWxlTWFwW3JlZHVjZWRSdWxlTmFtZV0gfHwgbnVsbDtcblxuICAgIGlmIChyZWR1Y2VkUnVsZSAhPT0gbnVsbCkge1xuICAgICAgcmV3cml0dGVuRGVmaW5pdGlvbiA9IHJld3JpdHRlbkRlZmluaXRpb25Gcm9tUGF0aChwYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV3cml0dGVuRGVmaW5pdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXZlcnNlUGF0aChwYXRoKSB7XG4gIGNvbnN0IHJldmVyc2VkUGF0aCA9IHBhdGguc2xpY2UoKTtcblxuICByZXZlcnNlZFBhdGgucmV2ZXJzZSgpO1xuXG4gIHJldHVybiByZXZlcnNlZFBhdGg7XG59XG5cbmZ1bmN0aW9uIHJld3JpdHRlbkRlZmluaXRpb25Gcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IHJlZHVjZWRSdWxlTmFtZVBhcnQgPSByZWR1Y2VkUnVsZU5hbWVQYXJ0RnJvbVBhdGgocGF0aCksXG4gICAgICAgIHJldmVyc2VkUGF0aCA9IHJldmVyc2VQYXRoKHBhdGgpLFxuICAgICAgICBydWxlTmFtZXMgPSByZXZlcnNlZFBhdGgsIC8vL1xuICAgICAgICBydWxlTmFtZXNMZW5ndGggPSBydWxlTmFtZXMubGVuZ3RoLFxuICAgICAgICBsYXN0SW5kZXggPSBydWxlTmFtZXNMZW5ndGggLSAxLFxuICAgICAgICBwYXJ0cyA9IFtdOyAvLy9cblxuICBwYXJ0cy5wdXNoKHJlZHVjZWRSdWxlTmFtZVBhcnQpO1xuXG4gIGZvckVhY2hSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZXMsIChydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFBhcnQgPSBkaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICAgIHBhcnRzLnB1c2goZGlyZWN0bHlSZXBlYXRlZFBhcnQpO1xuXG4gICAgICBjb25zdCB0ZW1wb3JhcnlSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZTsgLy8vXG5cbiAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lOyAvLy9cblxuICAgICAgcnVsZU5hbWUgPSB0ZW1wb3JhcnlSdWxlTmFtZTsgIC8vL1xuXG4gICAgICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gaW5kaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKTtcblxuICAgICAgcGFydHMucHVzaChpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChydWxlTmFtZXNMZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBmaXJzdFJ1bGVOYW1lID0gZmlyc3QocnVsZU5hbWVzKSxcbiAgICAgICAgICBydWxlTmFtZSA9IGZpcnN0UnVsZU5hbWUsXG4gICAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFBhcnQgPSBkaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBwYXJ0cy5wdXNoKGRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcbiAgfVxuXG4gIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICByZXdyaXR0ZW5EZWZpbml0aW9uID0gbmV3IFJld3JpdHRlbkRlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gIHJldHVybiByZXdyaXR0ZW5EZWZpbml0aW9uO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZShydWxlTmFtZSkge1xuICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSksXG4gICAgICAgIHplcm9Pck1vcmVEaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0c1BhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0RnJvbVBhcnQoZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCksXG4gICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gemVyb09yTW9yZURpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnRzUGFydDsgLy8vXG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0O1xufVxuXG5mdW5jdGlvbiBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUGFydCA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydDsgIC8vL1xuXG4gIHJldHVybiBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0O1xufVxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJ1bGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgUmV3cml0dGVuTm9kZSBmcm9tIFwiLi4vbm9kZS9yZXdyaXR0ZW5cIjtcbmltcG9ydCBSZXdyaXR0ZW5EZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uL3Jld3JpdHRlblwiO1xuXG5pbXBvcnQgeyBwYXRoc0Zyb21SdWxlTmFtZUFuZEN5Y2xlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGF0aFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXdyaXR0ZW5SdWxlIGV4dGVuZHMgUnVsZSB7XG4gIE5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSwgc3RhdGUpIHtcbiAgICBjb25zdCBOb25UZXJtaW5hbE5vZGUgPSBSZXdyaXR0ZW5Ob2RlO1xuXG4gICAgcmV0dXJuIE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZUFuZEN5Y2xlcyhydWxlLCBjeWNsZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICAgIGNvbnN0IGRlZmluaXRpb25zID0gW10sXG4gICAgICAgICAgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICBwYXRocyA9IHBhdGhzRnJvbVJ1bGVOYW1lQW5kQ3ljbGVzKHJ1bGVOYW1lLCBjeWNsZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCk7XG5cbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBjb25zdCByZXdyaXR0ZW5EZWZpbml0aW9uID0gUmV3cml0dGVuRGVmaW5pdGlvbi5mcm9tUGF0aChwYXRoLCBydWxlTWFwKTtcblxuICAgICAgaWYgKHJld3JpdHRlbkRlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHJld3JpdHRlbkRlZmluaXRpb247IC8vL1xuXG4gICAgICAgIGRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBuYW1lID0gcnVsZU5hbWUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gcnVsZS5nZXRPcGFjaXR5KCksXG4gICAgICAgICAgcmV3cml0dGVuUnVsZSA9IG5ldyBSZXdyaXR0ZW5SdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiByZXdyaXR0ZW5SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9jeWNsZVwiO1xuaW1wb3J0IHsgcGVybXV0ZVJ1bGVOYW1lcywgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZSwgemVyb09yTW9yZVBhcnRzUGFydEZyb21QYXJ0IH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wYXJ0XCI7XG5pbXBvcnQgeyBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUsIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ydWxlTmFtZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVJ1bGVBbmRDeWNsZShydWxlLCBjeWNsZSkge1xuICAgIGxldCBkaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbiA9IG51bGw7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSksXG4gICAgICAgICAgcnVsZU5hbWVJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgIGlmIChydWxlTmFtZUluY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgIGNvbnN0IHBlcm11dGVkUnVsZU5hbWVzID0gcGVybXV0ZVJ1bGVOYW1lcyhydWxlTmFtZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICAgIHBhdGggPSBwZXJtdXRlZFJ1bGVOYW1lcywgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IHBhcnRzRnJvbVBhdGgocGF0aCksXG4gICAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbDtcblxuICAgICAgZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gPSBuZXcgRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJtdXRlUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBlcm11dGVkUGF0aCA9IHBhdGguc2xpY2UoKTsgIC8vL1xuXG4gIHBlcm11dGVkUGF0aC5yZXZlcnNlKCk7XG5cbiAgY29uc3QgcnVsZU5hbWUgPSBwZXJtdXRlZFBhdGgucG9wKCk7XG5cbiAgcGVybXV0ZWRQYXRoLnVuc2hpZnQocnVsZU5hbWUpO1xuXG4gIHJldHVybiBwZXJtdXRlZFBhdGg7XG59XG5cbmZ1bmN0aW9uIHBhcnRzRnJvbVBhdGgocGF0aCkge1xuICBjb25zdCBwZXJtdXRlZFBhdGggPSBwZXJtdXRlUGF0aChwYXRoKSxcbiAgICAgICAgcnVsZU5hbWVzID0gcGVybXV0ZWRQYXRoLCAvLy9cbiAgICAgICAgcGFydHMgPSBbXTtcblxuICBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWVzLCAocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHRlbXBvcmFyeVJ1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lOyAvLy9cblxuICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lOyAvLy9cblxuICAgIHJ1bGVOYW1lID0gdGVtcG9yYXJ5UnVsZU5hbWU7ICAvLy9cblxuICAgIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFBhcnQgPSBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lQW5kTGVmdFJldWNyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcGFydHMucHVzaChpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcblxuICAgIHBhcnRzLnB1c2goZGlyZWN0bHlSZXBlYXRlZFBhcnQpO1xuICB9KTtcblxuICBwYXJ0cy5wb3AoKTtcblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnQgPSBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUoZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSxcbiAgICAgICAgemVyb09yTW9yZURpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnRzUGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnRGcm9tUGFydChkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0KSxcbiAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFBhcnQgPSB6ZXJvT3JNb3JlRGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydHNQYXJ0OyAvLy9cblxuICByZXR1cm4gZGlyZWN0bHlSZXBlYXRlZFBhcnQ7XG59XG5cbmZ1bmN0aW9uIGluZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWVBbmRMZWZ0UmV1Y3JzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnQgPSBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUoaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUpLFxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0OyAgLy8vXG5cbiAgcmV0dXJuIGluZGlyZWN0bHlSZXBlYXRlZFBhcnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJ1bGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgRGlyZWN0bHlSZXBlYXRlZE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvcmVwZWF0ZWQvZGlyZWN0bHlcIjtcbmltcG9ydCBEaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9yZXBlYXRlZC9kaXJlY3RseVwiXG5cbmltcG9ydCB7IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0bHlSZXBlYXRlZFJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lLCBzdGF0ZSkge1xuICAgIGNvbnN0IE5vblRlcm1pbmFsTm9kZSA9IERpcmVjdGx5UmVwZWF0ZWROb2RlO1xuXG4gICAgcmV0dXJuIE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZUFuZEN5Y2xlcyhydWxlLCBjeWNsZXMpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW107XG5cbiAgICBjeWNsZXMubWFwKChjeWNsZSkgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gPSBEaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbi5mcm9tUnVsZUFuZEN5Y2xlKHJ1bGUsIGN5Y2xlKTtcblxuICAgICAgaWYgKGRpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBkaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbjsgIC8vL1xuXG4gICAgICAgIGRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBydWxlLmdldE9wYWNpdHkoKSxcbiAgICAgICAgICBkaXJlY3RseVJlcGVhdGVkUnVsZSA9IG5ldyBEaXJlY3RseVJlcGVhdGVkUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZGlyZWN0bHlSZXBlYXRlZFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBSZXdyaXR0ZW5SdWxlIGZyb20gXCIuL3J1bGUvcmV3cml0dGVuXCI7XG5pbXBvcnQgRGlyZWN0bHlSZXBlYXRlZFJ1bGUgZnJvbSBcIi4vcnVsZS9yZXBlYXRlZC9kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBpc1J1bGVOb25Db25zdW1pbmcgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9uQ29uc3VtaW5nXCI7XG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5pbXBvcnQgeyBpc0N5Y2xlSXJyZWR1Y2libGUsIHJ1bGVDeWNsZXNGcm9tUnVsZU5hbWVBbmRDeWNsZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvY3ljbGVcIjtcblxuY29uc3QgeyBmaWx0ZXIgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzKGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZXMoY3ljbGVzKTtcblxuICBydWxlTmFtZXMuZm9yRWFjaCgocnVsZU5hbWUpID0+IHtcbiAgICBsZXQgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdO1xuXG4gICAgY29uc3QgcmV3cml0dGVuUnVsZSA9IFJld3JpdHRlblJ1bGUuZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuXG4gICAgcnVsZSA9IHJld3JpdHRlblJ1bGU7IC8vL1xuXG4gICAgcnVsZU1hcFtydWxlTmFtZV0gPSBydWxlO1xuICB9KTtcblxuICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZXMgPSBydWxlc0Zyb21SdWxlKERpcmVjdGx5UmVwZWF0ZWRSdWxlLCBydWxlTWFwKTtcblxuICBkaXJlY3RseVJlcGVhdGVkUnVsZXMuZm9yRWFjaCgoZGlyZWN0bHlSZXBlYXRlZFJ1bGUpID0+IHtcbiAgICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5vbkNvbnN1bWluZyA9IGlzUnVsZU5vbkNvbnN1bWluZyhkaXJlY3RseVJlcGVhdGVkUnVsZSwgcnVsZU1hcCk7XG5cbiAgICBpZiAoZGlyZWN0bHlSZXBlYXRlZFJ1bGVOb25Db25zdW1pbmcpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGRpcmVjdGx5UmVwZWF0ZWRSdWxlLmdldE5hbWUoKTtcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGlyZWN0bHkgcmVwZWF0ZWQgJyR7ZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lfScgcnVsZSBpcyBub24tY29uc3VtaW5nLmApO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgY29uc3QgcnVsZUN5Y2xlcyA9IHJ1bGVDeWNsZXNGcm9tUnVsZU5hbWVBbmRDeWNsZXMocnVsZU5hbWUsIGN5Y2xlcyksXG4gICAgICAgICAgcnVsZUN5Y2xlc0lycmVkdWNpYmxlID0gcnVsZUN5Y2xlcy5ldmVyeSgocnVsZUN5Y2xlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydWxlQ3ljbGVJcnJlZHVjaWJsZSA9IGlzQ3ljbGVJcnJlZHVjaWJsZShydWxlQ3ljbGUsIHJ1bGVNYXApO1xuXG4gICAgICAgICAgICBpZiAocnVsZUN5Y2xlSXJyZWR1Y2libGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICBpZiAocnVsZUN5Y2xlc0lycmVkdWNpYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbmUgb2YgdGhlIGN5Y2xlcyBpbmNsdWRpbmcgdGhlICcke3J1bGVOYW1lfScgcnVsZSBoYXZlIGEgcmVkdWNlZCBydWxlLmApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bGVzRnJvbVJ1bGUoUnVsZSwgcnVsZU1hcCkge1xuICBjb25zdCBydWxlcyA9IE9iamVjdC52YWx1ZXMocnVsZU1hcCk7IC8vL1xuXG4gIGZpbHRlcihydWxlcywgKHJ1bGUpID0+IHtcbiAgICBjb25zdCBydWxlUnVsZSA9IChydWxlIGluc3RhbmNlb2YgUnVsZSk7XG5cbiAgICBpZiAocnVsZVJ1bGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGlyZWN0bHlSZXBlYXRlZFJ1bGUgZnJvbSBcIi4vcnVsZS9yZXBlYXRlZC9kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZURpcmVjdGx5UmVwZWF0ZWRSdWxlcyhjeWNsZXMsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlcyhjeWNsZXMpO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgICBkaXJlY3RseVJlcGVhdGVkUnVsZSA9IERpcmVjdGx5UmVwZWF0ZWRSdWxlLmZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCksXG4gICAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgcnVsZU1hcFtkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVdID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGU7XG4gIH0pO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBQYXJ0cywgRGVmaW5pdGlvbiB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNvbnN0IHsgRXBzaWxvblBhcnQgfSA9IFBhcnRzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcHNpbG9uRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVByZWNlZGVuY2UocHJlY2VkZW5jZSkge1xuICAgIGNvbnN0IGVwc2lsb25QYXJ0ID0gRXBzaWxvblBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIGVwc2lsb25QYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBlcHNpbG9uRGVmaW5pdGlvbiA9IEVwc2lsb25EZWZpbml0aW9uLmZyb21QYXJ0c0FuZFByZWNlZGVuY2UocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25EZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGFyZVBhcnRzRXF1YWwocGFydHMpIHtcbiAgY29uc3QgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBmaXJzdFBhcnRTdHJpbmcgPSBmaXJzdFBhcnQuYXNTdHJpbmcoKSxcbiAgICAgICAgcGFydHNFcXVhbCA9IHBhcnRzLmV2ZXJ5KChwYXJ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydFN0cmluZyA9IHBhcnQuYXNTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBwYXJ0U3RyaW5nRmlyc3RQYXJ0U3RyaW5nID0gKHBhcnRTdHJpbmcgPT09IGZpcnN0UGFydFN0cmluZyk7XG5cbiAgICAgICAgICBpZiAocGFydFN0cmluZ0ZpcnN0UGFydFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICByZXR1cm4gcGFydHNFcXVhbDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFydFR5cGVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuY29uc3QgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVsZU5vblByb2R1Y2luZyhydWxlLCBydWxlTWFwLCBydWxlTmFtZXMgPSBbXSkge1xuICBsZXQgcnVsZU5vblByb2R1Y2luZyA9IGZhbHNlO1xuXG4gIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gIGlmICghcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgIHJ1bGVOYW1lcyA9IFsgLy8vXG4gICAgICAuLi5ydWxlTmFtZXMsXG4gICAgICBydWxlTmFtZVxuICAgIF07XG5cbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKSxcbiAgICAgICAgICBkZWZpbml0aW9uc05vblByb2R1Y2luZyA9IGFyZURlZmluaXRpb25zTm9uUHJvZHVjaW5nKGRlZmluaXRpb25zLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgcnVsZU5vblByb2R1Y2luZyA9IGRlZmluaXRpb25zTm9uUHJvZHVjaW5nOyAvLy9cbiAgfVxuXG4gIHJldHVybiBydWxlTm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBhcmVEZWZpbml0aW9uc05vblByb2R1Y2luZyhkZWZpbml0aW9ucywgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGNvbnN0IGRlZmluaXRpb25zTm9uUHJvZHVjaW5nID0gZGVmaW5pdGlvbnMuZXZlcnkoKGRlZmluaXRpb24pID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uTm9uUHJvZHVjaW5nID0gaXNEZWZpbml0aW9uTm9uUHJvZHVjaW5nKGRlZmluaXRpb24sIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbk5vblByb2R1Y2luZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvbnNOb25Qcm9kdWNpbmc7XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5pdGlvbk5vblByb2R1Y2luZyhkZWZpbml0aW9uLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIHBhcnRzTm9uUHJvZHVjaW5nID0gYXJlUGFydHNOb25Qcm9kdWNpbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcyksXG4gICAgICAgIGRlZmluaXRpb25Ob25Qcm9kdWNpbmcgPSBwYXJ0c05vblByb2R1Y2luZztcblxuICByZXR1cm4gZGVmaW5pdGlvbk5vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gYXJlUGFydHNOb25Qcm9kdWNpbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0c05vblByb2R1Y2luZyA9IHBhcnRzLmV2ZXJ5KChwYXJ0KSA9PiB7XG4gICAgY29uc3QgcGFydE5vblByb2R1Y2luZyA9IGlzUGFydE5vblByb2R1Y2luZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgaWYgKHBhcnROb25Qcm9kdWNpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnRzTm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBpc1BhcnROb25Qcm9kdWNpbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGxldCBwYXJ0Tm9uUHJvZHVjaW5nO1xuXG4gIGNvbnN0IHBhclRlcm1pbmFsUGFydCA9IHBhcnQuaXNUZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFyVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3QgdGVybWluYWxQYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsUGFydFVzZWxlc3MgPSBpc1Rlcm1pbmFsUGFydE5vblByb2R1Y2luZyh0ZXJtaW5hbFBhcnQpO1xuXG4gICAgcGFydE5vblByb2R1Y2luZyA9IHRlcm1pbmFsUGFydFVzZWxlc3M7IC8vL1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsTlBhcnQgPSBwYXJ0LCAgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nID0gaXNOb25UZXJtaW5hbFBhcnROb25Qcm9kdWNpbmcobm9uVGVybWluYWxOUGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIHBhcnROb25Qcm9kdWNpbmcgPSBub25UZXJtaW5hbFBhcnROb25Qcm9kdWNpbmc7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHBhcnROb25Qcm9kdWNpbmc7XG59XG5cbmZ1bmN0aW9uIGlzVGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nKHRlcm1pbmFsUGFydCkge1xuICBjb25zdCB0ZXJtaW5hbFBhcnROb25Qcm9kdWNpbmcgPSBmYWxzZTtcblxuICByZXR1cm4gdGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBpc05vblRlcm1pbmFsUGFydE5vblByb2R1Y2luZyhub25UZXJtaW5hbFBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBsZXQgcGFydE5vblByb2R1Y2luZyA9IGZhbHNlO1xuXG4gIGNvbnN0IHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUnVsZU5hbWVQYXJ0VHlwZToge1xuICAgICAgY29uc3QgcnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IHJ1bGVOYW1lUGFydC5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdIHx8IG51bGw7XG5cbiAgICAgIGlmIChydWxlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVOb25Qcm9kdWNpbmcgPSBpc1J1bGVOb25Qcm9kdWNpbmcocnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gcnVsZU5vblByb2R1Y2luZzsgIC8vL1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIE9wdGlvbmFsUGFydFBhcnRUeXBlOiB7XG4gICAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gdHJ1ZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBjb25zdCBvbmVPck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgIHBhcnQgPSBvbmVPck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpO1xuXG4gICAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gaXNQYXJ0Tm9uUHJvZHVjaW5nKHBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgWmVyb09yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgIHBhcnROb25Qcm9kdWNpbmcgPSB0cnVlO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBjb25zdCBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgIHBhcnRzID0gc2VxdWVuY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpLFxuICAgICAgICAgICAgcGFydHNOb25Qcm9kdWNpbmcgPSBhcmVQYXJ0c05vblByb2R1Y2luZyhwYXJ0cywgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgcGFydE5vblByb2R1Y2luZyA9IHBhcnRzTm9uUHJvZHVjaW5nOyAvLy9cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBDaG9pY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IGNob2ljZU9mUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgIHBhcnRzID0gY2hvaWNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKSxcbiAgICAgICAgICAgIHBhcnRzTm9uUHJvZHVjaW5nID0gcGFydHMuZXZlcnkoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydE5vblByb2R1Y2luZyA9IGlzUGFydE5vblByb2R1Y2luZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0Tm9uUHJvZHVjaW5nO1xuICAgICAgICAgICAgfSlcblxuICAgICAgcGFydE5vblByb2R1Y2luZyA9IHBhcnRzTm9uUHJvZHVjaW5nOyAvLy9cblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnROb25Qcm9kdWNpbmc7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IFJ1bGVOYW1lUGFydFR5cGUsXG4gICAgICAgIE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICAgICAgICBDaG9pY2VPZlBhcnRzUGFydFR5cGUsXG4gICAgICAgIE9uZU9yTW9yZVBhcnRzUGFydFR5cGUsXG4gICAgICAgIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSB9ID0gcGFydFR5cGVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uQ29tcGxleChkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIGZpcnN0UGFydENvbXBsZXggPSBpc1BhcnRDb21wbGV4KGZpcnN0UGFydCksXG4gICAgICAgIGRlZmluaXRpb25Db21wbGV4ID0gZmlyc3RQYXJ0Q29tcGxleDsgLy8vXG5cbiAgcmV0dXJuIGRlZmluaXRpb25Db21wbGV4O1xufVxuXG5mdW5jdGlvbiBpc1BhcnRDb21wbGV4KHBhcnQpIHtcbiAgbGV0IHBhcnRDb21wbGV4ID0gdHJ1ZTtcblxuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUnVsZU5hbWVQYXJ0VHlwZToge1xuICAgICAgICBwYXJ0Q29tcGxleCA9IGZhbHNlO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIE9wdGlvbmFsUGFydFBhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUGFydFBhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gb3B0aW9uYWxQYXJ0UGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgcGFydENvbXBsZXggPSBpc1BhcnRDb21wbGV4KHBhcnQpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIE9uZU9yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3Qgb25lT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICAgIHBhcnQgPSBvbmVPck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgIHBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChwYXJ0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpOyAgLy8vXG5cbiAgICAgICAgcGFydENvbXBsZXggPSBpc1BhcnRDb21wbGV4KHBhcnQpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlOlxuICAgICAgY2FzZSBDaG9pY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgcGFydENvbXBsZXggPSB0cnVlO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0Q29tcGxleDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5pbXBvcnQge2lzUGFydE5vbkNvbnN1bWluZ30gZnJvbSBcIi4vbm9uQ29uc3VtaW5nXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uT2NjbHVkZWQoZGVmaW5pdGlvbiwgcnVsZU1hcCwgcnVsZU5hbWVzID0gW10pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgZmlyc3RQYXJ0Tm9uQ29uc3VtaW5nID0gaXNQYXJ0Tm9uQ29uc3VtaW5nKGZpcnN0UGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKSxcbiAgICAgICAgZGVmaW5pdGlvbk9jY2x1ZGVkID0gZmlyc3RQYXJ0Tm9uQ29uc3VtaW5nOyAgLy8vXG5cbiAgcmV0dXJuIGRlZmluaXRpb25PY2NsdWRlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uQ2FsbEFoZWFkKGRlZmluaXRpb24pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgZmlyc3RQYXJ0Q2FsbEFoZWFkID0gaXNQYXJ0Q2FsbEFoZWFkKGZpcnN0UGFydCksXG4gICAgICAgIGRlZmluaXRpb25DYWxsQWhlYWQgPSBmaXJzdFBhcnRDYWxsQWhlYWQ7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uQ2FsbEFoZWFkO1xufVxuXG5mdW5jdGlvbiBpc1BhcnRDYWxsQWhlYWQocGFydCkge1xuICBsZXQgcGFydENhbGxBaGVhZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHBhcnROb25UZXJtaW5hbFBhcnQgPSBwYXJ0LmlzTm9uVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhcnROb25UZXJtaW5hbFBhcnQpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbFBhcnQgPSBwYXJ0LCAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQuaXNSdWxlTmFtZVBhcnQoKTtcblxuICAgIGlmIChub25UZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQpIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBjYWxsQWhlYWQgPSBydWxlTmFtZVBhcnQuaXNDYWxsQWhlYWQoKTtcblxuICAgICAgcGFydENhbGxBaGVhZCA9IGNhbGxBaGVhZDsgIC8vL1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0Q2FsbEFoZWFkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJ0VHlwZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgT3B0aW9uYWxQYXJ0UGFydFR5cGUsIE9uZU9yTW9yZVBhcnRzUGFydFR5cGUsIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJ0UXVhbGlmaWVkKHBhcnQpIHtcbiAgbGV0IHBhcnRRdWFsaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgT3B0aW9uYWxQYXJ0UGFydFR5cGU6XG4gICAgICBjYXNlIE9uZU9yTW9yZVBhcnRzUGFydFR5cGU6XG4gICAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIHBhcnRRdWFsaWZpZWQgPSB0cnVlO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0UXVhbGlmaWVkO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluaXRpb25RdWFsaWZpZWQoZGVmaW5pdGlvbikge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBmaXJzdFBhcnRRdWFsaWZpZWQgPSBpc1BhcnRRdWFsaWZpZWQoZmlyc3RQYXJ0KSxcbiAgICAgICAgZGVmaW5pdGlvblF1YWxpZmllZCA9IGZpcnN0UGFydFF1YWxpZmllZDsgLy8vXG5cbiAgcmV0dXJuIGRlZmluaXRpb25RdWFsaWZpZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgUnVsZSwgRGVmaW5pdGlvbiB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBFcHNpbG9uRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9lcHNpbG9uXCI7XG5pbXBvcnQgSW5kaXJlY3RseVJlcGVhdGVkTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9yZXBlYXRlZC9pbmRpcmVjdGx5XCI7XG5cbmltcG9ydCB7IGFyZVBhcnRzRXF1YWwgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3BhcnRzXCI7XG5pbXBvcnQgeyBpc1J1bGVOb25Qcm9kdWNpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vblByb2R1Y2luZ1wiO1xuaW1wb3J0IHsgaXNEZWZpbml0aW9uQ29tcGxleCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvY29tcGxleFwiO1xuaW1wb3J0IHsgaXNEZWZpbml0aW9uT2NjbHVkZWQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL29jY2x1ZGVkXCI7XG5pbXBvcnQgeyBpc0RlZmluaXRpb25DYWxsQWhlYWQgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2NhbGxBaGVhZFwiO1xuaW1wb3J0IHsgaXNEZWZpbml0aW9uUXVhbGlmaWVkIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9xdWFsaWZpZWRcIjtcbmltcG9ydCB7IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ydWxlTmFtZVwiO1xuaW1wb3J0IHsgaXNEZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9sZWZ0UmVjdXJzaXZlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIE5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSwgc3RhdGUpIHtcbiAgICBjb25zdCBOb25UZXJtaW5hbE5vZGUgPSBJbmRpcmVjdGx5UmVwZWF0ZWROb2RlO1xuXG4gICAgcmV0dXJuIE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZUFuZExlZnRSZWN1cnNpdmVSdWxlKHJ1bGUsIGxlZnRSZWN1cnNpdmVSdWxlLCBydWxlTWFwKSB7XG4gICAgbGV0IGRlZmluaXRpb25zID0gcnVsZS5nZXREZWZpbml0aW9ucygpO1xuXG4gICAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgbGV0IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucyA9IGRlZmluaXRpb25zLmZpbHRlcigoZGVmaW5pdGlvbikgPT4geyAgLy8vXG4gICAgICBjb25zdCBkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSA9IGlzRGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUoZGVmaW5pdGlvbiwgcnVsZU1hcCk7XG5cbiAgICAgIGlmIChkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZSkge1xuICAgICAgICBjb25zdCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21EZWZpbml0aW9uKGRlZmluaXRpb24sIHJ1bGVNYXApLFxuICAgICAgICAgICAgICBmaXJzdExlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGZpcnN0KGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGlmIChmaXJzdExlZnRSZWN1cnNpdmVSdWxlTmFtZSA9PT0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3RyaW5nID0gZGVmaW5pdGlvbi5hc1N0cmluZygpO1xuXG4gICAgICAgICAgY29uc3QgZGVmaW5pdGlvbkNvbXBsZXggPSBpc0RlZmluaXRpb25Db21wbGV4KGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25Db21wbGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtkZWZpbml0aW9uU3RyaW5nfScgbGVmdCByZWN1cnNpdmUtZGVmaW5pdGlvbiBvZiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlIGlzIGNvbXBsZXguYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGVmaW5pdGlvbk9jY2x1ZGVkID0gaXNEZWZpbml0aW9uT2NjbHVkZWQoZGVmaW5pdGlvbiwgcnVsZU1hcCk7XG5cbiAgICAgICAgICBpZiAoZGVmaW5pdGlvbk9jY2x1ZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uU3RyaW5nID0gZGVmaW5pdGlvbi5hc1N0cmluZygpO1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtkZWZpbml0aW9uU3RyaW5nfScgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbiBvZiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlIGlzIG9jY2x1ZGVkLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25DYWxsQWhlYWQgPSBpc0RlZmluaXRpb25DYWxsQWhlYWQoZGVmaW5pdGlvbik7XG5cbiAgICAgICAgICBpZiAoZGVmaW5pdGlvbkNhbGxBaGVhZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlyc3QgcGFydCBvZiB0aGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyBsb29rLWFoZWFkLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25RdWFsaWZpZWQgPSBpc0RlZmluaXRpb25RdWFsaWZpZWQoZGVmaW5pdGlvbik7XG5cbiAgICAgICAgICBpZiAoZGVmaW5pdGlvblF1YWxpZmllZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlyc3QgcGFydCBvZiB0aGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyBxdWFsaWZpZWQuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGZpcnN0UGFydHNFcXVhbCA9IGFyZUZpcnN0UGFydHNFcXVhbChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMpO1xuXG4gICAgaWYgKCFmaXJzdFBhcnRzRXF1YWwpIHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpcnN0IHBhcnRzIG9mIHRoZSAnJHtsZWZ0UmVjdXJzaXZlUnVsZU5hbWV9JyBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9ucyBpbiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlIGFyZSBub3QgZXF1YWwuYCk7XG4gICAgfVxuXG4gICAgbGV0IHByZWNlZGVuY2UgPSBudWxsO1xuXG4gICAgbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zID0gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zLmZpbHRlcigobGVmdFJlY3Vyc2l2ZURlZmluaXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgICAgIHBhcnRzTGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuXG4gICAgICBpZiAocGFydHNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJlY2VkZW5jZSA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFByZWNlZGVuY2UoKTtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVPcGFjaXR5ID0gbGVmdFJlY3Vyc2l2ZVJ1bGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSksXG4gICAgICAgICAgbmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IGxlZnRSZWN1cnNpdmVSdWxlT3BhY2l0eTsgLy8vXG5cbiAgICBkZWZpbml0aW9ucyA9IGRlZmluaXRpb25zRnJvbUxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucyhsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMpO1xuXG4gICAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUnVsZSA9IG5ldyBJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKSxcbiAgICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTm9uUHJvZHVjaW5nID0gaXNSdWxlTm9uUHJvZHVjaW5nKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUsIHJ1bGVNYXApO1xuXG4gICAgaWYgKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOb25Qcm9kdWNpbmcpIHtcbiAgICAgIGNvbnN0IGVwc2lsb25EZWZpbml0aW9uID0gRXBzaWxvbkRlZmluaXRpb24uZnJvbVByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG5cbiAgICAgIGRlZmluaXRpb25zLnB1c2goZXBzaWxvbkRlZmluaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFyZUZpcnN0UGFydHNFcXVhbChkZWZpbml0aW9ucykge1xuICBjb25zdCBmaXJzdFBhcnRzID0gZGVmaW5pdGlvbnMubWFwKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgICAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpO1xuXG4gICAgICAgICAgcmV0dXJuIGZpcnN0UGFydDtcbiAgICAgICAgfSksXG4gICAgICAgIGZpcnN0UGFydHNFcXVhbCA9IGFyZVBhcnRzRXF1YWwoZmlyc3RQYXJ0cyk7XG5cbiAgcmV0dXJuIGZpcnN0UGFydHNFcXVhbDtcbn1cblxuZnVuY3Rpb24gZGVmaW5pdGlvbnNGcm9tTGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zKGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucykge1xuICBjb25zdCBkZWZpbml0aW9ucyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucy5tYXAoKGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKSA9PiB7IC8vL1xuICAgICAgICAgIGxldCBwYXJ0cyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFBhcnRzKCk7XG5cbiAgICAgICAgICBwYXJ0cyA9IFsgLy8vXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICAgIF1cblxuICAgICAgICAgIHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgICBjb25zdCBwcmVjZWRlbmNlID0gbGVmdFJlY3Vyc2l2ZURlZmluaXRpb24uZ2V0UHJlY2VkZW5jZSgpLFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSBEZWZpbml0aW9uLmZyb21QYXJ0c0FuZFByZWNlZGVuY2UocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBkZWZpbml0aW9ucztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgZnJvbSBcIi4vcnVsZS9yZXBlYXRlZC9pbmRpcmVjdGx5XCI7XG5cbmltcG9ydCB7IHJ1bGVOYW1lc0Zyb21DeWNsZSB9IGZyb20gXCIuL3V0aWxpdGllcy9jeWNsZVwiO1xuaW1wb3J0IHsgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgfSBmcm9tIFwiLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKSB7XG4gIGN5Y2xlcy5mb3JFYWNoKChjeWNsZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSk7XG5cbiAgICBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWVzLCAocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkgPT4ge1xuICAgICAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKTtcblxuICAgICAgbGV0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBydWxlTWFwW2luZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lXSB8fCBudWxsO1xuXG4gICAgICBpZiAoaW5kaXJlY3RseVJlcGVhdGVkUnVsZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlID0gcnVsZU1hcFtsZWZ0UmVjdXJzaXZlUnVsZU5hbWVdO1xuXG4gICAgICAgIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlLmZyb21SdWxlQW5kTGVmdFJlY3Vyc2l2ZVJ1bGUocnVsZSwgbGVmdFJlY3Vyc2l2ZVJ1bGUsIHJ1bGVNYXApO1xuXG4gICAgICAgIHJ1bGVNYXBbaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVdID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgcnVsZXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgRGlyZWN0ZWRHcmFwaCBmcm9tIFwiLi9kaXJlY3RlZEdyYXBoXCI7XG5pbXBvcnQgY3JlYXRlUmVkdWNlZFJ1bGVzIGZyb20gXCIuL2NyZWF0ZVJlZHVjZWRSdWxlc1wiO1xuaW1wb3J0IHJld3JpdGVMZWZ0UmVjdXJzaXZlUnVsZXMgZnJvbSBcIi4vcmV3cml0ZUxlZnRSZWN1cnNpdmVSdWxlc1wiO1xuaW1wb3J0IGNyZWF0ZURpcmVjdGx5UmVwZWF0ZWRSdWxlcyBmcm9tIFwiLi9jcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXNcIjtcbmltcG9ydCBjcmVhdGVJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlcyBmcm9tIFwiLi9jcmVhdGVJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlc1wiO1xuXG5pbXBvcnQgeyBlZGdlc0Zyb21TdGFydFJ1bGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvZGlyZWN0ZWRHcmFwaFwiO1xuaW1wb3J0IHsgTEVGVF9SRUNVUlNJVkVfTEFCRUwgfSBmcm9tIFwiLi9sYWJlbHNcIjtcbmltcG9ydCB7IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZSB9IGZyb20gXCIuL3V0aWxpdGllcy9sZWZ0UmVjdXJzaXZlXCI7XG5cbmNvbnN0IHsgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgcnVsZU1hcEZyb21SdWxlcywgc3RhcnRSdWxlRnJvbVJ1bGVzLCBydWxlc0Zyb21TdGFydFJ1bGVBbmRSdWxlTWFwIH0gPSBydWxlc1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZWxpbWluYXRlTGVmdFJlY3Vyc2lvbihydWxlcykge1xuICBjb25zdCBydWxlTWFwID0gcnVsZU1hcEZyb21SdWxlcyhydWxlcyksXG4gICAgICAgIHN0YXJ0UnVsZSA9IHN0YXJ0UnVsZUZyb21SdWxlcyhydWxlcyksXG4gICAgICAgIHJ1bGVOYW1lc01hcCA9IHJ1bGVOYW1lc01hcEZyb21Ob3RoaW5nKHJ1bGVNYXApLFxuICAgICAgICBjeWNsZXMgPSBjeWNsZXNGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcblxuICBjcmVhdGVSZWR1Y2VkUnVsZXMoY3ljbGVzLCBydWxlTWFwKTtcblxuICBjcmVhdGVJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlcyhjeWNsZXMsIHJ1bGVNYXApO1xuXG4gIGNyZWF0ZURpcmVjdGx5UmVwZWF0ZWRSdWxlcyhjeWNsZXMsIHJ1bGVNYXApO1xuXG4gIHJld3JpdGVMZWZ0UmVjdXJzaXZlUnVsZXMoY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuXG4gIHJ1bGVzID0gcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcChzdGFydFJ1bGUsIHJ1bGVNYXApOyAvLy9cblxuICByZXR1cm4gcnVsZXM7XG59XG5cbmZ1bmN0aW9uIGRpcmVjdGVkR3JhcGhGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHN0YXJ0UnVsZU5hbWUgPSBzdGFydFJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICBlZGdlcyA9IGVkZ2VzRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCksXG4gICAgICAgIHN0YXJ0VmVydGV4ID0gc3RhcnRSdWxlTmFtZSwgIC8vL1xuICAgICAgICBkaXJlY3RlZEdyYXBoID0gRGlyZWN0ZWRHcmFwaC5mcm9tRWRnZXNBbmRTdGFydFZlcnRleChlZGdlcywgc3RhcnRWZXJ0ZXgpO1xuXG4gIHJldHVybiBkaXJlY3RlZEdyYXBoO1xufVxuXG5mdW5jdGlvbiBydWxlTmFtZXNNYXBGcm9tTm90aGluZyhydWxlTWFwKSB7XG4gIGNvbnN0IHJ1bGVOYW1lc01hcCA9IHt9LFxuICAgICAgICBydWxlTmFtZXMgPSBPYmplY3Qua2V5cyhydWxlTWFwKTtcblxuICBydWxlTmFtZXMuZm9yRWFjaCgocnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZShydWxlLCBydWxlTWFwKSxcbiAgICAgICAgICBydWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzOyAvLy9cblxuICAgIHJ1bGVOYW1lc01hcFtydWxlTmFtZV0gPSBydWxlTmFtZXM7XG4gIH0pO1xuXG4gIHJldHVybiBydWxlTmFtZXNNYXA7XG59XG5cbmZ1bmN0aW9uIGlzQ3ljbGVMZWZ0UmVjdXJzaXZlKGN5Y2xlKSB7XG4gIGNvbnN0IGN5Y2xlTGVmdFJlY3Vyc2l2ZSA9IGN5Y2xlLmV2ZXJ5RWRnZSgoZWRnZSkgPT4ge1xuICAgIGNvbnN0IGxhYmVsID0gZWRnZS5nZXRMYWJlbCgpLFxuICAgICAgICAgIGxhYmVsTGVmdFJlY3Vyc2l2ZUxhYmVsID0gKGxhYmVsID09PSBMRUZUX1JFQ1VSU0lWRV9MQUJFTCksXG4gICAgICAgICAgZWRnZUxlZnRSZWN1cnNpdmUgPSBsYWJlbExlZnRSZWN1cnNpdmVMYWJlbDsgIC8vL1xuXG4gICAgaWYgKGVkZ2VMZWZ0UmVjdXJzaXZlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjeWNsZUxlZnRSZWN1cnNpdmU7XG59XG5cbmZ1bmN0aW9uIGN5Y2xlc0Zyb21TdGFydFJ1bGUoc3RhcnRSdWxlLCBydWxlTWFwLCBydWxlTmFtZXNNYXApIHtcbiAgY29uc3QgZGlyZWN0ZWRHcmFwaCA9IGRpcmVjdGVkR3JhcGhGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSxcbiAgICAgICAgY3ljbGVzID0gZGlyZWN0ZWRHcmFwaC5maW5kQ3ljbGVzKCk7XG5cbiAgZmlsdGVyKGN5Y2xlcywgKGN5Y2xlKSA9PiB7XG4gICAgY29uc3QgY3ljbGVMZWZ0UmVjdXJzaXZlID0gaXNDeWNsZUxlZnRSZWN1cnNpdmUoY3ljbGUpO1xuXG4gICAgaWYgKGN5Y2xlTGVmdFJlY3Vyc2l2ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY3ljbGVzO1xufVxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhhbXBsZUxleGVyIH0gZnJvbSBcIi4vZXhhbXBsZS9sZXhlci9leGFtcGxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4YW1wbGVQYXJzZXIgfSBmcm9tIFwiLi9leGFtcGxlL3BhcnNlci9leGFtcGxlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgZWxpbWluYXRlTGVmdFJlY3Vyc2lvbiB9IGZyb20gXCIuL2VsaW1pbmF0ZUxlZnRSZWN1cnNpb25cIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICBub2RlID0gbm9kZXMuc2hpZnQoKSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZXNRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwic3BlY2lhbFwiOiBcIl4oPzpcXFxcJFxcXFwkfFxcXFwkfFxcXFxcXFxcXFxcXCh8XFxcXFxcXFxcXFxcKXxcXFxcXFxcXFxcXFxbfFxcXFxcXFxcXFxcXF0pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl4oPzouKz8oPz1cXFxcJFxcXFwkfFxcXFwkfFxcXFxcXFxcXFxcXCh8XFxcXFxcXFxcXFxcKXxcXFxcXFxcXFxcXFxbfFxcXFxcXFxcXFxcXF0pfC4rKVwiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuXHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZVhMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47XHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKFRlWExleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoVGVYTGV4ZXIsIHJ1bGVzKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoVGVYTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgZW50cmllcyA9IFtcclxuICB7XHJcbiAgICBcInNwZWNpYWxcIjogXCJeKD86LHw6fFxcXFx7fFxcXFx9fFxcXFxbfFxcXFxdKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl4tP1sxLTldWzAtOV0qKFxcXFwuWzAtOV0rKT9cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJib29sZWFuXCI6IFwiXig/OnRydWV8ZmFsc2UpXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibnVsbFwiOiBcIl4oPzpudWxsKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc10rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb21tb25MZXhlcixcclxuICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxyXG4gICAgICAgICBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBKU09OTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuO1xyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhKU09OTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhKU09OTGV4ZXIsIHJ1bGVzKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoSlNPTkxleGVyLCBlbnRyaWVzKTsgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IExBVElOID0gXCJbXFxcXHB7U2NyaXB0PUxhdGlufV1cIixcclxuICAgICAgREVDSU1BTCA9IFwiWzAtOV1cIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJ0eXBlXCI6IFwiXig/Ok5vZGVzfE5vZGV8U3RyaW5nfE51bWJlcnxCb29sZWFuKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInF1ZXJ5XCI6IFwiXig/Om5vZGVRdWVyeXxub2Rlc1F1ZXJ5KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInByaW1hcnkta2V5d29yZFwiOiBcIl5yZXR1cm5cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzZWNvbmRhcnkta2V5d29yZFwiOiBcIl4oPzppZnxlbHNlfHJlZHVjZXxldmVyeXxzb21lfGFzKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bGxcIjogXCJebnVsbFwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImJvb2xlYW5cIjogXCJeKD86dHJ1ZXxmYWxzZSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJicmFja2V0XCI6IFwiXig/OlxcXFx7fFxcXFx9KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInNwZWNpYWxcIjogXCJeKD86IT18PT18IXw9fCx8O3xffCYmfFxcXFx8XFxcXHx8XFxcXCh8XFxcXCl8XFxcXFt8XFxcXF0pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBgXiR7TEFUSU59KyR7REVDSU1BTH0qYCxcclxuICB9LFxyXG4gIHtcclxuICAgIFwibnVtYmVyXCI6IGBeJHtERUNJTUFMfStgXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc10rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb21tb25MZXhlcixcclxuICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxyXG4gICAgICAgICBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sXHJcbiAgICAgICAgIEVuZE9mTGluZUNvbW1lbnROb25TaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcclxuXHJcbmltcG9ydCBlbnRyaWVzIGZyb20gXCIuL2VudHJpZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZUxleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IEVuZE9mTGluZUNvbW1lbnROb25TaWduaWZpY2FudFRva2VuO1xyXG5cclxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuOyAgLy8vXHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuO1xyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhGdXJ0bGVMZXhlcik7IH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKEZ1cnRsZUxleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEZ1cnRsZUxleGVyLCBlbnRyaWVzKTsgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IEdSRUVLID0gXCJbXFxcXHB7U2NyaXB0PUdyZWVrfV1cIixcclxuICAgICAgTEFUSU4gPSBcIltcXFxccHtTY3JpcHQ9TGF0aW59XVwiLFxyXG4gICAgICBERUNJTUFMID0gXCJbMC05XVwiLFxyXG4gICAgICBMQVRJTl9MT1dFUl9DQVNFID0gXCJbXFxcXHB7U2NyaXB0PUxhdGlufSYmXFxcXHB7TG93ZXJjYXNlfV1cIixcclxuICAgICAgTEFUSU5fVVBQRVJfQ0FTRSA9IFwiW1xcXFxwe1NjcmlwdD1MYXRpbn0mJlxcXFxwe1VwcGVyY2FzZX1dXCIsXHJcbiAgICAgIE1BVEhFTUFUSUNBTF9TQU5TX1NFUklGX0JPTEQgPSBcIltcXFxcdXsxRDVENH0tXFxcXHV7MUQ2MDd9XVwiLFxyXG4gICAgICBNQVRIRU1BVElDQUxfSVRBTElDX1VQUEVSX0NBU0UgPSBcIltcXFxcdXsxRDQzNH0tXFxcXHV7MUQ0NER9XVwiLFxyXG4gICAgICBNQVRIRU1BVElDQUxfU0NSSVBUX1VQUEVSX0NBU0UgPSBcIltcXFxcdXsxRDQ5Q31cXFxcdXsyMTJDfVxcXFx1ezFENDlFfVxcXFx1ezFENDlGfVxcXFx1ezIxMzB9XFxcXHV7MjEzMX1cXFxcdXsxRDRBMn1cXFxcdXsyMTBCfVxcXFx1ezIxMTB9XFxcXHV7MUQ0QTV9XFxcXHV7MUQ0QTZ9XFxcXHV7MjExMn1cXFxcdXsyMTMzfVxcXFx1ezFENEE5fS1cXFxcdXsxRDRBQ31cXFxcdXsyMTFCfVxcXFx1ezFENEFFfS1cXFxcdXsxRDRCNX1dXCIsXHJcbiAgICAgIE1BVEhFTUFUSUNBTF9GUkFLVFVSX1VQUEVSX0NBU0UgPSBcIltcXFxcdXsxRDUwNH1cXFxcdXsxRDUwNX1cXFxcdXsyMTJEfVxcXFx1ezFENTA3fS1cXFxcdXsxRDUwQX1cXFxcdXsyMTBDfVxcXFx1ezIxMTF9XFxcXHV7MUQ1MER9LVxcXFx1ezFENTE0fVxcXFx1ezIxMUN9XFxcXHV7MUQ1MTZ9LVxcXFx1ezFENTFDfVxcXFx1ezIxMjh9XVwiO1xyXG5cclxuY29uc3QgZW50cmllcyA9IFtcclxuICB7XHJcbiAgICBcInByaW1hcnkta2V5d29yZFwiOiBcIl4oPzpSdWxlfEF4aW9tfFRoZW9yZW18TGVtbWF8Q29uamVjdHVyZXxNZXRhTGVtbWF8TWV0YXRoZW9yZW18UHJlbWlzZXN8UHJlbWlzZXxDb25jbHVzaW9ufFByb29mfFRoZXJlZm9yZXxTdXBwb3NlfEhlbmNlfFRoZW58UHJvdmlzaW9uYWx8VHlwZXxUeXBlUHJlZml4fFByb3BlcnRpZXN8UHJvcGVydHl8VmFyaWFibGV8Q29uc3RydWN0b3J8Q29tYmluYXRvcnxNZXRhdmFyaWFibGV8R2l2ZW4pXFxcXGJcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzZWNvbmRhcnkta2V5d29yZFwiOiBcIl4oPzppc3xpbnxhbnxhfG9mfGJ5fGZyb218YmVjYXVzZXxmb3J8c2F0aXNmaWVzfHByb3Zpc2lvbmFsbHl8ZGVmaW5lZHx1bmRlZmluZWR8bWlzc2luZ3xwcmVzZW50KVxcXFxiXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibWV0YS10eXBlXCI6IFwiXig/OlN0YXRlbWVudHxSZWZlcmVuY2V8RnJhbWUpXFxcXGJcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IGBeKD86JHtMQVRJTl9VUFBFUl9DQVNFfSR7TEFUSU59KiR7REVDSU1BTH0qfCR7TEFUSU5fTE9XRVJfQ0FTRX0ke0xBVElOfSske0RFQ0lNQUx9KilgLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZGVudGlmaWVyXCI6IGBeKD86JHtMQVRJTl9MT1dFUl9DQVNFfSR7REVDSU1BTH0qfCR7R1JFRUt9K3wke01BVEhFTUFUSUNBTF9TQU5TX1NFUklGX0JPTER9K3wke01BVEhFTUFUSUNBTF9JVEFMSUNfVVBQRVJfQ0FTRX0rfCR7TUFUSEVNQVRJQ0FMX1NDUklQVF9VUFBFUl9DQVNFfSt8JHtNQVRIRU1BVElDQUxfRlJBS1RVUl9VUFBFUl9DQVNFfSspYFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJwcmltaXRpdmVcIjogXCJeKD86XFxcXHx8XFxcXC5cXFxcLlxcXFwufFxcXFwofFxcXFwpfFxcXFxbfFxcXFxdfFxcXFwrfC18LHw8fD4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwic3BlY2lhbFwiOiBcIl4oPzpAfDo6fDp8PSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNcXFxcKFxcXFwpXFxcXFtcXFxcXTosXStcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLFxyXG4gICAgICAgICBXaGl0ZXNwYWNlVG9rZW4sXHJcbiAgICAgICAgIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sXHJcbiAgICAgICAgIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcclxuICAgICAgICAgRW5kT2ZMaW5lQ29tbWVudFNpZ25pZmljYW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9taW5hbExleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuO1xyXG5cclxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuOyAgLy8vXHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuO1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJhbHBoYS1udW1lcmljXCI6IFwiXlthLXpBLVowLTldK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInB1bmN0dWF0aW9uXCI6IFwiXltALFxcXFwuXFxcIidgXStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcclxuXHJcbmltcG9ydCBlbnRyaWVzIGZyb20gXCIuL2VudHJpZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYWluVGV4dExleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbjsgIC8vLlxyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhQbGFpblRleHRMZXhlcik7IH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKFBsYWluVGV4dExleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKFBsYWluVGV4dExleGVyLCBlbnRyaWVzKTsgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OlxcXFx8fFxcXFwofFxcXFwpfFxcXFw/fFxcXFwqfFxcXFwrfDo6PXw7fDxOT19XSElURVNQQUNFPnw8RU5EX09GX0xJTkU+KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl4oPzowfFsxLTldWzAtOV0qKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJeW1xcXFx3fl0rXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidHlwZVwiOiBcIl5cXFxcW1teXFxcXF1dK1xcXFxdXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXStcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXJCTkZuTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcblxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuOyAvLy9cblxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xuXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKEN1c3RvbUdyYW1tYXJCTkZuTGV4ZXIpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKEN1c3RvbUdyYW1tYXJCTkZuTGV4ZXIsIHJ1bGVzKTsgfVxuXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhDdXN0b21HcmFtbWFyQk5GbkxleGVyLCBlbnRyaWVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgZW50cmllcyA9IFtcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc10rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBlbnRyaWVzIGZyb20gXCIuL2VudHJpZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xuXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW47XG5cbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcblxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlcik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciwgcnVsZXMpOyB9XG5cbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIsIGVudHJpZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGRvY3VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAgKCBkZWxpbWl0ZWRUZVggfCBwbGFpbk1hcmt1cCApKyA7XG4gICAgXG4gICAgXG4gICAgXG4gICAgZGVsaW1pdGVkVGVYICAgICAgICAgICAgICAgICAgICA6Oj0gICBkb2xsYXJEZWxpbWl0ZXIgaW5saW5lVGVYIGRvbGxhckRlbGltaXRlciBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGRvdWJsZURvbGxhckRlbGltaXRlciBkaXNwbGF5VGVYIGRvdWJsZURvbGxhckRlbGltaXRlciBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIG9wZW5pbmdCcmFja2V0RGVsaW1pdGVyIGlubGluZVRlWCBjbG9zaW5nQnJhY2tldERlbGltaXRlciBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIG9wZW5pbmdTcXVhcmVCcmFja2V0RGVsaW1pdGVyIGRpc3BsYXlUZVggY2xvc2luZ1NxdWFyZUJyYWNrZXREZWxpbWl0ZXIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgXG5cbiAgICBcbiAgICBpbmxpbmVUZVggICAgICAgICAgICAgICAgICAgICAgIDo6PSAgIFt1bmFzc2lnbmVkXSogO1xuXG4gICAgZGlzcGxheVRlWCAgICAgICAgICAgICAgICAgICAgICA6Oj0gICBbdW5hc3NpZ25lZF0qIDtcblxuXG5cbiAgICBkb2xsYXJEZWxpbWl0ZXIgICAgICAgICAgICAgICAgIDo6PSAgIFwiJFwiIDtcbiBcbiAgICBkb3VibGVEb2xsYXJEZWxpbWl0ZXIgICAgICAgICAgIDo6PSAgIFwiJCRcIiA7XG4gICAgXG5cbiAgICBcbiAgICBvcGVuaW5nQnJhY2tldERlbGltaXRlciAgICAgICAgIDo6PSAgIFwiXFxcXChcIiA7XG5cbiAgICBjbG9zaW5nQnJhY2tldERlbGltaXRlciAgICAgICAgIDo6PSAgIFwiXFxcXClcIiA7XG5cbiAgICBvcGVuaW5nU3F1YXJlQnJhY2tldERlbGltaXRlciAgIDo6PSAgIFwiXFxcXFtcIiA7XG4gICAgXG4gICAgY2xvc2luZ1NxdWFyZUJyYWNrZXREZWxpbWl0ZXIgICA6Oj0gICBcIlxcXFxdXCIgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIHBsYWluTWFya3VwICAgICAgICAgICAgICAgICAgICAgOjo9ICAgLiA7XG5cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZVhQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhUZVhQYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihUZVhQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKFRlWFBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGRvY3VtZW50ICAgICA6Oj0gIGpzb24gZXJyb3IqIFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIGVycm9yKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgIDtcbiAgXG4gIFxuICBcbiAgICBqc29uICAgICAgICAgOjo9ICBhcnJheSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBvYmplY3QgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgW3N0cmluZy1saXRlcmFsXSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBbYm9vbGVhbl0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgW251bWJlcl0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgW251bGxdIFxuICAgIFxuICAgICAgICAgICAgICAgICAgIDtcbiAgXG4gIFxuICBcbiAgICBhcnJheS4uICAgICAgOjo9ICBcIltcIiAoIGVsZW1lbnQgKCBcIixcIiBlbGVtZW50ICkqICk/IG5vbnNlbnNlPyBcIl1cIiA7XG4gIFxuICBcbiAgICAgXG4gICAgb2JqZWN0Li4gICAgIDo6PSAgXCJ7XCIgKCBwcm9wZXJ0eSAoIFwiLFwiIHByb3BlcnR5ICkqICk/IG5vbnNlbnNlPyBcIn1cIiA7XG4gIFxuICBcbiAgICBcbiAgICBwcm9wZXJ0eSAgICAgOjo9ICBbc3RyaW5nLWxpdGVyYWxdIFwiOlwiIGpzb24gO1xuICBcbiAgICBcblxuICAgIGVsZW1lbnQgICAgICA6Oj0gIGpzb24gO1xuICBcbiAgICBcblxuICAgIG5vbnNlbnNlLiAgICA6Oj0gICggXCI6XCIgfCBcIixcIiB8IFtzdHJpbmctbGl0ZXJhbF0gfCBbbnVtYmVyXSB8IFtib29sZWFuXSB8IFtudWxsXSB8IFt1bmFzc2lnbmVkXSApKyA7XG4gICAgXG5cblxuICAgIGVycm9yLiAgICAgICA6Oj0gIC4gO1xuICAgIFxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBKU09OUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoSlNPTlBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKEpTT05QYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKEpTT05QYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICAgICAgICAgICA6Oj0gICggcHJvY2VkdXJlRGVjbGFyYXRpb24gfCBlcnJvciApKyA7XG4gICAgXG4gICAgXG4gICAgXG4gICAgcHJvY2VkdXJlRGVjbGFyYXRpb24gICAgOjo9ICBbdHlwZV0gbGFiZWw8Tk9fV0hJVEVTUEFDRT5cIihcIiBwYXJhbWV0ZXJzPyBcIilcIiByZXR1cm5CbG9jayA7XG4gICAgXG4gICAgYW5vbnltb3VzUHJvY2VkdXJlICAgICAgOjo9ICBbdHlwZV0gXCIoXCIgcGFyYW1ldGVycz8gXCIpXCIgcmV0dXJuQmxvY2sgO1xuICAgIFxuICAgIHJldHVyblN0YXRlbWVudCAgICAgICAgIDo6PSAgXCJyZXR1cm5cIiB0ZXJtIFwiO1wiIDsgXG4gICAgXG4gICAgXG4gICAgXG4gICAgc3RlcCAgICAgICAgICAgICAgICAgICAgOjo9ICBhcnJheUFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb2JqZWN0QXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB2YXJpYWJsZUFzc2lnbm1lbnRzXG4gICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyAgXG4gICAgICBcbiAgICAgIFxuICAgIFxuICAgIGFycmF5QXNzaWdubWVudCAgICAgICAgIDo6PSAgXCJbXCIgcGFyYW1ldGVycyBcIl1cIiBcIj1cIiB2YXJpYWJsZSBcIjtcIiA7XG4gICAgXG4gICAgb2JqZWN0QXNzaWdubWVudCAgICAgICAgOjo9ICBcIntcIiBuYW1lZFBhcmFtZXRlcnMgXCJ9XCIgXCI9XCIgdmFyaWFibGUgXCI7XCIgO1xuICAgIFxuICAgIHZhcmlhYmxlQXNzaWdubWVudHMgICAgIDo6PSAgW3R5cGVdIHZhcmlhYmxlQXNzaWdubWVudCAoIFwiLFwiIHZhcmlhYmxlQXNzaWdubWVudCApKiBcIjtcIiA7XG4gICAgXG4gICAgdmFyaWFibGVBc3NpZ25tZW50ICAgICAgOjo9ICB2YXJpYWJsZSBcIj1cIiBleHByZXNzaW9uIDtcbiAgICBcblxuXG4gICAgbmFtZWRQYXJhbWV0ZXJzICAgICAgICAgOjo9ICBuYW1lZFBhcmFtZXRlciAoIFwiLFwiIG5hbWVkUGFyYW1ldGVyICkqIDtcbiAgICBcbiAgICBwYXJhbWV0ZXJzICAgICAgICAgICAgICA6Oj0gIHBhcmFtZXRlciAoIFwiLFwiIHBhcmFtZXRlciApKiA7XG4gICAgXG4gICAgdGVybXMgICAgICAgICAgICAgICAgICAgOjo9ICB0ZXJtICggXCIsXCIgdGVybSApKiA7XG4gICAgXG5cblxuICAgIG5hbWVkUGFyYW1ldGVyICAgICAgICAgIDo6PSAgW3R5cGVdIFtuYW1lXSAoIFwiYXNcIiBbbmFtZV0gKT8gOyAgIFxuICAgIFxuICAgIHBhcmFtZXRlciAgICAgICAgICAgICAgIDo6PSAgW3R5cGVdIFtuYW1lXVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgXCJfXCIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIFxuICAgIHByb2NlZHVyZUNhbGwgICAgICAgICAgIDo6PSAgcmVmZXJlbmNlPE5PX1dISVRFU1BBQ0U+XCIoXCIgdGVybXM/IFwiKVwiIDtcbiAgICBcbiAgICByZXR1cm5CbG9jay4uICAgICAgICAgICA6Oj0gIFwie1wiICggc3RlcCB8IG5vbnNlbnNlICkqIHJldHVyblN0YXRlbWVudCBcIn1cIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgbm9kZXNRdWVyeSAgICAgICAgICAgICAgOjo9ICBcIm5vZGVzUXVlcnlcIjxOT19XSElURVNQQUNFPlwiKFwiIHZhcmlhYmxlIFwiLFwiIFtzdHJpbmctbGl0ZXJhbF0gXCIpXCIgO1xuICAgIFxuICAgIG5vZGVRdWVyeSAgICAgICAgICAgICAgIDo6PSAgXCJub2RlUXVlcnlcIjxOT19XSElURVNQQUNFPlwiKFwiIHZhcmlhYmxlIFwiLFwiIFtzdHJpbmctbGl0ZXJhbF0gXCIpXCIgO1xuICAgIFxuICAgIHRlcm5hcnkgICAgICAgICAgICAgICAgIDo6PSAgXCJpZlwiIFwiKFwiIHRlcm0gXCIpXCIgZXhwcmVzc2lvbiBcImVsc2VcIiBleHByZXNzaW9uIDtcbiAgICBcbiAgICByZWR1Y2UgICAgICAgICAgICAgICAgICA6Oj0gIFwicmVkdWNlXCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBhbm9ueW1vdXNQcm9jZWR1cmUgXCIsXCIgZXhwcmVzc2lvbiBcIilcIiA7XG4gICAgXG4gICAgZXZlcnkgICAgICAgICAgICAgICAgICAgOjo9ICBcImV2ZXJ5XCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBhbm9ueW1vdXNQcm9jZWR1cmUgXCIpXCIgO1xuICAgIFxuICAgIHNvbWUgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJzb21lXCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBhbm9ueW1vdXNQcm9jZWR1cmUgXCIpXCIgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIGNvbXBhcmlzb25UZXJtICAgICAgICAgIDo6PSAgdGVybSAoIFwiPT1cIiB8IFwiIT1cIiApIHRlcm0gOyBcbiAgICBcbiAgICBicmFja2V0ZWRUZXJtICAgICAgICAgICA6Oj0gIFwiKFwiIHRlcm0gXCIpXCIgOyBcbiAgICBcbiAgICBuZWdhdGVkVGVybSAgICAgICAgICAgICA6Oj0gIFwiIVwiPE5PX1dISVRFU1BBQ0U+dGVybSA7IFxuICAgIFxuICAgIGxvZ2ljYWxUZXJtICAgICAgICAgICAgIDo6PSAgdGVybSAoIFwifHxcIiB8IFwiJiZcIiApIHRlcm0gOyBcblxuXG4gICAgXG4gICAgZXhwcmVzc2lvbiAgICAgICAgICAgICAgOjo9ICBwcm9jZWR1cmVDYWxsXG4gICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmV0dXJuQmxvY2tcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vZGVzUXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbm9kZVF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHRlcm5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmVkdWNlXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBldmVyeVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgc29tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHRlcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIHRlcm0gICAgICAgICAgICAgICAgICAgIDo6PSAgY29tcGFyaXNvblRlcm0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBicmFja2V0ZWRUZXJtIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbG9naWNhbFRlcm0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBuZWdhdGVkVGVybSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHByaW1pdGl2ZSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHZhcmlhYmxlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIFxuICAgIHByaW1pdGl2ZSAgICAgICAgICAgICAgIDo6PSAgW3N0cmluZy1saXRlcmFsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbYm9vbGVhbl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW251bWJlcl0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtudWxsXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5cbiAgICByZWZlcmVuY2UuICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSA7XG4gICAgXG4gICAgdmFyaWFibGUgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuICAgIFxuICAgIGxhYmVsLiAgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICBub25zZW5zZS4gICAgICAgICAgICAgICA6Oj0gIFtzZWNvbmRhcnkta2V5d29yZF0gfCBbdHlwZV0gfCBbbnVsbF0gfCBbYm9vbGVhbl0gfCBbc3RyaW5nLWxpdGVyYWxdIHwgW3F1ZXJ5XSB8IFtzcGVjaWFsXSB8IFtuYW1lXSB8IFtudW1iZXJdIHwgW3VuYXNzaWduZWRdIDtcblxuXG4gICAgXG4gICAgZXJyb3IuICAgICAgICAgICAgICAgICAgOjo9ICAuIDtcbiAgICBcbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVydGxlUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoRnVydGxlUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoRnVydGxlUGFyc2VyLCBibmYpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21SdWxlcyhGdXJ0bGVQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgZG9jdW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCB2YXJpYWJsZURlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb21iaW5hdG9yRGVjbGFyYXRpb24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNvbnN0cnVjdG9yRGVjbGFyYXRpb24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0eXBlUHJlZml4RGVjbGFyYXRpb24gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc2ltcGxlVHlwZURlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb21wbGV4VHlwZURlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHJ1bGUgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYXhpb20gXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGVtbWEgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdGhlb3JlbSBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb25qZWN0dXJlIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG1ldGFMZW1tYSBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtZXRhdGhlb3JlbSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgc2VjdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB2ZXJ0aWNhbFNwYWNlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVycm9yICkrIDtcblxuXG5cbnNlY3Rpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiR2l2ZW5cIiA8RU5EX09GX0xJTkU+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5cG90aGVzaXMrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBheGlvbSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBsZW1tYSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0aGVvcmVtIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNvbmplY3R1cmUgKSA7IFxuXG5cblxudmVydGljYWxTcGFjZSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgPEVORF9PRl9MSU5FPisgO1xuXG5cblxuZXJyb3IuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgLiA7XG5cblxuXG52YXJpYWJsZURlY2xhcmF0aW9uICAgICAgICAgICAgICAgICAgOjo9ICBcIlZhcmlhYmxlXCIgdmFyaWFibGUgKCBcIjpcIiB0eXBlIFwicHJvdmlzaW9uYWxseVwiPyApPyA8RU5EX09GX0xJTkU+IDtcbiBcbmNvbWJpbmF0b3JEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICA6Oj0gIFwiQ29tYmluYXRvclwiIGNvbWJpbmF0b3IuLi4gPEVORF9PRl9MSU5FPiA7XG4gXG5jb25zdHJ1Y3RvckRlY2xhcmF0aW9uICAgICAgICAgICAgICAgOjo9ICBcIkNvbnN0cnVjdG9yXCIgY29uc3RydWN0b3IuLi4gKCBcIjpcIiB0eXBlIFwicHJvdmlzaW9uYWxseVwiPyApPyA8RU5EX09GX0xJTkU+IDtcbiBcbm1ldGF2YXJpYWJsZURlY2xhcmF0aW9uICAgICAgICAgICAgICA6Oj0gIFwiTWV0YXZhcmlhYmxlXCIgbWV0YXZhcmlhYmxlLi4uIFwiOlwiIG1ldGFUeXBlIDxFTkRfT0ZfTElORT4gO1xuIFxudHlwZVByZWZpeERlY2xhcmF0aW9uICAgICAgICAgICAgICAgIDo6PSAgXCJUeXBlUHJlZml4XCIgdHlwZVByZWZpeCA8RU5EX09GX0xJTkU+IDtcblxuc2ltcGxlVHlwZURlY2xhcmF0aW9uICAgICAgICAgICAgICAgIDo6PSAgXCJQcm92aXNpb25hbFwiPyBcIlR5cGVcIiB0eXBlICggXCI6XCIgdHlwZXMgKT8gPEVORF9PRl9MSU5FPiA7XG4gXG5jb21wbGV4VHlwZURlY2xhcmF0aW9uICAgICAgICAgICAgICAgOjo9ICBcIlByb3Zpc2lvbmFsXCI/IFwiVHlwZVwiIDxFTkRfT0ZfTElORT4gXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCBcIjpcIiB0eXBlcyApPyA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFwiUHJvcGVydGllc1wiIDxFTkRfT0ZfTElORT4gcHJvcGVydHlEZWNsYXJhdGlvbiBwcm9wZXJ0eURlY2xhcmF0aW9uKyApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcIlByb3BlcnR5XCIgPEVORF9PRl9MSU5FPiBwcm9wZXJ0eURlY2xhcmF0aW9uICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gIFxuXG4gIFxucnVsZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgcnVsZUhlYWRlciBydWxlQm9keSA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxubWV0YUxlbW1hICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YUxlbW1hSGVhZGVyIG1ldGFMZW1tYUJvZHkgO1xuXG5tZXRhdGhlb3JlbSAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBtZXRhdGhlb3JlbUhlYWRlciBtZXRhdGhlb3JlbUJvZHkgO1xuXG5heGlvbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBheGlvbUhlYWRlciBheGlvbUJvZHkgO1xuXG5sZW1tYSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBsZW1tYUhlYWRlciBsZW1tYUJvZHkgO1xuXG50aGVvcmVtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICB0aGVvcmVtSGVhZGVyIHRoZW9yZW1Cb2R5IDtcblxuY29uamVjdHVyZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgY29uamVjdHVyZUhlYWRlciBjb25qZWN0dXJlQm9keSA7XG5cblxuXG5ydWxlSGVhZGVyICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiUnVsZVwiIHBhcmVudGhlc2lzZWRMYWJlbHMuLi4gPEVORF9PRl9MSU5FPiA7IFxuXG5tZXRhTGVtbWFIZWFkZXIgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiTWV0YUxlbW1hXCIgcGFyZW50aGVzaXNlZExhYmVsLi4uIDxFTkRfT0ZfTElORT4gfCBcIk1ldGFMZW1tYVwiIDxFTkRfT0ZfTElORT4gO1xuXG5tZXRhdGhlb3JlbUhlYWRlciAgICAgICAgICAgICAgICAgICA6Oj0gIFwiTWV0YXRoZW9yZW1cIiBwYXJlbnRoZXNpc2VkTGFiZWwuLi4gPEVORF9PRl9MSU5FPiA7IFxuXG5heGlvbUhlYWRlciAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiQXhpb21cIiBzaWduYXR1cmU/IHBhcmVudGhlc2lzZWRMYWJlbHMuLi4gPEVORF9PRl9MSU5FPiA7IFxuXG5sZW1tYUhlYWRlciAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiTGVtbWFcIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gfCBcIkxlbW1hXCIgPEVORF9PRl9MSU5FPiA7IFxuXG50aGVvcmVtSGVhZGVyICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiVGhlb3JlbVwiIHBhcmVudGhlc2lzZWRMYWJlbHMuLi4gPEVORF9PRl9MSU5FPiA7IFxuXG5jb25qZWN0dXJlSGVhZGVyICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiQ29uamVjdHVyZVwiIHBhcmVudGhlc2lzZWRMYWJlbHMuLi4gPEVORF9PRl9MSU5FPiA7XG5cblxuXG5ydWxlQm9keSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCJQcmVtaXNlc1wiIDxFTkRfT0ZfTElORT4gcHJlbWlzZSBwcmVtaXNlKyApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcIlByZW1pc2VcIiA8RU5EX09GX0xJTkU+IHByZW1pc2UgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb25jbHVzaW9uXCIgPEVORF9PRl9MSU5FPiBjb25jbHVzaW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2Y/IDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5tZXRhTGVtbWFCb2R5ICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2YgO1xuXG5tZXRhdGhlb3JlbUJvZHkgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZiA7XG5cbmF4aW9tQm9keSAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTdXBwb3NlXCIgPEVORF9PRl9MSU5FPiBzdXBwb3NpdGlvbitcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGVuXCIgPEVORF9PRl9MSU5FPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1Y3Rpb24gO1xuXG5sZW1tYUJvZHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGVuXCIgPEVORF9PRl9MSU5FPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mIDtcblxudGhlb3JlbUJvZHkgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uK1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2YgO1xuXG5jb25qZWN0dXJlQm9keSAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGVuXCIgPEVORF9PRl9MSU5FPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZj8gO1xuXG5cblxucHJvb2YgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJQcm9vZlwiIDxFTkRfT0ZfTElORT4gZGVyaXZhdGlvbiA7XG5cbnN1YnByb29mICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rIHN1YkRlcml2YXRpb24gO1xuXG5kZXJpdmF0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggc3RlcCB8IHN1YnByb29mICkrIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZWZvcmVcIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwIDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbnN1YkRlcml2YXRpb24gICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIChcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkhlbmNlXCIgPEVORF9PRl9MSU5FPlxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHN0ZXAgfCBzdWJwcm9vZiApKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwIDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cblxuXG5wcm9wZXJ0eURlY2xhcmF0aW9uLiAgICAgICAgICAgICAgICAgOjo9ICBwcm9wZXJ0eSAoIFwiOlwiIHR5cGUgKT8gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cblxuY29tYmluYXRvciAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgc3RhdGVtZW50IDtcblxuY29uc3RydWN0b3IgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSA7IFxuXG4gXG5cbnByZW1pc2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHByb2NlZHVyZUNhbGwgPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHN0YXRlbWVudC4uLiA8RU5EX09GX0xJTkU+ICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbm9uc2Vuc2UuLi4gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbnN1cHBvc2l0aW9uLiAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHByb2NlZHVyZUNhbGwgPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHN0YXRlbWVudC4uLiA8RU5EX09GX0xJTkU+ICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbm9uc2Vuc2UuLi4gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbmNvbmNsdXNpb24uICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHN0YXRlbWVudC4uLiA8RU5EX09GX0xJTkU+ICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbm9uc2Vuc2UuLi4gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbmRlZHVjdGlvbi4gICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHN0YXRlbWVudC4uLiA8RU5EX09GX0xJTkU+ICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbm9uc2Vuc2UuLi4gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbmh5cG90aGVzaXMuICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHN0YXRlbWVudC4uLiA8RU5EX09GX0xJTkU+ICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbm9uc2Vuc2UuLi4gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuXG5zdGVwLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gcXVhbGlmaWNhdGlvbj8gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIHF1YWxpZmljYXRpb24/IDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cblxucXVhbGlmaWNhdGlvbiAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJiZWNhdXNlXCIgc2F0aXNmaWVzQXNzZXJ0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICggXCJieVwiIHwgXCJmcm9tXCIgKSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBcblxuXG5cbnBhcmVudGhlc2lzZWRMYWJlbHMgICAgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIGxhYmVscyBcIilcIiA7IFxuXG5wYXJlbnRoZXNpc2VkTGFiZWwgICAgICAgICAgICAgICAgICAgOjo9ICBcIihcIiBsYWJlbCBcIilcIiA7IFxuXG5cblxucHJvY2VkdXJlQ2FsbCAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJAXCI8Tk9fV0hJVEVTUEFDRT5wcm9jZWR1cmVSZWZlcmVuY2U8Tk9fV0hJVEVTUEFDRT5cIihcIiBwYXJhbWV0ZXIgKCBcIixcIiBwYXJhbWV0ZXIgKSogXCIpXCIgO1xuXG5cblxuc2lnbmF0dXJlICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgdGVybSAoIFwiLFwiIHRlcm0gKSogXCJdXCIgO1xuXG5cblxuYXJndW1lbnRzICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgYXJndW1lbnQgKCBcIixcIiBhcmd1bWVudCApKiA7XG5cbmxhYmVscyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGxhYmVsICggXCIsXCIgbGFiZWwgKSogO1xuXG50eXBlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICB0eXBlICggXCIsXCIgdHlwZSApKiA7XG5cblxuXG5hcmd1bWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICB0ZXJtICggKSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdHlwZSAoIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5tZXRhQXJndW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQgKCApIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBtZXRhVHlwZSAoICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuZnJhbWVBcmd1bWVudCAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgZnJhbWUgKCApIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBtZXRhVHlwZSAoICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5wcm9jZWR1cmVSZWZlcmVuY2UuICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG5yZWZlcmVuY2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBtZXRhdmFyaWFibGUgO1xuXG5sYWJlbC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBtZXRhdmFyaWFibGUgO1xuXG5cblxuZXF1aXZhbGVuY2VzICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgZXF1aXZhbGVuY2UgKCBcIixcIiBlcXVpdmFsZW5jZSApKiA7XG5cbmVxdWl2YWxlbmNlICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiIHRlcm0gKCBcIixcIiB0ZXJtICkrIFwiXVwiIDtcblxuXG5cbm1ldGF2YXJpYWJsZS4gICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSAoIDxOT19XSElURVNQQUNFPlwiKFwiICggdGVybSB8IHR5cGUgfCBzdHVmZiApIFwiKVwiICk/IDtcblxucGFyYW1ldGVyLiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIHwgW2lkZW50aWZpZXJdIDtcblxudmFyaWFibGUuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW2lkZW50aWZpZXJdIDtcblxubWV0YVR5cGUuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW21ldGEtdHlwZV0gO1xuXG5wcm9wZXJ0eS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0rIDtcblxudHlwZVByZWZpeC4gICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW3R5cGVdIDtcblxudHlwZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW3R5cGVdICggPE5PX1dISVRFU1BBQ0U+W3R5cGVdICk/IFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBcIjxcIjxOT19XSElURVNQQUNFPlwiPlwiXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5cbnN0dWZmLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gICggW3N0cmluZy1saXRlcmFsXSB8IFtzeW1ib2xdIHwgW3R5cGVdIHwgW25hbWVdIHwgW2lkZW50aWZpZXJdIHwgW3ByaW1pdGl2ZV0gfCBbdW5hc3NpZ25lZF0gKSsgO1xuXG5ub25zZW5zZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoIFtzZWNvbmRhcnkta2V5d29yZF0gfCBbbWV0YS10eXBlXSB8IFtzcGVjaWFsXSB8IFtzeW1ib2xdIHwgW3R5cGVdIHwgW25hbWVdIHwgW2lkZW50aWZpZXJdIHwgW3ByaW1pdGl2ZV0gfCBbdW5hc3NpZ25lZF0gKSsgO2A7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9taW5hbFBhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGRvY3VtZW50ICAgICAgIDo6PSAgKCBibG9jayB8IHZlcnRpY2FsU3BhY2UgKSsgO1xuXG4gICAgYmxvY2sgICAgICAgICAgOjo9ICBlbmRlZExpbmUqIGxhc3RMaW5lIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIHwgIGVuZGVkTGluZStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICBsYXN0TGluZSAgICAgICA6Oj0gICggW2FscGhhLW51bWVyaWNdIHwgW3B1bmN0dWF0aW9uXSB8IFt1bmFzc2lnbmVkXSApKyA7XG5cbiAgICBlbmRlZExpbmUgICAgICA6Oj0gICggW2FscGhhLW51bWVyaWNdIHwgW3B1bmN0dWF0aW9uXSB8IFt1bmFzc2lnbmVkXSApKyA8RU5EX09GX0xJTkU+IDtcblxuICAgIHZlcnRpY2FsU3BhY2UgIDo6PSAgPEVORF9PRl9MSU5FPisgO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYWluVGV4dFBhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKFBsYWluVGV4dFBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKFBsYWluVGV4dFBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoUGxhaW5UZXh0UGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYFxuXG4gICAgICBkb2N1bWVudCAgICAgICAgICAgICAgICAgOjo9ICAoIHJ1bGUgfCBlcnJvciApKyA7XG5cbiAgICAgIHJ1bGUgICAgICAgICAgICAgICAgICAgICA6Oj0gIG5hbWUgXCI6Oj1cIiBkZWZpbml0aW9ucyBcIjtcIiA7XG5cbiAgICAgIG5hbWUgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSA7XG5cbiAgICAgIGRlZmluaXRpb25zICAgICAgICAgICAgICA6Oj0gIGRlZmluaXRpb24gKCBcInxcIiBkZWZpbml0aW9uICkqIDtcblxuICAgICAgZGVmaW5pdGlvbiAgICAgICAgICAgICAgIDo6PSAgcGFydCsgcHJlY2VkZW5jZT8gO1xuIFxuICAgICAgcGFydCAgICAgICAgICAgICAgICAgICAgIDo6PSAgbm9uVGVybWluYWxQYXJ0IHF1YW50aWZpZXIqXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgIG5vblRlcm1pbmFsUGFydCAgICAgICAgICA6Oj0gIGNob2ljZU9mUGFydHNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgc2VxdWVuY2VPZlBhcnRzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJ1bGVOYW1lIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgIHRlcm1pbmFsUGFydCAgICAgICAgICAgICA6Oj0gIHNpZ25pZmljYW50VG9rZW5UeXBlXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgc3RyaW5nTGl0ZXJhbFxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIGVuZE9mTGluZVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vV2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgIHNlcXVlbmNlT2ZQYXJ0cyAgICAgICAgICA6Oj0gIFwiKFwiIHBhcnQgcGFydCsgXCIpXCIgO1xuXG4gICAgICBjaG9pY2VPZlBhcnRzICAgICAgICAgICAgOjo9ICBcIihcIiBwYXJ0Q2hvaWNlICggXCJ8XCIgcGFydENob2ljZSApKyBcIilcIiA7XG5cbiAgICAgIHBhcnRDaG9pY2UgICAgICAgICAgICAgICA6Oj0gIHBhcnQgcHJlY2VkZW5jZT8gO1xuXG4gICAgICBydWxlTmFtZSAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBzaWduaWZpY2FudFRva2VuVHlwZSAgICAgOjo9ICBbdHlwZV0gO1xuXG4gICAgICBzdHJpbmdMaXRlcmFsICAgICAgICAgICAgOjo9ICBbc3RyaW5nLWxpdGVyYWxdIDtcblxuICAgICAgcHJlY2VkZW5jZSAgICAgICAgICAgICAgIDo6PSAgXCIoXCIgW251bWJlcl0/IFwiKVwiIDtcbiAgICAgIFxuICAgICAgZW5kT2ZMaW5lICAgICAgICAgICAgICAgIDo6PSAgXCI8RU5EX09GX0xJTkU+XCIgO1xuICAgICAgXG4gICAgICBub1doaXRlc3BhY2UgICAgICAgICAgICAgOjo9ICBcIjxOT19XSElURVNQQUNFPlwiIDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgcXVhbnRpZmllciAgICAgICAgICAgICAgIDo6PSAgb3B0aW9uYWxRdWFudGlmaWVyXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvbmVPck1vcmVRdWFudGlmaWVyXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgemVyb09yTW9yZVF1YW50aWZpZXJcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgIG9wdGlvbmFsUXVhbnRpZmllciAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiP1wiIDtcblxuICAgICAgb25lT3JNb3JlUXVhbnRpZmllciAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIrXCIgO1xuXG4gICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllciAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIipcIiA7XG5cbiAgICAgIGVycm9yLiAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhDdXN0b21HcmFtbWFyQk5GUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoQ3VzdG9tR3JhbW1hckJORlBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoQ3VzdG9tR3JhbW1hckJORlBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGRvY3VtZW50ICAgICAgIDo6PSAgKCBleHByZXNzaW9uIHwgdmVydGljYWxTcGFjZSB8IGVycm9yICkrIDtcblxuICAgIGV4cHJlc3Npb24gICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+W3VuYXNzaWduZWRdPE5PX1dISVRFU1BBQ0U+PEVORF9PRl9MSU5FPiA7XG5cbiAgICB2ZXJ0aWNhbFNwYWNlICA6Oj0gIDxFTkRfT0ZfTElORT4rIDtcbiAgIFxuICAgIGVycm9yLiAgICAgICAgIDo6PSAgLiA7XG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyLCBibmYpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21SdWxlcyhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGVYTGV4ZXIgfSBmcm9tIFwiLi90ZVgvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSlNPTkxleGVyIH0gZnJvbSBcIi4vanNvbi9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGdXJ0bGVMZXhlciB9IGZyb20gXCIuL2Z1cnRsZS9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb21pbmFsTGV4ZXIgfSBmcm9tIFwiLi9ub21pbmFsL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYWluVGV4dExleGVyIH0gZnJvbSBcIi4vcGxhaW5UZXh0L2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1c3RvbUdyYW1tYXJCTkZMZXhlciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXJCTkYvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5L2xleGVyXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGVYUGFyc2VyIH0gZnJvbSBcIi4vdGVYL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBKU09OUGFyc2VyIH0gZnJvbSBcIi4vanNvbi9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlUGFyc2VyIH0gZnJvbSBcIi4vZnVydGxlL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb21pbmFsUGFyc2VyIH0gZnJvbSBcIi4vbm9taW5hbC9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGxhaW5UZXh0UGFyc2VyIH0gZnJvbSBcIi4vcGxhaW5UZXh0L3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDdXN0b21HcmFtbWFyQk5GUGFyc2VyIH0gZnJvbSBcIi4vY3VzdG9tR3JhbW1hckJORi9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9wYXJzZXJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ3VzdG9tR3JhbW1hckJORkxleGVyLCBDdXN0b21HcmFtbWFyQk5GUGFyc2VyIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXJzXCI7XG5pbXBvcnQgeyBDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLCBDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciB9IGZyb20gXCJvY2NhbS1ncmFtbWFyc1wiO1xuXG5leHBvcnQgY29uc3QgY3VzdG9tR3JhbW1hckJORkxleGVyID0gQ3VzdG9tR3JhbW1hckJORkxleGVyLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBjb25zdCBjdXN0b21HcmFtbWFyQk5GUGFyc2VyID0gQ3VzdG9tR3JhbW1hckJORlBhcnNlci5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgY29uc3QgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciA9IEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyID0gQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIuZnJvbU5vdGhpbmcoKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciB9IGZyb20gXCIuLi91dGlsaXRpZXMvZ3JhbW1hclwiXG5cbmNvbnN0IHsgc2Vjb25kIH0gPSBhcnJheVV0aWxpdGllcztcblxuY29uc3QgZXhwcmVzc2lvbk5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5KFwiLy9leHByZXNzaW9uXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbnNGcm9tVm9jYWJ1bGFyeSh2b2NhYnVsYXJ5LCBleHByZXNzaW9ucykge1xuICBjb25zdCBjb250ZW50ID0gdm9jYWJ1bGFyeSwgLy8vXG4gICAgICAgIHRva2VucyA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgIG5vZGUgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlci5wYXJzZSh0b2tlbnMpO1xuXG4gIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwcmVzc2lvbk5vZGVzID0gZXhwcmVzc2lvbk5vZGVzUXVlcnkobm9kZSk7XG5cbiAgZXhwcmVzc2lvbk5vZGVzLmZvckVhY2goKGV4cHJlc3Npb25Ob2RlKSA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IGNvbnRlbnRGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIGV4cHJlc3Npb24gPSBlc2NhcGUoY29udGVudCk7XG5cbiAgICBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29udGVudEZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICBzZWNvbmRDaGlsZE5vZGUgPSBzZWNvbmQoY2hpbGROb2RlcyksXG4gICAgICAgIHVuYXNzaWduZWRUZXJtaW5hbE5vZGUgPSBzZWNvbmRDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgY29udGVudCA9IHVuYXNzaWduZWRUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vbkxleGVyIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IE5vbWluYWxMZXhlciwgTm9taW5hbFBhcnNlciB9IGZyb20gXCJvY2NhbS1ncmFtbWFyc1wiO1xuXG5leHBvcnQgY29uc3Qgbm9taW5hbExleGVyID0gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoTm9taW5hbExleGVyKTtcblxuZXhwb3J0IGNvbnN0IG5vbWluYWxQYXJzZXIgPSBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoTm9taW5hbFBhcnNlcik7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBub21pbmFsUGFyc2VyIH0gZnJvbSBcIi4vdXRpbGl0aWVzL25vbWluYWxcIjtcbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FLCBTVEFURU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBTVFVGRl9SVUxFX05BTUUsIE5PTlNFTlNFX1JVTEVfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuY29uc3QgcnVsZU1hcCA9IG5vbWluYWxQYXJzZXIuZ2V0UnVsZU1hcCgpLFxuICAgICAgc3R1ZmZSdWxlID0gcnVsZU1hcFtTVFVGRl9SVUxFX05BTUVdLFxuICAgICAgbm9uc2Vuc2VSdWxlID0gcnVsZU1hcFtOT05TRU5TRV9SVUxFX05BTUVdLFxuICAgICAgc3R1ZmZUeXBlcyA9IHR5cGVzRnJvbVJ1bGUoc3R1ZmZSdWxlKSxcbiAgICAgIG5vbnNlbnNlVHlwZXMgPSB0eXBlc0Zyb21SdWxlKG5vbnNlbnNlUnVsZSksXG4gICAgICB0ZXJtVHlwZXMgPSBzdHVmZlR5cGVzLCAvLy9cbiAgICAgIHN0YXRlbWVudFR5cGVzID0gbm9uc2Vuc2VUeXBlcyxcbiAgICAgIHR5cGVzTWFwID0ge1xuICAgICAgICBbVEVSTV9SVUxFX05BTUVdOiB0ZXJtVHlwZXMsXG4gICAgICAgIFtTVEFURU1FTlRfUlVMRV9OQU1FXTogc3RhdGVtZW50VHlwZXNcbiAgICAgIH07XG5cbmV4cG9ydCBkZWZhdWx0IHR5cGVzTWFwO1xuXG5mdW5jdGlvbiB0eXBlc0Zyb21SdWxlKHJ1bGUpIHtcbiAgbGV0IHBhcnRzO1xuXG4gIGNvbnN0IGRlZmluaXRpb25zID0gcnVsZS5nZXREZWZpbml0aW9ucygpLFxuICAgICAgICBmaXJzdEREZWZpbml0aW9uID0gZmlyc3QoZGVmaW5pdGlvbnMpLFxuICAgICAgICBkZWZpbml0aW9uID0gZmlyc3RERGVmaW5pdGlvbjsgIC8vL1xuXG4gIHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gIGNvbnN0IGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgb25lT3JNb3JlUGFydHNQYXJ0ID0gZmlyc3RQYXJ0LCAvLy9cbiAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCksXG4gICAgICAgIGNob2ljZU9yUGFydHNQYXJ0ID0gcGFydDsgLy8vXG5cbiAgcGFydHMgPSBjaG9pY2VPclBhcnRzUGFydC5nZXRQYXJ0cygpO1xuXG4gIGNvbnN0IHR5cGVzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmdldFNpZ25pZmljYW50VG9rZW5UeXBlKCksXG4gICAgICAgICAgdHlwZSA9IHNpZ25pZmljYW50VG9rZW5UeXBlOyAgLy8vXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHR5cGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHR5cGVzTWFwIGZyb20gXCIuLi90eXBlc01hcFwiO1xuXG5pbXBvcnQgeyBub21pbmFsTGV4ZXIgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL25vbWluYWxcIjtcbmltcG9ydCB7IG5vZGVRdWVyeSwgbm9kZXNRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcXVlcnlcIjtcbmltcG9ydCB7IFVOQVNTSUdORURfVFlQRSwgQkFTRV9UWVBFX1NZTUJPTCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGN1c3RvbUdyYW1tYXJCTkZMZXhlciwgY3VzdG9tR3JhbW1hckJORlBhcnNlciwgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciwgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2dyYW1tYXJcIjtcblxuY29uc3QgeyBmaXJzdCwgc2Vjb25kIH0gPSBhcnJheVV0aWxpdGllcztcblxuY29uc3QgZXhwcmVzc2lvbk5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5KFwiLy9leHByZXNzaW9uXCIpLFxuICAgICAgcnVsZU5hbWVUZXJtaW5hbE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9kb2N1bWVudC9ydWxlL25hbWUvQCohXCIpLFxuICAgICAgdW5hc3NpZ25lZFRlcm1pbmFsTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL2V4cHJlc3Npb24vQHVuYXNzaWduZWRcIiksXG4gICAgICBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8vc3RyaW5nTGl0ZXJhbC9AKiFcIiksXG4gICAgICBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvL3NpZ25pZmljYW50VG9rZW5UeXBlL0AqIVwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQk5GKGJuZiwgcnVsZU5hbWUpIHtcbiAgY29uc3QgY29udGVudCA9IGJuZixcbiAgICAgICAgdG9rZW5zID0gY3VzdG9tR3JhbW1hckJORkxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3VzdG9tR3JhbW1hckJORlBhcnNlci5wYXJzZSh0b2tlbnMpO1xuXG4gIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcnVsZU5hbWVUZXJtaW5hbE5vZGUgPSBydWxlTmFtZVRlcm1pbmFsTm9kZVF1ZXJ5KG5vZGUpO1xuXG4gIGlmIChydWxlTmFtZVRlcm1pbmFsTm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5hbWUgPSBuYW1lRnJvbVJ1bGVOYW1lVGVybWluYWxOb2RlKHJ1bGVOYW1lVGVybWluYWxOb2RlKTtcblxuICAgIGlmIChuYW1lICE9PSBydWxlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7bmFtZX0nIHJ1bGUgc2hvdWxkIGJlIG5hbWVkICcke3J1bGVOYW1lfScuYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHlwZXMgPSB0eXBlc01hcFtydWxlTmFtZV0sXG4gICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlcyA9IHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2Rlc1F1ZXJ5KG5vZGUpO1xuXG4gIHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2Rlcy5mb3JFYWNoKChzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlRnJvbVNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlKHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlKSxcbiAgICAgICAgICB0eXBlc0luY2x1ZGVUeXBlID0gdHlwZXMuaW5jbHVkZXModHlwZSk7XG5cbiAgICBpZiAoIXR5cGVzSW5jbHVkZVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke3R5cGV9JyB0eXBlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlJ3MgdHlwZXMuYClcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVzID0gc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXNRdWVyeShub2RlKTtcblxuICBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2Rlcy5mb3JFYWNoKChzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IGNvbnRlbnRGcm9tU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZShzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlKTtcblxuICAgIGlmIChjb250ZW50ID09PSBCQVNFX1RZUEVfU1lNQk9MKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7Y29udGVudH1cIiBzdHJpbmcgbGl0ZXJhbCBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIGJhc2UgdHlwZSBzeW1ib2wuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5zID0gbm9taW5hbExleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIHRva2Vuc0xlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICBpZiAodG9rZW5zTGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuaXNpbmcgdGhlIFwiJHtjb250ZW50fVwiIHN0cmluZyBsaXRlcmFsIGRvZXMgbm90IHJlc3VsdCBpbiBhIHNpbmdsZSB0b2tlbi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFRva2VuID0gZmlyc3QodG9rZW5zKSxcbiAgICAgICAgICB0b2tlbiA9IGZpcnN0VG9rZW4sIC8vL1xuICAgICAgICAgIHR5cGUgPSB0b2tlbi5nZXRUeXBlKCksXG4gICAgICAgICAgdHlwZXNJbmNsdWRlVHlwZSA9IHR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuXG4gICAgaWYgKCF0eXBlc0luY2x1ZGVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7Y29udGVudH1cIiBzdHJpbmcgbGl0ZXJhbCdzIHRva2VuJ3MgJyR7dHlwZX0nIHR5cGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUncyB0eXBlcy5gKVxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVZvY2FidWxhcnkodm9jYWJ1bGFyeSkge1xuICBjb25zdCBjb250ZW50ID0gdm9jYWJ1bGFyeSwgLy8vXG4gICAgICAgIHRva2VucyA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgIG5vZGUgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlci5wYXJzZSh0b2tlbnMpO1xuXG4gIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwcmVzc2lvbk5vZGVzID0gZXhwcmVzc2lvbk5vZGVzUXVlcnkobm9kZSk7XG5cbiAgZXhwcmVzc2lvbk5vZGVzLmZvckVhY2goKGV4cHJlc3Npb25Ob2RlKSA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IGNvbnRlbnRGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHRva2VucyA9IG5vbWluYWxMZXhlci50b2tlbmlzZShjb250ZW50KSxcbiAgICAgICAgICB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRva2Vuc0xlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW5pc2luZyB0aGUgJyR7Y29udGVudH0nIGNvbnRlbnQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHRva2VuLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSBmaXJzdCh0b2tlbnMpLFxuICAgICAgICAgIHRva2VuID0gZmlyc3RUb2tlbixcbiAgICAgICAgICB0eXBlID0gdG9rZW4uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHR5cGUgIT09IFVOQVNTSUdORURfVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7dHlwZX0nIHR5cGUgb2YgdGhlICcke2NvbnRlbnR9JyB0b2tlbiBpcyBub3QgJ3VuYXNzaWduZWQnLmApO1xuICAgIH1cblxuICAgIGlmIChjb250ZW50ID09PSBCQVNFX1RZUEVfU1lNQk9MKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtjb250ZW50fScgdG9rZW4gY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBiYXNlIHR5cGUgc3ltYm9sLmApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgbGV0IGNvbnRlbnQ7XG5cbiAgY29uc3QgdW5hc3NpZ25lZFRlcm1pbmFsTm9kZSA9IHVuYXNzaWduZWRUZXJtaW5hbE5vZGVRdWVyeShleHByZXNzaW9uTm9kZSk7XG5cbiAgY29udGVudCA9IHVuYXNzaWduZWRUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gIHJldHVybiBjb250ZW50Oztcbn1cblxuZnVuY3Rpb24gbmFtZUZyb21SdWxlTmFtZVRlcm1pbmFsTm9kZShydWxlTmFtZVRlcm1pbmFsTm9kZSkge1xuICBsZXQgbmFtZTtcblxuICBjb25zdCBjb250ZW50ID0gcnVsZU5hbWVUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gIG5hbWUgPSBjb250ZW50OyAvLy9cblxuICByZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24gY29udGVudEZyb21TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlKHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUpIHtcbiAgbGV0IGNvbnRlbnQ7XG5cbiAgY29udGVudCA9IHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKC9cIihbXlwiXSopXCIvKSxcbiAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgY29udGVudCA9IHNlY29uZE1hdGNoOyAvLy9cblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gdHlwZUZyb21TaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZShzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZSkge1xuICBsZXQgdHlwZTtcblxuICBjb25zdCBjb250ZW50ID0gc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICBtYXRjaGVzID0gY29udGVudC5tYXRjaCgvXFxbKFteXFxdXSopXFxdLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gIHR5cGUgPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIHR5cGU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5pbXBvcnQgeyBwYXJzZXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgZWxpbWluYXRlTGVmdFJlY3Vyc2lvbiB9IGZyb20gXCJvY2NhbS1ncmFtbWFyLXV0aWxpdGllc1wiO1xuXG5pbXBvcnQgZGVmYXVsdEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXIvZGVmYXVsdFwiO1xuXG5pbXBvcnQgeyBleHByZXNzaW9uc0Zyb21Wb2NhYnVsYXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy92b2NhYnVsYXJ5XCI7XG5pbXBvcnQgeyBWRVJUSUNBTF9CQVIsIFZFUlRJQ0FMX1NQQUNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVCTkYsIHZhbGlkYXRlVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdmFsaWRhdGVcIjtcbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FLCBTVEFURU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgVFlQRV9WT0NBQlVMQVJZX05BTUUsIFNZTUJPTF9WT0NBQlVMQVJZX05BTUUgfSBmcm9tIFwiLi4vdm9jYWJ1bGFyeU5hbWVzXCI7XG5cbmNvbnN0IHsgb3BhcXVlICB9ID0gc3BlY2lhbFN5bWJvbHMsXG4gICAgICB7IHJ1bGVzRnJvbUJORiB9ID0gcGFyc2VyVXRpbGl0aWVzLFxuICAgICAgeyB1bnNoaWZ0LCBmb3J3YXJkc0ZvckVhY2gsIGJhY2t3YXJkc0ZvckVhY2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21iaW5lZEN1c3RvbUdyYW1tYXIge1xuICBjb25zdHJ1Y3RvcihydWxlcywgZW50cmllcykge1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICB9XG4gIFxuICBnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcztcbiAgfVxuXG4gIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgfVxuXG4gIHBvc3RQcm9jZXNzKHJ1bGVzKSB7XG4gICAgcnVsZXMgPSBbIC8vL1xuICAgICAgLi4ucnVsZXMsXG4gICAgICAuLi50aGlzLnJ1bGVzXG4gICAgXTtcblxuICAgIHJ1bGVzID0gZWxpbWluYXRlTGVmdFJlY3Vyc2lvbihydWxlcyk7ICAvLy9cblxuICAgIHJldHVybiBydWxlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZyhpbmNsdWRlRGVmYXVsdCA9IHRydWUpIHtcbiAgICBsZXQgY3VzdG9tR3JhbW1hcnMgPSBbXTtcblxuICAgIGlmIChpbmNsdWRlRGVmYXVsdCkge1xuICAgICAgY3VzdG9tR3JhbW1hcnMgPSBbIGRlZmF1bHRDdXN0b21HcmFtbWFyLCAuLi5jdXN0b21HcmFtbWFycyBdOyAvLy9cbiAgICB9XG5cbiAgICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSxcbiAgICAgICAgICBlbnRyaWVzID0gZW50cmllc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyksXG4gICAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gbmV3IENvbWJpbmVkQ3VzdG9tR3JhbW1hcihydWxlcywgZW50cmllcyk7XG5cbiAgICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xuICB9XG5cbiAgc3RhdGljIGZyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycywgaW5jbHVkZURlZmF1bHQgPSB0cnVlKSB7XG4gICAgaWYgKGluY2x1ZGVEZWZhdWx0KSB7XG4gICAgICBjdXN0b21HcmFtbWFycyA9IFsgZGVmYXVsdEN1c3RvbUdyYW1tYXIsIC4uLmN1c3RvbUdyYW1tYXJzIF07IC8vL1xuICAgIH1cblxuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpLFxuICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSxcbiAgICAgICAgICBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBuZXcgQ29tYmluZWRDdXN0b21HcmFtbWFyKHJ1bGVzLCBlbnRyaWVzKTtcbiAgICBcbiAgICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bGVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IFtcbiAgICAgICAgICBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICBTVEFURU1FTlRfUlVMRV9OQU1FLFxuICAgICAgICBdLFxuICAgICAgICBibmZzID0gcnVsZU5hbWVzLm1hcCgocnVsZU5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBibmYgPSBibmZGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIHJ1bGVOYW1lKTtcblxuICAgICAgICAgIHJldHVybiBibmY7XG4gICAgICAgIH0pLFxuICAgICAgICBibmYgPSBibmZzLmpvaW4oVkVSVElDQUxfU1BBQ0UpLFxuICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUJORihibmYpO1xuXG4gIGNvbWJpbmVSdWxlcyhydWxlcyk7XG5cbiAgY29uc3Qgb3BhY2l0eSA9IG9wYXF1ZTsgLy8vXG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBydWxlLmdldE5hbWUoKTtcblxuICAgICAgaWYgKG5hbWUgPT09IHJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcnVsZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICB9KTtcblxuICByZXR1cm4gcnVsZXM7XG59XG5cbmZ1bmN0aW9uIGVudHJpZXNGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpIHtcbiAgY29uc3Qgdm9jYWJ1bGFyeU5hbWVzID0gW1xuICAgICAgICAgIFRZUEVfVk9DQUJVTEFSWV9OQU1FLFxuICAgICAgICAgIFNZTUJPTF9WT0NBQlVMQVJZX05BTUVcbiAgICAgICAgXSxcbiAgICAgICAgZW50cmllcyA9IHZvY2FidWxhcnlOYW1lcy5tYXAoKHZvY2FidWxhcnlOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyeUZyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycywgdm9jYWJ1bGFyeU5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9KTtcblxuICByZXR1cm4gZW50cmllcztcbn1cblxuZnVuY3Rpb24gZW50cnlGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIHZvY2FidWxhcnlOYW1lKSB7XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG5cbiAgYmFja3dhcmRzRm9yRWFjaChjdXN0b21HcmFtbWFycywgKGN1c3RvbUdyYW1tYXIpID0+IHtcbiAgICBjb25zdCB2b2NhYnVsYXJ5ID0gY3VzdG9tR3JhbW1hci5nZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lKSxcbiAgICAgICAgICBjdXN0b21HcmFtbWFyRGVmYXVsdEN1c3RvbUdyYW1tYXIgPSBjdXN0b21HcmFtbWFyLmlzRGVmYXVsdEN1c3RvbUdyYW1tYXIoKTtcblxuICAgIGlmICghY3VzdG9tR3JhbW1hckRlZmF1bHRDdXN0b21HcmFtbWFyKSB7XG4gICAgICB2YWxpZGF0ZVZvY2FidWxhcnkodm9jYWJ1bGFyeSk7XG4gICAgfVxuXG4gICAgZXhwcmVzc2lvbnNGcm9tVm9jYWJ1bGFyeSh2b2NhYnVsYXJ5LCBleHByZXNzaW9ucyk7XG4gIH0pO1xuXG4gIGNvbnN0IHBhdHRlcm4gPSBleHByZXNzaW9ucy5qb2luKFZFUlRJQ0FMX0JBUiksXG4gICAgICAgIGVudHJ5TmFtZSA9IHZvY2FidWxhcnlOYW1lLCAgLy8vXG4gICAgICAgIGVudHJ5VmFsdWUgPSBgXig/OiR7cGF0dGVybn0pYCxcbiAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgW2VudHJ5TmFtZV06IGVudHJ5VmFsdWVcbiAgICAgICAgfTtcblxuICByZXR1cm4gZW50cnk7XG59XG5cbmZ1bmN0aW9uIGJuZkZyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycywgcnVsZU5hbWUpIHtcbiAgY29uc3QgYm5mcyA9IFtdO1xuXG4gIGZvcndhcmRzRm9yRWFjaChjdXN0b21HcmFtbWFycywgKGN1c3RvbUdyYW1tYXIpID0+IHtcbiAgICBjb25zdCBibmYgPSBjdXN0b21HcmFtbWFyLmdldEJORihydWxlTmFtZSksXG4gICAgICAgICAgY3VzdG9tR3JhbW1hckRlZmF1bHRDdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hci5pc0RlZmF1bHRDdXN0b21HcmFtbWFyKCk7XG5cbiAgICBpZiAoIWN1c3RvbUdyYW1tYXJEZWZhdWx0Q3VzdG9tR3JhbW1hcikge1xuICAgICAgdmFsaWRhdGVCTkYoYm5mLCBydWxlTmFtZSk7XG4gICAgfVxuXG4gICAgYm5mcy5wdXNoKGJuZik7XG4gIH0pO1xuXG4gIGNvbnN0IGJuZiA9IGJuZnMuam9pbihWRVJUSUNBTF9TUEFDRSk7XG5cbiAgcmV0dXJuIGJuZjtcbn1cblxuZnVuY3Rpb24gY29tYmluZVJ1bGVzKHJ1bGVzKSB7XG4gIGxldCBvdXRlckluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcblxuICB3aGlsZSAob3V0ZXJJbmRleCA8IGxlbmd0aCkge1xuICAgIGNvbnN0IG91dGVyUnVsZSA9IHJ1bGVzW291dGVySW5kZXhdLFxuICAgICAgICAgIG91dGVyUnVsZU5hbWUgPSBvdXRlclJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgbGV0IGlubmVySW5kZXggPSBvdXRlckluZGV4ICsgMTtcblxuICAgIHdoaWxlIChpbm5lckluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBjb25zdCBpbm5lclJ1bGUgPSBydWxlc1tpbm5lckluZGV4XSxcbiAgICAgICAgICAgIGlubmVyUnVsZU5hbWUgPSBpbm5lclJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgICBpZiAoaW5uZXJSdWxlTmFtZSA9PT0gb3V0ZXJSdWxlTmFtZSkge1xuICAgICAgICBjb25zdCBpbm5lclJ1bGVEZWZpbml0aW9ucyA9IGlubmVyUnVsZS5nZXREZWZpbml0aW9ucygpLFxuICAgICAgICAgICAgICBvdXRlclJ1bGVEZWZpbml0aW9ucyA9IG91dGVyUnVsZS5nZXREZWZpbml0aW9ucygpO1xuXG4gICAgICAgIHVuc2hpZnQob3V0ZXJSdWxlRGVmaW5pdGlvbnMsIGlubmVyUnVsZURlZmluaXRpb25zKTtcblxuICAgICAgICBjb25zdCBzdGFydCA9IGlubmVySW5kZXgsIC8vL1xuICAgICAgICAgICAgICBkZWxldGVDb3VudCA9IDE7XG5cbiAgICAgICAgcnVsZXMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG5cbiAgICAgICAgbGVuZ3RoID0gcnVsZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5uZXJJbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dGVySW5kZXgrKztcblxuICAgIGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBsZXhlclV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IENvbWJpbmVkQ3VzdG9tR3JhbW1hciBmcm9tIFwiLi4vY3VzdG9tR3JhbW1hci9jb21iaW5lZFwiO1xuXG5jb25zdCB7IGxleGVyRnJvbVJ1bGVzLCBydWxlc0Zyb21FbnRyaWVzIH0gPSBsZXhlclV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGxleGVyRnJvbU5vdGhpbmcoQ2xhc3MpIHtcbiAgY29uc3QgeyBlbnRyaWVzIH0gPSBDbGFzcyxcbiAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21Ob3RoaW5nKCksXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGxleGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4ZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgeyBlbnRyaWVzIH0gPSBDbGFzcyxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21FbnRyaWVzQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGVudHJpZXMsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gbGV4ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXhlckZyb21FbnRyaWVzQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgcnVsZXMgPSBydWxlc0Zyb21FbnRyaWVzQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGVudHJpZXMsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gbGV4ZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbGV4ZXJGcm9tTm90aGluZyxcbiAgbGV4ZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyLFxuICBsZXhlckZyb21FbnRyaWVzQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyXG59O1xuXG5mdW5jdGlvbiBydWxlc0Zyb21FbnRyaWVzQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGVudHJpZXMsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCBjdXN0b21HcmFtbWFyRW50cmllcyA9IGNvbWJpbmVkQ3VzdG9tR3JhbW1hci5nZXRFbnRyaWVzKCk7XG5cbiAgZW50cmllcyA9IFsgLy8vXG4gICAgLi4uY3VzdG9tR3JhbW1hckVudHJpZXMsXG4gICAgLi4uZW50cmllc1xuICBdO1xuXG4gIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tRW50cmllcyhlbnRyaWVzKTtcblxuICByZXR1cm4gcnVsZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnNlclV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBDb21iaW5lZEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXIvY29tYmluZWRcIjtcblxuY29uc3QgeyBydWxlc0Zyb21CTkYsIHBhcnNlckZyb21SdWxlcywgcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZSB9ID0gcGFyc2VyVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbU5vdGhpbmcoQ2xhc3MpIHtcbiAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBDb21iaW5lZEN1c3RvbUdyYW1tYXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoYm5mLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbVN0YXJ0UnVsZU5hbWUoQ2xhc3MsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBDb21iaW5lZEN1c3RvbUdyYW1tYXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoYm5mLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXNBbmRTdGFydFJ1bGVOYW1lKENsYXNzLCBydWxlcywgc3RhcnRSdWxlTmFtZSk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21Db21iaW5lZEN1c3RvbUdyYW1tYXIoQ2xhc3MsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCB7IGJuZiB9ID0gQ2xhc3MsXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoQ2xhc3MsIGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21TdGFydFJ1bGVOYW1lQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBzdGFydFJ1bGVOYW1lLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUoQ2xhc3MsIHJ1bGVzLCBzdGFydFJ1bGVOYW1lKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbUJORlN0YXJ0UnVsZU5hbWVBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoQ2xhc3MsIGJuZiwgc3RhcnRSdWxlTmFtZSwgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcGFyc2VyRnJvbU5vdGhpbmcsXG4gIHBhcnNlckZyb21TdGFydFJ1bGVOYW1lLFxuICBwYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyLFxuICBwYXJzZXJGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyLFxuICBwYXJzZXJGcm9tU3RhcnRSdWxlTmFtZUFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgcGFyc2VyRnJvbUJORlN0YXJ0UnVsZU5hbWVBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXJcbn07XG5cbmZ1bmN0aW9uIHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBsZXQgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICBydWxlcyA9IGNvbWJpbmVkQ3VzdG9tR3JhbW1hci5wb3N0UHJvY2VzcyhydWxlcyk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQ3VzdG9tR3JhbW1hciBmcm9tIFwiLi4vY3VzdG9tR3JhbW1hclwiO1xuaW1wb3J0IENvbWJpbmVkQ3VzdG9tR3JhbW1hciBmcm9tIFwiLi4vY3VzdG9tR3JhbW1hci9jb21iaW5lZFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUpTT04oanNvbikge1xuICBjb25zdCBjdXN0b21HcmFtbWFyc0pTT04gPSBqc29uLCAgLy8vXG4gICAgICAgIGN1c3RvbUdyYW1tYXJzID0gY3VzdG9tR3JhbW1hcnNKU09OLm1hcCgoY3VzdG9tR3JhbW1hckpTT04pID0+IHtcbiAgICAgICAgICBjb25zdCBqc29uID0gY3VzdG9tR3JhbW1hckpTT04sIC8vL1xuICAgICAgICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBDdXN0b21HcmFtbWFyLmZyb21KU09OKGpzb24pO1xuXG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUdyYW1tYXI7XG4gICAgICAgIH0pO1xuXG4gIGN1c3RvbUdyYW1tYXJzLnJldmVyc2UoKTsgLy9cblxuICBjb25zdCBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBDb21iaW5lZEN1c3RvbUdyYW1tYXIuZnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKTtcblxuICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbU5vdGhpbmcoKSB7XG4gIGNvbnN0IGN1c3RvbUdyYW1tYXJzID0gW10sXG4gICAgICAgIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IENvbWJpbmVkQ3VzdG9tR3JhbW1hci5mcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpO1xuXG4gIHJldHVybiBjb21iaW5lZEN1c3RvbUdyYW1tYXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpIHtcbiAgY3VzdG9tR3JhbW1hcnMgPSBbICAvLy9cbiAgICAuLi5jdXN0b21HcmFtbWFyc1xuICBdO1xuXG4gIGN1c3RvbUdyYW1tYXJzLnJldmVyc2UoKTsgLy8vXG5cbiAgY29uc3QgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tSlNPTixcbiAgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbU5vdGhpbmcsXG4gIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21DdXN0b21HcmFtbWFyc1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgREVGQVVMVF9DVVNUT01fR1JBTU1BUl9OQU1FIH0gZnJvbSBcIi4vZ3JhbW1hck5hbWVzXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgcnVsZU5hbWVzIH0gZnJvbSBcIi4vcnVsZU5hbWVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZvY2FidWxhcnlOYW1lcyB9IGZyb20gXCIuL3ZvY2FidWxhcnlOYW1lc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1c3RvbUdyYW1tYXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlZmF1bHRDdXN0b21HcmFtbWFyIH0gZnJvbSBcIi4vY3VzdG9tR3JhbW1hci9kZWZhdWx0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbWJpbmVkQ3VzdG9tR3JhbW1hciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXIvY29tYmluZWRcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXhlcnNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvbGV4ZXJzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlcnNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcGFyc2Vyc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjdXN0b21HcmFtbWFyVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N1c3RvbUdyYW1tYXJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ3VzdG9tR3JhbW1hciwgY3VzdG9tR3JhbW1hclV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1jdXN0b20tZ3JhbW1hcnNcIjtcblxuY29uc3QgeyBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tQ3VzdG9tR3JhbW1hcnMgfSA9IGN1c3RvbUdyYW1tYXJVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21HcmFtbWFyRnJvbU5hbWVBbmRFbnRyaWVzKG5hbWUsIGVudHJpZXMpIHtcbiAgY29uc3QgdGVybUJORiA9IGVudHJpZXMuZ2V0VGVybUJORigpLFxuICAgICAgICBzdGF0ZW1lbnRCTkYgPSBlbnRyaWVzLmdldFN0YXRlbWVudEJORigpLFxuICAgICAgICB0eXBlVm9jYWJ1bGFyeSA9IGVudHJpZXMuZ2V0VHlwZVZvY2FidWxhcnkoKSxcbiAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeSA9IGVudHJpZXMuZ2V0U3ltYm9sVm9jYWJ1bGFyeSgpLFxuICAgICAgICBjdXN0b21HcmFtbWFyID0gQ3VzdG9tR3JhbW1hci5mcm9tTmFtZVRlcm1CTkZTdGF0ZW1lbnRCTkZUeXBlVm9jYWJ1bGFyeUFuZFN5bWJvbFZvY2FidWxhcnkobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSk7XG5cbiAgcmV0dXJuIGN1c3RvbUdyYW1tYXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tUmVsZWFzZUNvbnRleHRzKHJlbGVhc2VDb250ZXh0cykge1xuICBjb25zdCBjdXN0b21HcmFtbWFycyA9IHJlbGVhc2VDb250ZXh0cy5tYXAoKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY3VzdG9tR3JhbW1hciA9IHJlbGVhc2VDb250ZXh0LmdldEN1c3RvbUdyYW1tYXIoKTtcblxuICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICB9KTtcblxuICBjb25zdCBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpO1xuXG4gIHJldHVybiBjb21iaW5lZEN1c3RvbUdyYW1tYXI7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlQ29udGV4dHNGcm9tSlNPTihqc29uLCBmaWxlQ29udGV4dHMsIHJlbGVhc2VDb250ZXh0LCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCkge1xuICBjb25zdCBmaWxlQ29udGV4dHNKU09OID0ganNvbjsgIC8vL1xuXG4gIGZpbGVDb250ZXh0c0pTT04uZm9yRWFjaCgoZmlsZUNvbnRleHRKU09OKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlUGF0aCB9ID0gZmlsZUNvbnRleHRKU09OLFxuICAgICAgICAgIEZpbGVDb250ZXh0ID0gRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgaWYgKEZpbGVDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBqc29uID0gZmlsZUNvbnRleHRKU09OLCAvLy9cbiAgICAgICAgICAgIGZpbGVDb250ZXh0ID0gRmlsZUNvbnRleHQuZnJvbUpTT04oanNvbiwgcmVsZWFzZUNvbnRleHQpO1xuXG4gICAgICBmaWxlQ29udGV4dHMucHVzaChmaWxlQ29udGV4dCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVDb250ZXh0c0Zyb21FbnRyaWVzKGVudHJpZXMsIGZpbGVDb250ZXh0cywgcmVsZWFzZUNvbnRleHQsIEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKSB7XG4gIGVudHJpZXMuZm9yRWFjaEZpbGUoKGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgIEZpbGVDb250ZXh0ID0gRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgaWYgKEZpbGVDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBmaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0LmZyb21GaWxlKGZpbGUsIHJlbGVhc2VDb250ZXh0KTtcblxuICAgICAgZmlsZUNvbnRleHRzLnB1c2goZmlsZUNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZmlsZUNvbnRleHRzRnJvbUpTT04sXG4gIGZpbGVDb250ZXh0c0Zyb21FbnRyaWVzXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgdmVyaWZ5VHlwZVByZWZpeGVzLCB2ZXJpZnlGaWxlQ29udGV4dHMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ZlcmlmeVwiO1xuaW1wb3J0IHsgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbVJlbGVhc2VDb250ZXh0cyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY3VzdG9tR3JhbW1hclwiO1xuaW1wb3J0IHsgZmlsZUNvbnRleHRzRnJvbUpTT04sIGZpbGVDb250ZXh0c0Zyb21FbnRyaWVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9maWxlQ29udGV4dFwiO1xuaW1wb3J0IHsgVFJBQ0VfTEVWRUwsIERFQlVHX0xFVkVMLCBJTkZPX0xFVkVMLCBXQVJOSU5HX0xFVkVMLCBFUlJPUl9MRVZFTCwgQlJFQUtfTUVTU0FHRSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBwdXNoLCB0YWlsLCBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbGVhc2VDb250ZXh0IHtcbiAgY29uc3RydWN0b3IobG9nLCBuYW1lLCBqc29uLCBlbnRyaWVzLCBjYWxsYmFjaywgY3VzdG9tR3JhbW1hciwgdmVyaWZpZXMsIGluaXRpYWxpc2VkLCBmaWxlQ29udGV4dHMsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciwgZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cykge1xuICAgIHRoaXMubG9nID0gbG9nO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmN1c3RvbUdyYW1tYXIgPSBjdXN0b21HcmFtbWFyO1xuICAgIHRoaXMudmVyaWZpZXMgPSB2ZXJpZmllcztcbiAgICB0aGlzLmluaXRpYWxpc2VkID0gaW5pdGlhbGlzZWQ7XG4gICAgdGhpcy5maWxlQ29udGV4dHMgPSBmaWxlQ29udGV4dHM7XG4gICAgdGhpcy5jb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXI7XG4gICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzID0gZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cztcbiAgfVxuXG4gIGdldExvZygpIHtcbiAgICByZXR1cm4gdGhpcy5sb2c7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRKU09OKCkge1xuICAgIHJldHVybiB0aGlzLmpzb247XG4gIH1cblxuICBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXM7XG4gIH1cblxuICBnZXRDYWxsYmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjaztcbiAgfVxuXG4gIGdldEN1c3RvbUdyYW1tYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIGdldFZlcmlmaWVzKCkge1xuICAgIHJldHVybiB0aGlzLnZlcmlmaWVzO1xuICB9XG5cbiAgaXNJbml0aWFsaXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsaXNlZDtcbiAgfVxuXG4gIGdldEZpbGVDb250ZXh0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlQ29udGV4dHM7XG4gIH1cblxuICBnZXRDb21iaW5lZEN1c3RvbUdyYW1tYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWRDdXN0b21HcmFtbWFyO1xuICB9XG5cbiAgZ2V0RGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cygpIHtcbiAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzO1xuICB9XG5cbiAgZ2V0UmVsZWFzZUNvbnRleHQoKSB7XG4gICAgY29uc3QgcmVsZWFzZUNvbnRleHQgPSB0aGlzOyAgLy8vXG5cbiAgICByZXR1cm4gcmVsZWFzZUNvbnRleHQ7XG4gIH1cblxuICBnZXREZXB0aCgpIHtcbiAgICBjb25zdCBkZXB0aCA9IDA7XG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBoYXNWZXJpZmllZCgpIHtcbiAgICBjb25zdCB2ZXJpZmllZCA9IHRoaXMudmVyaWZpZXM7IC8vL1xuXG4gICAgcmV0dXJuIHZlcmlmaWVkO1xuICB9XG5cbiAgaXNSZWxlYXNlZCgpIHtcbiAgICBjb25zdCByZWxlYXNlZCA9ICh0aGlzLmpzb24gIT09IG51bGwpO1xuXG4gICAgcmV0dXJuIHJlbGVhc2VkO1xuICB9XG5cbiAgZ2V0VHlwZVByZWZpeCgpIHtcbiAgICBsZXQgdHlwZVByZWZpeCA9IG51bGw7XG5cbiAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgdHlwZVByZWZpeGVzID0gdGhpcy5nZXRUeXBlUHJlZml4ZXMoaW5jbHVkZURlcGVuZGVuY2llcyksXG4gICAgICAgICAgdHlwZVByZWZpeGVzTGVuZ3RoID0gdHlwZVByZWZpeGVzLmxlbmd0aDtcblxuICAgIGlmICh0eXBlUHJlZml4ZXNMZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpcnN0VHlwZVByZWZpeCA9IGZpcnN0KHR5cGVQcmVmaXhlcyk7XG5cbiAgICAgIHR5cGVQcmVmaXggPSBmaXJzdFR5cGVQcmVmaXg7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlUHJlZml4O1xuICB9XG5cbiAgZ2V0TGFiZWxzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0TGFiZWxzID0gZmlsZUNvbnRleHQuZ2V0TGFiZWxzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChsYWJlbHMsIGZpbGVDb250ZXh0TGFiZWxzKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dExhYmVscyA9IHJlbGVhc2VDb250ZXh0LmdldExhYmVscyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKGxhYmVscywgcmVsZWFzZUNvbnRleHRMYWJlbHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVscztcbiAgfVxuXG4gIGdldFR5cGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgdHlwZXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRUeXBlcyA9IGZpbGVDb250ZXh0LmdldFR5cGVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaCh0eXBlcywgZmlsZUNvbnRleHRUeXBlcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRUeXBlcyA9IHJlbGVhc2VDb250ZXh0LmdldFR5cGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2godHlwZXMsIHJlbGVhc2VDb250ZXh0VHlwZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVzO1xuICB9XG5cbiAgZ2V0UnVsZXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBydWxlcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dFJ1bGVzID0gZmlsZUNvbnRleHQuZ2V0UnVsZXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKHJ1bGVzLCBmaWxlQ29udGV4dFJ1bGVzKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFJ1bGVzID0gcmVsZWFzZUNvbnRleHQuZ2V0UnVsZXMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChydWxlcywgcmVsZWFzZUNvbnRleHRSdWxlcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBnZXRBeGlvbXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBheGlvbXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRBeGlvbXMgPSBmaWxlQ29udGV4dC5nZXRBeGlvbXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKGF4aW9tcywgZmlsZUNvbnRleHRBeGlvbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0QXhpb21zID0gcmVsZWFzZUNvbnRleHQuZ2V0QXhpb21zKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2goYXhpb21zLCByZWxlYXNlQ29udGV4dEF4aW9tcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXhpb21zO1xuICB9XG5cbiAgZ2V0TGVtbWFzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgbGVtbWFzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0TGVtbWFzID0gZmlsZUNvbnRleHQuZ2V0TGVtbWFzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChsZW1tYXMsIGZpbGVDb250ZXh0TGVtbWFzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBsZW1tYXM7XG4gIH1cblxuICBnZXRUaGVvcmVtcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHRoZW9yZW1zID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0VGhlb3JlbXMgPSBmaWxlQ29udGV4dC5nZXRUaGVvcmVtcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2godGhlb3JlbXMsIGZpbGVDb250ZXh0VGhlb3JlbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0VGhlb3JlbXMgPSByZWxlYXNlQ29udGV4dC5nZXRUaGVvcmVtcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKHRoZW9yZW1zLCByZWxlYXNlQ29udGV4dFRoZW9yZW1zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGVvcmVtcztcbiAgfVxuXG4gIGdldFByb2NlZHVyZXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBwcm9jZWR1cmVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0UHJvY2VkdXJlcyA9IGZpbGVDb250ZXh0LmdldFByb2NlZHVyZXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKHByb2NlZHVyZXMsIGZpbGVDb250ZXh0UHJvY2VkdXJlcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRQcm9jZWR1cmVzID0gcmVsZWFzZUNvbnRleHQuZ2V0UHJvY2VkdXJlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKHByb2NlZHVyZXMsIHJlbGVhc2VDb250ZXh0UHJvY2VkdXJlcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlcztcbiAgfVxuXG4gIGdldE1ldGFMZW1tYXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhTGVtbWFzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0TWV0YUxlbW1hcyA9IGZpbGVDb250ZXh0LmdldE1ldGFMZW1tYXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKG1ldGFMZW1tYXMsIGZpbGVDb250ZXh0TWV0YUxlbW1hcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWV0YUxlbW1hcztcbiAgfVxuXG4gIGdldENvbmplY3R1cmVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgY29uamVjdHVyZXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRDb25qZWN0dXJlcyA9IGZpbGVDb250ZXh0LmdldENvbmplY3R1cmVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChjb25qZWN0dXJlcywgZmlsZUNvbnRleHRDb25qZWN0dXJlcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRDb25qZWN0dXJlcyA9IHJlbGVhc2VDb250ZXh0LmdldENvbmplY3R1cmVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2goY29uamVjdHVyZXMsIHJlbGVhc2VDb250ZXh0Q29uamVjdHVyZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmplY3R1cmVzO1xuICB9XG5cbiAgZ2V0Q29tYmluYXRvcnMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBjb21iaW5hdG9ycyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dENvbWJpbmF0b3JzID0gZmlsZUNvbnRleHQuZ2V0Q29tYmluYXRvcnMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKGNvbWJpbmF0b3JzLCBmaWxlQ29udGV4dENvbWJpbmF0b3JzKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dENvbWJpbmF0b3JzID0gcmVsZWFzZUNvbnRleHQuZ2V0Q29tYmluYXRvcnMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChjb21iaW5hdG9ycywgcmVsZWFzZUNvbnRleHRDb21iaW5hdG9ycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tYmluYXRvcnM7XG4gIH1cblxuICBnZXRUeXBlUHJlZml4ZXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCB0eXBlUHJlZml4ZXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRUeXBlUHJlZml4ZXMgPSBmaWxlQ29udGV4dC5nZXRUeXBlUHJlZml4ZXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKHR5cGVQcmVmaXhlcywgZmlsZUNvbnRleHRUeXBlUHJlZml4ZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0VHlwZVByZWZpeGVzID0gcmVsZWFzZUNvbnRleHQuZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2godHlwZVByZWZpeGVzLCByZWxlYXNlQ29udGV4dFR5cGVQcmVmaXhlcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZVByZWZpeGVzO1xuICB9XG5cbiAgZ2V0Q29uc3RydWN0b3JzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0Q29uc3RydWN0b3JzID0gZmlsZUNvbnRleHQuZ2V0Q29uc3RydWN0b3JzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChjb25zdHJ1Y3RvcnMsIGZpbGVDb250ZXh0Q29uc3RydWN0b3JzKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dENvbnN0cnVjdG9ycyA9IHJlbGVhc2VDb250ZXh0LmdldENvbnN0cnVjdG9ycyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKGNvbnN0cnVjdG9ycywgcmVsZWFzZUNvbnRleHRDb25zdHJ1Y3RvcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9ycztcbiAgfVxuXG4gIGdldE1ldGF0aGVvcmVtcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGF0aGVvcmVtcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dE1ldGF0aGVvcmVtcyA9IGZpbGVDb250ZXh0LmdldE1ldGF0aGVvcmVtcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2gobWV0YXRoZW9yZW1zLCBmaWxlQ29udGV4dE1ldGF0aGVvcmVtcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRNZXRhdGhlb3JlbXMgPSByZWxlYXNlQ29udGV4dC5nZXRNZXRhdGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChtZXRhdGhlb3JlbXMsIHJlbGVhc2VDb250ZXh0TWV0YXRoZW9yZW1zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhdGhlb3JlbXM7XG4gIH1cblxuICBnZXREZXBlbmRlbmNpZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGVwZW5kZW5jaWVzKCk7IH1cblxuICBtYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbikgeyByZXR1cm4gdGhpcy5lbnRyaWVzLm1hdGNoU2hvcnRlbmVkVmVyc2lvbihzaG9ydGVuZWRWZXJzaW9uKTsgfVxuXG4gIHRyYWNlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IFRSQUNFX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGRlYnVnKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IERFQlVHX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGluZm8obWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gSU5GT19MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IFdBUk5JTkdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZXJyb3IobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gRVJST1JfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSwgZmlsZVBhdGggPSBudWxsLCBsaW5lSW5kZXggPSBudWxsKSB7XG4gICAgdGhpcy5sb2cud3JpdGUobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpO1xuICB9XG5cbiAgaW5pdGlhbGlzZShyZWxlYXNlQ29udGV4dHMsIEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKSB7XG4gICAgY29uc3QgcmVsZWFzZWQgPSB0aGlzLmlzUmVsZWFzZWQoKSxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IHRoaXMsICAvLy9cbiAgICAgICAgICByZWxlYXNlQ29udGV4dHNUYWlsID0gdGFpbChyZWxlYXNlQ29udGV4dHMpO1xuXG4gICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzID0gcmVsZWFzZUNvbnRleHRzVGFpbDsgLy8vXG5cbiAgICB0aGlzLmNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21SZWxlYXNlQ29udGV4dHMocmVsZWFzZUNvbnRleHRzKTtcblxuICAgIHJlbGVhc2VkID9cbiAgICAgIGZpbGVDb250ZXh0c0Zyb21KU09OKHRoaXMuanNvbiwgdGhpcy5maWxlQ29udGV4dHMsIHJlbGVhc2VDb250ZXh0LCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCkgOlxuICAgICAgICBmaWxlQ29udGV4dHNGcm9tRW50cmllcyh0aGlzLmVudHJpZXMsIHRoaXMuZmlsZUNvbnRleHRzLCByZWxlYXNlQ29udGV4dCwgRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgpO1xuXG4gICAgdGhpcy5pbml0aWFsaXNlZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBicmVhayhmaWxlUGF0aCwgbGluZUluZGV4KSB7XG4gICAgY29uc3QgbGV2ZWwgPSBUUkFDRV9MRVZFTCxcbiAgICAgICAgICBtZXNzYWdlID0gQlJFQUtfTUVTU0FHRTtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSwgZmlsZVBhdGgsIGxpbmVJbmRleCk7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpczsgLy8vXG5cbiAgICBhd2FpdCB0aGlzLmNhbGxiYWNrKGNvbnRleHQsIGZpbGVQYXRoLCBsaW5lSW5kZXgpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5KCkge1xuICAgIGxldCB2ZXJpZmllcyA9IGZhbHNlO1xuXG4gICAgY29uc3QgdHlwZVByZWZpeGVzID0gdGhpcy5nZXRUeXBlUHJlZml4ZXMoKSxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IHRoaXMsIC8vL1xuICAgICAgICAgIHR5cGVQcmVmaXhlc1ZlcmlmeSA9IHZlcmlmeVR5cGVQcmVmaXhlcyh0eXBlUHJlZml4ZXMsIHJlbGVhc2VDb250ZXh0KTtcblxuICAgIGlmICh0eXBlUHJlZml4ZXNWZXJpZnkpIHtcbiAgICAgIGNvbnN0IHZlcmlmaWVkRmlsZUNvbnRleHRzID0gW10sXG4gICAgICAgICAgICBmaWxlQ29udGV4dHNWZXJpZnkgPSBhd2FpdCB2ZXJpZnlGaWxlQ29udGV4dHModGhpcy5maWxlQ29udGV4dHMsIHZlcmlmaWVkRmlsZUNvbnRleHRzKTtcblxuICAgICAgaWYgKGZpbGVDb250ZXh0c1ZlcmlmeSkge1xuICAgICAgICB2ZXJpZmllcyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy52ZXJpZmllcyA9IHZlcmlmaWVzO1xuXG4gICAgICAgIHRoaXMuZmlsZUNvbnRleHRzID0gdmVyaWZpZWRGaWxlQ29udGV4dHM7IC8vL1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2ZXJpZmllcztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBmaWxlQ29udGV4dHNKU09OID0gdGhpcy5maWxlQ29udGV4dHMubWFwKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZUNvbnRleHRKU09OID0gZmlsZUNvbnRleHQudG9KU09OKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWxlQ29udGV4dEpTT047XG4gICAgICAgICAgfSksXG4gICAgICAgICAganNvbiA9IGZpbGVDb250ZXh0c0pTT047ICAvLy9cblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIGZyb21Mb2dOYW1lSlNPTkVudHJpZXNDYWxsYmFja0FuZEN1c3RvbUdyYW1tYXIobG9nLCBuYW1lLCBqc29uLCBlbnRyaWVzLCBjYWxsYmFjaywgY3VzdG9tR3JhbW1hcikge1xuICAgIGNvbnN0IHZlcmlmaWVzID0gZmFsc2UsXG4gICAgICAgICAgaW5pdGlhbGlzZWQgPSBmYWxzZSxcbiAgICAgICAgICBmaWxlQ29udGV4dHMgPSBbXSxcbiAgICAgICAgICBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBudWxsLFxuICAgICAgICAgIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMgPSBudWxsLFxuICAgICAgICAgIHJlbGVhc2VDb250ZXh0ID0gbmV3IFJlbGVhc2VDb250ZXh0KGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIsIHZlcmlmaWVzLCBpbml0aWFsaXNlZCwgZmlsZUNvbnRleHRzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIsIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMpO1xuXG4gICAgcmV0dXJuIHJlbGVhc2VDb250ZXh0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgYXMgTm9uVGVybWluYWxOb2RlQmFzZSB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGVCYXNlIHtcbiAgc29tZVRlcm1pbmFsTm9kZShjYWxsYmFjaywgdG9rZW5UeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc29tZUNoaWxkTm9kZSgoY2hpbGROb2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGROb2RlVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgdGVybWluYWxOb2RlVHlwZSA9IHRlcm1pbmFsTm9kZS5nZXRUeXBlKCk7XG5cbiAgICAgICAgaWYgKHRlcm1pbmFsTm9kZVR5cGUgPT09IHRva2VuVHlwZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0ZXJtaW5hbE5vZGUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Tm9kZUJ5UnVsZU5hbWUoLi4ucnVsZU5hbWVzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAocnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkgfHwgbnVsbDtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZ2V0Tm9kZXNCeVJ1bGVOYW1lKC4uLnJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5maWx0ZXJDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZ2V0TGFzdE5vZGVCeVJ1bGVOYW1lKC4uLnJ1bGVOYW1lcykge1xuICAgIGxldCBsYXN0Tm9kZSA9IG51bGw7XG5cbiAgICB0aGlzLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICBsYXN0Tm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxhc3ROb2RlO1xuICB9XG5cbiAgZ2V0Rmlyc3ROb2RlQnlSdWxlTmFtZSguLi5ydWxlTmFtZXMpIHtcbiAgICBsZXQgZmlyc3ROb2RlID0gbnVsbDtcblxuICAgIHRoaXMuZm9yd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgZmlyc3ROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlyc3ROb2RlO1xuICB9XG5cbiAgZ2V0U2luZ3VsYXJOb2RlQnlSdWxlTmFtZSguLi5ydWxlTmFtZXMpIHtcbiAgICBsZXQgc2luZ3VsYXJOb2RlID0gbnVsbDtcblxuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5maWx0ZXJDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKG5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBmaXJzdE5vZGUgPSBmaXJzdChub2Rlcyk7XG5cbiAgICAgIHNpbmd1bGFyTm9kZSA9IGZpcnN0Tm9kZTsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbmd1bGFyTm9kZTtcbiAgfVxuXG4gIGdldERlc2NlbmRhbnROb2Rlc0J5UnVsZU5hbWUoLi4ucnVsZU5hbWVzKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmZpbHRlckRlc2NlbmRhbnROb2RlKChkZXNjZW5kYW50Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgZGVzY2VuZGFudE5vZGVOb25UZXJtaW5hbE5vZGUgPSBkZXNjZW5kYW50Tm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoZGVzY2VuZGFudE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZGVzY2VuZGFudE5vZGUsIC8vL1xuICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAocnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlQmFzZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1xdWVyeVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVF1ZXJ5KGV4cHJlc3Npb25TdHJpbmcpIHtcbiAgY29uc3QgcXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGNvbnN0IG5vZGVzID0gcXVlcnkuZXhlY3V0ZShub2RlKTtcblxuICAgIG5vZGUgPSBub2Rlcy5zaGlmdCgpIHx8IG51bGw7IC8vL1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc1F1ZXJ5KGV4cHJlc3Npb25TdHJpbmcpIHtcbiAgY29uc3QgcXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKTtcblxuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGNvbnN0IG5vZGVzID0gcXVlcnkuZXhlY3V0ZShub2RlKTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBub2RlUXVlcnksXG4gIG5vZGVzUXVlcnksXG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBub2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5cbmNvbnN0IHsgbWF0Y2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgY29uc3Qgbm9uVGVybWluYWxOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvKlwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1pbmFsTm9kZU1hcEZyb21Ob2Rlcyhub2Rlcykge1xuICBjb25zdCB0ZXJtaW5hbE5vZGVNYXAgPSB7fTtcblxuICBub2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZTsgIC8vXG5cbiAgICAgIHRlcm1pbmFsTm9kZU1hcFtpbmRleF0gPSB0ZXJtaW5hbE5vZGU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGVybWluYWxOb2RlTWFwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJlVGVybWluYWxOb2RlTWFwc0VxdWFsKGdlbmVyYWxUZXJtaW5hbE5vZGVNYXAsIHNwZWNpZmljVGVybWluYWxOb2RlTWFwKSB7XG4gIGxldCB0ZXJtaW5hbE5vZGVNYXBzRXF1YWwgPSBmYWxzZTtcblxuICBjb25zdCBnZW5lcmFsSW5kZXhlcyA9IE9iamVjdC5rZXlzKGdlbmVyYWxUZXJtaW5hbE5vZGVNYXApLCAvLy9cbiAgICAgICAgc3BlY2lmaWNJbmRleGVzID0gT2JqZWN0LmtleXMoc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXApLCAvLy9cbiAgICAgICAgdGVybWluYWxOb2RlTWFwS2V5c01hdGNoID0gbWF0Y2goZ2VuZXJhbEluZGV4ZXMsIHNwZWNpZmljSW5kZXhlcywgKGdlbmVyYWxJbmRleCwgc3BlY2lmaWNJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChnZW5lcmFsSW5kZXggPT09IHNwZWNpZmljSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgaWYgKHRlcm1pbmFsTm9kZU1hcEtleXNNYXRjaCkge1xuICAgIGNvbnN0IGdlbmVyYWxUZXJtaW5hbE5vZGVzID0gT2JqZWN0LnZhbHVlcyhnZW5lcmFsVGVybWluYWxOb2RlTWFwKSwgLy8vXG4gICAgICAgICAgc3BlY2lmaWNUZXJtaW5hbE5vZGVzID0gT2JqZWN0LnZhbHVlcyhzcGVjaWZpY1Rlcm1pbmFsTm9kZU1hcCksIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZU1hcFZhbHVlc01hdGNoID0gbWF0Y2goZ2VuZXJhbFRlcm1pbmFsTm9kZXMsIHNwZWNpZmljVGVybWluYWxOb2RlcywgKGdlbmVyYWxUZXJtaW5hbE5vZGUsIHNwZWNpZmljVGVybWluYWxOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmFsVGVybWluYWxOb2RlTWF0Y2hlc1NwZWNpZmljVGVybWluYWxOb2RlID0gZ2VuZXJhbFRlcm1pbmFsTm9kZS5tYXRjaChzcGVjaWZpY1Rlcm1pbmFsTm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChnZW5lcmFsVGVybWluYWxOb2RlTWF0Y2hlc1NwZWNpZmljVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gdGVybWluYWxOb2RlTWFwVmFsdWVzTWF0Y2g7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHRlcm1pbmFsTm9kZU1hcHNFcXVhbDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnksIHRlcm1pbmFsTm9kZU1hcEZyb21Ob2RlcywgYXJlVGVybWluYWxOb2RlTWFwc0VxdWFsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXNzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFppcFBhc3Mge1xuICBydW4oZ2VuZXJhbE5vZGUsIHNwZWNpZmljTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gdGhpcy52aXNpdE5vZGUoZ2VuZXJhbE5vZGUsIHNwZWNpZmljTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGRlc2NlbmQoZ2VuZXJhbENoaWxkTm9kZXMsIHNwZWNpZmljQ2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlc2NlbmRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgZ2VuZXJhbENoaWxkTm9kZXNMZW5ndGggPSBnZW5lcmFsQ2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgc3BlY2lmaWNDaGlsZE5vZGVzTGVuZ3RoID0gc3BlY2lmaWNDaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChnZW5lcmFsQ2hpbGROb2Rlc0xlbmd0aCA9PT0gc3BlY2lmaWNDaGlsZE5vZGVzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBzcGVjaWZpY1Rlcm1pbmFsTm9kZU1hcCA9IHRlcm1pbmFsTm9kZU1hcEZyb21Ob2RlcyhzcGVjaWZpY0NoaWxkTm9kZXMpLFxuICAgICAgICAgICAgZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCA9IHRlcm1pbmFsTm9kZU1hcEZyb21Ob2RlcyhnZW5lcmFsQ2hpbGROb2RlcyksXG4gICAgICAgICAgICB0ZXJtaW5hbE5vZGVNYXBzRXF1YWwgPSBhcmVUZXJtaW5hbE5vZGVNYXBzRXF1YWwoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCwgc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXApO1xuXG4gICAgICBpZiAodGVybWluYWxOb2RlTWFwc0VxdWFsKSB7XG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBnZW5lcmFsQ2hpbGROb2Rlcy5ldmVyeSgoZ2VuZXJhbENoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBzcGVjaWZpY0NoaWxkTm9kZSA9IHNwZWNpZmljQ2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgc3BlY2lmaWNOb2RlID0gc3BlY2lmaWNDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgIGdlbmVyYWxOb2RlID0gZ2VuZXJhbENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICAgIGRlc2NlbmRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY2VuZGVkO1xuICB9XG5cbiAgdmlzaXROb2RlKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBnZW5lcmFsTm9kZVRlcm1pbmFsTm9kZSA9IGdlbmVyYWxOb2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgc3BlY2lmaWNOb2RlVGVybWluYWxOb2RlID0gc3BlY2lmaWNOb2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgZ2VuZXJhbE5vZGVOb25UZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHNwZWNpZmljTm9kZU5vblRlcm1pbmFsTm9kZSA9IHNwZWNpZmljTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKGdlbmVyYWxOb2RlVGVybWluYWxOb2RlICYmIHNwZWNpZmljTm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgZ2VuZXJhbFRlcm1pbmFsTm9kZSA9IGdlbmVyYWxOb2RlLCAgLy8vXG4gICAgICAgICAgICBzcGVjaWZpY1Rlcm1pbmFsTm9kZSA9IHNwZWNpZmljTm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdFRlcm1pbmFsTm9kZShnZW5lcmFsVGVybWluYWxOb2RlLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKGdlbmVyYWxOb2RlTm9uVGVybWluYWxOb2RlICYmIHNwZWNpZmljTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgZ2VuZXJhbE5vblRlcm1pbmFsTm9kZSA9IGdlbmVyYWxOb2RlLCAgLy8vXG4gICAgICAgICAgICBzcGVjaWZpY05vblRlcm1pbmFsTm9kZSA9IHNwZWNpZmljTm9kZTsgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9uVGVybWluYWxOb2RlKGdlbmVyYWxOb25UZXJtaW5hbE5vZGUsIHNwZWNpZmljTm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXRUZXJtaW5hbE5vZGUoZ2VuZXJhbFRlcm1pbmFsTm9kZSwgc3BlY2lmaWNUZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgeyAvLy9cbiAgICBsZXQgdmlzaXRlZDtcblxuICAgIHZpc2l0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICB2aXNpdE5vblRlcm1pbmFsTm9kZShnZW5lcmFsTm9uVGVybWluYWxOb2RlLCBzcGVjaWZpY05vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIGxldCB7IG1hcHMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBtYXBzID0gWyAvLy9cbiAgICAgIC4uLm1hcHMsXG4gICAgICB7XG4gICAgICAgIGdlbmVyYWxOb2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBzcGVjaWZpY05vZGVRdWVyeTogbm9uVGVybWluYWxOb2RlUXVlcnksXG4gICAgICAgIHJ1bjogKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgPT4ge1xuICAgICAgICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBnZW5lcmFsTm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBnZW5lcmFsTm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksIC8vL1xuICAgICAgICAgICAgICAgIHNwZWNpZmljTm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBzcGVjaWZpY05vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpOyAvLy9cblxuICAgICAgICAgIGlmIChnZW5lcmFsTm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPT09IHNwZWNpZmljTm9uVGVybWluYWxOb2RlUnVsZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYWxOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gZ2VuZXJhbE5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgICAgICAgICBzcGVjaWZpY05vblRlcm1pbmFsTm9kZUNoaWxkTm9kZXMgPSBzcGVjaWZpY05vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgICAgICAgICBnZW5lcmFsQ2hpbGROb2RlcyA9IGdlbmVyYWxOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzLCAvLy9cbiAgICAgICAgICAgICAgICAgIHNwZWNpZmljQ2hpbGROb2RlcyA9IHNwZWNpZmljTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgICAgICBkZXNjZW5kZWQgPSB0aGlzLmRlc2NlbmQoZ2VuZXJhbENoaWxkTm9kZXMsIHNwZWNpZmljQ2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKGRlc2NlbmRlZCkge1xuICAgICAgICAgICAgICB2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlzaXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cblxuICAgIG1hcHMuc29tZSgobWFwKSA9PiB7XG4gICAgICBjb25zdCB7IGdlbmVyYWxOb2RlUXVlcnksIHNwZWNpZmljTm9kZVF1ZXJ5LCBydW4gfSA9IG1hcDtcblxuICAgICAgY29uc3QgZ2VuZXJhbE5vZGUgPSBnZW5lcmFsTm9kZVF1ZXJ5KGdlbmVyYWxOb25UZXJtaW5hbE5vZGUpLCAgLy8vXG4gICAgICAgICAgICBzcGVjaWZpY05vZGUgPSBzcGVjaWZpY05vZGVRdWVyeShzcGVjaWZpY05vblRlcm1pbmFsTm9kZSk7ICAvLy9cblxuICAgICAgaWYgKChnZW5lcmFsTm9kZSAhPT0gbnVsbCkgJiYgKHNwZWNpZmljTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyAgPSBydW4oZ2VuZXJhbE5vZGUsIHNwZWNpZmljTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzczsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Bhc3NcIjtcbmltcG9ydCB7IGFzeW5jU29tZSwgYXN5bmNFdmVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNocm9ub3VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFzeW5jUGFzcyB7XG4gIGFzeW5jIHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgc3VjY2VzcztcblxuICAgIGNvbnN0IHZpc2l0ZWQgPSBhd2FpdCB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgc3VjY2VzcyA9IHZpc2l0ZWQ7ICAvLy9cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG5cbiAgYXN5bmMgZGVzY2VuZChjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgZGVzY2VuZGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gYXdhaXQgYXN5bmNFdmVyeShjaGlsZE5vZGVzLCBhc3luYyAoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgIHZpc2l0ZWQgPSBhd2FpdCB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh2aXNpdGVkKSB7XG4gICAgICBkZXNjZW5kZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjZW5kZWQ7XG4gIH1cblxuICBhc3luYyB2aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IGF3YWl0IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUodGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlOyAgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSBhd2FpdCB0aGlzLnZpc2l0Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIGFzeW5jIHZpc2l0VGVybWluYWxOb2RlKHRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgdmlzaXRlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIGFzeW5jIHZpc2l0Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIGxldCB7IG1hcHMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBtYXBzID0gWyAvLy9cbiAgICAgIC4uLm1hcHMsXG4gICAgICB7XG4gICAgICAgIG5vZGVRdWVyeTogbm9uVGVybWluYWxOb2RlUXVlcnksXG4gICAgICAgIHJ1bjogYXN5bmMgKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgPT4ge1xuICAgICAgICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSwgLy8vXG4gICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gYXdhaXQgdGhpcy5kZXNjZW5kKGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAoZGVzY2VuZGVkKSB7XG4gICAgICAgICAgICB2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlzaXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cblxuICAgIGF3YWl0IGFzeW5jU29tZShtYXBzLCBhc3luYyAobWFwKSA9PiB7XG4gICAgICBjb25zdCB7IG5vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlUXVlcnkobm9uVGVybWluYWxOb2RlKTtcblxuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgIHZpc2l0ZWQgPSBzdWNjZXNzOyAgLy8vXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBub25UZXJtaW5hbE5vZGVRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVQYXNzIHtcbiAgcnVuKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBzdWNjZXNzO1xuXG4gICAgY29uc3QgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICBzdWNjZXNzID0gdmlzaXRlZDsgIC8vL1xuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cblxuICBkZXNjZW5kKGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBkZXNjZW5kZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IHZpc2l0ZWQgPSBjaGlsZE5vZGVzLmV2ZXJ5KChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh2aXNpdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgIGRlc2NlbmRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NlbmRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZDtcblxuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdFRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXRUZXJtaW5hbE5vZGUodGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBjb25zdCB2aXNpdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgbGV0IHsgbWFwcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgIG1hcHMgPSBbIC8vL1xuICAgICAgLi4ubWFwcyxcbiAgICAgIHtcbiAgICAgICAgbm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgcnVuOiAobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSA9PiB7XG4gICAgICAgICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLCAvLy9cbiAgICAgICAgICAgICAgICBkZXNjZW5kZWQgPSB0aGlzLmRlc2NlbmQoY2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICAgIGlmIChkZXNjZW5kZWQpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2aXNpdGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuXG4gICAgbWFwcy5zb21lKChtYXApID0+IHtcbiAgICAgIGNvbnN0IHsgbm9kZVF1ZXJ5LCBydW4gfSA9IG1hcDtcblxuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVRdWVyeShub25UZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gcnVuKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgdmlzaXRlZCA9IHN1Y2Nlc3M7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBub25UZXJtaW5hbE5vZGVRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3J3YXJkUGFzcyB7XG4gIHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgc3VjY2VzcztcblxuICAgIGNvbnN0IHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgc3VjY2VzcyA9IHZpc2l0ZWQ7ICAvLy9cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG5cbiAgZGVzY2VuZChpbmRleCwgY2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlc2NlbmRlZEZvcndhcmQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGRlc2NlbmRGb3J3YXJkID0gcmVtYWluaW5nQXJndW1lbnRzLnBvcCgpLCAvLy9cbiAgICAgICAgICBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoaW5kZXggPT09IGNoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgIGRlc2NlbmRlZEZvcndhcmQgPSBkZXNjZW5kRm9yd2FyZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2luZGV4XSxcbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cywgKCkgPT4ge1xuICAgICAgICAgICAgICByZW1haW5pbmdBcmd1bWVudHMucHVzaChkZXNjZW5kRm9yd2FyZCk7XG5cbiAgICAgICAgICAgICAgY29uc3QgYWhlYWRJbmRleCA9IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGVkRm9yd2FyZCA9IHRoaXMuZGVzY2VuZChhaGVhZEluZGV4LCBjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kZWRGb3J3YXJkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgIGlmICh2aXNpdGVkKSB7XG4gICAgICAgIGRlc2NlbmRlZEZvcndhcmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXNjZW5kZWRGb3J3YXJkO1xuICB9XG5cbiAgdmlzaXROb2RlKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlOyAgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0VGVybWluYWxOb2RlKHRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICB2aXNpdFRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBkZXNjZW5kRm9yd2FyZCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKSwgLy8vXG4gICAgICAgICAgZGVzY2VuZGVkRm9yd2FyZCA9IGRlc2NlbmRGb3J3YXJkKCk7XG5cbiAgICBpZiAoZGVzY2VuZGVkRm9yd2FyZCkge1xuICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVtYWluaW5nQXJndW1lbnRzLnB1c2goZGVzY2VuZEZvcndhcmQpO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICB2aXNpdE5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBub2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IChub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLCAvLy9cbiAgICAgICAgICAgICAgICBkZXNjZW5kZWQgPSB0aGlzLmRlc2NlbmQoaW5kZXgsIGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAoZGVzY2VuZGVkKSB7XG4gICAgICAgICAgICB2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlzaXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cblxuICAgIG1hcHMuc29tZSgobWFwKSA9PiB7XG4gICAgICBjb25zdCB7IG5vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlUXVlcnkobm9uVGVybWluYWxOb2RlKTtcblxuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgIHZpc2l0ZWQgPSBzdWNjZXNzO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnksIHRlcm1pbmFsTm9kZU1hcEZyb21Ob2RlcywgYXJlVGVybWluYWxOb2RlTWFwc0VxdWFsIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXNzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVxdWl2YWxlbmNlUGFzcyB7XG4gIHJ1bihsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgc3VjY2VzcztcblxuICAgIGNvbnN0IHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgc3VjY2VzcyA9IHZpc2l0ZWQ7ICAvLy9cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG5cbiAgZGVzY2VuZChsZWZ0Q2hpbGROb2RlcywgcmlnaHRDaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgZGVzY2VuZGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBsZWZ0Q2hpbGROb2Rlc0xlbmd0aCA9IGxlZnRDaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgIHJpZ2h0Q2hpbGROb2Rlc0xlbmd0aCA9IHJpZ2h0Q2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAobGVmdENoaWxkTm9kZXNMZW5ndGggPT09IHJpZ2h0Q2hpbGROb2Rlc0xlbmd0aCkge1xuICAgICAgY29uc3QgbGVmdFRlcm1pbmFsTm9kZU1hcCA9IHRlcm1pbmFsTm9kZU1hcEZyb21Ob2RlcyhsZWZ0Q2hpbGROb2RlcyksXG4gICAgICAgICAgICByaWdodFRlcm1pbmFsTm9kZU1hcCA9IHRlcm1pbmFsTm9kZU1hcEZyb21Ob2RlcyhyaWdodENoaWxkTm9kZXMpLFxuICAgICAgICAgICAgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gYXJlVGVybWluYWxOb2RlTWFwc0VxdWFsKGxlZnRUZXJtaW5hbE5vZGVNYXAsIHJpZ2h0VGVybWluYWxOb2RlTWFwKTtcblxuICAgICAgaWYgKHRlcm1pbmFsTm9kZU1hcHNFcXVhbCkge1xuICAgICAgICBkZXNjZW5kZWQgPSBsZWZ0Q2hpbGROb2Rlcy5ldmVyeSgobGVmdENoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCByaWdodENoaWxkTm9kZSA9IHJpZ2h0Q2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgbGVmdE5vZGUgPSBsZWZ0Q2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICByaWdodE5vZGUgPSByaWdodENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKGxlZnROb2RlLCByaWdodE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY2VuZGVkO1xuICB9XG5cbiAgdmlzaXROb2RlKGxlZnROb2RlLCByaWdodE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBsZWZ0Tm9kZVRlcm1pbmFsTm9kZSA9IGxlZnROb2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgcmlnaHROb2RlVGVybWluYWxOb2RlID0gcmlnaHROb2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgbGVmdE5vZGVOb25UZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZS5pc05vblRlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHJpZ2h0Tm9kZU5vblRlcm1pbmFsTm9kZSA9IHJpZ2h0Tm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKGxlZnROb2RlVGVybWluYWxOb2RlICYmIHJpZ2h0Tm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgbGVmdFRlcm1pbmFsTm9kZSA9IGxlZnROb2RlLCAgLy8vXG4gICAgICAgICAgICByaWdodFRlcm1pbmFsTm9kZSA9IHJpZ2h0Tm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdFRlcm1pbmFsTm9kZShsZWZ0VGVybWluYWxOb2RlLCByaWdodFRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKGxlZnROb2RlTm9uVGVybWluYWxOb2RlICYmIHJpZ2h0Tm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgbGVmdE5vblRlcm1pbmFsTm9kZSA9IGxlZnROb2RlLCAgLy8vXG4gICAgICAgICAgICByaWdodE5vblRlcm1pbmFsTm9kZSA9IHJpZ2h0Tm9kZTsgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9uVGVybWluYWxOb2RlKGxlZnROb25UZXJtaW5hbE5vZGUsIHJpZ2h0Tm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXRUZXJtaW5hbE5vZGUobGVmdFRlcm1pbmFsTm9kZSwgcmlnaHRUZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgeyAvLy9cbiAgICBsZXQgdmlzaXRlZDtcblxuICAgIHZpc2l0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICB2aXNpdE5vblRlcm1pbmFsTm9kZShsZWZ0Tm9uVGVybWluYWxOb2RlLCByaWdodE5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIGxldCB7IG1hcHMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBtYXBzID0gWyAvLy9cbiAgICAgIC4uLm1hcHMsXG4gICAgICB7XG4gICAgICAgIGxlZnROb2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICByaWdodE5vZGVRdWVyeTogbm9uVGVybWluYWxOb2RlUXVlcnksXG4gICAgICAgIHJ1bjogKGxlZnROb2RlLCByaWdodE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgPT4ge1xuICAgICAgICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBsZWZ0Tm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBsZWZ0Tm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksIC8vL1xuICAgICAgICAgICAgICAgIHJpZ2h0Tm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSByaWdodE5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpOyAvLy9cblxuICAgICAgICAgIGlmIChsZWZ0Tm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPT09IHJpZ2h0Tm9uVGVybWluYWxOb2RlUnVsZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnROb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gbGVmdE5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgICAgICAgICByaWdodE5vblRlcm1pbmFsTm9kZUNoaWxkTm9kZXMgPSByaWdodE5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgICAgICAgICBsZWZ0Q2hpbGROb2RlcyA9IGxlZnROb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzLCAvLy9cbiAgICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGROb2RlcyA9IHJpZ2h0Tm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgICAgICBkZXNjZW5kZWQgPSB0aGlzLmRlc2NlbmQobGVmdENoaWxkTm9kZXMsIHJpZ2h0Q2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKGRlc2NlbmRlZCkge1xuICAgICAgICAgICAgICB2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlzaXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cblxuICAgIG1hcHMuc29tZSgobWFwKSA9PiB7XG4gICAgICBjb25zdCB7IGxlZnROb2RlUXVlcnksIHJpZ2h0Tm9kZVF1ZXJ5LCBydW4gfSA9IG1hcDtcblxuICAgICAgY29uc3QgbGVmdE5vZGUgPSBsZWZ0Tm9kZVF1ZXJ5KGxlZnROb25UZXJtaW5hbE5vZGUpLCAgLy8vXG4gICAgICAgICAgICByaWdodE5vZGUgPSByaWdodE5vZGVRdWVyeShyaWdodE5vblRlcm1pbmFsTm9kZSk7ICAvLy9cblxuICAgICAgaWYgKChsZWZ0Tm9kZSAhPT0gbnVsbCkgJiYgKHJpZ2h0Tm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHJ1bihsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgIHZpc2l0ZWQgPSBzdWNjZXNzOyAgLy8vXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhc3luY0V2ZXJ5ICB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNocm9ub3VzXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0V2ZXJ5RGVwZW5kZW5jeShkZXBlbmRlbmNpZXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5ID0gZGVwZW5kZW5jaWVzLmdldEFycmF5KCk7XG5cbiAgcmV0dXJuIGF3YWl0IGFzeW5jRXZlcnkoYXJyYXksIGNhbGxiYWNrKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IGFzeW5jRXZlcnlEZXBlbmRlbmN5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9kZXBlbmRlbmN5XCI7XG5cbmNvbnN0IHsgbGFzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXNlUmVsZWFzZUNvbnRleHQoZGVwZW5kZW5jeSwgY29udGV4dCkge1xuICBjb25zdCB7IGxvZywgcmVsZWFzZUNvbnRleHRNYXAgfSA9IGNvbnRleHQsXG4gICAgICAgIGRlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgIHJlbGVhc2VOYW1lID0gZGVwZW5kZW5jeU5hbWUsIC8vL1xuICAgICAgICByZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0TWFwW3JlbGVhc2VOYW1lXSB8fCBudWxsO1xuXG4gIGlmIChyZWxlYXNlQ29udGV4dCA9PT0gbnVsbCkge1xuICAgIGxvZy53YXJuaW5nKGBVbmFibGUgdG8gaW5pdGlhbGlzZSB0aGUgJyR7ZGVwZW5kZW5jeU5hbWV9JyBjb250ZXh0IGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuYCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVsZWFzZUNvbnRleHRJbml0aWFsaXNlZCA9IHJlbGVhc2VDb250ZXh0LmlzSW5pdGlhbGlzZWQoKTtcblxuICAgIGlmICghcmVsZWFzZUNvbnRleHRJbml0aWFsaXNlZCkge1xuICAgICAgaW5pdGlhbGlzZURlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMoZGVwZW5kZW5jeSwgcmVsZWFzZUNvbnRleHQsIGNvbnRleHQpO1xuXG4gICAgICBjb25zdCByZWxlYXNlQ29udGV4dHMgPSByZXRyaWV2ZVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dCwgcmVsZWFzZUNvbnRleHRNYXApO1xuXG4gICAgICBsb2cuaW5mbyhgSW5pdGlhbGlzaW5nIHRoZSAnJHtkZXBlbmRlbmN5TmFtZX0nIGNvbnRleHQuLi5gKTtcblxuICAgICAgY29uc3QgeyBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCB9ID0gY29udGV4dDtcblxuICAgICAgcmVsZWFzZUNvbnRleHQuaW5pdGlhbGlzZShyZWxlYXNlQ29udGV4dHMsIEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKTtcblxuICAgICAgbG9nLmRlYnVnKGAuLi5pbml0aWFsaXNlZCB0aGUgJyR7ZGVwZW5kZW5jeU5hbWV9JyBjb250ZXh0LmApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVsZWFzZUNvbnRleHQoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpIHtcbiAgbGV0IHJlbGVhc2VDb250ZXh0Q3JlYXRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHsgbG9nLCByZWxlYXNlQ29udGV4dE1hcCB9ID0gY29udGV4dCxcbiAgICAgICAgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgcmVsZWFzZU5hbWUgPSBkZXBlbmRlbmN5TmFtZSwgLy8vXG4gICAgICAgIHJlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHRNYXBbcmVsZWFzZU5hbWVdIHx8IG51bGw7XG5cbiAgaWYgKHJlbGVhc2VDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5ID0gY2hlY2tSZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVuY3ksIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgVGhlICcke3JlbGVhc2VOYW1lfScgY29udGV4dCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuYCk7XG5cbiAgICAgIHJlbGVhc2VDb250ZXh0Q3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRlcGVuZGVuY3lTdHJpbmcgPSBkZXBlbmRlbmN5LmFzU3RyaW5nKCksXG4gICAgICAgICAgZGVwZW5kZW50TmFtZXNMZW5ndGggPSBkZXBlbmRlbnROYW1lcy5sZW5ndGg7XG5cbiAgICBpZiAoZGVwZW5kZW50TmFtZXNMZW5ndGggPT09IDApIHtcbiAgICAgIGxvZy5pbmZvKGBDcmVhdGluZyB0aGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0Li4uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3REZXBlbmRlbnROYW1lID0gbGFzdChkZXBlbmRlbnROYW1lcyksXG4gICAgICAgICAgICBkZXBlbmRlbnROYW1lID0gbGFzdERlcGVuZGVudE5hbWU7ICAvLy9cblxuICAgICAgbG9nLmluZm8oYENyZWF0aW5nIHRoZSAnJHtyZWxlYXNlTmFtZX0nIGNvbnRleHQgZ2l2ZW4gdGhlICcke2RlcGVuZGVudE5hbWV9JyBkZXBlbmRhbnQncyAnJHtkZXBlbmRlbmN5U3RyaW5nfScgZGVwZW5kZW5jeS4uLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVsZWFzZUNvbnRleHRGcm9tRGVwZW5kZW5jeSB9ID0gY29udGV4dCxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IGF3YWl0IHJlbGVhc2VDb250ZXh0RnJvbURlcGVuZGVuY3koZGVwZW5kZW5jeSwgY29udGV4dCk7XG5cbiAgICBpZiAocmVsZWFzZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeSA9IGNoZWNrUmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5KHJlbGVhc2VDb250ZXh0LCBkZXBlbmRlbmN5LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCk7XG5cbiAgICAgIGlmIChyZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kpIHtcbiAgICAgICAgcmVsZWFzZUNvbnRleHRNYXBbcmVsZWFzZU5hbWVdID0gcmVsZWFzZUNvbnRleHQ7XG5cbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c0NyZWF0ZWQgPSBhd2FpdCBjcmVhdGVEZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzKGRlcGVuZGVuY3ksIHJlbGVhc2VDb250ZXh0LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNDcmVhdGVkKSB7XG4gICAgICAgICAgcmVsZWFzZUNvbnRleHRDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgcmVsZWFzZU5hbWUgPSBkZXBlbmRlbmN5TmFtZTsgLy8vXG5cbiAgICAgIGxvZy53YXJuaW5nKGBUaGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0IGNvdWxkIG5vdCBiZSBjcmVhdGVkLiBQZXJoYXBzIHRoZSAnbWV0YS5qc29uJyBmaWxlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC4gT3IgdGhlcmUgY291bGQgYmUgYSBkZXBlbmRlbmN5IG1pc21hdGNoLmApO1xuICAgIH1cblxuICAgIHJlbGVhc2VDb250ZXh0Q3JlYXRlZCA/XG4gICAgICBsb2cuZGVidWcoYC4uLmNyZWF0ZWQgdGhlICcke3JlbGVhc2VOYW1lfScgY29udGV4dC5gKSA6XG4gICAgICAgIGxvZy53YXJuaW5nKGAuLi51bmFibGUgdG8gY3JlYXRlIHRoZSAnJHtyZWxlYXNlTmFtZX0nIGNvbnRleHQuYCk7XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZUNvbnRleHRDcmVhdGVkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UmVsZWFzZUNvbnRleHQocmVsZWFzZU5hbWUsIGRlcGVuZGVudE5hbWUsIGRlcGVuZGVudFJlbGVhc2VkLCByZWxlYXNlQ29udGV4dE1hcCkge1xuICBsZXQgcmVsZWFzZUNvbnRleHRWZXJpZmllcyA9IGZhbHNlO1xuXG4gIGNvbnN0IHJlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHRNYXBbcmVsZWFzZU5hbWVdO1xuXG4gIGlmIChyZWxlYXNlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHJlbGVhc2VkID0gcmVsZWFzZUNvbnRleHQuaXNSZWxlYXNlZCgpO1xuXG4gICAgaWYgKHJlbGVhc2VkKSB7XG4gICAgICByZWxlYXNlQ29udGV4dFZlcmlmaWVzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlcGVuZGVudFJlbGVhc2VkKSB7XG4gICAgICAgIHJlbGVhc2VDb250ZXh0Lndhcm5pbmcoYFRoZSAnJHtyZWxlYXNlTmFtZX0nIHByb2plY3QgY2Fubm90IGJlIHZlcmlmaWVzIGJlY2F1c2UgaXRzICcke2RlcGVuZGVudE5hbWV9JyBkZXBlbmRlbnQgaXMgYSBwYWNrYWdlLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW50TmFtZSA9IHJlbGVhc2VOYW1lLCAgLy8vXG4gICAgICAgICAgICAgIGRlcGVuZGVudFJlbGVhc2VkID0gcmVsZWFzZWQsIC8vL1xuICAgICAgICAgICAgICBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzVmVyaWZ5ID0gYXdhaXQgdmVyaWZ5RGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dCwgZGVwZW5kZW50TmFtZSwgZGVwZW5kZW50UmVsZWFzZWQsIHJlbGVhc2VDb250ZXh0TWFwKTtcblxuICAgICAgICBpZiAoZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c1ZlcmlmeSkge1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0VmVyaWZpZWQgPSByZWxlYXNlQ29udGV4dC5oYXNWZXJpZmllZCgpO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VDb250ZXh0VmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0VmVyaWZpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWxlYXNlQ29udGV4dC5pbmZvKGBWZXJpZnlpbmcgdGhlICcke3JlbGVhc2VOYW1lfScgcHJvamVjdC4uLmApO1xuXG4gICAgICAgICAgICBjb25zdCB2ZXJpZmllcyA9IGF3YWl0IHJlbGVhc2VDb250ZXh0LnZlcmlmeSgpO1xuXG4gICAgICAgICAgICBpZiAodmVyaWZpZXMpIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHQuaW5mbyhgLi4udmVyaWZpZWQgdGhlICcke3JlbGVhc2VOYW1lfScgcHJvamVjdC5gKTtcblxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFZlcmlmaWVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZUNvbnRleHRWZXJpZmllcztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBjcmVhdGVSZWxlYXNlQ29udGV4dCxcbiAgdmVyaWZ5UmVsZWFzZUNvbnRleHQsXG4gIGluaXRpYWxpc2VSZWxlYXNlQ29udGV4dFxufTtcblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhkZXBlbmRlbmN5LCByZWxlYXNlQ29udGV4dCwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpIHtcbiAgbGV0IGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNDcmVhdGVkO1xuXG4gIGNvbnN0IGRlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IHJlbGVhc2VDb250ZXh0LmdldERlcGVuZGVuY2llcygpO1xuXG4gIGRlcGVuZGVudE5hbWVzID0gWyAuLi5kZXBlbmRlbnROYW1lcywgZGVwZW5kZW5jeU5hbWUgXTsgIC8vL1xuXG4gIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHNDcmVhdGVkID0gYXdhaXQgYXN5bmNFdmVyeURlcGVuZGVuY3koZGVwZW5kZW5jaWVzLCBhc3luYyAoZGVwZW5kZW5jeSkgPT4ge1xuICAgIGNvbnN0IGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHMgPSBjaGVja0N5Y2xpY0RlcGVuZGVuY3lFeGlzdHMoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjeWNsaWNEZXBlbmRlbmN5RXhpc3RzKSB7XG4gICAgICBjb25zdCByZWxlYXNlQ29udGV4dENyZWF0ZWQgPSBhd2FpdCBjcmVhdGVSZWxlYXNlQ29udGV4dChkZXBlbmRlbmN5LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCk7XG5cbiAgICAgIGlmIChyZWxlYXNlQ29udGV4dENyZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c0NyZWF0ZWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeURlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVudE5hbWUsIGRlcGVuZGVudFJlbGVhc2VkLCByZWxlYXNlQ29udGV4dE1hcCkge1xuICBjb25zdCBkZXBlbmRlbmNpZXMgPSByZWxlYXNlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoKSxcbiAgICAgICAgZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c1ZlcmlmeSA9IGF3YWl0IGFzeW5jRXZlcnlEZXBlbmRlbmN5KGRlcGVuZGVuY2llcywgYXN5bmMgKGRlcGVuZGVuY3kpID0+IHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgICAgICAgICAgcmVsZWFzZU5hbWUgPSBuYW1lLCAvLy9cbiAgICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFZlcmlmaWVzID0gYXdhaXQgdmVyaWZ5UmVsZWFzZUNvbnRleHQocmVsZWFzZU5hbWUsIGRlcGVuZGVudE5hbWUsIGRlcGVuZGVudFJlbGVhc2VkLCByZWxlYXNlQ29udGV4dE1hcCk7XG5cbiAgICAgICAgICBpZiAocmVsZWFzZUNvbnRleHRWZXJpZmllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICByZXR1cm4gZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c1ZlcmlmeTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVSZWxlYXNlQ29udGV4dHMocmVsZWFzZUNvbnRleHQsIHJlbGVhc2VDb250ZXh0TWFwKSB7XG4gIGNvbnN0IHJlbGVhc2VDb250ZXh0cyA9IFtdLFxuICAgICAgICByZW1haW5pbmdSZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0LCAgLy8vXG4gICAgICAgIHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0cyA9IFtcbiAgICAgICAgICByZW1haW5pbmdSZWxlYXNlQ29udGV4dFxuICAgICAgICBdO1xuXG4gIGxldCByZW1haW5pbmdSZWxlYXNlQ29udGV4dHNMZW5ndGggPSByZW1haW5pbmdSZWxlYXNlQ29udGV4dHMubGVuZ3RoO1xuXG4gIHdoaWxlIChyZW1haW5pbmdSZWxlYXNlQ29udGV4dHNMZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcmVtYWluaW5nUmVsZWFzZUNvbnRleHQgPSByZW1haW5pbmdSZWxlYXNlQ29udGV4dHMuc2hpZnQoKSxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0OyAgLy8vXG5cbiAgICByZWxlYXNlQ29udGV4dHMucHVzaChyZWxlYXNlQ29udGV4dCk7XG5cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSByZWxlYXNlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoKTtcblxuICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoRGVwZW5kZW5jeSgoZGVwZW5kZW5jeSkgPT4ge1xuICAgICAgY29uc3QgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgICAgIHJlbGVhc2VOYW1lID0gZGVwZW5kZW5jeU5hbWUsIC8vL1xuICAgICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSByZWxlYXNlQ29udGV4dE1hcFtyZWxlYXNlTmFtZV0sXG4gICAgICAgICAgICByZWxlYXNlQ29udGV4dHNJbmNsdWRlc1JlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHRzLmluY2x1ZGVzKHJlbGVhc2VDb250ZXh0KSxcbiAgICAgICAgICAgIHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0c0luY2x1ZGVzUmVsZWFzZUNvbnRleHQgPSByZW1haW5pbmdSZWxlYXNlQ29udGV4dHMuaW5jbHVkZXMocmVsZWFzZUNvbnRleHQpO1xuXG4gICAgICBpZiAoIXJlbGVhc2VDb250ZXh0c0luY2x1ZGVzUmVsZWFzZUNvbnRleHQgJiYgIXJlbWFpbmluZ1JlbGVhc2VDb250ZXh0c0luY2x1ZGVzUmVsZWFzZUNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nUmVsZWFzZUNvbnRleHQgPSByZWxlYXNlQ29udGV4dDsgLy8vXG5cbiAgICAgICAgcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzLnB1c2gocmVtYWluaW5nUmVsZWFzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzTGVuZ3RoID0gcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZWxlYXNlQ29udGV4dHM7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ3ljbGljRGVwZW5kZW5jeUV4aXN0cyhkZXBlbmRlbmN5LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCkge1xuICBjb25zdCBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICBkZXBlbmRlbnROYW1lc0luY2x1ZGVzRGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbnROYW1lcy5pbmNsdWRlcyhkZXBlbmRlbmN5TmFtZSksXG4gICAgICAgIGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHMgPSBkZXBlbmRlbnROYW1lc0luY2x1ZGVzRGVwZW5kZW5jeU5hbWU7ICAvLy9cblxuICBpZiAoY3ljbGljRGVwZW5kZW5jeUV4aXN0cykge1xuICAgIGNvbnN0IHsgbG9nIH0gPSBjb250ZXh0LFxuICAgICAgICAgIGZpcnN0RGVwZW5kZW50TmFtZSA9IGZpcnN0KGRlcGVuZGVudE5hbWVzKSxcbiAgICAgICAgICBkZXBlbmRlbmN5TmFtZXMgPSBbICAvLy9cbiAgICAgICAgICAgIC4uLmRlcGVuZGVudE5hbWVzLFxuICAgICAgICAgICAgZmlyc3REZXBlbmRlbnROYW1lXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZXBlbmRlbmN5TmFtZXNTdHJpbmcgPSBkZXBlbmRlbmN5TmFtZXMuam9pbihgJyAtPiAnYCk7XG5cbiAgICBsb2cud2FybmluZyhgVGhlcmUgaXMgYSBjeWNsaWMgZGVwZW5kZW5jeSwgJyR7ZGVwZW5kZW5jeU5hbWVzU3RyaW5nfScuYCk7XG4gIH1cblxuICByZXR1cm4gY3ljbGljRGVwZW5kZW5jeUV4aXN0cztcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVuY3ksIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KSB7XG4gIGxldCByZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kgPSB0cnVlO1xuXG4gIGNvbnN0IHNob3J0ZW5lZFZlcnNpb24gPSBkZXBlbmRlbmN5LmdldFNob3J0ZWRWZXJzaW9uKCk7XG5cbiAgaWYgKHNob3J0ZW5lZFZlcnNpb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBlbnRyaWVzTWF0Y2hTaG9ydGVuZWRWZXJzaW9uID0gcmVsZWFzZUNvbnRleHQubWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgaWYgKCFlbnRyaWVzTWF0Y2hTaG9ydGVuZWRWZXJzaW9uKSB7XG4gICAgICBjb25zdCB7IGxvZyB9ID0gY29udGV4dCxcbiAgICAgICAgICAgIHZlcnNpb24gPSByZWxlYXNlQ29udGV4dC5nZXRWZXJzaW9uKCksXG4gICAgICAgICAgICBsYXN0RGVwZW5kZW50TmFtZSA9IGxhc3QoZGVwZW5kZW50TmFtZXMpLFxuICAgICAgICAgICAgZGVwZW5kZW50TmFtZSA9IGxhc3REZXBlbmRlbnROYW1lLCAgLy8vXG4gICAgICAgICAgICB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgZGVwZW5kZW5jeVN0cmluZyA9IGRlcGVuZGVuY3kuYXNTdHJpbmcoKTtcblxuICAgICAgbG9nLndhcm5pbmcoYFRoZSAnJHtkZXBlbmRlbnROYW1lfScgZGVwZW5kZW50IHJlcXVpcmVzIHRoZSAnJHtkZXBlbmRlbmN5U3RyaW5nfScgZGVwZW5kZW5jeSBidXQgYSBjb250ZXh0IHdpdGggdmVyc2lvbiAnJHt2ZXJzaW9uU3RyaW5nfScgd2FzIHByb3ZpZGVkLmApO1xuXG4gICAgICByZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5O1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXNlRGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhkZXBlbmRlbmN5LCByZWxlYXNlQ29udGV4dCwgY29udGV4dCkge1xuICBjb25zdCBkZXBlbmRlbmNpZXMgPSByZWxlYXNlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoKTtcblxuICBkZXBlbmRlbmNpZXMuZm9yRWFjaERlcGVuZGVuY3koKGRlcGVuZGVuY3kpID0+IHsgIC8vL1xuICAgIGluaXRpYWxpc2VSZWxlYXNlQ29udGV4dChkZXBlbmRlbmN5LCBjb250ZXh0KTtcbiAgfSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBGSUxFX1RZUEUgPSBcIkZpbGVcIjtcbmV4cG9ydCBjb25zdCBESVJFQ1RPUllfVFlQRSA9IFwiRGlyZWN0b3J5XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IERPVUJMRV9TUEFDRSA9IFwiICBcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0FNUEVSU0FORCA9IFwiJmFtcDtcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0xFU1NfVEhBTiA9IFwiJmx0O1wiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRURfR1JFQVRFUl9USEFOID0gXCImZ3Q7XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERPVUJMRV9TUEFDRSwgRU1QVFlfU1RSSU5HLCBFU0NBUEVEX0FNUEVSU0FORCwgRVNDQVBFRF9MRVNTX1RIQU4sIEVTQ0FQRURfR1JFQVRFUl9USEFOIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3Qgc2FuaXRpc2VkQ29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgRVNDQVBFRF9BTVBFUlNBTkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIEVTQ0FQRURfTEVTU19USEFOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBFU0NBUEVEX0dSRUFURVJfVEhBTik7XG5cbiAgcmV0dXJuIHNhbml0aXNlZENvbnRlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmltRG91YmxlUXVvdGVzKGNvbnRlbnQpIHsgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvKF5cInxcIiQpL2csIEVNUFRZX1NUUklORyk7IH0gLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UoY29udGVudCkgeyByZXR1cm4gY29udGVudC5yZXBsYWNlKC9cXHQvZywgRE9VQkxFX1NQQUNFKTsgfSAvLy9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBzYW5pdGlzZUNvbnRlbnQsXG4gIHRyaW1Eb3VibGVRdW90ZXMsXG4gIGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRklMRV9UWVBFIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZSB9IGZyb20gXCIuL3V0aWxpdGllcy9jb250ZW50XCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMucmVsZWFzZWQgPSByZWxlYXNlZDtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuXG4gIGlzUmVsZWFzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZWQ7XG4gIH1cblxuICBpc0ZpbGUoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRydWU7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIGlzRGlyZWN0b3J5KCkge1xuICAgIGNvbnN0IGRpcmVjdG9yeSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgfVxuXG4gIHNldFBhdGgocGF0aCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cblxuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgc2V0UmVsZWFzZWQocmVsZWFzZWQpIHtcbiAgICB0aGlzLnJlbGVhc2VkID0gcmVsZWFzZWQ7XG4gIH1cblxuICBtYXRjaEZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgZmlsZVBhdGhNYXRjaGVzID0gKHRoaXMucGF0aCA9PT0gZmlsZVBhdGgpO1xuXG4gICAgcmV0dXJuIGZpbGVQYXRoTWF0Y2hlcztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IEZpbGUsXG4gICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICAgIHJlbGVhc2VkID0gdGhpcy5yZWxlYXNlZCxcbiAgICAgICAgICBqc29uID0ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgcmVsZWFzZWRcbiAgICAgICAgICB9O1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IEZJTEVfVFlQRTtcblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGxldCBmaWxlID0gbnVsbDtcblxuICAgIGlmIChqc29uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7IHR5cGUgfSA9IGpzb247XG5cbiAgICAgIGlmICh0eXBlID09PSBGSUxFX1RZUEUpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCB9ID0ganNvbjtcblxuICAgICAgICBjb25zdCB7IHBhdGgsIHJlbGVhc2VkIH0gPSBqc29uO1xuXG4gICAgICAgIGNvbnRlbnQgPSBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UoY29udGVudCk7ICAvLy9cblxuICAgICAgICBmaWxlID0gbmV3IEZpbGUocGF0aCwgY29udGVudCwgcmVsZWFzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZG9jdW1lbnQuZ2V0RmlsZVBhdGgoKSxcbiAgICAgICAgICByZWxlYXNlZCA9IGRvY3VtZW50LmlzUmVsZWFzZWQoKSxcbiAgICAgICAgICBwYXRoID0gZmlsZVBhdGg7ICAvLy9cblxuICAgIGxldCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0Q29udGVudCgpO1xuXG4gICAgY29udGVudCA9IGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZShjb250ZW50KTsgIC8vL1xuXG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKTtcblxuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXRoQ29udGVudEFuZFJlbGVhc2VkKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKSB7XG4gICAgY29udGVudCA9IGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZShjb250ZW50KTsgIC8vL1xuXG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKTtcblxuICAgIHJldHVybiBmaWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBGaWxlIGZyb20gXCIuL2ZpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgZ2V0RmlsZVBhdGhzKCkge1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IHRoaXMubWFwRmlsZSgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKTtcblxuICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbGVQYXRocztcbiAgfVxuXG4gIGFkZEZpbGUoZmlsZSkgeyB0aGlzLmFycmF5LnB1c2goZmlsZSk7IH1cblxuICBtYXBGaWxlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICBzb21lRmlsZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5zb21lKGNhbGxiYWNrKTsgfVxuXG4gIHJlZHVjZUZpbGUoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkgeyByZXR1cm4gdGhpcy5hcnJheS5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7IH1cblxuICBmb3JFYWNoRmlsZShjYWxsYmFjaykgeyB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spOyB9XG5cbiAgZmluZEZpbGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuZmluZChjYWxsYmFjaykgfHwgbnVsbDsgfSAgLy8vXG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGZpbGVzSlNPTiA9IHRoaXMuYXJyYXkubWFwKChmaWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlSlNPTiA9IChmaWxlICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUudG9KU09OKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGZpbGVKU09OO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGpzb24gPSBmaWxlc0pTT047IC8vL1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGZpbGVzSlNPTiA9IGpzb24sIC8vL1xuICAgICAgICAgIGFycmF5ID0gW10sXG4gICAgICAgICAgZmlsZXMgPSBuZXcgRmlsZXMoYXJyYXkpO1xuICAgIFxuICAgIGZpbGVzSlNPTi5mb3JFYWNoKChmaWxlSlNPTikgPT4ge1xuICAgICAgY29uc3QganNvbiA9IGZpbGVKU09OLCAgLy8vXG4gICAgICAgICAgICBmaWxlID0gRmlsZS5mcm9tSlNPTihqc29uKTtcblxuICAgICAgZmlsZXMuYWRkRmlsZShmaWxlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXSxcbiAgICAgICAgICBmaWxlcyA9IG5ldyBGaWxlcyhhcnJheSk7XG5cbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSID0gMWUxMjtcbmV4cG9ydCBjb25zdCBNSU5PUl9OVU1CRVJfTVVMVElQTElFUiA9IDFlNjtcbmV4cG9ydCBjb25zdCBQQVRDSF9OVU1CRVJfTVVMVElQTElFUiA9IDFlMDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSLCBNSU5PUl9OVU1CRVJfTVVMVElQTElFUiwgUEFUQ0hfTlVNQkVSX01VTFRJUExJRVIgfSBmcm9tIFwiLi4vbXVsdGlwbGVyc1wiO1xuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWpvck51bWJlckZyb21OdW1iZXIobnVtYmVyKSB7XG4gIGNvbnN0IG1ham9yTnVtYmVyID0gKG51bWJlciAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihudW1iZXIgLyBNQUpPUl9OVU1CRVJfTVVMVElQTElFUikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAwOyAgLy8vXG5cbiAgcmV0dXJuIG1ham9yTnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlub3JOdW1iZXJGcm9tTnVtYmVyKG51bWJlcikge1xuICBjb25zdCBtaW5vck51bWJlciA9IChudW1iZXIgIT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG51bWJlciAlIE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSKSAvIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDA7ICAvLy9cblxuICByZXR1cm4gbWlub3JOdW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaE51bWJlckZyb21OdW1iZXIobnVtYmVyKSB7XG4gIGNvbnN0IHBhdGNoTnVtYmVyID0gKG51bWJlciAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcigobnVtYmVyICUgTUlOT1JfTlVNQkVSX01VTFRJUExJRVIpIC8gUEFUQ0hfTlVNQkVSX01VTFRJUExJRVIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMDsgIC8vL1xuXG4gIHJldHVybiBwYXRjaE51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ham9yTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgbGV0IG1ham9yTnVtYmVyID0gMDtcblxuICBpZiAoc3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHN0cmluZy5tYXRjaCgvXihcXGQrKS8pLFxuICAgICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgbWFqb3JOdW1iZXIgPSBOdW1iZXIoc2Vjb25kTWF0Y2gpOyAgLy8vXG4gIH1cblxuICByZXR1cm4gbWFqb3JOdW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5vck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSB7XG4gIGxldCBtaW5vck51bWJlciA9IDA7XG5cbiAgaWYgKHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHJpbmcubWF0Y2goL15cXGQrXFwuKFxcZCspLyksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBtaW5vck51bWJlciA9IE51bWJlcihzZWNvbmRNYXRjaCk7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBtaW5vck51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgbGV0IHBhdGNoTnVtYmVyID0gMDtcblxuICBpZiAoc3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHN0cmluZy5tYXRjaCgvXlxcZCtcXC5cXGQrXFwuKFxcZCspLyksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBwYXRjaE51bWJlciA9IE51bWJlcihzZWNvbmRNYXRjaCk7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBwYXRjaE51bWJlcjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTUFKT1JfTlVNQkVSX01VTFRJUExJRVIsIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSLCBQQVRDSF9OVU1CRVJfTVVMVElQTElFUiB9IGZyb20gXCIuL211bHRpcGxlcnNcIjtcbmltcG9ydCB7IG1ham9yTnVtYmVyRnJvbU51bWJlcixcbiAgICAgICAgIG1pbm9yTnVtYmVyRnJvbU51bWJlcixcbiAgICAgICAgIHBhdGNoTnVtYmVyRnJvbU51bWJlcixcbiAgICAgICAgIG1ham9yTnVtYmVyRnJvbVN0cmluZyxcbiAgICAgICAgIG1pbm9yTnVtYmVyRnJvbVN0cmluZyxcbiAgICAgICAgIHBhdGNoTnVtYmVyRnJvbVN0cmluZyB9IGZyb20gXCIuL3V0aWxpdGllcy92ZXJzaW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnNpb24ge1xuICBjb25zdHJ1Y3RvcihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKSB7XG4gICAgdGhpcy5tYWpvck51bWJlciA9IG1ham9yTnVtYmVyO1xuICAgIHRoaXMubWlub3JOdW1iZXIgPSBtaW5vck51bWJlcjtcbiAgICB0aGlzLnBhdGNoTnVtYmVyID0gcGF0Y2hOdW1iZXI7XG4gIH1cblxuICBnZXRNYWpvck51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYWpvck51bWJlcjtcbiAgfVxuXG4gIGdldE1pbm9yTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLm1pbm9yTnVtYmVyO1xuICB9XG5cbiAgZ2V0UGF0Y2hOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0Y2hOdW1iZXI7XG4gIH1cblxuICBidW1wTWFqb3JOdW1iZXIoKSB7XG4gICAgdGhpcy5tYWpvck51bWJlciArPSAxO1xuICB9XG5cbiAgYnVtcE1pbm9yTnVtYmVyKCkge1xuICAgIHRoaXMubWlub3JOdW1iZXIgKz0gMTtcbiAgfVxuXG4gIGJ1bXBQYXRjaE51bWJlcigpIHtcbiAgICB0aGlzLnBhdGNoTnVtYmVyICs9IDE7XG4gIH1cblxuICByZXNldE1ham9yTnVtYmVyKCkge1xuICAgIHRoaXMubWFqb3JOdW1iZXIgPSAwO1xuICB9XG5cbiAgcmVzZXRNaW5vck51bWJlcigpIHtcbiAgICB0aGlzLm1pbm9yTnVtYmVyID0gMDtcbiAgfVxuXG4gIHJlc2V0UGF0Y2hOdW1iZXIoKSB7XG4gICAgdGhpcy5wYXRjaE51bWJlciA9IDA7XG4gIH1cblxuICBtYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbikge1xuICAgIGxldCBtYXRjaGVzU2hvcnRlbmVkVmVyc2lvbiA9IGZhbHNlO1xuXG4gICAgaWYgKHNob3J0ZW5lZFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIG1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWFqb3JOdW1iZXIgPSBzaG9ydGVuZWRWZXJzaW9uLmdldE1ham9yTnVtYmVyKCk7XG5cbiAgICAgIGlmICh0aGlzLm1ham9yTnVtYmVyID09PSBtYWpvck51bWJlcikge1xuICAgICAgICBjb25zdCBtaW5vck51bWJlciA9IHNob3J0ZW5lZFZlcnNpb24uZ2V0TWlub3JOdW1iZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5taW5vck51bWJlciA+PSBtaW5vck51bWJlcikge1xuICAgICAgICAgIG1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzU2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGAke3RoaXMubWFqb3JOdW1iZXJ9LiR7dGhpcy5taW5vck51bWJlcn0uJHt0aGlzLnBhdGNoTnVtYmVyfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgdG9WZXJzaW9uTnVtYmVyKCkge1xuICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSB0aGlzLm1ham9yTnVtYmVyICogTUFKT1JfTlVNQkVSX01VTFRJUExJRVIgKyB0aGlzLm1pbm9yTnVtYmVyICogTUlOT1JfTlVNQkVSX01VTFRJUExJRVIgKyB0aGlzLnBhdGNoTnVtYmVyICogUEFUQ0hfTlVNQkVSX01VTFRJUExJRVI7XG5cbiAgICByZXR1cm4gdmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gbWFqb3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSBtaW5vck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSxcbiAgICAgICAgICBwYXRjaE51bWJlciA9IHBhdGNoTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTtcblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gMCxcbiAgICAgICAgICBtaW5vck51bWJlciA9IDAsXG4gICAgICAgICAgcGF0Y2hOdW1iZXIgPSAwLFxuICAgICAgICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTtcblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IHZlcnNpb24uZ2V0TWFqb3JOdW1iZXIoKSxcbiAgICAgICAgICBtaW5vck51bWJlciA9IHZlcnNpb24uZ2V0TWlub3JOdW1iZXIoKSxcbiAgICAgICAgICBwYXRjaE51bWJlciA9IHZlcnNpb24uZ2V0UGF0Y2hOdW1iZXIoKTtcblxuICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTsgLy8vXG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVyc2lvbk51bWJlcih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgY29uc3QgbnVtYmVyID0gdmVyc2lvbk51bWJlciwgLy8vXG4gICAgICAgICAgbWFqb3JOdW1iZXIgPSBtYWpvck51bWJlckZyb21OdW1iZXIobnVtYmVyKSxcbiAgICAgICAgICBtaW5vck51bWJlciA9IG1pbm9yTnVtYmVyRnJvbU51bWJlcihudW1iZXIpLFxuICAgICAgICAgIHBhdGNoTnVtYmVyID0gcGF0Y2hOdW1iZXJGcm9tTnVtYmVyKG51bWJlciksXG4gICAgICAgICAgdmVyc2lvbiA9IG5ldyBWZXJzaW9uKG1ham9yTnVtYmVyLCBtaW5vck51bWJlciwgcGF0Y2hOdW1iZXIpO1xuXG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRElSRUNUT1JZX1RZUEUgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGlzRmlsZSgpIHtcbiAgICBjb25zdCBmaWxlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIGlzRGlyZWN0b3J5KCkge1xuICAgIGNvbnN0IGRpcmVjdG9yeSA9IHRydWU7XG5cbiAgICByZXR1cm4gZGlyZWN0b3J5O1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gRGlyZWN0b3J5LFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBESVJFQ1RPUllfVFlQRTtcblxuICBzdGF0aWMgZnJvbVBhdGgocGF0aCkge1xuICAgIGNvbnN0IGRpcmVjdG9yeSA9IG5ldyBEaXJlY3RvcnkocGF0aCk7XG5cbiAgICByZXR1cm4gZGlyZWN0b3J5O1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBsZXQgZGlyZWN0b3J5ID0gbnVsbDtcblxuICAgIGlmIChqc29uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7IHR5cGUgfSA9IGpzb247XG5cbiAgICAgIGlmICh0eXBlID09PSBESVJFQ1RPUllfVFlQRSkge1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGpzb247XG5cbiAgICAgICAgZGlyZWN0b3J5ID0gbmV3IERpcmVjdG9yeShwYXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0b3J5O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhdGhVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgYm90dG9tbW9zdE5hbWVGcm9tUGF0aCB9ID0gcGF0aFV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVOYW1lRnJvbUZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gIGNvbnN0IHBhdGggPSBmaWxlUGF0aCwgIC8vL1xuICAgICAgICBib3R0b21tb3N0TmFtZSA9IGJvdHRvbW1vc3ROYW1lRnJvbVBhdGgocGF0aCksXG4gICAgICAgIGZpbGVOYW1lID0gYm90dG9tbW9zdE5hbWU7ICAvL1xuXG4gIHJldHVybiBmaWxlTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFJFQURNRV9NRF9GSUxFX05BTUUgPSBcIlJFQURNRS5tZFwiO1xuZXhwb3J0IGNvbnN0IE1FVEFfSlNPTl9GSUxFX05BTUUgPSBcIm1ldGEuanNvblwiO1xuXG5leHBvcnQgY29uc3QgVEVSTV9CTkZfRklMRV9OQU1FID0gXCJ0ZXJtLmJuZlwiO1xuZXhwb3J0IGNvbnN0IFNUQVRFTUVOVF9CTkZfRklMRV9OQU1FID0gXCJzdGF0ZW1lbnQuYm5mXCI7XG5leHBvcnQgY29uc3QgVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSA9IFwidHlwZS52Y2JcIjtcbmV4cG9ydCBjb25zdCBTWU1CT0xfVk9DQUJVTEFSWV9GSUxFX05BTUUgPSBcInN5bWJvbC52Y2JcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBSRUFETUVfTURfRklMRV9OQU1FLFxuICBNRVRBX0pTT05fRklMRV9OQU1FLFxuICBURVJNX0JORl9GSUxFX05BTUUsXG4gIFNUQVRFTUVOVF9CTkZfRklMRV9OQU1FLFxuICBUWVBFX1ZPQ0FCVUxBUllfRklMRV9OQU1FLFxuICBTWU1CT0xfVk9DQUJVTEFSWV9GSUxFX05BTUVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpbGVOYW1lRnJvbUZpbGVQYXRoIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9uYW1lXCI7XG5pbXBvcnQgeyBURVJNX0JORl9GSUxFX05BTUUsIFNUQVRFTUVOVF9CTkZfRklMRV9OQU1FIH0gZnJvbSBcIi4uL2ZpbGVOYW1lc1wiO1xuXG5mdW5jdGlvbiBnZXRCTkYoYm5mRmlsZU5hbWUpIHtcbiAgbGV0IGJuZiA9IEVNUFRZX1NUUklORztcblxuICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZXMgPSB0aGlzLmdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZSA9IGN1c3RvbUdyYW1tYXJCTkZGaWxlcy5maW5kKChjdXN0b21HcmFtbWFyQk5GRmlsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aCA9IGN1c3RvbUdyYW1tYXJCTkZGaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZU5hbWUgPSBmaWxlTmFtZUZyb21GaWxlUGF0aChjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgpO1xuXG4gICAgICAgICAgaWYgKGN1c3RvbUdyYW1tYXJCTkZGaWxlTmFtZSA9PT0gYm5mRmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoY3VzdG9tR3JhbW1hckJORkZpbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZUNvbnRlbnQgPSBjdXN0b21HcmFtbWFyQk5GRmlsZS5nZXRDb250ZW50KCk7XG5cbiAgICBibmYgPSBjdXN0b21HcmFtbWFyQk5GRmlsZUNvbnRlbnQ7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBibmY7XG59XG5cbmZ1bmN0aW9uIGdldFRlcm1CTkYoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gVEVSTV9CTkZfRklMRV9OQU1FLCAvLy9cbiAgICAgICAgYm5mID0gdGhpcy5nZXRCTkYoZmlsZU5hbWUpLFxuICAgICAgICB0ZXJtQk5GID0gYm5mOyAgLy8vXG5cbiAgcmV0dXJuIHRlcm1CTkY7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlbWVudEJORigpIHtcbiAgY29uc3QgZmlsZU5hbWUgPSBTVEFURU1FTlRfQk5GX0ZJTEVfTkFNRSwgLy8vXG4gICAgICAgIGJuZiA9IHRoaXMuZ2V0Qk5GKGZpbGVOYW1lKSxcbiAgICAgICAgc3RhdGVtZW50Qk5GID0gYm5mOyAgLy8vXG5cbiAgcmV0dXJuIHN0YXRlbWVudEJORjtcbn1cblxuY29uc3QgYm5mTWl4aW5zID0ge1xuICBnZXRCTkYsXG4gIGdldFRlcm1CTkYsXG4gIGdldFN0YXRlbWVudEJORlxufTtcblxuZXhwb3J0IGRlZmF1bHQgYm5mTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgcmVhZG1lRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezF9UkVBRE1FXFxcXC5tZCRcIixcclxuICAgICAgZnVydGxlRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezEsfVteXFxcXC5dK1xcXFwuZnRsJFwiLFxyXG4gICAgICBub21pbmFsRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezEsfVteXFxcXC5dK1xcXFwubm1sJFwiLFxyXG4gICAgICBtYXJrZG93bkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxLH1bXlxcXFwuXStcXFxcLm1kJFwiLFxyXG4gICAgICBtZXRhSlNPTkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfW1ldGFcXFxcLmpzb24kXCIsXHJcbiAgICAgIGluZGV4SlNPTkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfWluZGV4XFxcXC5qc29uJFwiLFxyXG4gICAgICBtYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezEsfVteXFxcXC5dK1xcXFwubWRzJFwiLFxyXG4gICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezF9KHRlcm18c3RhdGVtZW50KVxcXFwuYm5mJFwiLFxyXG4gICAgICBkZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoUGF0dGVybiA9IFwiXlteXFxcXC9dK1xcXFwvZGVmYXVsdFxcXFwubWRzJFwiLFxyXG4gICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfSh0eXBlfHN5bWJvbClcXFxcLnZjYiRcIixcclxuICAgICAgcmVsZWFzZUZpbGVQYXRoUGF0dGVybiA9IGAke3JlYWRtZUZpbGVQYXRoUGF0dGVybn18JHtmdXJ0bGVGaWxlUGF0aFBhdHRlcm59fCR7bm9taW5hbEZpbGVQYXRoUGF0dGVybn18JHttZXRhSlNPTkZpbGVQYXRoUGF0dGVybn18JHtjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGhQYXR0ZXJufXwke2N1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGhQYXR0ZXJufWAsXHJcbiAgICAgIHJlY29nbmlzZWRGaWxlUGF0aFBhdHRlcm4gPSBgJHtyZWxlYXNlRmlsZVBhdGhQYXR0ZXJufXwke2luZGV4SlNPTkZpbGVQYXRoUGF0dGVybn18JHttYXJrZG93bkZpbGVQYXRoUGF0dGVybn18JHttYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJufWA7XHJcblxyXG5jb25zdCByZWFkbWVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChyZWFkbWVGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBmdXJ0bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChmdXJ0bGVGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICByZWxlYXNlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocmVsZWFzZUZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG5vbWluYWxGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChub21pbmFsRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgbWFya2Rvd25GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChtYXJrZG93bkZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG1ldGFKU09ORmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAobWV0YUpTT05GaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBpbmRleEpTT05GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChpbmRleEpTT05GaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICByZWNvZ25pc2VkRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocmVjb2duaXNlZEZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG1hcmtkb3duU3R5bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChtYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBkZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGRlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUGF0dGVybik7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aFJlYWRtZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiByZWFkbWVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aEZ1cnRsZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBmdXJ0bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aFJlbGVhc2VGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gcmVsZWFzZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTm9taW5hbEZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBub21pbmFsRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhNYXJrZG93bkZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBtYXJrZG93bkZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gbWV0YUpTT05GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aEluZGV4SlNPTkZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBpbmRleEpTT05GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aFJlY29nbmlzZWRGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gcmVjb2duaXNlZEZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTWFya2Rvd25TdHlsZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBtYXJrZG93blN0eWxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aERlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIGRlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBpc0ZpbGVQYXRoUmVhZG1lRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aEZ1cnRsZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aE5vbWluYWxGaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoTWFya2Rvd25GaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoSW5kZXhKU09ORmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aFJlY29nbmlzZWRGaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoTWFya2Rvd25TdHlsZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aERlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGhcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBpc0ZpbGVQYXRoUmVhZG1lRmlsZVBhdGgsXG4gICAgICAgICBpc0ZpbGVQYXRoRnVydGxlRmlsZVBhdGgsXG4gICAgICAgICBpc0ZpbGVQYXRoTm9taW5hbEZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aE1ldGFKU09ORmlsZVBhdGgsXG4gICAgICAgICBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2ZpbGVQYXRoXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkbWVGaWxlRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGxldCByZWFkbWVGaWxlID0gbnVsbDtcblxuICBmaWxlcy5zb21lRmlsZSgoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgZmlsZVBhdGhSZWFkbWVGaWxlUGF0aCA9IGlzRmlsZVBhdGhSZWFkbWVGaWxlUGF0aChmaWxlUGF0aCk7XG5cbiAgICBpZiAoZmlsZVBhdGhSZWFkbWVGaWxlUGF0aCkge1xuICAgICAgcmVhZG1lRmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVhZG1lRmlsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZUZpbGVzRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGNvbnN0IGZ1cnRsZUZpbGVzID0gZmlsZXMucmVkdWNlRmlsZSgoZnVydGxlRmlsZXMsIGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgIGZpbGVQYXRoRnVydGxlRmlsZVBhdGggPSBpc0ZpbGVQYXRoRnVydGxlRmlsZVBhdGgoZmlsZVBhdGgpLFxuICAgICAgICAgIGZpbGVGdXJ0bGVGaWxlID0gZmlsZVBhdGhGdXJ0bGVGaWxlUGF0aDsgIC8vL1xuXG4gICAgaWYgKGZpbGVGdXJ0bGVGaWxlKSB7XG4gICAgICBjb25zdCBmdXJ0bGVGaWxlID0gZmlsZTsgIC8vL1xuXG4gICAgICBmdXJ0bGVGaWxlcy5wdXNoKGZ1cnRsZUZpbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdXJ0bGVGaWxlcztcbiAgfSwgW10pO1xuXG4gIHJldHVybiBmdXJ0bGVGaWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vbWluYWxGaWxlc0Zyb21GaWxlcyhmaWxlcykge1xuICBjb25zdCBub21pbmFsRmlsZXMgPSBmaWxlcy5yZWR1Y2VGaWxlKChub21pbmFsRmlsZXMsIGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgZmlsZVBhdGhOb21pbmFsRmlsZVBhdGggPSBpc0ZpbGVQYXRoTm9taW5hbEZpbGVQYXRoKGZpbGVQYXRoKSxcbiAgICAgIGZpbGVOb21pbmFsRmlsZSA9IGZpbGVQYXRoTm9taW5hbEZpbGVQYXRoOyAgLy8vXG5cbiAgICBpZiAoZmlsZU5vbWluYWxGaWxlKSB7XG4gICAgICBjb25zdCBub21pbmFsRmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgbm9taW5hbEZpbGVzLnB1c2gobm9taW5hbEZpbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub21pbmFsRmlsZXM7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gbm9taW5hbEZpbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWV0YUpTT05GaWxlRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGxldCBtZXRhSlNPTkZpbGUgPSBudWxsO1xuXG4gIGZpbGVzLnNvbWVGaWxlKChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBmaWxlUGF0aE1ldGFKU09ORmlsZVBhdGggPSBpc0ZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aChmaWxlUGF0aCk7XG5cbiAgICBpZiAoZmlsZVBhdGhNZXRhSlNPTkZpbGVQYXRoKSB7XG4gICAgICBtZXRhSlNPTkZpbGUgPSBmaWxlOyAgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG1ldGFKU09ORmlsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbUdyYW1tYXJCTkZGaWxlc0Zyb21GaWxlcyhmaWxlcykge1xuICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZXMgPSBmaWxlcy5yZWR1Y2VGaWxlKChjdXN0b21HcmFtbWFyQk5GRmlsZXMsIGZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoID0gaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aChmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgZmlsZUN1c3RvbUdyYW1tYXJCTkZGaWxlID0gZmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGg7ICAvLy9cblxuICAgICAgICAgIGlmIChmaWxlQ3VzdG9tR3JhbW1hckJORkZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJCTkZGaWxlID0gZmlsZTsgIC8vL1xuXG4gICAgICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZXMucHVzaChjdXN0b21HcmFtbWFyQk5GRmlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUdyYW1tYXJCTkZGaWxlcztcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyQk5GRmlsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMgPSBmaWxlcy5yZWR1Y2VGaWxlKChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzLCBmaWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICAgICAgICBmaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGggPSBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aChmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgZmlsZUN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSA9IGZpbGVQYXRoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aDsgIC8vL1xuXG4gICAgICAgICAgaWYgKGZpbGVDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcy5wdXNoKGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXM7XG4gICAgICAgIH0sIFtdKTtcblxuICByZXR1cm4gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcmVhZG1lRmlsZUZyb21GaWxlcyxcbiAgICAgICAgIGZ1cnRsZUZpbGVzRnJvbUZpbGVzLFxuICAgICAgICAgbm9taW5hbEZpbGVzRnJvbUZpbGVzLFxuICAgICAgICAgbWV0YUpTT05GaWxlRnJvbUZpbGVzLFxuICAgICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVzRnJvbUZpbGVzLFxuICAgICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc0Zyb21GaWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvZmlsZXNcIjtcblxuZnVuY3Rpb24gZ2V0UmVhZG1lRmlsZSgpIHtcbiAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKCksXG4gICAgICAgIHJlYWRtZUZpbGUgPSByZWFkbWVGaWxlRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gcmVhZG1lRmlsZTtcbn1cblxuZnVuY3Rpb24gZ2V0RnVydGxlRmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBmdXJ0bGVGaWxlcyA9IGZ1cnRsZUZpbGVzRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gZnVydGxlRmlsZXM7XG59XG5cbmZ1bmN0aW9uIGdldE5vbWluYWxGaWxlcygpIHtcbiAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKCksXG4gICAgICAgIG5vbWluYWxGaWxlcyA9IG5vbWluYWxGaWxlc0Zyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIG5vbWluYWxGaWxlcztcbn1cblxuZnVuY3Rpb24gZ2V0TWV0YUpTT05GaWxlKCkge1xuICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgbWV0YUpTT05GaWxlID0gbWV0YUpTT05GaWxlRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gbWV0YUpTT05GaWxlO1xufVxuXG5mdW5jdGlvbiBnZXRDdXN0b21HcmFtbWFyQk5GRmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZXMgPSBjdXN0b21HcmFtbWFyQk5GRmlsZXNGcm9tRmlsZXMoZmlsZXMpO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyQk5GRmlsZXM7XG59XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc0Zyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXM7XG59XG5cbmNvbnN0IGZpbGVzTWl4aW5zID0ge1xuICBnZXRSZWFkbWVGaWxlLFxuICBnZXRGdXJ0bGVGaWxlcyxcbiAgZ2V0Tm9taW5hbEZpbGVzLFxuICBnZXRNZXRhSlNPTkZpbGUsXG4gIGdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcyxcbiAgZ2V0Q3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZmlsZXNNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlcGVuZGVuY3kge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBzaG9ydGVuZWRWZXJzaW9uKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnNob3J0ZW5lZFZlcnNpb24gPSBzaG9ydGVuZWRWZXJzaW9uO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0U2hvcnRlZFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmc7XG5cbiAgICBpZiAodGhpcy5zaG9ydGVuZWRWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzaG9ydGVuZWRWZXJzaW9uU3RyaW5nID0gdGhpcy5zaG9ydGVuZWRWZXJzaW9uLnRvU3RyaW5nKCk7XG5cbiAgICAgIHN0cmluZyA9IGAke3RoaXMubmFtZX1AJHtzaG9ydGVuZWRWZXJzaW9uU3RyaW5nfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmluZyA9IHRoaXMubmFtZTsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgY29uc3Qgc2hvcnRlbmVkVmVyc2lvbiA9IG51bGwsXG4gICAgICAgICAgZGVwZW5kZW5jeSA9IG5ldyBEZXBlbmRlbmN5KG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWVBbmRTaG9ydGVuZWRWZXJzaW9uKG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pIHtcbiAgICBjb25zdCBkZXBlbmRlbmN5ID0gbmV3IERlcGVuZGVuY3kobmFtZSwgc2hvcnRlbmVkVmVyc2lvbik7XG5cbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBNQUpPUl9OVU1CRVJfTVVMVElQTElFUiwgTUlOT1JfTlVNQkVSX01VTFRJUExJRVIgfSBmcm9tIFwiLi9tdWx0aXBsZXJzXCI7XG5pbXBvcnQgeyBtYWpvck51bWJlckZyb21OdW1iZXIsIG1pbm9yTnVtYmVyRnJvbU51bWJlciwgbWFqb3JOdW1iZXJGcm9tU3RyaW5nLCBtaW5vck51bWJlckZyb21TdHJpbmcgfSBmcm9tIFwiLi91dGlsaXRpZXMvdmVyc2lvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaG9ydGVuZWRWZXJzaW9uIHtcbiAgY29uc3RydWN0b3IobWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKSB7XG4gICAgdGhpcy5tYWpvck51bWJlciA9IG1ham9yTnVtYmVyO1xuICAgIHRoaXMubWlub3JOdW1iZXIgPSBtaW5vck51bWJlcjtcbiAgfVxuXG4gIGdldE1ham9yTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLm1ham9yTnVtYmVyO1xuICB9XG5cbiAgZ2V0TWlub3JOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlub3JOdW1iZXI7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBgJHt0aGlzLm1ham9yTnVtYmVyfS4ke3RoaXMubWlub3JOdW1iZXJ9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICB0b1ZlcnNpb25OdW1iZXIoKSB7XG4gICAgY29uc3QgdmVyc2lvbk51bWJlciA9IHRoaXMubWFqb3JOdW1iZXIgKiBNQUpPUl9OVU1CRVJfTVVMVElQTElFUiArIHRoaXMubWlub3JOdW1iZXIgKiBNSU5PUl9OVU1CRVJfTVVMVElQTElFUjtcblxuICAgIHJldHVybiB2ZXJzaW9uTnVtYmVyO1xuICB9XG5cbiAgZ2V0TGVhc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXIoKSB7XG4gICAgY29uc3QgdmVyc2lvbk51bWJlciA9IHRoaXMudG9WZXJzaW9uTnVtYmVyKCksXG4gICAgICAgICAgbGVhc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uTnVtYmVyOyAvLy9cblxuICAgIHJldHVybiBsZWFzdE1hdGNoaW5nVmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIGdldEdyZWF0ZXN0TWF0Y2hpbmdWZXJzaW9uTnVtYmVyKCkge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gdGhpcy5tYWpvck51bWJlciArIDEsXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSAwLFxuICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb24gPSBTaG9ydGVuZWRWZXJzaW9uLmZyb21NYWpvck51bWJlckFuZE1pbm9yTnVtYmVyKG1ham9yTnVtYmVyLCBtaW5vck51bWJlciksXG4gICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbk51bWJlciA9IHNob3J0ZW5lZFZlcnNpb24udG9WZXJzaW9uTnVtYmVyKCksXG4gICAgICAgICAgZ3JlYXRlc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXIgPSBzaG9ydGVuZWRWZXJzaW9uTnVtYmVyIC0gMTtcblxuICAgIHJldHVybiBncmVhdGVzdE1hdGNoaW5nVmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gbWFqb3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSBtaW5vck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSxcbiAgICAgICAgICBzaG9ydGVuZWRWZXJzaW9uID0gbmV3IFNob3J0ZW5lZFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKTtcblxuICAgIHJldHVybiBzaG9ydGVuZWRWZXJzaW9uO1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJzaW9uTnVtYmVyKHZlcnNpb25OdW1iZXIpIHtcbiAgICBjb25zdCBudW1iZXIgPSB2ZXJzaW9uTnVtYmVyLCAvLy9cbiAgICAgICAgICBtYWpvck51bWJlciA9IG1ham9yTnVtYmVyRnJvbU51bWJlcihudW1iZXIpLFxuICAgICAgICAgIG1pbm9yTnVtYmVyID0gbWlub3JOdW1iZXJGcm9tTnVtYmVyKG51bWJlciksXG4gICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IG5ldyBTaG9ydGVuZWRWZXJzaW9uKG1ham9yTnVtYmVyLCBtaW5vck51bWJlcik7XG5cbiAgICByZXR1cm4gc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTWFqb3JOdW1iZXJBbmRNaW5vck51bWJlcihtYWpvck51bWJlciwgbWlub3JOdW1iZXIpIHtcbiAgICBjb25zdCBzaG9ydGVuZWRWZXJzaW9uID0gbmV3IFNob3J0ZW5lZFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKTtcblxuICAgIHJldHVybiBzaG9ydGVuZWRWZXJzaW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlcGVuZGVuY3kgZnJvbSBcIi4vZGVwZW5kZW5jeVwiO1xuaW1wb3J0IFNob3J0ZW5lZFZlcnNpb24gZnJvbSBcIi4vc2hvcnRlbmVkVmVyc2lvblwiO1xuXG5jb25zdCB7IGZvckVhY2ggfSA9IGFzeW5jaHJvbm91c1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVwZW5kZW5jaWVzIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGFkZERlcGVuZGVuY3koZGVwZW5kZW5jeSkgeyB0aGlzLmFycmF5LnB1c2goZGVwZW5kZW5jeSk7IH1cblxuICBtYXBEZXBlbmRlbmN5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICBldmVyeURlcGVuZGVuY3koY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuZXZlcnkoY2FsbGJhY2spOyB9XG5cbiAgcmVkdWNlRGVwZW5kZW5jeShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmFycmF5LnJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKTsgfVxuXG4gIGZvckVhY2hEZXBlbmRlbmN5KGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBhc3luY2hyb25vdXNGb3JFYWNoRGVwZW5kZW5jeShvcGVyYXRpb24sIGRvbmUpIHsgZm9yRWFjaCh0aGlzLmFycmF5LCBvcGVyYXRpb24sIGRvbmUpOyB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llc0pTT04gPSB0aGlzLmFycmF5LnJlZHVjZSgoZGVwZW5kZW5jaWVzSlNPTiwgZGVwZW5kZW5jeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IGRlcGVuZGVuY3kuZ2V0U2hvcnRlZFZlcnNpb24oKSxcbiAgICAgICAgICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBzaG9ydGVuZWRWZXJzaW9uLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGRlcGVuZGVuY2llc0pTT05bbmFtZV0gPSBzaG9ydGVuZWRWZXJzaW9uU3RyaW5nO1xuICBcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNKU09OO1xuICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICBqc29uID0gZGVwZW5kZW5jaWVzSlNPTjsgLy8vXG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzSlNPTiA9IGpzb24sIC8vL1xuICAgICAgICAgIGRlcGVuZGVuY2llc0pTT05LZXlzID0gT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzSlNPTiksXG4gICAgICAgICAgbmFtZXMgPSBkZXBlbmRlbmNpZXNKU09OS2V5cywgLy8vXG4gICAgICAgICAgYXJyYXkgPSBuYW1lcy5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBkZXBlbmRlbmNpZXNKU09OW25hbWVdLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc2hvcnRlbmVkVmVyc2lvblN0cmluZywgIC8vL1xuICAgICAgICAgICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IFNob3J0ZW5lZFZlcnNpb24uZnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IERlcGVuZGVuY3kuZnJvbU5hbWVBbmRTaG9ydGVuZWRWZXJzaW9uKG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBuZXcgRGVwZW5kZW5jaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBuZXcgRGVwZW5kZW5jaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICBub2RlID0gbm9kZXMuc2hpZnQoKSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZXNRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ1ZlcnNpb25TdHJpbmcoc3RyaW5nKSB7IHJldHVybiAvKD86MHwoWzEtOV1cXGQqKSlcXC4oPzowfChbMS05XVxcZCopKVxcLig/OjB8KFsxLTldXFxkKikpLy50ZXN0KHN0cmluZyk7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyhzdHJpbmcpIHsgcmV0dXJuIC8oPzowfChbMS05XVxcZCopKVxcLig/OjB8KFsxLTldXFxkKikpLy50ZXN0KHN0cmluZyk7IH1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFZFUlNJT05fUFJPUEVSVFlfTkFNRSA9IFwidmVyc2lvblwiO1xuZXhwb3J0IGNvbnN0IFJFUE9TSVRPUllfUFJPUEVSVFlfTkFNRSA9IFwicmVwb3NpdG9yeVwiO1xuZXhwb3J0IGNvbnN0IERFUEVOREVOQ0lFU19QUk9QRVJUWV9OQU1FID0gXCJkZXBlbmRlbmNpZXNcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgSlNPTkxleGVyLCBKU09OUGFyc2VyIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXJzXCI7XG5cbmltcG9ydCBWZXJzaW9uIGZyb20gXCIuLi92ZXJzaW9uXCI7XG5pbXBvcnQgRGVwZW5kZW5jeSBmcm9tIFwiLi4vZGVwZW5kZW5jeVwiO1xuaW1wb3J0IERlcGVuZGVuY2llcyBmcm9tIFwiLi4vZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgU2hvcnRlbmVkVmVyc2lvbiBmcm9tIFwiLi4vc2hvcnRlbmVkVmVyc2lvblwiO1xuXG5pbXBvcnQgeyBET1VCTEVfU1BBQ0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyB0cmltRG91YmxlUXVvdGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBpc1N0cmluZ1ZlcnNpb25TdHJpbmcsIGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdmFsaWRhdGVcIjtcbmltcG9ydCB7IFZFUlNJT05fUFJPUEVSVFlfTkFNRSwgUkVQT1NJVE9SWV9QUk9QRVJUWV9OQU1FLCBERVBFTkRFTkNJRVNfUFJPUEVSVFlfTkFNRSB9IGZyb20gXCIuLi9wcm9wZXJ0eU5hbWVzXCI7XG5cbmNvbnN0IGpzb25MZXhlciA9IEpTT05MZXhlci5mcm9tTm90aGluZygpLFxuICAgICAganNvblBhcnNlciA9IEpTT05QYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuY29uc3QgZXJyb3JOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8qL2Vycm9yXCIpLFxuICAgICAgcHJvcGVydHlOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi9wcm9wZXJ0eS9qc29uL29iamVjdC9wcm9wZXJ0eVwiKSxcbiAgICAgIGRvY3VtZW50UHJvcGVydHlOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi9kb2N1bWVudC9qc29uL29iamVjdC9wcm9wZXJ0eVwiKSxcbiAgICAgIHByb3BlcnR5U3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3Byb3BlcnR5L0BzdHJpbmctbGl0ZXJhbFwiKSxcbiAgICAgIHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9wcm9wZXJ0eS9qc29uL0BzdHJpbmctbGl0ZXJhbCFcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01ldGFKU09ORmlsZVZhbGlkKG1ldGFKU09ORmlsZSkge1xuICBsZXQgbWV0YUpTT05GaWxlVmFsaWQgPSBmYWxzZTtcblxuICBjb25zdCBkb2N1bWVudE5vZGUgPSBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSk7XG5cbiAgaWYgKGRvY3VtZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGVycm9yTm9kZXMgPSBlcnJvck5vZGVzUXVlcnkoZG9jdW1lbnROb2RlKSxcbiAgICAgICAgICBlcnJvck5vZGVzTGVuZ3RoID0gZXJyb3JOb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoZXJyb3JOb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25Gcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSksXG4gICAgICAgICAgICByZXBvc2l0b3J5ID0gcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICAgICAgbWV0YUpTT05GaWxlVmFsaWQgPSAoKHZlcnNpb24gIT09IG51bGwpICYmIChyZXBvc2l0b3J5ICE9PSBudWxsKSAmJiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ldGFKU09ORmlsZVZhbGlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWV0YUpTT05GaWxlVmVyc2lvbihtZXRhSlNPTkZpbGUsIHZlcnNpb24pIHtcbiAgY29uc3QgZG9jdW1lbnROb2RlID0gZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZShtZXRhSlNPTkZpbGUpLFxuICAgICAgICByZXBvc2l0b3J5ID0gcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBsZXQgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIGNvbnN0IHN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgZGVwZW5kZW5jaWVzSlNPTiA9IGRlcGVuZGVuY2llcy50b0pTT04oKTtcblxuICB2ZXJzaW9uID0gc3RyaW5nOyAgLy8vXG5cbiAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzSlNPTjsgIC8vL1xuXG4gIGNvbnN0IG1ldGFKU09OID0ge1xuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgcmVwb3NpdG9yeSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXNcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YUpTT05TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShtZXRhSlNPTiwgbnVsbCwgRE9VQkxFX1NQQUNFKSxcbiAgICAgICAgbWV0YUpTT05GaWxlQ29udGVudCA9IG1ldGFKU09OU3RyaW5nOyAvLy9cblxuICBtZXRhSlNPTkZpbGUuc2V0Q29udGVudChtZXRhSlNPTkZpbGVDb250ZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSB7XG4gIGxldCBkb2N1bWVudE5vZGUgPSBudWxsO1xuXG4gIGlmIChtZXRhSlNPTkZpbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBjb250ZW50ID0gbWV0YUpTT05GaWxlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICB0b2tlbnMgPSBqc29uTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgICAgbm9kZSA9IGpzb25QYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICAgIGRvY3VtZW50Tm9kZSA9IG5vZGU7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpIHtcbiAgbGV0IHZlcnNpb24gPSBudWxsO1xuXG4gIGNvbnN0IGRvY3VtZW50UHJvcGVydHlOb2RlcyA9IGRvY3VtZW50UHJvcGVydHlOb2Rlc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBkb2N1bWVudFByb3BlcnR5Tm9kZXMuc29tZSgoZG9jdW1lbnRQcm9wZXJ0eU5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBkb2N1bWVudFByb3BlcnR5Tm9kZSwgIC8vL1xuICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09IFZFUlNJT05fUFJPUEVSVFlfTkFNRSkge1xuICAgICAgY29uc3Qgc3RyaW5nUHJvcGVydHlWYWx1ZSA9IHN0cmluZ1Byb3BlcnR5VmFsdWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSk7XG5cbiAgICAgIGlmIChzdHJpbmdQcm9wZXJ0eVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IHN0cmluZ1Byb3BlcnR5VmFsdWUsIC8vL1xuICAgICAgICAgICAgICBzdHJpbmdWZXJzaW9uU3RyaW5nID0gaXNTdHJpbmdWZXJzaW9uU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKHN0cmluZ1ZlcnNpb25TdHJpbmcpIHtcbiAgICAgICAgICB2ZXJzaW9uID0gVmVyc2lvbi5mcm9tU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSB7XG4gIGxldCByZXBvc2l0b3J5ID0gbnVsbDtcblxuICBjb25zdCBkb2N1bWVudFByb3BlcnR5Tm9kZXMgPSBkb2N1bWVudFByb3BlcnR5Tm9kZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgZG9jdW1lbnRQcm9wZXJ0eU5vZGVzLnNvbWUoKGRvY3VtZW50UHJvcGVydHlOb2RlKSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZG9jdW1lbnRQcm9wZXJ0eU5vZGUsICAvLy9cbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSk7XG5cbiAgICBpZiAocHJvcGVydHlOYW1lID09PSBSRVBPU0lUT1JZX1BST1BFUlRZX05BTUUpIHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXBvc2l0b3J5ID0gc3RyaW5nUHJvcGVydHlWYWx1ZTsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlcG9zaXRvcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBsZXQgZGVwZW5kZW5jaWVzID0gbnVsbDtcblxuICBjb25zdCBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGVGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgaWYgKGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZSAhPT0gbnVsbCkge1xuICAgIGRlcGVuZGVuY2llcyA9IERlcGVuZGVuY2llcy5mcm9tTm90aGluZygpO1xuXG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlLCAgLy8vXG4gICAgICAgICAgcHJvcGVydHlOb2RlcyA9IHByb3BlcnR5Tm9kZXNRdWVyeShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgcHJvcGVydHlOb2Rlcy5mb3JFYWNoKChwcm9wZXJ0eU5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgc3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyA9IGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChzdHJpbmdTaG9ydGVuZWRWZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eU5hbWUsICAvLy9cbiAgICAgICAgICAgICAgICBzaG9ydGVuZWRWZXJzaW9uID0gU2hvcnRlbmVkVmVyc2lvbi5mcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IERlcGVuZGVuY3kuZnJvbU5hbWVBbmRTaG9ydGVuZWRWZXJzaW9uKG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZERlcGVuZGVuY3koZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXBlbmRlbmN5TmFtZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBsZXQgZGVwZW5kZW5jeU5hbWVzID0gbnVsbDtcblxuICBjb25zdCBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGVGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgaWYgKGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZSAhPT0gbnVsbCkge1xuICAgIGRlcGVuZGVuY3lOYW1lcyA9IFtdO1xuXG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlLCAgLy8vXG4gICAgICAgICAgcHJvcGVydHlOb2RlcyA9IHByb3BlcnR5Tm9kZXNRdWVyeShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgcHJvcGVydHlOb2Rlcy5mb3JFYWNoKChwcm9wZXJ0eU5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgc3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyA9IGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChzdHJpbmdTaG9ydGVuZWRWZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lOYW1lID0gcHJvcGVydHlOYW1lOyAgLy8vXG5cbiAgICAgICAgICBkZXBlbmRlbmN5TmFtZXMucHVzaChkZXBlbmRlbmN5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmN5TmFtZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNNZXRhSlNPTkZpbGVWYWxpZCxcbiAgdXBkYXRlTWV0YUpTT05GaWxlVmVyc2lvbixcbiAgZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZSxcbiAgdmVyc2lvbkZyb21Eb2N1bWVudE5vZGUsXG4gIHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlLFxuICBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlLFxuICBkZXBlbmRlbmN5TmFtZXNGcm9tRG9jdW1lbnROb2RlXG59O1xuXG5mdW5jdGlvbiBwcm9wZXJ0eU5hbWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSkge1xuICBjb25zdCBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUgPSBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVRdWVyeShwcm9wZXJ0eU5vZGUpLFxuICAgICAgICBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVDb250ZW50ID0gcHJvcGVydHlTdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgcHJvcGVydHlOYW1lID0gdHJpbURvdWJsZVF1b3Rlcyhwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVDb250ZW50KTsgLy8vXG5cbiAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nUHJvcGVydHlWYWx1ZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKSB7XG4gIGxldCBzdHJpbmdQcm9wZXJ0eVZhbHVlID0gbnVsbDtcblxuICBjb25zdCBwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlID0gcHJvcGVydHlKU09OU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZVF1ZXJ5KHByb3BlcnR5Tm9kZSk7XG5cbiAgaWYgKHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlQ29udGVudCA9IHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgc3RyaW5nUHJvcGVydHlWYWx1ZSA9IHRyaW1Eb3VibGVRdW90ZXMocHJvcGVydHlKU09OU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZUNvbnRlbnQpOyAvLy9cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdQcm9wZXJ0eVZhbHVlO1xufVxuXG5mdW5jdGlvbiBkb2N1bWVudFByb3BlcnR5Tm9kZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBjb25zdCBkb2N1bWVudFByb3BlcnR5Tm9kZXMgPSBkb2N1bWVudFByb3BlcnR5Tm9kZXNRdWVyeShkb2N1bWVudE5vZGUpO1xuXG4gIHJldHVybiBkb2N1bWVudFByb3BlcnR5Tm9kZXM7XG59XG5cbmZ1bmN0aW9uIGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSB7XG4gIGxldCBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBudWxsO1xuXG4gIGNvbnN0IGRvY3VtZW50UHJvcGVydHlOb2RlcyA9IGRvY3VtZW50UHJvcGVydHlOb2Rlc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBkb2N1bWVudFByb3BlcnR5Tm9kZXMuc29tZSgoZG9jdW1lbnRQcm9wZXJ0eU5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBkb2N1bWVudFByb3BlcnR5Tm9kZSwgIC8vL1xuICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09IERFUEVOREVOQ0lFU19QUk9QRVJUWV9OQU1FKSB7XG4gICAgICBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBwcm9wZXJ0eU5vZGU7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB2ZXJzaW9uRnJvbURvY3VtZW50Tm9kZSwgcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUsIGRlcGVuZGVuY2llc0Zyb21Eb2N1bWVudE5vZGUsIGRlcGVuZGVuY3lOYW1lc0Zyb21Eb2N1bWVudE5vZGUsIGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL21ldGFKU09OXCI7XG5cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgIGRvY3VtZW50Tm9kZSA9IGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSxcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb25Gcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbmZ1bmN0aW9uIGdldFJlcG9zaXRvcnkoKSB7XG4gIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgIGRvY3VtZW50Tm9kZSA9IGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSxcbiAgICAgICAgcmVwb3NpdG9yeSA9IHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHJlcG9zaXRvcnk7XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcygpIHtcbiAgY29uc3QgbWV0YUpTT05GaWxlID0gdGhpcy5nZXRNZXRhSlNPTkZpbGUoKSxcbiAgICAgICAgZG9jdW1lbnROb2RlID0gZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZShtZXRhSlNPTkZpbGUpLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGRlcGVuZGVuY2llcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeU5hbWVzKCkge1xuICBjb25zdCBtZXRhSlNPTkZpbGUgPSB0aGlzLmdldE1ldGFKU09ORmlsZSgpLFxuICAgICAgICBkb2N1bWVudE5vZGUgPSBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSksXG4gICAgICAgIGRlcGVuZGVuY3lOYW1lcyA9IGRlcGVuZGVuY3lOYW1lc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICByZXR1cm4gZGVwZW5kZW5jeU5hbWVzO1xufVxuXG5jb25zdCBtZXRhSlNPTk1peGlucyA9IHtcbiAgZ2V0VmVyc2lvbixcbiAgZ2V0UmVwb3NpdG9yeSxcbiAgZ2V0RGVwZW5kZW5jaWVzLFxuICBnZXREZXBlbmRlbmN5TmFtZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1ldGFKU09OTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBmaWxlTmFtZUZyb21GaWxlUGF0aCB9IGZyb20gXCIuLi91dGlsaXRpZXMvbmFtZVwiO1xuaW1wb3J0IHsgVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSwgU1lNQk9MX1ZPQ0FCVUxBUllfRklMRV9OQU1FIH0gZnJvbSBcIi4uL2ZpbGVOYW1lc1wiO1xuXG5mdW5jdGlvbiBnZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlGaWxlTmFtZSkge1xuICBsZXQgdm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORztcblxuICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzID0gdGhpcy5nZXRDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzKCksXG4gICAgICAgIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMuZmluZCgoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGggPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVOYW1lID0gZmlsZU5hbWVGcm9tRmlsZVBhdGgoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZU5hbWUgPT09IHZvY2FidWxhcnlGaWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVDb250ZW50ID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlLmdldENvbnRlbnQoKTtcblxuICAgIHZvY2FidWxhcnkgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVDb250ZW50OyAgLy8vXG4gIH1cblxuICByZXR1cm4gdm9jYWJ1bGFyeTtcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZVZvY2FidWxhcnkoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSwgLy8vXG4gICAgICAgIHZvY2FidWxhcnkgPSB0aGlzLmdldFZvY2FidWxhcnkoZmlsZU5hbWUpLFxuICAgICAgICB0eXBlVm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7ICAvLy9cblxuICByZXR1cm4gdHlwZVZvY2FidWxhcnk7XG59XG5cbmZ1bmN0aW9uIGdldFN5bWJvbFZvY2FidWxhcnkoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gU1lNQk9MX1ZPQ0FCVUxBUllfRklMRV9OQU1FLCAvLy9cbiAgICAgICAgdm9jYWJ1bGFyeSA9IHRoaXMuZ2V0Vm9jYWJ1bGFyeShmaWxlTmFtZSksXG4gICAgICAgIHN5bWJvbFZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5OyAgLy8vXG5cbiAgcmV0dXJuIHN5bWJvbFZvY2FidWxhcnk7XG59XG5cbmNvbnN0IHZvY2FidWxhcnlNaXhpbnMgPSAge1xuICBnZXRWb2NhYnVsYXJ5LFxuICBnZXRUeXBlVm9jYWJ1bGFyeSxcbiAgZ2V0U3ltYm9sVm9jYWJ1bGFyeVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdm9jYWJ1bGFyeU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGF0aFV0aWxpdGllcywgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBGaWxlIGZyb20gXCIuL2ZpbGVcIjtcbmltcG9ydCBGaWxlcyBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0IERpcmVjdG9yeSBmcm9tIFwiLi9kaXJlY3RvcnlcIjtcbmltcG9ydCBibmZNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2JuZlwiO1xuaW1wb3J0IGZpbGVzTWl4aW5zIGZyb20gXCIuL21peGlucy9maWxlc1wiO1xuaW1wb3J0IG1ldGFKU09OTWl4aW5zIGZyb20gXCIuL21peGlucy9tZXRhSlNPTlwiO1xuaW1wb3J0IHZvY2FidWxhcnlNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3ZvY2FidWxhcnlcIjtcblxuY29uc3QgeyBmaXJzdCwgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aCB9ID0gcGF0aFV0aWxpdGllcztcblxuY2xhc3MgRW50cmllcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRUb3Btb3N0RGlyZWN0b3J5TmFtZSgpIHtcbiAgICBsZXQgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IGZpcnN0RW50cnkgPSBmaXJzdCh0aGlzLmFycmF5KTsgLy8vXG5cbiAgICBpZiAoZmlyc3RFbnRyeSkgeyAvLy9cbiAgICAgIGNvbnN0IGZpcnN0RW50cnlQYXRoID0gZmlyc3RFbnRyeS5nZXRQYXRoKCk7XG5cbiAgICAgIHRvcG1vc3REaXJlY3RvcnlOYW1lID0gdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aChmaXJzdEVudHJ5UGF0aCk7XG5cbiAgICAgIGlmICh0b3Btb3N0RGlyZWN0b3J5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IGZpcnN0RW50cnlQYXRoOyAgLy8vXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlOYW1lO1xuICB9XG5cbiAgcmVtb3ZlRmlsZUJ5UGF0aChwYXRoKSB7XG4gICAgZmlsdGVyKHRoaXMuYXJyYXksIChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgZW50cnlGaWxlID0gZW50cnkuaXNGaWxlKCk7XG5cbiAgICAgIGlmIChlbnRyeUZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGVudHJ5LCAvLy9cbiAgICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKTtcblxuICAgICAgICBpZiAoZmlsZVBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBmaW5kRmlsZShmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICAgIGZpbGUgPSBmaWxlcy5maW5kRmlsZSgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGhNYXRjaGVzID0gZmlsZS5tYXRjaEZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgICAgICAgICAgaWYgKGZpbGVQYXRoTWF0Y2hlcykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICBnZXRGaWxlcygpIHtcbiAgICBjb25zdCBmaWxlcyA9IEZpbGVzLmZyb21Ob3RoaW5nKCk7XG5cbiAgICB0aGlzLm1hcEVudHJ5KChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgZW50cnlGaWxlID0gZW50cnkuaXNGaWxlKCk7XG5cbiAgICAgIGlmIChlbnRyeUZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGVudHJ5OyAvLy9cblxuICAgICAgICBmaWxlcy5hZGRGaWxlKGZpbGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbGVzO1xuICB9XG5cbiAgZ2V0RmlsZVBhdGhzKCkge1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IHRoaXMucmVkdWNlRW50cnkoKGZpbGVQYXRocywgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5RmlsZSA9IGVudHJ5LmlzRmlsZSgpO1xuXG4gICAgICBpZiAoZW50cnlGaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBlbnRyeSwgLy8vXG4gICAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCk7XG5cbiAgICAgICAgZmlsZVBhdGhzLnB1c2goZmlsZVBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsZVBhdGhzO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBmaWxlUGF0aHM7XG4gIH1cblxuICBnZXREaXJlY3RvcnlQYXRocygpIHtcbiAgICBjb25zdCBkaXJlY3RvcnlQYXRocyA9IHRoaXMucmVkdWNlRW50cnkoKGRpcmVjdG9yeVBhdGhzLCBlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgZW50cnlEaXJlY3RvcnkgPSBlbnRyeS5pc0RpcmVjdG9yeSgpO1xuXG4gICAgICBpZiAoZW50cnlEaXJlY3RvcnkpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0gZW50cnksIC8vL1xuICAgICAgICAgICAgICBkaXJlY3RvcnlQYXRoID0gZGlyZWN0b3J5LmdldFBhdGgoKTtcblxuICAgICAgICBkaXJlY3RvcnlQYXRocy5wdXNoKGRpcmVjdG9yeVBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0b3J5UGF0aHM7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIGRpcmVjdG9yeVBhdGhzO1xuICB9XG5cbiAgbWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5nZXRWZXJzaW9uKCksXG4gICAgICAgICAgdmVyc2lvbk1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uID0gdmVyc2lvbi5tYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbik7XG5cbiAgICByZXR1cm4gdmVyc2lvbk1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uO1xuICB9XG5cbiAgYWRkRmlsZShmaWxlKSB7XG4gICAgY29uc3QgZW50cnkgPSBmaWxlOyAvLy9cblxuICAgIHRoaXMuYWRkRW50cnkoZW50cnkpO1xuICB9XG5cbiAgYWRkRW50cnkoZW50cnkpIHsgdGhpcy5hcnJheS5wdXNoKGVudHJ5KTsgfVxuXG4gIGFkZERpcmVjdG9yeShkaXJlY3RvcnkpIHtcbiAgICBjb25zdCBlbnRyeSA9IGRpcmVjdG9yeTsgIC8vL1xuXG4gICAgdGhpcy5hZGRFbnRyeShlbnRyeSk7XG4gIH1cblxuICBmb3JFYWNoRmlsZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpO1xuXG4gICAgZmlsZXMuZm9yRWFjaEZpbGUoY2FsbGJhY2spO1xuICB9XG5cbiAgbWFwRW50cnkoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkubWFwKGNhbGxiYWNrKTsgfVxuXG4gIHNvbWVFbnRyeShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5zb21lKGNhbGxiYWNrKTsgfVxuXG4gIGV2ZXJ5RW50cnkoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuZXZlcnkoY2FsbGJhY2spOyB9XG5cbiAgZm9yRWFjaEVudHJ5KGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICByZWR1Y2VFbnRyeShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmFycmF5LnJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKTsgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlbnRyaWVzSlNPTiA9IHRoaXMuYXJyYXkubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cnlKU09OID0gZW50cnkudG9KU09OKCk7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5SlNPTjtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBqc29uID0gZW50cmllc0pTT047IC8vL1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBFbnRyaWVzKGFycmF5KSxcbiAgICAgICAgICBlbnRyaWVzSlNPTiA9IGpzb247IC8vL1xuXG4gICAgZW50cmllc0pTT04ubWFwKChlbnRyeUpTT04pID0+IHtcbiAgICAgIGNvbnN0IGpzb24gPSBlbnRyeUpTT04sIC8vL1xuICAgICAgICAgICAgZmlsZSA9IEZpbGUuZnJvbUpTT04oanNvbiksXG4gICAgICAgICAgICBkaXJlY3RvcnkgPSBEaXJlY3RvcnkuZnJvbUpTT04oanNvbiksXG4gICAgICAgICAgICBlbnRyeSA9IGZpbGUgfHwgZGlyZWN0b3J5OyAgLy8vXG5cbiAgICAgIGVudHJpZXMuYWRkRW50cnkoZW50cnkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbUVudHJ5KGVudHJ5KSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXG4gICAgICAgICAgICBlbnRyeVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBFbnRyaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBFbnRyaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oRW50cmllcy5wcm90b3R5cGUsIGJuZk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCBmaWxlc01peGlucyk7XG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCBtZXRhSlNPTk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCB2b2NhYnVsYXJ5TWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgRW50cmllcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZm9yRWFjaEZpbGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuZW50cmllcy5mb3JFYWNoRmlsZShjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gZmluZEZpbGUoZmlsZVBhdGgpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5maW5kRmlsZShmaWxlUGF0aCk7IH1cblxuZnVuY3Rpb24gZ2V0Qk5GKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEJORigpOyB9XG5cbmZ1bmN0aW9uIGdldEZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEZpbGVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0VGVybUJORigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRUZXJtQk5GKCk7IH1cblxuZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRWZXJzaW9uKCk7IH1cblxuZnVuY3Rpb24gZ2V0RmlsZVBhdGhzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEZpbGVQYXRocygpOyB9XG5cbmZ1bmN0aW9uIGdldFZvY2FidWxhcnkoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0Vm9jYWJ1bGFyeSgpOyB9XG5cbmZ1bmN0aW9uIGdldFJlcG9zaXRvcnkoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0UmVwb3NpdG9yeSgpOyB9XG5cbmZ1bmN0aW9uIGdldFJlYWRtZUZpbGUoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0UmVhZG1lRmlsZSgpOyB9XG5cbmZ1bmN0aW9uIGdldFN0YXRlbWVudEJORigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRTdGF0ZW1lbnRCTkYoKTsgfVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGVwZW5kZW5jaWVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0VHlwZVZvY2FidWxhcnkoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0VHlwZVZvY2FidWxhcnkoKTsgfVxuXG5mdW5jdGlvbiBnZXRTeW1ib2xWb2NhYnVsYXJ5KCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldFN5bWJvbFZvY2FidWxhcnkoKTsgfVxuXG5mdW5jdGlvbiBnZXRNZXRhSlNPTkZpbGUoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0TWV0YUpTT05GaWxlKCk7IH1cblxuZnVuY3Rpb24gZ2V0RnVydGxlRmlsZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RnVydGxlRmlsZXMoKTsgfVxuXG5mdW5jdGlvbiBnZXROb21pbmFsRmlsZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0Tm9taW5hbEZpbGVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0b3J5UGF0aHMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGlyZWN0b3J5UGF0aHMoKTsgfVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5TmFtZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGVwZW5kZW5jeU5hbWVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0Q3VzdG9tR3JhbW1hckJORkZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcygpOyB9XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0Q3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcygpOyB9XG5cbmNvbnN0IGVudHJpZXNNaXhpbnMgPSB7XG4gIGZvckVhY2hGaWxlLFxuICBmaW5kRmlsZSxcbiAgZ2V0Qk5GLFxuICBnZXRGaWxlcyxcbiAgZ2V0VGVybUJORixcbiAgZ2V0VmVyc2lvbixcbiAgZ2V0RmlsZVBhdGhzLFxuICBnZXRWb2NhYnVsYXJ5LFxuICBnZXRSZXBvc2l0b3J5LFxuICBnZXRSZWFkbWVGaWxlLFxuICBnZXRTdGF0ZW1lbnRCTkYsXG4gIGdldERlcGVuZGVuY2llcyxcbiAgZ2V0VHlwZVZvY2FidWxhcnksXG4gIGdldFN5bWJvbFZvY2FidWxhcnksXG4gIGdldE1ldGFKU09ORmlsZSxcbiAgZ2V0RnVydGxlRmlsZXMsXG4gIGdldE5vbWluYWxGaWxlcyxcbiAgZ2V0RGlyZWN0b3J5UGF0aHMsXG4gIGdldERlcGVuZGVuY3lOYW1lcyxcbiAgZ2V0Q3VzdG9tR3JhbW1hckJORkZpbGVzLFxuICBnZXRDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5pbXBvcnQgZW50cmllc01peGlucyBmcm9tIFwiLi9taXhpbnMvZW50cmllc1wiO1xuXG5jbGFzcyBQcm9qZWN0IHtcbiAgY29uc3RydWN0b3IobmFtZSwgZW50cmllcykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlbnRyaWVzSlNPTiA9IHRoaXMuZW50cmllcy50b0pTT04oKSxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzSlNPTiwgIC8vL1xuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZW50cmllc1xuICAgICAgICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgbGV0IHsgZW50cmllcyB9ID0ganNvbjtcblxuICAgIGNvbnN0IHsgbmFtZSB9ID0ganNvbixcbiAgICAgICAgICBlbnRyaWVzSlNPTiA9IGVudHJpZXM7ICAvLy9cblxuICAgIGpzb24gPSBlbnRyaWVzSlNPTjsgLy8vXG5cbiAgICBlbnRyaWVzID0gRW50cmllcy5mcm9tSlNPTihqc29uKTsgLy8vXG5cbiAgICBjb25zdCBwcm9qZWN0ID0gbmV3IFByb2plY3QobmFtZSwgZW50cmllcyk7XG5cbiAgICByZXR1cm4gcHJvamVjdDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgY29uc3QgZW50cmllcyA9IEVudHJpZXMuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBwcm9qZWN0ID0gbmV3IFByb2plY3QobmFtZSwgZW50cmllcyk7XG5cbiAgICByZXR1cm4gcHJvamVjdDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZUFuZEVudHJpZXMobmFtZSwgZW50cmllcykge1xuICAgIGNvbnN0IHByb2plY3QgPSBuZXcgUHJvamVjdChuYW1lLCBlbnRyaWVzKTtcblxuICAgIHJldHVybiBwcm9qZWN0O1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oUHJvamVjdC5wcm90b3R5cGUsIGVudHJpZXNNaXhpbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRmlsZSBmcm9tIFwiLi9maWxlXCI7XG5pbXBvcnQgRW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5pbXBvcnQgZW50cmllc01peGlucyBmcm9tIFwiLi9taXhpbnMvZW50cmllc1wiO1xuXG5pbXBvcnQgeyBET1VCTEVfU1BBQ0UgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGlzTWV0YUpTT05GaWxlVmFsaWQgfSBmcm9tIFwiLi91dGlsaXRpZXMvbWV0YUpTT05cIjtcbmltcG9ydCB7IGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGggfSBmcm9tIFwiLi91dGlsaXRpZXMvZmlsZVBhdGhcIjtcbmltcG9ydCB7IHJlYWRtZUZpbGVGcm9tRmlsZXMsIG1ldGFKU09ORmlsZUZyb21GaWxlcyB9IGZyb20gXCIuL3V0aWxpdGllcy9maWxlc1wiO1xuXG5jbGFzcyBSZWxlYXNlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgZW50cmllcykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgfVxuXG4gIHVwZGF0ZVZlcnNpb24odmVyc2lvbikge1xuICAgIGxldCByZXBvc2l0b3J5ID0gdGhpcy5nZXRSZXBvc2l0b3J5KCksXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKCk7XG5cbiAgICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAgIHJlcG9zaXRvcnlKU09OID0gcmVwb3NpdG9yeSwgIC8vL1xuICAgICAgICAgIGRlcGVuZGVuY2llc0pTT04gPSBkZXBlbmRlbmNpZXMudG9KU09OKCk7XG5cbiAgICB2ZXJzaW9uID0gdmVyc2lvblN0cmluZzsgIC8vL1xuICAgIHJlcG9zaXRvcnkgPSByZXBvc2l0b3J5SlNPTjsgIC8vL1xuICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc0pTT047ICAvLy9cblxuICAgIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICByZXBvc2l0b3J5LFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgRE9VQkxFX1NQQUNFKSxcbiAgICAgICAgICBmaWxlID0gbWV0YUpTT05GaWxlLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IGpzb25TdHJpbmc7IC8vL1xuXG4gICAgZmlsZS5zZXRDb250ZW50KGNvbnRlbnQpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGVudHJpZXNKU09OID0gdGhpcy5lbnRyaWVzLnRvSlNPTigpLFxuICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgICAgZW50cmllcyA9IGVudHJpZXNKU09OLCAgLy8vXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlbnRyaWVzXG4gICAgICAgICAgfTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBsZXQgeyBlbnRyaWVzIH0gPSBqc29uO1xuXG4gICAgY29uc3QgeyBuYW1lIH0gPSBqc29uLFxuICAgICAgICAgIGVudHJpZXNKU09OID0gZW50cmllczsgIC8vL1xuXG4gICAganNvbiA9IGVudHJpZXNKU09OOyAvLy9cblxuICAgIGVudHJpZXMgPSBFbnRyaWVzLmZyb21KU09OKGpzb24pOyAvLy9cblxuICAgIGNvbnN0IHJlbGVhc2UgPSBuZXcgUmVsZWFzZShuYW1lLCBlbnRyaWVzKTtcblxuICAgIHJldHVybiByZWxlYXNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21Qcm9qZWN0KHByb2plY3QpIHtcbiAgICBsZXQgcmVsZWFzZSA9IG51bGwsXG4gICAgICAgIGVudHJpZXMgPSBwcm9qZWN0LmdldEVudHJpZXMoKTtcblxuICAgIGNvbnN0IGVudHJpZXNSZWxlYXNhYmxlID0gYXJlRW50cmllc1JlbGVhc2FibGUoZW50cmllcyk7XG5cbiAgICBpZiAoZW50cmllc1JlbGVhc2FibGUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwcm9qZWN0LmdldE5hbWUoKSxcbiAgICAgICAgICAgIHJlbGVhc2VkRW50cmllcyA9IHJlbGVhc2VFbnRyaWVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgICAgIGVudHJpZXMgPSByZWxlYXNlZEVudHJpZXM7ICAvLy9cblxuICAgICAgcmVsZWFzZSA9IG5ldyBSZWxlYXNlKG5hbWUsIGVudHJpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWxlYXNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKSB7XG4gICAgbGV0IHJlbGVhc2UgPSBudWxsO1xuXG4gICAgY29uc3QgZW50cmllc1JlbGVhc2FibGUgPSBhcmVFbnRyaWVzUmVsZWFzYWJsZShlbnRyaWVzKTtcblxuICAgIGlmIChlbnRyaWVzUmVsZWFzYWJsZSkge1xuICAgICAgcmVsZWFzZSA9IG5ldyBSZWxlYXNlKG5hbWUsIGVudHJpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWxlYXNlO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oUmVsZWFzZS5wcm90b3R5cGUsIGVudHJpZXNNaXhpbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBSZWxlYXNlO1xuXG5mdW5jdGlvbiByZWxlYXNlRW50cmllc0Zyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgY29uc3QgcmVsZWFzZWRFbnRyaWVzID0gRW50cmllcy5mcm9tTm90aGluZygpLCAgLy8vXG4gICAgICAgIGZpbGVzID0gZW50cmllcy5nZXRGaWxlcygpO1xuXG4gIGZpbGVzLmZvckVhY2hGaWxlKChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBmaWxlUGF0aFJlbGVhc2VGaWxlUGF0aCA9IGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgaWYgKGZpbGVQYXRoUmVsZWFzZUZpbGVQYXRoKSB7XG4gICAgICBjb25zdCBwYXRoID0gZmlsZVBhdGgsICAvLy9cbiAgICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcblxuICAgICAgZmlsZSA9IEZpbGUuZnJvbVBhdGhDb250ZW50QW5kUmVsZWFzZWQocGF0aCwgY29udGVudCwgcmVsZWFzZWQpOyAgLy8vXG5cbiAgICAgIHJlbGVhc2VkRW50cmllcy5hZGRGaWxlKGZpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlbGVhc2VkRW50cmllcztcbn1cblxuZnVuY3Rpb24gYXJlRW50cmllc1JlbGVhc2FibGUoZW50cmllcykge1xuICBsZXQgZW50cmllc1JlbGVhc2FibGUgPSBmYWxzZTtcblxuICBjb25zdCBmaWxlcyA9IGVudHJpZXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgcmVhZG1lRmlsZSA9IHJlYWRtZUZpbGVGcm9tRmlsZXMoZmlsZXMpLFxuICAgICAgICBtZXRhSlNPTkZpbGUgPSBtZXRhSlNPTkZpbGVGcm9tRmlsZXMoZmlsZXMpO1xuXG4gIGlmICgocmVhZG1lRmlsZSAhPT0gbnVsbCkgJiYgKG1ldGFKU09ORmlsZSAhPT0gbnVsbCkpIHtcbiAgICBjb25zdCBtZXRhSlNPTkZpbGVWYWxpZCA9IGlzTWV0YUpTT05GaWxlVmFsaWQobWV0YUpTT05GaWxlKTtcblxuICAgIGlmIChtZXRhSlNPTkZpbGVWYWxpZCkge1xuICAgICAgZW50cmllc1JlbGVhc2FibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbnRyaWVzUmVsZWFzYWJsZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUHJvamVjdCBmcm9tIFwiLi9wcm9qZWN0XCI7XG5cbmNvbnN0IHsgZm9yRWFjaCB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0cyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7IHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDsgfVxuXG4gIGFkZFByb2plY3QocHJvamVjdCkgeyB0aGlzLmFycmF5LnB1c2gocHJvamVjdCk7IH1cblxuICBtYXBQcm9qZWN0KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICByZWR1Y2VQcm9qZWN0KGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHsgcmV0dXJuIHRoaXMuYXJyYXkucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbiAgZm9yRWFjaFByb2plY3QoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGFzeW5jaHJvbm91c0ZvckVhY2hQcm9qZWN0KGNhbGxiYWNrLCBkb25lKSB7IGZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2ssIGRvbmUpOyB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmFycmF5Lm1hcCgocHJvamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHJvamVjdEpTT04gPSBwcm9qZWN0LnRvSlNPTigpO1xuXG4gICAgICByZXR1cm4gcHJvamVjdEpTT047XG4gICAgfSk7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgYXJyYXkgPSBqc29uLm1hcCgoanNvbikgPT4geyAgLy8vXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gUHJvamVjdC5mcm9tSlNPTihqc29uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJvamVjdHMgPSBuZXcgUHJvamVjdHMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHByb2plY3RzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgcHJvamVjdHMgPSBuZXcgUHJvamVjdHMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHByb2plY3RzO1xuICB9XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUmVsZWFzZSBmcm9tIFwiLi9yZWxlYXNlXCI7XG5cbmNvbnN0IHsgZm9yRWFjaCB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxlYXNlcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7IHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDsgfVxuXG4gIGFkZFJlbGVhc2UocmVsZWFzZSkgeyB0aGlzLmFycmF5LnB1c2gocmVsZWFzZSk7IH1cblxuICBtYXBSZWxlYXNlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICByZWR1Y2VSZWxlYXNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHsgcmV0dXJuIHRoaXMuYXJyYXkucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbiAgZm9yRWFjaFJlbGVhc2UoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGFzeW5jaHJvbm91c0ZvckVhY2hSZWxlYXNlKGNhbGxiYWNrLCBkb25lKSB7IGZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2ssIGRvbmUpOyB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmFycmF5Lm1hcCgocmVsZWFzZSkgPT4ge1xuICAgICAgY29uc3QgcmVsZWFzZUpTT04gPSByZWxlYXNlLnRvSlNPTigpO1xuXG4gICAgICByZXR1cm4gcmVsZWFzZUpTT047XG4gICAgfSk7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgYXJyYXkgPSBqc29uLm1hcCgoanNvbikgPT4geyAgLy8vXG4gICAgICAgICAgICBjb25zdCByZWxlYXNlID0gUmVsZWFzZS5mcm9tSlNPTihqc29uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2U7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcmVsZWFzZXMgPSBuZXcgUmVsZWFzZXMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHJlbGVhc2VzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgcmVsZWFzZXMgPSBuZXcgUmVsZWFzZXMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHJlbGVhc2VzO1xuICB9XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlIH0gZnJvbSBcIi4vZmlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlcyB9IGZyb20gXCIuL2ZpbGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFZlcnNpb24gfSBmcm9tIFwiLi92ZXJzaW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVudHJpZXMgfSBmcm9tIFwiLi9lbnRyaWVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2plY3QgfSBmcm9tIFwiLi9wcm9qZWN0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlbGVhc2UgfSBmcm9tIFwiLi9yZWxlYXNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2plY3RzIH0gZnJvbSBcIi4vcHJvamVjdHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVsZWFzZXMgfSBmcm9tIFwiLi9yZWxlYXNlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaXJlY3RvcnkgfSBmcm9tIFwiLi9kaXJlY3RvcnlcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmlsZU5hbWVzIH0gZnJvbSBcIi4vZmlsZU5hbWVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlcGVuZGVuY3kgfSBmcm9tIFwiLi9kZXBlbmRlbmN5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlcGVuZGVuY2llcyB9IGZyb20gXCIuL2RlcGVuZGVuY2llc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaG9ydGVuZWRWZXJzaW9uIH0gZnJvbSBcIi4vc2hvcnRlbmVkVmVyc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb250ZW50VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmlsZVBhdGhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZmlsZVBhdGhcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWV0YUpTT05VdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvbWV0YUpTT05cIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRW50cmllcywgbWV0YUpTT05VdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbW9kZWxcIjtcblxuaW1wb3J0IFJlbGVhc2VDb250ZXh0IGZyb20gXCIuLi9jb250ZXh0L3JlbGVhc2VcIjtcblxuaW1wb3J0IHsgY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY3VzdG9tR3JhbW1hclwiO1xuXG5jb25zdCB7IGlzTWV0YUpTT05GaWxlVmFsaWQgfSA9IG1ldGFKU09OVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZUNvbnRleHRGcm9tSlNPTihqc29uLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgbG9nLCBjYWxsYmFjayB9ID0gY29udGV4dCxcbiAgICAgICAgeyBuYW1lIH0gPSBqc29uO1xuXG4gIGxldCB7IGVudHJpZXMgfSA9IGpzb247XG5cbiAgKHtjb250ZXh0fSA9IGpzb24pOyAvLy9cblxuICBqc29uID0gZW50cmllczsgLy8vXG5cbiAgZW50cmllcyA9IEVudHJpZXMuZnJvbUpTT04oanNvbik7XG5cbiAgY29uc3QgY29udGV4dEpTT04gPSBjb250ZXh0OyAgLy8vXG5cbiAganNvbiA9IGNvbnRleHRKU09OOyAvLy9cblxuICBjb25zdCBjdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKSxcbiAgICAgICAgcmVsZWFzZUNvbnRleHQgPSBSZWxlYXNlQ29udGV4dC5mcm9tTG9nTmFtZUpTT05FbnRyaWVzQ2FsbGJhY2tBbmRDdXN0b21HcmFtbWFyKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIpO1xuXG4gIHJldHVybiByZWxlYXNlQ29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VDb250ZXh0RnJvbVByb2plY3QocHJvamVjdCwgY29udGV4dCkge1xuICBsZXQgcmVsZWFzZUNvbnRleHQgPSBudWxsO1xuXG4gIGlmIChwcm9qZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgbWV0YUpTT05GaWxlID0gcHJvamVjdC5nZXRNZXRhSlNPTkZpbGUoKTtcblxuICAgIGlmIChtZXRhSlNPTkZpbGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1ldGFKU09ORmlsZVZhbGlkID0gaXNNZXRhSlNPTkZpbGVWYWxpZChtZXRhSlNPTkZpbGUpO1xuXG4gICAgICBpZiAobWV0YUpTT05GaWxlVmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBsb2csIGNhbGxiYWNrIH0gPSBjb250ZXh0LFxuICAgICAgICAgICAgICBuYW1lID0gcHJvamVjdC5nZXROYW1lKCksXG4gICAgICAgICAgICAgIGpzb24gPSBudWxsLFxuICAgICAgICAgICAgICBlbnRyaWVzID0gcHJvamVjdC5nZXRFbnRyaWVzKCksXG4gICAgICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBjdXN0b21HcmFtbWFyRnJvbU5hbWVBbmRFbnRyaWVzKG5hbWUsIGVudHJpZXMpO1xuXG4gICAgICAgIHJlbGVhc2VDb250ZXh0ID0gUmVsZWFzZUNvbnRleHQuZnJvbUxvZ05hbWVKU09ORW50cmllc0NhbGxiYWNrQW5kQ3VzdG9tR3JhbW1hcihsb2csIG5hbWUsIGpzb24sIGVudHJpZXMsIGNhbGxiYWNrLCBjdXN0b21HcmFtbWFyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZUNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxlYXNlQ29udGV4dEZyb21SZWxlYXNlKHJlbGVhc2UsIGNvbnRleHQpIHtcbiAgbGV0IHJlbGVhc2VDb250ZXh0ID0gbnVsbDtcblxuICBpZiAocmVsZWFzZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHsgbG9nLCBjYWxsYmFjayB9ID0gY29udGV4dCxcbiAgICAgICAgICBuYW1lID0gcmVsZWFzZS5nZXROYW1lKCksXG4gICAgICAgICAganNvbiA9IG51bGwsXG4gICAgICAgICAgZW50cmllcyA9IHJlbGVhc2UuZ2V0RW50cmllcygpLFxuICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBjdXN0b21HcmFtbWFyRnJvbU5hbWVBbmRFbnRyaWVzKG5hbWUsIGVudHJpZXMpO1xuXG4gICAgcmVsZWFzZUNvbnRleHQgPSBSZWxlYXNlQ29udGV4dC5mcm9tTG9nTmFtZUpTT05FbnRyaWVzQ2FsbGJhY2tBbmRDdXN0b21HcmFtbWFyKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VDb250ZXh0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlbGVhc2VDb250ZXh0RnJvbUpTT04sXG4gIHJlbGVhc2VDb250ZXh0RnJvbVByb2plY3QsXG4gIHJlbGVhc2VDb250ZXh0RnJvbVJlbGVhc2Vcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9nIH0gZnJvbSBcIi4vbG9nXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZW1lbnQgfSBmcm9tIFwiLi9lbGVtZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRleHQgfSBmcm9tIFwiLi9jb250ZXh0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGVDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9maWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlbGVhc2VDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9yZWxlYXNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL25vblRlcm1pbmFsTm9kZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFppcFBhc3MgfSBmcm9tIFwiLi9wYXNzL3ppcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBc3luY1Bhc3MgfSBmcm9tIFwiLi9wYXNzL2FzeW5jXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbXBsZVBhc3MgfSBmcm9tIFwiLi9wYXNzL3NpbXBsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3J3YXJkUGFzcyB9IGZyb20gXCIuL3Bhc3MvZm9yd2FyZFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFcXVpdmFsZW5jZVBhc3MgfSBmcm9tIFwiLi9wYXNzL2VxdWl2YWxlbmNlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9kZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHF1ZXJ5VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbGVDb250ZXh0VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2ZpbGVDb250ZXh0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcmlmaWNhdGlvblV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy92ZXJpZmljYXRpb25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWxlYXNlQ29udGV4dFV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9yZWxlYXNlQ29udGV4dFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBlbGVtZW50cyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lKEVsZW1lbnQpIHtcbiAgY29uc3QgeyBuYW1lIH0gPSBFbGVtZW50O1xuXG4gIGVsZW1lbnRzW25hbWVdID0gRWxlbWVudDtcblxuICByZXR1cm4gRWxlbWVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudHM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgU3RlcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5QXNzaWdubWVudCwgb2JqZWN0QXNzaWdtZW50LCB2YXJpYWJsZXNzQXNzaWdubWVudCkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMuYXJyYXlBc3NpZ25tZW50ID0gYXJyYXlBc3NpZ25tZW50O1xuICAgIHRoaXMub2JqZWN0QXNzaWdtZW50ID0gb2JqZWN0QXNzaWdtZW50O1xuICAgIHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQgPSB2YXJpYWJsZXNzQXNzaWdubWVudDtcbiAgfVxuXG4gIGdldEFycmF5QXNzaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheUFzc2lnbm1lbnQ7XG4gIH1cblxuICBnZXRPYmplY3RBc3NpZ21lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0QXNzaWdtZW50O1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzc0Fzc2lnbm1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQ7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMuYXJyYXlBc3NpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFycmF5QXNzaWdubWVudC5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub2JqZWN0QXNzaWdtZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm9iamVjdEFzc2lnbWVudC5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIGF3YWl0IHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlN0ZXBcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIGdldE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgZXhjZXB0aW9uID0gbmV3IEV4Y2VwdGlvbihtZXNzYWdlKTtcblxuICAgIHJldHVybiBleGNlcHRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE5PREVfVFlQRSA9IFwiTm9kZVwiO1xuZXhwb3J0IGNvbnN0IE5PREVTX1RZUEUgPSBcIk5vZGVzXCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX1RZUEUgPSBcIlN0cmluZ1wiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUl9UWVBFID0gXCJOdW1iZXJcIjtcbmV4cG9ydCBjb25zdCBCT09MRUFOX1RZUEUgPSBcIkJvb2xlYW5cIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY2xhc3MgTnVsbE5vZGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbnVsbE5vZGUgPSBuZXcgTnVsbE5vZGUoKTtcblxuICAgIHJldHVybiBudWxsTm9kZTtcbiAgfVxufVxuXG5jb25zdCBudWxsTm9kZSA9IE51bGxOb2RlLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBkZWZhdWx0IG51bGxOb2RlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgTlVMTCA9IFwibnVsbFwiO1xuZXhwb3J0IGNvbnN0IFRSVUUgPSBcInRydWVcIjtcbmV4cG9ydCBjb25zdCBGQUxTRSA9IFwiZmFsc2VcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IE5PVF9FUVVBTF9UTyA9IFwiIT1cIjtcbmV4cG9ydCBjb25zdCBDT05KVU5DVElPTl9PUEVSQVRPUiA9IFwiJiZcIjtcbmV4cG9ydCBjb25zdCBESVNKVU5DVElPTl9PUEVSQVRPUiA9IFwifHxcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCkge1xuICBjb25zdCBzdHJpbmcgPSBzdHJpbmdMaXRlcmFsLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdMaXRlcmFsRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgY29uc3Qgc3RyaW5nTGl0ZXJhbCA9IGBcIiR7c3RyaW5nfVwiYDtcblxuICByZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IG51bGxOb2RlIGZyb20gXCIuLi9udWxsTm9kZVwiO1xuXG5pbXBvcnQgeyBOVUxMIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJuYXJ5U3RyaW5nRnJvbVRlcm0odGVybSkge1xuICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgdGVybmFyeVN0cmluZyA9IGBpZiAoJHt0ZXJtU3RyaW5nfSkgeyAuLi4gfSBlbHNlIHsgLi4uIH1gO1xuXG4gIHJldHVybiB0ZXJuYXJ5U3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVTdHJpbmdGcm9tTmFtZShuYW1lKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gbmFtZTsgIC8vL1xuXG4gIHJldHVybiB2YXJpYWJsZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW10aXZlU3RyaW5nRnJvbU5vZGUobm9kZSwgY29udGV4dCkge1xuICBjb25zdCBwcmltdGl2ZVN0cmluZyA9IChub2RlID09PSBudWxsTm9kZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOVUxMIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKTtcblxuICByZXR1cm4gcHJpbXRpdmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltdGl2ZVN0cmluZ0Zyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCBzdHJpbmcgPSBjb250ZXh0Lm5vZGVzQXNTdHJpbmcobm9kZXMpLFxuICAgICAgICBwcmltdGl2ZVN0cmluZyA9IHN0cmluZzsgIC8vL1xuXG4gIHJldHVybiBwcmltdGl2ZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1TdHJpbmdGcm9tUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCB0ZXJtU3RyaW5nO1xuXG4gIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICBpZiAocHJvcGVydHkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5U3RyaW5nID0gcHJvcGVydHkuZ2V0U3RyaW5nKCk7XG5cbiAgICAgIHRlcm1TdHJpbmcgPSBwcm9wZXJ0eVN0cmluZzsgIC8vL1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1TdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltdGl2ZVN0cmluZ0Zyb21Cb29sZWFuKGJvb2xlYW4pIHtcbiAgY29uc3QgZXhwcmVzc3Npb25TdHJpbmcgPSBgJHtib29sZWFufWA7XG5cbiAgcmV0dXJuIGV4cHJlc3NzaW9uU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5KSB7XG4gIGNvbnN0IHRlcm1zU3RyaW5nID0gdGVybXNBcnJheS5yZWR1Y2UoKHRlcm1zU3RyaW5nLCB0ZXJtKSA9PiB7XG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICB0ZXJtc1N0cmluZyA9ICh0ZXJtc1N0cmluZyA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICB0ZXJtU3RyaW5nIDpcbiAgICAgICAgICAgICAgICAgICAgIGAke3Rlcm1zU3RyaW5nfSwgJHt0ZXJtU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gdGVybXNTdHJpbmc7XG4gIH0sIG51bGwpOyAvLy9cblxuICByZXR1cm4gdGVybXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uU3RyaW5nRnJvbVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICBsZXQgZXhwcmVzc2lvblN0cmluZztcblxuICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgaWYgKHByb3BlcnR5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eVN0cmluZyA9IHByb3BlcnR5LmdldFN0cmluZygpO1xuXG4gICAgICBleHByZXNzaW9uU3RyaW5nID0gcHJvcGVydHlTdHJpbmc7ICAvLy9cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBleHByZXNzaW9uU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbXRpdmVTdHJpbmdGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsKSB7XG4gIGNvbnN0IHN0cmluZyA9IHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwpLFxuICAgICAgICBwcmltdGl2ZVN0cmluZyA9IHN0cmluZzsgIC8vL1xuXG4gIHJldHVybiBwcmltdGl2ZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVQcm9wZXJ0eVN0cmluZ0Zyb21OYW1lQW5kVHlwZShuYW1lLCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVTdHJpbmcgPSB0eXBlLCAgLy8vXG4gICAgICAgIG5hbWVTdHJpbmcgPSBuYW1lLCAgLy8vXG4gICAgICAgIG5vZGVQcm9wZXJ0eVN0cmluZyA9IGAke3R5cGVTdHJpbmd9ICR7bmFtZVN0cmluZ31gO1xuXG4gIHJldHVybiBub2RlUHJvcGVydHlTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZ0Zyb21Qcm9jZWR1cmUocHJvY2VkdXJlKSB7XG4gIGNvbnN0IHR5cGUgPSBwcm9jZWR1cmUuZ2V0VHlwZSgpLFxuICAgICAgICBsYWJlbCA9IHByb2NlZHVyZS5nZXRMYWJlbCgpLFxuICAgICAgICBwYXJhbWV0ZXJzID0gcHJvY2VkdXJlLmdldFBhcmFtZXRlcnMoKSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50ID0gcHJvY2VkdXJlLmdldFJldHVyblN0YXRlbWVudCgpLFxuICAgICAgICBsYWJlbFN0cmluZyA9IGxhYmVsLmdldFN0cmluZygpLFxuICAgICAgICBwYXJhbWV0ZXJzU3RyaW5nID0gcGFyYW1ldGVycy5nZXRTdHJpbmcoKSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50U3RyaW5nID0gcmV0dXJuU3RhdGVtZW50LmdldFN0cmluZygpLFxuICAgICAgICBwcm9jZWR1cmVEZWxjYXJhdGlvblN0cmluZyA9IGAke3R5cGV9ICR7bGFiZWxTdHJpbmcgfSgke3BhcmFtZXRlcnNTdHJpbmd9KSB7IC4uLiAke3JldHVyblN0YXRlbWVudFN0cmluZ30gfWA7XG5cbiAgcmV0dXJuIHByb2NlZHVyZURlbGNhcmF0aW9uU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQmxvY2tTdHJpbmdGcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnQpIHtcbiAgY29uc3QgcmV0dXJuU3RhdGVtZW50U3RyaW5nID0gcmV0dXJuU3RhdGVtZW50LmdldFN0cmluZygpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IGB7IC4uLiAke3JldHVyblN0YXRlbWVudFN0cmluZ30gfWA7XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVByb3BlcnRpZXNTdHJpbmdGcm9tTm9kZVByb3BlcnRpZXNBcnJheShub2RlUHJvcGVydGllc0FycmF5KSB7XG4gIGNvbnN0IG5vZGVQcm9wZXJ0aWVzU3RyaW5nID0gbm9kZVByb3BlcnRpZXNBcnJheS5yZWR1Y2UoKG5vZGVQcm9wZXJ0aWVzU3RyaW5nLCBub2RlUHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVQcm9wZXJ0eVN0cmluZyA9IG5vZGVQcm9wZXJ0eS5nZXRTdHJpbmcoKTtcblxuICAgICAgbm9kZVByb3BlcnRpZXNTdHJpbmcgPSAobm9kZVByb3BlcnRpZXNTdHJpbmcgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlUHJvcGVydHlTdHJpbmcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtub2RlUHJvcGVydGllc1N0cmluZ30sICR7bm9kZVByb3BlcnR5U3RyaW5nfWA7XG5cbiAgICAgIHJldHVybiBub2RlUHJvcGVydGllc1N0cmluZztcbiAgICB9LCBudWxsKTtcblxuICByZXR1cm4gbm9kZVByb3BlcnRpZXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlKHR5cGUsIHZhcmlhYmxlKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA9IGAke3R5cGV9ICR7dmFyaWFibGVTdHJpbmd9ID0gLi4uIDtgO1xuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb21lU3RyaW5nRnJvbVZhcmlhYmxlQW5kQW5vbnltb3VzUHJvY2VkdXJlKHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlLmdldFN0cmluZygpLFxuICAgICAgICBzb21lU3RyaW5nID0gYFNvbWUoJHt2YXJpYWJsZVN0cmluZ30sICR7YW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nfSkgYDtcblxuICByZXR1cm4gc29tZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZXJ5U3RyaW5nRnJvbVZhcmlhYmxlQW5kQW5vbnltb3VzUHJvY2VkdXJlKHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlLmdldFN0cmluZygpLFxuICAgICAgICBldmVyeVN0cmluZyA9IGBFdmVyeSgke3ZhcmlhYmxlU3RyaW5nfSwgJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9KSBgO1xuXG4gIHJldHVybiBldmVyeVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZ0Zyb21WYXJpYWJsZUFzc2lnbm1lbnQodmFyaWFibGVBc3NpZ25tZW50KSB7XG4gIGNvbnN0IHZhcmlhYmxlID0gdmFyaWFibGVBc3NpZ25tZW50LmdldFZhcmlhYmxlKCksXG4gICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA9IGAke3ZhcmlhYmxlU3RyaW5nfSA9IC4uLmA7XG5cbiAgcmV0dXJuIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2NlZHVyZVN0cmluZ0Zyb21UeXBlTGFiZWxQYXJhbWV0ZXJzQW5kUmV0dXJuQmxvY2sodHlwZSwgbGFiZWwsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gIGNvbnN0IHR5cGVTdHJpbmcgPSB0eXBlLCAgLy8vXG4gICAgICAgIGxhYmVsU3RyaW5nID0gbGFiZWwuZ2V0U3RyaW5nKCksXG4gICAgICAgIHBhcmFtZXRlcnNTdHJpbmcgPSBwYXJhbWV0ZXJzLmdldFN0cmluZygpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IHJldHVybkJsb2NrLmdldFN0cmluZygpLFxuICAgICAgICBwcm9jZWR1cmVTdHJpbmcgPSBgJHt0eXBlU3RyaW5nfSAke2xhYmVsU3RyaW5nfSgke3BhcmFtZXRlcnNTdHJpbmd9KSAke3JldHVybkJsb2NrU3RyaW5nfWA7XG5cbiAgcmV0dXJuIHByb2NlZHVyZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFub255bW91c1Byb2NlZHVyZVN0cmluZ0Zyb21UeXBlUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrKHR5cGUsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gIGNvbnN0IHR5cGVTdHJpbmcgPSB0eXBlLCAgLy8vXG4gICAgICAgIHBhcmFtZXRlcnNTdHJpbmcgPSBwYXJhbWV0ZXJzLmdldFN0cmluZygpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IHJldHVybkJsb2NrLmdldFN0cmluZygpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmcgPSBgJHt0eXBlU3RyaW5nfSAoJHtwYXJhbWV0ZXJzU3RyaW5nfSkgJHtyZXR1cm5CbG9ja1N0cmluZ31gO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudHNBcnJheSh0eXBlLCB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkpIHtcbiAgbGV0IHZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkucmVkdWNlKCh2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nLCB2YXJpYWJsZUFzc2lnbm1lbnQpID0+IHtcbiAgICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVmFyaWFibGVBc3NpZ25tZW50KHZhcmlhYmxlQXNzaWdubWVudCk7XG5cbiAgICB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nID0gKHZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmcgPT09IG51bGwpID9cbiAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA6XG4gICAgICBgJHt2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nfSwgJHt2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmd9YDtcblxuICAgIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nO1xuICB9LCBudWxsKTsgLy8vXG5cbiAgdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZyA9IGAke3R5cGV9ICR7dmFyaWFibGVBc3NpZ25tZW50c1N0cmluZ30gO2A7IC8vL1xuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlU3RyaW5nRnJvbVZhcmlhYmxlSW5pdGlhbEV4cHJlc3Npb25BbmRBbm9ueW1vdXNQcm9jZWR1cmUodmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgaW5pdGlhbEV4cHJlc3Npb25TdHJpbmcgPSBpbml0aWFsRXhwcmVzc2lvbi5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlLmdldFN0cmluZygpLFxuICAgICAgICByZWR1Y2VTdHJpbmcgPSBgUmVkdWNlKCR7dmFyaWFibGVTdHJpbmd9LCAke2Fub255bW91c1Byb2NlZHVyZVN0cmluZ30sICR7aW5pdGlhbEV4cHJlc3Npb25TdHJpbmd9KWA7XG5cbiAgcmV0dXJuIHJlZHVjZVN0cmluZztcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmltcG9ydCB7IE5PREVfVFlQRSwgTk9ERVNfVFlQRSwgU1RSSU5HX1RZUEUsIEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgcHJpbXRpdmVTdHJpbmdGcm9tTm9kZSwgcHJpbXRpdmVTdHJpbmdGcm9tTm9kZXMsIHByaW10aXZlU3RyaW5nRnJvbUJvb2xlYW4sIHByaW10aXZlU3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbWl0aXZlRnJvbU5vZGUobm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFByaW1pdGl2ZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIHByaW1pdGl2ZVN0cmluZyA9IHByaW10aXZlU3RyaW5nRnJvbU5vZGUobm9kZSwgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZVN0cmluZywgIC8vL1xuICAgICAgICB0eXBlID0gTk9ERV9UWVBFLFxuICAgICAgICB2YWx1ZSA9IG5vZGU7IC8vL1xuXG4gIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCB7IFByaW1pdGl2ZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIHByaW1pdGl2ZVN0cmluZyA9IHByaW10aXZlU3RyaW5nRnJvbU5vZGVzKG5vZGVzLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlU3RyaW5nLCAgLy8vXG4gICAgICAgIHR5cGUgPSBOT0RFU19UWVBFLFxuICAgICAgICB2YWx1ZSA9IG5vZGVzLCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcmltaXRpdmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBwcmltaXRpdmVTdHJpbmcgPSBwcmltdGl2ZVN0cmluZ0Zyb21Cb29sZWFuKGJvb2xlYW4pLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmVTdHJpbmcsICAvLy9cbiAgICAgICAgdHlwZSA9IEJPT0xFQU5fVFlQRSxcbiAgICAgICAgdmFsdWUgPSBib29sZWFuLCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcmltaXRpdmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBwcmltaXRpdmVTdHJpbmcgPSBwcmltdGl2ZVN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwpLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmVTdHJpbmcsICAvLy9cbiAgICAgICAgdHlwZSA9IFNUUklOR19UWVBFLFxuICAgICAgICB2YWx1ZSA9IHN0cmluZ0xpdGVyYWwsICAvLy9cbiAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcHJpbWl0aXZlID0gbmV3IFByaW1pdGl2ZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHZhbHVlKTtcblxuICByZXR1cm4gcHJpbWl0aXZlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByaW1pdGl2ZUZyb21Ob2RlLFxuICBwcmltaXRpdmVGcm9tTm9kZXMsXG4gIHByaW1pdGl2ZUZyb21Cb29sZWFuLFxuICBwcmltaXRpdmVGcm9tU3RyaW5nTGl0ZXJhbFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGVsZW1lbnRzIGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5pbXBvcnQgeyBwcmltaXRpdmVGcm9tTm9kZSwgcHJpbWl0aXZlRnJvbU5vZGVzLCBwcmltaXRpdmVGcm9tQm9vbGVhbiwgcHJpbWl0aXZlRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ByaW1pdGl2ZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tTm9kZShub2RlLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpO1xuXG4gIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm0gPSBuZXcgVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICB2YXJpYWJsZSA9IG51bGwsXG4gICAgICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICB2YXJpYWJsZSA9IG51bGwsXG4gICAgICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmUuZ2V0U3RyaW5nKCksXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm0gPSBuZXcgVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlKTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICBub2RlID0gbnVsbCxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlKTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICB0ZXJtRnJvbU5vZGUsXG4gIHRlcm1Gcm9tTm9kZXMsXG4gIHRlcm1Gcm9tQm9vbGVhbixcbiAgdGVybUZyb21TdHJpbmdMaXRlcmFsLFxuICB0ZXJtRnJvbVByaW1pdGl2ZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCwgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFU19UWVBFLCBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZSwgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmNvbnN0IHsgYXN5bmNTb21lIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBTb21lIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGFub255bW91c1Byb2NlZHVyZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0QW5vbnltb3VzUHJvY2VkdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmFub255bW91c1Byb2NlZHVyZTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGF3YWl0IHRoaXMuYnJlYWsoY29udGV4dCk7XG5cbiAgICBjb25zdCBzb21lU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3NvbWVTdHJpbmd9JyBzb21lLi4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IE5PREVTX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVTX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgbm9kZXMgPSBwcmltaXRpdmVWYWx1ZSwgLy8vXG4gICAgICAgICAgYm9vbGVhbiA9IGF3YWl0IGFzeW5jU29tZShub2RlcywgYXN5bmMgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXJtO1xuXG4gICAgICAgICAgICB0ZXJtID0gdGVybUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgIHRlcm1zID0gVGVybXMuZnJvbVRlcm0odGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLmFub255bW91c1Byb2NlZHVyZS5jYWxsKHRlcm1zLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgICAgICAgICAgaWYgKHRlcm1UeXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgdHlwZSBpcyAnJHt0ZXJtVHlwZX0nIHdoZW4gaXQgc2hvdWxkIGJlIG9mIHR5cGUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgICAgICAgICBib29sZWFuID0gcHJpbWl0aXZlVmFsdWU7IC8vL1xuXG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbjtcbiAgICAgICAgICB9KTtcblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYC4uLmV2YWx1YXRlZCB0aGUgJyR7c29tZVN0cmluZ30nIHNvbWUgYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiU29tZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBUZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSwgbmVnYXRlZFRlcm0sIGxvZ2ljYWxUZXJtLCBicmFja2V0ZWRUZXJtLCBjb21wYXJpc29uVGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICB0aGlzLm5lZ2F0ZWRUZXJtID0gbmVnYXRlZFRlcm07XG4gICAgdGhpcy5sb2dpY2FsVGVybSA9IGxvZ2ljYWxUZXJtO1xuICAgIHRoaXMuYnJhY2tldGVkVGVybSA9IGJyYWNrZXRlZFRlcm07XG4gICAgdGhpcy5jb21wYXJpc29uVGVybSA9IGNvbXBhcmlzb25UZXJtO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRQcmltaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlO1xuICB9XG5cbiAgZ2V0TmVnYXRlZFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRlZFRlcm07XG4gIH1cblxuICBnZXRMb2dpY2FsVGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dpY2FsVGVybTtcbiAgfVxuXG4gIGdldEJyZWVkaW5nVGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5icmFja2V0ZWRUZXJtO1xuICB9XG5cbiAgZ2V0Q29tcGFyaXNvblRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyaXNvblRlcm07XG4gIH1cblxuICBnZXRQcmltaXRpdmVWYWx1ZSgpIHtcbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRoaXMucHJpbWl0aXZlLmdldFZhbHVlKCk7XG5cbiAgICByZXR1cm4gcHJpbWl0aXZlVmFsdWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnZhcmlhYmxlLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJpbWl0aXZlICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5wcmltaXRpdmUuZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubmVnYXRlZFRlcm0uZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2dpY2FsVGVybSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubG9naWNhbFRlcm0uZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5icmFja2V0ZWRUZXJtICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5icmFja2V0ZWRUZXJtLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29tcGFyaXNvblRlcm0gIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLmNvbXBhcmlzb25UZXJtLmdldFR5cGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGlzQm9vbGVhbigpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICAgICAgYm9vbGVhbiA9ICh0eXBlID09PSBCT09MRUFOX1RZUEUpO1xuXG4gICAgcmV0dXJuIGJvb2xlYW47XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy52YXJpYWJsZSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByaW1pdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMucHJpbWl0aXZlLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMubmVnYXRlZFRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvZ2ljYWxUZXJtICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gdGhpcy5sb2dpY2FsVGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnJhY2tldGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMuYnJhY2tldGVkVGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29tcGFyaXNvblRlcm0gIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLmNvbXBhcmlzb25UZXJtLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgaXNFcXVhbFRvKHRlcm0pIHtcbiAgICBsZXQgZXF1YWxUbyA9IGZhbHNlO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGVybS5nZXRWYXJpYWJsZSgpO1xuXG4gICAgICBpZiAodmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgZXF1YWxUbyA9IHRoaXMudmFyaWFibGUuaXNFcXVhbFRvKHZhcmlhYmxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJpbWl0aXZlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmltaXRpdmUgPSB0ZXJtLmdldFByaW1pdGl2ZSgpO1xuXG4gICAgICBpZiAocHJpbWl0aXZlICE9PSBudWxsKSB7XG4gICAgICAgIGVxdWFsVG8gPSB0aGlzLnByaW1pdGl2ZS5pc0VxdWFsVG8ocHJpbWl0aXZlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWxUbztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJUZXJtXCI7XG5cbiAgc3RhdGljIGZyb21QcmltaXRpdmUocHJpbWl0aXZlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcHJpbWl0aXZlU3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZVN0cmluZywgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGwsXG4gICAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICAgIG5lZ2F0ZWRUZXJtID0gbnVsbCxcbiAgICAgICAgICBsb2dpY2FsVGVybSA9IG51bGwsXG4gICAgICAgICAgYnJhY2tldGVkVGVybSA9IG51bGwsXG4gICAgICAgICAgY29tcGFyaXNvblRlcm0gPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlLCBuZWdhdGVkVGVybSwgbG9naWNhbFRlcm0sIGJyYWNrZXRlZFRlcm0sIGNvbXBhcmlzb25UZXJtKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFRlcm1zIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGdldExlbmd0aCgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICBnZXRUZXJtKGluZGV4KSB7XG4gICAgY29uc3QgdGVybSA9IHRoaXMuYXJyYXlbaW5kZXhdIHx8IG51bGw7ICAvLy9cblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgYWRkVGVybSh0ZXJtKSB7XG4gICAgdGhpcy5hcnJheS5wdXNoKHRlcm0pO1xuICB9XG5cbiAgbWFwVGVybShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5tYXAoY2FsbGJhY2spOyB9XG5cbiAgZm9yRWFjaFRlcm0oY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtc0FycmF5ID0gdGhpcy5tYXBUZXJtKCh0ZXJtKSA9PiB7XG4gICAgICAgICAgICB0ZXJtID0gdGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGVybXNTdHJpbmcgPSB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5KHRlcm1zQXJyYXksIGNvbnRleHQpLFxuICAgICAgICAgIHN0cmluZyA9IHRlcm1zU3RyaW5nLCAvLy9cbiAgICAgICAgICBhcnJheSA9IHRlcm1zQXJyYXksIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB0ZXJtcyA9IG5ldyBUZXJtcyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICAgIHJldHVybiB0ZXJtcztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJUZXJtc1wiO1xuXG4gIHN0YXRpYyBmcm9tVGVybSh0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybXNBcnJheSA9IFtcbiAgICAgICAgICAgIHRlcm1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHRlcm1zU3RyaW5nID0gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5LCBjb250ZXh0KSxcbiAgICAgICAgICBzdHJpbmcgPSB0ZXJtc1N0cmluZywgLy8vXG4gICAgICAgICAgYXJyYXkgPSB0ZXJtc0FycmF5LCAvLy9cbiAgICAgICAgICBub2RlID0gbnVsbDtcblxuICAgIGNvbnRleHQgPSBudWxsO1xuXG4gICAgY29uc3QgdGVybXMgPSBuZXcgVGVybXMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgICByZXR1cm4gdGVybXM7XG4gIH1cbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIExhYmVsIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBjb21wYXJlUHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlTmFtZUNvbXBhcmVzID0gKHRoaXMubmFtZSA9PT0gcHJvY2VkdXJlTmFtZSk7XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlTmFtZUNvbXBhcmVzO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkxhYmVsXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBFcnJvciBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXJ4dCwgc3RyaW5nLCBub2RlKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuICB9XG5cbiAgdmVyaWZ5KGNvbnRleHQpIHtcbiAgICBjb25zdCB2ZXJpZmllcyA9IGZhbHNlLFxuICAgICAgICAgIGVycm9yU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC53YXJuaW5nKGBUaGUgJyR7ZXJyb3JTdHJpbmd9JyBlcnJvciBjYW5ub3QgYmUgdmVyaWZpZWQuYCk7XG5cbiAgICByZXR1cm4gdmVyaWZpZXM7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiRXJyb3JcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVTX1RZUEUsIEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlLCB0ZXJtRnJvbUJvb2xlYW4gfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuY29uc3QgeyBhc3luY0V2ZXJ5IH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBFdmVyeSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgZXZlcnlTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7ZXZlcnlTdHJpbmd9JyBldmVyeS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFU19UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFU19UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gdGVybS5nZXROb2RlcygpLFxuICAgICAgICAgIGJvb2xlYW4gPSBhd2FpdCBhc3luY0V2ZXJ5KG5vZGVzLCBhc3luYyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRlcm07XG5cbiAgICAgICAgICAgIGNvbnN0IHsgVGVybXMgfSA9IGVsZW1lbnRzO1xuXG4gICAgICAgICAgICB0ZXJtID0gdGVybUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXJtcyA9IFRlcm1zLmZyb21UZXJtKHRlcm0sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICB0ZXJtID0gYXdhaXQgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUuY2FsbCh0ZXJtcywgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXJtVHlwZSAhPT0gQk9PTEVBTl9UWVBFKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIHR5cGUgaXMgJyR7dGVybVR5cGV9JyB3aGVuIGl0IHNob3VsZCBiZSBvZiB0eXBlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJvb2xlYW4gPSB0ZXJtLmdldEJvb2xlYW4oKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW47XG4gICAgICAgICAgfSk7XG5cbiAgICB0ZXJtID0gdGVybUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGAuLi5ldmFsdWF0ZWQgdGhlICcke2V2ZXJ5U3RyaW5nfScgZXZlcnkgYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiRXZlcnlcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVTX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5jb25zdCB7IGFzeW5jUmVkdWNlIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBSZWR1Y2UgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgaW5pdGlhbEV4cHJlc3Npb24sIGFub255bW91c1Byb2NlZHVyZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmluaXRpYWxFeHByZXNzaW9uID0gaW5pdGlhbEV4cHJlc3Npb247XG4gICAgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldEluaXRpYWxFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0QW5vbnltb3VzUHJvY2VkdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmFub255bW91c1Byb2NlZHVyZTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGF3YWl0IHRoaXMuYnJlYWsoY29udGV4dCk7XG5cbiAgICBjb25zdCByZWR1Y2VTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cmVkdWNlU3RyaW5nfScgcmVkdWNlLi4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IE5PREVTX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVTX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSB0ZXJtLmdldE5vZGVzKCksXG4gICAgICAgICAgaW5pdGlhbEV4cHJlc3Npb24gPSBhd2FpdCB0aGlzLmluaXRpYWxFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgdGVybSA9IGF3YWl0IGFzeW5jUmVkdWNlKG5vZGVzLCBhc3luYyAoY3VycmVudEV4cHJlc3Npb24sIG5vZGUpID0+IHtcbiAgICAgIGxldCB0ZXJtO1xuXG4gICAgICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cztcblxuICAgICAgdGVybSA9IGN1cnJlbnRUZXJtOyAvLy9cblxuICAgICAgY29uc3QgdGVybXMgPSBUZXJtcy5mcm9tVGVybSh0ZXJtLCBjb250ZXh0KTtcblxuICAgICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgICAgdGVybXMuYWRkVGVybSh0ZXJtKTtcblxuICAgICAgdGVybSA9IGF3YWl0IHRoaXMuYW5vbnltb3VzUHJvY2VkdXJlLmNhbGwodGVybXMsIGNvbnRleHQpO1xuXG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9LCBpbml0aWFsRXhwcmVzc2lvbik7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYC4uLmV2YWx1YXRlZCB0aGUgJyR7cmVkdWNlU3RyaW5nfScgcmVkdWNlIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJlZHVjZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVGVybmFyeSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0sIGlmRXhwcmVzc2lvbiwgZWxzZUV4cHJlc3Npb24pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICAgIHRoaXMuaWZFeHByZXNzaW9uID0gaWZFeHByZXNzaW9uO1xuICAgIHRoaXMuZWxzZUV4cHJlc3Npb24gPSBlbHNlRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGdldElmQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0RWxzZUJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmVsc2VFeHByZXNzaW9uO1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgdGVybmFyeVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7dGVybmFyeVN0cmluZ30nIHRlcm5hcnkuLi5gKTtcblxuICAgIHRlcm0gPSB0aGlzLnRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyB0eXBlIGlzICcke3Rlcm1UeXBlfScgd2hlbiBpdCBzaG91bGQgYmUgb2YgdHlwZSAnJHtCT09MRUFOX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgYm9vbGVhbiA9IHByaW1pdGl2ZVZhbHVlOyAvLy9cblxuICAgIHRlcm0gPSBib29sZWFuID9cbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pZkV4cHJlc3Npb24uZXZhbHVhdGUoY29udGV4dCkgOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxzZUV4cHJlc3Npb24uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7dGVybmFyeVN0cmluZ30nIHRlcm5hcnkgYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVGVybmFyeVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVmFyaWFibGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lLCB0ZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudGVybSA9IHRlcm07XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBjb21wYXJlVmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSkge1xuICAgIGNvbnN0IGNvbXBhcmVzVG9WYXJpYWJsZU5hbWUgPSAodGhpcy5uYW1lID09PSB2YXJpYWJsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGNvbXBhcmVzVG9WYXJpYWJsZU5hbWU7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUuLi5gKTtcblxuICAgIGNvbnN0IG5lc3RlZCA9IHRydWUsXG4gICAgICAgICAgdmFyaWFibGVOYW1lID0gdGhpcy5uYW1lLCAvLy9cbiAgICAgICAgICB2YXJpYWJsZVByZXNlbnQgPSBjb250ZXh0LmlzVmFyaWFibGVQcmVzZW50QnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lLCBuZXN0ZWQpO1xuXG4gICAgaWYgKCF2YXJpYWJsZVByZXNlbnQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUgaXMgbm90IHByZXNlbnQuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB2YXJpYWJsZSA9IGNvbnRleHQuZmluZFZhcmlhYmxlQnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lKSxcbiAgICAgICAgICB0ZXJtID0gdmFyaWFibGUuZ2V0VGVybSgpLFxuICAgICAgICAgIHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIGFzIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybS5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgYXNzaWduKHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCBuZXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgICB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICB2YXJpYWJsZU5hbWUgPSB0aGlzLm5hbWUsIC8vL1xuICAgICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKSwgLy8vXG4gICAgICAgICAgdmFyaWFibGVQcmVzZW50ID0gY29udGV4dC5pc1ZhcmlhYmxlUHJlc2VudEJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSwgbmVzdGVkKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEFzc2lnbmluZyB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gdG8gdGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUuLi5gKTtcblxuICAgIGlmICh2YXJpYWJsZVByZXNlbnQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUgaXMgYWxyZWFkeSBwcmVzZW50LmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpLFxuICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gdmFyaWFibGVUeXBlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt2YXJpYWJsZVN0cmluZ30gdmFyaWFibGUncyAnJHt2YXJpYWJsZVR5cGV9JyB0eXBlIGRvZXMgbm90IGNvbXBhcmUgdG8gdGhlIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuXG4gICAgY29uc3QgdmFyaWFibGUgPSB0aGlzOyAgLy8vXG5cbiAgICBjb250ZXh0LmFkZFZhcmlhYmxlKHZhcmlhYmxlKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmFzc2lnbmVkIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSB0byB0aGUgJyR7dmFyaWFibGVTdHJpbmd9JyB2YXJpYWJsZS5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJWYXJpYWJsZVwiO1xuXG4gIHN0YXRpYyBmcm9tUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWUgPSBwYXJhbWV0ZXIuZ2V0TmFtZSgpLFxuICAgICAgICAgIHRlcm0gPSBudWxsLFxuICAgICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGVTdHJpbmdGcm9tTmFtZShuYW1lKSxcbiAgICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZVN0cmluZywgIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIHRlcm0pO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IGFsaWFzZWROYW1lID0gbmFtZWRQYXJhbWV0ZXIuZ2V0QWxpYXNlZE5hbWUoKSxcbiAgICAgICAgICB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWUgPSBhbGlhc2VkTmFtZSwgLy8vXG4gICAgICAgICAgdGVybSA9IG51bGwsXG4gICAgICAgICAgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZVN0cmluZ0Zyb21OYW1lKG5hbWUpLFxuICAgICAgICAgIHN0cmluZyA9IHZhcmlhYmxlU3RyaW5nLCAgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIGNvbnN0IHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgdGVybSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRlcm1BbmRQYXJhbWV0ZXIodGVybSwgcGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdHlwZSA9IHBhcmFtZXRlci5nZXRUeXBlKCksXG4gICAgICAgICAgbmFtZSA9IHBhcmFtZXRlci5nZXROYW1lKCksXG4gICAgICAgICAgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZVN0cmluZ0Zyb21OYW1lKG5hbWUpLFxuICAgICAgICAgIHN0cmluZyA9IHZhcmlhYmxlU3RyaW5nLCAgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIGNvbnN0IHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgdGVybSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBudWxsTm9kZSBmcm9tIFwiLi4vbnVsbE5vZGVcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIE5PREVTX1RZUEUsIFNUUklOR19UWVBFLCBOVU1CRVJfVFlQRSwgQk9PTEVBTl9UWVBFICB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5jb25zdCB7IG1hdGNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFByaW1pdGl2ZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICAgIHByaW1pdGl2ZSA9IHRoaXMsXG4gICAgICAgICAgdGVybSA9IFRlcm0uZnJvbVByaW1pdGl2ZShwcmltaXRpdmUsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBpc0VxdWFsVG8ocHJpbWl0aXZlKSB7XG4gICAgbGV0IGVxdWFsVG8gPSBmYWxzZTtcblxuICAgIGNvbnN0IHR5cGUgPSBwcmltaXRpdmUuZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBwcmltaXRpdmUuZ2V0VmFsdWUoKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgTk9ERV9UWVBFOiB7XG4gICAgICAgICAgY29uc3Qgbm9kZUEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBub2RlQiA9IHZhbHVlLCAgLy8vXG4gICAgICAgICAgICAgICAgbm9kZU1hdGNoZXMgPSBtYXRjaE5vZGUobm9kZUEsIG5vZGVCKTtcblxuICAgICAgICAgIGlmIChub2RlTWF0Y2hlcykge1xuICAgICAgICAgICAgZXF1YWxUbyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIE5PREVTX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBub2Rlc0EgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBub2Rlc0IgPSB2YWx1ZSwgIC8vL1xuICAgICAgICAgICAgICAgIG5vZGVzTWF0Y2ggPSBtYXRjaE5vZGVzKG5vZGVzQSwgbm9kZXNCKTtcblxuICAgICAgICAgIGlmIChub2Rlc01hdGNoKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgU1RSSU5HX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBzdHJpbmdMaXRlcmFsQSA9IHRoaXMudmFsdWUsIC8vL1xuICAgICAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxCID0gdmFsdWU7ICAvLy9cblxuICAgICAgICAgIGlmIChzdHJpbmdMaXRlcmFsQSA9PT0gc3RyaW5nTGl0ZXJhbEIpIHtcbiAgICAgICAgICAgIGVxdWFsVG8gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBOVU1CRVJfVFlQRToge1xuICAgICAgICAgIGNvbnN0IG51bWJlckEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBudW1iZXJCID0gdmFsdWU7ICAvLy9cblxuICAgICAgICAgIGlmIChudW1iZXJBID09PSBudW1iZXJCKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQk9PTEVBTl9UWVBFOiB7XG4gICAgICAgICAgY29uc3QgYm9vbGVhbkEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBib29sZWFuQiA9IHZhbHVlOyAgLy8vXG5cbiAgICAgICAgICBpZiAoYm9vbGVhbkEgPT09IGJvb2xlYW5CKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcXVhbFRvO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlByaW1pdGl2ZVwiO1xufSk7XG5cbmZ1bmN0aW9uIG1hdGNoTm9kZShub2RlQSwgbm9kZUIpIHtcbiAgbGV0IG5vZGVNYXRjaGVzO1xuXG4gIGlmICgobm9kZUEgPT09IG51bGxOb2RlKSB8fCAobm9kZUIgPT09IG51bGxOb2RlKSkge1xuICAgIG5vZGVNYXRjaGVzID0gKG5vZGVBID09PSBub2RlQik7XG4gIH0gZWxzZSBpZiAobm9kZUEgPT09IG51bGxOb2RlKSB7XG4gICAgbm9kZU1hdGNoZXMgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChub2RlQiA9PT0gbnVsbE5vZGUpIHtcbiAgICBub2RlTWF0Y2hlcyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGVBTWF0Y2hlc05vZGVCID0gbm9kZUEubWF0Y2gobm9kZUIpO1xuXG4gICAgbm9kZU1hdGNoZXMgPSBub2RlQU1hdGNoZXNOb2RlQjsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG5vZGVNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBtYXRjaE5vZGVzKG5vZGVzQSwgbm9kZXNCKSB7XG4gIGNvbnN0IG5vZGVzTWF0Y2ggPSBtYXRjaChub2Rlc0EsIG5vZGVzQiwgKG5vZGVBLCBub2RlQikgPT4ge1xuICAgIGNvbnN0IG5vZGVNYXRjaGVzID0gbWF0Y2hOb2RlKG5vZGVBLCBub2RlQik7XG5cbiAgICBpZiAobm9kZU1hdGNoZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzTWF0Y2g7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUmVmZXJlbmNlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVOYW1lKCkge1xuICAgIGNvbnN0IHByb2NlZHVyZU5hbWUgPSB0aGlzLm5hbWU7ICAvLy9cblxuICAgIHJldHVybiBwcm9jZWR1cmVOYW1lO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJlZmVyZW5jZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUHJvY2VkdXJlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbGFiZWwsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB0aGlzLnJldHVybkJsb2NrID0gcmV0dXJuQmxvY2s7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXRMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycztcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLnJldHVybkJsb2NrO1xuICB9XG5cbiAgaXNCb29sZWFuKCkge1xuICAgIGNvbnN0IHR5cGVCb29sZWFuVHlwZSA9ICh0aGlzLnR5cGUgPT09IEJPT0xFQU5fVFlQRSksXG4gICAgICAgICAgYm9vbGVhbiA9IHR5cGVCb29sZWFuVHlwZTsgIC8vL1xuXG4gICAgcmV0dXJuIGJvb2xlYW47XG4gIH1cblxuICBnZXROYW1lKCkgeyByZXR1cm4gdGhpcy5sYWJlbC5nZXROYW1lKCk7IH1cblxuICBnZXRSZXR1cm5TdGF0ZW1lbnQoKSB7IHJldHVybiB0aGlzLnJldHVybkJsb2NrLmdldFJldHVyblN0YXRlbWVudCgpOyB9XG5cbiAgY29tcGFyZVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSkgeyByZXR1cm4gdGhpcy5sYWJlbC5jb21wYXJlUHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTsgfVxuXG4gIGFzeW5jIGNhbGwodGVybXMsIGNvbnRleHQpIHtcbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgcHJvY2VkdXJlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ2FsbGluZyB0aGUgJyR7cHJvY2VkdXJlU3RyaW5nfScgcHJvY2VkdXJlLi4uYCk7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMuY29tcGFyZVRlcm1zKHRlcm1zLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHZhcmlhYmxlc0Zyb21UZXJtc0FuZFBhcmFtZXRlcnModGVybXMsIHRoaXMucGFyYW1ldGVycywgY29udGV4dCksXG4gICAgICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmV0dXJuQmxvY2suZXZhbHVhdGUodmFyaWFibGVzLCBjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdGVybVR5cGUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHtwcm9jZWR1cmVTdHJpbmd9JyBwcm9jZWR1cmUncyAnJHt0aGlzLnR5cGV9JyB0eXBlLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jYWxsZWQgdGhlICcke3Byb2NlZHVyZVN0cmluZ30nIHByb2NlZHVyZS5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlByb2NlZHVyZVwiO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZXNGcm9tVGVybXNBbmRQYXJhbWV0ZXJzKHRlcm1zLCBwYXJhbWV0ZXJzLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlcyA9IFtdO1xuXG4gIHRlcm1zLmZvckVhY2hUZXJtKCh0ZXJtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcnMuZ2V0UGFyYW1ldGVyKGluZGV4KTtcblxuICAgIGlmIChwYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgVmFyaWFibGUgfSA9IGVsZW1lbnRzLFxuICAgICAgICAgICAgdmFyaWFibGUgPSBWYXJpYWJsZS5mcm9tVGVybUFuZFBhcmFtZXRlcih0ZXJtLCBwYXJhbWV0ZXIsIGNvbnRleHQpO1xuXG4gICAgICB2YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdmFyaWFibGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVfVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgTm9kZVF1ZXJ5IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBub2RlUXVlcnlTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtub2RlUXVlcnlTdHJpbmd9JyBub2RlIHF1ZXJ5Li4uYCk7XG5cbiAgICBpZiAodGhpcy5xdWVyeSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBDYW5ub3QgZXZhbHVhdGUgdGhlICcke25vZGVRdWVyeVN0cmluZ30nIG5vZGUgcXVlcnkgYmVjYXVzZSBpdHMgZXhwcmVzc2lvbiBpcyBtYWxmb3JtZWQuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRlcm0gPSB0aGlzLnZhcmlhYmxlLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gTk9ERV9UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgbGV0IG5vZGU7XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKTtcblxuICAgIG5vZGUgPSBwcmltaXRpdmVWYWx1ZTsgIC8vL1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyBub2RlIGlzIG51bGwuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5xdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKG5vZGVzTGVuZ3RoICE9PSAxKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIG5vZGVzIGlzICR7bm9kZXNMZW5ndGh9IHdoZW4gaXQgc2hvdWxkIGJlIDEuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IGZpcnN0KG5vZGVzKTtcblxuICAgIG5vZGUgPSBmaXJzdE5vZGU7IC8vL1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtub2RlUXVlcnlTdHJpbmd9JyBub2RlIHF1ZXJ5IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5vZGVRdWVyeVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFBhcmFtZXRlciBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBjb21wYXJlVGVybSh0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgcGFyYW1ldGVyU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ29tcGFyaW5nIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSBhZ2FpbnN0IHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSB0ZXJtVHlwZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIncyAnJHt0aGlzLnR5cGV9JyB0eXBlLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJpbmcgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtIGFnYWluc3QgdGhlICcke3BhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlci5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQYXJhbWV0ZXJcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBQYXJhbWV0ZXJzIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGdldExlbmd0aCgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXIoaW5kZXgpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSB0aGlzLmFycmF5W2luZGV4XSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIHBhcmFtZXRlcjtcbiAgfVxuXG4gIGZvckVhY2hQYXJhbWV0ZXIoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGNvbXBhcmVUZXJtcyh0ZXJtcywgY29udGV4dCkge1xuICAgIGNvbnN0IHRlcm1zU3RyaW5nID0gdGVybXMuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgcGFyYW1ldGVyc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ29tcGFyaW5nIHRoZSAnJHt0ZXJtc1N0cmluZ30nIHRlcm1zIGFnYWluc3QgdGhlICcke3BhcmFtZXRlcnNTdHJpbmd9JyBwYXJhbWV0ZXJzLi4uYCk7XG5cbiAgICBjb25zdCB0ZXJtc0xlbmd0aCA9IHRlcm1zLmdldExlbmd0aCgpLFxuICAgICAgICAgIHBhcmFtZXRlcnNMZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKHRlcm1zTGVuZ3RoICE9PSBwYXJhbWV0ZXJzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtc1N0cmluZ30nIGV4cHJlc3Npb25zIGFuZCAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycyBhcmUgbm90IG9mIHRoZSBzYW1lIGxlbmd0aC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGhpcy5mb3JFYWNoUGFyYW1ldGVyKChwYXJhbWV0ZXIsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtcy5nZXRUZXJtKGluZGV4KTtcblxuICAgICAgICBwYXJhbWV0ZXIuY29tcGFyZVRlcm0odGVybSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7dGVybXNTdHJpbmd9JyB0ZXJtcyBhZ2FpbnN0IHRoZSAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycy5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQYXJhbWV0ZXJzXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgTk9ERV9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBOb2Rlc1F1ZXJ5IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBub2Rlc1F1ZXJ5U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bm9kZXNRdWVyeVN0cmluZ30nIG5vZGVzIHF1ZXJ5Li4uYCk7XG5cbiAgICBpZiAodGhpcy5xdWVyeSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBDYW5ub3QgZXZhbHVhdGUgdGhlICcke25vZGVzUXVlcnlTdHJpbmd9JyBub2RlcyBxdWVyeSBiZWNhdXNlIGl0cyBleHByZXNzaW9uIGlzIG1hbGZvcm1lZC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgbm9kZTtcblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpO1xuXG4gICAgbm9kZSA9IHByaW1pdGl2ZVZhbHVlOyAgLy8vXG5cbiAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIG5vZGUgaXMgbnVsbC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLnF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICB0ZXJtID0gdGVybUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bm9kZXNRdWVyeVN0cmluZ30nIG5vZGVzIHF1ZXJ5IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5vZGVzUXVlcnlcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIEV4cHJlc3Npb24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtLCBzb21lLCBldmVyeSwgcmVkdWNlLCB0ZXJuYXJ5LCBub2RlUXVlcnksIG5vZGVzUXVlcnksIHJldHVybkJsb2NrLCBwcm9jZWR1cmVDYWxsKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgICB0aGlzLnNvbWUgPSBzb21lO1xuICAgIHRoaXMuZXZlcnkgPSBldmVyeTtcbiAgICB0aGlzLnJlZHVjZSA9IHJlZHVjZTtcbiAgICB0aGlzLnRlcm5hcnkgPSB0ZXJuYXJ5O1xuICAgIHRoaXMubm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5O1xuICAgIHRoaXMubm9kZXNRdWVyeSA9IG5vZGVzUXVlcnk7XG4gICAgdGhpcy5yZXR1cm5CbG9jayA9IHJldHVybkJsb2NrO1xuICAgIHRoaXMucHJvY2VkdXJlQ2FsbCA9IHByb2NlZHVyZUNhbGw7XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBnZXRTb21lKCkge1xuICAgIHJldHVybiB0aGlzLnNvbWU7XG4gIH1cblxuICBnZXRFdmVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVyeTtcbiAgfVxuXG4gIGdldFJlZHVjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2U7XG4gIH1cblxuICBnZXRUZXJuYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRlcm5heTtcbiAgfVxuXG4gIGdldE5vZGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlUXVlcnk7XG4gIH1cblxuICBnZXROb2Rlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzUXVlcnk7XG4gIH1cblxuICBnZXRSZXR1cm5CbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXR1cm5CbG9jaztcbiAgfVxuXG4gIGdldFByb2NlZHVyZUNhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2VkdXJlQ2FsbDtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZXJtICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy50ZXJtLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc29tZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMuc29tZS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV2ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5ldmVyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlZHVjZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMucmVkdWNlLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVybmFyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMudGVybmFyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGVRdWVyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubm9kZVF1ZXJ5LmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubm9kZXNRdWVyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubm9kZXNRdWVyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJldHVybkJsb2NrICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5yZXR1cm5CbG9jay5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2NlZHVyZUNhbGwgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnByb2NlZHVyZUNhbGwuZ2V0VHlwZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubm9kZVF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gdGhpcy5ub2RlUXVlcnkuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGVzUXVlcnkgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLm5vZGVzUXVlcnkuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNvbWUgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnNvbWUuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV2ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gYXdhaXQgIHRoaXMuZXZlcnkuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlZHVjZSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmVkdWNlLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZXJuYXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gYXdhaXQgdGhpcy50ZXJuYXJ5LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZXR1cm5CbG9jayAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmV0dXJuQmxvY2suZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2NlZHVyZUNhbGwgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnByb2NlZHVyZUNhbGwuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiRXhwcmVzc2lvblwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmNvbnN0IHsgcHVzaCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2NrQ29udGV4dCBleHRlbmRzIENvbnRleHQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCB2YXJpYWJsZXMpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcblxuICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzKG5lc3RlZCA9IHRydWUpIHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcblxuICAgIHB1c2godmFyaWFibGVzLCB0aGlzLnZhcmlhYmxlcyk7XG5cbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzID0gY29udGV4dC5nZXRWYXJpYWJsZXMoKTtcblxuICAgICAgcHVzaCh2YXJpYWJsZXMsIGNvbnRleHRWYXJpYWJsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYWJsZXM7XG4gIH1cblxuICBhZGRWYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgIGNvbnN0IG5lc3RlZCA9IGZhbHNlLFxuICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlLmdldE5hbWUoKSxcbiAgICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlLmdldFN0cmluZygpLFxuICAgICAgICAgIHZhcmlhYmxlUHJlc2VudCA9IHRoaXMuaXNWYXJpYWJsZVByZXNlbnRCeVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUsIG5lc3RlZCk7XG5cbiAgICBpZiAodmFyaWFibGVQcmVzZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIGlzIGFscmVhZHkgcHJlc2VudC4nYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEFkZGVkIHRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIHRvIHRoZSBjb250ZXh0LmApO1xuXG4gICAgdGhpcy52YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gIH1cblxuICBmaW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgcHJvY2VkdXJlID0gY29udGV4dC5maW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgfVxuXG4gIGlzUHJvY2VkdXJlUHJlc2VudEJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgIHByb2NlZHVyZVByZXNlbnQgPSBjb250ZXh0LmlzUHJvY2VkdXJlUHJlc2VudEJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTtcblxuICAgIHJldHVybiBwcm9jZWR1cmVQcmVzZW50O1xuICB9XG5cbiAgZmluZFZhcmlhYmxlQnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lLCBuZXN0ZWQgPSB0cnVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gdGhpcy5nZXRWYXJpYWJsZXMobmVzdGVkKSxcbiAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlcy5maW5kKCh2YXJpYWJsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVDb21wYXJlc1RvVmFyaWFibGVOYW1lID0gdmFyaWFibGUuY29tcGFyZVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAodmFyaWFibGVDb21wYXJlc1RvVmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cblxuICBpc1ZhcmlhYmxlUHJlc2VudEJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSwgbmVzdGVkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5maW5kVmFyaWFibGVCeVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUsIG5lc3RlZCksXG4gICAgICAgICAgdmFyaWFibGVQcmVzZW50ID0gKHZhcmlhYmxlICE9PSBudWxsKTtcblxuICAgIHJldHVybiB2YXJpYWJsZVByZXNlbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVZhcmlhYmxlcyh2YXJpYWJsZXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBibG9ja0NvbnRleHQgPSBDb250ZXh0LmZyb21Ob3RoaW5nKEJsb2NrQ29udGV4dCwgdmFyaWFibGVzLCBjb250ZXh0KVxuXG4gICAgcmV0dXJuIGJsb2NrQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuaW1wb3J0IEJsb2NrQ29udGV4dCBmcm9tIFwiLi4vY29udGV4dC9ibG9ja1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuY29uc3QgeyBhc3luY0ZvckVhY2ggfSA9IGFzeW5jaHJvbm91c1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFJldHVybkJsb2NrIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgc3RlcHMsIG5vbnNlbnNpY2FsLCByZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgdGhpcy5ub25zZW5zaWNhbCA9IG5vbnNlbnNpY2FsO1xuICAgIHRoaXMucmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50O1xuICB9XG5cbiAgZ2V0U3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHM7XG4gIH1cblxuICBpc05vbnNlbnNpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLm5vbnNlbnNpY2FsO1xuICB9XG5cbiAgZ2V0UmV0dXJuU3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlbWVudDtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKHZhcmlhYmxlcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRleHQgPSB2YXJpYWJsZXM7ICAvLy9cblxuICAgICAgdmFyaWFibGVzID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuQmxvY2tTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3JldHVybkJsb2NrU3RyaW5nfScgcmV0dXJuIGJsb2NrLi4uYCk7XG5cbiAgICBpZiAodGhpcy5ub25zZW5zaWNhbCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgcmV0dXJuIGJsb2NrIGlzIG5vbnNlbnNpY2FsLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja0NvbnRleHQgPSBCbG9ja0NvbnRleHQuZnJvbVZhcmlhYmxlcyh2YXJpYWJsZXMsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dCA9IGJsb2NrQ29udGV4dDsgLy8vXG5cbiAgICBhd2FpdCBhc3luY0ZvckVhY2godGhpcy5zdGVwcywgYXN5bmMgKHN0ZXApID0+IHtcbiAgICAgIGF3YWl0IHN0ZXAuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ZXJtID0gdGhpcy5yZXR1cm5TdGF0ZW1lbnQuZXZhbHVhdGUoY29udGV4dCksXG4gICAgICAgICAgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGBFdmFsdWF0ZWQuLi4gdGhlICcke3JldHVybkJsb2NrU3RyaW5nfScgcmV0dXJuIGJsb2NrIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJldHVybkJsb2NrXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbUJvb2xlYW4gfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE5lZ2F0ZWRUZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IG5lZ2F0ZWRUZXJtU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtuZWdhdGVkVGVybVN0cmluZ30nIG5lZ2F0ZWQgdGVybS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgbGVmdCB0ZXJtJ3MgdHlwZSBpcyAnJHt0ZXJtVHlwZX0nIHdoZW4gaXQgc2hvdWxkIGJlIG9mIHR5cGUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGxldCBib29sZWFuO1xuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCk7XG5cbiAgICBib29sZWFuID0gcHJpbWl0aXZlVmFsdWU7IC8vL1xuXG4gICAgYm9vbGVhbiA9ICFib29sZWFuO1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtuZWdhdGVkVGVybVN0cmluZ30nIG5lZ2F0ZWQgdGVybSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJOZWdhdGVkVGVybVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBMb2dpY2FsVGVybSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIGRpc2p1bmN0aW9uLCBsZWZ0VGVybSwgcmlnaHRUZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpc2p1bmN0aW9uID0gZGlzanVuY3Rpb247XG4gICAgdGhpcy5sZWZ0VGVybSA9IGxlZnRUZXJtO1xuICAgIHRoaXMucmlnaHRUZXJtID0gcmlnaHRUZXJtO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgaXNEaXNqdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNqdW5jdGlvbjtcbiAgfVxuXG4gIGdldExlZnRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnRUZXJtO1xuICB9XG5cbiAgZ2V0UmlnaHRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0VGVybTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IGxvZ2ljYWxUZXJtU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtsb2dpY2FsVGVybVN0cmluZ30nIGxvZ2ljYWwgdGVybS4uLmApO1xuXG4gICAgY29uc3QgbGVmdFRlcm0gPSB0aGlzLmxlZnRUZXJtLmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIHJpZ2h0VGVybSA9IHRoaXMucmlnaHRUZXJtLmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIGxlZnRUZXJtVHlwZSA9IGxlZnRUZXJtLmdldFR5cGUoKSxcbiAgICAgICAgICByaWdodFRlcm1UeXBlID0gcmlnaHRUZXJtLmdldFR5cGUoKTtcblxuICAgIGlmIChsZWZ0VGVybVR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgbGVmdFRlcm1TdHJpbmcgPSBsZWZ0VGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke2xlZnRUZXJtU3RyaW5nfScgbGVmdCB0ZXJtJ3MgdHlwZSBpcyAnJHtsZWZ0VGVybVR5cGV9JyB3aGVuIGl0IHNob3VsZCBiZSBvZiB0eXBlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRUZXJtVHlwZSAhPT0gQk9PTEVBTl9UWVBFKSB7XG4gICAgICBjb25zdCByaWdodFRlcm1TdHJpbmcgPSByaWdodFRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHtyaWdodFRlcm1TdHJpbmd9JyByaWdodCB0ZXJtJ3MgdHlwZSBpcyAnJHtyaWdodFRlcm1UeXBlfScgd2hlbiBpdCBzaG91bGQgYmUgb2YgdHlwZSAnJHtCT09MRUFOX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdFRlcm1QcmltaXRpdmVWYWx1ZSA9IGxlZnRUZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgcmlnaHRUZXJtUHJpbWl0aXZlVmFsdWUgPSByaWdodFRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBsZWZ0Qm9vbGVhbiA9bGVmdFRlcm1QcmltaXRpdmVWYWx1ZSwgLy8vXG4gICAgICAgICAgcmlnaHRCb29sZWFuID0gcmlnaHRUZXJtUHJpbWl0aXZlVmFsdWUsIC8vL1xuICAgICAgICAgIGJvb2xlYW4gPSB0aGlzLmRpc2p1bmN0aW9uID9cbiAgICAgICAgICAgICAgICAgICAgICAobGVmdEJvb2xlYW4gfHwgcmlnaHRCb29sZWFuKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAobGVmdEJvb2xlYW4gJiYgcmlnaHRCb29sZWFuKTtcblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bG9naWNhbFRlcm1TdHJpbmd9JyBsb2dpY2FsIHRlcm0gYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiTG9naWNhbFRlcm1cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIEJyYWNrZXRlZFRlcm0gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgfVxuXG4gIGdldFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGdldFR5cGUoKSB7IHJldHVybiB0aGlzLnRlcm0uZ2V0VHlwZSgpOyB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgYnJhY2tldGVkVGVybVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7YnJhY2tldGVkVGVybVN0cmluZ30nIGJyYWNrZXRlZCB0ZXJtLi4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy50ZXJtLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke2JyYWNrZXRlZFRlcm1TdHJpbmd9JyBicmFja2V0ZWQgdGVybSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJCcmFja2V0ZWRUZXJtXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUHJvY2VkdXJlQ2FsbCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHJlZmVyZW5jZSwgdGVybXMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICB0aGlzLnRlcm1zID0gdGVybXM7XG4gIH1cblxuICBnZXRSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlO1xuICB9XG5cbiAgZ2V0VGVybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybXM7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVOYW1lKCkgeyByZXR1cm4gdGhpcy5yZWZlcmVuY2UuZ2V0UHJvY2VkdXJlTmFtZSgpOyB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGF3YWl0IHRoaXMuYnJlYWsoY29udGV4dCk7XG5cbiAgICBjb25zdCBwcm9jZWR1cmVDYWxsU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cHJvY2VkdXJlQ2FsbFN0cmluZ30nIHByb2NlZHVyZSBjYWxsLi4uYCk7XG5cbiAgICBjb25zdCBwcm9jZWR1cmVOYW1lID0gdGhpcy5nZXRQcm9jZWR1cmVOYW1lKCksXG4gICAgICAgICAgcHJvY2VkdXJlUHJlc2VudCA9IGNvbnRleHQuaXNQcm9jZWR1cmVQcmVzZW50QnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpO1xuXG4gICAgaWYgKCFwcm9jZWR1cmVQcmVzZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHtwcm9jZWR1cmVDYWxsU3RyaW5nfSBwcm9jZWR1cmUgaXMgbm90IHByZXNlbnQuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9jZWR1cmUgPSBjb250ZXh0LmZpbmRQcm9jZWR1cmVCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSksXG4gICAgICAgICAgdGVybXMgPSB0aGlzLnRlcm1zLmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIHRlcm0gPSBhd2FpdCBwcm9jZWR1cmUuY2FsbCh0ZXJtcywgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7cHJvY2VkdXJlQ2FsbFN0cmluZ30nIHByb2NlZHVyZSBjYWxsIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlByb2NlZHVyZUNhbGxcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbUJvb2xlYW4gfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIENvbXBhcmlzb25UZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmVnYXRlZCwgbGVmdFRlcm0sIHJpZ2h0VGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgdGhpcy5sZWZ0VGVybSA9IGxlZnRUZXJtO1xuICAgIHRoaXMucmlnaHRUZXJtID0gcmlnaHRUZXJtO1xuICB9XG5cbiAgaXNOZWdhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0ZWQ7XG4gIH1cblxuICBnZXRMZWZ0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0VGVybTtcbiAgfVxuXG4gIGdldFJpZ2h0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodFRlcm07XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBjb21wYXJpc29uVGVybVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7Y29tcGFyaXNvblRlcm1TdHJpbmd9JyBjb21wYXJpc29uIHRlcm0uLi5gKTtcblxuICAgIGNvbnN0IGxlZnRUZXJtID0gdGhpcy5sZWZ0VGVybS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICByaWdodFRlcm0gPSB0aGlzLnJpZ2h0VGVybS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICBsZWZ0VGVybVR5cGUgPSBsZWZ0VGVybS5nZXRUeXBlKCksXG4gICAgICAgICAgcmlnaHRUZXJtVHlwZSA9IHJpZ2h0VGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAobGVmdFRlcm1UeXBlICE9PSByaWdodFRlcm1UeXBlKSB7XG4gICAgICBjb25zdCBsZWZ0VGVybVN0cmluZyA9IGxlZnRUZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgcmlnaHRUZXJtU3RyaW5nID0gcmlnaHRUZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7bGVmdFRlcm1TdHJpbmd9JyBsZWZ0IHRlcm0ncyB0eXBlIGlzICcke2xlZnRUZXJtVHlwZX0nIHdoZXJlYXMgdGhlICcke3JpZ2h0VGVybVN0cmluZ30nIHJpZ2h0IHRlcm0ncyB0eXBlIGlzICcke3JpZ2h0VGVybVR5cGV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdFRlcm1FcXVhbFRvUmlnaHRUZXJtID0gbGVmdFRlcm0uaXNFcXVhbFRvKHJpZ2h0VGVybSk7XG5cbiAgICBsZXQgYm9vbGVhbiA9IGxlZnRUZXJtRXF1YWxUb1JpZ2h0VGVybTsgLy8vXG5cbiAgICBpZiAodGhpcy5uZWdhdGVkKSB7XG4gICAgICBib29sZWFuID0gIWJvb2xlYW47IC8vL1xuICAgIH1cblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7Y29tcGFyaXNvblRlcm1TdHJpbmd9JyBjb21wYXJpc29uIHRlcm0gYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiQ29tcGFyaXNvblRlcm1cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBOYW1lZFBhcmFtZXRlciBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGFsaWFzKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEFsaWFzKCkge1xuICAgIHJldHVybiB0aGlzLmFsaWFzO1xuICB9XG5cbiAgaXNBbGlhc2VkKCkge1xuICAgIGNvbnN0IGFsaWFzZWQgPSAodGhpcy5hbGlhcyAhPT0gbnVsbCk7XG5cbiAgICByZXR1cm4gYWxpYXNlZDtcbiAgfVxuXG4gIGdldEFsaWFzZWROYW1lKCkge1xuICAgIGNvbnN0IGFsaWFzZWQgPSB0aGlzLmlzQWxpYXNlZCgpLFxuICAgICAgICAgIGFsaWFzZWROYW1lID0gYWxpYXNlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpYXMgOiAgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lOyAvLy9cblxuICAgIHJldHVybiBhbGlhc2VkTmFtZTtcbiAgfVxuXG4gIGNvbXBhcmVUZXJtKHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSB0ZXJtVHlwZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgJyR7dGhpcy50eXBlfScgdHlwZS5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyZWQgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLmApO1xuICB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyQ29tcGFyZXM7XG5cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlckEgPSB0aGlzLCAgLy8vXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJCID0gbmFtZWRQYXJhbWV0ZXI7IC8vL1xuXG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJBU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXJBLmdldFN0cmluZygpLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyQlN0cmluZyA9IG5hbWVkUGFyYW1ldGVyQi5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJBU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyQlN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgY29uc3QgbmFtZSA9IG5hbWVkUGFyYW1ldGVyLmdldE5hbWUoKSxcbiAgICAgICAgICB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpO1xuXG4gICAgbmFtZWRQYXJhbWV0ZXJDb21wYXJlcyA9ICgodGhpcy5uYW1lID09PSBuYW1lKSAmJiAodGhpcy50eXBlID09PSB0eXBlKSk7XG5cbiAgICBpZiAobmFtZWRQYXJhbWV0ZXJDb21wYXJlcykge1xuICAgICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyZWQgdGhlICcke25hbWVkUGFyYW1ldGVyQVN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlckJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVkUGFyYW1ldGVyQ29tcGFyZXM7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiTmFtZWRQYXJhbWV0ZXJcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Rlcm1cIjtcbmltcG9ydCB7IE5PREVfVFlQRSwgTk9ERVNfVFlQRSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgQXJyYXlBc3NpZ21lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcGFyYW1ldGVycykge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnM7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgYXJyYXlBc3NpZ25tZW50U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHthcnJheUFzc2lnbm1lbnRTdHJpbmd9JyBhcnJheSBhc3NpZ25tZW50Li4uYCk7XG5cbiAgICBjb25zdCB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFU19UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFU19UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIG5vZGVzID0gcHJpbWl0aXZlVmFsdWUsIC8vL1xuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIHBhcmFtZXRlcnNMZW5ndGggPSB0aGlzLnBhcmFtZXRlcnMuZ2V0TGVuZ3RoKCk7XG5cbiAgICBpZiAocGFyYW1ldGVyc0xlbmd0aCA+IG5vZGVzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5wYXJhbWV0ZXJzLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbm9kZXNTdHJpbmcgPSBjb250ZXh0Lm5vZGVzQXNTdHJpbmcobm9kZXgpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgbGVuZ3RoIG9mIHRoZSAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycyBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgJyR7bm9kZXNTdHJpbmd9JyBub2Rlcy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmZvckVhY2hQYXJhbWV0ZXIoKHBhcmFtZXRlciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgICAgICB0aGlzLmV2YWx1YXRlUGFyYW1ldGVyKHBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke2FycmF5QXNzaWdubWVudFN0cmluZ30nIGFycmF5IGFzc2lnbm1lbnQuYCk7XG4gIH1cblxuICBldmFsdWF0ZVBhcmFtZXRlcihwYXJhbWV0ZXIsIGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgICBjb25zdCBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvbi5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBwYXJhbWV0ZXJTdHJpbmcgPSBwYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIgYWdhaW5zdCB0aGUgJyR7ZXhwcmVzc2lvblN0cmluZ30nIGV4cHJlc3Npb24uLi5gKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlclR5cGUgPSBwYXJhbWV0ZXIuZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHBhcmFtZXRlclR5cGUgIT09IE5PREVfVFlQRSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgdHlwZSBvZiB0aGUgJyR7cGFyYW1ldGVyU3RyaW5nfScgcGFyYW1ldGVyIHNob3VsZCBiZSAnJHtOT0RFX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgeyBWYXJpYWJsZSB9ID0gZWxlbWVudHMsXG4gICAgICAgICAgdmFyaWFibGUgPSBWYXJpYWJsZS5mcm9tUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGV4dCk7XG5cbiAgICB2YXJpYWJsZS5hc3NpZ24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke3BhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlciBhZ2FpbnN0IHRoZSAnJHtleHByZXNzaW9uU3RyaW5nfScgZXhwcmVzc2lvbi5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJBcnJheUFzc2lnbm1lbnRcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFJldHVyblN0YXRlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICB9XG5cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgcmV0dXJuU3RhdGVtZW50U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cmV0dXJuU3RhdGVtZW50U3RyaW5nfScgcmV0dXJuIHN0YXRlbWVudC4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtyZXR1cm5TdGF0ZW1lbnRTdHJpbmd9JyByZXR1cm4gc3RhdGVtZW50IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJldHVyblN0YXRlbWVudFwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE5hbWVkUGFyYW1ldGVycyBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG5cbiAgZ2V0TmFtZWRQYXJhbWV0ZXIoaW5kZXgpIHtcbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlciA9IHRoaXMuYXJyYXlbaW5kZXhdIHx8IG51bGw7XG5cbiAgICByZXR1cm4gbmFtZWRQYXJhbWV0ZXI7XG4gIH1cblxuICBzb21lTmFtZWRQYXJhbWV0ZXIoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICBmb3JFYWNoTmFtZWRQYXJhbWV0ZXIoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGNvbXBhcmVUZXJtcyh0ZXJtcywgY29udGV4dCkge1xuICAgIGNvbnN0IHRlcm1zU3RyaW5nID0gdGVybXMuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke3Rlcm1zU3RyaW5nfScgdGVybXMgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJzU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVycy4uLmApO1xuXG4gICAgY29uc3QgdGVybXNMZW5ndGggPSB0ZXJtcy5nZXRMZW5ndGgoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlcnNMZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKHRlcm1zTGVuZ3RoICE9PSBuYW1lZFBhcmFtZXRlcnNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1zU3RyaW5nfScgdGVybXMgYW5kICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMgYXJlIG5vdCBvZiB0aGUgc2FtZSBsZW5ndGguYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZm9yRWFjaE5hbWVkUGFyYW1ldGVyKChuYW1lZFBhcmFtZXRlciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChuYW1lZFBhcmFtZXRlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0ZXJtID0gdGVybXMuZ2V0VGVybShpbmRleCk7XG5cbiAgICAgICAgbmFtZWRQYXJhbWV0ZXIuY29tcGFyZVRlcm0odGVybSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7dGVybXNTdHJpbmd9JyB0ZXJtcyB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzLmApO1xuICB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlcnNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZFBhcmFtZXRlciB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzLi4uYCk7XG5cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlckEgPSBuYW1lZFBhcmFtZXRlciwgLy8vXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJDb21wYXJlcyA9IHRoaXMuc29tZU5hbWVkUGFyYW1ldGVyKChuYW1lZFBhcmFtZXRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWVkUGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyQiA9IG5hbWVkUGFyYW1ldGVyLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgbmFtZWRQYXJhbWV0ZXJCQ29tcGFyZXNUb05hbWVkUGFyYW1ldGVyQSA9IG5hbWVkUGFyYW1ldGVyQS5jb21wYXJlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXJCLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICBpZiAobmFtZWRQYXJhbWV0ZXJCQ29tcGFyZXNUb05hbWVkUGFyYW1ldGVyQSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICBpZiAoIW5hbWVkUGFyYW1ldGVyQ29tcGFyZXMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWRQYXJhbWV0ZXIgZG9lcyBub3QgY29tcGFyZSB0byBhbnkgb2YgdGhlICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkUGFyYW1ldGVyIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMuYCk7XG4gIH1cblxuICBjb21wYXJlTmFtZWRQYXJhbWV0ZXJzKG5hbWVkUGFyYW1ldGVycywgY29udGV4dCkge1xuICAgIG5hbWVkUGFyYW1ldGVycy5mb3JFYWNoTmFtZWRQYXJhbWV0ZXIoKG5hbWVkUGFyYW1ldGVyKSA9PiB7XG4gICAgICBpZiAobmFtZWRQYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb21wYXJlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5hbWVkUGFyYW1ldGVyc1wiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vZGVQcm9wZXJ0eVN0cmluZ0Zyb21OYW1lQW5kVHlwZSB9IGZyb20gXCIuL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZVByb3BlcnR5IHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCB0eXBlLCBuYW1lKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgZ2V0U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGxldCBuYW1lZFBhcmFtZXRlckNvbXBhcmVzO1xuXG4gICAgY29uc3Qgbm9kZVByb3BlcnR5U3RyaW5nID0gdGhpcy5zdHJpbmcsIC8vL1xuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke25vZGVQcm9wZXJ0eVN0cmluZ30nIG5vZGUgcHJvcGVydHkgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlci5nZXROYW1lKCksXG4gICAgICAgICAgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKTtcblxuICAgIG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMgPSAoKHRoaXMubmFtZSA9PT0gbmFtZSkgJiYgKHRoaXMudHlwZSA9PT0gdHlwZSkpO1xuXG4gICAgaWYgKG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtub2RlUHJvcGVydHlTdHJpbmd9JyBub2RlIHByb3BlcnR5IHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLmApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lZFBhcmFtZXRlckNvbXBhcmVzO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlBhcmFtZXRlclwiO1xuXG4gIHN0YXRpYyBmcm9tTmFtZUFuZFR5cGUobmFtZSwgdHlwZSkge1xuICAgIGNvbnN0IG5vZGVQcm9wZXJ0eVN0cmluZyA9IG5vZGVQcm9wZXJ0eVN0cmluZ0Zyb21OYW1lQW5kVHlwZShuYW1lLCB0eXBlKSxcbiAgICAgICAgICBzdHJpbmcgPSBub2RlUHJvcGVydHlTdHJpbmcsICAvLy9cbiAgICAgICAgICBub2RlUHJvcGVydHkgPSBuZXcgTm9kZVByb3BlcnR5KHN0cmluZywgdHlwZSwgbmFtZSk7XG5cbiAgICByZXR1cm4gbm9kZVByb3BlcnR5O1xuICB9XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgQ09OVEVOVF9QQVJBTUVURVJfTkFNRSA9IFwiY29udGVudFwiO1xuZXhwb3J0IGNvbnN0IFRFUk1JTkFMX1BBUkFNRVRFUl9OQU1FID0gXCJ0ZXJtaW5hbFwiO1xuZXhwb3J0IGNvbnN0IENISUxEX05PREVTX1BBUkFNRVRFUl9OQU1FID0gXCJjaGlsZE5vZGVzXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4vZXhjZXB0aW9uXCI7XG5pbXBvcnQgTm9kZVByb3BlcnR5IGZyb20gXCIuL25vZGVQcm9wZXJ0eVwiO1xuXG5pbXBvcnQgeyBOT0RFU19UWVBFLCBTVFJJTkdfVFlQRSwgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IG5vZGVQcm9wZXJ0aWVzU3RyaW5nRnJvbU5vZGVQcm9wZXJ0aWVzQXJyYXkgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyBDT05URU5UX1BBUkFNRVRFUl9OQU1FLCBURVJNSU5BTF9QQVJBTUVURVJfTkFNRSwgQ0hJTERfTk9ERVNfUEFSQU1FVEVSX05BTUUgfSBmcm9tIFwiLi9wYXJhbWV0ZXJOYW1lc1wiO1xuXG5jbGFzcyBOb2RlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZywgYXJyYXkpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBzb21lTm9kZVByb3BlcnR5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5LnNvbWUoY2FsbGJhY2spOyB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgbm9kZVByb3BlcnRpZXNTdHJpbmcgPSB0aGlzLnN0cmluZywgLy8vXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgd2l0aCB0aGUgJyR7bm9kZVByb3BlcnRpZXNTdHJpbmd9JyBub2RlIHByb3BlcnRpZXMuLi5gKTtcblxuICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyc0NvbXBhcmUgPSB0aGlzLnNvbWVOb2RlUHJvcGVydHkoKG5vZGVQcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJDb21wYXJlc1RvTm9kZVByb3BlcnR5ID0gbm9kZVByb3BlcnR5LmNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCk7XG5cbiAgICAgIGlmIChuYW1lZFBhcmFtZXRlckNvbXBhcmVzVG9Ob2RlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIW5hbWVkUGFyYW1ldGVyc0NvbXBhcmUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIGRvZXMgbm90IGNvbXBtYXJlIHRvIGFueSBvZiB0aGUgJyR7bm9kZVByb3BlcnRpZXNTdHJpbmd9JyBub2RlIHByb3BlcnRpZXMuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciB3aXRoIHRoZSAnJHtub2RlUHJvcGVydGllc1N0cmluZ30nIG5vZGUgcHJvcGVydGllcy5gKTtcbiAgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcnMobmFtZWRQYXJhbWV0ZXJzLCBjb250ZXh0KSB7XG4gICAgbmFtZWRQYXJhbWV0ZXJzLmZvckVhY2hOYW1lZFBhcmFtZXRlcigobmFtZWRQYXJhbWV0ZXIpID0+IHtcbiAgICAgIHRoaXMuY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBub2RlUHJvcGVydGllc0FycmF5ID0gbm9kZVByb3BlcnRpZXNBcnJheUZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgc3RyaW5nID0gbm9kZVByb3BlcnRpZXNTdHJpbmdGcm9tTm9kZVByb3BlcnRpZXNBcnJheShub2RlUHJvcGVydGllc0FycmF5KSxcbiAgICAgICAgICBhcnJheSA9IG5vZGVQcm9wZXJ0aWVzQXJyYXksICAvLy9cbiAgICAgICAgICBub2RlUHJvcGVydGllcyA9IG5ldyBOb2RlUHJvcGVydGllcyhzdHJpbmcsIGFycmF5KTtcblxuICAgIHJldHVybiBub2RlUHJvcGVydGllcztcbiAgfVxufVxuXG5jb25zdCBub2RlUHJvcGVydGllcyA9IE5vZGVQcm9wZXJ0aWVzLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVQcm9wZXJ0aWVzO1xuXG5mdW5jdGlvbiBub2RlUHJvcGVydGllc0FycmF5RnJvbU5vdGhpbmcoKSB7XG4gIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgIFNUUklOR19UWVBFLFxuICAgICAgICAgIEJPT0xFQU5fVFlQRSxcbiAgICAgICAgICBOT0RFU19UWVBFLFxuICAgICAgICBdLFxuICAgICAgICBuYW1lcyA9IFtcbiAgICAgICAgICBDT05URU5UX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICAgIFRFUk1JTkFMX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICAgIENISUxEX05PREVTX1BBUkFNRVRFUl9OQU1FXG4gICAgICAgIF0sXG4gICAgICAgIG5vZGVQcm9wZXJ0aWVzQXJyYXkgPSBuYW1lcy5tYXAoKG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBub2RlUHJvcGVydHkgPSBOb2RlUHJvcGVydHkuZnJvbU5hbWVBbmRUeXBlKG5hbWUsIHR5cGUpO1xuXG4gICAgICAgICAgcmV0dXJuIG5vZGVQcm9wZXJ0eTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIG5vZGVQcm9wZXJ0aWVzQXJyYXk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuaW1wb3J0IG5vZGVQcm9wZXJ0aWVzIGZyb20gXCIuLi8uLi9ub2RlUHJvcGVydGllc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IHN0cmluZ0xpdGVyYWxGcm9tU3RyaW5nIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIE5PREVTX1RZUEUsIFNUUklOR19UWVBFLCBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZXMsIHRlcm1Gcm9tQm9vbGVhbiwgdGVybUZyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5pbXBvcnQgeyBDT05URU5UX1BBUkFNRVRFUl9OQU1FLCBURVJNSU5BTF9QQVJBTUVURVJfTkFNRSwgQ0hJTERfTk9ERVNfUEFSQU1FVEVSX05BTUUgfSBmcm9tIFwiLi4vLi4vcGFyYW1ldGVyTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE9iamVjdEFzc2lnbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBuYW1lZFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5uYW1lZFBhcmFtZXRlcnMgPSBuYW1lZFBhcmFtZXRlcnM7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldE5hbWVkUGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lZFBhcmFtZXRlcnM7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3Qgb2JqZWN0QXNzaWdubWVudFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7b2JqZWN0QXNzaWdubWVudFN0cmluZ30nIG9iamVjdCBhc3NpZ25tZW50Li4uYCk7XG5cbiAgICBjb25zdCB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBub2RlUHJvcGVydGllcy5jb21wYXJlTmFtZWRQYXJhbWV0ZXJzKHRoaXMubmFtZWRQYXJhbWV0ZXJzLCBjb250ZXh0KTtcblxuICAgIHRoaXMubmFtZWRQYXJhbWV0ZXJzLmZvckVhY2hOYW1lZFBhcmFtZXRlcigobmFtZWRQYXJhbWV0ZXIpID0+IHtcbiAgICAgIHRoaXMuZXZhbHVhdGVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke29iamVjdEFzc2lnbm1lbnRTdHJpbmd9JyBvYmplY3QgYXNzaWdubWVudC5gKTtcbiAgfVxuXG4gIGV2YWx1YXRlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgYWdhaW5zdCB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0uLi5gKTtcblxuICAgIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlci5nZXROYW1lKCk7XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgQ09OVEVOVF9QQVJBTUVURVJfTkFNRToge1xuICAgICAgICB0ZXJtID0gdGhpcy5ldmFsdWF0ZUNvbnRlbnROYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgVEVSTUlOQUxfUEFSQU1FVEVSX05BTUU6IHtcbiAgICAgICAgdGVybSA9IHRoaXMuZXZhbHVhdGVUZXJtaW5hbE5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCB0ZXJtLCBjb250ZXh0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBDSElMRF9OT0RFU19QQVJBTUVURVJfTkFNRToge1xuICAgICAgICB0ZXJtID0gdGhpcy5ldmFsdWF0ZUNoaWxkTm9kZXNOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBWYXJpYWJsZSB9ID0gZWxlbWVudHMsXG4gICAgICAgICAgdmFyaWFibGUgPSBWYXJpYWJsZS5mcm9tTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpO1xuXG4gICAgdmFyaWFibGUuYXNzaWduKHRlcm0sIGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlciBuYW1lZCBhZ2FpbnN0IHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybS5gKTtcbiAgfVxuXG4gIGV2YWx1YXRlQ29udGVudE5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCB0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgY29udGVudCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgaWYgKHR5cGUgIT09IFNUUklOR19UWVBFKSB7XG4gICAgICBjb25zdCBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIncyB0eXBlIHNob3VsZCBiZSAnJHtTVFJJTkdfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBub2RlID0gcHJpbWl0aXZlVmFsdWUsICAvLy9cbiAgICAgICAgICBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKCFub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3Mgbm9kZSBtdXN0IGJlIHRlcm1pbmFsLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgc3RyaW5nID0gY29udGVudCwgIC8vL1xuICAgICAgICAgIHN0cmluZ0xpdGVyYWwgPSBzdHJpbmdMaXRlcmFsRnJvbVN0cmluZyhzdHJpbmcpO1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHRyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgY29udGVudCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciBhcyAnJHt0ZXJtU3R0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBldmFsdWF0ZVRlcm1pbmFsTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSB0ZXJtaW5hbCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgaWYgKHR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgdHlwZSBzaG91bGQgYmUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIG5vZGUgPSBwcmltaXRpdmVWYWx1ZSwgIC8vL1xuICAgICAgICAgIG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgdGVybWluYWwgPSBub2RlVGVybWluYWxOb2RlOyAgLy8vXG5cbiAgICBjb25zdCBib29sZWFuID0gdGVybWluYWw7IC8vL1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KTsgIC8vL1xuXG4gICAgY29uc3QgdGVybVN0dHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSB0ZXJtaW5hbCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciBhcyAnJHt0ZXJtU3R0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBldmFsdWF0ZUNoaWxkTm9kZXNOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCkge1xuICAgIGNvbnN0IHR5cGUgPSBuYW1lZFBhcmFtZXRlci5nZXRUeXBlKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlIGNoaWxkIG5vZGVzICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLi4uYCk7XG5cbiAgICBpZiAodHlwZSAhPT0gTk9ERVNfVFlQRSkge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgdHlwZSBzaG91bGQgYmUgJyR7Tk9ERVNfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBub2RlID0gcHJpbWl0aXZlVmFsdWUsICAvLy9cbiAgICAgICAgICBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKCFub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3Mgbm9kZSBtdXN0IGJlIG5vbi10ZXJtaW5hbC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIG5vZGVzID0gY2hpbGROb2RlczsgIC8vL1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0dHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSBjaGlsZE5vZGVzICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIGFzICcke3Rlcm1TdHRyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJPYmplY3RBc3NpZ21lbnRcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB2YXJpYWJsZXNGcm9tVGVybXNBbmRQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3Byb2NlZHVyZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgQW5vbnltb3VzUHJvY2VkdXJlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5yZXR1cm5CbG9jayA9IHJldHVybkJsb2NrO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzO1xuICB9XG5cbiAgZ2V0UmV0dXJuQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucmV0dXJuQmxvY2s7XG4gIH1cblxuICBhc3luYyBjYWxsKHRlcm1zLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBDYWxsaW5nIHRoZSAnJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9JyBhbm9ueW1vdXMgcHJvY2VkdXJlLi4uYCk7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMuY29tcGFyZVRlcm1zKHRlcm1zLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHZhcmlhYmxlc0Zyb21UZXJtc0FuZFBhcmFtZXRlcnModGVybXMsIHRoaXMucGFyYW1ldGVycywgY29udGV4dCksXG4gICAgICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmV0dXJuQmxvY2suZXZhbHVhdGUodmFyaWFibGVzLCBjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdGVybVR5cGUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9JyBhbm9ueW1vdXMgcHJvY2VkdXJlJ3MgJyR7dGhpcy50eXBlfScgdHlwZS5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY2FsbGVkIHRoZSAnJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9JyBhbm9ueW1vdXMgcHJvY2VkdXJlLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiQW5vbnltb3VzUHJvY2VkdXJlXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgZXhwcmVzc2lvbikge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3ZhcmlhYmxlQXNzaWdubWVudFN0cmluZ30nIHZhcmlhYmxlIGFzc2lnbm1lbnQuLi5gKTtcblxuICAgIHRlcm0gPSBhd2FpdCB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICB0aGlzLnZhcmlhYmxlLmFzc2lnbih0ZXJtLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHt2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmd9JyB2YXJpYWJsZSBhc3NpZ25tZW50IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlZhcmlhYmxlQXNzaWdubWVudFwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQsIGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmNvbnN0IHsgYXN5bmNGb3JFYWNoIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnRzIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7dmFyaWFibGVBc3NpZ25tZW50c1N0cmluZ30nIHZhcmlhYmxlIGFzc2lnbm1lbnRzLi4uYCk7XG5cbiAgICBhd2FpdCBhc3luY0ZvckVhY2godGhpcy5hcnJheSwgYXN5bmMgKHZhcmlhYmxlQXNzaWdubWVudCkgPT4ge1xuICAgICAgYXdhaXQgdmFyaWFibGVBc3NpZ25tZW50LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHt2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nfScgdmFyaWFibGUgYXNzaWdubWVudHMuYCk7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVmFyaWFibGVBc3NpZ25tZW50c1wiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUHJvY2VkdXJlRGVjbGFyYXRpb24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCBwcm9jZWR1cmUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnByb2NlZHVyZSA9IHByb2NlZHVyZTtcbiAgfVxuXG4gIGdldFByb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZWR1cmU7XG4gIH1cblxuICB2ZXJpZnkoY29udGV4dCkge1xuICAgIGNvbnN0IHZlcmlmaWVzID0gdHJ1ZTtcblxuICAgIGNvbnN0IHByb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7cHJvY2VkdXJlRGVjbGFyYXRpb25TdHJpbmd9JyBwcm9jZWR1cmUgZGVjbGFyYXRpb24uLi5gKVxuXG4gICAgY29uc3QgcHJvY2VkdXJlID0gdGhpcy5nZXRQcm9jZWR1cmUoKTtcblxuICAgIGNvbnRleHQuYWRkUHJvY2VkdXJlKHByb2NlZHVyZSk7XG5cbiAgICBpZiAodmVyaWZpZXMpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZ30nIHByb2NlZHVyZSBkZWNsYXJhdGlvbi5gKVxuICAgIH1cblxuICAgIHJldHVybiB2ZXJpZmllcztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQcm9jZWR1cmVEZWNsYXJhdGlvblwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTdGVwIGZyb20gXCIuL2VsZW1lbnQvc3RlcFwiO1xuaW1wb3J0IFNvbWUgZnJvbSBcIi4vZWxlbWVudC9zb21lXCI7XG5pbXBvcnQgVGVybSBmcm9tIFwiLi9lbGVtZW50L3Rlcm1cIjtcbmltcG9ydCBUZXJtcyBmcm9tIFwiLi9lbGVtZW50L3Rlcm1zXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4vZWxlbWVudC9sYWJlbFwiO1xuaW1wb3J0IEVycm9yIGZyb20gXCIuL2VsZW1lbnQvZXJyb3JcIjtcbmltcG9ydCBFdmVyeSBmcm9tIFwiLi9lbGVtZW50L2V2ZXJ5XCI7XG5pbXBvcnQgUmVkdWNlIGZyb20gXCIuL2VsZW1lbnQvcmVkdWNlXCI7XG5pbXBvcnQgVGVybmFyeSBmcm9tIFwiLi9lbGVtZW50L3Rlcm5hcnlcIjtcbmltcG9ydCBWYXJpYWJsZSBmcm9tIFwiLi9lbGVtZW50L3ZhcmlhYmxlXCI7XG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gXCIuL2VsZW1lbnQvcHJpbWl0aXZlXCI7XG5pbXBvcnQgUmVmZXJlbmNlIGZyb20gXCIuL2VsZW1lbnQvcmVmZXJlbmNlXCI7XG5pbXBvcnQgUHJvY2VkdXJlIGZyb20gXCIuL2VsZW1lbnQvcHJvY2VkdXJlXCI7XG5pbXBvcnQgTm9kZVF1ZXJ5IGZyb20gXCIuL2VsZW1lbnQvbm9kZVF1ZXJ5XCI7XG5pbXBvcnQgUGFyYW1ldGVyIGZyb20gXCIuL2VsZW1lbnQvcGFyYW1ldGVyXCI7XG5pbXBvcnQgUGFyYW1ldGVycyBmcm9tIFwiLi9lbGVtZW50L3BhcmFtZXRlcnNcIjtcbmltcG9ydCBOb2Rlc1F1ZXJ5IGZyb20gXCIuL2VsZW1lbnQvbm9kZXNRdWVyeVwiO1xuaW1wb3J0IEV4cHJlc3Npb24gZnJvbSBcIi4vZWxlbWVudC9leHByZXNzaW9uXCI7XG5pbXBvcnQgUmV0dXJuQmxvY2sgZnJvbSBcIi4vZWxlbWVudC9yZXR1cm5CbG9ja1wiO1xuaW1wb3J0IE5lZ2F0ZWRUZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9uZWdhdGVkXCI7XG5pbXBvcnQgTG9naWNhbFRlcm0gZnJvbSBcIi4vZWxlbWVudC90ZXJtL2xvZ2ljYWxcIjtcbmltcG9ydCBCcmFja2V0ZWRUZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9icmFja2V0ZWRcIjtcbmltcG9ydCBQcm9jZWR1cmVDYWxsIGZyb20gXCIuL2VsZW1lbnQvcHJvY2VkdXJlQ2FsbFwiO1xuaW1wb3J0IENvbXBhcmlzb25UZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9jb21wYXJpc29uXCI7XG5pbXBvcnQgTmFtZWRQYXJhbWV0ZXIgZnJvbSBcIi4vZWxlbWVudC9wYXJhbWV0ZXIvbmFtZWRcIjtcbmltcG9ydCBBcnJheUFzc2lnbWVudCBmcm9tIFwiLi9lbGVtZW50L2Fzc2lnbm1lbnQvYXJyYXlcIjtcbmltcG9ydCBSZXR1cm5TdGF0ZW1lbnQgZnJvbSBcIi4vZWxlbWVudC9zdGF0ZW1lbnQvcmV0dXJuXCI7XG5pbXBvcnQgTmFtZWRQYXJhbWV0ZXJzIGZyb20gXCIuL2VsZW1lbnQvcGFyYW1ldGVycy9uYW1lZFwiO1xuaW1wb3J0IE9iamVjdEFzc2lnbm1lbnQgZnJvbSBcIi4vZWxlbWVudC9hc3NpZ25tZW50L29iamVjdFwiO1xuaW1wb3J0IEFub255bW91c1Byb2NlZHVyZSBmcm9tIFwiLi9lbGVtZW50L3Byb2NlZHVyZS9hbm9ueW1vdXNcIjtcbmltcG9ydCBWYXJpYWJsZUFzc2lnbm1lbnQgZnJvbSBcIi4vZWxlbWVudC9hc3NpZ25tZW50L3ZhcmlhYmxlXCI7XG5pbXBvcnQgVmFyaWFibGVBc3NpZ25tZW50cyBmcm9tIFwiLi9lbGVtZW50L2Fzc2lnbm1lbnRzL3ZhcmlhYmxlXCI7XG5pbXBvcnQgUHJvY2VkdXJlRGVjbGFyYXRpb24gZnJvbSBcIi4vZWxlbWVudC9kZWNsYXJhdGlvbi9wcm9jZWR1cmVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRnVydGxlTGV4ZXIgYXMgRnVydGxlTGV4ZXJCYXNlIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXJzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZUxleGVyIGV4dGVuZHMgRnVydGxlTGV4ZXJCYXNlIHt9XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBTVEVQX1JVTEVfTkFNRSA9IFwic3RlcFwiO1xuZXhwb3J0IGNvbnN0IFNPTUVfUlVMRV9OQU1FID0gXCJzb21lXCI7XG5leHBvcnQgY29uc3QgVEVSTV9SVUxFX05BTUUgPSBcInRlcm1cIjtcbmV4cG9ydCBjb25zdCBURVJNU19SVUxFX05BTUUgPSBcInRlcm1zXCI7XG5leHBvcnQgY29uc3QgRVZFUllfUlVMRV9OQU1FID0gXCJldmVyeVwiO1xuZXhwb3J0IGNvbnN0IExBQkVMX1JVTEVfTkFNRSA9IFwibGFiZWxcIjtcbmV4cG9ydCBjb25zdCBFUlJPUl9SVUxFX05BTUUgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgUkVEVUNFX1JVTEVfTkFNRSA9IFwicmVkdWNlXCI7XG5leHBvcnQgY29uc3QgVEVSTkFSWV9SVUxFX05BTUUgPSBcInRlcm5hcnlcIjtcbmV4cG9ydCBjb25zdCBWQVJJQUJMRV9SVUxFX05BTUUgPSBcInZhcmlhYmxlXCI7XG5leHBvcnQgY29uc3QgTk9OU0VOU0VfUlVMRV9OQU1FID0gXCJub25zZW5zZVwiO1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1JVTEVfTkFNRSA9IFwiZG9jdW1lbnRcIjtcbmV4cG9ydCBjb25zdCBQUklNSVRJVkVfUlVMRV9OQU1FID0gXCJwcmltaXRpdmVcIjtcbmV4cG9ydCBjb25zdCBSRUZFUkVOQ0VfUlVMRV9OQU1FID0gXCJyZWZlcmVuY2VcIjtcbmV4cG9ydCBjb25zdCBQQVJBTUVURVJfUlVMRV9OQU1FID0gXCJwYXJhbWV0ZXJcIjtcbmV4cG9ydCBjb25zdCBOT0RFX1FVRVJZX1JVTEVfTkFNRSA9IFwibm9kZVF1ZXJ5XCI7XG5leHBvcnQgY29uc3QgRVhQUkVTU0lPTl9SVUxFX05BTUUgPSBcImV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBQQVJBTUVURVJTX1JVTEVfTkFNRSA9IFwicGFyYW1ldGVyc1wiO1xuZXhwb3J0IGNvbnN0IE5PREVTX1FVRVJZX1JVTEVfTkFNRSA9IFwibm9kZXNRdWVyeVwiO1xuZXhwb3J0IGNvbnN0IFJFVFVSTl9CTE9DS19SVUxFX05BTUUgPSBcInJldHVybkJsb2NrXCI7XG5leHBvcnQgY29uc3QgTE9HSUNBTF9URVJNX1JVTEVfTkFNRSA9IFwibG9naWNhbFRlcm1cIjtcbmV4cG9ydCBjb25zdCBORUdBVEVEX1RFUk1fUlVMRV9OQU1FID0gXCJuZWdhdGVkVGVybVwiO1xuZXhwb3J0IGNvbnN0IEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSA9IFwiYnJhY2tldGVkVGVybVwiO1xuZXhwb3J0IGNvbnN0IFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSA9IFwicHJvY2VkdXJlQ2FsbFwiO1xuZXhwb3J0IGNvbnN0IENPTVBBUklTT05fVEVSTV9SVUxFX05BTUUgPSBcImNvbXBhcmlzb25UZXJtXCI7XG5leHBvcnQgY29uc3QgTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRSA9IFwibmFtZWRQYXJhbWV0ZXJcIjtcbmV4cG9ydCBjb25zdCBOQU1FRF9QQVJBTUVURVJTX1JVTEVfTkFNRSA9IFwibmFtZWRQYXJhbWV0ZXJzXCI7XG5leHBvcnQgY29uc3QgUkVUVVJOX1NUQVRFTUVOVF9SVUxFX05BTUUgPSBcInJldHVyblN0YXRlbWVudFwiO1xuZXhwb3J0IGNvbnN0IEFSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FID0gXCJhcnJheUFzc2lnbm1lbnRcIjtcbmV4cG9ydCBjb25zdCBPQkpFQ1RfQVNTSUdOTUVOVF9SVUxFX05BTUUgPSBcIm9iamVjdEFzc2lnbm1lbnRcIjtcbmV4cG9ydCBjb25zdCBWQVJJQUJMRV9BU1NJR05NRU5UX1JVTEVfTkFNRSA9IFwidmFyaWFibGVBc3NpZ25tZW50XCI7XG5leHBvcnQgY29uc3QgQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUgPSBcImFub255bW91c1Byb2NlZHVyZVwiO1xuZXhwb3J0IGNvbnN0IFZBUklBQkxFX0FTU0lHTk1FTlRTX1JVTEVfTkFNRSA9IFwidmFyaWFibGVBc3NpZ25tZW50c1wiO1xuZXhwb3J0IGNvbnN0IFBST0NFRFVSRV9ERUNMQVJBVElPTl9SVUxFX05BTUUgPSBcInByb2NlZHVyZURlY2xhcmF0aW9uXCI7XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBBUlJBWV9BU1NJR05NRU5UX1JVTEVfTkFNRSwgT0JKRUNUX0FTU0lHTk1FTlRfUlVMRV9OQU1FLCBWQVJJQUJMRV9BU1NJR05NRU5UU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RlcE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRBcnJheUFzc2lnbm1lbnROb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gQVJSQVlfQVNTSUdOTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICAgYXJyYXlBc3NpZ25tZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGFycmF5QXNzaWdubWVudE5vZGU7XG4gIH1cblxuICBnZXRPYmplY3RBc3NpZ25tZW50Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE9CSkVDVF9BU1NJR05NRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgICBvYmplY3RBc3NpZ25tZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG9iamVjdEFzc2lnbm1lbnROb2RlO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVBc3NpZ25tZW50c05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9BU1NJR05NRU5UU19SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50c05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU3RlcE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvbWVOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxvZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsb2VOb2RlO1xuICB9XG5cbiAgZ2V0QW5vbnltb3VzUHJvY2VkdXJlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEFOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FLFxuICAgICAgICAgIGFub255bW91c1Byb2NlZHVyZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTb21lTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgUFJJTUlUSVZFX1JVTEVfTkFNRSxcbiAgICAgICAgIE5FR0FURURfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgQlJBQ0tFVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgQ09NUEFSSVNPTl9URVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgZ2V0UHJpbWl0aXZlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBSSU1JVElWRV9SVUxFX05BTUUsXG4gICAgICAgICAgcHJpbWl0aXZlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByaW1pdGl2ZU5vZGU7XG4gIH1cblxuICBnZXROZWdhdGVkVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBORUdBVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIG5lZ2F0ZWRUZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5lZ2F0ZWRUZXJtTm9kZTtcbiAgfVxuXG4gIGdldExvZ2ljYWxUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IExPR0lDQUxfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgbG9naWNhbFRlcm1SdWxlTmFtZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGxvZ2ljYWxUZXJtUnVsZU5hbWU7XG4gIH1cblxuICBnZXRCcmFja2V0ZWRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICBicmFja2V0ZWRUZXJtUnVsZU5hbWUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBicmFja2V0ZWRUZXJtUnVsZU5hbWU7XG4gIH1cblxuICBnZXRDb21wYXJpc29uVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIGNvbXBhcmlzb25Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gY29tcGFyaXNvbk5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBvcGFjaXR5OyAvLy9cblxuICAgICAgb3BhY2l0eSA9IGNoaWxkTm9kZXM7IC8vL1xuXG4gICAgICBjaGlsZE5vZGVzID0gcnVsZU5hbWU7ICAvLy9cblxuICAgICAgcnVsZU5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gVGVybU5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgdGVybU5vZGUgPSBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRUZXJtTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShUZXJtTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlcnlOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXZlcnlOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRZUEVfVE9LRU5fVFlQRSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IE5BTUVfVE9LRU5fVFlQRSA9IFwibmFtZVwiO1xuZXhwb3J0IGNvbnN0IE5VTExfVE9LRU5fVFlQRSA9IFwibnVsbFwiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUl9UT0tFTl9UWVBFID0gXCJudW1iZXJcIjtcbmV4cG9ydCBjb25zdCBTUEVDSUFMX1RPS0VOX1RZUEUgPSBcInNwZWNpYWxcIjtcbmV4cG9ydCBjb25zdCBCT09MRUFOX1RPS0VOX1RZUEUgPSBcImJvb2xlYW5cIjtcbmV4cG9ydCBjb25zdCBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFID0gXCJzdHJpbmctbGl0ZXJhbFwiO1xuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5BTUVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKExhYmVsTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShFcnJvck5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgRVhQUkVTU0lPTl9SVUxFX05BTUUsIEFOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb25Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZXhwcmVzc2lvbk5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBleHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVkdWNlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSwgRVhQUkVTU0lPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm5hcnlOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0RXhwcmVzc2lvbk5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZXhwcmVzc2lvbk5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGV4cHJlc3Npb25Ob2RlcztcbiAgfVxuXG4gIGdldElmRXhwcmVzc2lvbk5vZGUoKSB7XG4gICAgY29uc3QgZmlyc3RFeHByZXNzaW9uTm9kZSA9IHRoaXMuZ2V0Rmlyc3RFeHByZXNzaW9uTm9kZSgpLFxuICAgICAgICAgIGlmRXhwcmVzc2lvbk5vZGUgPSBmaXJzdEV4cHJlc3Npb25Ob2RlOyAgLy8vXG5cbiAgICByZXR1cm4gaWZFeHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIGdldEVsc2VFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBzZWNvbmRFeHByZXNzaW9uTm9kZSA9IHRoaXMuZ2V0U2Vjb25kRXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgICBlbHNlRXhwcmVzc2lvbk5vZGUgPSBzZWNvbmRFeHByZXNzaW9uTm9kZTsgLy8vXG5cbiAgICByZXR1cm4gZWxzZUV4cHJlc3Npb25Ob2RlO1xuICB9XG5cbiAgZ2V0Rmlyc3RFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBleHByZXNzaW9uTm9kZXMgPSB0aGlzLmdldEV4cHJlc3Npb25Ob2RlcygpLFxuICAgICAgICAgIGZpcnN0RXhwcmVzc2lvbk5vZGUgPSBmaXJzdChleHByZXNzaW9uTm9kZXMpO1xuXG4gICAgcmV0dXJuIGZpcnN0RXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBnZXRTZWNvbmRFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBleHByZXNzaW9uTm9kZXMgPSB0aGlzLmdldEV4cHJlc3Npb25Ob2RlcygpLFxuICAgICAgICAgIHNlY29uZEV4cHJlc3Npb25Ob2RlID0gc2Vjb25kKGV4cHJlc3Npb25Ob2Rlcyk7XG5cbiAgICByZXR1cm4gc2Vjb25kRXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFRlcm5hcnlOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKERvY3VtZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFyaWFibGVOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5BTUVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFZhcmlhYmxlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uc2Vuc2VOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShOb25zZW5zZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBudWxsTm9kZSBmcm9tIFwiLi4vbnVsbE5vZGVcIjtcblxuaW1wb3J0IHsgTlVMTCwgVFJVRSwgRkFMU0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIFNUUklOR19UWVBFLCBOVU1CRVJfVFlQRSwgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBOVUxMX1RPS0VOX1RZUEUsIE5VTUJFUl9UT0tFTl9UWVBFLCBCT09MRUFOX1RPS0VOX1RZUEUsIFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmltaXRpdmVOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZTtcblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUoKSxcbiAgICAgICAgICBudW1iZXIgPSB0aGlzLmdldE51bWJlcigpLFxuICAgICAgICAgIGJvb2xlYW4gPSB0aGlzLmdldEJvb2xlYW4oKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IE5PREVfVFlQRTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IE5VTUJFUl9UWVBFO1xuICAgIH0gZWxzZSBpZiAoYm9vbGVhbiAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IEJPT0xFQU5fVFlQRTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZ0xpdGVyYWwgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBTVFJJTkdfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIGxldCB2YWx1ZTtcblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUoKSxcbiAgICAgICAgICBudW1iZXIgPSB0aGlzLmdldE51bWJlcigpLFxuICAgICAgICAgIGJvb2xlYW4gPSB0aGlzLmdldEJvb2xlYW4oKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBub2RlOyAvLy9cbiAgICB9IGVsc2UgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBudW1iZXI7IC8vL1xuICAgIH0gZWxzZSBpZiAoYm9vbGVhbiAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBib29sZWFuOyAgLy8vXG4gICAgfSBlbHNlIGlmIChzdHJpbmdMaXRlcmFsICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ0xpdGVyYWw7ICAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBnZXROb2RlKCkge1xuICAgIGxldCBub2RlID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5VTExfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgaWYgKGNvbnRlbnQgPT09IE5VTEwpIHtcbiAgICAgICAgbm9kZSA9IG51bGxOb2RlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldE51bWJlcigpIHtcbiAgICBsZXQgbnVtYmVyID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5VTUJFUl9UT0tFTl9UWVBFOyAvLy9cblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgaWYgKGNvbnRlbnQgPT09IFRSVUUpIHtcbiAgICAgICAgbnVtYmVyID0gTnVtYmVyKGNvbnRlbnQpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgZ2V0Qm9vbGVhbigpIHtcbiAgICBsZXQgYm9vbGVhbiA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBCT09MRUFOX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSBUUlVFKSB7XG4gICAgICAgIGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudCA9PT0gRkFMU0UpIHtcbiAgICAgICAgYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gYm9vbGVhbjtcbiAgfVxuXG4gIGdldFN0cmluZ0xpdGVyYWwoKSB7XG4gICAgbGV0IHN0cmluZ0xpdGVyYWwgPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1RSSU5HX0xJVEVSQUxfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCA9IGNvbnRlbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcmltaXRpdmVOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBOQU1FX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZlcmVuY2VOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5BTUVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJlZmVyZW5jZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFRZUEVfVE9LRU5fVFlQRSwgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyYW10ZXJOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZSA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG5hbWUgPSBjb250ZW50OyAvL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFRZUEVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgdHlwZSA9IGNvbnRlbnQ7IC8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7XG4gICAgaWYgKHByZWNlZGVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJlY2VkZW5jZSA9IG9wYWNpdHk7IC8vL1xuXG4gICAgICBvcGFjaXR5ID0gY2hpbGROb2RlczsgLy8vXG5cbiAgICAgIGNoaWxkTm9kZXMgPSBydWxlTmFtZTsgIC8vL1xuXG4gICAgICBydWxlTmFtZSA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJhbXRlck5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1ldGVyTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJOb2RlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCB7IFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2RlUXVlcnlOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0U3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWwgPSB0aGlzLmdldFN0cmluZ0xpdGVyYWwoKSxcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmdGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsKTtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBnZXRTdHJpbmdMaXRlcmFsKCkge1xuICAgIGxldCBzdHJpbmdMaXRlcmFsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1RSSU5HX0xJVEVSQUxfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCA9IGNvbnRlbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9kZVF1ZXJ5Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBTT01FX1JVTEVfTkFNRSxcbiAgICAgICAgIEVWRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFRFVDRV9SVUxFX05BTUUsXG4gICAgICAgICBURVJOQVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgTk9ERVNfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgUkVUVVJOX0JMT0NLX1JVTEVfTkFNRSxcbiAgICAgICAgIFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwcmVzc2lvbk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm1Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cblxuICBnZXRTb21lTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFNPTUVfUlVMRV9OQU1FLFxuICAgICAgICAgIHNvbWVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gc29tZU5vZGU7XG4gIH1cblxuICBnZXRFdmVyeU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBFVkVSWV9SVUxFX05BTUUsXG4gICAgICAgICAgZXZlcnlOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gZXZlcnlOb2RlO1xuICB9XG5cbiAgZ2V0UmVkdWNlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFRFVDRV9SVUxFX05BTUUsXG4gICAgICAgICAgcmVkdWNlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHJlZHVjZU5vZGU7XG4gIH1cblxuICBnZXRUZXJuYXJ5Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk5BUllfUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm5hcnlOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybmFyeU5vZGU7XG4gIH1cblxuICBnZXROb2RlUXVlcnlOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTk9ERV9RVUVSWV9SVUxFX05BTUUsXG4gICAgICAgICAgbm9kZVF1ZXJ5Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5vZGVRdWVyeU5vZGU7XG4gIH1cblxuICBnZXROb2Rlc1F1ZXJ5Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5PREVTX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgICBub2RlU1F1ZXJ5Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5vZGVTUXVlcnlOb2RlO1xuICB9XG5cbiAgZ2V0UmV0dXJuQmxvY2tOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUkVUVVJOX0JMT0NLX1JVTEVfTkFNRSxcbiAgICAgICAgICByZXR1cm5CbG9ja05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiByZXR1cm5CbG9ja05vZGU7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVDYWxsTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSxcbiAgICAgICAgICBwcm9jZWR1cmVDYWxsTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZUNhbGxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShFeHByZXNzaW9uTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgUEFSQU1FVEVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyYW10ZXJzTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFBhcmFtZXRlck5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgICBwYXJhbWV0ZXJOb2RlcyA9IHRoaXMuZ2V0Tm9kZXNCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJOb2RlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7XG4gICAgaWYgKHByZWNlZGVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJlY2VkZW5jZSA9IG9wYWNpdHk7IC8vL1xuXG4gICAgICBvcGFjaXR5ID0gY2hpbGROb2RlczsgLy8vXG5cbiAgICAgIGNoaWxkTm9kZXMgPSBydWxlTmFtZTsgIC8vL1xuXG4gICAgICBydWxlTmFtZSA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJhbXRlcnNOb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtZXRlcnNOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHBhcmFtZXRlcnNOb2RlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCB7IFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2Rlc1F1ZXJ5Tm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFN0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCksXG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgZ2V0U3RyaW5nTGl0ZXJhbCgpIHtcbiAgICBsZXQgc3RyaW5nTGl0ZXJhbCA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBzdHJpbmdMaXRlcmFsID0gY29udGVudDsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWw7XG4gIH1cblxuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShOb2Rlc1F1ZXJ5Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgU1RFUF9SVUxFX05BTUUsIE5PTlNFTlNFX1JVTEVfTkFNRSwgUkVUVVJOX1NUQVRFTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldHVybkJsb2NrTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGlzTm9uc2Vuc2ljYWwoKSB7XG4gICAgY29uc3Qgbm9uc2Vuc2VOb2RlcyA9IHRoaXMuZ2V0Tm9uc2Vuc2VOb2RlcygpLFxuICAgICAgICAgIG5vbnNlbnNlTm9kZXNMZW5ndGggPSBub25zZW5zZU5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBub25zZW5zaWNhbCA9IChub25zZW5zZU5vZGVzTGVuZ3RoID4gMCk7XG5cbiAgICByZXR1cm4gbm9uc2Vuc2ljYWw7XG4gIH1cblxuICBnZXRTdGVwTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBTVEVQX1JVTEVfTkFNRSxcbiAgICAgICAgICBzdGVwTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gc3RlcE5vZGVzO1xuICB9XG5cbiAgZ2V0Tm9uc2Vuc2VOb2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5PTlNFTlNFX1JVTEVfTkFNRSxcbiAgICAgICAgICBub25zZW5zZU5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgICByZXR1cm4gbm9uc2Vuc2VOb2RlcztcbiAgfVxuXG4gIGdldFJldHVyblN0YXRlbWVudE5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSRVRVUk5fU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgICByZXR1cm5TdGF0ZW1lbnQgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiByZXR1cm5TdGF0ZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJldHVybkJsb2NrTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgVGVybU5vZGUgZnJvbSBcIi4uLy4uL25vZGUvdGVybVwiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IFNQRUNJQUxfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi8uLi90b2tlblR5cGVzXCI7XG5pbXBvcnQgeyBDT05KVU5DVElPTl9PUEVSQVRPUiwgRElTSlVOQ1RJT05fT1BFUkFUT1IgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIGxhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dpY2FsVGVybU5vZGUgZXh0ZW5kcyBUZXJtTm9kZSB7XG4gIGdldE9wZXJhdG9yKCkge1xuICAgIGxldCBvcGVyYXRvciA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBTUEVDSUFMX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG9wZXJhdG9yID0gY29udGVudDsgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gb3BlcmF0b3I7XG4gIH1cblxuICBpc0NvbmplY3Rpb24oKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLmdldE9wZXJhdG9yKCksXG4gICAgICAgICAgY29uamVjdGlvbiA9IChvcGVyYXRvciA9PT0gQ09OSlVOQ1RJT05fT1BFUkFUT1IpO1xuXG4gICAgcmV0dXJuIGNvbmplY3Rpb247XG4gIH1cblxuICBpc0Rpc2p1bmN0aW9uKCkge1xuICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5nZXRPcGVyYXRvcigpLFxuICAgICAgICAgIGRpc2p1bmN0aW9uID0gKG9wZXJhdG9yID09PSBESVNKVU5DVElPTl9PUEVSQVRPUik7XG5cbiAgICByZXR1cm4gZGlzanVuY3Rpb247XG4gIH1cblxuICBnZXRUZXJtTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGVzO1xuICB9XG5cbiAgZ2V0TGVmdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IGZpcnN0RXhwcmVzaW9uTm9kZSA9IHRoaXMuZ2V0Rmlyc3RUZXJtTm9kZSgpLFxuICAgICAgICAgIGxlZnRUZXJtTm9kZSA9IGZpcnN0RXhwcmVzaW9uTm9kZTsgIC8vL1xuXG4gICAgcmV0dXJuIGxlZnRUZXJtTm9kZTtcbiAgfVxuXG4gIGdldFJpZ2h0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgbGFzdFRlcm1Ob2RlID0gdGhpcy5nZXRMYXN0VGVybU5vZGUoKSxcbiAgICAgICAgICByaWdodFRlcm1Ob2RlID0gbGFzdFRlcm1Ob2RlOyAvLy9cblxuICAgIHJldHVybiByaWdodFRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0TGFzdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgbGFzdFRlcm1Ob2RlID0gbGFzdCh0ZXJtTm9kZXMpO1xuXG4gICAgcmV0dXJuIGxhc3RUZXJtTm9kZTtcbiAgfVxuXG4gIGdldEZpcnN0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgdGVybU5vZGVzID0gdGhpcy5nZXRUZXJtTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdFRlcm1Ob2RlID0gZmlyc3QodGVybU5vZGVzKTtcblxuICAgIHJldHVybiBmaXJzdFRlcm1Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gVGVybU5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKExvZ2ljYWxUZXJtTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXJtTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtXCI7XG5cbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZWdhdGVkVGVybU5vZGUgZXh0ZW5kcyBUZXJtTm9kZSB7XG4gIGdldFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB0ZXJtTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFRlcm1Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShOZWdhdGVkVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFRFUk1TX1JVTEVfTkFNRSwgUkVGRVJFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvY2VkdXJlQ2FsbE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRUZXJtc05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNU19SVUxFX05BTUUsXG4gICAgICAgICAgdGVybXNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybXNOb2RlO1xuICB9XG5cbiAgZ2V0UmVmZXJlbmNlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFRkVSRU5DRV9SVUxFX05BTUUsXG4gICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHJlZmVyZW5jZU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFByb2NlZHVyZUNhbGxOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1Ob2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1cIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyYWNrZXRlZFRlcm1Ob2RlIGV4dGVuZHMgVGVybU5vZGUge1xuICBnZXRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm1Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBUZXJtTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQnJhY2tldGVkVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFRlcm1Ob2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1cIjtcblxuaW1wb3J0IHsgTk9UX0VRVUFMX1RPIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBTUEVDSUFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuXG5jb25zdCB7IGZpcnN0LCBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wYXJpc29uVGVybU5vZGUgZXh0ZW5kcyBUZXJtTm9kZSB7XG4gIGlzTmVnYXRlZCgpIHtcbiAgICBsZXQgbmVnYXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1BFQ0lBTF9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBpZiAoY29udGVudCA9PT0gTk9UX0VRVUFMX1RPKSB7XG4gICAgICAgIG5lZ2F0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5lZ2F0ZWQ7XG4gIH1cblxuICBnZXRUZXJtTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGVzO1xuICB9XG5cbiAgZ2V0TGVmdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IGZpcnN0VGVybU5vZGUgPSB0aGlzLmdldEZpcnN0VGVybU5vZGUoKSxcbiAgICAgICAgICBsZWZ0VGVybU5vZGUgPSBmaXJzdFRlcm1Ob2RlOyAvLy9cblxuICAgIHJldHVybiBsZWZ0VGVybU5vZGU7XG4gIH1cblxuICBnZXRSaWdodFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHNlY29uZFRlcm1Ob2RlID0gdGhpcy5nZXRTZWNvbmRUZXJtTm9kZSgpLFxuICAgICAgICAgIHJpZ2h0VGVybU5vZGUgPSBzZWNvbmRUZXJtTm9kZTsgIC8vL1xuXG4gICAgcmV0dXJuIHJpZ2h0VGVybU5vZGU7XG4gIH1cblxuICBnZXRGaXJzdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgZmlyc3RUZXJtTm9kZSA9IGZpcnN0KHRlcm1Ob2Rlcyk7XG5cbiAgICByZXR1cm4gZmlyc3RUZXJtTm9kZTtcbiAgfVxuXG4gIGdldFNlY29uZFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgc2Vjb25kVGVybU5vZGUgPSBzZWNvbmQodGVybU5vZGVzKTtcblxuICAgIHJldHVybiBzZWNvbmRUZXJtTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFRlcm1Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDb21wYXJpc29uVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFyYW10ZXJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3BhcmFtZXRlclwiO1xuXG5pbXBvcnQgeyBOQU1FX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lZFBhcmFtdGVyTm9kZSBleHRlbmRzIFBhcmFtdGVyTm9kZSB7XG4gIGdldEFsaWFzKCkge1xuICAgIGxldCBhbGlhcyA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgICBhbGlhcyA9IGNvbnRlbnQ7IC8vXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBhbGlhcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFBhcmFtdGVyTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZWRQYXJhbXRlck5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFyYW10ZXJzTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9wYXJhbWV0ZXJzXCI7XG5cbmltcG9ydCB7IE5BTUVEX1BBUkFNRVRFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hbWVkUGFyYW10ZXJzTm9kZSBleHRlbmRzIFBhcmFtdGVyc05vZGUge1xuICBnZXROYW1lZFBhcmFtZXRlck5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgICBuYW1lZFBhcmFtdGVyTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gbmFtZWRQYXJhbXRlck5vZGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gUGFyYW10ZXJzTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZWRQYXJhbXRlcnNOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZW1lbnROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RhdGVtZW50Tm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9zdGF0ZW1lbnRcIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldHVyblN0YXRlbWVudE5vZGUgZXh0ZW5kcyBTdGF0ZW1lbnROb2RlIHtcbiAgZ2V0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gU3RhdGVtZW50Tm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmV0dXJuU3RhdGVtZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXNzaWdubWVudHJOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXNzaWdubWVudHJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL2Fzc2lnbm1lbnRcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBQQVJBTUVURVJTX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJyYXlBc3NpZ25tZW50Tm9kZSBleHRlbmRzIEFzc2lnbm1lbnRyTm9kZSB7XG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZU5vZGU7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgIHBhcmFtZXRlcnNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcGFyYW1ldGVyc05vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBBc3NpZ25tZW50ck5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEFycmF5QXNzaWdubWVudE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXNzaWdubWVudHJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL2Fzc2lnbm1lbnRcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBOQU1FRF9QQVJBTUVURVJTX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0QXNzaWdubWVudE5vZGUgZXh0ZW5kcyBBc3NpZ25tZW50ck5vZGUge1xuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgZ2V0TmFtZWRQYXJhbWV0ZXJzTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5BTUVEX1BBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyc05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBuYW1lZFBhcmFtZXRlcnNOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gQXNzaWdubWVudHJOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPYmplY3RBc3NpZ25tZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvY2VkdXJlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb2NlZHVyZU5vZGUgZnJvbSBcIi4uLy4uL25vZGUvcHJvY2VkdXJlXCI7XG5cbmltcG9ydCB7IFRZUEVfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi8uLi90b2tlblR5cGVzXCI7XG5pbXBvcnQgeyBQQVJBTUVURVJTX1JVTEVfTkFNRSwgUkVUVVJOX0JMT0NLX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5vbnltb3VzUHJvY2VkdXJlTm9kZSBleHRlbmRzIFByb2NlZHVyZU5vZGUge1xuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gVFlQRV9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICB0eXBlID0gY29udGVudDsgIC8vL1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnNOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICAgcGFyYW1ldGVyc05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJzTm9kZTtcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICAgcmV0dXJuQmxvY2tOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcmV0dXJuQmxvY2tOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gUHJvY2VkdXJlTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBBc3NpZ25tZW50ck5vZGUgZnJvbSBcIi4uLy4uL25vZGUvYXNzaWdubWVudFwiO1xuXG5pbXBvcnQgeyBWQVJJQUJMRV9SVUxFX05BTUUsIEVYUFJFU1NJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnROb2RlIGV4dGVuZHMgQXNzaWdubWVudHJOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb25Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZXhwcmVzc2lvbk5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBleHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIEFzc2lnbm1lbnRyTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBBc3NpZ25tZW50c05vZGUgZnJvbSBcIi4uLy4uL25vZGUvYXNzaWdubWVudFwiO1xuXG5pbXBvcnQgeyBUWVBFX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuaW1wb3J0IHsgVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhcmlhYmxlQXNzaWdubWVudHNOb2RlIGV4dGVuZHMgQXNzaWdubWVudHNOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFRZUEVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgdHlwZSA9IGNvbnRlbnQ7ICAvLy9cbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRWYXJpYWJsZUFzc2lnbm1lbnROb2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlQXNzaW5nbm1lbnROb2RzcyA9IHRoaXMuZ2V0Tm9kZXNCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZUFzc2luZ25tZW50Tm9kc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBBc3NpZ25tZW50c05vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNsYXJhdGlvbk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWNsYXJhdGlvbk5vZGUgZnJvbSBcIi4uLy4uL25vZGUvZGVjbGFyYXRpb25cIjtcblxuaW1wb3J0IHsgVFlQRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3Rva2VuVHlwZXNcIjtcbmltcG9ydCB7IExBQkVMX1JVTEVfTkFNRSwgUEFSQU1FVEVSU19SVUxFX05BTUUsIFJFVFVSTl9CTE9DS19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSBleHRlbmRzIERlY2xhcmF0aW9uTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBUWVBFX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHR5cGUgPSBjb250ZW50OyAgLy8vXG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0TGFiZWxOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTEFCRUxfUlVMRV9OQU1FLFxuICAgICAgICAgIGxhYmVsTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGxhYmVsTm9kZTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnNOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICAgcGFyYW1ldGVyc05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJzTm9kZTtcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICAgcmV0dXJuQmxvY2tOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcmV0dXJuQmxvY2tOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gRGVjbGFyYXRpb25Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RlcE5vZGUgZnJvbSBcIi4vbm9kZS9zdGVwXCI7XG5pbXBvcnQgU29tZU5vZGUgZnJvbSBcIi4vbm9kZS9zb21lXCI7XG5pbXBvcnQgVGVybU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJtXCI7XG5pbXBvcnQgVGVybXNOb2RlIGZyb20gXCIuL25vZGUvdGVybXNcIjtcbmltcG9ydCBFdmVyeU5vZGUgZnJvbSBcIi4vbm9kZS9ldmVyeVwiO1xuaW1wb3J0IExhYmVsTm9kZSBmcm9tIFwiLi9ub2RlL2xhYmVsXCI7XG5pbXBvcnQgRXJyb3JOb2RlIGZyb20gXCIuL25vZGUvZXJyb3JcIjtcbmltcG9ydCBSZWR1Y2VOb2RlIGZyb20gXCIuL25vZGUvcmVkdWNlXCI7XG5pbXBvcnQgVGVybmFyeU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJuYXJ5XCI7XG5pbXBvcnQgRG9jdW1lbnROb2RlIGZyb20gXCIuL25vZGUvZG9jdW1lbnRcIjtcbmltcG9ydCBWYXJpYWJsZU5vZGUgZnJvbSBcIi4vbm9kZS92YXJpYWJsZVwiO1xuaW1wb3J0IE5vbnNlbnNlTm9kZSBmcm9tIFwiLi9ub2RlL25vbnNlbnNlXCI7XG5pbXBvcnQgUHJpbWl0aXZlTm9kZSBmcm9tIFwiLi9ub2RlL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IFJlZmVyZW5jZU5vZGUgZnJvbSBcIi4vbm9kZS9yZWZlcmVuY2VcIjtcbmltcG9ydCBQYXJhbWV0ZXJOb2RlIGZyb20gXCIuL25vZGUvcGFyYW1ldGVyXCI7XG5pbXBvcnQgTm9kZVF1ZXJ5Tm9kZSBmcm9tIFwiLi9ub2RlL25vZGVRdWVyeVwiO1xuaW1wb3J0IEV4cHJlc3Npb25Ob2RlIGZyb20gXCIuL25vZGUvZXhwcmVzc2lvblwiO1xuaW1wb3J0IFBhcmFtZXRlcnNOb2RlIGZyb20gXCIuL25vZGUvcGFyYW1ldGVyc1wiO1xuaW1wb3J0IE5vZGVzUXVlcnlOb2RlIGZyb20gXCIuL25vZGUvbm9kZXNRdWVyeVwiO1xuaW1wb3J0IFJldHVybkJsb2NrTm9kZSBmcm9tIFwiLi9ub2RlL3JldHVybkJsb2NrXCI7XG5pbXBvcnQgTG9naWNhbFRlcm1Ob2RlIGZyb20gXCIuL25vZGUvdGVybS9sb2dpY2FsXCI7XG5pbXBvcnQgTmVnYXRlZFRlcm1Ob2RlIGZyb20gXCIuL25vZGUvdGVybS9uZWdhdGVkXCI7XG5pbXBvcnQgUHJvY2VkdXJlQ2FsbE5vZGUgZnJvbSBcIi4vbm9kZS9wcm9jZWR1cmVDYWxsXCI7XG5pbXBvcnQgQnJhY2tldGVkVGVybU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJtL2JyYWNrZXRlZFwiO1xuaW1wb3J0IENvbXBhcmlzb25UZXJtTm9kZSBmcm9tIFwiLi9ub2RlL3Rlcm0vY29tcGFyaXNvblwiO1xuaW1wb3J0IE5hbWVkUGFyYW1ldGVyTm9kZSBmcm9tIFwiLi9ub2RlL3BhcmFtZXRlci9uYW1lZFwiO1xuaW1wb3J0IE5hbWVkUGFyYW1ldGVyc05vZGUgZnJvbSBcIi4vbm9kZS9wYXJhbWV0ZXJzL25hbWVkXCI7XG5pbXBvcnQgUmV0dXJuU3RhdGVtZW50Tm9kZSBmcm9tIFwiLi9ub2RlL3N0YXRlbWVudC9yZXR1cm5cIjtcbmltcG9ydCBBcnJheUFzc2lnbm1lbnROb2RlIGZyb20gXCIuL25vZGUvYXNzaWdubWVudC9hcnJheVwiO1xuaW1wb3J0IE9iamVjdEFzc2lnbm1lbnROb2RlIGZyb20gXCIuL25vZGUvYXNzaWdubWVudC9vYmplY3RcIjtcbmltcG9ydCBBbm9ueW1vdXNQcm9jZWR1cmVOb2RlIGZyb20gXCIuL25vZGUvcHJvY2VkdXJlL2Fub3ltb3VzXCI7XG5pbXBvcnQgVmFyaWFibGVBc3NpZ25tZW50Tm9kZSBmcm9tIFwiLi9ub2RlL2Fzc2lnbm1lbnQvdmFyaWFibGVcIjtcbmltcG9ydCBWYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSBmcm9tIFwiLi9ub2RlL2Fzc2lnbm1lbnRzL3ZhcmlhYmxlXCI7XG5pbXBvcnQgUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlIGZyb20gXCIuL25vZGUvZGVjbGFyYXRpb24vcHJvY2VkdXJlXCI7XG5cbmltcG9ydCB7IFNURVBfUlVMRV9OQU1FLFxuICAgICAgICAgU09NRV9SVUxFX05BTUUsXG4gICAgICAgICBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIFRFUk1TX1JVTEVfTkFNRSxcbiAgICAgICAgIEVWRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIExBQkVMX1JVTEVfTkFNRSxcbiAgICAgICAgIEVSUk9SX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFRFVDRV9SVUxFX05BTUUsXG4gICAgICAgICBURVJOQVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIERPQ1VNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PTlNFTlNFX1JVTEVfTkFNRSxcbiAgICAgICAgIFBSSU1JVElWRV9SVUxFX05BTUUsXG4gICAgICAgICBSRUZFUkVOQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICBQQVJBTUVURVJTX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVTX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICBMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgTkVHQVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSxcbiAgICAgICAgIENPTVBBUklTT05fVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBOQU1FRF9QQVJBTUVURVJfUlVMRV9OQU1FLFxuICAgICAgICAgTkFNRURfUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICBSRVRVUk5fU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIEFSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgT0JKRUNUX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgIFZBUklBQkxFX0FTU0lHTk1FTlRTX1JVTEVfTkFNRSxcbiAgICAgICAgIFBST0NFRFVSRV9ERUNMQVJBVElPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgTm9uVGVybWluYWxOb2RlTWFwID0ge1xuICBbU1RFUF9SVUxFX05BTUVdOiBTdGVwTm9kZSxcbiAgW1NPTUVfUlVMRV9OQU1FXTogU29tZU5vZGUsXG4gIFtURVJNX1JVTEVfTkFNRV06IFRlcm1Ob2RlLFxuICBbVEVSTVNfUlVMRV9OQU1FXTogVGVybXNOb2RlLFxuICBbRVZFUllfUlVMRV9OQU1FXTogRXZlcnlOb2RlLFxuICBbTEFCRUxfUlVMRV9OQU1FXTogTGFiZWxOb2RlLFxuICBbRVJST1JfUlVMRV9OQU1FXTogRXJyb3JOb2RlLFxuICBbUkVEVUNFX1JVTEVfTkFNRV06IFJlZHVjZU5vZGUsXG4gIFtURVJOQVJZX1JVTEVfTkFNRV06IFRlcm5hcnlOb2RlLFxuICBbVkFSSUFCTEVfUlVMRV9OQU1FXTogVmFyaWFibGVOb2RlLFxuICBbTk9OU0VOU0VfUlVMRV9OQU1FXTogTm9uc2Vuc2VOb2RlLFxuICBbRE9DVU1FTlRfUlVMRV9OQU1FXTogRG9jdW1lbnROb2RlLFxuICBbUFJJTUlUSVZFX1JVTEVfTkFNRV06IFByaW1pdGl2ZU5vZGUsXG4gIFtSRUZFUkVOQ0VfUlVMRV9OQU1FXTogUmVmZXJlbmNlTm9kZSxcbiAgW1BBUkFNRVRFUl9SVUxFX05BTUVdOiBQYXJhbWV0ZXJOb2RlLFxuICBbTk9ERV9RVUVSWV9SVUxFX05BTUVdOiBOb2RlUXVlcnlOb2RlLFxuICBbRVhQUkVTU0lPTl9SVUxFX05BTUVdOiBFeHByZXNzaW9uTm9kZSxcbiAgW1BBUkFNRVRFUlNfUlVMRV9OQU1FXTogUGFyYW1ldGVyc05vZGUsXG4gIFtOT0RFU19RVUVSWV9SVUxFX05BTUVdOiBOb2Rlc1F1ZXJ5Tm9kZSxcbiAgW1JFVFVSTl9CTE9DS19SVUxFX05BTUVdOiBSZXR1cm5CbG9ja05vZGUsXG4gIFtMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FXTogTG9naWNhbFRlcm1Ob2RlLFxuICBbTkVHQVRFRF9URVJNX1JVTEVfTkFNRV06IE5lZ2F0ZWRUZXJtTm9kZSxcbiAgW1BST0NFRFVSRV9DQUxMX1JVTEVfTkFNRV06IFByb2NlZHVyZUNhbGxOb2RlLFxuICBbQlJBQ0tFVEVEX1RFUk1fUlVMRV9OQU1FXTogQnJhY2tldGVkVGVybU5vZGUsXG4gIFtDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FXTogQ29tcGFyaXNvblRlcm1Ob2RlLFxuICBbTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRV06IE5hbWVkUGFyYW1ldGVyTm9kZSxcbiAgW05BTUVEX1BBUkFNRVRFUlNfUlVMRV9OQU1FXTogTmFtZWRQYXJhbWV0ZXJzTm9kZSxcbiAgW1JFVFVSTl9TVEFURU1FTlRfUlVMRV9OQU1FXTogUmV0dXJuU3RhdGVtZW50Tm9kZSxcbiAgW0FSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FXTogQXJyYXlBc3NpZ25tZW50Tm9kZSxcbiAgW09CSkVDVF9BU1NJR05NRU5UX1JVTEVfTkFNRV06IE9iamVjdEFzc2lnbm1lbnROb2RlLFxuICBbQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUVdOiBBbm9ueW1vdXNQcm9jZWR1cmVOb2RlLFxuICBbVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUVdOiBWYXJpYWJsZUFzc2lnbm1lbnROb2RlLFxuICBbVkFSSUFCTEVfQVNTSUdOTUVOVFNfUlVMRV9OQU1FXTogVmFyaWFibGVBc3NpZ25tZW50c05vZGUsXG4gIFtQUk9DRURVUkVfREVDTEFSQVRJT05fUlVMRV9OQU1FXTogUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOb25UZXJtaW5hbE5vZGVNYXA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgRnVydGxlUGFyc2VyIGFzIEZ1cnRsZVBhcnNlckJhc2UgfSBmcm9tIFwib2NjYW0tZ3JhbW1hcnNcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZU1hcCBmcm9tIFwiLi4vbm9uVGVybWluYWxOb2RlTWFwXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZVBhcnNlciBleHRlbmRzIEZ1cnRsZVBhcnNlckJhc2Uge1xuICBzdGF0aWMgTm9uVGVybWluYWxOb2RlTWFwID0gTm9uVGVybWluYWxOb2RlTWFwO1xuXG4gIHN0YXRpYyBkZWZhdWx0Tm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1xdWVyeVwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybmFyeVN0cmluZ0Zyb21UZXJtLFxuICAgICAgICAgdmFyaWFibGVTdHJpbmdGcm9tTmFtZSxcbiAgICAgICAgIHRlcm1TdHJpbmdGcm9tUHJvcGVydGllcyxcbiAgICAgICAgIGV4cHJlc3Npb25TdHJpbmdGcm9tUHJvcGVydGllcyxcbiAgICAgICAgIHByb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nRnJvbVByb2NlZHVyZSxcbiAgICAgICAgIHJldHVybkJsb2NrU3RyaW5nRnJvbVJldHVyblN0YXRlbWVudE5vZGUsXG4gICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlLFxuICAgICAgICAgc29tZVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSxcbiAgICAgICAgIGV2ZXJ5U3RyaW5nRnJvbVZhcmlhYmxlQW5kQW5vbnltb3VzUHJvY2VkdXJlLFxuICAgICAgICAgcHJvY2VkdXJlU3RyaW5nRnJvbVR5cGVMYWJlbFBhcmFtZXRlcnNBbmRSZXR1cm5CbG9jayxcbiAgICAgICAgIGFub255bW91c1Byb2NlZHVyZVN0cmluZ0Zyb21UeXBlUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrLFxuICAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnRzQXJyYXksXG4gICAgICAgICByZWR1Y2VTdHJpbmdGcm9tVmFyaWFibGVJbml0aWFsRXhwcmVzc2lvbkFuZEFub255bW91c1Byb2NlZHVyZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwRnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgU3RlcCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBzdGVwTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgYXJyYXlBc3NpZ25tZW50ID0gYXJyYXlBc3NpZ25tZW50RnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgb2JqZWN0QXNzaWdtZW50ID0gb2JqZWN0QXNzaWdubWVudEZyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uID0gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3Qgc3RlcCA9IG5ldyBTdGVwKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXlBc3NpZ25tZW50LCBvYmplY3RBc3NpZ21lbnQsIHZhcmlhYmxlc0RlY2xhcmF0aW9uKTtcblxuICByZXR1cm4gc3RlcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvbWVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBTb21lIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHNvbWVOb2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBzb21lU3RyaW5nID0gc29tZVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSh2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSxcbiAgICAgICAgc3RyaW5nID0gc29tZVN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHNvbWUgPSBuZXcgU29tZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpO1xuXG4gIHJldHVybiBzb21lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdGVybU5vZGUsICAvLy9cbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5lZ2F0ZWRUZXJtID0gbmVnYXRlZFRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBsb2dpY2FsVGVybSA9IGxvZ2ljYWxUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgYnJhY2tldGVkVGVybSA9IGJyYWNrZXRlZFRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBjb21wYXJpc29uVGVybSA9IGNvbXBhcmlzb25UZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICB2YXJpYWJsZSxcbiAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgbmVnYXRlZFRlcm0sXG4gICAgICAgICAgbG9naWNhbFRlcm0sXG4gICAgICAgICAgYnJhY2tldGVkVGVybSxcbiAgICAgICAgICBjb21wYXJpc29uVGVybVxuICAgICAgICBdLFxuICAgICAgICB0ZXJtU3RyaW5nID0gdGVybVN0cmluZ0Zyb21Qcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSB0ZXJtU3RyaW5nOyAgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSwgbmVnYXRlZFRlcm0sIGxvZ2ljYWxUZXJtLCBicmFja2V0ZWRUZXJtLCBjb21wYXJpc29uVGVybSk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0Zyb21UZXJtc05vZGUodGVybXNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgVGVybXMgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdGVybXNOb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHRlcm1Ob2RlcyA9IHRlcm1zTm9kZS5nZXRUZXJtTm9kZXMoKSxcbiAgICAgICAgdGVybXNBcnJheSA9IHRlcm1zQXJyYXlGcm9tVGVybU5vZGVzKHRlcm1Ob2RlcywgY29udGV4dCksXG4gICAgICAgIGFycmF5ID0gdGVybXNBcnJheTsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybXMgPSBuZXcgVGVybXMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgcmV0dXJuIHRlcm1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JGcm9tRXJyb3JOb2RlKGVycm9yTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEVycm9yIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGVycm9yTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNvbnRleHQsIHN0cmluZywgbm9kZSk7XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlcnlGcm9tRXZlcnlOb2RlKGV2ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEV2ZXJ5IH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGV2ZXJ5Tm9kZSwgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tRXZlcnlOb2RlKGV2ZXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21FdmVyeU5vZGUoZXZlcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgZXZlcnlTdHJpbmcgPSBldmVyeVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSh2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSxcbiAgICAgICAgc3RyaW5nID0gZXZlcnlTdHJpbmc7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGV2ZXJ5ID0gbmV3IEV2ZXJ5KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGFub255bW91c1Byb2NlZHVyZSk7XG5cbiAgcmV0dXJuIGV2ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxGcm9tTGFiZWxOb2RlKGxhYmVsTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IExhYmVsIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGxhYmVsTm9kZSxcbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIG5hbWUgPSBuYW1lRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGxhYmVsID0gbmV3IExhYmVsKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSk7XG5cbiAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFJlZHVjZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSByZWR1Y2VOb2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgaW5pdGlhbEV4cHJlc3Npb24gPSBpbml0aWFsRXhwcmVzc2lvbkZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmVkdWNlU3RyaW5nID0gcmVkdWNlU3RyaW5nRnJvbVZhcmlhYmxlSW5pdGlhbEV4cHJlc3Npb25BbmRBbm9ueW1vdXNQcm9jZWR1cmUodmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpLFxuICAgICAgICBzdHJpbmcgPSByZWR1Y2VTdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZWR1Y2UgPSBuZXcgUmVkdWNlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpO1xuXG4gIHJldHVybiByZWR1Y2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJuYXJ5RnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgVGVybmFyeSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSB0ZXJuYXJ5Tm9kZSwgLy8vXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgaWZFeHByZXNzaW9uID0gaWZFeHByZXNzaW9uRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgZWxzZUV4cHJlc3Npb24gPSBlbHNlRXhwcmVzc2lvbkZyb21UZXJuYXJ5Tm9kZSh0ZXJuYXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHRlcm5hcnlTdHJpbmcgPSB0ZXJuYXJ5U3RyaW5nRnJvbVRlcm0odGVybSksXG4gICAgICAgIHN0cmluZyA9IHRlcm5hcnlTdHJpbmc7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm5hcnkgPSBuZXcgVGVybmFyeShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0sIGlmRXhwcmVzc2lvbiwgZWxzZUV4cHJlc3Npb24pO1xuXG4gIHJldHVybiB0ZXJuYXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHZhcmlhYmxlTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5hbWUgPSBuYW1lRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGV4cHJlc3Npb24pO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZUZyb21SZWZlcmVuY2VOb2RlKHJlZmVyZW5jZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBSZWZlcmVuY2UgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcmVmZXJlbmNlTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICBuYW1lID0gbmFtZUZyb21SZWZlcmVuY2VOb2RlKHJlZmVyZW5jZU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHJlZmVyZW5jZSA9IG5ldyBSZWZlcmVuY2UoY29udGV4dCwgc3RyaW5nLCBub2RlLCBuYW1lKTtcblxuICByZXR1cm4gcmVmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyRnJvbVBhcmFtZXRlck5vZGUocGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBsZXQgcGFyYW1ldGVyID0gbnVsbDtcblxuICBjb25zdCB0eXBlID0gdHlwZUZyb21QYXJhbmV0ZXJOb2RlKHBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgY29uc3QgeyBQYXJhbWV0ZXIgfSA9IGVsZW1lbnRzLFxuICAgICAgICAgIG5vZGUgPSBwYXJhbWV0ZXJOb2RlLCAvLy9cbiAgICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgICBuYW1lID0gbmFtZUZyb21QYXJhbmV0ZXJOb2RlKHBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBwYXJhbWV0ZXIgPSBuZXcgUGFyYW1ldGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1ldGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVF1ZXJ5RnJvbU5vZGVRdWVyeU5vZGUobm9kZVF1ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IE5vZGVRdWVyeSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBub2RlUXVlcnlOb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tTm9kZVF1ZXJ5Tm9kZShub2RlUXVlcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcXVlcnkgPSBxdWVyeUZyb21Ob2RlUXVlcnlOb2RlKG5vZGVRdWVyeU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVRdWVyeSA9IG5ldyBOb2RlUXVlcnkoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcXVlcnkpO1xuXG4gIHJldHVybiBub2RlUXVlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJpbWl0aXZlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHByaW1pdGl2ZU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUZyb21QcmltaXRpdmVOb2RlKHByaW1pdGl2ZU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnlGcm9tTm9kZXNRdWVyeU5vZGUobm9kZXNRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOb2Rlc1F1ZXJ5IH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IG5vZGVzUXVlcnlOb2RlLCAgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbU5vZGVzUXVlcnlOb2RlKG5vZGVzUXVlcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcXVlcnkgPSBxdWVyeUZyb21Ob2Rlc1F1ZXJ5Tm9kZShub2Rlc1F1ZXJ5Tm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3Qgbm9kZXNRdWVyeSA9IG5ldyBOb2Rlc1F1ZXJ5KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KTtcblxuICByZXR1cm4gbm9kZXNRdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtZXRlcnNGcm9tUGFyYW1ldGVyc05vZGUocGFyYW1ldGVyc05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQYXJhbWV0ZXJzIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHBhcmFtZXRlcnNOb2RlLCAgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICBwYXJhbXRlcnNBcnJheSA9IHBhcmFtdGVyc0FycmF5RnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgYXJyYXkgPSBwYXJhbXRlcnNBcnJheTsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBQYXJhbWV0ZXJzKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpO1xuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEV4cHJlc3Npb24gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gZXhwcmVzc2lvbk5vZGUsICAvLy9cbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBzb21lID0gc29tZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIGV2ZXJ5ID0gZXZlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICByZWR1Y2UgPSByZWR1Y2VGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICB0ZXJuYXJ5ID0gdGVybmFyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vZGVRdWVyeSA9IG5vZGVRdWVyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuQmxvY2sgPSByZXR1cm5CbG9ja0Zyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIHByb2NlZHVyZUNhbGwgPSBwcm9jZWR1cmVDYWxsRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICB0ZXJtLFxuICAgICAgICAgIHNvbWUsXG4gICAgICAgICAgZXZlcnksXG4gICAgICAgICAgcmVkdWNlLFxuICAgICAgICAgIHRlcm5hcnksXG4gICAgICAgICAgbm9kZVF1ZXJ5LFxuICAgICAgICAgIG5vZGVzUXVlcnksXG4gICAgICAgICAgcmV0dXJuQmxvY2ssXG4gICAgICAgICAgcHJvY2VkdXJlQ2FsbFxuICAgICAgICBdLFxuICAgICAgICBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvblN0cmluZ0Zyb21Qcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSBleHByZXNzaW9uU3RyaW5nOyAgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdGVybSwgc29tZSwgZXZlcnksIHJlZHVjZSwgdGVybmFyeSwgbm9kZVF1ZXJ5LCBub2Rlc1F1ZXJ5LCByZXR1cm5CbG9jaywgcHJvY2VkdXJlQ2FsbCk7XG5cbiAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5CbG9ja0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUmV0dXJuQmxvY2sgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcmV0dXJuQmxvY2tOb2RlLCAvLy9cbiAgICAgICAgc3RlcHMgPSBzdGVwc0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgbm9uc2Vuc2ljYWwgPSBub25zZW5zaWNhbEZyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50RnJvbVJldHVybkJsb2NrTm9kZShyZXR1cm5CbG9ja05vZGUsIGNvbnRleHQpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IHJldHVybkJsb2NrU3RyaW5nRnJvbVJldHVyblN0YXRlbWVudE5vZGUocmV0dXJuU3RhdGVtZW50KSxcbiAgICAgICAgc3RyaW5nID0gcmV0dXJuQmxvY2tTdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZXR1cm5CbG9jayA9IG5ldyBSZXR1cm5CbG9jayhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHN0ZXBzLCBub25zZW5zaWNhbCwgcmV0dXJuU3RhdGVtZW50KTtcblxuICByZXR1cm4gcmV0dXJuQmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVDYWxsRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJvY2VkdXJlQ2FsbCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcm9jZWR1cmVDYWxsTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2VGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpLFxuICAgICAgICB0ZXJtcyA9IHRlcm1zRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcm9jZWR1cmVDYWxsID0gbmV3IFByb2NlZHVyZUNhbGwoY29udGV4dCwgc3RyaW5nLCBub2RlLCByZWZlcmVuY2UsIHRlcm1zKTtcblxuICByZXR1cm4gcHJvY2VkdXJlQ2FsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVkUGFyYW1ldGVyRnJvbU5hbWVkUGFyYW1ldGVyTm9kZShuYW1lZFBhcmFtZXRlck5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOYW1lZFBhcmFtZXRlciB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBuYW1lZFBhcmFtZXRlck5vZGUsICAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHR5cGUgPSB0eXBlRnJvbU5hbWVkUGFyYW1ldGVyTm9kZShuYW1lZFBhcmFtZXRlck5vZGUsIGNvbnRleHQpLFxuICAgICAgICBuYW1lID0gbmFtZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgYWxpYXMgPSBhbGlhc0Zyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBuYW1lZFBhcmFtZXRlciA9IG5ldyBOYW1lZFBhcmFtZXRlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGFsaWFzKTtcblxuICByZXR1cm4gbmFtZWRQYXJhbWV0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZFBhcmFtZXRlcnNGcm9tTmFtZWRQYXJhbWV0ZXJzTm9kZShuYW1lZFBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgTmFtZWRQYXJhbWV0ZXJzIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IG5hbWVkUGFyYW1ldGVyc05vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgbmFtZWRQYXJhbWV0ZXJOb2RlcyA9IG5hbWVkUGFyYW1ldGVyc05vZGUuZ2V0TmFtZWRQYXJhbWV0ZXJOb2RlcygpLFxuICAgICAgICBuYW1lZFBhcmFtZXRlcnNBcnJheSA9IG5hbWVkUGFyYW10ZXJzQXJyYXlGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlcyhuYW1lZFBhcmFtZXRlck5vZGVzLCBjb250ZXh0KSxcbiAgICAgICAgYXJyYXkgPSBuYW1lZFBhcmFtZXRlcnNBcnJheTsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgbmFtZWRQYXJhbWV0ZXJzID0gbmV3IE5hbWVkUGFyYW1ldGVycyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gbmFtZWRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlBc3NpZ25tZW50RnJvbUFycmF5QXNzaWdubWVudE5vZGUoYXJyYXlBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEFycmF5QXNzaWdubWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBhcnJheUFzc2lnbm1lbnROb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBhcnJheUFzc2lnbm1lbnQgPSBuZXcgQXJyYXlBc3NpZ25tZW50KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHBhcmFtZXRlcnMpO1xuXG4gIHJldHVybiBhcnJheUFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnRGcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUmV0dXJuU3RhdGVtZW50IH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHJldHVyblN0YXRlbWVudE5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZXR1cm5TdGF0ZW1lbnQgPSBuZXcgUmV0dXJuU3RhdGVtZW50KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdGVybSk7XG5cbiAgcmV0dXJuIHJldHVyblN0YXRlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVkUGFyYW1ldGVyc0Zyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuYW1lZFBhcmFtZXRlcnNOb2RlID0gb2JqZWN0QXNzaWdubWVudE5vZGUuZ2V0TmFtZWRQYXJhbWV0ZXJzTm9kZSgpLFxuICAgICAgICBuYW1lZFBhcmFtZXRlcnMgPSBuYW1lZFBhcmFtZXRlcnNGcm9tTmFtZWRQYXJhbWV0ZXJzTm9kZShuYW1lZFBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gbmFtZWRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0QXNzaWdubWVudEZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IE9iamVjdEFzc2lnbWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBvYmplY3RBc3NpZ25tZW50Tm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIG5hbWVkUGFyYW1ldGVycyA9IG5hbWVkUGFyYW1ldGVyc0Zyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3Qgb2JqZWN0QXNzaWdubWVudCA9IG5ldyBPYmplY3RBc3NpZ21lbnQoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgbmFtZWRQYXJhbWV0ZXJzKTtcblxuICByZXR1cm4gb2JqZWN0QXNzaWdubWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBBbm9ueW1vdXNQcm9jZWR1cmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgIC8vL1xuICAgICAgICB0eXBlID0gdHlwZUZyb21Qcm9jZWR1cmVBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVyc0Zyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICByZXR1cm5CbG9jayA9IHJldHVybkJsb2NrRnJvbUFub255bW91c1Byb2NlZHVyZU5vZGUoYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nRnJvbVR5cGVQYXJhbWV0ZXJzQW5kUmV0dXJuQmxvY2sodHlwZSwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spLFxuICAgICAgICBzdHJpbmcgPSBub255bW91c1Byb2NlZHVyZVN0cmluZzsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlID0gbmV3IEFub255bW91c1Byb2NlZHVyZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKTtcblxuICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlQXNzaWdubWVudHMgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdmFyaWFibGVBc3NpZ25tZW50c05vZGUsIC8vL1xuICAgICAgICB0eXBlID0gdHlwZUZyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudHNBcnJheSA9IHZhcmlhYmxlQXNzaWdubWVudHNBcnJheUZyb21UeXBlQW5kVmFyaWFibGVBc3NpZ25tZW50c05vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudHNBcnJheSh0eXBlLCB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkpLFxuICAgICAgICBhcnJheSA9IHZhcmlhYmxlQXNzaWdubWVudHNBcnJheSwgLy8vXG4gICAgICAgIHN0cmluZyA9IHZhcmlhYmxlQXNzaWdubWVudFN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHZhcmlhYmxlQXNzaWdubWVudHMgPSBuZXcgVmFyaWFibGVBc3NpZ25tZW50cyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2NlZHVyZURlY2xhcmF0aW9uRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcm9jZWR1cmVEZWNsYXJhdGlvbiB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsICAvLy9cbiAgICAgICAgcHJvY2VkdXJlID0gcHJvY2VkdXJlRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZyA9IHByb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nRnJvbVByb2NlZHVyZShwcm9jZWR1cmUpLFxuICAgICAgICBzdHJpbmcgPSBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByb2NlZHVyZURlY2xhcmF0aW9uID0gbmV3IFByb2NlZHVyZURlY2xhcmF0aW9uKGNvbnRleHQsIHN0cmluZywgbm9kZSwgcHJvY2VkdXJlKTtcblxuICByZXR1cm4gcHJvY2VkdXJlRGVjbGFyYXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbmFtZSA9IGxhYmVsTm9kZS5nZXROYW1lKCk7XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1Ob2RlID0gdGVybmFyeU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gc29tZU5vZGUuZ2V0VmFyaWFibGVOb2RlKCksIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCB2YXJpYWJsZSA9IG51bGw7XG5cbiAgY29uc3QgdmFyaWFibGVOb2RlID0gdGVybU5vZGUuZ2V0VmFyaWFibGVOb2RlKCk7XG5cbiAgaWYgKHZhcmlhYmxlTm9kZSAhPT0gbnVsbCkge1xuICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUpIHtcbiAgY29uc3QgbmFtZSA9IHZhcmlhYmxlTm9kZS5nZXROYW1lKCk7XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IG51bGw7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHByaW1pdGl2ZSA9IG51bGw7XG5cbiAgY29uc3QgcHJpbWl0aXZlTm9kZSA9IHRlcm1Ob2RlLmdldFByaW1pdGl2ZU5vZGUoKTtcblxuICBpZiAocHJpbWl0aXZlTm9kZSAhPT0gbnVsbCkge1xuICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21QcmltaXRpdmVOb2RlKHByaW1pdGl2ZU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbUV2ZXJ5Tm9kZShldmVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gZXZlcnlOb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tUGFyYW5ldGVyTm9kZShwYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXJOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVGcm9tUGFyYW5ldGVyTm9kZShwYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSBwYXJhbWV0ZXJOb2RlLmdldE5hbWUoKTtcblxuICByZXR1cm4gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVGcm9tUmVmZXJlbmNlTm9kZShyZWZlcmVuY2VOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSByZWZlcmVuY2VOb2RlLmdldE5hbWUoKTtcblxuICByZXR1cm4gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBwcmltaXRpdmVOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSByZWR1Y2VOb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IHRlcm1Ob2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0VGVybU5vZGUoKTtcblxuICBpZiAodGVybU5vZGUgIT09IG51bGwpIHtcbiAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvbWVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHNvbWUgPSBudWxsO1xuXG4gIGNvbnN0IHNvbWVOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0U29tZU5vZGUoKTtcblxuICBpZiAoc29tZU5vZGUgIT09IG51bGwpIHtcbiAgICBzb21lID0gc29tZUZyb21Tb21lTm9kZShzb21lTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gc29tZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5RnJvbU5vZGVRdWVyeU5vZGUobm9kZVF1ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBzdHJpbmcgPSBub2RlUXVlcnlOb2RlLmdldFN0cmluZygpLFxuICAgICAgICBleHByZXNzaW9uU3RyaW5nID0gc3RyaW5nLCAgLy8vXG4gICAgICAgIHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhbHVlID0gcHJpbWl0aXZlTm9kZS5nZXRWYWx1ZSgpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5RnJvbU5vZGVzUXVlcnlOb2RlKG5vZGVzUXVlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHN0cmluZyA9IG5vZGVzUXVlcnlOb2RlLmdldFN0cmluZygpLFxuICAgICAgICBleHByZXNzaW9uU3RyaW5nID0gc3RyaW5nLCAgLy8vXG4gICAgICAgIHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IGV2ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBldmVyeU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXRFdmVyeU5vZGUoKTtcblxuICBpZiAoZXZlcnlOb2RlICE9PSBudWxsKSB7XG4gICAgZXZlcnkgPSBldmVyeUZyb21FdmVyeU5vZGUoZXZlcnlOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBldmVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZWRUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBuZWdhdGVkVGVybSA9IG51bGw7XG5cbiAgY29uc3QgbmVnYXRlZFRlcm1Ob2RlID0gdGVybU5vZGUuZ2V0TmVnYXRlZFRlcm1Ob2RlKCk7XG5cbiAgaWYgKG5lZ2F0ZWRUZXJtTm9kZSAhPT0gbnVsbCkge1xuICAgIG5lZ2F0ZWRUZXJtID0gbmVnYXRlZFRlcm1Gcm9tTmVnYXRlZFRlcm1Ob2RlKG5lZ2F0ZWRUZXJtTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gbmVnYXRlZFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dpY2FsVGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBsZXQgbG9naWNhbFRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IGxvZ2ljYWxUZXJtTm9kZSA9IHRlcm1Ob2RlLmdldExvZ2ljYWxUZXJtTm9kZSgpO1xuXG4gIGlmIChsb2dpY2FsVGVybU5vZGUgIT09IG51bGwpIHtcbiAgICBsb2dpY2FsVGVybSA9IGxvZ2ljYWxUZXJtRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGxvZ2ljYWxUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBCT09MRUFOX1RZUEU7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbU5lZ2F0ZWRUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IEJPT0xFQU5fVFlQRTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tTmVnYXRlZFRlcm1Ob2RlKG5lZ2F0ZWRUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0ZXJtTm9kZSA9IG5lZ2F0ZWRUZXJtTm9kZS5nZXRUZXJtTm9kZSgpLFxuICAgICAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uTm9kZSA9IHJlZHVjZU5vZGUuZ2V0RXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCByZWR1Y2UgPSBudWxsO1xuXG4gIGNvbnN0IHJlZHVjZU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXRSZWR1Y2VOb2RlKCk7XG5cbiAgaWYgKHJlZHVjZU5vZGUgIT09IG51bGwpIHtcbiAgICByZWR1Y2UgPSByZWR1Y2VGcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiByZWR1Y2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwc0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHN0ZXBOb2RlcyA9IHJldHVybkJsb2NrTm9kZS5nZXRTdGVwTm9kZXMoKSxcbiAgICAgICAgc3RlcHMgPSBzdGVwTm9kZXMubWFwKChzdGVwTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwRnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KTtcblxuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gc3RlcHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21Ob2RlUXVlcnlOb2RlKG5vZGVRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gbm9kZVF1ZXJ5Tm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJuYXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCB0ZXJuYXJ5ID0gbnVsbDtcblxuICBjb25zdCB0ZXJuYXJ5Tm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFRlcm5hcnlOb2RlKCk7XG5cbiAgaWYgKHRlcm5hcnlOb2RlICE9PSBudWxsKSB7XG4gICAgdGVybmFyeSA9IHRlcm5hcnlGcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRlcm5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFja2V0ZWRUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBicmFja2V0ZWRUZXJtID0gbnVsbDtcblxuICBjb25zdCBicmFja2V0ZWRUZXJtTm9kZSA9IHRlcm1Ob2RlLmdldEJyYWNrZXRlZFRlcm1Ob2RlKCk7XG5cbiAgaWYgKGJyYWNrZXRlZFRlcm1Ob2RlICE9PSBudWxsKSB7XG4gICAgYnJhY2tldGVkVGVybSA9IGJyYWNrZXRlZFRlcm1Gcm9tQnJhY2tldGVkVGVybU5vZGUoYnJhY2tldGVkVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNrZXRlZFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbUJyYWNrZXRlZFRlcm1Ob2RlKGJyYWNrZXRlZFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1Ob2RlID0gYnJhY2tldGVkVGVybU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJpc29uVGVybUZyb21UZXJtTm9kZSh0ZXJtTk9kZSwgY29udGV4dCkge1xuICBsZXQgY29tcGFyaXNvblRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IGNvbXBhcmlzb25UZXJtTm9kZSA9IHRlcm1OT2RlLmdldENvbXBhcmlzb25UZXJtTm9kZSgpO1xuXG4gIGlmIChjb21wYXJpc29uVGVybU5vZGUgIT09IG51bGwpIHtcbiAgICBjb21wYXJpc29uVGVybSA9IGNvbXBhcmlzb25UZXJtRnJvbUNvbXBhcmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmlzb25UZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tTm9kZXNRdWVyeU5vZGUobm9kZXNRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gbm9kZXNRdWVyeU5vZGUuZ2V0VmFyaWFibGVOb2RlKCksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybXNOb2RlID0gcHJvY2VkdXJlQ2FsbE5vZGUuZ2V0VGVybXNOb2RlKCksXG4gICAgICAgIHRlcm1zID0gdGVybXNGcm9tVGVybXNOb2RlKHRlcm1zTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFBhcmFtZXRlck5vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlck5vZGUuZ2V0TmFtZSgpO1xuXG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVmdFRlcm1Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBsZWZ0VGVybU5vZGUgPSBsb2dpY2FsVGVybU5vZGUuZ2V0TGVmdFRlcm1Ob2RlKCksXG4gICAgbGVmdFRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKGxlZnRUZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGxlZnRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlBc3NpZ25tZW50RnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSB7XG4gIGxldCBhcnJheUFzc2lnbm1lbnQgPSBudWxsO1xuXG4gIGNvbnN0IGFycmF5QXNzaWdubWVudE5vZGUgPSBzdGVwTm9kZS5nZXRBcnJheUFzc2lnbm1lbnROb2RlKCk7XG5cbiAgaWYgKGFycmF5QXNzaWdubWVudE5vZGUgIT09IG51bGwpIHtcbiAgICBhcnJheUFzc2lnbm1lbnQgPSBhcnJheUFzc2lnbm1lbnRGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBhcnJheUFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZkV4cHJlc3Npb25Gcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgaWZFeHByZXNzaW9uTm9kZSA9IHRlcm5hcnlOb2RlLmdldElmRXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgaWZFeHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShpZkV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaWZFeHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVF1ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBub2RlUXVlcnkgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVRdWVyeU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXROb2RlUXVlcnlOb2RlKCk7XG5cbiAgaWYgKG5vZGVRdWVyeU5vZGUgIT09IG51bGwpIHtcbiAgICBub2RlUXVlcnkgPSBub2RlUXVlcnlGcm9tTm9kZVF1ZXJ5Tm9kZShub2RlUXVlcnlOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBub2RlUXVlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGlhc0Zyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFsaWFzID0gbmFtZWRQYXJhbWV0ZXJOb2RlLmdldEFsaWFzKCk7XG5cbiAgcmV0dXJuIGFsaWFzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21SZXR1cm5TdGF0ZW1lbnROb2RlKHJldHVyblN0YXRlbWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybU5vZGUgPSByZXR1cm5TdGF0ZW1lbnROb2RlLmdldFRlcm1Ob2RlKCksXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEFzc2lnbm1lbnRGcm9tU3RlcE5vZGUoc3RlcE5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IG9iamVjdEFzc2lnbm1lbnQgPSBudWxsO1xuXG4gIGNvbnN0IG9iamVjdEFzc2lnbm1lbnROb2RlID0gc3RlcE5vZGUuZ2V0T2JqZWN0QXNzaWdubWVudE5vZGUoKTtcblxuICBpZiAob2JqZWN0QXNzaWdubWVudE5vZGUgIT09IG51bGwpIHtcbiAgICBvYmplY3RBc3NpZ25tZW50ID0gb2JqZWN0QXNzaWdubWVudEZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0QXNzaWdubWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IG5vZGVzUXVlcnkgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVzUXVlcnlOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0Tm9kZXNRdWVyeU5vZGUoKTtcblxuICBpZiAobm9kZXNRdWVyeU5vZGUgIT09IG51bGwpIHtcbiAgICBub2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeUZyb21Ob2Rlc1F1ZXJ5Tm9kZShub2Rlc1F1ZXJ5Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gbm9kZXNRdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJpZ2h0VGVybUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHJpZ2h0VGVybU5vZGUgPSBsb2dpY2FsVGVybU5vZGUuZ2V0UmlnaHRUZXJtTm9kZSgpLFxuICAgICAgIHJpZ2h0VGVybSA9IHRlcm1Gcm9tVGVybU5vZGUocmlnaHRUZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJpZ2h0VGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZWRGcm9tQ29tcGFyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuZWdhdGVkID0gY29tcGFyaXNvblRlcm1Ob2RlLmlzTmVnYXRlZCgpO1xuXG4gIHJldHVybiBuZWdhdGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxzZUV4cHJlc3Npb25Gcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZWxzZUV4cHJlc3Npb25Ob2RlID0gdGVybmFyeU5vZGUuZ2V0RWxzZUV4cHJlc3Npb25Ob2RlKCksXG4gICAgICAgIGVsc2VFeHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShlbHNlRXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBlbHNlRXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkJsb2NrRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCByZXR1cm5CbG9jayA9IG51bGw7XG5cbiAgY29uc3QgcmV0dXJuQmxvY2tOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0UmV0dXJuQmxvY2tOb2RlKCk7XG5cbiAgaWYgKHJldHVybkJsb2NrTm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybkJsb2NrID0gcmV0dXJuQmxvY2tGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmV0dXJuQmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IHNvbWVOb2RlLmdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlID0gYW5vbnltb3VzUHJvY2VkdXJlRnJvbUFub255bW91c1Byb2NlZHVyZU5vZGUoYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGFub255bW91c1Byb2NlZHVyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vbnNlbnNpY2FsRnJvbVJldHVybkJsb2NrTm9kZShyZXR1cm5CbG9ja05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3Qgbm9uc2Vuc2ljYWwgPSByZXR1cm5CbG9ja05vZGUuaXNOb25zZW5zaWNhbCgpO1xuXG4gIHJldHVybiBub25zZW5zaWNhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZUZyb21Qcm9jZWR1cmVDYWxsTm9kZShwcm9jZWR1cmVDYWxsTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByZWZlcmVuY2VOb2RlID0gcHJvY2VkdXJlQ2FsbE5vZGUuZ2V0UmVmZXJlbmNlTm9kZSgpLFxuICAgICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2VGcm9tUmVmZXJlbmNlTm9kZShyZWZlcmVuY2VOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmVmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVmdFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBsZWZ0VGVybU5vZGUgPSBjb21wYXJpc29uVGVybU5vZGUuZ2V0TGVmdFRlcm1Ob2RlKCksXG4gICAgICAgIGxlZnRUZXJtID0gdGVybUZyb21UZXJtTm9kZShsZWZ0VGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBsZWZ0VGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc2p1bmN0aW9uRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZGlzanVuY3Rpb24gPSBsb2dpY2FsVGVybU5vZGUuaXNEaXNqdW5jdGlvbigpO1xuXG4gIHJldHVybiBkaXNqdW5jdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZWRUZXJtRnJvbU5lZ2F0ZWRUZXJtTm9kZShuZWdhdGVkVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOZWdhdGVkVGVybSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBuZWdhdGVkVGVybU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdGVybU5vZGUgPSBuZWdhdGVkVGVybU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tTmVnYXRlZFRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tTmVnYXRlZFRlcm1Ob2RlKG5lZ2F0ZWRUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5lZ2F0ZWRUZXJtID0gbmV3IE5lZ2F0ZWRUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdGVybSk7XG5cbiAgcmV0dXJuIG5lZ2F0ZWRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9naWNhbFRlcm1Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IExvZ2ljYWxUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGxvZ2ljYWxUZXJtTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB0eXBlID0gdHlwZUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgZGlzanVuY3Rpb24gPSBkaXNqdW5jdGlvbkZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgbGVmdFRlcm0gPSBsZWZ0VGVybUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmlnaHRUZXJtID0gcmlnaHRUZXJtRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBsb2dpY2FsVGVybSA9IG5ldyBMb2dpY2FsVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIGRpc2p1bmN0aW9uLCBsZWZ0VGVybSwgcmlnaHRUZXJtKTtcblxuICByZXR1cm4gbG9naWNhbFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21UeXBlQW5kVmFyaWFibGVOb2RlKHR5cGUsIHZhcmlhYmxlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHZhcmlhYmxlTm9kZSwgIC8vL1xuICAgICAgICBuYW1lID0gbmFtZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlKSxcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tVHlwZUFuZFZhcmlhYmxlTm9kZSh0eXBlLCB2YXJpYWJsZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUobmFtZSksXG4gICAgICAgIHN0cmluZyA9IHZhcmlhYmxlU3RyaW5nLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgZXhwcmVzc2lvbik7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCkge1xuICBsZXQgdmFyaWFibGVBc3NpZ25tZW50cyA9IG51bGw7XG5cbiAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50c05vZGUgPSBzdGVwTm9kZS5nZXRWYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSgpO1xuXG4gIGlmICh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSAhPT0gbnVsbCkge1xuICAgIHZhcmlhYmxlQXNzaWdubWVudHMgPSB2YXJpYWJsZUFzc2lnbm1lbnRzRnJvbVZhcmlhYmxlQXNzaWdubWVudHNOb2RlKHZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5vbnltb3VzUHJvY2VkdXJlRnJvbUV2ZXJ5Tm9kZShldmVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IGV2ZXJ5Tm9kZS5nZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsRXhwcmVzc2lvbkZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgaW5pdGlhbEV4cHJlc3Npb24gPSBleHByZXNzaW9uOyAvLy9cblxuICByZXR1cm4gaW5pdGlhbEV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVDYWxsRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBwcm9jZWR1cmVDYWxsID0gbnVsbDtcblxuICBjb25zdCBwcm9jZWR1cmVDYWxsTm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFByb2NlZHVyZUNhbGxOb2RlKCk7XG5cbiAgaWYgKHByb2NlZHVyZUNhbGxOb2RlICE9PSBudWxsKSB7XG4gICAgcHJvY2VkdXJlQ2FsbCA9IHByb2NlZHVyZUNhbGxGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHByb2NlZHVyZUNhbGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByaWdodFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByaWdodFRlcm1Ob2RlID0gY29tcGFyaXNvblRlcm1Ob2RlLmdldFJpZ2h0VGVybU5vZGUoKSxcbiAgICAgICAgcmlnaHRUZXJtID0gdGVybUZyb21UZXJtTm9kZShyaWdodFRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmlnaHRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IGFycmF5QXNzaWdubWVudE5vZGUuZ2V0VmFyaWFibGVOb2RlKCksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0eXBlID0gdmFyaWFibGVBc3NpZ25tZW50c05vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5vbnltb3VzUHJvY2VkdXJlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gcmVkdWNlTm9kZS5nZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSBvYmplY3RBc3NpZ25tZW50Tm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZS5nZXRUeXBlKCk7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uRnJvbVR5cGVBbmRWYXJpYWJsZU5vZGUodHlwZSwgdmFyaWFibGVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyc0Zyb21BcnJheUFzc2lnbm1lbnROb2RlKGFycmF5QXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyYW1ldGVyc05vZGUgPSBhcnJheUFzc2lnbm1lbnROb2RlLmdldFBhcmFtZXRlcnNOb2RlKCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhYmVsRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbGFiZWxOb2RlID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLmdldExhYmVsTm9kZSgpLFxuICAgICAgICBsYWJlbCA9IGxhYmVsRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblN0YXRlbWVudEZyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHJldHVyblN0YXRlbWVudE5vZGUgPSByZXR1cm5CbG9ja05vZGUuZ2V0UmV0dXJuU3RhdGVtZW50Tm9kZSgpLFxuICAgICAgICByZXR1cm5TdGF0ZW1lbnQgPSByZXR1cm5TdGF0ZW1lbnRGcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmV0dXJuU3RhdGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhY2tldGVkVGVybUZyb21CcmFja2V0ZWRUZXJtTm9kZShicmFja2V0ZWRUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEJyYWNrZXRlZFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gYnJhY2tldGVkVGVybU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSwgIC8vL1xuICAgICAgICB0ZXJtID0gdGVybUZyb21CcmFja2V0ZWRUZXJtTm9kZShicmFja2V0ZWRUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGJyYWNrZXRlZFRlcm0gPSBuZXcgQnJhY2tldGVkVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0pO1xuXG4gIHJldHVybiBicmFja2V0ZWRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21WYXJpYWJsZUFzc2lnbm1lbnROb2RlKHZhcmlhYmxlQXNzaWdtZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uTm9kZSA9IHZhcmlhYmxlQXNzaWdtZW50Tm9kZS5nZXRFeHByZXNzaW9uTm9kZSgpLFxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJhbWV0ZXJzRnJvbUFub255bW91c1Byb2NlZHVyZU5vZGUoYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBwYXJhbWV0ZXJzTm9kZSA9IGFub255bW91c1Byb2NlZHVyZU5vZGUuZ2V0UGFyYW1ldGVyc05vZGUoKSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tUGFyYW1ldGVyc05vZGUocGFyYW1ldGVyc05vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyaXNvblRlcm1Gcm9tQ29tcGFyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IENvbXBhcmlzb25UZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGNvbXBhcmlzb25UZXJtTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgbmVnYXRlZCA9IG5lZ2F0ZWRGcm9tQ29tcGFyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGxlZnRUZXJtID0gbGVmdFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHJpZ2h0VGVybSA9IHJpZ2h0VGVybUZyb21Db21wenJpc29uVGVybU5vZGUoY29tcGFyaXNvblRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgY29tcGFyaXNvblRlcm0gPSBuZXcgQ29tcGFyaXNvblRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCBuZWdhdGVkLCBsZWZ0VGVybSwgcmlnaHRUZXJtKTtcblxuICByZXR1cm4gY29tcGFyaXNvblRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5CbG9ja0Zyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcmV0dXJuQmxvY2tOb2RlID0gYW5vbnltb3VzUHJvY2VkdXJlTm9kZS5nZXRSZXR1cm5CbG9ja05vZGUoKSxcbiAgICAgICAgcmV0dXJuQmxvY2sgPSByZXR1cm5CbG9ja0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmV0dXJuQmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFByb2NlZHVyZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsICAvLy9cbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIGxhYmVsID0gbGFiZWxGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICByZXR1cm5CbG9jayA9IHJldHVybkJsb2NrRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwcm9jZWR1cmVTdHJpbmcgPSBwcm9jZWR1cmVTdHJpbmdGcm9tVHlwZUxhYmVsUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrKHR5cGUsIGxhYmVsLCBwYXJhbWV0ZXJzLCByZXR1cm5CbG9jayksXG4gICAgICAgIHN0cmluZyA9IHByb2NlZHVyZVN0cmluZywgLy8vXG4gICAgICAgIHByb2NlZHVyZSA9IG5ldyBQcm9jZWR1cmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBsYWJlbCwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spO1xuXG4gIHJldHVybiBwcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJhbWV0ZXJzRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyYW1ldGVyc05vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUuZ2V0UGFyYW1ldGVyc05vZGUoKSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tUGFyYW1ldGVyc05vZGUocGFyYW1ldGVyc05vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21Qcm9jZWR1cmVBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IGFub255bW91c1Byb2NlZHVyZU5vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQmxvY2tGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByZXR1cm5CbG9ja05vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUuZ2V0UmV0dXJuQmxvY2tOb2RlKCksXG4gICAgICAgIHJldHVybkJsb2NrID0gcmV0dXJuQmxvY2tGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSB2YXJpYWJsZUFzc2lnbm1lbnROb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVR5cGVBbmRWYXJpYWJsZU5vZGUodHlwZSwgdmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlQXNzaWdubWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSB2YXJpYWJsZUFzc2lnbm1lbnROb2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uRnJvbVZhcmlhYmxlQXNzaWdubWVudE5vZGUodmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA9IHZhcmlhYmxlQXNzaWdubWVudFN0cmluZ0Zyb21UeXBlQW5kVmFyaWFibGUodHlwZSwgdmFyaWFibGUsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcsICAvLy9cbiAgICAgICAgYXNzaWdubWVudCA9IG5ldyBWYXJpYWJsZUFzc2lnbm1lbnQoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgZXhwcmVzc2lvbik7XG5cbiAgcmV0dXJuIGFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0FycmF5RnJvbVRlcm1Ob2Rlcyh0ZXJtTm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybXNBcnJheSA9IHRlcm1Ob2Rlcy5tYXAoKHRlcm1Ob2RlKSA9PiB7IC8vL1xuICAgIGNvbnN0IHRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9KTtcblxuICByZXR1cm4gdGVybXNBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtdGVyc0FycmF5RnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBhcmFtZXRlck5vZGVzID0gcGFyYW1ldGVyc05vZGUuZ2V0UGFyYW1ldGVyTm9kZXMoKSxcbiAgICAgICAgcGFyYW10ZXJzQXJyYXkgPSBwYXJhbWV0ZXJOb2Rlcy5tYXAoKHBhcmFtZXRlck5vZGUpID0+IHsgLy8vXG4gICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyRnJvbVBhcmFtZXRlck5vZGUocGFyYW1ldGVyTm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gcGFyYW10ZXJzQXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZFBhcmFtdGVyc0FycmF5RnJvbU5hbWVkUGFyYW1ldGVyTm9kZXMobmFtZWRQYXJhbWV0ZXJOb2RlcywgY29udGV4dCkge1xuICBjb25zdCBuYW1lZFBhcmFtdGVyc0FycmF5ID0gbmFtZWRQYXJhbWV0ZXJOb2Rlcy5tYXAoKG5hbWVkUGFyYW1ldGVyTm9kZSkgPT4geyAvLy9cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlciA9IG5hbWVkUGFyYW1ldGVyRnJvbU5hbWVkUGFyYW1ldGVyTm9kZShuYW1lZFBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIG5hbWVkUGFyYW1ldGVyO1xuICB9KTtcblxuICByZXR1cm4gbmFtZWRQYXJhbXRlcnNBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlQXNzaWdubWVudHNBcnJheUZyb21UeXBlQW5kVmFyaWFibGVBc3NpZ25tZW50c05vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50Tm9kZXMgPSB2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZS5nZXRWYXJpYWJsZUFzc2lnbm1lbnROb2RlcygpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkgPSB2YXJpYWJsZUFzc2lnbm1lbnROb2Rlcy5tYXAoKHZhcmlhYmxlQXNzaWdubWVudE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnQgPSB2YXJpYWJsZUFzc2lnbm1lbnRGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50O1xuICAgICAgICB9KTtcblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50c0FycmF5O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBTaW1wbGVQYXNzLCBxdWVyeVV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZXJyb3JGcm9tRXJyb3JOb2RlLCBwcm9jZWR1cmVEZWNsYXJhdGlvbkZyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2VsZW1lbnRcIjtcblxuY29uc3QgeyBub2RlUXVlcnkgfSA9IHF1ZXJ5VXRpbGl0aWVzO1xuXG5jb25zdCBlcnJvck5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9lcnJvclwiKSxcbiAgICAgIHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3Byb2NlZHVyZURlY2xhcmF0aW9uXCIpO1xuXG5jbGFzcyBUb3BMZXZlbFBhc3MgZXh0ZW5kcyBTaW1wbGVQYXNzIHtcbiAgc3RhdGljIG1hcHMgPSBbXG4gICAge1xuICAgICAgbm9kZVF1ZXJ5OiBlcnJvck5vZGVRdWVyeSxcbiAgICAgIHJ1bjogKGVycm9yTm9kZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JGcm9tRXJyb3JOb2RlKGVycm9yTm9kZSwgY29udGV4dCksXG4gICAgICAgICAgICAgIGVycm9yVmVyaWZpZXMgPSBlcnJvci52ZXJpZnkoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGVycm9yVmVyaWZpZXMpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbm9kZVF1ZXJ5OiBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGVRdWVyeSxcbiAgICAgIHJ1bjogKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHByb2NlZHVyZURlY2xhcmF0aW9uID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Gcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgICAgICAgIHByb2NlZHVyZURlY2xhcmF0aW9uVmVyaWZpZXMgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbi52ZXJpZnkoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKHByb2NlZHVyZURlY2xhcmF0aW9uVmVyaWZpZXMpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cblxuY29uc3QgdG9wTGV2ZWxQYXNzID0gbmV3IFRvcExldmVsUGFzcygpO1xuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5RmlsZShmaWxlTm9kZSwgY29udGV4dCkge1xuICBsZXQgZmlsZVZlcmlmaWVzID0gZmFsc2U7XG5cbiAgY29uc3Qgbm9kZSA9IGZpbGVOb2RlLCAvLy9cbiAgICAgICAgc3VjZXNzID0gdG9wTGV2ZWxQYXNzLnJ1bihub2RlLCBjb250ZXh0KTtcblxuICBpZiAoc3VjZXNzKSB7XG4gICAgZmlsZVZlcmlmaWVzID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmaWxlVmVyaWZpZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGxleGVyVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgRnVydGxlTGV4ZXIgZnJvbSBcIi4uL2Z1cnRsZS9sZXhlclwiO1xuXG5jb25zdCB7IGxleGVyRnJvbVJ1bGVzLCBydWxlc0Zyb21FbnRyaWVzIH0gPSBsZXhlclV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZUxleGVyRnJvbU5vdGhpbmcoQ2xhc3MpIHtcbiAgaWYgKENsYXNzID09PSB1bmRlZmluZWQpIHtcbiAgICBDbGFzcyA9IEZ1cnRsZUxleGVyOyAgLy8vXG4gIH1cblxuICBjb25zdCB7IGVudHJpZXMgfSA9IEZ1cnRsZUxleGVyO1xuXG4gIGxldCBydWxlcztcblxuICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgY29uc3QgZnVydGxlTGV4ZXIgPSBsZXhlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBmdXJ0bGVMZXhlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZUxleGVyRnJvbUVudHJpZXMoQ2xhc3MsIGVudHJpZXMpIHtcbiAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGVudHJpZXMgPSBDbGFzczsgIC8vL1xuXG4gICAgQ2xhc3MgPSBGdXJ0bGVMZXhlcjsgIC8vL1xuICB9XG5cbiAgbGV0IHJ1bGVzO1xuXG4gIHJ1bGVzID0gcnVsZXNGcm9tRW50cmllcyhlbnRyaWVzKTtcblxuICBjb25zdCBmdXJ0bGVMZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGZ1cnRsZUxleGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZ1cnRsZUxleGVyRnJvbUVudHJpZXMsXG4gIGZ1cnRsZUxleGVyRnJvbU5vdGhpbmdcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnNlclV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXItdXRpbGl0aWVzXCI7XG5cbmltcG9ydCBGdXJ0bGVQYXJzZXIgZnJvbSBcIi4uL2Z1cnRsZS9wYXJzZXJcIjtcblxuY29uc3QgeyBydWxlc0Zyb21CTkYsIHBhcnNlckZyb21SdWxlcywgcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZSB9ID0gcGFyc2VyVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gZnVydGxlUGFyc2VyRnJvbUJORihDbGFzcywgYm5mKSB7XG4gIGlmIChibmYgPT09IHVuZGVmaW5lZCkge1xuICAgIGJuZiA9IENsYXNzOyAgLy8vXG5cbiAgICBDbGFzcyA9IEZ1cnRsZVBhcnNlcjsgIC8vL1xuICB9XG5cbiAgbGV0IHJ1bGVzO1xuXG4gIHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZik7XG5cbiAgcnVsZXMgPSBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uKHJ1bGVzKTsgIC8vL1xuXG4gIGNvbnN0IGZ1cnRsZVBhcnNlciA9IHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBmdXJ0bGVQYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdXJ0bGVQYXJzZXJGcm9tTm90aGluZyhDbGFzcykge1xuICBpZiAoQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIENsYXNzID0gRnVydGxlUGFyc2VyOyAgLy8vXG4gIH1cblxuICBjb25zdCB7IGJuZiB9ID0gRnVydGxlUGFyc2VyO1xuXG4gIGxldCBydWxlcztcblxuICBydWxlcyA9IHJ1bGVzRnJvbUJORihibmYpO1xuXG4gIHJ1bGVzID0gZWxpbWluYXRlTGVmdFJlY3Vyc2lvbihydWxlcyk7ICAvLy9cblxuICBjb25zdCBmdXJ0bGVQYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gZnVydGxlUGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVydGxlUGFyc2VyRnJvbUJORkFuZFN0YXJ0UnVsZU5hbWUoQ2xhc3MsIGJuZiwgc3RhcnRSdWxlTmFtZSkge1xuICBpZiAoc3RhcnRSdWxlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRSdWxlTmFtZSA9IGJuZjsgIC8vL1xuXG4gICAgYm5mID0gQ2xhc3M7ICAvLy9cblxuICAgIENsYXNzID0gRnVydGxlUGFyc2VyOyAgLy8vXG4gIH1cblxuICBsZXQgcnVsZXM7XG5cbiAgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICBydWxlcyA9IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpOyAgLy8vXG5cbiAgY29uc3QgZnVydGxlUGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpO1xuXG4gIHJldHVybiBmdXJ0bGVQYXJzZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZnVydGxlUGFyc2VyRnJvbUJORixcbiAgZnVydGxlUGFyc2VyRnJvbU5vdGhpbmcsXG4gIGZ1cnRsZVBhcnNlckZyb21CTkZBbmRTdGFydFJ1bGVOYW1lXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRnVydGxlTGV4ZXIgZnJvbSBcIi4uL2Z1cnRsZS9sZXhlclwiO1xuaW1wb3J0IEZ1cnRsZVBhcnNlciBmcm9tIFwiLi4vZnVydGxlL3BhcnNlclwiO1xuXG5pbXBvcnQgeyBmdXJ0bGVMZXhlckZyb21Ob3RoaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9sZXhlcnNcIjtcbmltcG9ydCB7IGZ1cnRsZVBhcnNlckZyb21Ob3RoaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJzZXJzXCI7XG5cbmV4cG9ydCBjb25zdCBmdXJ0bGVMZXhlciA9IGZ1cnRsZUxleGVyRnJvbU5vdGhpbmcoRnVydGxlTGV4ZXIpO1xuXG5leHBvcnQgY29uc3QgZnVydGxlUGFyc2VyID0gZnVydGxlUGFyc2VyRnJvbU5vdGhpbmcoRnVydGxlUGFyc2VyKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRmlsZUNvbnRleHQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IHZlcmlmeUZpbGUgfSBmcm9tIFwiLi4vLi4vcHJvY2Vzcy92ZXJpZnlcIjtcbmltcG9ydCB7IGZ1cnRsZUxleGVyLCBmdXJ0bGVQYXJzZXIgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2Z1cnRsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXJ0bGVGaWxlQ29udGV4dCBleHRlbmRzIEZpbGVDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgZmlsZUNvbnRlbnQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUsIGxleGVyLCBwYXJzZXIsIHByb2NlZHVyZXMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBmaWxlQ29udGVudCwgZmlsZVBhdGgsIHRva2Vucywgbm9kZSk7XG5cbiAgICB0aGlzLmxleGVyID0gbGV4ZXI7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5wcm9jZWR1cmVzID0gcHJvY2VkdXJlcztcbiAgfVxuXG4gIGdldExleGVyKCkge1xuICAgIHJldHVybiB0aGlzLmxleGVyO1xuICB9XG5cbiAgZ2V0UGFyc2VyKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlcjtcbiAgfVxuXG4gIGdldFByb2NlZHVyZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IGluY2x1ZGVSZWxlYXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2V0UHJvY2VkdXJlcygpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VkdXJlcztcblxuICAgIHJldHVybiBwcm9jZWR1cmVzO1xuICB9XG5cbiAgZ2V0TGFiZWxzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuXG4gICAgcmV0dXJuIGxhYmVscztcbiAgfVxuXG4gIGdldFR5cGVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHR5cGVzID0gW107XG5cbiAgICByZXR1cm4gdHlwZXM7XG4gIH1cblxuICBnZXRSdWxlcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBydWxlcyA9IFtdXG5cbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBnZXRBeGlvbXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgYXhpb21zID0gW107XG5cbiAgICByZXR1cm4gYXhpb21zO1xuICB9XG5cbiAgZ2V0TGVtbWFzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxlbW1hcyA9IFtdO1xuXG4gICAgcmV0dXJuIGxlbW1hcztcbiAgfVxuXG4gIGdldFRoZW9yZW1zKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHRoZW9yZW1zID0gW107XG5cbiAgICByZXR1cm4gdGhlb3JlbXM7XG4gIH1cblxuICBnZXRWYXJpYWJsZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW107XG5cbiAgICByZXR1cm4gdmFyaWFibGVzO1xuICB9XG5cbiAgZ2V0TWV0YUxlbW1hcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhTGVtbWFzID0gW107XG5cbiAgICByZXR1cm4gbWV0YUxlbW1hcztcbiAgfVxuXG4gIGdldENvbmplY3R1cmVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbmplY3R1cmVzID0gW107XG5cbiAgICByZXR1cm4gY29uamVjdHVyZXM7XG4gIH1cblxuICBnZXRDb21iaW5hdG9ycyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBjb21iaW5hdG9ycyA9IFtdO1xuXG4gICAgcmV0dXJuIGNvbWJpbmF0b3JzO1xuICB9XG5cbiAgZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHR5cGVQcmVmaXhlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHR5cGVQcmVmaXhlcztcbiAgfVxuXG4gIGdldENvbnN0cnVjdG9ycyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvcnMgPSBbXTtcblxuICAgIHJldHVybiBjb25zdHJ1Y3RvcnM7XG4gIH1cblxuICBnZXRNZXRhdGhlb3JlbXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YXRoZW9yZW1zID0gW107XG5cbiAgICByZXR1cm4gbWV0YXRoZW9yZW1zO1xuICB9XG5cbiAgZ2V0TWV0YXZhcmlhYmxlcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhdmFyaWFibGVzID0gW107XG5cbiAgICByZXR1cm4gbWV0YXZhcmlhYmxlcztcbiAgfVxuXG4gIGFkZFByb2NlZHVyZShwcm9jZWR1cmUpIHtcbiAgICBjb25zdCBwcm9jZWR1cmVTdHJpbmcgPSBwcm9jZWR1cmUuZ2V0U3RyaW5nKCk7XG5cbiAgICB0aGlzLnByb2NlZHVyZXMucHVzaChwcm9jZWR1cmUpO1xuXG4gICAgY29uc3QgZmlsZVBhdGggPSB0aGlzLmdldEZpbGVQYXRoKCk7XG5cbiAgICB0aGlzLmRlYnVnKGBBZGRlZCB0aGUgJyR7cHJvY2VkdXJlU3RyaW5nfScgcHJvY2VkdXJlIHRvIHRoZSAnJHtmaWxlUGF0aH0nIGZpbGUgY29udGV4dC5gKTtcbiAgfVxuXG4gIGZpbmRQcm9jZWR1cmVCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSkge1xuICAgIGNvbnN0IHByb2NlZHVyZXMgPSB0aGlzLmdldFByb2NlZHVyZXMoKSxcbiAgICAgICAgICBwcm9jZWR1cmUgPSBwcm9jZWR1cmVzLmZpbmQoKHByb2NlZHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvY2VkdXJlQ29tcGFyZXNUb1Byb2NlZHVyZU5hbWUgPSBwcm9jZWR1cmUuY29tcGFyZVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9jZWR1cmVDb21wYXJlc1RvUHJvY2VkdXJlTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgfVxuXG4gIGlzUHJvY2VkdXJlUHJlc2VudEJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlID0gdGhpcy5maW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpLFxuICAgICAgICAgIHByb2NlZHVyZVByZXNlbnQgPSAocHJvY2VkdXJlICE9PSBudWxsKTtcblxuICAgIHJldHVybiBwcm9jZWR1cmVQcmVzZW50O1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5wcm9jZWR1cmVzID0gW107XG4gIH1cblxuICBjb21wbGV0ZSgpIHtcbiAgICAvLy9cbiAgfVxuXG4gIGFzeW5jIHZlcmlmeUZpbGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpLFxuICAgICAgICAgIGNvbnRleHQgPSB0aGlzLCAvLy9cbiAgICAgICAgICBmaWxlTm9kZSA9IG5vZGUsICAvLy9cbiAgICAgICAgICBmaWxlVmVyaWZpZXMgPSB2ZXJpZnlGaWxlKGZpbGVOb2RlLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBmaWxlVmVyaWZpZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbUZpbGUoZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGxleGVyID0gZnVydGxlTGV4ZXIsICAvLy9cbiAgICAgICAgICBwYXJzZXIgPSBmdXJ0bGVQYXJzZXIsICAvLy9cbiAgICAgICAgICBwcm9jZWR1cmVzID0gW10sXG4gICAgICAgICAgZnVydGxlRmlsZUNvbnRleHQgPSBGaWxlQ29udGV4dC5mcm9tRmlsZShGdXJ0bGVGaWxlQ29udGV4dCwgZmlsZSwgbGV4ZXIsIHBhcnNlciwgcHJvY2VkdXJlcywgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZnVydGxlRmlsZUNvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbiwgY29udGV4dCkge1xuICAgIGNvbnN0IGxleGVyID0gZnVydGxlTGV4ZXIsICAvLy9cbiAgICAgICAgICBwYXJzZXIgPSBmdXJ0bGVQYXJzZXIsICAvLy9cbiAgICAgICAgICBwcm9jZWR1cmVzID0gbnVsbCxcbiAgICAgICAgICBmdXJ0bGVGaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0LmZyb21KU09OKEZ1cnRsZUZpbGVDb250ZXh0LCBqc29uLCBsZXhlciwgcGFyc2VyLCBwcm9jZWR1cmVzLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBmdXJ0bGVGaWxlQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmltcG9ydCB7IHRlcm1zU3RyaW5nRnJvbVRlcm1zQXJyYXkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlLCB0ZXJtRnJvbVByaW1pdGl2ZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtcyB9ID0gZWxlbWVudHMsXG4gICAgICAgIHRlcm1zQXJyYXkgPSB0ZXJtc0FycmF5RnJvbU5vZGVzKG5vZGVzLCBjb250ZXh0KSxcbiAgICAgICAgdGVybXNTdHJpbmcgPSB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5KHRlcm1zQXJyYXkpLFxuICAgICAgICBzdHJpbmcgPSB0ZXJtc1N0cmluZywgLy8vXG4gICAgICAgIGFycmF5ID0gdGVybXNBcnJheSwgIC8vL1xuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJtcyA9IG5ldyBUZXJtcyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gdGVybXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0Zyb21QcmltaXRpdmVzKHByaW1pdGl2ZXMpIHtcbiAgY29uc3QgeyBUZXJtcyB9ID0gZWxlbWVudHMsXG4gICAgICAgIHRlcm1zQXJyYXkgPSB0ZXJtc0FycmF5RnJvbVByaW1pdGl2ZXMocHJpbWl0aXZlcyksXG4gICAgICAgIHRlcm1zU3RyaW5nID0gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5KSxcbiAgICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICAgIHN0cmluZyA9IHRlcm1zU3RyaW5nLCAvLy9cbiAgICAgICAgYXJyYXkgPSB0ZXJtc0FycmF5LCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsLFxuICAgICAgICB0ZXJtcyA9IG5ldyBUZXJtcyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gdGVybXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdGVybXNGcm9tTm9kZXMsXG4gIHRlcm1zRnJvbVByaW1pdGl2ZXNcbn07XG5cbmZ1bmN0aW9uIHRlcm1zQXJyYXlGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybXNBcnJheSA9IG5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IHRlcm0gPSB0ZXJtRnJvbU5vZGUobm9kZSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1zQXJyYXk7XG59XG5cbmZ1bmN0aW9uIHRlcm1zQXJyYXlGcm9tUHJpbWl0aXZlcyhwcmltaXRpdmVzKSB7XG4gIGNvbnN0IHRlcm1zQXJyYXkgPSBwcmltaXRpdmVzLm1hcCgocHJpbWl0aXZlKSA9PiB7XG4gICAgY29uc3QgdGVybSA9IHRlcm1Gcm9tUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1zQXJyYXk7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFwiLi9wcmVhbWJsZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlcm1zIH0gZnJvbSBcIi4vZWxlbWVudC90ZXJtc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZ1cnRsZUxleGVyIH0gZnJvbSBcIi4vZnVydGxlL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZ1cnRsZVBhcnNlciB9IGZyb20gXCIuL2Z1cnRsZS9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlRmlsZUNvbnRleHQgfSBmcm9tIFwiLi9jb250ZXh0L2ZpbGUvZnVydGxlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGVybVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy90ZXJtXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRlcm1zVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3Rlcm1zXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGxleGVyc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9sZXhlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2Vyc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9wYXJzZXJzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByaW1pdGl2ZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9wcmltaXRpdmVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuY29uc3QgU3ViSGVhZGluZyA9IHdpdGhTdHlsZS5oMmBcblxuICBtYXJnaW46IDFyZW0gMCAwLjVyZW0gMDtcbiAgZm9udC1zaXplOiAycmVtO1xuICBcbiAgOmZpcnN0LW9mLXR5cGUge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gIH1cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgU3ViSGVhZGluZztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgU2l6ZWFibGVEaXYgfSBmcm9tIFwiZWFzeS1sYXlvdXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFNpemVhYmxlRGl2KWBcblxuICB3aWR0aDogODByZW07XG4gIG1pbi13aWR0aDogNDhyZW07XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgVGV4dGFyZWEgfSBmcm9tIFwiZWFzeVwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVGV4dGFyZWEpYFxuXG4gIGJvcmRlcjogMXB4IHNvbGlkIGRhcmtncmV5O1xuICBoZWlnaHQ6IDM2cmVtO1xuICByZXNpemU6IHZlcnRpY2FsO1xuICBwYWRkaW5nOiAwLjI1cmVtO1xuICBmb250LXNpemU6IDEuMnJlbTtcbiAgbGluZS1oZWlnaHQ6IDEuNXJlbTtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCTkZUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgZ2V0Qk5GKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpLFxuICAgICAgICAgIGJuZiA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBibmY7XG4gIH1cblxuICBzZXRCTkYoYm5mKSB7XG4gICAgY29uc3QgdmFsdWUgPSBibmY7XG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0Qk5GID0gdGhpcy5nZXRCTkYuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXRCTkYgPSB0aGlzLnNldEJORi5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRCTkYsXG4gICAgICBzZXRCTkZcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiYm5mXCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiXG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IElucHV0IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgUnVsZU5hbWVJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgZ2V0UnVsZU5hbWUoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgcnVsZU5hbWUgPSB2YWx1ZTsgLy8vXG5cbiAgICByZXR1cm4gcnVsZU5hbWU7XG4gIH1cblxuICBzZXRSdWxlTmFtZShydWxlTmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gcnVsZU5hbWU7IC8vL1xuXG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBwYXJlbnRDb250ZXh0KCkge1xuICAgIGNvbnN0IGdldFJ1bGVOYW1lID0gdGhpcy5nZXRSdWxlTmFtZS5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldFJ1bGVOYW1lID0gdGhpcy5zZXRSdWxlTmFtZS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRSdWxlTmFtZSxcbiAgICAgIHNldFJ1bGVOYW1lXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInJ1bGUtbmFtZVwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoUnVsZU5hbWVJbnB1dClgXG5cbiAgYm9yZGVyOiAxcHggc29saWQgZGFya2dyZXk7XG4gIHBhZGRpbmc6IDAuMjVyZW07XG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0YXJlYSBmcm9tIFwiLi4vdGV4dGFyZWFcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uLy4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbnNUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgc2V0VG9rZW5zKHRva2Vucykge1xuICAgIGxldCBsaW5lTnVtYmVyID0gMSxcbiAgICAgICAgcHJldmlvdXNUb2tlbiA9IG51bGw7XG5cbiAgICBjb25zdCBodG1sID0gdG9rZW5zLnJlZHVjZSgoaHRtbCwgdG9rZW4pID0+IHtcbiAgICAgIGNvbnN0IHRva2VuSFRNTCA9IHRva2VuLmFzSFRNTCgpO1xuXG4gICAgICBpZiAocHJldmlvdXNUb2tlbiA9PT0gbnVsbCkge1xuICAgICAgICBodG1sICs9IGAke2xpbmVOdW1iZXIrK306IGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2aW91c1Rva2VuRW5kT2ZMaW5lVG9rZW4gPSBwcmV2aW91c1Rva2VuLmlzRW5kT2ZMaW5lVG9rZW4oKTtcblxuICAgICAgICBpZiAocHJldmlvdXNUb2tlbkVuZE9mTGluZVRva2VuKSB7XG4gICAgICAgICAgaHRtbCArPSBgJHtsaW5lTnVtYmVyKyt9OiBgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gdG9rZW5IVE1MO1xuXG4gICAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG5cbiAgICAgIHJldHVybiBodG1sO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICB0aGlzLmh0bWwoaHRtbCk7XG4gIH1cblxuICBjbGVhclRva2VucygpIHtcbiAgICBjb25zdCBodG1sID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgdGhpcy5odG1sKGh0bWwpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXRUb2tlbnMgPSB0aGlzLnNldFRva2Vucy5iaW5kKHRoaXMpLFxuICAgICAgICAgIGNsZWFyVG9rZW5zID0gdGhpcy5jbGVhclRva2Vucy5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBzZXRUb2tlbnMsXG4gICAgICBjbGVhclRva2Vuc1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJ0b2tlbnNcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50VGV4dGFyZWEgZXh0ZW5kcyBUZXh0YXJlYSB7XG4gIGdldENvbnRlbnQoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgY29udGVudCA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb250ZW50OyAgLy8vXG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0Q29udGVudCA9IHRoaXMuZ2V0Q29udGVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldENvbnRlbnQgPSB0aGlzLnNldENvbnRlbnQuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgZ2V0Q29udGVudCxcbiAgICAgIHNldENvbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29udGVudFwiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGV4dGFyZWEgZnJvbSBcIi4uL3RleHRhcmVhXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyc2VUcmVlVGV4dGFyZWEgZXh0ZW5kcyBUZXh0YXJlYSB7XG4gIHNldFBhcnNlVHJlZShwYXJzZVRyZWUpIHtcbiAgICBpZiAocGFyc2VUcmVlICE9PSBudWxsKSB7XG4gICAgICBwYXJzZVRyZWUuc2hpZnRMaW5lKCk7ICAvL1xuXG4gICAgICBjb25zdCBwYXJzZVRyZWVTdHJpbmcgPSBwYXJzZVRyZWUuYXNTdHJpbmcoKSxcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VUcmVlU3RyaW5nOyAgLy8vXG5cbiAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyUGFyc2VUcmVlKCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJQYXJzZVRyZWUoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3Qgc2V0UGFyc2VUcmVlID0gdGhpcy5zZXRQYXJzZVRyZWUuYmluZCh0aGlzKSxcbiAgICAgICAgICBjbGVhclBhcnNlVHJlZSA9IHRoaXMuY2xlYXJQYXJzZVRyZWUuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgc2V0UGFyc2VUcmVlLFxuICAgICAgY2xlYXJQYXJzZVRyZWVcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwidG9rZW5zXCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0YXJlYSBmcm9tIFwiLi4vdGV4dGFyZWFcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV4aWNhbEVudHJpZXNUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgZ2V0TGV4aWNhbEVudHJpZXMoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgbGV4aWNhbEVudHJpZXMgPSBKU09OLnBhcnNlKHZhbHVlKTtcblxuICAgIHJldHVybiBsZXhpY2FsRW50cmllcztcbiAgfVxuXG4gIHNldExleGljYWxFbnRyaWVzKGxleGljYWxFbnRyaWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShsZXhpY2FsRW50cmllcywgbnVsbCwgXCIgIFwiKTtcblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBnZXRMZXhpY2FsRW50cmllcyA9IHRoaXMuZ2V0TGV4aWNhbEVudHJpZXMuYmluZCh0aGlzKSxcbiAgICAgICAgICBzZXRMZXhpY2FsRW50cmllcyA9IHRoaXMuc2V0TGV4aWNhbEVudHJpZXMuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiAoe1xuICAgICAgZ2V0TGV4aWNhbEVudHJpZXMsXG4gICAgICBzZXRMZXhpY2FsRW50cmllc1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJsZXhpY2FsLWVudHJpZXNcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCJcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5pbXBvcnQgeyBSb3dzRGl2LCBDb2x1bW5EaXYsIENvbHVtbnNEaXYsIFZlcnRpY2FsU3BsaXR0ZXJEaXYgfSBmcm9tIFwiZWFzeS1sYXlvdXRcIjtcbmltcG9ydCB7IEZ1cnRsZUxleGVyLEZ1cnRsZVBhcnNlciwgbGV4ZXJzVXRpbGl0aWVzLCBwYXJzZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4uL2luZGV4XCI7IC8vL1xuXG5pbXBvcnQgU3ViSGVhZGluZyBmcm9tIFwiLi92aWV3L3N1YkhlYWRpbmdcIjtcbmltcG9ydCBTaXplYWJsZURpdiBmcm9tIFwiLi92aWV3L2Rpdi9zaXplYWJsZVwiO1xuaW1wb3J0IEJORlRleHRhcmVhIGZyb20gXCIuL3ZpZXcvdGV4dGFyZWEvYm5mXCI7XG5pbXBvcnQgUnVsZU5hbWVJbnB1dCBmcm9tIFwiLi92aWV3L2lucHV0L3J1bGVOYW1lXCI7XG5pbXBvcnQgVG9rZW5zVGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS90b2tlbnNcIjtcbmltcG9ydCBDb250ZW50VGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS9jb250ZW50XCI7XG5pbXBvcnQgUGFyc2VUcmVlVGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS9wYXJzZVRyZWVcIjtcbmltcG9ydCBMZXhpY2FsRW50cmllc1RleHRhcmVhIGZyb20gXCIuL3ZpZXcvdGV4dGFyZWEvbGV4aWNhbEVudHJpZXNcIjtcblxuY29uc3QgeyBmdXJ0bGVQYXJzZXJGcm9tQk5GIH0gPSBwYXJzZXJzVXRpbGl0aWVzLFxuICAgICAgeyBmdXJ0bGVMZXhlckZyb21FbnRyaWVzIH0gPSBsZXhlcnNVdGlsaXRpZXM7XG5cbmNvbnN0IHsgYm5mIH0gPSBGdXJ0bGVQYXJzZXIsXG4gICAgICB7IGVudHJpZXMgfSA9IEZ1cnRsZUxleGVyO1xuXG5jbGFzcyBWaWV3IGV4dGVuZHMgRWxlbWVudCB7XG4gIGtleVVwSGFuZGxlciA9IChldmVudCwgZWxlbWVudCkgPT4ge1xuICAgIC8vIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmdldFRva2VucygpLFxuICAgICAgICAgICAgcGFyc2VUcmVlID0gdGhpcy5nZXRQYXJzZVRyZWUodG9rZW5zKTtcblxuICAgICAgdGhpcy5zZXRUb2tlbnModG9rZW5zKTtcblxuICAgICAgdGhpcy5zZXRQYXJzZVRyZWUocGFyc2VUcmVlKTtcbiAgICAvLyB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgIC8vXG4gICAgLy8gICB0aGlzLmNsZWFyVG9rZW5zKCk7XG4gICAgLy9cbiAgICAvLyAgIHRoaXMuY2xlYXJQYXJzZVRyZWUoKTtcbiAgICAvLyB9XG4gIH1cblxuICBnZXRUb2tlbnMoKSB7XG4gICAgY29uc3QgbGV4aWNhbEVudHJpZXMgPSB0aGlzLmdldExleGljYWxFbnRyaWVzKCksXG4gICAgICAgICAgZW50cmllcyA9IGxleGljYWxFbnRyaWVzLCAvLy9cbiAgICAgICAgICBmdXJ0bGVMZXhlciA9IGZ1cnRsZUxleGVyRnJvbUVudHJpZXMoZW50cmllcyksXG4gICAgICAgICAgbGV4ZXIgPSBmdXJ0bGVMZXhlciwgIC8vL1xuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICB0b2tlbnMgPSBsZXhlci50b2tlbmlzZShjb250ZW50KTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBnZXRQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgbGV0IHBhcnNlVHJlZSA9IG51bGw7XG5cbiAgICBjb25zdCBibmYgPSB0aGlzLmdldEJORigpLFxuICAgICAgICAgIGZ1cnRsZVBhcnNlciA9IGZ1cnRsZVBhcnNlckZyb21CTkYoYm5mKSxcbiAgICAgICAgICBwYXJzZXIgPSBmdXJ0bGVQYXJzZXIsICAvLy9cbiAgICAgICAgICBydWxlTmFtZSA9IHRoaXMuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTWFwID0gcGFyc2VyLmdldFJ1bGVNYXAoKSxcbiAgICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgICAgbm9kZSA9IHBhcnNlci5wYXJzZSh0b2tlbnMsIHJ1bGUpO1xuXG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHBhcnNlVHJlZSA9IG5vZGUuYXNQYXJzZVRyZWUodG9rZW5zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgY2hpbGRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gKFxuXG4gICAgICA8Q29sdW1uc0Rpdj5cbiAgICAgICAgPFNpemVhYmxlRGl2PlxuICAgICAgICAgIDxSb3dzRGl2PlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIExleGljYWwgZW50cmllc1xuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPExleGljYWxFbnRyaWVzVGV4dGFyZWEgb25LZXlVcD17dGhpcy5rZXlVcEhhbmRsZXJ9IC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgQk5GXG4gICAgICAgICAgICA8L1N1YkhlYWRpbmc+XG4gICAgICAgICAgICA8Qk5GVGV4dGFyZWEgb25LZXlVcD17dGhpcy5rZXlVcEhhbmRsZXJ9IC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgUnVsZSBuYW1lXG4gICAgICAgICAgICA8L1N1YkhlYWRpbmc+XG4gICAgICAgICAgICA8UnVsZU5hbWVJbnB1dCBvbktleVVwPXt0aGlzLmtleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICA8L1Jvd3NEaXY+XG4gICAgICAgIDwvU2l6ZWFibGVEaXY+XG4gICAgICAgIDxWZXJ0aWNhbFNwbGl0dGVyRGl2IC8+XG4gICAgICAgIDxDb2x1bW5EaXY+XG4gICAgICAgICAgPFJvd3NEaXY+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgQ29udGVudFxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPENvbnRlbnRUZXh0YXJlYSBvbktleVVwPXt0aGlzLmtleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBUb2tlbnNcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxUb2tlbnNUZXh0YXJlYSAvPlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIFBhcnNlIHRyZWVcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxQYXJzZVRyZWVUZXh0YXJlYSAvPlxuICAgICAgICAgIDwvUm93c0Rpdj5cbiAgICAgICAgPC9Db2x1bW5EaXY+XG4gICAgICA8L0NvbHVtbnNEaXY+XG5cbiAgICApO1xuICB9XG5cbiAgaW5pdGlhbGlzZSgpIHtcbiAgICB0aGlzLmFzc2lnbkNvbnRleHQoKTtcblxuICAgIGNvbnN0IHsgaW5pdGlhbENvbnRlbnQsIGluaXRpYWxSdWxlTmFtZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBjb250ZW50ID0gaW5pdGlhbENvbnRlbnQsIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lID0gaW5pdGlhbFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgICBsZXhpY2FsRW50cmllcyA9IGVudHJpZXM7IC8vL1xuXG4gICAgdGhpcy5zZXRCTkYoYm5mKTtcblxuICAgIHRoaXMuc2V0Q29udGVudChjb250ZW50KTtcblxuICAgIHRoaXMuc2V0UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgdGhpcy5zZXRMZXhpY2FsRW50cmllcyhsZXhpY2FsRW50cmllcyk7XG5cbiAgICB0aGlzLmtleVVwSGFuZGxlcigpO1xuICB9XG5cbiAgc3RhdGljIGluaXRpYWxSdWxlTmFtZSA9IFwidmFyaWFibGVBc3NpZ25tZW50XCI7XG5cbiAgc3RhdGljIGluaXRpYWxDb250ZW50ID0gYEJvb2xlYW4gdmFyaWFibGVCb3VuZCA9IGlzVmFyaWFibGVCb3VuZCh0ZXJtTm9kZSwgc3RhdGVtZW50Tm9kZSk7YDtcblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJ2aWV3XCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFZpZXcpYFxuXG4gIHBhZGRpbmc6IDFyZW07XG4gXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgXCJqdXh0YXBvc2VcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgQm9keSB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBWaWV3IGZyb20gXCIuL2V4YW1wbGUvdmlld1wiO1xuXG5jb25zdCB7IHJlbmRlclN0eWxlcyB9ID0gd2l0aFN0eWxlO1xuXG5yZW5kZXJTdHlsZXMoKTtcblxuY29uc3QgYm9keSA9IG5ldyBC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
