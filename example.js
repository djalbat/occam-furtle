(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
  var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/easy/lib/offset.js
  var require_offset = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Offset;
      }
    });
    var Offset = class {
      constructor(top, left) {
        this.top = top;
        this.left = left;
      }
      getTop() {
        return this.top;
      }
      getLeft() {
        return this.left;
      }
      static fromDOMElement(domElement) {
        const {offsetTop, offsetLeft} = domElement, top = offsetTop, left = offsetLeft, offset = new Offset(top, left);
        return offset;
      }
    };
  });

  // node_modules/easy/lib/bounds.js
  var require_bounds = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Bounds;
      }
    });
    var Bounds = class {
      constructor(top, left, right, bottom) {
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
      }
      getTop() {
        return this.top;
      }
      getLeft() {
        return this.left;
      }
      getRight() {
        return this.right;
      }
      getBottom() {
        return this.bottom;
      }
      getWidth() {
        const width = this.right - this.left;
        return width;
      }
      getHeight() {
        const height = this.bottom - this.top;
        return height;
      }
      setTop(top) {
        this.top = top;
      }
      setLeft(left) {
        this.left = left;
      }
      setRight(right) {
        this.right = right;
      }
      setBottom(bottom) {
        this.bottom = bottom;
      }
      areOverlapping(bounds) {
        const bottom = bounds.getBottom(), right = bounds.getRight(), left = bounds.getLeft(), top = bounds.getTop(), overlapping = this.top < bottom && this.left < right && this.right > left && this.bottom > top;
        return overlapping;
      }
      areOverlappingByTopAndLeft(top, left) {
        const overlapping = this.top <= top && this.left <= left && this.right > left && this.bottom > top;
        return overlapping;
      }
      static fromDOMElement(domElement) {
        const {pageXOffset, pageYOffset} = window, boundingClientRect = domElement.getBoundingClientRect(), windowScrollTop = pageYOffset, windowScrollLeft = pageXOffset, top = boundingClientRect.top + windowScrollTop, left = boundingClientRect.left + windowScrollLeft, right = boundingClientRect.right + windowScrollLeft, bottom = boundingClientRect.bottom + windowScrollTop, bounds = new Bounds(top, left, right, bottom);
        return bounds;
      }
      static fromTopLeftWidthAndHeight(top, left, width, height) {
        const bottom = top + height, right = left + width, bounds = new Bounds(top, left, right, bottom);
        return bounds;
      }
    };
  });

  // node_modules/easy/lib/utilities/array.js
  var require_array = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get augment() {
        return augment;
      },
      get first() {
        return first2;
      },
      get flatten() {
        return flatten;
      },
      get guarantee() {
        return guarantee;
      },
      get push() {
        return push;
      }
    });
    function first2(array) {
      return array[0];
    }
    function push(array1, array2) {
      Array.prototype.push.apply(array1, array2);
    }
    function augment(array1, array2, test) {
      array1 = [
        ...array1
      ];
      array2.forEach((element, index) => {
        const passed = test(element, index);
        if (passed) {
          array1.push(element);
        }
      });
      return array1;
    }
    function flatten(array) {
      return array.reduce((array2, element) => {
        array2 = array2.concat(element);
        return array2;
      }, []);
    }
    function guarantee(arrayOrElement) {
      arrayOrElement = arrayOrElement || [];
      return arrayOrElement instanceof Array ? arrayOrElement : [
        arrayOrElement
      ];
    }
  });

  // node_modules/easy/lib/constants.js
  var require_constants = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BLOCK() {
        return BLOCK;
      },
      get BODY() {
        return BODY;
      },
      get BOOLEAN() {
        return BOOLEAN;
      },
      get CLASS() {
        return CLASS;
      },
      get CLASS_NAME() {
        return CLASS_NAME;
      },
      get DEFAULT_PROPERTIES() {
        return DEFAULT_PROPERTIES;
      },
      get DISABLED() {
        return DISABLED;
      },
      get DISPLAY() {
        return DISPLAY;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get FOR() {
        return FOR;
      },
      get FUNCTION() {
        return FUNCTION;
      },
      get HEIGHT() {
        return HEIGHT;
      },
      get HTML_FOR() {
        return HTML_FOR;
      },
      get IGNORED_PROPERTIES() {
        return IGNORED_PROPERTIES;
      },
      get NONE() {
        return NONE;
      },
      get OBJECT() {
        return OBJECT;
      },
      get SPACE() {
        return SPACE;
      },
      get STRING() {
        return STRING;
      },
      get SVG_NAMESPACE_URI() {
        return SVG_NAMESPACE_URI;
      },
      get UNDEFINED() {
        return UNDEFINED;
      },
      get WIDTH() {
        return WIDTH;
      },
      get WILDCARD() {
        return WILDCARD;
      }
    });
    var FOR = "for";
    var BODY = "body";
    var NONE = "none";
    var SPACE = " ";
    var CLASS = "class";
    var WIDTH = "width";
    var BLOCK = "block";
    var HEIGHT = "height";
    var OBJECT = "object";
    var STRING = "string";
    var DISPLAY = "display";
    var BOOLEAN = "boolean";
    var DISABLED = "disabled";
    var FUNCTION = "function";
    var WILDCARD = "*";
    var HTML_FOR = "htmlFor";
    var UNDEFINED = "undefined";
    var CLASS_NAME = "className";
    var EMPTY_STRING = "";
    var SVG_NAMESPACE_URI = "http://www.w3.org/2000/svg";
    var DEFAULT_PROPERTIES = "defaultProperties";
    var IGNORED_PROPERTIES = "ignoredProperties";
  });

  // node_modules/easy/lib/utilities/object.js
  var require_object = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combine() {
        return combine;
      },
      get prune() {
        return prune;
      }
    });
    var _constants = require_constants();
    function combine(target, source = {}) {
      target = {
        ...target
      };
      const names = Object.keys(source);
      names.forEach((name) => {
        const targetValue = target[name], sourceValue = source[name], targetHasOwnProperty = target.hasOwnProperty(name);
        target[name] = targetHasOwnProperty ? combineValues(targetValue, sourceValue) : sourceValue;
      });
      return target;
    }
    function prune(target, names = []) {
      target = {
        ...target
      };
      names.forEach((name) => {
        const targetHasOwnProperty = target.hasOwnProperty(name);
        if (targetHasOwnProperty) {
          delete target[name];
        }
      });
      return target;
    }
    function combineValues(targetValue, sourceValue) {
      const targetValueBoolean = isValueBoolean(targetValue), sourceValueBoolean = isValueBoolean(sourceValue), combinedValue = targetValueBoolean && sourceValueBoolean ? targetValue : `${targetValue} ${sourceValue}`;
      return combinedValue;
    }
    function isValueBoolean(value) {
      const valueBoolean = typeof value === _constants.BOOLEAN;
      return valueBoolean;
    }
  });

  // node_modules/easy/lib/utilities/string.js
  var require_string = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "camelCaseToSnakeCase", {
      enumerable: true,
      get: function() {
        return camelCaseToSnakeCase;
      }
    });
    function camelCaseToSnakeCase(string) {
      return string.replace(/([A-Z]+)/g, (match, characters) => {
        const upperCaseCharacters = characters.toLowerCase(), snakeCaseCharacters = `-${upperCaseCharacters}`;
        return snakeCaseCharacters;
      });
    }
  });

  // node_modules/easy/lib/utilities/name.js
  var require_name = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isHTMLAttributeName() {
        return isHTMLAttributeName;
      },
      get isSVGAttributeName() {
        return isSVGAttributeName;
      },
      get isSVGTagName() {
        return isSVGTagName;
      }
    });
    function isSVGTagName(tagName) {
      return svgTagNames.includes(tagName);
    }
    function isSVGAttributeName(attributeName) {
      return svgAttributeNames.includes(attributeName);
    }
    function isHTMLAttributeName(attributeName) {
      return htmlAttributeNames.includes(attributeName);
    }
    var svgTagNames = [
      "altGlyph",
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "animation",
      "audio",
      "circle",
      "clipPath",
      "color-profile",
      "cursor",
      "defs",
      "desc",
      "discard",
      "ellipse",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "filter",
      "font",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-uri",
      "foreignObject",
      "g",
      "glyph",
      "glyphRef",
      "handler",
      "hatch",
      "hatchpath",
      "hkern",
      "image",
      "line",
      "linearGradient",
      "listener",
      "marker",
      "mask",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "metadata",
      "missing-glyph",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "prefetch",
      "radialGradient",
      "rect",
      "script",
      "set",
      "solidcolor",
      "stop",
      "style",
      "svg",
      "switch",
      "symbol",
      "tbreak",
      "text",
      "textArea",
      "textPath",
      "title",
      "tref",
      "tspan",
      "unknown",
      "use",
      "video",
      "view",
      "vkern"
    ];
    var svgAttributeNames = [
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "alphabetic",
      "amplitude",
      "arabic-form",
      "ascent",
      "attributeName",
      "attributeType",
      "azimuth",
      "bandwidth",
      "baseFrequency",
      "baseProfile",
      "baseline-shift",
      "bbox",
      "begin",
      "bias",
      "by",
      "calcMode",
      "cap-height",
      "clip",
      "className",
      "clip-path",
      "clip-rule",
      "clipPathUnits",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "contentScriptType",
      "contentStyleType",
      "crossorigin",
      "cursor",
      "cx",
      "cy",
      "d",
      "defaultAction",
      "descent",
      "diffuseConstant",
      "direction",
      "display",
      "divisor",
      "dominant-baseline",
      "download",
      "dur",
      "dx",
      "dy",
      "edgeMode",
      "editable",
      "elevation",
      "enable-background",
      "end",
      "event",
      "exponent",
      "externalResourcesRequired",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterRes",
      "filterUnits",
      "flood-color",
      "flood-opacity",
      "focusHighlight",
      "focusable",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "format",
      "fr",
      "from",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "handler",
      "hanging",
      "hatchContentUnits",
      "hatchUnits",
      "height",
      "horiz-adv-x",
      "horiz-origin-x",
      "horiz-origin-y",
      "href",
      "hreflang",
      "id",
      "ideographic",
      "image-rendering",
      "in",
      "in2",
      "initialVisibility",
      "intercept",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kernelMatrix",
      "kernelUnitLength",
      "kerning",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "letter-spacing",
      "lighting-color",
      "limitingConeAngle",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "mask",
      "maskContentUnits",
      "maskUnits",
      "mathematical",
      "max",
      "media",
      "mediaCharacterEncoding",
      "mediaContentEncodings",
      "mediaSize",
      "mediaTime",
      "method",
      "min",
      "mode",
      "name",
      "nav-down",
      "nav-down-left",
      "nav-down-right",
      "nav-left",
      "nav-next",
      "nav-prev",
      "nav-right",
      "nav-up",
      "nav-up-left",
      "nav-up-right",
      "numOctaves",
      "observer",
      "offset",
      "opacity",
      "operator",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "overlay",
      "overline-position",
      "overline-thickness",
      "panose-1",
      "path",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "phase",
      "pitch",
      "playbackOrder",
      "playbackorder",
      "pointer-events",
      "points",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "propagate",
      "r",
      "radius",
      "refX",
      "refY",
      "rendering-intent",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "requiredFonts",
      "requiredFormats",
      "restart",
      "result",
      "rotate",
      "rx",
      "ry",
      "scale",
      "seed",
      "shape-rendering",
      "side",
      "slope",
      "snapshotTime",
      "spacing",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "src",
      "startOffset",
      "stdDeviation",
      "stemh",
      "stemv",
      "stitchTiles",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "string",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "style",
      "surfaceScale",
      "syncBehavior",
      "syncBehaviorDefault",
      "syncMaster",
      "syncTolerance",
      "syncToleranceDefault",
      "systemLanguage",
      "tableValues",
      "target",
      "targetX",
      "targetY",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textLength",
      "timelineBegin",
      "timelinebegin",
      "title",
      "to",
      "transform",
      "transformBehavior",
      "type",
      "u1",
      "u2",
      "underline-position",
      "underline-thickness",
      "unicode",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "values",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "viewBox",
      "viewTarget",
      "visibility",
      "width",
      "widths",
      "word-spacing",
      "writing-mode",
      "x",
      "x-height",
      "x1",
      "x2",
      "xChannelSelector",
      "y",
      "y1",
      "y2",
      "yChannelSelector",
      "z",
      "zoomAndPan"
    ];
    var htmlAttributeNames = [
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "allow",
      "allowFullScreen",
      "allowTransparency",
      "alt",
      "async",
      "autoComplete",
      "autoFocus",
      "autoPlay",
      "capture",
      "cellPadding",
      "cellSpacing",
      "challenge",
      "charSet",
      "checked",
      "cite",
      "classID",
      "className",
      "colSpan",
      "cols",
      "content",
      "contentEditable",
      "contextMenu",
      "controls",
      "coords",
      "crossOrigin",
      "data",
      "dateTime",
      "default",
      "defer",
      "dir",
      "disabled",
      "download",
      "draggable",
      "encType",
      "form",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "frameBorder",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hrefLang",
      "htmlFor",
      "httpEquiv",
      "icon",
      "id",
      "inputMode",
      "integrity",
      "is",
      "keyParams",
      "keyType",
      "kind",
      "label",
      "lang",
      "list",
      "loop",
      "low",
      "manifest",
      "marginHeight",
      "marginWidth",
      "max",
      "maxLength",
      "media",
      "mediaGroup",
      "method",
      "min",
      "minLength",
      "multiple",
      "muted",
      "name",
      "noValidate",
      "nonce",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "poster",
      "preload",
      "profile",
      "radioGroup",
      "readOnly",
      "rel",
      "required",
      "reversed",
      "role",
      "rowSpan",
      "rows",
      "sandbox",
      "scope",
      "scoped",
      "scrolling",
      "seamless",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "spellCheck",
      "src",
      "srcDoc",
      "srcLang",
      "srcSet",
      "start",
      "step",
      "style",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "value",
      "width",
      "wmode",
      "wrap"
    ];
  });

  // node_modules/easy/lib/utilities/element.js
  var require_element = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get constructElement() {
        return constructElement;
      },
      get default() {
        return _default;
      },
      get destroyElement() {
        return destroyElement;
      },
      get mountElement() {
        return mountElement;
      },
      get unmountElement() {
        return unmountElement;
      }
    });
    function constructElement(element, domElement) {
      element.domElement = domElement;
      domElement.__element__ = element;
    }
    function destroyElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.forEach((element2) => {
        const domElement = element2.getDOMElement();
        delete element2.domElement;
        delete domElement.__element__;
      });
    }
    function mountElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.reverse();
      elements.forEach((element2) => {
        element2.didMount && element2.didMount();
      });
    }
    function unmountElement(element) {
      const descendantElements = element.getDescendantElements(), elements = [
        element,
        ...descendantElements
      ];
      elements.forEach((element2) => {
        element2.willUnmount && element2.willUnmount();
      });
    }
    var _default = {
      constructElement,
      destroyElement,
      mountElement,
      unmountElement
    };
  });

  // node_modules/easy/lib/utilities/dom.js
  var require_dom = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ascendantDOMNodesFromDOMNode() {
        return ascendantDOMNodesFromDOMNode;
      },
      get descendantDOMNodesFromDOMNode() {
        return descendantDOMNodesFromDOMNode;
      },
      get domNodeMatchesSelector() {
        return domNodeMatchesSelector;
      },
      get elementsFromDOMElements() {
        return elementsFromDOMElements;
      },
      get filterDOMNodes() {
        return filterDOMNodes;
      },
      get filterDOMNodesBySelector() {
        return filterDOMNodesBySelector;
      }
    });
    var _array = require_array();
    var _constants = require_constants();
    function elementsFromDOMElements(domElements) {
      const domElementsWithElements = filterDOMNodes(domElements, (domElement) => {
        if (domElement.__element__) {
          return true;
        }
      }), elements = domElementsWithElements.map((domElement) => {
        const element = domElement.__element__;
        return element;
      });
      return elements;
    }
    function ascendantDOMNodesFromDOMNode(domNode, height, ascendantDOMNodes = []) {
      if (height > 0) {
        const parentDOMNode = domNode.parentElement;
        if (parentDOMNode !== null) {
          ascendantDOMNodes.push(parentDOMNode);
          height--;
          ascendantDOMNodesFromDOMNode(parentDOMNode, height, ascendantDOMNodes);
        }
      }
      return ascendantDOMNodes;
    }
    function descendantDOMNodesFromDOMNode(domNode, depth, descendantDOMNodes = []) {
      if (depth > 0) {
        const childDOMNodes = domNode.childNodes;
        (0, _array.push)(descendantDOMNodes, childDOMNodes);
        depth--;
        childDOMNodes.forEach((childDOMNode) => {
          descendantDOMNodesFromDOMNode(childDOMNode, depth, descendantDOMNodes);
        });
      }
      return descendantDOMNodes;
    }
    function filterDOMNodesBySelector(domNodes, selector) {
      const filteredDOMNodes = filterDOMNodes(domNodes, (domNode) => {
        if (domNodeMatchesSelector(domNode, selector)) {
          return true;
        }
      });
      return filteredDOMNodes;
    }
    function domNodeMatchesSelector(domNode, selector) {
      const domNodeType = domNode.nodeType;
      switch (domNodeType) {
        case Node.ELEMENT_NODE: {
          const domElement = domNode;
          return domElement.matches(selector);
        }
        case Node.TEXT_NODE: {
          if (selector === _constants.WILDCARD) {
            return true;
          }
        }
      }
      return false;
    }
    function filterDOMNodes(domNodes, test) {
      const filteredDOMNodes = [], domNodesLength = domNodes.length;
      for (let index = 0; index < domNodesLength; index++) {
        const domNode = domNodes[index], result = test(domNode);
        if (result) {
          filteredDOMNodes.push(domNode);
        }
      }
      return filteredDOMNodes;
    }
  });

  // node_modules/easy/lib/mixins/element.js
  var require_element2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get getAscendantElements() {
        return getAscendantElements;
      },
      get getChildElements() {
        return getChildElements;
      },
      get getDescendantElements() {
        return getDescendantElements;
      },
      get getNextSiblingElement() {
        return getNextSiblingElement;
      },
      get getParentElement() {
        return getParentElement;
      },
      get getPreviousSiblingElement() {
        return getPreviousSiblingElement;
      }
    });
    var _array = require_array();
    var _constants = require_constants();
    var _dom = require_dom();
    function getParentElement(selector = _constants.WILDCARD) {
      let parentElement = null;
      const parentDOMElement = this.domElement.parentElement;
      if (parentDOMElement !== null) {
        if (parentDOMElement.matches(selector)) {
          const parentDOMElements = [
            parentDOMElement
          ], parentElements = (0, _dom.elementsFromDOMElements)(parentDOMElements), firstParentElement = (0, _array.first)(parentElements);
          parentElement = firstParentElement || null;
        }
      }
      return parentElement;
    }
    function getChildElements(selector = _constants.WILDCARD) {
      const childDOMNodes = this.domElement.childNodes, childDOMElements = (0, _dom.filterDOMNodesBySelector)(childDOMNodes, selector), childElements = (0, _dom.elementsFromDOMElements)(childDOMElements);
      return childElements;
    }
    function getAscendantElements(selector = _constants.WILDCARD, maximumHeight = Infinity) {
      const height = maximumHeight, domNode = this.domElement, ascendantDOMNodes = (0, _dom.ascendantDOMNodesFromDOMNode)(domNode, height), ascendantDOMElements = (0, _dom.filterDOMNodesBySelector)(ascendantDOMNodes, selector), ascendantElements = (0, _dom.elementsFromDOMElements)(ascendantDOMElements);
      return ascendantElements;
    }
    function getDescendantElements(selector = _constants.WILDCARD, maximumDepth = Infinity) {
      const depth = maximumDepth, domNode = this.domElement, descendantDOMNodes = (0, _dom.descendantDOMNodesFromDOMNode)(domNode, depth), descendantDOMElements = (0, _dom.filterDOMNodesBySelector)(descendantDOMNodes, selector), descendantElements = (0, _dom.elementsFromDOMElements)(descendantDOMElements);
      return descendantElements;
    }
    function getNextSiblingElement(selector = _constants.WILDCARD) {
      let nextSiblingElement = null;
      const nextSiblingDOMNode = this.domElement.nextSibling;
      if (nextSiblingDOMNode !== null && (0, _dom.domNodeMatchesSelector)(nextSiblingDOMNode, selector)) {
        nextSiblingElement = nextSiblingDOMNode.__element__ || null;
      }
      return nextSiblingElement;
    }
    function getPreviousSiblingElement(selector = _constants.WILDCARD) {
      let previousSiblingElement = null;
      const previousSiblingDOMNode = this.domElement.previousSibling;
      if (previousSiblingDOMNode !== null && (0, _dom.domNodeMatchesSelector)(previousSiblingDOMNode, selector)) {
        previousSiblingElement = previousSiblingDOMNode.__element__ || null;
      }
      return previousSiblingElement;
    }
    var elementMixins = {
      getParentElement,
      getChildElements,
      getAscendantElements,
      getDescendantElements,
      getNextSiblingElement,
      getPreviousSiblingElement
    };
    var _default = elementMixins;
  });

  // node_modules/easy/lib/textElement.js
  var require_textElement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TextElement;
      }
    });
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _element = require_element();
    var _element1 = require_element2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TextElement = class {
      constructor(text) {
        const element = this, domElement = document.createTextNode(text);
        (0, _element.constructElement)(element, domElement);
      }
      getDOMElement() {
        return this.domElement;
      }
      getOffset() {
        const offset = _offset.default.fromDOMElement(this.domElement);
        return offset;
      }
      getBounds() {
        const bounds = _bounds.default.fromDOMElement(this.domElement);
        return bounds;
      }
      getWidth() {
        return this.domElement.offsetWidth;
      }
      getHeight() {
        return this.domElement.offsetHeight;
      }
      getText() {
        const nodeValue = this.domElement.nodeValue, text = nodeValue;
        return text;
      }
      setText(text) {
        const nodeValue = text;
        this.domElement.nodeValue = nodeValue;
      }
      prependTo(parentElement) {
        parentElement.prepend(this);
      }
      appendTo(parentElement) {
        parentElement.append(this);
      }
      addTo(parentElement) {
        parentElement.add(this);
      }
      removeFrom(parentElement) {
        parentElement.remove(this);
      }
      insertBefore(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, siblingDOMElement);
      }
      insertAfter(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, siblingDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, siblingDOMElement.nextSibling);
      }
      remove() {
        this.domElement.remove();
      }
      destroy() {
        const element = this;
        (0, _element.destroyElement)(element);
      }
    };
    Object.assign(TextElement.prototype, {
      getParentElement: _element1.getParentElement,
      getAscendantElements: _element1.getAscendantElements,
      getNextSiblingElement: _element1.getNextSiblingElement,
      getPreviousSiblingElement: _element1.getPreviousSiblingElement
    });
  });

  // node_modules/easy/lib/utilities/elements.js
  var require_elements = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get removeFalseyElements() {
        return removeFalseyElements;
      },
      get replaceStringsWithTextElements() {
        return replaceStringsWithTextElements;
      }
    });
    var _textElement = /* @__PURE__ */ _interop_require_default(require_textElement());
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function removeFalseyElements(elements) {
      elements = elements.reduce((elements2, element) => {
        if (element) {
          elements2.push(element);
        }
        return elements2;
      }, []);
      return elements;
    }
    function replaceStringsWithTextElements(elements) {
      elements = elements.map((element) => {
        if (typeof element === _constants.STRING) {
          const text = element, textElement = new _textElement.default(text);
          element = textElement;
        }
        return element;
      });
      return elements;
    }
  });

  // node_modules/easy/lib/eventTypes.js
  var require_eventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AUXCLICK_EVENT_TYPE() {
        return AUXCLICK_EVENT_TYPE;
      },
      get BLUR_EVENT_TYPE() {
        return BLUR_EVENT_TYPE;
      },
      get CHANGE_EVENT_TYPE() {
        return CHANGE_EVENT_TYPE;
      },
      get CLICK_EVENT_TYPE() {
        return CLICK_EVENT_TYPE;
      },
      get CONTEXTMENU_EVENT_TYPE() {
        return CONTEXTMENU_EVENT_TYPE;
      },
      get COPY_EVENT_TYPE() {
        return COPY_EVENT_TYPE;
      },
      get CUT_EVENT_TYPE() {
        return CUT_EVENT_TYPE;
      },
      get DBLCLICK_EVENT_TYPE() {
        return DBLCLICK_EVENT_TYPE;
      },
      get ERROR_EVENT_TYPE() {
        return ERROR_EVENT_TYPE;
      },
      get FOCUS_EVENT_TYPE() {
        return FOCUS_EVENT_TYPE;
      },
      get FULLSCREENCHANGE_EVENT_TYPE() {
        return FULLSCREENCHANGE_EVENT_TYPE;
      },
      get INPUT_EVENT_TYPE() {
        return INPUT_EVENT_TYPE;
      },
      get KEYDOWN_EVENT_TYPE() {
        return KEYDOWN_EVENT_TYPE;
      },
      get KEYUP_EVENT_TYPE() {
        return KEYUP_EVENT_TYPE;
      },
      get MOUSEDOWN_EVENT_TYPE() {
        return MOUSEDOWN_EVENT_TYPE;
      },
      get MOUSEMOVE_EVENT_TYPE() {
        return MOUSEMOVE_EVENT_TYPE;
      },
      get MOUSEOUT_EVENT_TYPE() {
        return MOUSEOUT_EVENT_TYPE;
      },
      get MOUSEOVER_EVENT_TYPE() {
        return MOUSEOVER_EVENT_TYPE;
      },
      get MOUSEUP_EVENT_TYPE() {
        return MOUSEUP_EVENT_TYPE;
      },
      get PASTE_EVENT_TYPE() {
        return PASTE_EVENT_TYPE;
      },
      get RESIZE_EVENT_TYPE() {
        return RESIZE_EVENT_TYPE;
      },
      get SCROLL_EVENT_TYPE() {
        return SCROLL_EVENT_TYPE;
      },
      get SELECTIONCHANGE_EVENT_TYPE() {
        return SELECTIONCHANGE_EVENT_TYPE;
      },
      get SELECT_EVENT_TYPE() {
        return SELECT_EVENT_TYPE;
      },
      get TOUCHEND_EVENT_TYPE() {
        return TOUCHEND_EVENT_TYPE;
      },
      get TOUCHMOVE_EVENT_TYPE() {
        return TOUCHMOVE_EVENT_TYPE;
      },
      get TOUCHSTART_EVENT_TYPE() {
        return TOUCHSTART_EVENT_TYPE;
      },
      get UNHANDLEDREJECTION_EVENT_TYPE() {
        return UNHANDLEDREJECTION_EVENT_TYPE;
      },
      get WHEEL_EVENT_TYPE() {
        return WHEEL_EVENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var CUT_EVENT_TYPE = "cut";
    var COPY_EVENT_TYPE = "copy";
    var BLUR_EVENT_TYPE = "blur";
    var ERROR_EVENT_TYPE = "error";
    var PASTE_EVENT_TYPE = "paste";
    var WHEEL_EVENT_TYPE = "wheel";
    var INPUT_EVENT_TYPE = "input";
    var FOCUS_EVENT_TYPE = "focus";
    var CLICK_EVENT_TYPE = "click";
    var KEYUP_EVENT_TYPE = "keyup";
    var SELECT_EVENT_TYPE = "select";
    var CHANGE_EVENT_TYPE = "change";
    var RESIZE_EVENT_TYPE = "resize";
    var SCROLL_EVENT_TYPE = "scroll";
    var KEYDOWN_EVENT_TYPE = "keydown";
    var MOUSEUP_EVENT_TYPE = "mouseup";
    var AUXCLICK_EVENT_TYPE = "auxclick";
    var MOUSEOUT_EVENT_TYPE = "mouseout";
    var DBLCLICK_EVENT_TYPE = "dblclick";
    var TOUCHEND_EVENT_TYPE = "touchend";
    var TOUCHMOVE_EVENT_TYPE = "touchmove";
    var MOUSEOVER_EVENT_TYPE = "mouseover";
    var MOUSEDOWN_EVENT_TYPE = "mousedown";
    var MOUSEMOVE_EVENT_TYPE = "mousemove";
    var TOUCHSTART_EVENT_TYPE = "touchstart";
    var CONTEXTMENU_EVENT_TYPE = "contextmenu";
    var SELECTIONCHANGE_EVENT_TYPE = "selectionchange";
    var FULLSCREENCHANGE_EVENT_TYPE = "fullscreenchange";
    var UNHANDLEDREJECTION_EVENT_TYPE = "unhandledrejection";
    var _default = {
      CUT_EVENT_TYPE,
      COPY_EVENT_TYPE,
      BLUR_EVENT_TYPE,
      ERROR_EVENT_TYPE,
      PASTE_EVENT_TYPE,
      WHEEL_EVENT_TYPE,
      INPUT_EVENT_TYPE,
      FOCUS_EVENT_TYPE,
      CLICK_EVENT_TYPE,
      KEYUP_EVENT_TYPE,
      SELECT_EVENT_TYPE,
      CHANGE_EVENT_TYPE,
      RESIZE_EVENT_TYPE,
      SCROLL_EVENT_TYPE,
      KEYDOWN_EVENT_TYPE,
      MOUSEUP_EVENT_TYPE,
      AUXCLICK_EVENT_TYPE,
      MOUSEOUT_EVENT_TYPE,
      DBLCLICK_EVENT_TYPE,
      TOUCHEND_EVENT_TYPE,
      TOUCHMOVE_EVENT_TYPE,
      MOUSEOVER_EVENT_TYPE,
      MOUSEDOWN_EVENT_TYPE,
      MOUSEMOVE_EVENT_TYPE,
      TOUCHSTART_EVENT_TYPE,
      CONTEXTMENU_EVENT_TYPE,
      SELECTIONCHANGE_EVENT_TYPE,
      FULLSCREENCHANGE_EVENT_TYPE,
      UNHANDLEDREJECTION_EVENT_TYPE
    };
  });

  // node_modules/easy/lib/mixins/jsx.js
  var require_jsx = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _array = require_array();
    var _object = require_object();
    var _string = require_string();
    var _name = require_name();
    var _elements = require_elements();
    var _eventTypes = require_eventTypes();
    var _constants = require_constants();
    var DOUBLE_CLICK_EVENT_TYPE = "doubleclick";
    var SELECTION_CHANGE_EVENT_TYPE = "selectionChange";
    var FULL_SCREEN_CHANGE_EVENT_TYPE = "fullScreenChange";
    function applyProperties(properties, defaultProperties, ignoredProperties) {
      this.properties = (0, _object.combine)(properties, defaultProperties);
      properties = (0, _object.prune)(this.properties, ignoredProperties);
      const namespaceURI = this.domElement.namespaceURI, svg = namespaceURI === _constants.SVG_NAMESPACE_URI, propertiesKeys = Object.keys(properties), names = propertiesKeys;
      names.forEach((name) => {
        const value = properties[name], nameHandlerName = isNameHandlerName(name), nameCustomHandlerName = isNameCustomHandlerName(name);
        if (false) {
        } else if (nameHandlerName) {
          addHandler(this, name, value);
        } else if (nameCustomHandlerName) {
          addCustomHandler(this, name, value);
        } else {
          const nameAttributeName = isNameAttributeName(name, svg);
          if (nameAttributeName) {
            addAttribute(this, name, value);
          }
        }
      });
      const childElements = childElementsFromElement(this) || properties.childElements, context2 = {};
      childElements.forEach((childElement) => {
        updateContext(childElement, context2);
        this.add(childElement);
      });
      this.context = context2;
    }
    function getProperties() {
      return this.properties;
    }
    function getContext() {
      return this.context;
    }
    function assignContext(names) {
      if (names === void 0) {
        names = Object.keys(this.context);
      }
      names.forEach((name) => {
        const value = this.context[name], propertyName = name, descriptor = {
          value
        };
        Object.defineProperty(this, propertyName, descriptor);
        delete this.context[name];
      });
    }
    var jsxMixins = {
      applyProperties,
      getProperties,
      getContext,
      assignContext
    };
    var _default = jsxMixins;
    function childElementsFromElement(element) {
      let childElements = null;
      if (typeof element.childElements === _constants.FUNCTION) {
        childElements = element.childElements.call(element);
        childElements = (0, _array.guarantee)(childElements);
        childElements = (0, _elements.removeFalseyElements)(childElements);
        childElements = (0, _elements.replaceStringsWithTextElements)(childElements);
      }
      return childElements;
    }
    function updateContext(childElement, context2) {
      const parentContext = typeof childElement.parentContext === _constants.FUNCTION ? childElement.parentContext() : childElement.context;
      Object.assign(context2, parentContext);
    }
    function addHandler(element, name, value) {
      let eventType = name.substring(2).toLowerCase();
      switch (eventType) {
        case DOUBLE_CLICK_EVENT_TYPE: {
          eventType = _eventTypes.DBLCLICK_EVENT_TYPE;
          break;
        }
        case SELECTION_CHANGE_EVENT_TYPE: {
          eventType = _eventTypes.SELECTIONCHANGE_EVENT_TYPE;
          break;
        }
        case FULL_SCREEN_CHANGE_EVENT_TYPE: {
          eventType = _eventTypes.FULLSCREENCHANGE_EVENT_TYPE;
          break;
        }
      }
      const handler = value;
      element.onEvent(eventType, handler);
    }
    function addCustomHandler(element, name, value) {
      const customEventType = (0, _string.camelCaseToSnakeCase)(name).replace(/on-custom-/, ""), customHandler = value;
      element.onCustomEvent(customEventType, customHandler);
    }
    function addAttribute(element, name, value) {
      if (name === _constants.CLASS_NAME) {
        name = _constants.CLASS;
      }
      if (name === _constants.HTML_FOR) {
        name = _constants.FOR;
      }
      if (typeof value === _constants.OBJECT) {
        const keys = Object.keys(value);
        keys.forEach((key) => {
          element.domElement[name][key] = value[key];
        });
      } else if (typeof value === _constants.BOOLEAN) {
        if (value) {
          value = name;
          element.addAttribute(name, value);
        }
      } else {
        element.addAttribute(name, value);
      }
    }
    function isNameHandlerName(name) {
      const nameHandlerName = /^on(?!Custom)/.test(name);
      return nameHandlerName;
    }
    function isNameAttributeName(name, svg) {
      const nameAttributeName = svg ? (0, _name.isSVGAttributeName)(name) : (0, _name.isHTMLAttributeName)(name);
      return nameAttributeName;
    }
    function isNameCustomHandlerName(name) {
      const nameCustomHandlerName = /^onCustom/.test(name);
      return nameCustomHandlerName;
    }
  });

  // node_modules/easy/lib/mixins/key.js
  var require_key = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onKeyUp(keyUpHandler, element) {
      this.onEvent(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function offKeyUp(keyUpHandler, element) {
      this.offEvent(_eventTypes.KEYUP_EVENT_TYPE, keyUpHandler, element);
    }
    function onKeyDown(keyDownHandler, element) {
      this.onEvent(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    function offKeyDown(keyDownHandler, element) {
      this.offEvent(_eventTypes.KEYDOWN_EVENT_TYPE, keyDownHandler, element);
    }
    var keyMixins = {
      onKeyUp,
      offKeyUp,
      onKeyDown,
      offKeyDown
    };
    var _default = keyMixins;
  });

  // node_modules/easy/lib/mixins/state.js
  var require_state = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    function getState() {
      return this.state;
    }
    function setState(state) {
      this.state = state;
    }
    function updateState(state) {
      this.state === void 0 ? this.state = state : Object.assign(this.state, state);
    }
    var stateMixins = {
      getState,
      setState,
      updateState
    };
    var _default = stateMixins;
  });

  // node_modules/easy/lib/mixins/event.js
  var require_event = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    function onEvent(eventTypes, handler, element = this) {
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach((eventType) => {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          const resizeEventListeners = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            this.resizeObserver = new ResizeObserver((entries) => {
              const resizeEventListeners2 = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE);
              resizeEventListeners2.forEach((resizeEventListener) => {
                const event = null;
                resizeEventListener(event);
              });
            });
            this.resizeObserver.observe(this.domElement);
          }
          this.addEventListener(eventType, handler, element);
        } else {
          const eventListener = this.addEventListener(eventType, handler, element);
          this.domElement.addEventListener(eventType, eventListener);
        }
      });
    }
    function offEvent(eventTypes, handler, element = this) {
      eventTypes = eventTypes.split(_constants.SPACE);
      eventTypes.forEach((eventType) => {
        if (eventType === _eventTypes.RESIZE_EVENT_TYPE) {
          this.removeEventListener(eventType, handler, element);
          const resizeEventListeners = this.findEventListeners(_eventTypes.RESIZE_EVENT_TYPE), resizeEventListenersLength = resizeEventListeners.length;
          if (resizeEventListenersLength === 0) {
            this.resizeObserver.unobserve(this.domElement);
            delete this.resizeObserver;
          }
        } else {
          const eventListener = this.removeEventListener(eventType, handler, element);
          this.domElement.removeEventListener(eventType, eventListener);
        }
      });
    }
    function addEventListener(eventType, handler, element) {
      const eventListener = this.createEventListener(eventType, handler, element);
      if (!this.eventListeners) {
        this.eventListeners = [];
      }
      this.eventListeners.push(eventListener);
      return eventListener;
    }
    function removeEventListener(eventType, handler, element) {
      const eventListener = this.findEventListener(eventType, handler, element), index = this.eventListeners.indexOf(eventListener), start = index, deleteCount = 1;
      this.eventListeners.splice(start, deleteCount);
      if (this.eventListeners.length === 0) {
        delete this.eventListeners;
      }
      return eventListener;
    }
    function findEventListener(eventType, handler, element) {
      const eventListener = this.eventListeners.find((eventListener2) => {
        if (eventListener2.element === element && eventListener2.handler === handler && eventListener2.eventType === eventType) {
          return true;
        }
      });
      return eventListener;
    }
    function findEventListeners(eventType) {
      const eventListeners = [];
      if (this.eventListeners) {
        this.eventListeners.forEach((eventListener) => {
          const found = eventListener.eventType === eventType;
          if (found) {
            eventListeners.push(eventListener);
          }
        });
      }
      return eventListeners;
    }
    function createEventListener(eventType, handler, element) {
      let eventListener;
      const handlerElement = element;
      eventListener = (event) => {
        const element2 = this;
        handler.call(handlerElement, event, element2);
      };
      Object.assign(eventListener, {
        element,
        handler,
        eventType
      });
      return eventListener;
    }
    var eventMixins = {
      onEvent,
      offEvent,
      addEventListener,
      removeEventListener,
      findEventListener,
      findEventListeners,
      createEventListener
    };
    var _default = eventMixins;
  });

  // node_modules/easy/lib/mixins/mouse.js
  var require_mouse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onMouseUp(mouseUpHandler, element) {
      this.onEvent(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function offMouseUp(mouseUpHandler, element) {
      this.offEvent(_eventTypes.MOUSEUP_EVENT_TYPE, mouseUpHandler, element);
    }
    function onMouseOut(mouseOutHandler, element) {
      this.onEvent(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function offMouseOut(mouseOutHandler, element) {
      this.offEvent(_eventTypes.MOUSEOUT_EVENT_TYPE, mouseOutHandler, element);
    }
    function onMouseDown(mouseDownHandler, element) {
      this.onEvent(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function offMouseDown(mouseDownHandler, element) {
      this.offEvent(_eventTypes.MOUSEDOWN_EVENT_TYPE, mouseDownHandler, element);
    }
    function onMouseOver(mouseOverHandler, element) {
      this.onEvent(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function offMouseOver(mouseOverHandler, element) {
      this.offEvent(_eventTypes.MOUSEOVER_EVENT_TYPE, mouseOverHandler, element);
    }
    function onMouseMove(mouseMoveHandler, element) {
      this.onEvent(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    function offMouseMove(mouseMoveHandler, element) {
      this.offEvent(_eventTypes.MOUSEMOVE_EVENT_TYPE, mouseMoveHandler, element);
    }
    var mouseMixins = {
      onMouseUp,
      offMouseUp,
      onMouseOut,
      offMouseOut,
      onMouseDown,
      offMouseDown,
      onMouseOver,
      offMouseOver,
      onMouseMove,
      offMouseMove
    };
    var _default = mouseMixins;
  });

  // node_modules/easy/lib/mixins/click.js
  var require_click = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onClick(clickHandler, element) {
      this.onEvent(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function offClick(clickHandler, element) {
      this.offEvent(_eventTypes.CLICK_EVENT_TYPE, clickHandler, element);
    }
    function onAuxClick(auxClickHandler, element) {
      this.onEvent(_eventTypes.AUXCLICK_EVENT_TYPE, auxClickHandler, element);
    }
    function offAuxClick(auxClickHandler, element) {
      this.offEvent(_eventTypes.AUXCLICK_EVENT_TYPE, auxClickHandler, element);
    }
    function onDoubleClick(doubleClickHandler, element) {
      this.onEvent(_eventTypes.DBLCLICK_EVENT_TYPE, doubleClickHandler, element);
    }
    function offDoubleClick(doubleClickHandler, element) {
      this.offEvent(_eventTypes.DBLCLICK_EVENT_TYPE, doubleClickHandler, element);
    }
    var clickMixins = {
      onClick,
      offClick,
      onAuxClick,
      offAuxClick,
      onDoubleClick,
      offDoubleClick
    };
    var _default = clickMixins;
  });

  // node_modules/easy/lib/mixins/touch.js
  var require_touch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onTouchStart(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHSTART_EVENT_TYPE, touchStartHandler);
    }
    function offTouchStart(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHSTART_EVENT_TYPE, touchStartHandler);
    }
    function onTouchMove(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHMOVE_EVENT_TYPE, touchStartHandler);
    }
    function offTouchMove(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHMOVE_EVENT_TYPE, touchStartHandler);
    }
    function onTouchEnd(touchStartHandler) {
      this.onEvent(_eventTypes.TOUCHEND_EVENT_TYPE, touchStartHandler);
    }
    function offTouchEnd(touchStartHandler) {
      this.offEvent(_eventTypes.TOUCHEND_EVENT_TYPE, touchStartHandler);
    }
    var clickMixins = {
      onTouchStart,
      offTouchStart,
      onTouchMove,
      offTouchMove,
      onTouchEnd,
      offTouchEnd
    };
    var _default = clickMixins;
  });

  // node_modules/easy/lib/mixins/scroll.js
  var require_scroll = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get offScroll() {
        return offScroll;
      },
      get onScroll() {
        return onScroll;
      }
    });
    var _eventTypes = require_eventTypes();
    function onScroll(scrollHandler, element) {
      this.onEvent(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function offScroll(scrollHandler, element) {
      this.offEvent(_eventTypes.SCROLL_EVENT_TYPE, scrollHandler, element);
    }
    function scrollTo(scrollTop, scrollLeft) {
      this.domElement.scrollTo(scrollLeft, scrollTop);
    }
    function getScrollTop() {
      return this.domElement.scrollTop;
    }
    function getScrollLeft() {
      return this.domElement.scrollLeft;
    }
    function getScrollWidth() {
      return this.domElement.scrollWidth;
    }
    function getScrollHeight() {
      return this.domElement.scrollHeight;
    }
    function setScrollTop(scrollTop) {
      this.domElement.scrollTop = scrollTop;
    }
    function setScrollLeft(scrollLeft) {
      this.domElement.scrollLeft = scrollLeft;
    }
    var scrollMixins = {
      onScroll,
      offScroll,
      scrollTo,
      getScrollTop,
      getScrollLeft,
      getScrollWidth,
      getScrollHeight,
      setScrollTop,
      setScrollLeft
    };
    var _default = scrollMixins;
  });

  // node_modules/easy/lib/mixins/resize.js
  var require_resize = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onResize(resizeHandler, element) {
      this.onEvent(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    function offResize(resizeHandler, element) {
      this.offEvent(_eventTypes.RESIZE_EVENT_TYPE, resizeHandler, element);
    }
    var resizeMixins = {
      onResize,
      offResize
    };
    var _default = resizeMixins;
  });

  // node_modules/easy/lib/mixins/fullScreen.js
  var require_fullScreen = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onFullScreenChange(fullScreenChangeHandler, element) {
      this.onEvent(_eventTypes.FULLSCREENCHANGE_EVENT_TYPE, fullScreenChangeHandler, element);
    }
    function offFullScreenChange(fullScreenChangeHandler, element) {
      this.offEvent(_eventTypes.FULLSCREENCHANGE_EVENT_TYPE, fullScreenChangeHandler, element);
    }
    function requestFullScreen(errorHandler) {
      const domElement = this.getDOMElement();
      domElement.requestFullscreen().catch(errorHandler);
    }
    function exitFullScreen() {
      document.exitFullscreen();
    }
    function isFullScreen() {
      const {fullscreenElement} = document, fullScreen = fullscreenElement !== null;
      return fullScreen;
    }
    var fullscreenMixins = {
      onFullScreenChange,
      offFullScreenChange,
      requestFullScreen,
      exitFullScreen,
      isFullScreen
    };
    var _default = fullscreenMixins;
  });

  // node_modules/easy/lib/utilities/async.js
  var require_async = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "forEach", {
      enumerable: true,
      get: function() {
        return forEach;
      }
    });
    function forEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
  });

  // node_modules/easy/lib/mixins/customEvent.js
  var require_customEvent = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants();
    var _async = require_async();
    function onCustomEvent(customEventTypes, customHandler, element = this) {
      customEventTypes = customEventTypes.split(_constants.SPACE);
      customEventTypes.forEach((customEventType) => {
        this.addCustomEventListener(customEventType, customHandler, element);
      });
    }
    function offCustomEvent(customEventTypes, customHandler, element = this) {
      customEventTypes = customEventTypes.split(_constants.SPACE);
      customEventTypes.forEach((customEventType) => {
        this.removeCustomEventListener(customEventType, customHandler, element);
      });
    }
    function callCustomHandlers(customEventType, ...remainingArguments) {
      const customEventListeners = this.findCustomEventListeners(customEventType);
      customEventListeners.forEach((customEventListener) => {
        const {customHandler, element: customHandlerElement} = customEventListener;
        customHandler.call(customHandlerElement, ...remainingArguments);
      });
    }
    function callCustomHandlersAsync(customEventType, ...remainingArguments) {
      const customEventListeners = this.findCustomEventListeners(customEventType), done = remainingArguments.pop();
      (0, _async.forEach)(customEventListeners, (customEventListener, next) => {
        const {customHandler, element: customHandlerElement} = customEventListener, done2 = next;
        customHandler.call(customHandlerElement, ...remainingArguments, done2);
      }, done);
    }
    function addCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.createCustomEventListener(customEventType, customHandler, element);
      if (!this.customEventListeners) {
        this.customEventListeners = [];
      }
      this.customEventListeners.push(customEventListener);
      return customEventListener;
    }
    function removeCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.findCustomEventListener(customEventType, customHandler, element), index = this.customEventListeners.indexOf(customEventListener), start = index, deleteCount = 1;
      this.customEventListeners.splice(start, deleteCount);
      if (this.customEventListeners.length === 0) {
        delete this.customEventListeners;
      }
      return customEventListener;
    }
    function findCustomEventListener(customEventType, customHandler, element) {
      const customEventListener = this.customEventListeners.find((customEventListener2) => {
        if (customEventListener2.element === element && customEventListener2.customHandler === customHandler && customEventListener2.customEventType === customEventType) {
          return true;
        }
      });
      return customEventListener;
    }
    function findCustomEventListeners(customEventType) {
      const customEventListeners = [];
      if (this.customEventListeners) {
        this.customEventListeners.forEach((customEventListener) => {
          const found = customEventListener.customEventType === customEventType;
          if (found) {
            customEventListeners.push(customEventListener);
          }
        });
      }
      return customEventListeners;
    }
    function createCustomEventListener(customEventType, customHandler, element) {
      let customEventListener;
      customEventListener = () => {
      };
      Object.assign(customEventListener, {
        element,
        customHandler,
        customEventType
      });
      return customEventListener;
    }
    var customEventMixins = {
      onCustomEvent,
      offCustomEvent,
      callCustomHandlers,
      callCustomHandlersAsync,
      addCustomEventListener,
      removeCustomEventListener,
      findCustomEventListener,
      findCustomEventListeners,
      createCustomEventListener
    };
    var _default = customEventMixins;
  });

  // node_modules/easy/lib/element.js
  var require_element3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Element;
      }
    });
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _jsx = /* @__PURE__ */ _interop_require_default(require_jsx());
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _state = /* @__PURE__ */ _interop_require_default(require_state());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _touch = /* @__PURE__ */ _interop_require_default(require_touch());
    var _scroll = /* @__PURE__ */ _interop_require_default(require_scroll());
    var _resize = /* @__PURE__ */ _interop_require_default(require_resize());
    var _element = /* @__PURE__ */ _interop_require_default(require_element2());
    var _fullScreen = /* @__PURE__ */ _interop_require_default(require_fullScreen());
    var _customEvent = /* @__PURE__ */ _interop_require_default(require_customEvent());
    var _array = require_array();
    var _object = require_object();
    var _name = require_name();
    var _element1 = require_element();
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Element = class {
      constructor(selector) {
        if (selector !== null) {
          const element = this, domElement = document.querySelector(selector);
          (0, _element1.constructElement)(element, domElement);
        }
      }
      getDOMElement() {
        return this.domElement;
      }
      getOffset() {
        const offset = _offset.default.fromDOMElement(this.domElement);
        return offset;
      }
      getBounds() {
        const bounds = _bounds.default.fromDOMElement(this.domElement);
        return bounds;
      }
      getWidth() {
        return this.domElement.offsetWidth;
      }
      getHeight() {
        return this.domElement.offsetHeight;
      }
      getInnerWidth() {
        return this.domElement.clientWidth;
      }
      getInnerHeight() {
        return this.domElement.clientHeight;
      }
      setWidth(width) {
        width = `${width}px`;
        this.style(_constants.WIDTH, width);
      }
      setHeight(height) {
        height = `${height}px`;
        this.style(_constants.HEIGHT, height);
      }
      hasAttribute(name) {
        return this.domElement.hasAttribute(name);
      }
      getAttribute(name) {
        return this.domElement.getAttribute(name);
      }
      setAttribute(name, value) {
        this.domElement.setAttribute(name, value);
      }
      clearAttribute(name) {
        this.domElement.removeAttribute(name);
      }
      addAttribute(name, value) {
        this.setAttribute(name, value);
      }
      removeAttribute(name) {
        this.clearAttribute(name);
      }
      hasClass(className) {
        return this.domElement.classList.contains(className);
      }
      setClass(className) {
        this.domElement.className = className;
      }
      addClass(className) {
        this.domElement.classList.add(className);
      }
      removeClass(className) {
        this.domElement.classList.remove(className);
      }
      toggleClass(className) {
        this.domElement.classList.toggle(className);
      }
      removeAllClasses() {
        this.domElement.className = _constants.EMPTY_STRING;
      }
      addTo(parentElement) {
        parentElement.add(this);
      }
      appendTo(parentElement) {
        parentElement.append(this);
      }
      prependTo(parentElement) {
        parentElement.prepend(this);
      }
      removeFrom(parentElement) {
        parentElement.remove(this);
      }
      insert(element) {
        this.append(element);
      }
      add(element) {
        this.append(element);
      }
      remove(element) {
        if (element) {
          element.remove();
          return;
        }
        this.domElement.remove();
      }
      prepend(element) {
        const domElement = element.domElement, referenceDOMElement = this.domElement.firstChild;
        this.domElement.insertBefore(domElement, referenceDOMElement);
      }
      append(element) {
        const domElement = element.domElement, referenceDOMElement = null;
        this.domElement.insertBefore(domElement, referenceDOMElement);
      }
      insertBefore(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, referenceDOMElement = siblingElement.domElement;
        parentDOMNode.insertBefore(this.domElement, referenceDOMElement);
      }
      insertAfter(siblingElement) {
        const parentDOMNode = siblingElement.domElement.parentNode, referenceDOMElement = siblingElement.domElement.nextSibling;
        parentDOMNode.insertBefore(this.domElement, referenceDOMElement);
      }
      mount(element) {
        this.add(element);
        (0, _element1.mountElement)(element);
      }
      unmount(element) {
        (0, _element1.unmountElement)(element);
        this.remove(element);
      }
      mountBefore(siblingElement) {
        this.insertBefore(siblingElement);
        const element = this;
        (0, _element1.mountElement)(element);
      }
      mountAfter(siblingElement) {
        this.insertAfter(siblingElement);
        const element = this;
        (0, _element1.mountElement)(element);
      }
      show(displayStyle = _constants.BLOCK) {
        this.display(displayStyle);
      }
      hide() {
        this.style(_constants.DISPLAY, _constants.NONE);
      }
      display(display) {
        this.style(_constants.DISPLAY, display);
      }
      enable() {
        this.clearAttribute(_constants.DISABLED);
      }
      disable() {
        this.setAttribute(_constants.DISABLED, _constants.DISABLED);
      }
      isEnabled() {
        const disabled = this.isDisabled(), enabled = !disabled;
        return enabled;
      }
      isDisabled() {
        const disabled = this.hasAttribute(_constants.DISABLED);
        return disabled;
      }
      isDisplayed() {
        const display = this.css(_constants.DISPLAY), displayed = display !== _constants.NONE;
        return displayed;
      }
      isShowing() {
        const displayed = this.isDisplayed(), showing = displayed;
        return showing;
      }
      isHidden() {
        const displayed = this.isDisplayed(), hidden = !displayed;
        return hidden;
      }
      style(name, value = null) {
        if (value !== null) {
          this.domElement.style[name] = value;
          return;
        }
        const style = this.domElement.style[name];
        return style;
      }
      html(html = null) {
        if (html !== null) {
          const innerHTML2 = html;
          this.domElement.innerHTML = innerHTML2;
          return;
        }
        const innerHTML = this.domElement.innerHTML;
        html = innerHTML;
        return html;
      }
      css(css = null) {
        if (css === null) {
          css = {};
          const computedStyles = getComputedStyle(this.domElement);
          for (let index = 0; index < computedStyles.length; index++) {
            const computedStyle = computedStyles[index], name = computedStyle, value = computedStyles.getPropertyValue(name);
            css[name] = value;
          }
        } else if (typeof css === _constants.STRING) {
          let name = css;
          const computedStyles = getComputedStyle(this.domElement), value = computedStyles.getPropertyValue(name);
          css = value;
        } else {
          const names = Object.keys(css);
          names.forEach((name) => {
            const value = css[name];
            this.style(name, value);
          });
        }
        return css;
      }
      destroy() {
        const element = this;
        (0, _element1.destroyElement)(element);
      }
      static fromClass(Class, properties, ...remainingArguments) {
        const {tagName} = Class, element = elementFromTagName(Class, tagName, ...remainingArguments), defaultProperties = defaultPropertiesFromClass(Class), ignoredProperties = ignoredPropertiesFromClass(Class);
        element.applyProperties(properties, defaultProperties, ignoredProperties);
        element.initialise && element.initialise();
        return element;
      }
      static fromTagName(tagName, properties, ...remainingArguments) {
        const Class = Element, element = elementFromTagName(Class, tagName, ...remainingArguments), defaultProperties = {}, ignoredProperties = [];
        element.applyProperties(properties, defaultProperties, ignoredProperties);
        element.initialise && element.initialise();
        return element;
      }
    };
    Object.assign(Element.prototype, _jsx.default);
    Object.assign(Element.prototype, _key.default);
    Object.assign(Element.prototype, _mouse.default);
    Object.assign(Element.prototype, _click.default);
    Object.assign(Element.prototype, _state.default);
    Object.assign(Element.prototype, _event.default);
    Object.assign(Element.prototype, _touch.default);
    Object.assign(Element.prototype, _scroll.default);
    Object.assign(Element.prototype, _resize.default);
    Object.assign(Element.prototype, _element.default);
    Object.assign(Element.prototype, _fullScreen.default);
    Object.assign(Element.prototype, _customEvent.default);
    function elementFromTagName(Class, tagName, ...remainingArguments) {
      const selector = null, element = new (Function.prototype.bind.call(Class, null, selector, ...remainingArguments))(), domElement = (0, _name.isSVGTagName)(tagName) ? document.createElementNS(_constants.SVG_NAMESPACE_URI, tagName) : document.createElement(tagName);
      (0, _element1.constructElement)(element, domElement);
      return element;
    }
    function defaultPropertiesFromClass(Class, defaultProperties = {}) {
      if (Class.hasOwnProperty(_constants.DEFAULT_PROPERTIES)) {
        defaultProperties = (0, _object.combine)(defaultProperties, Class[_constants.DEFAULT_PROPERTIES]);
      }
      const superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        defaultProperties = defaultPropertiesFromClass(superClass, defaultProperties);
      }
      return defaultProperties;
    }
    function ignoredPropertiesFromClass(Class, ignoredProperties = []) {
      if (Class.hasOwnProperty(_constants.IGNORED_PROPERTIES)) {
        ignoredProperties = (0, _array.augment)(ignoredProperties, Class[_constants.IGNORED_PROPERTIES], (ignoredProperty) => {
          if (!ignoredProperties.includes(ignoredProperty)) {
            return true;
          }
        });
      }
      const superClass = Object.getPrototypeOf(Class);
      if (superClass !== null) {
        ignoredProperties = ignoredPropertiesFromClass(superClass, ignoredProperties);
      }
      return ignoredProperties;
    }
  });

  // node_modules/easy/lib/react.js
  var require_react = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _array = require_array();
    var _constants = require_constants();
    var _elements = require_elements();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createElement(firstArgument, properties, ...childElements) {
      let element = null;
      if (firstArgument) {
        childElements = sanitiseChildElements(childElements);
        properties = Object.assign({
          childElements
        }, properties);
        if (false) {
        } else if (isSubclassOf(firstArgument, _element.default)) {
          const Class = firstArgument;
          element = Class.fromClass(Class, properties);
        } else if (typeof firstArgument === _constants.STRING) {
          const tagName = firstArgument;
          element = _element.default.fromTagName(tagName, properties);
        } else if (typeof firstArgument === _constants.FUNCTION) {
          const elementFunction = firstArgument;
          element = elementFunction(properties);
        }
      }
      return element;
    }
    var React2 = {
      createElement
    };
    var _default = React2;
    function sanitiseChildElements(childElements) {
      childElements = (0, _array.flatten)(childElements);
      childElements = (0, _elements.removeFalseyElements)(childElements);
      childElements = (0, _elements.replaceStringsWithTextElements)(childElements);
      return childElements;
    }
    function isSubclassOf(argument, Class) {
      const subclassOf = argument.prototype instanceof Class;
      return subclassOf;
    }
  });

  // node_modules/easy/lib/mouseButtons.js
  var require_mouseButtons = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get LEFT_MOUSE_BUTTON() {
        return LEFT_MOUSE_BUTTON;
      },
      get MIDDLE_MOUSE_BUTTON() {
        return MIDDLE_MOUSE_BUTTON;
      },
      get RIGHT_MOUSE_BUTTON() {
        return RIGHT_MOUSE_BUTTON;
      },
      get default() {
        return _default;
      }
    });
    var LEFT_MOUSE_BUTTON = 0;
    var RIGHT_MOUSE_BUTTON = 2;
    var MIDDLE_MOUSE_BUTTON = 1;
    var _default = {
      LEFT_MOUSE_BUTTON,
      RIGHT_MOUSE_BUTTON,
      MIDDLE_MOUSE_BUTTON
    };
  });

  // node_modules/easy/lib/mixins/input.js
  var require_input = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onInput(inputHandler, element) {
      this.onEvent(_eventTypes.INPUT_EVENT_TYPE, inputHandler, element);
    }
    function offInput(inputHandler, element) {
      this.offEvent(_eventTypes.INPUT_EVENT_TYPE, inputHandler, element);
    }
    function onChange(changeHandler, element) {
      this.onEvent(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function offChange(changeHandler, element) {
      this.offEvent(_eventTypes.CHANGE_EVENT_TYPE, changeHandler, element);
    }
    function getValue() {
      return this.domElement.value;
    }
    function setValue(value) {
      this.domElement.value = value;
    }
    function isReadOnly() {
      return this.domElement.readOnly;
    }
    function setReadOnly(readOnly) {
      this.domElement.readOnly = readOnly;
    }
    var inputMixins = {
      onInput,
      offInput,
      onChange,
      offChange,
      getValue,
      setValue,
      isReadOnly,
      setReadOnly
    };
    var _default = inputMixins;
  });

  // node_modules/easy/lib/mixins/focus.js
  var require_focus = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onBlur(blurHandler, element) {
      this.onEvent(_eventTypes.BLUR_EVENT_TYPE, blurHandler, element);
    }
    function offBlur(blurHandler, element) {
      this.offEvent(_eventTypes.BLUR_EVENT_TYPE, blurHandler, element);
    }
    function onFocus(focusHandler, element) {
      this.onEvent(_eventTypes.FOCUS_EVENT_TYPE, focusHandler, element);
    }
    function offFocus(focusHandler, element) {
      this.offEvent(_eventTypes.FOCUS_EVENT_TYPE, focusHandler, element);
    }
    function blur() {
      this.domElement.blur();
    }
    function focus() {
      this.domElement.focus();
    }
    function hasFocus() {
      const focus2 = document.activeElement === this.domElement;
      return focus2;
    }
    var focusMixins = {
      onBlur,
      offBlur,
      onFocus,
      offFocus,
      blur,
      focus,
      hasFocus
    };
    var _default = focusMixins;
  });

  // node_modules/easy/lib/mixins/selection.js
  var require_selection = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _eventTypes = require_eventTypes();
    function onCut(cutHandler, element) {
      this.onEvent(_eventTypes.CUT_EVENT_TYPE, cutHandler, element);
    }
    function offCut(cutHandler, element) {
      this.offEvent(_eventTypes.CUT_EVENT_TYPE, cutHandler, element);
    }
    function onCopy(copyHandler, element) {
      this.onEvent(_eventTypes.COPY_EVENT_TYPE, copyHandler, element);
    }
    function offCopy(copyHandler, element) {
      this.offEvent(_eventTypes.COPY_EVENT_TYPE, copyHandler, element);
    }
    function onPaste(pasteHandler, element) {
      this.onEvent(_eventTypes.PASTE_EVENT_TYPE, pasteHandler, element);
    }
    function offPaste(pasteHandler, element) {
      this.offEvent(_eventTypes.PASTE_EVENT_TYPE, pasteHandler, element);
    }
    function getSelectionStart() {
      return this.domElement.selectionStart;
    }
    function getSelectionEnd() {
      return this.domElement.selectionEnd;
    }
    function setSelectionStart(selectionStart) {
      this.domElement.selectionStart = selectionStart;
    }
    function setSelectionEnd(selectionEnd) {
      this.domElement.selectionEnd = selectionEnd;
    }
    function select() {
      this.domElement.select();
    }
    var selectionMixins = {
      onCut,
      offCut,
      onCopy,
      offCopy,
      onPaste,
      offPaste,
      getSelectionStart,
      getSelectionEnd,
      setSelectionStart,
      setSelectionEnd,
      select
    };
    var _default = selectionMixins;
  });

  // node_modules/easy/lib/document.js
  var require_document = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Document = class {
      constructor() {
        this.domElement = document;
      }
      getDOMElement() {
        return this.domElement;
      }
      getSelection() {
        return this.domElement.getSelection();
      }
      createRange() {
        return this.domElement.createRange();
      }
      createTextNode(data) {
        return this.domElement.createTextNode(data);
      }
      onSelectionChange(selectionChangeHandler, element) {
        this.onEvent(_eventTypes.SELECTIONCHANGE_EVENT_TYPE, selectionChangeHandler, element);
      }
      offSelectionChange(selectionChangeHandler, element) {
        this.offEvent(_eventTypes.SELECTIONCHANGE_EVENT_TYPE, selectionChangeHandler, element);
      }
      createEventListener(eventType, handler, element) {
        let eventListener;
        const handlerElement = element;
        eventListener = (event) => {
          if (eventType === _eventTypes.SELECTIONCHANGE_EVENT_TYPE) {
            const {domElement} = handlerElement, {currentTarget} = event, {activeElement} = currentTarget;
            if (domElement !== activeElement) {
              return;
            }
          }
          const element2 = this;
          handler.call(handlerElement, event, element2);
        };
        Object.assign(eventListener, {
          element,
          handler,
          eventType
        });
        return eventListener;
      }
    };
    Object.assign(Document.prototype, _key.default);
    Object.assign(Document.prototype, _event.default);
    Object.assign(Document.prototype, _mouse.default);
    Object.assign(Document.prototype, _click.default);
    var _default = typeof document === _constants.UNDEFINED ? void 0 : new Document();
  });

  // node_modules/easy/lib/window.js
  var require_window = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _key = /* @__PURE__ */ _interop_require_default(require_key());
    var _event = /* @__PURE__ */ _interop_require_default(require_event());
    var _mouse = /* @__PURE__ */ _interop_require_default(require_mouse());
    var _click = /* @__PURE__ */ _interop_require_default(require_click());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _constants = require_constants();
    var _eventTypes = require_eventTypes();
    var _scroll = require_scroll();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Window = class {
      constructor() {
        this.domElement = window;
      }
      getDOMElement() {
        return this.domElement;
      }
      assign(...sources) {
        const target = this.domElement;
        Object.assign(target, ...sources);
      }
      reload() {
        window.location.reload();
      }
      getWidth() {
        return this.domElement.innerWidth;
      }
      getHeight() {
        return this.domElement.innerHeight;
      }
      getScrollTop() {
        return this.domElement.pageYOffset;
      }
      getScrollLeft() {
        return this.domElement.pageXOffset;
      }
      getSelection() {
        return this.domElement.getSelection();
      }
      getScreenWidth() {
        return this.domElement.screen.width;
      }
      getScreenHeight() {
        return this.domElement.screen.height;
      }
      scrollTo(scrollTop, scrollLeft) {
        this.domElement.scrollTo(scrollLeft, scrollTop);
      }
      onResize(resizeHandler, element) {
        const eventType = _eventTypes.RESIZE_EVENT_TYPE, eventListener = this.addEventListener(eventType, resizeHandler, element);
        this.domElement.addEventListener(eventType, eventListener);
      }
      offResize(resizeHandler, element) {
        const eventType = _eventTypes.RESIZE_EVENT_TYPE, eventListener = this.removeEventListener(eventType, resizeHandler, element);
        this.domElement.removeEventListener(eventType, eventListener);
      }
    };
    Object.assign(Window.prototype, _key.default);
    Object.assign(Window.prototype, _event.default);
    Object.assign(Window.prototype, _mouse.default);
    Object.assign(Window.prototype, _click.default);
    Object.assign(Window.prototype, _focus.default);
    Object.assign(Window.prototype, {
      onScroll: _scroll.onScroll,
      offScroll: _scroll.offScroll
    });
    var _default = typeof window === _constants.UNDEFINED ? void 0 : new Window();
  });

  // node_modules/easy/lib/element/body.js
  var require_body = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Body;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _constants = require_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Body = class extends _element.default {
      constructor(selector = _constants.BODY) {
        super(selector);
      }
    };
    __publicField(Body, "tagName", "body");
  });

  // node_modules/easy/lib/element/link.js
  var require_link = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Link;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Link = class extends _element.default {
      getHRef() {
        return this.getAttribute("href");
      }
      setHRef(href) {
        return this.setAttribute("href", href);
      }
    };
    __publicField(Link, "tagName", "a");
    Object.assign(Link.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/input.js
  var require_input2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Input;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Input = class extends _element.default {
    };
    __publicField(Input, "tagName", "input");
    Object.assign(Input.prototype, _input.default);
    Object.assign(Input.prototype, _focus.default);
    Object.assign(Input.prototype, _selection.default);
  });

  // node_modules/easy/lib/element/button.js
  var require_button = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Button;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Button = class extends _element.default {
    };
    __publicField(Button, "tagName", "button");
    Object.assign(Button.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/select.js
  var require_select = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Select;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Select = class extends _element.default {
    };
    __publicField(Select, "tagName", "select");
    Object.assign(Select.prototype, _input.default);
    Object.assign(Select.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/checkbox.js
  var require_checkbox = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Checkbox;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Checkbox = class extends _element.default {
      isChecked() {
        return this.domElement.checked;
      }
      check(checked = true) {
        this.domElement.checked = checked;
      }
    };
    __publicField(Checkbox, "tagName", "input");
    __publicField(Checkbox, "defaultProperties", {
      type: "checkbox"
    });
    Object.assign(Checkbox.prototype, _input.default);
    Object.assign(Checkbox.prototype, _focus.default);
  });

  // node_modules/easy/lib/element/textarea.js
  var require_textarea = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Textarea;
      }
    });
    var _element = /* @__PURE__ */ _interop_require_default(require_element3());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Textarea = class extends _element.default {
    };
    __publicField(Textarea, "tagName", "textarea");
    Object.assign(Textarea.prototype, _input.default);
    Object.assign(Textarea.prototype, _focus.default);
    Object.assign(Textarea.prototype, _selection.default);
  });

  // node_modules/easy/lib/index.js
  var require_lib = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Body() {
        return _body.default;
      },
      get Bounds() {
        return _bounds.default;
      },
      get Button() {
        return _button.default;
      },
      get Checkbox() {
        return _checkbox.default;
      },
      get Element() {
        return _element1.default;
      },
      get Input() {
        return _input1.default;
      },
      get Link() {
        return _link.default;
      },
      get Offset() {
        return _offset.default;
      },
      get React() {
        return _react.default;
      },
      get Select() {
        return _select.default;
      },
      get TextElement() {
        return _textElement.default;
      },
      get Textarea() {
        return _textarea.default;
      },
      get customEventMixins() {
        return _customEvent.default;
      },
      get document() {
        return _document.default;
      },
      get elementUtilities() {
        return _element.default;
      },
      get eventTypes() {
        return _eventTypes.default;
      },
      get focusMixins() {
        return _focus.default;
      },
      get inputMixins() {
        return _input.default;
      },
      get mouseButtons() {
        return _mouseButtons.default;
      },
      get selectionMixins() {
        return _selection.default;
      },
      get window() {
        return _window.default;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_default(require_react());
    var _bounds = /* @__PURE__ */ _interop_require_default(require_bounds());
    var _offset = /* @__PURE__ */ _interop_require_default(require_offset());
    var _eventTypes = /* @__PURE__ */ _interop_require_default(require_eventTypes());
    var _mouseButtons = /* @__PURE__ */ _interop_require_default(require_mouseButtons());
    var _element = /* @__PURE__ */ _interop_require_default(require_element());
    var _input = /* @__PURE__ */ _interop_require_default(require_input());
    var _focus = /* @__PURE__ */ _interop_require_default(require_focus());
    var _selection = /* @__PURE__ */ _interop_require_default(require_selection());
    var _customEvent = /* @__PURE__ */ _interop_require_default(require_customEvent());
    var _element1 = /* @__PURE__ */ _interop_require_default(require_element3());
    var _textElement = /* @__PURE__ */ _interop_require_default(require_textElement());
    var _document = /* @__PURE__ */ _interop_require_default(require_document());
    var _window = /* @__PURE__ */ _interop_require_default(require_window());
    var _body = /* @__PURE__ */ _interop_require_default(require_body());
    var _link = /* @__PURE__ */ _interop_require_default(require_link());
    var _input1 = /* @__PURE__ */ _interop_require_default(require_input2());
    var _button = /* @__PURE__ */ _interop_require_default(require_button());
    var _select = /* @__PURE__ */ _interop_require_default(require_select());
    var _checkbox = /* @__PURE__ */ _interop_require_default(require_checkbox());
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/juxtapose/lib/juxtapose.js
  var require_juxtapose = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _easy = require_lib();
    Object.assign(globalThis, {
      React: _easy.React
    });
  });

  // node_modules/juxtapose/lib/index.js
  var require_lib2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_juxtapose();
  });

  // node_modules/with-style/lib/tagNames.js
  var require_tagNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var tagNames = [
      "a",
      "abbr",
      "address",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "svg",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ];
    var _default = tagNames;
  });

  // node_modules/necessary/lib/levels.js
  var require_levels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DEBUG_LEVEL() {
        return DEBUG_LEVEL;
      },
      get ERROR_LEVEL() {
        return ERROR_LEVEL;
      },
      get FATAL_LEVEL() {
        return FATAL_LEVEL;
      },
      get INFO_LEVEL() {
        return INFO_LEVEL;
      },
      get TRACE_LEVEL() {
        return TRACE_LEVEL;
      },
      get WARNING_LEVEL() {
        return WARNING_LEVEL;
      },
      get default() {
        return _default;
      }
    });
    var TRACE_LEVEL = "trace";
    var DEBUG_LEVEL = "debug";
    var INFO_LEVEL = "info";
    var WARNING_LEVEL = "warning";
    var ERROR_LEVEL = "error";
    var FATAL_LEVEL = "fatal";
    var _default = {
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL,
      FATAL_LEVEL
    };
  });

  // node_modules/necessary/lib/methods.js
  var require_methods = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DELETE_METHOD() {
        return DELETE_METHOD;
      },
      get GET_METHOD() {
        return GET_METHOD;
      },
      get OPTIONS_METHOD() {
        return OPTIONS_METHOD;
      },
      get PATCH_METHOD() {
        return PATCH_METHOD;
      },
      get POST_METHOD() {
        return POST_METHOD;
      },
      get default() {
        return _default;
      }
    });
    var GET_METHOD = "GET";
    var POST_METHOD = "POST";
    var PATCH_METHOD = "PATCH";
    var DELETE_METHOD = "DELETE";
    var OPTIONS_METHOD = "OPTIONS";
    var _default = {
      GET_METHOD,
      POST_METHOD,
      PATCH_METHOD,
      DELETE_METHOD,
      OPTIONS_METHOD
    };
  });

  // node_modules/necessary/lib/headers.js
  var require_headers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ACCEPT_HEADER() {
        return ACCEPT_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_HEADERS_HEADER() {
        return ACCESS_CONTROL_ALLOW_HEADERS_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_METHODS_HEADER() {
        return ACCESS_CONTROL_ALLOW_METHODS_HEADER;
      },
      get ACCESS_CONTROL_ALLOW_ORIGIN_HEADER() {
        return ACCESS_CONTROL_ALLOW_ORIGIN_HEADER;
      },
      get ACCESS_CONTROL_REQUEST_METHOD_HEADER() {
        return ACCESS_CONTROL_REQUEST_METHOD_HEADER;
      },
      get AUTHORIZATION_HEADER() {
        return AUTHORIZATION_HEADER;
      },
      get CACHE_CONTROL_HEADER() {
        return CACHE_CONTROL_HEADER;
      },
      get CONTENT_DISPOSITION_HEADER() {
        return CONTENT_DISPOSITION_HEADER;
      },
      get CONTENT_LENGTH_HEADER() {
        return CONTENT_LENGTH_HEADER;
      },
      get CONTENT_TYPE_HEADER() {
        return CONTENT_TYPE_HEADER;
      },
      get LOCATION_HEADER() {
        return LOCATION_HEADER;
      },
      get PRAGMA_HEADER() {
        return PRAGMA_HEADER;
      },
      get TRANSFER_ENCODING_HEADER() {
        return TRANSFER_ENCODING_HEADER;
      },
      get USER_AGENT_HEADER() {
        return USER_AGENT_HEADER;
      },
      get default() {
        return _default;
      }
    });
    var PRAGMA_HEADER = "pragma";
    var ACCEPT_HEADER = "accept";
    var LOCATION_HEADER = "location";
    var USER_AGENT_HEADER = "user-agent";
    var CONTENT_TYPE_HEADER = "content-type";
    var AUTHORIZATION_HEADER = "authorization";
    var CACHE_CONTROL_HEADER = "cache-control";
    var CONTENT_LENGTH_HEADER = "content-length";
    var TRANSFER_ENCODING_HEADER = "transfer-encoding";
    var CONTENT_DISPOSITION_HEADER = "content-disposition";
    var ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = "access-control-allow-origin";
    var ACCESS_CONTROL_ALLOW_METHODS_HEADER = "access-control-allow-methods";
    var ACCESS_CONTROL_ALLOW_HEADERS_HEADER = "access-control-allow-headers";
    var ACCESS_CONTROL_REQUEST_METHOD_HEADER = "access-control-request-method";
    var _default = {
      PRAGMA_HEADER,
      ACCEPT_HEADER,
      LOCATION_HEADER,
      USER_AGENT_HEADER,
      CONTENT_TYPE_HEADER,
      AUTHORIZATION_HEADER,
      CACHE_CONTROL_HEADER,
      CONTENT_LENGTH_HEADER,
      TRANSFER_ENCODING_HEADER,
      CONTENT_DISPOSITION_HEADER,
      ACCESS_CONTROL_ALLOW_ORIGIN_HEADER,
      ACCESS_CONTROL_ALLOW_METHODS_HEADER,
      ACCESS_CONTROL_ALLOW_HEADERS_HEADER,
      ACCESS_CONTROL_REQUEST_METHOD_HEADER
    };
  });

  // node_modules/necessary/lib/keyCodes.js
  var require_keyCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ARROW_DOWN_KEY_CODE() {
        return ARROW_DOWN_KEY_CODE;
      },
      get ARROW_LEFT_KEY_CODE() {
        return ARROW_LEFT_KEY_CODE;
      },
      get ARROW_RIGHT_KEY_CODE() {
        return ARROW_RIGHT_KEY_CODE;
      },
      get ARROW_UP_KEY_CODE() {
        return ARROW_UP_KEY_CODE;
      },
      get BACKSPACE_KEY_CODE() {
        return BACKSPACE_KEY_CODE;
      },
      get DELETE_KEY_CODE() {
        return DELETE_KEY_CODE;
      },
      get ENTER_KEY_CODE() {
        return ENTER_KEY_CODE;
      },
      get ESCAPE_KEY_CODE() {
        return ESCAPE_KEY_CODE;
      },
      get SHIFT_KEY_CODE() {
        return SHIFT_KEY_CODE;
      },
      get TAB_KEY_CODE() {
        return TAB_KEY_CODE;
      },
      get default() {
        return _default;
      }
    });
    var TAB_KEY_CODE = 9;
    var SHIFT_KEY_CODE = 16;
    var ENTER_KEY_CODE = 13;
    var ESCAPE_KEY_CODE = 27;
    var DELETE_KEY_CODE = 46;
    var BACKSPACE_KEY_CODE = 8;
    var ARROW_UP_KEY_CODE = 38;
    var ARROW_DOWN_KEY_CODE = 40;
    var ARROW_LEFT_KEY_CODE = 37;
    var ARROW_RIGHT_KEY_CODE = 39;
    var _default = {
      TAB_KEY_CODE,
      SHIFT_KEY_CODE,
      ENTER_KEY_CODE,
      ESCAPE_KEY_CODE,
      DELETE_KEY_CODE,
      BACKSPACE_KEY_CODE,
      ARROW_UP_KEY_CODE,
      ARROW_DOWN_KEY_CODE,
      ARROW_LEFT_KEY_CODE,
      ARROW_RIGHT_KEY_CODE
    };
  });

  // node_modules/necessary/lib/encodings.js
  var require_encodings = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BASE64_ENCODING() {
        return BASE64_ENCODING;
      },
      get UTF8_ENCODING() {
        return UTF8_ENCODING;
      },
      get UTF_8_ENCODING() {
        return UTF_8_ENCODING;
      },
      get default() {
        return _default;
      }
    });
    var UTF8_ENCODING = "utf8";
    var UTF_8_ENCODING = "utf-8";
    var BASE64_ENCODING = "base64";
    var _default = {
      UTF8_ENCODING,
      UTF_8_ENCODING,
      BASE64_ENCODING
    };
  });

  // node_modules/necessary/lib/characters.js
  var require_characters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AMPERSAND_CHARACTER() {
        return AMPERSAND_CHARACTER;
      },
      get ASTERISK_CHARACTER() {
        return ASTERISK_CHARACTER;
      },
      get BACKSLASH_CHARACTER() {
        return BACKSLASH_CHARACTER;
      },
      get BACKSPACE_CHARACTER() {
        return BACKSPACE_CHARACTER;
      },
      get BACKTICK_DELIMITER() {
        return BACKTICK_DELIMITER;
      },
      get BAR_CHARACTER() {
        return BAR_CHARACTER;
      },
      get CARRIAGE_RETURN_CHARACTER() {
        return CARRIAGE_RETURN_CHARACTER;
      },
      get CLOSING_BRACKET_CHARACTER() {
        return CLOSING_BRACKET_CHARACTER;
      },
      get CLOSING_CURLY_BRACKET_CHARACTER() {
        return CLOSING_CURLY_BRACKET_CHARACTER;
      },
      get CLOSING_SQUARE_BRACKET_CHARACTER() {
        return CLOSING_SQUARE_BRACKET_CHARACTER;
      },
      get COLON_CHARACTER() {
        return COLON_CHARACTER;
      },
      get COMMA_CHARACTER() {
        return COMMA_CHARACTER;
      },
      get CTRL_C_CHARACTER() {
        return CTRL_C_CHARACTER;
      },
      get DASH_CHARACTER() {
        return DASH_CHARACTER;
      },
      get DOLLAR_CHARACTER() {
        return DOLLAR_CHARACTER;
      },
      get DOWN_CHARACTER() {
        return DOWN_CHARACTER;
      },
      get ESCAPE_CHARACTER() {
        return ESCAPE_CHARACTER;
      },
      get ETX_CHARACTER() {
        return ETX_CHARACTER;
      },
      get EXCLAMATION_MARK_CHARACTER() {
        return EXCLAMATION_MARK_CHARACTER;
      },
      get FORWARD_SLASH_CHARACTER() {
        return FORWARD_SLASH_CHARACTER;
      },
      get HAT_CHARACTER() {
        return HAT_CHARACTER;
      },
      get LEFT_CHARACTER() {
        return LEFT_CHARACTER;
      },
      get NEW_LINE_CHARACTER() {
        return NEW_LINE_CHARACTER;
      },
      get OPENING_BRACKET_CHARACTER() {
        return OPENING_BRACKET_CHARACTER;
      },
      get OPENING_CURLY_BRACKET_CHARACTER() {
        return OPENING_CURLY_BRACKET_CHARACTER;
      },
      get OPENING_SQUARE_BRACKET_CHARACTER() {
        return OPENING_SQUARE_BRACKET_CHARACTER;
      },
      get PERIOD_CHARACTER() {
        return PERIOD_CHARACTER;
      },
      get PLUS_CHARACTER() {
        return PLUS_CHARACTER;
      },
      get QUESTION_MARK_CHARACTER() {
        return QUESTION_MARK_CHARACTER;
      },
      get RIGHT_CHARACTER() {
        return RIGHT_CHARACTER;
      },
      get SPACE_CHARACTER() {
        return SPACE_CHARACTER;
      },
      get UP_CHARACTER() {
        return UP_CHARACTER;
      },
      get WILDCARD_CHARACTER() {
        return WILDCARD_CHARACTER;
      },
      get default() {
        return _default;
      }
    });
    var UP_CHARACTER = "[A";
    var ETX_CHARACTER = "";
    var BAR_CHARACTER = "|";
    var HAT_CHARACTER = "^";
    var PLUS_CHARACTER = "+";
    var DASH_CHARACTER = "-";
    var DOWN_CHARACTER = "[B";
    var LEFT_CHARACTER = "[D";
    var RIGHT_CHARACTER = "[C";
    var SPACE_CHARACTER = " ";
    var COMMA_CHARACTER = ",";
    var COLON_CHARACTER = ":";
    var PERIOD_CHARACTER = ".";
    var DOLLAR_CHARACTER = "$";
    var CTRL_C_CHARACTER = "^C";
    var ESCAPE_CHARACTER = "";
    var ASTERISK_CHARACTER = "*";
    var WILDCARD_CHARACTER = "*";
    var BACKTICK_DELIMITER = "`";
    var NEW_LINE_CHARACTER = "\n";
    var AMPERSAND_CHARACTER = "&";
    var BACKSLASH_CHARACTER = "\\";
    var BACKSPACE_CHARACTER = String.fromCharCode(127);
    var QUESTION_MARK_CHARACTER = "?";
    var FORWARD_SLASH_CHARACTER = "/";
    var OPENING_BRACKET_CHARACTER = "(";
    var CLOSING_BRACKET_CHARACTER = ")";
    var CARRIAGE_RETURN_CHARACTER = "\r";
    var EXCLAMATION_MARK_CHARACTER = "!";
    var OPENING_CURLY_BRACKET_CHARACTER = "{";
    var CLOSING_CURLY_BRACKET_CHARACTER = "}";
    var OPENING_SQUARE_BRACKET_CHARACTER = "[";
    var CLOSING_SQUARE_BRACKET_CHARACTER = "]";
    var _default = {
      UP_CHARACTER,
      ETX_CHARACTER,
      BAR_CHARACTER,
      HAT_CHARACTER,
      PLUS_CHARACTER,
      DASH_CHARACTER,
      DOWN_CHARACTER,
      LEFT_CHARACTER,
      RIGHT_CHARACTER,
      SPACE_CHARACTER,
      COMMA_CHARACTER,
      COLON_CHARACTER,
      PERIOD_CHARACTER,
      DOLLAR_CHARACTER,
      CTRL_C_CHARACTER,
      ESCAPE_CHARACTER,
      ASTERISK_CHARACTER,
      WILDCARD_CHARACTER,
      BACKTICK_DELIMITER,
      NEW_LINE_CHARACTER,
      AMPERSAND_CHARACTER,
      BACKSLASH_CHARACTER,
      BACKSPACE_CHARACTER,
      QUESTION_MARK_CHARACTER,
      FORWARD_SLASH_CHARACTER,
      OPENING_BRACKET_CHARACTER,
      CLOSING_BRACKET_CHARACTER,
      CARRIAGE_RETURN_CHARACTER,
      EXCLAMATION_MARK_CHARACTER,
      OPENING_CURLY_BRACKET_CHARACTER,
      CLOSING_CURLY_BRACKET_CHARACTER,
      OPENING_SQUARE_BRACKET_CHARACTER,
      CLOSING_SQUARE_BRACKET_CHARACTER
    };
  });

  // node_modules/necessary/lib/statusCodes.js
  var require_statusCodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BAD_GATEWAY_502_STATUS_CODE() {
        return BAD_GATEWAY_502_STATUS_CODE;
      },
      get BAD_REQUEST_400_STATUS_CODE() {
        return BAD_REQUEST_400_STATUS_CODE;
      },
      get CONFLICT_409_STATUS_CODE() {
        return CONFLICT_409_STATUS_CODE;
      },
      get CREATED_201_STATUS_CODE() {
        return CREATED_201_STATUS_CODE;
      },
      get FORBIDDEN_403_STATUS_CODE() {
        return FORBIDDEN_403_STATUS_CODE;
      },
      get FOUND_302_STATUS_CODE() {
        return FOUND_302_STATUS_CODE;
      },
      get INTERNAL_SERVER_ERROR_500_STATUS_CODE() {
        return INTERNAL_SERVER_ERROR_500_STATUS_CODE;
      },
      get METHOD_NOT_ALLOWED_405_STATUS_CODE() {
        return METHOD_NOT_ALLOWED_405_STATUS_CODE;
      },
      get NOT_ACCEPTABLE_406_STATUS_CODE() {
        return NOT_ACCEPTABLE_406_STATUS_CODE;
      },
      get NOT_FOUND_404_STATUS_CODE() {
        return NOT_FOUND_404_STATUS_CODE;
      },
      get NO_CONTENT_204_STATUS_CODE() {
        return NO_CONTENT_204_STATUS_CODE;
      },
      get OK_200_STATUS_CODE() {
        return OK_200_STATUS_CODE;
      },
      get REQUEST_TIMEOUT_408_STATUS_CODE() {
        return REQUEST_TIMEOUT_408_STATUS_CODE;
      },
      get SEE_OTHER_303_STATUS_CODE() {
        return SEE_OTHER_303_STATUS_CODE;
      },
      get SERVICE_UNAVAILABLE_503_STATUS_CODE() {
        return SERVICE_UNAVAILABLE_503_STATUS_CODE;
      },
      get TOO_MANY_REQUESTS_429_STATUS_CODE() {
        return TOO_MANY_REQUESTS_429_STATUS_CODE;
      },
      get UNAUTHORIZED_401_STATUS_CODE() {
        return UNAUTHORIZED_401_STATUS_CODE;
      },
      get UNPROCESSABLE_ENTITY_422_STATUS_CODE() {
        return UNPROCESSABLE_ENTITY_422_STATUS_CODE;
      },
      get ZERO_0_STATUS_CODE() {
        return ZERO_0_STATUS_CODE;
      },
      get default() {
        return _default;
      }
    });
    var ZERO_0_STATUS_CODE = 0;
    var OK_200_STATUS_CODE = 200;
    var FOUND_302_STATUS_CODE = 302;
    var CREATED_201_STATUS_CODE = 201;
    var CONFLICT_409_STATUS_CODE = 409;
    var SEE_OTHER_303_STATUS_CODE = 303;
    var FORBIDDEN_403_STATUS_CODE = 403;
    var NOT_FOUND_404_STATUS_CODE = 404;
    var NO_CONTENT_204_STATUS_CODE = 204;
    var BAD_GATEWAY_502_STATUS_CODE = 502;
    var BAD_REQUEST_400_STATUS_CODE = 400;
    var UNAUTHORIZED_401_STATUS_CODE = 401;
    var NOT_ACCEPTABLE_406_STATUS_CODE = 406;
    var REQUEST_TIMEOUT_408_STATUS_CODE = 408;
    var TOO_MANY_REQUESTS_429_STATUS_CODE = 429;
    var METHOD_NOT_ALLOWED_405_STATUS_CODE = 405;
    var SERVICE_UNAVAILABLE_503_STATUS_CODE = 503;
    var UNPROCESSABLE_ENTITY_422_STATUS_CODE = 422;
    var INTERNAL_SERVER_ERROR_500_STATUS_CODE = 500;
    var _default = {
      ZERO_0_STATUS_CODE,
      OK_200_STATUS_CODE,
      FOUND_302_STATUS_CODE,
      CREATED_201_STATUS_CODE,
      CONFLICT_409_STATUS_CODE,
      SEE_OTHER_303_STATUS_CODE,
      FORBIDDEN_403_STATUS_CODE,
      NOT_FOUND_404_STATUS_CODE,
      NO_CONTENT_204_STATUS_CODE,
      BAD_GATEWAY_502_STATUS_CODE,
      BAD_REQUEST_400_STATUS_CODE,
      UNAUTHORIZED_401_STATUS_CODE,
      NOT_ACCEPTABLE_406_STATUS_CODE,
      REQUEST_TIMEOUT_408_STATUS_CODE,
      TOO_MANY_REQUESTS_429_STATUS_CODE,
      METHOD_NOT_ALLOWED_405_STATUS_CODE,
      SERVICE_UNAVAILABLE_503_STATUS_CODE,
      UNPROCESSABLE_ENTITY_422_STATUS_CODE,
      INTERNAL_SERVER_ERROR_500_STATUS_CODE
    };
  });

  // node_modules/necessary/lib/contentTypes.js
  var require_contentTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE() {
        return APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get APPLICATION_JSON_CONTENT_TYPE() {
        return APPLICATION_JSON_CONTENT_TYPE;
      },
      get APPLICATION_OCTET_STREAM_CONTENT_TYPE() {
        return APPLICATION_OCTET_STREAM_CONTENT_TYPE;
      },
      get APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE() {
        return APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE() {
        return APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE;
      },
      get TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE() {
        return TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get TEXT_HTML_CONTENT_TYPE() {
        return TEXT_HTML_CONTENT_TYPE;
      },
      get TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE() {
        return TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE;
      },
      get TEXT_PLAIN_CONTENT_TYPE() {
        return TEXT_PLAIN_CONTENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var TEXT_HTML_CONTENT_TYPE = "text/html";
    var TEXT_PLAIN_CONTENT_TYPE = "text/plain";
    var APPLICATION_JSON_CONTENT_TYPE = "application/json";
    var TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE = "text/html; charset=utf-8";
    var TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE = "text/plain; charset=utf-8";
    var APPLICATION_OCTET_STREAM_CONTENT_TYPE = "application/octet-stream";
    var APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE = "application/x-www-form-urlencoded";
    var APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE = "application/json; charset=utf-8";
    var APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE = "application/x-www-form-urlencoded; charset=utf-8";
    var _default = {
      TEXT_HTML_CONTENT_TYPE,
      TEXT_PLAIN_CONTENT_TYPE,
      APPLICATION_JSON_CONTENT_TYPE,
      TEXT_HTML_CHARSET_UTF_8_CONTENT_TYPE,
      TEXT_PLAIN_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_OCTET_STREAM_CONTENT_TYPE,
      APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CONTENT_TYPE,
      APPLICATION_X_WWW_FORM_ENCODED_CHARSET_UTF_8_CONTENT_TYPE
    };
  });

  // node_modules/necessary/lib/statusMessages.js
  var require_statusMessages = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BAD_GATEWAY_502_STATUS_MESSAGE() {
        return BAD_GATEWAY_502_STATUS_MESSAGE;
      },
      get BAD_REQUEST_400_STATUS_MESSAGE() {
        return BAD_REQUEST_400_STATUS_MESSAGE;
      },
      get CONFLICT_409_STATUS_MESSAGE() {
        return CONFLICT_409_STATUS_MESSAGE;
      },
      get CREATED_201_STATUS_MESSAGE() {
        return CREATED_201_STATUS_MESSAGE;
      },
      get FORBIDDEN_403_STATUS_MESSAGE() {
        return FORBIDDEN_403_STATUS_MESSAGE;
      },
      get FOUND_302_STATUS_MESSAGE() {
        return FOUND_302_STATUS_MESSAGE;
      },
      get INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE() {
        return INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE;
      },
      get METHOD_NOT_ALLOWED_405_STATUS_MESSAGE() {
        return METHOD_NOT_ALLOWED_405_STATUS_MESSAGE;
      },
      get NOT_ACCEPTABLE_406_STATUS_MESSAGE() {
        return NOT_ACCEPTABLE_406_STATUS_MESSAGE;
      },
      get NOT_FOUND_404_STATUS_MESSAGE() {
        return NOT_FOUND_404_STATUS_MESSAGE;
      },
      get NO_CONTENT_204_STATUS_MESSAGE() {
        return NO_CONTENT_204_STATUS_MESSAGE;
      },
      get OK_200_STATUS_MESSAGE() {
        return OK_200_STATUS_MESSAGE;
      },
      get REQUEST_TIMEOUT_408_STATUS_MESSAGE() {
        return REQUEST_TIMEOUT_408_STATUS_MESSAGE;
      },
      get SEE_OTHER_303_STATUS_MESSAGE() {
        return SEE_OTHER_303_STATUS_MESSAGE;
      },
      get SERVICE_UNAVAILABLE_503_STATUS_MESSAGE() {
        return SERVICE_UNAVAILABLE_503_STATUS_MESSAGE;
      },
      get TOO_MANY_REQUESTS_429_STATUS_MESSAGE() {
        return TOO_MANY_REQUESTS_429_STATUS_MESSAGE;
      },
      get UNAUTHORIZED_401_STATUS_MESSAGE() {
        return UNAUTHORIZED_401_STATUS_MESSAGE;
      },
      get UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE() {
        return UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE;
      },
      get ZERO_0_STATUS_MESSAGE() {
        return ZERO_0_STATUS_MESSAGE;
      },
      get default() {
        return _default;
      }
    });
    var ZERO_0_STATUS_MESSAGE = "";
    var OK_200_STATUS_MESSAGE = "OK";
    var FOUND_302_STATUS_MESSAGE = "Found";
    var CREATED_201_STATUS_MESSAGE = "Created";
    var CONFLICT_409_STATUS_MESSAGE = "Conflict";
    var SEE_OTHER_303_STATUS_MESSAGE = "See other";
    var FORBIDDEN_403_STATUS_MESSAGE = "Forbidden";
    var NOT_FOUND_404_STATUS_MESSAGE = "Not found";
    var NO_CONTENT_204_STATUS_MESSAGE = "No content";
    var BAD_GATEWAY_502_STATUS_MESSAGE = "Bad gateway";
    var BAD_REQUEST_400_STATUS_MESSAGE = "Bad request";
    var UNAUTHORIZED_401_STATUS_MESSAGE = "Unauthorized";
    var NOT_ACCEPTABLE_406_STATUS_MESSAGE = "Not Acceptable";
    var REQUEST_TIMEOUT_408_STATUS_MESSAGE = "Request timeout";
    var TOO_MANY_REQUESTS_429_STATUS_MESSAGE = "Too many requests";
    var METHOD_NOT_ALLOWED_405_STATUS_MESSAGE = "Method not allowed";
    var SERVICE_UNAVAILABLE_503_STATUS_MESSAGE = "Service unavailable";
    var UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE = "Unprocessable Entity";
    var INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE = "Internal server error";
    var _default = {
      ZERO_0_STATUS_MESSAGE,
      OK_200_STATUS_MESSAGE,
      FOUND_302_STATUS_MESSAGE,
      CREATED_201_STATUS_MESSAGE,
      CONFLICT_409_STATUS_MESSAGE,
      SEE_OTHER_303_STATUS_MESSAGE,
      FORBIDDEN_403_STATUS_MESSAGE,
      NOT_FOUND_404_STATUS_MESSAGE,
      NO_CONTENT_204_STATUS_MESSAGE,
      BAD_GATEWAY_502_STATUS_MESSAGE,
      BAD_REQUEST_400_STATUS_MESSAGE,
      UNAUTHORIZED_401_STATUS_MESSAGE,
      NOT_ACCEPTABLE_406_STATUS_MESSAGE,
      REQUEST_TIMEOUT_408_STATUS_MESSAGE,
      TOO_MANY_REQUESTS_429_STATUS_MESSAGE,
      METHOD_NOT_ALLOWED_405_STATUS_MESSAGE,
      SERVICE_UNAVAILABLE_503_STATUS_MESSAGE,
      UNPROCESSABLE_ENTITY_422_STATUS_MESSAGE,
      INTERNAL_SERVER_ERROR_500_STATUS_MESSAGE
    };
  });

  // node_modules/necessary/lib/constants.js
  var require_constants2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN() {
        return BOOLEAN;
      },
      get DATA() {
        return DATA;
      },
      get DEFAULT() {
        return DEFAULT;
      },
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ENVIRONMENT() {
        return ENVIRONMENT;
      },
      get ERROR() {
        return ERROR;
      },
      get FUNCTION() {
        return FUNCTION;
      },
      get NUMBER() {
        return NUMBER;
      },
      get PACKAGE_JSON() {
        return PACKAGE_JSON;
      },
      get STRING() {
        return STRING;
      },
      get ZERO() {
        return ZERO;
      }
    });
    var ZERO = "0";
    var DATA = "data";
    var ERROR = "error";
    var STRING = "string";
    var NUMBER = "number";
    var BOOLEAN = "boolean";
    var DEFAULT = "default";
    var FUNCTION = "function";
    var ENVIRONMENT = "ENVIRONMENT";
    var EMPTY_STRING = "";
    var DOUBLE_SPACE = "  ";
    var PACKAGE_JSON = "package.json";
  });

  // node_modules/necessary/lib/utilities/array.js
  var require_array2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get augment() {
        return augment;
      },
      get back() {
        return back;
      },
      get backwardsEvery() {
        return backwardsEvery;
      },
      get backwardsFind() {
        return backwardsFind;
      },
      get backwardsFindIndex() {
        return backwardsFindIndex;
      },
      get backwardsForEach() {
        return backwardsForEach;
      },
      get backwardsReduce() {
        return backwardsReduce;
      },
      get backwardsSome() {
        return backwardsSome;
      },
      get clear() {
        return clear;
      },
      get combine() {
        return combine;
      },
      get compare() {
        return compare;
      },
      get compress() {
        return compress;
      },
      get concat() {
        return concat;
      },
      get copy() {
        return copy;
      },
      get correlate() {
        return correlate;
      },
      get default() {
        return _default;
      },
      get eighth() {
        return eighth;
      },
      get eighthLast() {
        return eighthLast;
      },
      get extract() {
        return extract;
      },
      get fifth() {
        return fifth;
      },
      get fifthLast() {
        return fifthLast;
      },
      get filter() {
        return filter;
      },
      get find() {
        return find;
      },
      get first() {
        return first2;
      },
      get firstLast() {
        return firstLast;
      },
      get forwardsEvery() {
        return forwardsEvery;
      },
      get forwardsFind() {
        return forwardsFind;
      },
      get forwardsFindIndex() {
        return forwardsFindIndex;
      },
      get forwardsForEach() {
        return forwardsForEach;
      },
      get forwardsReduce() {
        return forwardsReduce;
      },
      get forwardsSome() {
        return forwardsSome;
      },
      get fourth() {
        return fourth;
      },
      get fourthLast() {
        return fourthLast;
      },
      get front() {
        return front;
      },
      get head() {
        return head;
      },
      get last() {
        return last;
      },
      get match() {
        return match;
      },
      get merge() {
        return merge;
      },
      get ninth() {
        return ninth;
      },
      get ninthLast() {
        return ninthLast;
      },
      get patch() {
        return patch;
      },
      get prune() {
        return prune;
      },
      get push() {
        return push;
      },
      get replace() {
        return replace;
      },
      get resolve() {
        return resolve;
      },
      get reverse() {
        return reverse;
      },
      get second() {
        return second;
      },
      get secondLast() {
        return secondLast;
      },
      get separate() {
        return separate;
      },
      get seventh() {
        return seventh;
      },
      get seventhLast() {
        return seventhLast;
      },
      get sixth() {
        return sixth;
      },
      get sixthLast() {
        return sixthLast;
      },
      get splice() {
        return splice;
      },
      get tail() {
        return tail;
      },
      get tenth() {
        return tenth;
      },
      get third() {
        return third;
      },
      get thirdLast() {
        return thirdLast;
      },
      get unshift() {
        return unshift;
      }
    });
    function first2(array) {
      return array[0];
    }
    function second(array) {
      return array[1];
    }
    function third(array) {
      return array[2];
    }
    function fourth(array) {
      return array[3];
    }
    function fifth(array) {
      return array[4];
    }
    function sixth(array) {
      return array[5];
    }
    function seventh(array) {
      return array[6];
    }
    function eighth(array) {
      return array[7];
    }
    function ninth(array) {
      return array[8];
    }
    function tenth(array) {
      return array[9];
    }
    function firstLast(array) {
      return array[array.length - 1];
    }
    function secondLast(array) {
      return array[array.length - 2];
    }
    function thirdLast(array) {
      return array[array.length - 3];
    }
    function fourthLast(array) {
      return array[array.length - 4];
    }
    function fifthLast(array) {
      return array[array.length - 5];
    }
    function sixthLast(array) {
      return array[array.length - 6];
    }
    function seventhLast(array) {
      return array[array.length - 7];
    }
    function eighthLast(array) {
      return array[array.length - 8];
    }
    function ninthLast(array) {
      return array[array.length - 9];
    }
    function last(array) {
      return array[array.length - 1];
    }
    function head(array) {
      return array.slice(0, 1);
    }
    function tail(array) {
      return array.slice(1);
    }
    function back(array) {
      return array.slice(array.length - 1);
    }
    function front(array) {
      return array.slice(0, Math.max(1, array.length - 1));
    }
    function push(arrayA, arrayB) {
      Array.prototype.push.apply(arrayA, arrayB);
    }
    function unshift(arrayA, arrayB) {
      Array.prototype.unshift.apply(arrayA, arrayB);
    }
    function concat(arrayA, elementOrArray2) {
      const arrayB = elementOrArray2 instanceof Array ? elementOrArray2 : [
        elementOrArray2
      ];
      push(arrayA, arrayB);
    }
    function clear(array) {
      const start = 0;
      return array.splice(start);
    }
    function copy(arrayA, arrayB) {
      const start = 0, deleteCount = arrayB.length;
      splice(arrayA, start, deleteCount, arrayB);
    }
    function merge(arrayA, arrayB) {
      Array.prototype.push.apply(arrayA, arrayB);
    }
    function match(arrayA, arrayB, callback) {
      let matches = false;
      const arrayALength = arrayA.length, arrayBLength = arrayB.length;
      if (arrayALength === arrayBLength) {
        matches = arrayA.every((elementA, index) => {
          const elementB = arrayB[index], passed = callback(elementA, elementB, index);
          if (passed) {
            return true;
          }
        });
      }
      return matches;
    }
    function compare(arrayA, arrayB, callback) {
      let coupled = false;
      const arrayALength = arrayA.length, arrayBLength = arrayB.length;
      if (arrayALength === arrayBLength) {
        arrayB = [
          ...arrayB
        ];
        coupled = arrayA.every((elementA, index) => {
          const elementB = extract(arrayB, (elementB2) => {
            const result = callback(elementA, elementB2);
            if (result) {
              return true;
            }
          }) || null;
          if (elementB !== null) {
            return true;
          }
        });
      }
      return coupled;
    }
    function correlate(arrayA, arrayB, callback) {
      arrayB = [
        ...arrayB
      ];
      const correlates = arrayA.every((elementA) => {
        const elementB = extract(arrayB, (elementB2) => {
          const result = callback(elementA, elementB2);
          if (result) {
            return true;
          }
        }) || null;
        if (elementB !== null) {
          return true;
        }
      });
      return correlates;
    }
    function resolve(arrayA, arrayB, callback) {
      let resolved;
      arrayA = [
        ...arrayA
      ];
      for (; ; ) {
        const arrayALength2 = arrayA.length;
        if (arrayALength2 === 0) {
          break;
        }
        let resolved2 = false;
        arrayA.forEach((elementA) => {
          const passed = callback(elementA);
          if (passed) {
            const elementB = elementA;
            arrayB.push(elementB);
            resolved2 = true;
          }
        });
        if (!resolved2) {
          break;
        }
        filter(arrayA, (elementA) => {
          const arrayBIncludesElementA = arrayB.includes(elementA);
          if (!arrayBIncludesElementA) {
            return true;
          }
        });
      }
      const arrayALength = arrayA.length;
      resolved = arrayALength === 0;
      return resolved;
    }
    function find(array, callback) {
      const elements = [];
      forwardsForEach(array, (element, index) => {
        const passed = callback(element, index);
        if (passed) {
          elements.push(element);
        }
      });
      return elements;
    }
    function replace(array, element, callback) {
      let start;
      const found = array.some((element2, index) => {
        const passed = callback(element2, index);
        if (passed) {
          start = index;
          return true;
        }
      });
      if (found) {
        const deleteCount = 1;
        array.splice(start, deleteCount, element);
      }
      return found;
    }
    function splice(arrayA, start, deleteCount = Infinity, arrayB = []) {
      const args = [
        start,
        deleteCount,
        ...arrayB
      ], deletedElements = Array.prototype.splice.apply(arrayA, args);
      return deletedElements;
    }
    function filter(array, callback) {
      const deletedElements = [];
      backwardsForEach(array, (element, index) => {
        const passed = callback(element, index);
        if (!passed) {
          const start = index, deleteCount = 1, deletedElements2 = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements2);
          deletedElements2.unshift(firstDeletedElement);
        }
      });
      return deletedElements;
    }
    function prune(array, callback) {
      let deletedElement = void 0;
      array.some((element, index) => {
        const passed = callback(element, index);
        if (!passed) {
          const start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements);
          deletedElement = firstDeletedElement;
          return true;
        }
      });
      return deletedElement;
    }
    function extract(array, callback) {
      let deletedElement = void 0;
      array.some((element, index) => {
        const passed = callback(element, index);
        if (passed) {
          const start = index, deleteCount = 1, deletedElements = array.splice(start, deleteCount), firstDeletedElement = first2(deletedElements);
          deletedElement = firstDeletedElement;
          return true;
        }
      });
      return deletedElement;
    }
    function patch(array, element, callback) {
      const found = array.some((element2, index) => {
        const passed = callback(element2, index);
        if (passed) {
          return true;
        }
      });
      if (found) {
        array.push(element);
      }
      return found;
    }
    function compress(array, callback) {
      let index1 = 0, length = array.length;
      while (index1 < length) {
        const elementB = array[index1];
        for (let index2 = length - 1; index2 > index1; index2--) {
          const elementA = array[index2], passed = callback(elementA, elementB);
          if (!passed) {
            const start = index2, deleteCount = 1;
            array.splice(start, deleteCount);
          }
        }
        index1++;
        length = array.length;
      }
    }
    function combine(arrayA, arrayB, callback) {
      const array = [
        ...arrayA,
        ...arrayB
      ];
      compress(array, callback);
      return array;
    }
    function reverse(array) {
      array = [
        ...array
      ].reverse();
      return array;
    }
    function augment(arrayA, arrayB, callback) {
      arrayB.forEach((element, index) => {
        const passed = callback(element, index);
        if (passed) {
          arrayA.push(element);
        }
      });
    }
    function separate(array, arrayA, arrayB, callback) {
      array.forEach((element, index) => {
        const passed = callback(element, index);
        passed ? arrayA.push(element) : arrayB.push(element);
      });
    }
    function forwardsFind(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return element;
        }
      }
      return false;
    }
    function backwardsFind(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return element;
        }
      }
      return false;
    }
    function forwardsSome(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return true;
        }
      }
      return false;
    }
    function backwardsSome(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return true;
        }
      }
      return false;
    }
    function forwardsEvery(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    function backwardsEvery(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    function forwardsReduce(array, callback, initialValue) {
      let value = initialValue;
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index];
        value = callback(value, element, index);
      }
      return value;
    }
    function backwardsReduce(array, callback, initialValue) {
      let value = initialValue;
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index];
        value = callback(value, element, index);
      }
      return value;
    }
    function forwardsForEach(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index];
        callback(element, index);
      }
    }
    function backwardsForEach(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index];
        callback(element, index);
      }
    }
    function forwardsFindIndex(array, callback) {
      const arrayLength = array.length;
      for (let index = 0; index < arrayLength; index++) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return index;
        }
      }
      return -1;
    }
    function backwardsFindIndex(array, callback) {
      const arrayLength = array.length;
      for (let index = arrayLength - 1; index >= 0; index--) {
        const element = array[index], passed = callback(element, index);
        if (passed) {
          return index;
        }
      }
      return -1;
    }
    var _default = {
      first: first2,
      second,
      third,
      fourth,
      fifth,
      sixth,
      seventh,
      eighth,
      ninth,
      firstLast,
      secondLast,
      thirdLast,
      fourthLast,
      fifthLast,
      sixthLast,
      seventhLast,
      eighthLast,
      ninthLast,
      last,
      head,
      tail,
      back,
      front,
      push,
      unshift,
      concat,
      clear,
      copy,
      merge,
      match,
      compare,
      correlate,
      resolve,
      find,
      replace,
      splice,
      filter,
      prune,
      extract,
      patch,
      compress,
      combine,
      reverse,
      augment,
      separate,
      forwardsFind,
      backwardsFind,
      forwardsSome,
      backwardsSome,
      forwardsEvery,
      backwardsEvery,
      forwardsReduce,
      backwardsReduce,
      forwardsForEach,
      backwardsForEach,
      forwardsFindIndex,
      backwardsFindIndex
    };
  });

  // node_modules/necessary/lib/utilities/path.js
  var require_path = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get bottommostNameFromPath() {
        return bottommostNameFromPath;
      },
      get combinePaths() {
        return combinePaths;
      },
      get concatenatePaths() {
        return concatenatePaths;
      },
      get default() {
        return _default;
      },
      get isPathAbsolutePath() {
        return isPathAbsolutePath;
      },
      get isPathName() {
        return isPathName;
      },
      get isPathRelativePath() {
        return isPathRelativePath;
      },
      get isPathTopmostName() {
        return isPathTopmostName;
      },
      get isTopmostNameInAbsolutePath() {
        return isTopmostNameInAbsolutePath;
      },
      get pathWithoutBottommostNameFromPath() {
        return pathWithoutBottommostNameFromPath;
      },
      get pathWithoutTopmostDirectoryNameFromPath() {
        return pathWithoutTopmostDirectoryNameFromPath;
      },
      get topmostDirectoryNameFromPath() {
        return topmostDirectoryNameFromPath;
      },
      get topmostDirectoryPathFromPath() {
        return topmostDirectoryPathFromPath;
      }
    });
    var _constants = require_constants2();
    var _array = require_array2();
    function isPathName(path) {
      path = path.replace(/^\//, _constants.EMPTY_STRING).replace(/\/$/, _constants.EMPTY_STRING);
      const pathName = /\//.test(path) === false;
      return pathName;
    }
    function isPathTopmostName(path) {
      const pathName = isPathName(path), pathAbsolutePath = isPathAbsolutePath(path), pathTopmostName = pathName && pathAbsolutePath;
      return pathTopmostName;
    }
    function isPathRelativePath(path) {
      const pathRelativePath = !/^\//.test(path);
      return pathRelativePath;
    }
    function isPathAbsolutePath(path) {
      const pathAbsolutePath = /^\//.test(path);
      return pathAbsolutePath;
    }
    function isTopmostNameInAbsolutePath(topmostName, absolutePath) {
      const regExp = new RegExp(`^${topmostName}(?:\\/.+)?$`), topmostNameInAbsolutePath = regExp.test(absolutePath);
      return topmostNameInAbsolutePath;
    }
    function combinePaths(path, relativePath) {
      let combinedPath = null;
      const pathNames = path.split(/\//), relativePathNames = relativePath.split(/\//);
      let lastPathName, firstRelativePathName = (0, _array.first)(relativePathNames);
      if (firstRelativePathName === ".") {
        relativePathNames.shift();
      }
      firstRelativePathName = (0, _array.first)(relativePathNames);
      lastPathName = (0, _array.last)(pathNames);
      while (firstRelativePathName === ".." && lastPathName !== void 0) {
        relativePathNames.shift();
        pathNames.pop();
        firstRelativePathName = (0, _array.first)(relativePathNames);
        lastPathName = (0, _array.last)(pathNames);
      }
      if (lastPathName !== void 0) {
        const combinedPathNames = [].concat(pathNames).concat(relativePathNames);
        combinedPath = combinedPathNames.join("/");
      }
      return combinedPath;
    }
    function concatenatePaths(path, relativePath, ...remainingArguments) {
      let concatenatedPath;
      path = path.replace(/\/$/, _constants.EMPTY_STRING);
      concatenatedPath = `${path}/${relativePath}`;
      const remainingAArgumentsLength = remainingArguments.length;
      if (remainingAArgumentsLength > 0) {
        const path2 = concatenatedPath, relativePath2 = remainingArguments.shift();
        concatenatedPath = concatenatePaths(path2, relativePath2, ...remainingArguments);
      }
      return concatenatedPath;
    }
    function bottommostNameFromPath(path) {
      let bottommostName = null;
      const matches = path.match(/^.*\/([^\/]+\/?)$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        bottommostName = secondMatch;
      }
      return bottommostName;
    }
    function topmostDirectoryPathFromPath(path) {
      const matches = path.match(/^(.+)\/[^\/]+\/?$/), secondMatch = (0, _array.second)(matches), topmostDirectoryPath = secondMatch;
      return topmostDirectoryPath;
    }
    function topmostDirectoryNameFromPath(path) {
      let topmostDirectoryName = null;
      const matches = path.match(/^([^\/]+)\/.+$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        topmostDirectoryName = secondMatch;
      }
      return topmostDirectoryName;
    }
    function pathWithoutBottommostNameFromPath(path) {
      let pathWithoutBottommostName = null;
      const matches = path.match(/^(.*)\/[^\/]+\/?$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        pathWithoutBottommostName = secondMatch;
      }
      return pathWithoutBottommostName;
    }
    function pathWithoutTopmostDirectoryNameFromPath(path) {
      let pathWithoutTopmostDirectoryName = null;
      const matches = path.match(/^[^\/]+\/(.+)$/);
      if (matches !== null) {
        const secondMatch = (0, _array.second)(matches);
        pathWithoutTopmostDirectoryName = secondMatch;
      }
      return pathWithoutTopmostDirectoryName;
    }
    var _default = {
      isPathName,
      isPathTopmostName,
      isPathRelativePath,
      isPathAbsolutePath,
      isTopmostNameInAbsolutePath,
      combinePaths,
      concatenatePaths,
      bottommostNameFromPath,
      topmostDirectoryPathFromPath,
      topmostDirectoryNameFromPath,
      pathWithoutBottommostNameFromPath,
      pathWithoutTopmostDirectoryNameFromPath
    };
  });

  // node_modules/necessary/lib/utilities/http.js
  var require_http = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get hostnameFromHost() {
        return hostnameFromHost;
      },
      get overwrite() {
        return overwrite;
      },
      get portFromHost() {
        return portFromHost;
      },
      get queryStringFromQuery() {
        return queryStringFromQuery;
      },
      get secureFromHost() {
        return secureFromHost;
      },
      get underwrite() {
        return underwrite;
      },
      get urlFromHostURIAndQuery() {
        return urlFromHostURIAndQuery;
      }
    });
    var _array = require_array2();
    var _constants = require_constants2();
    var _characters = require_characters();
    function overwrite(headers, name, value) {
      const lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName = existingNames.find((existingName2) => {
        const existingLowerCaseName = existingName2.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName !== null) {
        headers[existingName] = value;
      }
    }
    function underwrite(headers, name, value) {
      const lowerCaseName = name.toLowerCase(), existingNames = Object.getOwnPropertyNames(headers), existingName = existingNames.find((existingName2) => {
        const existingLowerCaseName = existingName2.toLowerCase();
        if (existingLowerCaseName === lowerCaseName) {
          return true;
        }
      }) || null;
      if (existingName === null) {
        headers[name] = value;
      }
    }
    function portFromHost(host) {
      let port;
      const matches = host.match(/^https?:\/\/([^\/]+)/), secondMatch = (0, _array.second)(matches), index = secondMatch.indexOf(_characters.COLON_CHARACTER);
      if (index === -1) {
        const secure = secureFromHost(host);
        port = secure ? 443 : 80;
      } else {
        const start = index + 1, portString = secondMatch.substring(start);
        port = Number(portString);
      }
      return port;
    }
    function secureFromHost(host) {
      const secure = /^https:\/\//.test(host);
      return secure;
    }
    function hostnameFromHost(host) {
      const matches = host.match(/^https?:\/\/([^:\/]+)/), secondMatch = (0, _array.second)(matches), hostname = secondMatch;
      return hostname;
    }
    function queryStringFromQuery(query) {
      const names = Object.keys(query), namesLength = names.length, lastIndex = namesLength - 1, queryString = names.reduce((queryString2, name, index) => {
        const value = query[name], encodedName = encodeURIComponent(name), encodedValue = encodeURIComponent(value), ampersandOrNothing = index !== lastIndex ? _characters.AMPERSAND_CHARACTER : _constants.EMPTY_STRING;
        queryString2 += `${encodedName}=${encodedValue}${ampersandOrNothing}`;
        return queryString2;
      }, _constants.EMPTY_STRING);
      return queryString;
    }
    function urlFromHostURIAndQuery(host, uri, query) {
      const queryString = queryStringFromQuery(query), url = queryString === _constants.EMPTY_STRING ? `${host}${uri}` : `${host}${uri}?${queryString}`;
      return url;
    }
    var _default = {
      overwrite,
      underwrite,
      portFromHost,
      secureFromHost,
      hostnameFromHost,
      queryStringFromQuery,
      urlFromHostURIAndQuery
    };
  });

  // node_modules/necessary/lib/utilities/string.js
  var require_string2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get indexOf() {
        return indexOf;
      },
      get strcmp() {
        return strcmp;
      },
      get strlen() {
        return strlen;
      },
      get substring() {
        return substring;
      }
    });
    var _constants = require_constants2();
    function strlen(string) {
      let length = 0;
      const iterator = string[Symbol.iterator]();
      let character = iterator.next();
      while (!character.done) {
        character = iterator.next();
        length++;
      }
      return length;
    }
    function strcmp(stringA, stringB) {
      let difference;
      const iteratorA = stringA[Symbol.iterator](), iteratorB = stringB[Symbol.iterator]();
      let characterA = iteratorA.next(), characterB = iteratorB.next(), codePointA, codePointB;
      while (true) {
        codePointA = characterA.value ? characterA.value.codePointAt(0) : 0;
        codePointB = characterB.value ? characterB.value.codePointAt(0) : 0;
        difference = codePointB - codePointA;
        if (difference !== 0) {
          break;
        }
        if (characterA.done || characterB.done) {
          break;
        }
        characterA = iteratorA.next();
        characterB = iteratorB.next();
      }
      return difference;
    }
    function indexOf(string, searchString) {
      let index = -1, found = false;
      const searchStringLength = strlen(searchString);
      if (searchStringLength > 0) {
        let character;
        const iterator = string[Symbol.iterator](), searchIterator = searchString[Symbol.iterator](), searchCharacter = searchIterator.next();
        character = iterator.next();
        index++;
        while (!character.done) {
          if (character.value === searchCharacter.value) {
            const start = index, end = start + searchStringLength, subString = substring(string, start, end), difference = strcmp(subString, searchString);
            if (difference === 0) {
              found = true;
              break;
            }
          }
          character = iterator.next();
          index++;
        }
      }
      if (!found) {
        index = -1;
      }
      return index;
    }
    function substring(string, start, end = Infinity) {
      let index = 0;
      const iterator = string[Symbol.iterator](), characters = [];
      let character = iterator.next();
      while (!character.done) {
        if (index === end) {
          break;
        }
        if (index >= start) {
          characters.push(character.value);
        }
        index++;
        character = iterator.next();
      }
      const substring1 = characters.join(_constants.EMPTY_STRING);
      return substring1;
    }
    var _default = {
      strcmp,
      strlen,
      indexOf,
      substring
    };
  });

  // node_modules/necessary/lib/utilities/version.js
  var require_version = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get migrate() {
        return migrate;
      }
    });
    function migrate(json, migrationMap, latestVersion) {
      let {version} = json;
      while (version !== latestVersion) {
        const migrateFunction = migrationMap[version];
        json = migrateFunction(json);
        ({version} = json);
      }
      return json;
    }
    var _default = {
      migrate
    };
  });

  // node_modules/necessary/lib/utilities/asynchronous.js
  var require_asynchronous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get backwardsForEach() {
        return backwardsForEach;
      },
      get default() {
        return _default;
      },
      get eventually() {
        return eventually;
      },
      get forEach() {
        return forEach;
      },
      get forwardsForEach() {
        return forwardsForEach;
      },
      get repeatedly() {
        return repeatedly;
      },
      get sequence() {
        return sequence;
      },
      get whilst() {
        return whilst;
      }
    });
    function whilst(operation, done, context2) {
      let count = -1;
      function next() {
        count++;
        const index = count;
        operation(next, done, context2, index);
      }
      next();
    }
    function forEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    function sequence(operations, done, context2) {
      const length = operations.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, operation = operations[index];
          operation(next, done, context2, index);
        }
      }
      next();
    }
    function eventually(operations, done, context2) {
      const length = operations.length;
      if (length === 0) {
        done();
        return;
      }
      let count = 0;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        }
      }
      operations.forEach((operation, index) => {
        operation(next, done, context2, index);
      });
    }
    function repeatedly(operation, length, done, context2) {
      if (length === 0) {
        done();
        return;
      }
      let count = 0;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        }
      }
      for (let index = 0; index < length; index++) {
        operation(next, done, context2, index);
      }
    }
    function forwardsForEach(array, operation, done, context2) {
      const length = array.length;
      let count = -1;
      function next() {
        count++;
        const terminate = count === length;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    function backwardsForEach(array, operation, done, context2) {
      const length = array.length;
      let count = length;
      function next() {
        count--;
        const terminate = count === -1;
        if (terminate) {
          done();
        } else {
          const index = count, element = array[index];
          operation(element, next, done, context2, index);
        }
      }
      next();
    }
    var _default = {
      whilst,
      forEach,
      sequence,
      eventually,
      repeatedly,
      forwardsForEach,
      backwardsForEach
    };
  });

  // node_modules/necessary/lib/utilities/ajax.js
  var require_ajax = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get get() {
        return get;
      },
      get post() {
        return post;
      },
      get request() {
        return request;
      }
    });
    var _constants = require_constants2();
    var _methods = require_methods();
    var _contentTypes = require_contentTypes();
    var _headers = require_headers();
    var _http = require_http();
    function get(host, uri, query, headers, responseType, callback) {
      if (typeof headers === _constants.FUNCTION) {
        callback = headers;
        responseType = null;
        headers = {};
      }
      if (typeof responseType === _constants.FUNCTION) {
        callback = responseType;
        if (typeof headers === _constants.STRING) {
          responseType = headers;
          headers = {};
        } else {
          responseType = null;
        }
      }
      const method = _methods.GET_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, content = null;
      underwriteAcceptHeader(headers, accept);
      request(host, uri, query, method, content, headers, responseType, callback);
    }
    function post(host, uri, query, content, headers, responseType, callback) {
      if (typeof headers === _constants.FUNCTION) {
        callback = headers;
        responseType = null;
        headers = {};
      }
      if (typeof responseType === _constants.FUNCTION) {
        callback = responseType;
        if (typeof headers === _constants.STRING) {
          responseType = headers;
          headers = {};
        } else {
          responseType = null;
        }
      }
      const method = _methods.POST_METHOD, accept = _contentTypes.APPLICATION_JSON_CONTENT_TYPE, contentType = _contentTypes.APPLICATION_JSON_CONTENT_TYPE;
      underwriteAcceptHeader(headers, accept);
      underwriteContentTypeHeader(headers, contentType);
      request(host, uri, query, method, content, headers, responseType, callback);
    }
    function request(host, uri, query, method, content, headers, responseType, callback) {
      const url = (0, _http.urlFromHostURIAndQuery)(host, uri, query), accept = headers[_headers.ACCEPT_HEADER] || null, contentType = headers[_headers.CONTENT_TYPE_HEADER] || null, xmlHttpRequest = new XMLHttpRequest();
      if (contentType === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
        const json = content, jsonString = JSON.stringify(json);
        content = jsonString;
      }
      if (responseType !== null) {
        Object.assign(xmlHttpRequest, {
          responseType
        });
      }
      xmlHttpRequest.onreadystatechange = () => {
        const {readyState, status, response} = xmlHttpRequest, statusCode = status;
        if (readyState == 4) {
          let content2 = response;
          if (accept === _contentTypes.APPLICATION_JSON_CONTENT_TYPE) {
            try {
              const jsonString = content2, json = JSON.parse(jsonString);
              content2 = json;
            } catch (error) {
              content2 = null;
            }
          }
          callback(content2, statusCode);
        }
      };
      xmlHttpRequest.open(method, url);
      if (accept !== null) {
        xmlHttpRequest.setRequestHeader(_headers.ACCEPT_HEADER, accept);
      }
      if (contentType !== null) {
        xmlHttpRequest.setRequestHeader(_headers.CONTENT_TYPE_HEADER, contentType);
      }
      content !== null ? xmlHttpRequest.send(content) : xmlHttpRequest.send();
    }
    var _default = {
      get,
      post,
      request
    };
    function underwriteAcceptHeader(headers, accept) {
      const name = _headers.ACCEPT_HEADER, value = accept;
      (0, _http.underwrite)(headers, name, value);
    }
    function underwriteContentTypeHeader(headers, contentTYpe) {
      const name = _headers.CONTENT_TYPE_HEADER, value = contentTYpe;
      (0, _http.underwrite)(headers, name, value);
    }
  });

  // node_modules/necessary/lib/browser.js
  var require_browser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ajaxUtilities() {
        return _ajax.default;
      },
      get arrayUtilities() {
        return _array.default;
      },
      get asynchronousUtilities() {
        return _asynchronous.default;
      },
      get characters() {
        return _characters.default;
      },
      get contentTypes() {
        return _contentTypes.default;
      },
      get encodings() {
        return _encodings.default;
      },
      get headers() {
        return _headers.default;
      },
      get httpUtilities() {
        return _http.default;
      },
      get keyCodes() {
        return _keyCodes.default;
      },
      get levels() {
        return _levels.default;
      },
      get methods() {
        return _methods.default;
      },
      get pathUtilities() {
        return _path.default;
      },
      get statusCodes() {
        return _statusCodes.default;
      },
      get statusMessages() {
        return _statusMessages.default;
      },
      get stringUtilities() {
        return _string.default;
      },
      get versionUtilities() {
        return _version.default;
      }
    });
    var _levels = /* @__PURE__ */ _interop_require_default(require_levels());
    var _methods = /* @__PURE__ */ _interop_require_default(require_methods());
    var _headers = /* @__PURE__ */ _interop_require_default(require_headers());
    var _keyCodes = /* @__PURE__ */ _interop_require_default(require_keyCodes());
    var _encodings = /* @__PURE__ */ _interop_require_default(require_encodings());
    var _characters = /* @__PURE__ */ _interop_require_default(require_characters());
    var _statusCodes = /* @__PURE__ */ _interop_require_default(require_statusCodes());
    var _contentTypes = /* @__PURE__ */ _interop_require_default(require_contentTypes());
    var _statusMessages = /* @__PURE__ */ _interop_require_default(require_statusMessages());
    var _path = /* @__PURE__ */ _interop_require_default(require_path());
    var _http = /* @__PURE__ */ _interop_require_default(require_http());
    var _array = /* @__PURE__ */ _interop_require_default(require_array2());
    var _string = /* @__PURE__ */ _interop_require_default(require_string2());
    var _version = /* @__PURE__ */ _interop_require_default(require_version());
    var _asynchronous = /* @__PURE__ */ _interop_require_default(require_asynchronous());
    var _ajax = /* @__PURE__ */ _interop_require_default(require_ajax());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-lexers/lib/constants.js
  var require_constants3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_AMPERSAND() {
        return ESCAPED_AMPERSAND;
      },
      get ESCAPED_GREATER_THAN() {
        return ESCAPED_GREATER_THAN;
      },
      get ESCAPED_LESS_THAN() {
        return ESCAPED_LESS_THAN;
      },
      get V() {
        return V;
      }
    });
    var V = "v";
    var EMPTY_STRING = "";
    var ESCAPED_AMPERSAND = "&amp;";
    var ESCAPED_LESS_THAN = "&lt;";
    var ESCAPED_GREATER_THAN = "&gt;";
  });

  // node_modules/occam-lexers/lib/utilities/content.js
  var require_content = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "sanitiseContent", {
      enumerable: true,
      get: function() {
        return sanitiseContent;
      }
    });
    var _constants = require_constants3();
    function sanitiseContent(content) {
      const sanitisedContent = content.replace(/&/g, _constants.ESCAPED_AMPERSAND).replace(/</g, _constants.ESCAPED_LESS_THAN).replace(/>/g, _constants.ESCAPED_GREATER_THAN);
      return sanitisedContent;
    }
  });

  // node_modules/occam-lexers/lib/types.js
  var require_types = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get commentType() {
        return commentType;
      },
      get default() {
        return _default;
      },
      get endOfLineCommentType() {
        return endOfLineCommentType;
      },
      get endOfLineType() {
        return endOfLineType;
      },
      get endOfMultiLineCommentType() {
        return endOfMultiLineCommentType;
      },
      get middleOfMultiLineCommentType() {
        return middleOfMultiLineCommentType;
      },
      get nameType() {
        return nameType;
      },
      get numberType() {
        return numberType;
      },
      get regularExpressionType() {
        return regularExpressionType;
      },
      get singleLineCommentType() {
        return singleLineCommentType;
      },
      get startOfMultiLineCommentType() {
        return startOfMultiLineCommentType;
      },
      get stringLiteralType() {
        return stringLiteralType;
      },
      get typeType() {
        return typeType;
      },
      get whitespaceType() {
        return whitespaceType;
      }
    });
    var typeType = "type";
    var nameType = "name";
    var numberType = "number";
    var commentType = "comment";
    var endOfLineType = "end-of-line";
    var whitespaceType = "whitespace";
    var stringLiteralType = "string-literal";
    var endOfLineCommentType = `${endOfLineType} ${commentType}`;
    var singleLineCommentType = `single-line ${commentType}`;
    var regularExpressionType = "regular-expression";
    var endOfMultiLineCommentType = `end-of-multi-line ${commentType}`;
    var startOfMultiLineCommentType = `start-of-multi-line ${commentType}`;
    var middleOfMultiLineCommentType = `middle-of-multi-line ${commentType}`;
    var _default = {
      typeType,
      nameType,
      numberType,
      commentType,
      endOfLineType,
      whitespaceType,
      stringLiteralType,
      endOfLineCommentType,
      singleLineCommentType,
      regularExpressionType,
      endOfMultiLineCommentType,
      startOfMultiLineCommentType,
      middleOfMultiLineCommentType
    };
  });

  // node_modules/occam-lexers/lib/token.js
  var require_token = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Token;
      }
    });
    var _necessary = require_browser();
    var _content = require_content();
    var _types = require_types();
    var {first: first2} = _necessary.arrayUtilities;
    var {strlen} = _necessary.stringUtilities;
    var Token = class {
      constructor(type, content, significant) {
        this.type = type;
        this.content = content;
        this.significant = significant;
      }
      getType() {
        return this.type;
      }
      getContent() {
        return this.content;
      }
      getContentLength(naive = false) {
        const contentLength = naive ? this.content.length : strlen(this.content);
        return contentLength;
      }
      isSignificant() {
        return this.significant;
      }
      isCommentToken() {
        const typeIncludesCommentType = this.type.includes(_types.commentType), commentToken = typeIncludesCommentType;
        return commentToken;
      }
      isEndOfLineToken() {
        const typeEndOfLineType = this.type.includes(_types.endOfLineType), endOfLineToken = typeEndOfLineType;
        return endOfLineToken;
      }
      isWhitespaceToken() {
        const typeWhitespaceType = this.type === _types.whitespaceType, whitespaceToken = typeWhitespaceType;
        return whitespaceToken;
      }
      match(token) {
        let matches = false;
        if (token !== null) {
          const type = token.getType(), content = token.getContent(), significant = token.isSignificant();
          matches = this.type === type && this.content === content && this.significant === significant;
        }
        return matches;
      }
      asHTML() {
        const className = this.type, sanitisedContent = (0, _content.sanitiseContent)(this.content), html = `<span class="${className}">${sanitisedContent}</span>`;
        return html;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, type = this.type, content = this.content, significant = this.significant, token = new Class(type, content, significant, ...remainingArguments);
        return token;
      }
      static match(Class, content, significant, ...remainingArguments) {
        let token = null;
        const {regularExpression} = Class, matches = content.match(regularExpression);
        if (matches !== null) {
          const {index} = matches;
          if (index === 0) {
            const firstMatch = first2(matches);
            content = firstMatch;
            const contentLength = content.length;
            if (contentLength > 0) {
              const {type} = Class;
              token = new Class(type, content, significant, ...remainingArguments);
            }
          }
        }
        return token;
      }
      static fromContent(Class, content, significant, ...remainingArguments) {
        const {type} = Class, token = new Class(type, content, significant, ...remainingArguments);
        return token;
      }
      static fromContentAndType(Class, content, type, significant, ...remainingArguments) {
        return new Class(type, content, significant, ...remainingArguments);
      }
    };
  });

  // node_modules/occam-lexers/lib/token/significant.js
  var require_significant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantToken;
      }
    });
    var _token = /* @__PURE__ */ _interop_require_default(require_token());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantToken = class extends _token.default {
      static match(Class, content, ...remainingArguments) {
        if (content === void 0) {
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.match(Class, content, significant, ...remainingArguments);
        return significantToken;
      }
      static fromContent(Class, content, ...remainingArguments) {
        if (content === void 0) {
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.fromContent(Class, content, significant, ...remainingArguments);
        return significantToken;
      }
      static fromContentAndType(Class, content, type, ...remainingArguments) {
        if (type === void 0) {
          type = content;
          content = Class;
          Class = SignificantToken;
        }
        const significant = true, significantToken = _token.default.fromContentAndType(Class, content, type, significant, ...remainingArguments);
        return significantToken;
      }
    };
  });

  // node_modules/occam-lexers/lib/rule.js
  var require_rule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Rule;
      }
    });
    var _necessary = require_browser();
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _constants = require_constants3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var Rule = class {
      constructor(type, regularExpression) {
        this.type = type;
        this.regularExpression = regularExpression;
      }
      getType() {
        return this.type;
      }
      getRegularExpression() {
        return this.regularExpression;
      }
      match(content) {
        let significantToken = null;
        const matches = content.match(this.regularExpression);
        if (matches !== null) {
          const {index} = matches;
          if (index === 0) {
            const firstMatch = first2(matches);
            content = firstMatch;
            const contentLength = content.length;
            if (contentLength > 0) {
              significantToken = _significant.default.fromContentAndType(content, this.type);
            }
          }
        }
        return significantToken;
      }
      static fromToken(Token) {
        const {type, regularExpression} = Token, rule = new Rule(type, regularExpression);
        return rule;
      }
      static fromEntry(entry) {
        const entryKeys = Object.keys(entry), firstEntryKey = first2(entryKeys), type = firstEntryKey, regularExpressionPattern = entry[type], regularExpression = regularExpressionFromRegularExpressionPattern(regularExpressionPattern), rule = new Rule(type, regularExpression);
        return rule;
      }
      static fromTypeAndRegularExpressionPattern(type, regularExpressionPattern) {
        const regularExpression = regularExpressionFromRegularExpressionPattern(regularExpressionPattern), rule = new Rule(type, regularExpression);
        return rule;
      }
    };
    function regularExpressionFromRegularExpressionPattern(regularExpressionPattern) {
      const flags = _constants.V, regExp = new RegExp(regularExpressionPattern, flags), regularExpression = regExp;
      return regularExpression;
    }
  });

  // node_modules/occam-lexers/lib/specialSymbols.js
  var require_specialSymbols = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get asterisk() {
        return asterisk;
      },
      get closeBracket() {
        return closeBracket;
      },
      get default() {
        return _default;
      },
      get ellipsis() {
        return ellipsis;
      },
      get endOfLine() {
        return endOfLine;
      },
      get epsilon() {
        return epsilon;
      },
      get noWhitespace() {
        return noWhitespace;
      },
      get opaque() {
        return opaque;
      },
      get openBracket() {
        return openBracket;
      },
      get plus() {
        return plus;
      },
      get questionMark() {
        return questionMark;
      },
      get semiOpaque() {
        return semiOpaque;
      },
      get separator() {
        return separator;
      },
      get startOfContent() {
        return startOfContent;
      },
      get terminator() {
        return terminator;
      },
      get verticalBar() {
        return verticalBar;
      },
      get wildcard() {
        return wildcard;
      }
    });
    var plus = "+";
    var opaque = ".";
    var epsilon = "\u03B5";
    var wildcard = ".";
    var asterisk = "*";
    var ellipsis = "...";
    var separator = "::=";
    var semiOpaque = "..";
    var terminator = ";";
    var verticalBar = "|";
    var openBracket = "(";
    var closeBracket = ")";
    var questionMark = "?";
    var endOfLine = "<END_OF_LINE>";
    var noWhitespace = "<NO_WHITESPACE>";
    var startOfContent = "<START_OF_CONTENT>";
    var _default = {
      plus,
      opaque,
      epsilon,
      wildcard,
      asterisk,
      ellipsis,
      separator,
      semiOpaque,
      terminator,
      verticalBar,
      openBracket,
      closeBracket,
      questionMark,
      endOfLine,
      noWhitespace,
      startOfContent
    };
  });

  // node_modules/occam-lexers/lib/utilities/rules.js
  var require_rules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get rulesAsEntries() {
        return rulesAsEntries;
      }
    });
    function rulesAsEntries(rules) {
      const entries = rules.map((rule) => {
        const entry = ruleAsEntry(rule);
        return entry;
      });
      return entries;
    }
    var _default = {
      rulesAsEntries
    };
    function ruleAsEntry(rule) {
      const type = rule.getType(), regularExpression = rule.getRegularExpression(), {source} = regularExpression, entry = {
        [type]: source
      };
      return entry;
    }
  });

  // node_modules/occam-lexers/lib/utilities/lexer.js
  var require_lexer = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get lexerFromRules() {
        return lexerFromRules;
      },
      get rulesFromEntries() {
        return rulesFromEntries;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function rulesFromEntries(entries) {
      const rules = entries.map((entry) => {
        const rule = _rule.default.fromEntry(entry);
        return rule;
      });
      return rules;
    }
    function lexerFromRules(Class, rules) {
      const InCommentClasses = InCommentClassesFromClass(Class), NotInCommentClasses = NotInCommentClassesFromClass(Class), lexer = new Class(rules, InCommentClasses, NotInCommentClasses);
      return lexer;
    }
    var _default = {
      rulesFromEntries,
      lexerFromRules
    };
    function InCommentClassesFromClass(Class) {
      const {EndOfLineCommentToken, EndOfMultiLineCommentToken, MiddleOfMultiLineCommentToken} = Class;
      const InCommentClasses = [
        EndOfLineCommentToken,
        EndOfMultiLineCommentToken,
        MiddleOfMultiLineCommentToken
      ];
      return InCommentClasses;
    }
    function NotInCommentClassesFromClass(Class) {
      const {EndOfLineToken, WhitespaceToken, SingleLineCommentToken, RegularExpressionToken, StartOfMultiLineCommentToken, SinglyQuotedStringLiteralToken, DoublyQuotedStringLiteralToken} = Class;
      const NotInCommentClasses = [
        EndOfLineToken,
        WhitespaceToken,
        StartOfMultiLineCommentToken,
        SingleLineCommentToken,
        RegularExpressionToken,
        SinglyQuotedStringLiteralToken,
        DoublyQuotedStringLiteralToken
      ];
      return NotInCommentClasses;
    }
  });

  // node_modules/occam-lexers/lib/bnf/entries.js
  var require_entries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\||\\(|\\)|\\?|\\*|\\+|\\.\\.\\.|\\.\\.|\\.|::=|;|\u03B5|<START_OF_CONTENT>|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        number: "^(?:0|[1-9][0-9]*)"
      },
      {
        name: "^[\\w~]+"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-lexers/lib/utilities/token.js
  var require_token2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "inCommentFromTokenAndInComment", {
      enumerable: true,
      get: function() {
        return inCommentFromTokenAndInComment;
      }
    });
    function inCommentFromTokenAndInComment(token, inComment) {
      const tokenCommentToken = token.isCommentToken();
      if (tokenCommentToken) {
        const commentToken = token, commentTokenInCommentPreserving = commentToken.isInCommentPreserving();
        inComment = commentTokenInCommentPreserving;
      }
      return inComment;
    }
  });

  // node_modules/occam-lexers/lib/common/lexer.js
  var require_lexer2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CommonLexer;
      }
    });
    var _constants = require_constants3();
    var _token = require_token2();
    var _lexer = require_lexer();
    var CommonLexer = class {
      constructor(rules, InCommentClasses, NotInCommentClasses) {
        this.rules = rules;
        this.InCommentClasses = InCommentClasses;
        this.NotInCommentClasses = NotInCommentClasses;
      }
      getRules() {
        return this.rules;
      }
      getInCommentClasses() {
        return this.InCommentClasses;
      }
      getNotInCommentClasses() {
        return this.NotInCommentClasses;
      }
      tokenise(content, inComment = false) {
        const tokens = [];
        while (content !== _constants.EMPTY_STRING) {
          let token = null;
          const Classes = inComment ? this.InCommentClasses : this.NotInCommentClasses;
          Classes.some((Class) => {
            if (Class !== null) {
              token = Class.match(content);
              if (token !== null) {
                return true;
              }
            }
          });
          if (token === null) {
            let significantToken = null;
            this.rules.some((rule) => {
              significantToken = rule.match(content);
              if (significantToken !== null) {
                token = significantToken;
                return true;
              }
            });
          }
          if (token === null) {
            throw new Error(`The content '${content}' cannot be tokenised.`);
          }
          tokens.push(token);
          inComment = (0, _token.inCommentFromTokenAndInComment)(token, inComment);
          const naive = true, tokenContentLength = token.getContentLength(naive), start = tokenContentLength;
          content = content.substring(start);
        }
        return tokens;
      }
      static fromNothing(Class) {
        const {entries} = Class, rules = (0, _lexer.rulesFromEntries)(entries), lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
      static fromRules(Class, rules) {
        const lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
      static fromEntries(Class, entries) {
        const rules = (0, _lexer.rulesFromEntries)(entries), lexer = (0, _lexer.lexerFromRules)(Class, rules);
        return lexer;
      }
    };
  });

  // node_modules/occam-lexers/lib/token/nonSignificant.js
  var require_nonSignificant = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonSignificantToken;
      }
    });
    var _token = /* @__PURE__ */ _interop_require_default(require_token());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonSignificantToken = class extends _token.default {
      static match(Class, content) {
        const significant = false, nonSignificantToken = _token.default.match(Class, content, significant);
        return nonSignificantToken;
      }
      static fromContent(Class, content) {
        const significant = false, nonSignificantToken = _token.default.fromContent(Class, content, significant);
        return nonSignificantToken;
      }
      static fromContentAndType(Class, content, type) {
        const significant = false, nonSignificantToken = _token.default.fromContentAndType(Class, content, type, significant);
        return nonSignificantToken;
      }
    };
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/whitespace.js
  var require_whitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WhitespaceToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _WhitespaceToken = class extends _nonSignificant.default {
      static match(content) {
        return _nonSignificant.default.match(_WhitespaceToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_WhitespaceToken, content);
      }
    };
    var WhitespaceToken = _WhitespaceToken;
    __publicField(WhitespaceToken, "type", _types.whitespaceType);
    __publicField(WhitespaceToken, "regularExpression", /^[\t\v ]+/);
  });

  // node_modules/occam-lexers/lib/token/significant/regularExpression.js
  var require_regularExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _RegularExpressionToken = class extends _significant.default {
      static match(content) {
        return _significant.default.match(_RegularExpressionToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_RegularExpressionToken, content);
      }
    };
    var RegularExpressionToken = _RegularExpressionToken;
    __publicField(RegularExpressionToken, "type", _types.regularExpressionType);
    __publicField(RegularExpressionToken, "regularExpression", /^\/(?:\\[^\s]|[^\/\r\n\f])*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/endOfLine.js
  var require_endOfLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNonSignificantToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineNonSignificantToken = class extends _nonSignificant.default {
      asHTML() {
        const content = this.getContent(), html = content;
        return html;
      }
      static match(content) {
        return _nonSignificant.default.match(_EndOfLineNonSignificantToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_EndOfLineNonSignificantToken, content);
      }
    };
    var EndOfLineNonSignificantToken = _EndOfLineNonSignificantToken;
    __publicField(EndOfLineNonSignificantToken, "type", _types.endOfLineType);
    __publicField(EndOfLineNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral.js
  var require_stringLiteral = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralToken;
      }
    });
    var _necessary = require_browser();
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {substring} = _necessary.stringUtilities;
    var StringLiteralToken = class extends _significant.default {
      getString() {
        const content = this.getContent(), contentLength = this.getContentLength(), start = 1, end = contentLength - 1, string = substring(content, start, end);
        return string;
      }
      static match(Class, content) {
        return _significant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _significant.default.fromContent(Class, content);
      }
    };
    __publicField(StringLiteralToken, "type", _types.stringLiteralType);
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/doublyQuoted.js
  var require_doublyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DoublyQuotedStringLiteralToken;
      }
    });
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _DoublyQuotedStringLiteralToken = class extends _stringLiteral.default {
      static match(content) {
        return _stringLiteral.default.match(_DoublyQuotedStringLiteralToken, content);
      }
      static fromContent(content) {
        return _stringLiteral.default.fromContent(_DoublyQuotedStringLiteralToken, content);
      }
    };
    var DoublyQuotedStringLiteralToken = _DoublyQuotedStringLiteralToken;
    __publicField(DoublyQuotedStringLiteralToken, "regularExpression", /^"(?:\\[^\s]|[^"\\\r\n])*"/);
  });

  // node_modules/occam-lexers/lib/bnf/lexer.js
  var require_lexer3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFLexer;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BNFLexer = class extends _lexer.default {
      tokensFromBNF(bnf) {
        const content = bnf, tokens = super.tokenise(content);
        return tokens;
      }
      static fromNothing() {
        return _lexer.default.fromNothing(_BNFLexer);
      }
      static fromRules(rules) {
        return _lexer.default.fromRules(_BNFLexer, rules);
      }
      static fromEntries(entries) {
        return _lexer.default.fromEntries(_BNFLexer, entries);
      }
    };
    var BNFLexer = _BNFLexer;
    __publicField(BNFLexer, "entries", _entries.default);
    __publicField(BNFLexer, "EndOfLineToken", _endOfLine.default);
    __publicField(BNFLexer, "WhitespaceToken", _whitespace.default);
    __publicField(BNFLexer, "EndOfLineCommentToken", null);
    __publicField(BNFLexer, "RegularExpressionToken", _regularExpression.default);
    __publicField(BNFLexer, "SingleLineCommentToken", null);
    __publicField(BNFLexer, "EndOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "StartOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(BNFLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(BNFLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/basic/entries.js
  var require_entries2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        digit: "^\\d+"
      },
      {
        bracket: "^(?:\\(|\\))"
      },
      {
        operator: "^(?:\\+|-|\\*|\\/)"
      },
      {
        unassigned: "^[^\\s]"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-lexers/lib/token/significant/stringLiteral/singlyQuoted.js
  var require_singlyQuoted = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SinglyQuotedStringLiteralToken;
      }
    });
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _SinglyQuotedStringLiteralToken = class extends _stringLiteral.default {
      static match(content) {
        return _stringLiteral.default.match(_SinglyQuotedStringLiteralToken, content);
      }
      static fromContent(content) {
        return _stringLiteral.default.fromContent(_SinglyQuotedStringLiteralToken, content);
      }
    };
    var SinglyQuotedStringLiteralToken = _SinglyQuotedStringLiteralToken;
    __publicField(SinglyQuotedStringLiteralToken, "regularExpression", /^'(?:\\[^\s]|[^'\\\r\n])*'/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine.js
  var require_singleLine = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SingleLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SingleLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = false;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(SingleLineCommentToken, "type", _types.singleLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/pythonStyle.js
  var require_pythonStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleSingleLineCommentToken;
      }
    });
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleSingleLineCommentToken = class extends _singleLine.default {
      static match(content) {
        return _singleLine.default.match(_PythonStyleSingleLineCommentToken, content);
      }
      static fromContent(content) {
        return _singleLine.default.fromContent(_PythonStyleSingleLineCommentToken, content);
      }
    };
    var PythonStyleSingleLineCommentToken = _PythonStyleSingleLineCommentToken;
    __publicField(PythonStyleSingleLineCommentToken, "regularExpression", /^#[^\r\n\f]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/endOfLine.js
  var require_endOfLine2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineCommentNonSignificantToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineCommentNonSignificantToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(content) {
        return _nonSignificant.default.match(_EndOfLineCommentNonSignificantToken, content);
      }
      static fromContent(content) {
        return _nonSignificant.default.fromContent(_EndOfLineCommentNonSignificantToken, content);
      }
    };
    var EndOfLineCommentNonSignificantToken = _EndOfLineCommentNonSignificantToken;
    __publicField(EndOfLineCommentNonSignificantToken, "type", _types.endOfLineCommentType);
    __publicField(EndOfLineCommentNonSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf.js
  var require_endOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = false;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(EndOfMultiLineCommentToken, "type", _types.endOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/pythonStyle.js
  var require_pythonStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleEndOfMultiLineCommentToken;
      }
    });
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleEndOfMultiLineCommentToken = class extends _endOf.default {
      static match(content) {
        return _endOf.default.match(_PythonStyleEndOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _endOf.default.fromContent(_PythonStyleEndOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleEndOfMultiLineCommentToken = _PythonStyleEndOfMultiLineCommentToken;
    __publicField(PythonStyleEndOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf.js
  var require_startOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(StartOfMultiLineCommentToken, "type", _types.startOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/pythonStyle.js
  var require_pythonStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleStartOfMultiLineCommentToken;
      }
    });
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleStartOfMultiLineCommentToken = class extends _startOf.default {
      static match(content) {
        return _startOf.default.match(_PythonStyleStartOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _startOf.default.fromContent(_PythonStyleStartOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleStartOfMultiLineCommentToken = _PythonStyleStartOfMultiLineCommentToken;
    __publicField(PythonStyleStartOfMultiLineCommentToken, "regularExpression", /^###/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf.js
  var require_middleOf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return MiddleOfMultiLineCommentToken;
      }
    });
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var MiddleOfMultiLineCommentToken = class extends _nonSignificant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(Class, content) {
        return _nonSignificant.default.match(Class, content);
      }
      static fromContent(Class, content) {
        return _nonSignificant.default.fromContent(Class, content);
      }
    };
    __publicField(MiddleOfMultiLineCommentToken, "type", _types.middleOfMultiLineCommentType);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/pythonStyle.js
  var require_pythonStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PythonStyleMiddleOfMultiLineCommentToken;
      }
    });
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PythonStyleMiddleOfMultiLineCommentToken = class extends _middleOf.default {
      static match(content) {
        return _middleOf.default.match(_PythonStyleMiddleOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _middleOf.default.fromContent(_PythonStyleMiddleOfMultiLineCommentToken, content);
      }
    };
    var PythonStyleMiddleOfMultiLineCommentToken = _PythonStyleMiddleOfMultiLineCommentToken;
    __publicField(PythonStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n\f]+?(?=###)|[^\r\n\f]+)/);
  });

  // node_modules/occam-lexers/lib/basic/lexer.js
  var require_lexer4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BasicLexer;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries2());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _singlyQuoted = /* @__PURE__ */ _interop_require_default(require_singlyQuoted());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    var _pythonStyle = /* @__PURE__ */ _interop_require_default(require_pythonStyle());
    var _endOfLine1 = /* @__PURE__ */ _interop_require_default(require_endOfLine2());
    var _pythonStyle1 = /* @__PURE__ */ _interop_require_default(require_pythonStyle2());
    var _pythonStyle2 = /* @__PURE__ */ _interop_require_default(require_pythonStyle3());
    var _pythonStyle3 = /* @__PURE__ */ _interop_require_default(require_pythonStyle4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BasicLexer = class extends _lexer.default {
      static fromNothing() {
        return _lexer.default.fromNothing(_BasicLexer);
      }
      static fromRules(rules) {
        return _lexer.default.fromRules(_BasicLexer, rules);
      }
      static fromEntries(entries) {
        return _lexer.default.fromEntries(_BasicLexer, entries);
      }
    };
    var BasicLexer = _BasicLexer;
    __publicField(BasicLexer, "entries", _entries.default);
    __publicField(BasicLexer, "EndOfLineToken", _endOfLine.default);
    __publicField(BasicLexer, "WhitespaceToken", _whitespace.default);
    __publicField(BasicLexer, "EndOfLineCommentToken", _endOfLine1.default);
    __publicField(BasicLexer, "RegularExpressionToken", _regularExpression.default);
    __publicField(BasicLexer, "SingleLineCommentToken", _pythonStyle.default);
    __publicField(BasicLexer, "EndOfMultiLineCommentToken", _pythonStyle1.default);
    __publicField(BasicLexer, "StartOfMultiLineCommentToken", _pythonStyle2.default);
    __publicField(BasicLexer, "MiddleOfMultiLineCommentToken", _pythonStyle3.default);
    __publicField(BasicLexer, "SinglyQuotedStringLiteralToken", _singlyQuoted.default);
    __publicField(BasicLexer, "DoublyQuotedStringLiteralToken", _doublyQuoted.default);
  });

  // node_modules/occam-lexers/lib/token/significant/endOfLine.js
  var require_endOfLine3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineSignificantToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineSignificantToken = class extends _significant.default {
      asHTML() {
        const content = this.getContent(), html = content;
        return html;
      }
      static match(content) {
        return _significant.default.match(_EndOfLineSignificantToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_EndOfLineSignificantToken, content);
      }
    };
    var EndOfLineSignificantToken = _EndOfLineSignificantToken;
    __publicField(EndOfLineSignificantToken, "type", _types.endOfLineType);
    __publicField(EndOfLineSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/significant/comment/endOfLine.js
  var require_endOfLine4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineCommentSignificantToken;
      }
    });
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _types = require_types();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _EndOfLineCommentSignificantToken = class extends _significant.default {
      isInCommentPreserving() {
        const inCommentPreserving = true;
        return inCommentPreserving;
      }
      static match(content) {
        return _significant.default.match(_EndOfLineCommentSignificantToken, content);
      }
      static fromContent(content) {
        return _significant.default.fromContent(_EndOfLineCommentSignificantToken, content);
      }
    };
    var EndOfLineCommentSignificantToken = _EndOfLineCommentSignificantToken;
    __publicField(EndOfLineCommentSignificantToken, "type", _types.endOfLineCommentType);
    __publicField(EndOfLineCommentSignificantToken, "regularExpression", /^(?:\r\n|\r|\n|\f)/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/singleLine/cStyle.js
  var require_cStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleSingleLineCommentToken;
      }
    });
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleSingleLineCommentToken = class extends _singleLine.default {
      static match(content) {
        return _singleLine.default.match(_CStyleSingleLineCommentToken, content);
      }
      static fromContent(content) {
        return _singleLine.default.fromContent(_CStyleSingleLineCommentToken, content);
      }
    };
    var CStyleSingleLineCommentToken = _CStyleSingleLineCommentToken;
    __publicField(CStyleSingleLineCommentToken, "regularExpression", /^\/\/[^\r\n\f]*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/endOf/cStyle.js
  var require_cStyle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleEndOfMultiLineCommentToken;
      }
    });
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleEndOfMultiLineCommentToken = class extends _endOf.default {
      static match(content) {
        return _endOf.default.match(_CStyleEndOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _endOf.default.fromContent(_CStyleEndOfMultiLineCommentToken, content);
      }
    };
    var CStyleEndOfMultiLineCommentToken = _CStyleEndOfMultiLineCommentToken;
    __publicField(CStyleEndOfMultiLineCommentToken, "regularExpression", /^\*\//);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/startOf/cStyle.js
  var require_cStyle3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleStartOfMultiLineCommentToken;
      }
    });
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleStartOfMultiLineCommentToken = class extends _startOf.default {
      static match(content) {
        return _startOf.default.match(_CStyleStartOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _startOf.default.fromContent(_CStyleStartOfMultiLineCommentToken, content);
      }
    };
    var CStyleStartOfMultiLineCommentToken = _CStyleStartOfMultiLineCommentToken;
    __publicField(CStyleStartOfMultiLineCommentToken, "regularExpression", /^\/\*/);
  });

  // node_modules/occam-lexers/lib/token/nonSignificant/comment/multiLine/middleOf/cStyle.js
  var require_cStyle4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CStyleMiddleOfMultiLineCommentToken;
      }
    });
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CStyleMiddleOfMultiLineCommentToken = class extends _middleOf.default {
      static match(content) {
        return _middleOf.default.match(_CStyleMiddleOfMultiLineCommentToken, content);
      }
      static fromContent(content) {
        return _middleOf.default.fromContent(_CStyleMiddleOfMultiLineCommentToken, content);
      }
    };
    var CStyleMiddleOfMultiLineCommentToken = _CStyleMiddleOfMultiLineCommentToken;
    __publicField(CStyleMiddleOfMultiLineCommentToken, "regularExpression", /^(?:[^\r\n\f]+?(?=\*\/)|[^\r\n\f]+)/);
  });

  // node_modules/occam-lexers/lib/index.js
  var require_lib3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BNFLexer() {
        return _lexer1.default;
      },
      get BasicLexer() {
        return _lexer2.default;
      },
      get CStyleEndOfMultiLineCommentToken() {
        return _cStyle1.default;
      },
      get CStyleMiddleOfMultiLineCommentToken() {
        return _cStyle3.default;
      },
      get CStyleSingleLineCommentToken() {
        return _cStyle.default;
      },
      get CStyleStartOfMultiLineCommentToken() {
        return _cStyle2.default;
      },
      get CommonLexer() {
        return _lexer3.default;
      },
      get DoublyQuotedStringLiteralToken() {
        return _doublyQuoted.default;
      },
      get EndOfLineCommentNonSignificantToken() {
        return _endOfLine3.default;
      },
      get EndOfLineCommentSignificantToken() {
        return _endOfLine2.default;
      },
      get EndOfLineNonSignificantToken() {
        return _endOfLine1.default;
      },
      get EndOfLineSignificantToken() {
        return _endOfLine.default;
      },
      get EndOfMultiLineCommentToken() {
        return _endOf.default;
      },
      get MiddleOfMultiLineCommentToken() {
        return _middleOf.default;
      },
      get NonSignificantToken() {
        return _nonSignificant.default;
      },
      get PythonStyleEndOfMultiLineCommentToken() {
        return _pythonStyle1.default;
      },
      get PythonStyleMiddleOfMultiLineCommentToken() {
        return _pythonStyle3.default;
      },
      get PythonStyleSingleLineCommentToken() {
        return _pythonStyle.default;
      },
      get PythonStyleStartOfMultiLineCommentToken() {
        return _pythonStyle2.default;
      },
      get RegularExpressionToken() {
        return _regularExpression.default;
      },
      get Rule() {
        return _rule.default;
      },
      get SignificantToken() {
        return _significant.default;
      },
      get SingleLineCommentToken() {
        return _singleLine.default;
      },
      get SinglyQuotedStringLiteralToken() {
        return _singlyQuoted.default;
      },
      get StartOfMultiLineCommentToken() {
        return _startOf.default;
      },
      get StringLiteralToken() {
        return _stringLiteral.default;
      },
      get WhitespaceToken() {
        return _whitespace.default;
      },
      get lexerUtilities() {
        return _lexer.default;
      },
      get rulesUtilities() {
        return _rules.default;
      },
      get specialSymbols() {
        return _specialSymbols.default;
      },
      get types() {
        return _types.default;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule());
    var _types = /* @__PURE__ */ _interop_require_default(require_types());
    var _specialSymbols = /* @__PURE__ */ _interop_require_default(require_specialSymbols());
    var _rules = /* @__PURE__ */ _interop_require_default(require_rules());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer());
    var _lexer1 = /* @__PURE__ */ _interop_require_default(require_lexer3());
    var _lexer2 = /* @__PURE__ */ _interop_require_default(require_lexer4());
    var _lexer3 = /* @__PURE__ */ _interop_require_default(require_lexer2());
    var _significant = /* @__PURE__ */ _interop_require_default(require_significant());
    var _nonSignificant = /* @__PURE__ */ _interop_require_default(require_nonSignificant());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine3());
    var _endOfLine1 = /* @__PURE__ */ _interop_require_default(require_endOfLine());
    var _endOfLine2 = /* @__PURE__ */ _interop_require_default(require_endOfLine4());
    var _endOfLine3 = /* @__PURE__ */ _interop_require_default(require_endOfLine2());
    var _whitespace = /* @__PURE__ */ _interop_require_default(require_whitespace());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression());
    var _singlyQuoted = /* @__PURE__ */ _interop_require_default(require_singlyQuoted());
    var _doublyQuoted = /* @__PURE__ */ _interop_require_default(require_doublyQuoted());
    var _singleLine = /* @__PURE__ */ _interop_require_default(require_singleLine());
    var _endOf = /* @__PURE__ */ _interop_require_default(require_endOf());
    var _startOf = /* @__PURE__ */ _interop_require_default(require_startOf());
    var _middleOf = /* @__PURE__ */ _interop_require_default(require_middleOf());
    var _cStyle = /* @__PURE__ */ _interop_require_default(require_cStyle());
    var _cStyle1 = /* @__PURE__ */ _interop_require_default(require_cStyle2());
    var _cStyle2 = /* @__PURE__ */ _interop_require_default(require_cStyle3());
    var _cStyle3 = /* @__PURE__ */ _interop_require_default(require_cStyle4());
    var _pythonStyle = /* @__PURE__ */ _interop_require_default(require_pythonStyle());
    var _pythonStyle1 = /* @__PURE__ */ _interop_require_default(require_pythonStyle2());
    var _pythonStyle2 = /* @__PURE__ */ _interop_require_default(require_pythonStyle3());
    var _pythonStyle3 = /* @__PURE__ */ _interop_require_default(require_pythonStyle4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/entries.js
  var require_entries3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        media: "^@media"
      },
      {
        keyframes: "^@keyframes"
      },
      {
        colour: "^#(?:[0-9a-fA-F]{6}|[0-9a-fA-F]{3})"
      },
      {
        important: "^!important"
      },
      {
        percentage: "^(?:[0-9]+|[0-9]*\\.[0-9]+)%"
      },
      {
        frequency: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:hz|khz)"
      },
      {
        fraction: "^[1-9][0-9]*?fr"
      },
      {
        length: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:px|cm|mm|in|pt|pc)"
      },
      {
        angle: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:deg|rad|grad)"
      },
      {
        time: "^(?:[0-9]+|[0-9]*\\.[0-9]+)(?:s|ms)"
      },
      {
        rems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)rem"
      },
      {
        ems: "^(?:[0-9]+|[0-9]*\\.[0-9]+)em"
      },
      {
        number: "^[0-9]+|[0-9]*\\.[0-9]+"
      },
      {
        special: "^;|::|:|\\.|,|\\|=|~=|=|>|\\{|\\}|\\(|\\)|\\[|\\]"
      },
      {
        identifier: "^[_a-zA-Z0-9\\-]+"
      },
      {
        "logical-operator": "^(?:and|not)$"
      },
      {
        "plus-or-minus": "^[\\+\\-]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/with-style/lib/css/lexer.js
  var require_lexer5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CSSLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries3());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CSSLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CSSLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CSSLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CSSLexer, entries);
      }
    };
    var CSSLexer = _CSSLexer;
    __publicField(CSSLexer, "entries", _entries.default);
    __publicField(CSSLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(CSSLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CSSLexer, "EndOfLineCommentToken", null);
    __publicField(CSSLexer, "RegularExpressionToken", null);
    __publicField(CSSLexer, "SingleLineCommentToken", null);
    __publicField(CSSLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CSSLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CSSLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-parsers/lib/bnf/bnf.js
  var require_bnf = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

      document                 ::=  ( rule | error )+ ;

      rule                     ::=  name opacityModifier? "::=" definitions ";" ;

      name                     ::=  [name] ;

      definitions              ::=  definition ( "|" definition )* ;

      definition               ::=  part+ precedence? ;
 
      part                     ::=  nonTerminalPart quantifier*

                                 |  terminalPart quantifier*

                                 ;

      nonTerminalPart          ::=  choiceOfParts

                                 |  sequenceOfParts

                                 |  ruleName callAheadModifier?

                                 ;

      terminalPart             ::=  significantTokenType
  
                                 |  regularExpression
 
                                 |  stringLiteral
  
                                 |  endOfLine
  
                                 |  wildcard
  
                                 |  epsilon

                                 |  noWhitespace
                              
                                 |  startOfContent

                                 ;
                              
      sequenceOfParts          ::=  "(" part part+ ")" ;

      choiceOfParts            ::=  "(" partChoice ( "|" partChoice )+ ")" ;

      partChoice               ::=  part precedence? ;

      ruleName                 ::=  [name] ;

      significantTokenType     ::=  [type] ;

      regularExpression        ::=  [regular-expression] ;

      stringLiteral            ::=  [string-literal] ;

      precedence               ::=  "(" [number]? ")" ;
      
      endOfLine                ::=  "<END_OF_LINE>" ;
      
      wildcard                 ::=  "." ;

      epsilon                  ::=  "\u03B5" ;

      noWhitespace             ::=  "<NO_WHITESPACE>" ;                              

      startOfContent           ::+  "<START_OF_CONTENT>"; 
      
      quantifier               ::=  optionalQuantifier
 
                                 |  oneOrMoreQuantifier
  
                                 |  zeroOrMoreQuantifier
  
                                 ;

      opacityModifier          ::=  <NO_WHITESPACE>( "." | ".." );
      
      callAheadModifier        ::=  <NO_WHITESPACE>"..." ;

      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;

      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;

      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;

      error.                   ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-parsers/lib/constants.js
  var require_constants4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_BACKSLASH() {
        return ESCAPED_BACKSLASH;
      },
      get ESCAPED_DOUBLE_QUOTE() {
        return ESCAPED_DOUBLE_QUOTE;
      }
    });
    var EMPTY_STRING = "";
    var ESCAPED_BACKSLASH = "\\";
    var ESCAPED_DOUBLE_QUOTE = '"';
  });

  // node_modules/occam-parsers/lib/utilities/string.js
  var require_string3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "paddingFromPaddingLength", {
      enumerable: true,
      get: function() {
        return paddingFromPaddingLength;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {SPACE_CHARACTER} = _necessary.characters;
    function paddingFromPaddingLength(paddingLength) {
      let padding = _constants.EMPTY_STRING;
      for (let position = 0; position < paddingLength; position++) {
        padding += SPACE_CHARACTER;
      }
      return padding;
    }
  });

  // node_modules/occam-parsers/lib/rule.js
  var require_rule2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Rule;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var _occamlexers = require_lib3();
    var _string = require_string3();
    var {clear} = _necessary.arrayUtilities;
    var {opaque: opaqueSpecialSymbol, semiOpaque: semiOpaqueSpecialSymbol} = _occamlexers.specialSymbols;
    var Rule = class {
      constructor(name, opacity, definitions) {
        this.name = name;
        this.opacity = opacity;
        this.definitions = definitions;
      }
      getName() {
        return this.name;
      }
      getOpacity() {
        return this.opacity;
      }
      getDefinitions() {
        return this.definitions;
      }
      setName(name) {
        this.name = name;
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      setDefinitions(definitions) {
        this.definitions = definitions;
      }
      isOpaque() {
        const opaque = this.opacity === opaqueSpecialSymbol;
        return opaque;
      }
      isSemiOpaque() {
        const semiOpaque = this.opacity === semiOpaqueSpecialSymbol;
        return semiOpaque;
      }
      isTransparent() {
        const semiOpaque = this.opacity === null;
        return semiOpaque;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const opacity = this.opacity, ruleName = this.name, precedence = null, childNodes = [], NonTerminalNode = this.NonTerminalNodeFromRuleName(ruleName, state), nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), savedPrecedence = state.getSavedPrecedence();
        let node = nonTerminalNode;
        nodes.push(node);
        parsed = this.definitions.some((definition) => {
          let parsed2;
          clear(childNodes);
          const precedence2 = definition.getPrecedence();
          state.setPrecedence(precedence2);
          callback = () => {
            let parsed3;
            const precedence3 = state.getPrecedence();
            nonTerminalNode.setPrecedence(precedence3);
            parsed3 = true;
            if (parsed3) {
              node.setChildNodesParentNode();
            }
            const rewrittenNonTerminalNode = nonTerminalNode.rewrite(state);
            if (rewrittenNonTerminalNode !== null) {
              if (parsed3) {
                nodes.pop();
                node = rewrittenNonTerminalNode;
                nodes.push(node);
              }
            }
            if (parsed3) {
              const empty = node.isEmpty();
              if (empty) {
                parsed3 = false;
              }
            }
            if (parsed3) {
              const unprecedented = node.isUnprecedented();
              if (unprecedented) {
                parsed3 = false;
              }
            }
            if (parsed3) {
              if (callAhead !== null) {
                state.resetPrecedence(savedPrecedence);
                parsed3 = callAhead();
              }
            }
            if (rewrittenNonTerminalNode !== null) {
              if (!parsed3) {
                nodes.pop();
                node = nonTerminalNode;
                nodes.push(node);
              }
            }
            if (!parsed3) {
              node.resetChildNodesParentNode();
            }
            return parsed3;
          };
          parsed2 = definition.parse(childNodes, state, callback, callAhead);
          if (!parsed2) {
            state.resetPrecedence(savedPrecedence);
          }
          return parsed2;
        });
        if (!parsed) {
          nodes.pop();
        }
        if (callAhead === null) {
          state.resetPrecedence(savedPrecedence);
        }
        return parsed;
      }
      NonTerminalNodeFromRuleName(ruleName, state) {
        return state.NonTerminalNodeFromRuleName(ruleName);
      }
      asString(maximumRuleNameLength, multiLine = true) {
        const definitionsLength = this.definitions.length;
        multiLine = multiLine && definitionsLength > 1;
        const maximumPadding = (0, _string.paddingFromPaddingLength)(maximumRuleNameLength), definitionsString = this.definitions.reduce((definitionsString2, definition) => {
          const definitionString = definition.asString();
          if (definitionsString2 === _constants.EMPTY_STRING) {
            definitionsString2 = definitionString;
          } else {
            definitionsString2 = multiLine ? `${definitionsString2}

${maximumPadding}   | ${definitionString}` : `${definitionsString2} | ${definitionString}`;
          }
          return definitionsString2;
        }, _constants.EMPTY_STRING), ruleName = this.name, ruleNameLength = ruleName.length, opacityString = this.opacity === null ? _constants.EMPTY_STRING : this.opacity, opacityStringLength = opacityString.length, paddingLength = maximumRuleNameLength - ruleNameLength - opacityStringLength, padding = (0, _string.paddingFromPaddingLength)(paddingLength);
        const semicolonString = multiLine ? `

${maximumPadding}   ;` : " ;", string = `

${this.name}${opacityString}${padding} ::= ${definitionsString}${semicolonString}`;
        return string;
      }
      static fromNameOpacityAndDefinitions(Class, name, opacity, definitions) {
        if (definitions === void 0) {
          definitions = opacity;
          opacity = name;
          name = Class;
          Class = Rule;
        }
        const rule = new Class(name, opacity, definitions);
        return rule;
      }
    };
  });

  // node_modules/occam-parsers/lib/mixins/node.js
  var require_node = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var {push, first: first2, forwardsSome, backwardsSome} = _necessary.arrayUtilities;
    function getMultiplicity() {
      const childNodesLength = this.childNodes.length, multiplicity = childNodesLength;
      return multiplicity;
    }
    function mapChildNode(callback) {
      return this.childNodes.map(callback);
    }
    function someChildNode(callback) {
      return this.childNodes.some(callback);
    }
    function findChildNode(callback) {
      return this.childNodes.find(callback);
    }
    function everyChildNode(callback) {
      return this.childNodes.every(callback);
    }
    function filterChildNode(callback) {
      return this.childNodes.filter(callback);
    }
    function reduceChildNode(callback, initialValue) {
      return this.childNodes.reduce(callback, initialValue);
    }
    function forEachChildNode(callback) {
      this.childNodes.forEach(callback);
    }
    function forwardsSomeChildNode(callback) {
      return forwardsSome(this.childNodes, callback);
    }
    function backwardsSomeChildNode(callback) {
      return backwardsSome(this.childNodes, callback);
    }
    function indexOfChildNode(childNode) {
      return this.childNodes.indexOf(childNode);
    }
    function setChildNodesParentNode(childNodes) {
      if (childNodes === void 0) {
        childNodes = [
          ...this.childNodes
        ];
      }
      const parentNode = this;
      childNodes.forEach((childNode) => {
        childNode.setParentNode(parentNode);
      });
    }
    function resetChildNodesParentNode(childNodes) {
      if (childNodes === void 0) {
        childNodes = [
          ...this.childNodes
        ];
      }
      const parentNode = null;
      childNodes.forEach((childNode) => {
        childNode.setParentNode(parentNode);
      });
    }
    function addChildNode(addedChildNode, startIndex) {
      const addedChildNodes = [
        addedChildNode
      ];
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function addChildNodes(addedChildNodes, startIndex) {
      const deleteCount = 0;
      this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
    }
    function removeChildNode(removedChildNode) {
      let removedChildNodes;
      removedChildNodes = [
        removedChildNode
      ];
      removedChildNodes = this.removeChildNodes(removedChildNodes);
      return removedChildNodes;
    }
    function removeChildNodes(removedChildNodes) {
      if (removedChildNodes === void 0) {
        removedChildNodes = [
          ...this.childNodes
        ];
      }
      const removedChildNodesLength = removedChildNodes.length;
      if (removedChildNodesLength > 0) {
        const firstReplacedChildNode = first2(removedChildNodes), startIndex = this.childNodes.indexOf(firstReplacedChildNode), deleteCount = removedChildNodesLength, addedChildNodes = [];
        removedChildNodes = this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
      }
      return removedChildNodes;
    }
    function replaceChildNode(replacedChildNode, replacementChildNodes) {
      const replacedChildNodes = [
        replacedChildNode
      ];
      this.replaceChildNodes(replacedChildNodes, replacementChildNodes);
    }
    function replaceChildNodes(replacedChildNodes, replacementChildNodes) {
      const replacedChildNodesLength = replacedChildNodes.length, firstReplacedChildNode = first2(replacedChildNodes), startIndex = this.childNodes.indexOf(firstReplacedChildNode), deleteCount = replacedChildNodesLength;
      this.spliceChildNodes(startIndex, deleteCount, replacementChildNodes);
    }
    function appendChildNode(appendedChildNode) {
      const appendedChildNodes = [
        appendedChildNode
      ];
      this.appendChildNodes(appendedChildNodes);
    }
    function appendChildNodes(appendedChildNodes) {
      const addedChildNodes = appendedChildNodes, multiplicity = this.getMultiplicity(), startIndex = multiplicity;
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function prependChildNode(prependedChildNode) {
      const prependedChildNodes = [
        prependedChildNode
      ];
      this.prependChildNodes(prependedChildNodes);
    }
    function prependChildNodes(prependedChildNodes) {
      const addedChildNodes = prependedChildNodes, startIndex = 0;
      this.addChildNodes(addedChildNodes, startIndex);
    }
    function spliceChildNodes(startIndex, deleteCount, addedChildNodes = []) {
      const removedChildNodes = this.childNodes.splice(startIndex, deleteCount, ...addedChildNodes);
      this.resetChildNodesParentNode(removedChildNodes);
      this.setChildNodesParentNode(addedChildNodes);
      return removedChildNodes;
    }
    function sliceChildNodes(startIndex, endIndex = Infinity) {
      const childNodes = this.childNodes.slice(startIndex, endIndex);
      return childNodes;
    }
    function getAncestorNodes() {
      const ancestorNodes = [];
      let ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        ancestorNodes.push(ancestorNode);
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
      }
      return ancestorNodes;
    }
    function mapAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.map(callback);
    }
    function someAncestorNode(callback) {
      let result = false;
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        result = !!callback(ancestorNode, index);
        if (result) {
          break;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      return result;
    }
    function findAncestorNode(callback) {
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        const result = callback(ancestorNode, index);
        if (result) {
          return ancestorNode;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      ancestorNode = void 0;
      return ancestorNode;
    }
    function everyAncestorNode(callback) {
      let result = true;
      let index = 0, ancestorNode = this.parentNode;
      while (ancestorNode !== null) {
        result = !!callback(ancestorNode, index);
        if (!result) {
          break;
        }
        const parentNode = ancestorNode.getParentNode();
        ancestorNode = parentNode;
        index++;
      }
      return result;
    }
    function filterAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.filter(callback);
    }
    function reduceAncestorNode(callback, initialValue) {
      const ancestorNodes = this.getAncestorNodes();
      return ancestorNodes.reduce(callback, initialValue);
    }
    function forEachAncestorNode(callback) {
      const ancestorNodes = this.getAncestorNodes();
      ancestorNodes.forEach(callback);
    }
    function getDescendantNodes(descendantNodes = []) {
      push(descendantNodes, this.childNodes);
      this.forEachChildNode((childNode) => {
        childNode.getDescendantNodes(descendantNodes);
      });
      return descendantNodes;
    }
    function mapDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.map(callback);
    }
    function someDescendantNode(callback) {
      let result = false;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        const childNode = this.childNodes[index], descendantNode = childNode;
        result = !!callback(descendantNode);
        if (result) {
          break;
        }
        result = childNode.someDescendantNode(callback);
        if (result) {
          break;
        }
      }
      return result;
    }
    function findDescendantNode(callback) {
      let descendantNode = void 0;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        let result;
        const childNode = this.childNodes[index];
        descendantNode = childNode;
        result = callback(descendantNode);
        if (result) {
          break;
        }
        descendantNode = childNode.findDescendantNode(callback);
        if (descendantNode !== void 0) {
          break;
        }
      }
      return descendantNode;
    }
    function everyDescendantNode(callback) {
      let result = true;
      const childNodesLength = this.childNodes.length;
      for (let index = 0; index < childNodesLength; index++) {
        const childNode = this.childNodes[index], descendantNode = childNode;
        result = !!callback(descendantNode);
        if (!result) {
          break;
        }
        result = childNode.everyDescendantNode(callback);
        if (!result) {
          break;
        }
      }
      return result;
    }
    function filterDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.filter(callback);
    }
    function reduceDescendantNode(callback, initialValue) {
      const descendantNodes = this.getDescendantNodes();
      return descendantNodes.reduce(callback, initialValue);
    }
    function forEachDescendantNode(callback) {
      const descendantNodes = this.getDescendantNodes();
      descendantNodes.forEach(callback);
    }
    var nodeMixins = {
      getMultiplicity,
      mapChildNode,
      someChildNode,
      findChildNode,
      everyChildNode,
      filterChildNode,
      reduceChildNode,
      forEachChildNode,
      forwardsSomeChildNode,
      backwardsSomeChildNode,
      indexOfChildNode,
      setChildNodesParentNode,
      resetChildNodesParentNode,
      addChildNode,
      addChildNodes,
      removeChildNode,
      removeChildNodes,
      replaceChildNode,
      replaceChildNodes,
      appendChildNode,
      appendChildNodes,
      prependChildNode,
      prependChildNodes,
      spliceChildNodes,
      sliceChildNodes,
      getAncestorNodes,
      mapAncestorNode,
      someAncestorNode,
      findAncestorNode,
      everyAncestorNode,
      filterAncestorNode,
      reduceAncestorNode,
      forEachAncestorNode,
      getDescendantNodes,
      mapDescendantNode,
      someDescendantNode,
      findDescendantNode,
      everyDescendantNode,
      filterDescendantNode,
      reduceDescendantNode,
      forEachDescendantNode
    };
    var _default = nodeMixins;
  });

  // node_modules/occam-parsers/lib/parseTree.js
  var require_parseTree = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParseTree;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {last} = _necessary.arrayUtilities;
    var {NEW_LINE_CHARACTER, SPACE_CHARACTER} = _necessary.characters;
    var ParseTree = class {
      constructor(lines) {
        this.lines = lines;
      }
      clone() {
        const lines = this.lines.slice(), parseTree = new ParseTree(lines);
        return parseTree;
      }
      getWidth() {
        let width;
        let linesLength = this.lines.length;
        if (linesLength === 0) {
          width = 0;
        } else {
          const lastLine = last(this.lines), lastLineLength = lastLine.length;
          width = lastLineLength;
        }
        return width;
      }
      getDepth() {
        const linesLength = this.lines.length, depth = linesLength;
        return depth;
      }
      forEachLine(callback) {
        this.lines.forEach(callback);
      }
      appendToTop(parseTree) {
        parseTree.forEachLine((line) => {
          this.lines.unshift(line);
        });
      }
      appendToLeft(parseTree) {
        parseTree.forEachLine((line, index) => {
          this.lines[index] = line + this.lines[index];
        });
      }
      appendToRight(parseTree) {
        parseTree.forEachLine((line, index) => {
          this.lines[index] = this.lines[index] + line;
        });
      }
      appendToBottom(parseTree) {
        parseTree.forEachLine((line) => {
          this.lines.push(line);
        });
      }
      addTopMargin(topMarginDepth) {
        const width = this.getWidth(), topMarginWidth = width, topMarginString = marginStringFromMarginWidth(topMarginWidth);
        for (let index = 0; index < topMarginDepth; index++) {
          this.lines.unshift(topMarginString);
        }
      }
      addLeftMargin(leftMarginWidth) {
        const leftMarginString = marginStringFromMarginWidth(leftMarginWidth), linesLength = this.lines.length;
        for (let index = 0; index < linesLength; index++) {
          this.lines[index] = leftMarginString + this.lines[index];
        }
      }
      addRightMargin(rightMarginWidth) {
        const rightMarginString = marginStringFromMarginWidth(rightMarginWidth), linesLength = this.lines.length;
        for (let index = 0; index < linesLength; index++) {
          this.lines[index] = this.lines[index] + rightMarginString;
        }
      }
      addBottomMargin(bottomMarginDepth) {
        const width = this.getWidth(), bottomMarginWidth = width, bottomMarginString = marginStringFromMarginWidth(bottomMarginWidth);
        for (let index = 0; index < bottomMarginDepth; index++) {
          this.lines.push(bottomMarginString);
        }
      }
      popLine() {
        return this.lines.pop();
      }
      shiftLine() {
        return this.lines.shift();
      }
      pushLine(line) {
        this.lines.push(line);
      }
      unshiftLine(line) {
        this.lines.unshift(line);
      }
      asString() {
        const string = this.lines.reduce((string2, line) => {
          string2 += line + NEW_LINE_CHARACTER;
          return string2;
        }, _constants.EMPTY_STRING);
        return string;
      }
    };
    function marginStringFromMarginWidth(marginWidth, spaceCharacter) {
      spaceCharacter = spaceCharacter || SPACE_CHARACTER;
      let marginString = _constants.EMPTY_STRING;
      for (let index = 0; index < marginWidth; index++) {
        marginString += spaceCharacter;
      }
      return marginString;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/verticalBranch.js
  var require_verticalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VerticalBranchParseTree;
      }
    });
    var _necessary = require_browser();
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {BAR_CHARACTER} = _necessary.characters;
    var VerticalBranchParseTree = class extends _parseTree.default {
      constructor(lines, verticalBranchPosition) {
        super(lines);
        this.verticalBranchPosition = verticalBranchPosition;
      }
      getVerticalBranchPosition() {
        return this.verticalBranchPosition;
      }
      addLeftMargin(leftMarginWidth) {
        super.addLeftMargin(leftMarginWidth);
        this.verticalBranchPosition += leftMarginWidth;
      }
      static fromWidth(width) {
        const string = BAR_CHARACTER, verticalBranchPosition = 0, verticalBranchParseTree = VerticalBranchParseTree.fromStringAndVerticalBranchPosition(VerticalBranchParseTree, string, verticalBranchPosition), leftMarginWidth = Math.floor(width / 2), rightMarginWidth = width - leftMarginWidth - 1;
        verticalBranchParseTree.addLeftMargin(leftMarginWidth);
        verticalBranchParseTree.addRightMargin(rightMarginWidth);
        return verticalBranchParseTree;
      }
      static fromDepthAndVerticalBranchPosition(Class, depth, verticalBranchPosition) {
        const lines = linesFromDepth(depth), verticalBranchParseTree = new Class(lines, verticalBranchPosition);
        return verticalBranchParseTree;
      }
      static fromStringAndVerticalBranchPosition(Class, string, verticalBranchPosition) {
        if (verticalBranchPosition === void 0) {
          verticalBranchPosition = string;
          string = Class;
          Class = _parseTree.default;
        }
        const line = string, lines = [
          line
        ], verticalBranchParseTree = new Class(lines, verticalBranchPosition);
        return verticalBranchParseTree;
      }
    };
    function linesFromDepth(depth) {
      const lines = [];
      let index = 0;
      while (index < depth) {
        lines[index++] = _constants.EMPTY_STRING;
      }
      return lines;
    }
  });

  // node_modules/occam-parsers/lib/utilities/tokens.js
  var require_tokens = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lineIndexFromTokenIndexAndTokens", {
      enumerable: true,
      get: function() {
        return lineIndexFromTokenIndexAndTokens;
      }
    });
    function lineIndexFromTokenIndexAndTokens(tokenIndex, tokens) {
      let lineIndex = null;
      if (tokenIndex !== null) {
        lineIndex = 0;
        const start = 0, end = tokenIndex;
        tokens = tokens.slice(start, end);
        tokens.forEach((token) => {
          const tokenEndOfLineToken = token.isEndOfLineToken();
          if (tokenEndOfLineToken) {
            lineIndex++;
          }
        });
      }
      return lineIndex;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/ruleName.js
  var require_ruleName = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _constants = require_constants4();
    var _tokens = require_tokens();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {SPACE_CHARACTER} = _necessary.characters;
    var RuleNameParseTree = class extends _verticalBranch.default {
      static fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
        const ruleName = nonTerminalNode.getRuleName(), opacity = nonTerminalNode.getOpacity(), firstSignificantTokenIndex = nonTerminalNode.getFirstSignificantTokenIndex(tokens), lastSignificantTokenIndex = nonTerminalNode.getLastSignificantTokenIndex(tokens), firstLineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(firstSignificantTokenIndex, tokens), lastLineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(lastSignificantTokenIndex, tokens);
        let lineIndexes;
        if (firstLineIndex === lastLineIndex) {
          const lineIndex = firstLineIndex;
          if (lineIndex === null) {
            lineIndexes = _constants.EMPTY_STRING;
          } else {
            lineIndexes = ` [${lineIndex}]`;
          }
        } else {
          if (false) {
          } else if (firstLineIndex === null) {
            lineIndexes = ` [${lastLineIndex}]`;
          } else if (lastLineIndex === null) {
            lineIndexes = ` [${firstLineIndex}]`;
          } else {
            lineIndexes = ` [${firstLineIndex}-${lastLineIndex}]`;
          }
        }
        let string = `${ruleName}`;
        if (opacity !== null) {
          string = `${string}${opacity}`;
        }
        string = `${string}${lineIndexes}`;
        let precedence = nonTerminalNode.getPrecedence();
        if (precedence !== null) {
          if (precedence === Infinity) {
            precedence = SPACE_CHARACTER;
          }
          string = `${string} (${precedence})`;
        }
        const stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), ruleNameParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(RuleNameParseTree, string, verticalBranchPosition);
        ruleNameParseTree.appendToTop(verticalBranchParseTree);
        return ruleNameParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/horizontalBranch.js
  var require_horizontalBranch = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return HorizontalBranchParseTree;
      }
    });
    var _necessary = require_browser();
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {DASH_CHARACTER} = _necessary.characters;
    var HorizontalBranchParseTree = class extends _parseTree.default {
      static fromWidth(width) {
        const string = stringFromCharactersWidth(width, DASH_CHARACTER), line = string, lines = [
          line
        ], horizontalBranchParseTree = new HorizontalBranchParseTree(lines);
        return horizontalBranchParseTree;
      }
    };
    function stringFromCharactersWidth(charactersWidth, character) {
      let string = _constants.EMPTY_STRING;
      for (let index = 0; index < charactersWidth; index++) {
        string += character;
      }
      return string;
    }
  });

  // node_modules/occam-parsers/lib/parseTree/childNodes.js
  var require_childNodes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChildNodesParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _horizontalBranch = /* @__PURE__ */ _interop_require_default(require_horizontalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var ChildNodesParseTree = class extends _verticalBranch.default {
      static fromChildNodesAndTokens(childNodes, tokens) {
        let childNodesParseTree = null;
        const childNodesLength = childNodes.length;
        if (childNodesLength > 0) {
          const childNodeParseTrees = childNodes.reduce((childNodeParseTrees2, childNode) => {
            const childNodeParseTree = childNode.asParseTree(tokens);
            childNodeParseTrees2.push(childNodeParseTree);
            return childNodeParseTrees2;
          }, []), childNodeParseTreesLength = childNodeParseTrees.length;
          if (childNodeParseTreesLength === 1) {
            const firstChildNodeParseTree = first2(childNodeParseTrees);
            childNodesParseTree = firstChildNodeParseTree;
          } else {
            let firstVerticalBranchPosition, lastVerticalBranchPosition = 0, childNodeParseTreesWidth = 0, childNodeParseTreesDepth = 0;
            childNodeParseTrees.forEach((childNodeParseTree, index) => {
              const childNodeParseTreeWidth = childNodeParseTree.getWidth(), childNodeParseTreeDepth = childNodeParseTree.getDepth();
              if (index === 0) {
                const firstChildNodeParseTree = childNodeParseTree, firstChildNodeParseTreeVerticalBranchPosition = firstChildNodeParseTree.getVerticalBranchPosition();
                firstVerticalBranchPosition = firstChildNodeParseTreeVerticalBranchPosition;
              }
              if (index === childNodeParseTreesLength - 1) {
                const lastChildNodeParseTree = childNodeParseTree, lastChildNodeParseTreeVerticalBranchPosition = lastChildNodeParseTree.getVerticalBranchPosition();
                lastVerticalBranchPosition += lastChildNodeParseTreeVerticalBranchPosition;
              }
              if (index < childNodeParseTreesLength - 1) {
                lastVerticalBranchPosition += childNodeParseTreeWidth;
                lastVerticalBranchPosition += 1;
                childNodeParseTreesWidth += 1;
              }
              childNodeParseTreesWidth += childNodeParseTreeWidth;
              childNodeParseTreesDepth = Math.max(childNodeParseTreesDepth, childNodeParseTreeDepth);
            });
            const width = lastVerticalBranchPosition - firstVerticalBranchPosition + 1, verticalBranchParseTree = _verticalBranch.default.fromWidth(width), horizontalBranchParseTree = _horizontalBranch.default.fromWidth(width), leftMarginWidth = firstVerticalBranchPosition, rightMarginWidth = childNodeParseTreesWidth - width - leftMarginWidth;
            verticalBranchParseTree.addLeftMargin(leftMarginWidth);
            verticalBranchParseTree.addRightMargin(rightMarginWidth);
            horizontalBranchParseTree.addLeftMargin(leftMarginWidth);
            horizontalBranchParseTree.addRightMargin(rightMarginWidth);
            const verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), depth = childNodeParseTreesDepth;
            childNodesParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(ChildNodesParseTree, depth, verticalBranchPosition);
            childNodeParseTrees.forEach((childNodeParseTree, index) => {
              const childNodeParseTreeDepth = childNodeParseTree.getDepth(), clonedChildNodeParseTree = childNodeParseTree.clone();
              if (index < childNodeParseTreesLength - 1) {
                const rightMarginWidth2 = 1;
                clonedChildNodeParseTree.addRightMargin(rightMarginWidth2);
              }
              if (childNodeParseTreeDepth < childNodeParseTreesDepth) {
                const bottomMarginDepth = childNodeParseTreesDepth - childNodeParseTreeDepth;
                clonedChildNodeParseTree.addBottomMargin(bottomMarginDepth);
              }
              childNodesParseTree.appendToRight(clonedChildNodeParseTree);
            });
            childNodesParseTree.appendToTop(horizontalBranchParseTree);
            childNodesParseTree.appendToTop(verticalBranchParseTree);
          }
        }
        return childNodesParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/nonTerminalNode.js
  var require_nonTerminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNodeParseTree;
      }
    });
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName());
    var _childNodes = /* @__PURE__ */ _interop_require_default(require_childNodes());
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeParseTree = class extends _verticalBranch.default {
      static fromNonTerminalNodeAndTokens(nonTerminalNode, tokens) {
        let nonTerminalNodeParseTree;
        const childNodes = nonTerminalNode.getChildNodes(), ruleNameParseTree = _ruleName.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), childNodesParseTree = _childNodes.default.fromChildNodesAndTokens(childNodes, tokens);
        if (childNodesParseTree === null) {
          const ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition(), verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, depth = ruleNameParseTreeDepth;
          nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree, depth, verticalBranchPosition);
          nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
        } else {
          let ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
          const childNodesParseTreeVerticalBranchPosition = childNodesParseTree.getVerticalBranchPosition(), verticalBranchPositionsDifference = ruleNameParseTreeVerticalBranchPosition - childNodesParseTreeVerticalBranchPosition;
          let leftMarginWidth;
          if (false) {
          } else if (verticalBranchPositionsDifference < 0) {
            leftMarginWidth = -verticalBranchPositionsDifference;
            ruleNameParseTree.addLeftMargin(leftMarginWidth);
          } else if (verticalBranchPositionsDifference > 0) {
            leftMarginWidth = +verticalBranchPositionsDifference;
            childNodesParseTree.addLeftMargin(leftMarginWidth);
          }
          const ruleNameParseTreeWidth = ruleNameParseTree.getWidth(), childNodesParseTreeWidth = childNodesParseTree.getWidth(), widthsDifference = ruleNameParseTreeWidth - childNodesParseTreeWidth;
          let rightMarginWidth;
          if (false) {
          } else if (widthsDifference < 0) {
            rightMarginWidth = -widthsDifference;
            ruleNameParseTree.addRightMargin(rightMarginWidth);
          } else if (widthsDifference > 0) {
            rightMarginWidth = +widthsDifference;
            childNodesParseTree.addRightMargin(rightMarginWidth);
          }
          ruleNameParseTreeVerticalBranchPosition = ruleNameParseTree.getVerticalBranchPosition();
          const ruleNameParseTreeDepth = ruleNameParseTree.getDepth(), verticalBranchPosition = ruleNameParseTreeVerticalBranchPosition, depth = ruleNameParseTreeDepth;
          nonTerminalNodeParseTree = _verticalBranch.default.fromDepthAndVerticalBranchPosition(NonTerminalNodeParseTree, depth, verticalBranchPosition);
          nonTerminalNodeParseTree.appendToRight(ruleNameParseTree);
          nonTerminalNodeParseTree.appendToBottom(childNodesParseTree);
        }
        return nonTerminalNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/nonTerminal.js
  var require_nonTerminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNode;
      }
    });
    var _necessary = require_browser();
    var _occamlexers = require_lib3();
    var _node = /* @__PURE__ */ _interop_require_default(require_node());
    var _nonTerminalNode = /* @__PURE__ */ _interop_require_default(require_nonTerminalNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, match} = _necessary.arrayUtilities;
    var {opaque: opaqueSpecialSymbol, semiOpaque: semiOpaqueSpecialSymbol} = _occamlexers.specialSymbols;
    var NonTerminalNode = class {
      constructor(ruleName, parentNode, childNodes, opacity, precedence) {
        this.ruleName = ruleName;
        this.parentNode = parentNode;
        this.childNodes = childNodes;
        this.opacity = opacity;
        this.precedence = precedence;
      }
      getRuleName() {
        return this.ruleName;
      }
      getParentNode() {
        return this.parentNode;
      }
      getChildNodes() {
        return this.childNodes;
      }
      getOpacity() {
        return this.opacity;
      }
      getPrecedence() {
        return this.precedence;
      }
      setRuleName(ruleName) {
        this.ruleName = ruleName;
      }
      setParentNode(parentNode) {
        this.parentNode = parentNode;
      }
      setChildNodes(childNodes) {
        const startIndex = 0, deleteCount = Infinity, addedChildNodes = childNodes;
        this.spliceChildNodes(startIndex, deleteCount, addedChildNodes);
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      setPrecedence(precedence) {
        this.precedence = precedence;
      }
      isOpaque() {
        const opaque = this.opacity === opaqueSpecialSymbol;
        return opaque;
      }
      isSemiOpaque() {
        const semiOpaque = this.opacity === semiOpaqueSpecialSymbol;
        return semiOpaque;
      }
      isTransparent() {
        const semiOpaque = this.opacity === null;
        return semiOpaque;
      }
      isTerminalNode() {
        const terminalNode = false;
        return terminalNode;
      }
      isNonTerminalNode() {
        const nonTerminalNode = true;
        return nonTerminalNode;
      }
      getDescendantNodes(descendantNodes) {
        return descendantNodes;
      }
      getFirstSignificantTokenIndex(tokens) {
        let firstSignificantTokenIndex;
        this.forwardsSomeChildNode((childNode) => {
          const node = childNode;
          firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens);
          if (firstSignificantTokenIndex !== null) {
            return true;
          }
        });
        return firstSignificantTokenIndex;
      }
      getLastSignificantTokenIndex(tokens) {
        let lastSignificantTokenIndex;
        this.backwardsSomeChildNode((childNode) => {
          const node = childNode;
          lastSignificantTokenIndex = node.getLastSignificantTokenIndex(tokens);
          if (lastSignificantTokenIndex !== null) {
            return true;
          }
        });
        return lastSignificantTokenIndex;
      }
      getSignificantTokens(significantTokens = []) {
        this.childNodes.forEach((childNode) => {
          childNode.getSignificantTokens(significantTokens);
        });
        return significantTokens;
      }
      getMultiplicity() {
        const childNodesLength = this.childNodes.length, multiplicity = childNodesLength;
        return multiplicity;
      }
      isEmpty() {
        const multiplicity = this.getMultiplicity(), empty = multiplicity === 0;
        return empty;
      }
      isSingular() {
        const multiplicity = this.getMultiplicity(), singular = multiplicity === 1;
        return singular;
      }
      isLowerPrecedence(ruleName, precedence) {
        let lowerPrecedence;
        if (false) {
        } else if (this.precedence === null) {
          lowerPrecedence = false;
        } else if (this.precedence === Infinity) {
          const firstChildNode = first2(this.childNodes);
          lowerPrecedence = firstChildNode.isLowerPrecedence(ruleName, precedence);
        } else {
          lowerPrecedence = this.ruleName === ruleName && this.precedence < precedence;
        }
        return lowerPrecedence;
      }
      isUnprecedented() {
        let unprecedented = false;
        if (this.precedence !== null) {
          unprecedented = this.childNodes.some((childNode) => {
            const childNodeLowerPrecedence = childNode.isLowerPrecedence(this.ruleName, this.precedence);
            if (childNodeLowerPrecedence) {
              return true;
            }
          });
        }
        return unprecedented;
      }
      asParseTree(tokens) {
        const nonTerminalNode = this, nonTerminalNodeParseTree = _nonTerminalNode.default.fromNonTerminalNodeAndTokens(nonTerminalNode, tokens), parseTree = nonTerminalNodeParseTree;
        return parseTree;
      }
      match(node, depth = Infinity, exactly = false) {
        let matches = false;
        const nodeNonTerminalNode = node.isNonTerminalNode();
        if (nodeNonTerminalNode) {
          const nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
          if (this.ruleName === nonTerminalNodeRuleName) {
            const nonTerminalNodeOpacity = nonTerminalNode.getOpacity();
            if (this.opacity === nonTerminalNodeOpacity) {
              const precedence = this.getPrecedence(), nonTerminalNodePrecedence = nonTerminalNode.getPrecedence();
              if (precedence === nonTerminalNodePrecedence) {
                depth--;
                if (depth === 0) {
                  matches = true;
                } else {
                  const nonTerminalNodeChildNodes = nonTerminalNode.getChildNodes();
                  matches = match(this.childNodes, nonTerminalNodeChildNodes, (childNode, nonTerminalNodeChildNode) => {
                    const childNodeMatchesNonTerminalNodeChildNode = childNode.match(nonTerminalNodeChildNode, depth, exactly);
                    if (childNodeMatchesNonTerminalNodeChildNode) {
                      return true;
                    }
                  });
                }
              }
            }
          }
        }
        return matches;
      }
      rewrite(state) {
        const rewrittenNonTerminalNode = null;
        return rewrittenNonTerminalNode;
      }
      destroy() {
        this.forEachChildNode((childNode) => {
          childNode.destroy();
        });
        this.parentNode = null;
        this.childNodes = null;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, parentNode = null, ruleName = this.ruleName, childNodes = cloneChildNodes(this.childNodes), opacity = this.opacity, precedence = this.precedence, nonTerminalNode = new Class(ruleName, parentNode, childNodes, opacity, precedence, ...remainingArguments);
        nonTerminalNode.setChildNodesParentNode();
        return nonTerminalNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence, ...remainingArguments) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = NonTerminalNode;
        }
        const parentNode = null, nonTerminalNode = new Class(ruleName, parentNode, childNodes, opacity, precedence, ...remainingArguments);
        nonTerminalNode.setChildNodesParentNode();
        return nonTerminalNode;
      }
    };
    Object.assign(NonTerminalNode.prototype, _node.default);
    function cloneChildNodes(childNodes) {
      childNodes = childNodes.map((childNode) => {
        childNode = childNode.clone();
        return childNode;
      });
      return childNodes;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal.js
  var require_nonTerminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPart;
      }
    });
    var NonTerminalPart = class {
      constructor(type, callAhead) {
        this.type = type;
        this.callAhead = callAhead;
      }
      getType() {
        return this.type;
      }
      isCallAhead() {
        return this.callAhead;
      }
      isNonTerminalPart() {
        const nonTerminalPart = true;
        return nonTerminalPart;
      }
      isTerminalPart() {
        const terminalPart = false;
        return terminalPart;
      }
      isRuleNamePart() {
        const ruleNamePart = false;
        return ruleNamePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/partTypes.js
  var require_partTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ChoiceOfPartsPartType() {
        return ChoiceOfPartsPartType;
      },
      get OneOrMorePartsPartType() {
        return OneOrMorePartsPartType;
      },
      get OptionalPartPartType() {
        return OptionalPartPartType;
      },
      get RuleNamePartType() {
        return RuleNamePartType;
      },
      get SequenceOfPartsPartType() {
        return SequenceOfPartsPartType;
      },
      get ZeroOrMorePartsPartType() {
        return ZeroOrMorePartsPartType;
      },
      get default() {
        return _default;
      }
    });
    var RuleNamePartType = "ruleNamePart";
    var OptionalPartPartType = "optionalPart";
    var ChoiceOfPartsPartType = "choiceOfParts";
    var OneOrMorePartsPartType = "oneOrMoreParts";
    var ZeroOrMorePartsPartType = "zeroOrMoreParts";
    var SequenceOfPartsPartType = "sequenceOfParts";
    var _default = {
      RuleNamePartType,
      OptionalPartPartType,
      ChoiceOfPartsPartType,
      OneOrMorePartsPartType,
      ZeroOrMorePartsPartType,
      SequenceOfPartsPartType
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/optionalPart.js
  var require_optionalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return OptionalPartPart;
      },
      get parseOptionalPart() {
        return parseOptionalPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {questionMark} = _occamlexers.specialSymbols;
    var OptionalPartPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseOptionalPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${questionMark}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.OptionalPartPartType, callAhead = false, optionalPartPart = new OptionalPartPart(type, callAhead, part);
        return optionalPartPart;
      }
    };
    function parseOptionalPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        parsed = true;
      } else {
        parsed = callAhead();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback, callAhead);
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/zeroOrMoreParts.js
  var require_zeroOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return ZeroOrMorePartsPart;
      },
      get parseZeroOrMorePartsPart() {
        return parseZeroOrMorePartsPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asterisk} = _occamlexers.specialSymbols;
    var ZeroOrMorePartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseZeroOrMorePartsPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${asterisk}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.ZeroOrMorePartsPartType, callAhead = false, zeroOrMorePartsPart = new ZeroOrMorePartsPart(type, callAhead, part);
        return zeroOrMorePartsPart;
      }
    };
    function parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        if (parsed) {
          parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead);
        }
        parsed = true;
      } else {
        parsed = callAhead();
        if (!parsed) {
          parsed = part.parse(nodes, state, callback, () => {
            let parsed2;
            parsed2 = parseZeroOrMorePartsPart(part, nodes, state, callback, callAhead);
            return parsed2;
          });
        }
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/oneOrMoreParts.js
  var require_oneOrMoreParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return OneOrMorePartsPart;
      },
      get parseOneOrMorePartsPart() {
        return parseOneOrMorePartsPart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _partTypes = require_partTypes();
    var _zeroOrMoreParts = require_zeroOrMoreParts();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {plus} = _occamlexers.specialSymbols;
    var OneOrMorePartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, part) {
        super(type, callAhead);
        this.part = part;
      }
      getPart() {
        return this.part;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        parsed = parseOneOrMorePartsPart(this.part, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partString = this.part.asString(), string = `${partString}${plus}`;
        return string;
      }
      static fromPart(part) {
        const type = _partTypes.OneOrMorePartsPartType, callAhead = false, oneOrMorePartsPart = new OneOrMorePartsPart(type, callAhead, part);
        return oneOrMorePartsPart;
      }
    };
    function parseOneOrMorePartsPart(part, nodes, state, callback, callAhead) {
      let parsed;
      if (callAhead === null) {
        parsed = part.parse(nodes, state, callback, callAhead);
        if (parsed) {
          (0, _zeroOrMoreParts.parseZeroOrMorePartsPart)(part, nodes, state, callback, callAhead);
        }
      } else {
        parsed = part.parse(nodes, state, callback, () => {
          let parsed2;
          parsed2 = (0, _zeroOrMoreParts.parseZeroOrMorePartsPart)(part, nodes, state, callback, callAhead);
          return parsed2;
        });
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/ruleNames.js
  var require_ruleNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CALL_AHEAD_MODIFIER_RULE_NAME() {
        return CALL_AHEAD_MODIFIER_RULE_NAME;
      },
      get CHOICE_OF_PARTS_RULE_NAME() {
        return CHOICE_OF_PARTS_RULE_NAME;
      },
      get DEFINITIONS_RULE_NAME() {
        return DEFINITIONS_RULE_NAME;
      },
      get DEFINITION_RULE_NAME() {
        return DEFINITION_RULE_NAME;
      },
      get DOCUMENT_RULE_NAME() {
        return DOCUMENT_RULE_NAME;
      },
      get END_OF_LINE_RULE_NAME() {
        return END_OF_LINE_RULE_NAME;
      },
      get EPSILON_RULE_NAME() {
        return EPSILON_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get NAME_RULE_NAME() {
        return NAME_RULE_NAME;
      },
      get NON_TERMINAL_PART_RULE_NAME() {
        return NON_TERMINAL_PART_RULE_NAME;
      },
      get NO_WHITESPACE_PART_RULE_NAME() {
        return NO_WHITESPACE_PART_RULE_NAME;
      },
      get ONE_OR_MORE_QUANTIFIER_RULE_NAME() {
        return ONE_OR_MORE_QUANTIFIER_RULE_NAME;
      },
      get OPACITY_MODIFIER_RULE_NAME() {
        return OPACITY_MODIFIER_RULE_NAME;
      },
      get OPTIONAL_QUANTIFIER_RULE_NAME() {
        return OPTIONAL_QUANTIFIER_RULE_NAME;
      },
      get PART_CHOICE_RULE_NAME() {
        return PART_CHOICE_RULE_NAME;
      },
      get PART_RULE_NAME() {
        return PART_RULE_NAME;
      },
      get PRECEDENCE_RULE_NAME() {
        return PRECEDENCE_RULE_NAME;
      },
      get QUANTIFIER_RULE_NAME() {
        return QUANTIFIER_RULE_NAME;
      },
      get REGULAR_EXPRESSION_RULE_NAME() {
        return REGULAR_EXPRESSION_RULE_NAME;
      },
      get RULE_NAME_RULE_NAME() {
        return RULE_NAME_RULE_NAME;
      },
      get RULE_RULE_NAME() {
        return RULE_RULE_NAME;
      },
      get SEQUENCE_OF_PARTS_RULE_NAME() {
        return SEQUENCE_OF_PARTS_RULE_NAME;
      },
      get SIGNIFICANT_TOKEN_TYPE_RULE_NAME() {
        return SIGNIFICANT_TOKEN_TYPE_RULE_NAME;
      },
      get START_OF_CONTENT_PART_RULE_NAME() {
        return START_OF_CONTENT_PART_RULE_NAME;
      },
      get STRING_LITERAL_RULE_NAME() {
        return STRING_LITERAL_RULE_NAME;
      },
      get TERMINAL_PART_RULE_NAME() {
        return TERMINAL_PART_RULE_NAME;
      },
      get WILDCARD_RULE_NAME() {
        return WILDCARD_RULE_NAME;
      },
      get ZERO_OR_MORE_QUANTIFIER_RULE_NAME() {
        return ZERO_OR_MORE_QUANTIFIER_RULE_NAME;
      }
    });
    var NAME_RULE_NAME = "name";
    var PART_RULE_NAME = "part";
    var RULE_RULE_NAME = "rule";
    var ERROR_RULE_NAME = "error";
    var EPSILON_RULE_NAME = "epsilon";
    var DOCUMENT_RULE_NAME = "document";
    var WILDCARD_RULE_NAME = "wildcard";
    var RULE_NAME_RULE_NAME = "ruleName";
    var DEFINITION_RULE_NAME = "definition";
    var PRECEDENCE_RULE_NAME = "precedence";
    var QUANTIFIER_RULE_NAME = "quantifier";
    var END_OF_LINE_RULE_NAME = "endOfLine";
    var PART_CHOICE_RULE_NAME = "partChoice";
    var DEFINITIONS_RULE_NAME = "definitions";
    var TERMINAL_PART_RULE_NAME = "terminalPart";
    var STRING_LITERAL_RULE_NAME = "stringLiteral";
    var CHOICE_OF_PARTS_RULE_NAME = "choiceOfParts";
    var OPACITY_MODIFIER_RULE_NAME = "opacityModifier";
    var NON_TERMINAL_PART_RULE_NAME = "nonTerminalPart";
    var SEQUENCE_OF_PARTS_RULE_NAME = "sequenceOfParts";
    var NO_WHITESPACE_PART_RULE_NAME = "noWhitespace";
    var REGULAR_EXPRESSION_RULE_NAME = "regularExpression";
    var CALL_AHEAD_MODIFIER_RULE_NAME = "callAheadModifier";
    var OPTIONAL_QUANTIFIER_RULE_NAME = "optionalQuantifier";
    var START_OF_CONTENT_PART_RULE_NAME = "startOfContent";
    var SIGNIFICANT_TOKEN_TYPE_RULE_NAME = "significantTokenType";
    var ONE_OR_MORE_QUANTIFIER_RULE_NAME = "oneOrMoreQuantifier";
    var ZERO_OR_MORE_QUANTIFIER_RULE_NAME = "zeroOrMoreQuantifier";
  });

  // node_modules/occam-parsers/lib/utilities/bnf.js
  var require_bnf2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isNodeCallAheadModifierNode() {
        return isNodeCallAheadModifierNode;
      },
      get isNodeChoiceNode() {
        return isNodeChoiceNode;
      },
      get isNodeQuantifierNode() {
        return isNodeQuantifierNode;
      },
      get isNodeRuleNameNode() {
        return isNodeRuleNameNode;
      },
      get ruleNameFromQuantifierNode() {
        return ruleNameFromQuantifierNode;
      }
    });
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames();
    var {first: first2} = _necessary.arrayUtilities;
    function isNodeChoiceNode(node) {
      let nodeNoChoiceNode = false;
      const nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        const terminalNode = node, terminalNodeContent = terminalNode.getContent();
        nodeNoChoiceNode = terminalNodeContent === "|";
      }
      return nodeNoChoiceNode;
    }
    function isNodeRuleNameNode(node) {
      let nodeRuleNameNode = false;
      const nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, nonTerminalNodeRuleName = nonTerminalNode.getRuleName();
        nodeRuleNameNode = nonTerminalNodeRuleName === _ruleNames.RULE_NAME_RULE_NAME;
      }
      return nodeRuleNameNode;
    }
    function isNodeQuantifierNode(node) {
      let nodeQuantifierNode = false;
      const nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameQuantifierRuleName = ruleName === _ruleNames.QUANTIFIER_RULE_NAME;
        nodeQuantifierNode = ruleNameQuantifierRuleName;
      }
      return nodeQuantifierNode;
    }
    function isNodeCallAheadModifierNode(node) {
      let nodeCallAheadModifierNode = false;
      const nodeNonTerminalNode = node.isNonTerminalNode();
      if (nodeNonTerminalNode) {
        const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName(), ruleNameCallAheadModifierRuleName = ruleName === _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME;
        nodeCallAheadModifierNode = ruleNameCallAheadModifierRuleName;
      }
      return nodeCallAheadModifierNode;
    }
    function ruleNameFromQuantifierNode(quantifierNode) {
      let nonTerminalNode;
      nonTerminalNode = quantifierNode;
      const childNodes = nonTerminalNode.getChildNodes(), firstChildNode = first2(childNodes);
      nonTerminalNode = firstChildNode;
      const ruleName = nonTerminalNode.getRuleName();
      return ruleName;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/part.js
  var require_part = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _bnf = require_bnf2();
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {last} = _necessary.arrayUtilities;
    var PartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), nodes = childNodes.slice(), part = partFromNodes(nodes);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    function partFromNodes(nodes) {
      let part;
      const nodesLength = nodes.length;
      if (nodesLength === 1) {
        const node = nodes.pop(), callAhead = false;
        part = node.generatePart(callAhead);
      } else {
        const lastNodeQuantifierNode = isLastNodeQuantifierNode(nodes);
        if (lastNodeQuantifierNode) {
          const node = nodes.pop(), quantifierNode = node;
          part = partFromNodes(nodes);
          const ruleName = (0, _bnf.ruleNameFromQuantifierNode)(quantifierNode), collectionOfPartsPart = collectionOfPartsPartFromPartAndRuleName(part, ruleName);
          part = collectionOfPartsPart;
        } else {
          nodes.shift();
          part = partFromNodes(nodes);
        }
      }
      return part;
    }
    function isLastNodeQuantifierNode(nodes) {
      const lastNode = last(nodes), lastNodeQuantifierNode = (0, _bnf.isNodeQuantifierNode)(lastNode);
      return lastNodeQuantifierNode;
    }
    function collectionOfPartsPartFromPartAndRuleName(part, ruleName) {
      let collectionOfPartsPart;
      switch (ruleName) {
        case _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME:
          const optionalPartPart = _optionalPart.default.fromPart(part);
          collectionOfPartsPart = optionalPartPart;
          break;
        case _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME:
          const oneOrMorePartsPart = _oneOrMoreParts.default.fromPart(part);
          collectionOfPartsPart = oneOrMorePartsPart;
          break;
        case _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME:
          const zeroOrMorePartsPart = _zeroOrMoreParts.default.fromPart(part);
          collectionOfPartsPart = zeroOrMorePartsPart;
          break;
      }
      return collectionOfPartsPart;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/name.js
  var require_name2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var NameBNFNode = class extends _nonTerminal.default {
      getName() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), name = terminalNodeContent;
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NameBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/node.js
  var require_node2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeFromChildNodesAndRuleName() {
        return nodeFromChildNodesAndRuleName;
      },
      get nodesFromChildNodesAndRuleName() {
        return nodesFromChildNodesAndRuleName;
      }
    });
    function nodeFromChildNodesAndRuleName(childNodes, ruleName) {
      let node = null;
      childNodes.some((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode = childNode, nonTerminalNodeRuleName = nonTerminalNode.getRuleName(), nonTerminalNodeRuleNameRuleName = nonTerminalNodeRuleName === ruleName;
          if (nonTerminalNodeRuleNameRuleName) {
            node = childNode;
            return true;
          }
        }
      });
      return node;
    }
    function nodesFromChildNodesAndRuleName(childNodes, ruleName) {
      const nodes = childNodes.filter((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode = childNode, nonTerminalNodeRuleName = nonTerminalNode.getRuleName(), nonTerminalNodeRuleNameRuleName = nonTerminalNodeRuleName === ruleName;
          if (nonTerminalNodeRuleNameRuleName) {
            return true;
          }
        }
      });
      return nodes;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/rule.js
  var require_rule3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, secondLast} = _necessary.arrayUtilities;
    var RuleBNFNode = class extends _nonTerminal.default {
      generateRule(Rule) {
        const name = this.getName(), opacity = this.getOpacity(), definitions = this.generateDefinitions(), rule = Rule.fromNameOpacityAndDefinitions(name, opacity, definitions);
        return rule;
      }
      getOpacity() {
        let opacity = null;
        const ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME, childNodes = this.getChildNodes(), opacityModifierBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        if (opacityModifierBNFNode !== null) {
          opacity = opacityModifierBNFNode.getOpacity();
        }
        return opacity;
      }
      getName() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), nameBNFNode = firstChildNode, name = nameBNFNode.getName();
        return name;
      }
      generateDefinitions() {
        const childNodes = this.getChildNodes(), secondLastChildNode = secondLast(childNodes), definitionsBNFNode = secondLastChildNode, definitions = definitionsBNFNode.generateDefinitions();
        return definitions;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RuleBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/error.js
  var require_error = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ErrorBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ErrorBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal.js
  var require_terminal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPart;
      }
    });
    var TerminalPart = class {
      isCallAhead() {
        const callAhead = false;
        return callAhead;
      }
      isNonTerminalPart() {
        const nonTerminalPart = false;
        return nonTerminalPart;
      }
      isTerminalPart() {
        const terminalPart = true;
        return terminalPart;
      }
      isNoWhitespacePart() {
        const noWhitespacePart = false;
        return noWhitespacePart;
      }
      isStartOfContentPart() {
        const startOfContentPart = false;
        return startOfContentPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/terminalNode.js
  var require_terminalNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalNodeParseTree;
      }
    });
    var _necessary = require_browser();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    var _constants = require_constants4();
    var _tokens = require_tokens();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {NEW_LINE_CHARACTER, CARRIAGE_RETURN_CHARACTER} = _necessary.characters;
    var TerminalNodeParseTree = class extends _verticalBranch.default {
      static fromTerminalNodeAndTokens(terminalNode, tokens) {
        let content;
        content = terminalNode.getContent();
        content = content.replace(/[\r\n]/g, (match) => {
          switch (match) {
            case CARRIAGE_RETURN_CHARACTER:
              return "\\r";
            case NEW_LINE_CHARACTER:
              return "\\n";
            default:
              return match;
          }
        });
        const type = terminalNode.getType(), significantTokenIndex = terminalNode.getSignificantTokenIndex(tokens), lineIndex = (0, _tokens.lineIndexFromTokenIndexAndTokens)(significantTokenIndex, tokens);
        let lineIndexes;
        if (lineIndex === null) {
          lineIndexes = _constants.EMPTY_STRING;
        } else {
          lineIndexes = ` [${lineIndex}]`;
        }
        const string = `"${content}"[${type}]${lineIndexes}`, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(TerminalNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        return terminalNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal.js
  var require_terminal2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalNode;
      }
    });
    var _terminalNode = /* @__PURE__ */ _interop_require_default(require_terminalNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalNode = class {
      constructor(parentNode, significantToken) {
        this.parentNode = parentNode;
        this.significantToken = significantToken;
      }
      getParentNode() {
        return this.parentNode;
      }
      getSignificantToken() {
        return this.significantToken;
      }
      setParentNode(parentNode) {
        this.parentNode = parentNode;
      }
      setSignificantToken(significantToken) {
        this.significantToken = significantToken;
      }
      isStartOfContentNode() {
        const startOfContentNode = false;
        return startOfContentNode;
      }
      isNoWhitespaceNode() {
        const noWhitespaceNode = false;
        return noWhitespaceNode;
      }
      isEpsilonNode() {
        const epsilonNode = false;
        return epsilonNode;
      }
      isTerminalNode() {
        const terminalNode = true;
        return terminalNode;
      }
      isNonTerminalNode() {
        const nonTerminalNode = false;
        return nonTerminalNode;
      }
      getType() {
        return this.significantToken.getType();
      }
      getContent() {
        return this.significantToken.getContent();
      }
      getPrecedence() {
        const precedence = null;
        return precedence;
      }
      isLowerPrecedence(parentRuleName, parentPrecedence) {
        const lowerPrecedence = false;
        return lowerPrecedence;
      }
      getFirstSignificantTokenIndex(tokens) {
        const significantTokenIndex = this.getSignificantTokenIndex(tokens), firstSignificantTokenIndex = significantTokenIndex;
        return firstSignificantTokenIndex;
      }
      getLastSignificantTokenIndex(tokens) {
        const significantTokenIndex = this.getSignificantTokenIndex(tokens), lastSignificantTokenIndex = significantTokenIndex;
        return lastSignificantTokenIndex;
      }
      getSignificantTokenIndex(tokens) {
        let significantTokenIndex = null;
        if (this.significantToken !== null) {
          significantTokenIndex = tokens.indexOf(this.significantToken);
        }
        return significantTokenIndex;
      }
      getSignificantTokens(significantTokens = []) {
        if (this.significantToken !== null) {
          significantTokens.push(this.significantToken);
        }
        return significantTokens;
      }
      getAncestorNodes() {
        const ancestorNodes = [];
        let ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          ancestorNodes.push(ancestorNode);
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
        }
        return ancestorNodes;
      }
      mapAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.map(callback);
      }
      someAncestorNode(callback) {
        let result = false;
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          result = !!callback(ancestorNode, index);
          if (result) {
            break;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        return result;
      }
      findAncestorNode(callback) {
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          const result = callback(ancestorNode, index);
          if (result) {
            return ancestorNode;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        ancestorNode = void 0;
        return ancestorNode;
      }
      everyAncestorNode(callback) {
        let result = true;
        let index = 0, ancestorNode = this.parentNode;
        while (ancestorNode !== null) {
          result = !!callback(ancestorNode, index);
          if (!result) {
            break;
          }
          const parentNode = ancestorNode.getParentNode();
          ancestorNode = parentNode;
          index++;
        }
        return result;
      }
      filterAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.filter(callback);
      }
      reduceAncestorNode(callback, initialValue) {
        const ancestorNodes = this.getAncestorNodes();
        return ancestorNodes.reduce(callback, initialValue);
      }
      forEachAncestorNode(callback) {
        const ancestorNodes = this.getAncestorNodes();
        ancestorNodes.forEach(callback);
      }
      getDescendantNodes(descendantNodes = []) {
        return descendantNodes;
      }
      someDescendantNode(callback) {
        const result = false;
        return result;
      }
      findDescendantNode(callback) {
        let descendantNode = void 0;
        return descendantNode;
      }
      everyDescendantNode(callback) {
        let result = true;
        return result;
      }
      asParseTree(tokens) {
        const terminalNode = this, terminalNodeParseTree = _terminalNode.default.fromTerminalNodeAndTokens(terminalNode, tokens), parseTree = terminalNodeParseTree;
        return parseTree;
      }
      match(node, depth = Infinity, exactly = false) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, significantToken = terminalNode.getSignificantToken();
          matches = exactly ? this.significantToken === significantToken : this.significantToken.match(significantToken);
        }
        return matches;
      }
      clone(...remainingArguments) {
        const Class = this.constructor, parentNode = null, significantToken = this.significantToken, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
      destroy() {
        this.parentNode = null;
        this.significantToken = null;
      }
      static fromNothing(Class, ...remainingArguments) {
        if (Class === void 0) {
          Class = TerminalNode;
        }
        const parentNode = null, significantToken = null, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
      static fromSignificantToken(Class, significantToken, ...remainingArguments) {
        if (significantToken === void 0) {
          significantToken = Class;
          Class = TerminalNode;
        }
        const parentNode = null, terminalNode = new Class(parentNode, significantToken, ...remainingArguments);
        return terminalNode;
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/epsilonNode.js
  var require_epsilonNode = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = epsilon, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EpsilonNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const epsilonNodeParseTree = terminalNodeParseTree;
        return epsilonNodeParseTree;
      }
    };
    module.exports = EpsilonNodeParseTree;
  });

  // node_modules/occam-parsers/lib/node/terminal/epsilon.js
  var require_epsilon = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonNode;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _epsilonNode = /* @__PURE__ */ _interop_require_default(require_epsilonNode());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = epsilon;
        return content;
      }
      isEpsilonNode() {
        const epsilonNode = true;
        return epsilonNode;
      }
      asParseTree(tokens) {
        const epsilonNodeParseTree = _epsilonNode.default.fromNothing(), parseTree = epsilonNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeEpsilonNode = terminalNode.isEpsilonNode();
          if (terminalNodeEpsilonNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(EpsilonNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/epsilon.js
  var require_epsilon2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonPart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), epsilonBNFNode = _epsilon.default.fromNothing();
        parsed = epsilonBNFNode !== null;
        if (parsed) {
          nodes.push(epsilonBNFNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = epsilon;
        return string;
      }
      static fromNothing() {
        const epsilonPart = new EpsilonPart();
        return epsilonPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/epsilon.js
  var require_epsilon3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonBNFNode;
      }
    });
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EpsilonBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const epsilonPart = _epsilon.default.fromNothing();
        return epsilonPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(EpsilonBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/document.js
  var require_document2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentBNFNode = class extends _nonTerminal.default {
      generateRules(Rule) {
        const ruleName = _ruleNames.RULE_RULE_NAME, childNodes = this.getChildNodes(), ruleBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName), rules = ruleBNFNodes.map((ruleBNFNode) => {
          const rule = ruleBNFNode.generateRule(Rule);
          return rule;
        });
        return rules;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DocumentBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/ruleName.js
  var require_ruleName2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNamePart;
      }
    });
    var _occamlexers = require_lib3();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _constants = require_constants4();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {ellipsis} = _occamlexers.specialSymbols;
    var RuleNamePart = class extends _nonTerminal.default {
      constructor(type, callAAhead, ruleName) {
        super(type, callAAhead);
        this.ruleName = ruleName;
      }
      getRuleName() {
        return this.ruleName;
      }
      isRuleNamePart() {
        const ruleNamePart = true;
        return ruleNamePart;
      }
      findRule(state) {
        const ruleMap = state.getRuleMap(), rule = ruleMap[this.ruleName] || null;
        return rule;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const rule = this.findRule(state);
        parsed = rule !== null ? rule.parse(nodes, state, callback, callAhead) : false;
        return parsed;
      }
      asString() {
        const callAAhead = this.isCallAhead(), callAAheadString = callAAhead ? ellipsis : _constants.EMPTY_STRING, string = `${this.ruleName}${callAAheadString}`;
        return string;
      }
      static fromRuleName(ruleName) {
        const type = _partTypes.RuleNamePartType, callAAhead = false, ruleNamePart = new RuleNamePart(type, callAAhead, ruleName);
        return ruleNamePart;
      }
      static fromCallAheadAndRuleName(callAAhead, ruleName) {
        const type = _partTypes.RuleNamePartType, ruleNamePart = new RuleNamePart(type, callAAhead, ruleName);
        return ruleNamePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/ruleName.js
  var require_ruleName3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameBNFNode;
      }
    });
    var _necessary = require_browser();
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var RuleNameBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), ruleName = terminalNodeContent, ruleNamePart = _ruleName.default.fromCallAheadAndRuleName(callAhead, ruleName);
        return ruleNamePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RuleNameBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/wildcard.js
  var require_wildcard = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {wildcard} = _occamlexers.specialSymbols;
    var WildcardPart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          terminalNode = _terminal1.default.fromSignificantToken(significantToken);
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = wildcard;
        return string;
      }
      static fromNothing() {
        const wildcardPart = new WildcardPart();
        return wildcardPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/wildcard.js
  var require_wildcard2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardBNFNode;
      }
    });
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var WildcardBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const wildcardPart = _wildcard.default.fromNothing();
        return wildcardPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(WildcardBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/endOfLineNode.js
  var require_endOfLineNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLineNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = endOfLine, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(EndOfLineNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const endOfLineNodeParseTree = terminalNodeParseTree;
        return endOfLineNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/endOfLine.js
  var require_endOfLine5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _endOfLineNode = /* @__PURE__ */ _interop_require_default(require_endOfLineNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfLineNode = class extends _terminal.default {
      getContent(faithful = false) {
        const content = faithful ? super.getContent() : _constants.EMPTY_STRING;
        return content;
      }
      asParseTree(tokens) {
        const endOfLineNodeParseTree = _endOfLineNode.default.fromNothing(), parseTree = endOfLineNodeParseTree;
        return parseTree;
      }
      static fromSignificantToken(significantToken) {
        return _terminal.default.fromSignificantToken(EndOfLineNode, significantToken);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/endOfLine.js
  var require_endOfLine6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLinePart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLinePart = class extends _terminal.default {
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let endOfLineNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const significantTokenEndOfLineToken = significantToken.isEndOfLineToken();
          if (significantTokenEndOfLineToken) {
            endOfLineNode = _endOfLine.default.fromSignificantToken(significantToken);
          }
        }
        parsed = endOfLineNode !== null;
        if (parsed) {
          nodes.push(endOfLineNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = endOfLine;
        return string;
      }
      static fromNothing() {
        const endOfLinePart = new EndOfLinePart();
        return endOfLinePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/endOfLine.js
  var require_endOfLine7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineBNFNode;
      }
    });
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine6());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EndOfLineBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const endOfLinePart = _endOfLine.default.fromNothing();
        return endOfLinePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(EndOfLineBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/partChoice.js
  var require_partChoice = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoice;
      }
    });
    var _necessary = require_browser();
    var {SPACE_CHARACTER} = _necessary.characters;
    var PartChoice = class {
      constructor(part, precedence) {
        this.part = part;
        this.precedence = precedence;
      }
      getPart() {
        return this.part;
      }
      getPrecedence() {
        return this.precedence;
      }
      asString() {
        let string;
        const partString = this.part.asString();
        string = partString;
        if (this.precedence !== null) {
          const precedence = this.precedence === Infinity ? SPACE_CHARACTER : this.precedence;
          string = `${string} (${precedence})`;
        }
        return string;
      }
      static fromPart(part) {
        const precedence = null, partChoice = new PartChoice(part, precedence);
        return partChoice;
      }
      static fromPartAndPrecedence(part, precedence) {
        const partChoice = new PartChoice(part, precedence);
        return partChoice;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/partChoice.js
  var require_partChoice2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceBNFNode;
      }
    });
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _node = require_node2();
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceBNFNode = class extends _nonTerminal.default {
      generatePartChoice(callAhead) {
        let ruleName;
        const childNodes = this.getChildNodes();
        ruleName = _ruleNames.PART_RULE_NAME;
        const partBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const part = partBNFNode.generatePart(callAhead), precedence = precedenceBNFNode === null ? null : precedenceBNFNode.getPrecedence(), definition = _partChoice.default.fromPartAndPrecedence(part, precedence);
        return definition;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PartChoiceBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/precedence.js
  var require_precedence = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {second} = _necessary.arrayUtilities;
    var PrecedenceBNFNode = class extends _nonTerminal.default {
      getPrecedence() {
        let precedence = Infinity;
        const multiplicity = this.getMultiplicity();
        if (multiplicity === 3) {
          const childNodes = this.getChildNodes(), secondChildNode = second(childNodes), terminalNode = secondChildNode, content = terminalNode.getContent();
          precedence = Number(content);
        }
        return precedence;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(PrecedenceBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/quantifier.js
  var require_quantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(QuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/parse.js
  var require_parse = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get parsePart() {
        return parsePart;
      },
      get parseParts() {
        return parseParts;
      }
    });
    function parsePart(part, nodes, state, callback, callAhead) {
      let parsed;
      const index = 0, parts = [
        part
      ];
      parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      return parsed;
    }
    function parseParts(parts, nodes, state, callback, callAhead) {
      let parsed;
      const index = 0;
      parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      return parsed;
    }
    function parsePartOfParts(index, parts, nodes, state, callback, callAhead) {
      let parsed;
      const partsLength = parts.length;
      if (index === partsLength) {
        parsed = callback !== null ? callback() : true;
      } else {
        const part = parts[index], partCallAhead = callAhead === null ? part.isCallAhead() : true;
        index++;
        parsed = partCallAhead ? parsePartWithCallAhead(part, index, parts, nodes, state, callback, callAhead) : parsePartWithoutCallAhead(part, index, parts, nodes, state, callback, callAhead);
      }
      return parsed;
    }
    function parsePartWithCallAhead(part, index, parts, nodes, state, callback, callAhead) {
      let parsed;
      const nodesLength = nodes.length;
      callAhead = () => {
        let parsed2;
        parsed2 = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
        return parsed2;
      };
      parsed = part.parse(nodes, state, callback, callAhead);
      if (!parsed) {
        const start = nodesLength;
        nodes.splice(start);
      }
      return parsed;
    }
    function parsePartWithoutCallAhead(part, index, parts, nodes, state, callback, callAhead) {
      let parsed;
      parsed = part.parse(nodes, state, callback, callAhead);
      if (parsed) {
        parsed = parsePartOfParts(index, parts, nodes, state, callback, callAhead);
      }
      return parsed;
    }
  });

  // node_modules/occam-parsers/lib/definition.js
  var require_definition = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Definition;
      }
    });
    var _necessary = require_browser();
    var _parse = require_parse();
    var _constants = require_constants4();
    var {SPACE_CHARACTER} = _necessary.characters;
    var Definition = class {
      constructor(parts, precedence) {
        this.parts = parts;
        this.precedence = precedence;
      }
      getParts() {
        return this.parts;
      }
      getPrecedence() {
        return this.precedence;
      }
      parse(childNodes, state, callback, callAhead) {
        let parsed;
        const nodes = childNodes, savedIndex = state.getSavedIndex();
        parsed = (0, _parse.parseParts)(this.parts, nodes, state, callback, callAhead);
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        let string;
        const partsString = this.parts.reduce((partsString2, part) => {
          const partString = part.asString();
          if (partsString2 === _constants.EMPTY_STRING) {
            partsString2 = partString;
          } else {
            partsString2 = `${partsString2} ${partString}`;
          }
          return partsString2;
        }, _constants.EMPTY_STRING);
        string = partsString;
        if (this.precedence !== null) {
          const precedence = this.precedence === Infinity ? SPACE_CHARACTER : this.precedence;
          string = `${string} (${precedence})`;
        }
        return string;
      }
      static fromParts(Class, parts) {
        if (parts === void 0) {
          parts = Class;
          Class = Definition;
        }
        const precedence = null, definition = new Class(parts, precedence);
        return definition;
      }
      static fromPartsAndPrecedence(Class, parts, precedence) {
        if (precedence === void 0) {
          precedence = parts;
          parts = Class;
          Class = Definition;
        }
        const definition = new Class(parts, precedence);
        return definition;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/definition.js
  var require_definition2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionBNFNode;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionBNFNode = class extends _nonTerminal.default {
      generateDefinition() {
        let ruleName;
        const childNodes = this.getChildNodes();
        ruleName = _ruleNames.PART_RULE_NAME;
        const partBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName), callAhead = false, parts = partBNFNodes.map((partBNFNode) => {
          const part = partBNFNode.generatePart(callAhead);
          return part;
        }), precedence = precedenceBNFNode === null ? null : precedenceBNFNode.getPrecedence(), definition = _definition.default.fromPartsAndPrecedence(parts, precedence);
        return definition;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DefinitionBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/definitions.js
  var require_definitions = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionsBNFNode = class extends _nonTerminal.default {
      generateDefinitions() {
        const ruleName = _ruleNames.DEFINITION_RULE_NAME, childNodes = this.getChildNodes(), definitionBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName), definitions = definitionBNFNodes.map((definitionBNFNode) => {
          const definition = definitionBNFNode.generateDefinition();
          return definition;
        });
        return definitions;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(DefinitionsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/terminalPart.js
  var require_terminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var TerminalPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), node = firstChildNode, part = node.generatePart(callAhead);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(TerminalPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/choiceOfParts.js
  var require_choiceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsPart;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _parse = require_parse();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, partChoices) {
        super(type, callAhead);
        this.partChoices = partChoices;
      }
      getPartChoices() {
        return this.partChoices;
      }
      getParts() {
        const parts = this.partChoices.map((partChoice) => {
          const part = partChoice.getPart();
          return part;
        });
        return parts;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedPrecedence = state.getSavedPrecedence();
        parsed = this.partChoices.some((partChoice) => {
          let parsed2;
          const part = partChoice.getPart(), savedIndex = state.getSavedIndex(), precedence = partChoice.getPrecedence(), nodesLength = nodes.length;
          if (precedence !== null) {
            state.setPrecedence(precedence);
          }
          callback = callAhead === null ? null : () => {
            let parsed3;
            parsed3 = callAhead();
            return parsed3;
          };
          parsed2 = (0, _parse.parsePart)(part, nodes, state, callback, callAhead);
          if (!parsed2) {
            const start = nodesLength;
            nodes.splice(start);
            state.backtrack(savedIndex);
          }
          return parsed2;
        });
        if (!parsed) {
          state.resetPrecedence(savedPrecedence);
        }
        return parsed;
      }
      asString() {
        const partChoicesString = this.partChoices.reduce((partChoicesString2, partChoice) => {
          const partChoiceString = partChoice.asString();
          if (partChoicesString2 === null) {
            partChoicesString2 = partChoiceString;
          } else {
            partChoicesString2 = `${partChoicesString2} | ${partChoiceString}`;
          }
          return partChoicesString2;
        }, null), string = `( ${partChoicesString} )`;
        return string;
      }
      static fromPartChoices(partChoices) {
        const type = _partTypes.ChoiceOfPartsPartType, callAhead = false, choiceOfPartsPart = new ChoiceOfPartsPart(type, callAhead, partChoices);
        return choiceOfPartsPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/choiceOfParts.js
  var require_choiceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const ruleName = _ruleNames.PART_CHOICE_RULE_NAME, childNodes = this.getChildNodes(), partChoiceBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const partChoices = partChoiceBNFNodes.map((partChoiceBNFNode) => {
          const partChoice = partChoiceBNFNode.generatePartChoice(callAhead);
          return partChoice;
        }), choiceOfPartsPart = _choiceOfParts.default.fromPartChoices(partChoices), part = choiceOfPartsPart;
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ChoiceOfPartsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/stringLiteral.js
  var require_stringLiteral2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralPart;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StringLiteralPart = class extends _terminal.default {
      constructor(content) {
        super();
        this.content = content;
      }
      getContent() {
        return this.content;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const content = significantToken.getContent();
          if (content === this.content) {
            terminalNode = _terminal1.default.fromSignificantToken(significantToken);
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const content = this.content.replace(/\\/, "\\\\"), string = `"${content}"`;
        return string;
      }
      static fromContent(content) {
        const stringLiteralPart = new StringLiteralPart(content);
        return stringLiteralPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/stringLiteral.js
  var require_stringLiteral3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var StringLiteralBNFNode = class extends _nonTerminal.default {
      regularExpression = /^"((?:\\.|[^"\\])*)"$/;
      generatePart(callAhead) {
        const content = this.getContent(), stringLiteralPart = _stringLiteral.default.fromContent(content);
        return stringLiteralPart;
      }
      getContent() {
        let content;
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches);
        content = secondMatch;
        content = sanitiseContent(content);
        return content;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(StringLiteralBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    function sanitiseContent(content) {
      content = content.replace(/\\\\/g, _constants.ESCAPED_BACKSLASH).replace(/\\"/g, _constants.ESCAPED_DOUBLE_QUOTE);
      return content;
    }
  });

  // node_modules/occam-parsers/lib/node/bnf/nonTerminalPart.js
  var require_nonTerminalPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var NonTerminalPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const childNodes = this.getChildNodes();
        if (!callAhead) {
          const ruleName = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME, callAheadModifierBNFNode = (0, _node.nodeFromChildNodesAndRuleName)(childNodes, ruleName);
          callAhead = callAheadModifierBNFNode !== null;
        }
        const firstChildNode = first2(childNodes), node = firstChildNode, part = node.generatePart(callAhead);
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NonTerminalPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/nonTerminal/sequenceOfParts.js
  var require_sequenceOfParts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsPart;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal2());
    var _parse = require_parse();
    var _partTypes = require_partTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsPart = class extends _nonTerminal.default {
      constructor(type, callAhead, parts) {
        super(type, callAhead);
        this.parts = parts;
      }
      getParts() {
        return this.parts;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        const savedIndex = state.getSavedIndex(), nodesLength = nodes.length;
        callback = callAhead === null ? null : () => {
          let parsed2;
          parsed2 = callAhead();
          return parsed2;
        };
        parsed = (0, _parse.parseParts)(this.parts, nodes, state, callback, callAhead);
        if (!parsed) {
          const start = nodesLength;
          nodes.splice(start);
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const partsString = this.parts.reduce((partsString2, part) => {
          const partString = part.asString();
          if (partsString2 === null) {
            partsString2 = partString;
          } else {
            partsString2 = `${partsString2} ${partString}`;
          }
          return partsString2;
        }, null), string = `( ${partsString} )`;
        return string;
      }
      static fromParts(parts) {
        const type = _partTypes.SequenceOfPartsPartType, callAhead = false, sequenceOfPartsPart = new SequenceOfPartsPart(type, callAhead, parts);
        return sequenceOfPartsPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/sequenceOfParts.js
  var require_sequenceOfParts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    var _node = require_node2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const ruleName = _ruleNames.PART_RULE_NAME, childNodes = this.getChildNodes(), partBNFNodes = (0, _node.nodesFromChildNodesAndRuleName)(childNodes, ruleName);
        callAhead = false;
        const parts = partBNFNodes.map((partBNFNode) => {
          const part2 = partBNFNode.generatePart(callAhead);
          return part2;
        }), sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), part = sequenceOfPartsPart;
        return part;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(SequenceOfPartsBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/opacityModifier.js
  var require_opacityModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {second} = _necessary.arrayUtilities;
    var OpacityModifierBNFNode = class extends _nonTerminal.default {
      getOpacity() {
        const childNodes = this.getChildNodes(), secondChildNode = second(childNodes), terminalNode = secondChildNode, terminalNodeContent = terminalNode.getContent(), opacity = terminalNodeContent;
        return opacity;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OpacityModifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/noWhitespaceNode.js
  var require_noWhitespaceNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespaceNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespaceNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = noWhitespace, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(NoWhitespaceNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const noWhitespaceNodeParseTree = terminalNodeParseTree;
        return noWhitespaceNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/noWhitespace.js
  var require_noWhitespace = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespaceNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _noWhitespaceNode = /* @__PURE__ */ _interop_require_default(require_noWhitespaceNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespaceNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = _constants.EMPTY_STRING;
        return content;
      }
      isNoWhitespaceNode() {
        const noWhitespaceNode = true;
        return noWhitespaceNode;
      }
      asParseTree(tokens) {
        const noWhitespaceNodeParseTree = _noWhitespaceNode.default.fromNothing(), parseTree = noWhitespaceNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeNoWhitespaceNode = terminalNode.isNoWhitespaceNode();
          if (terminalNodeNoWhitespaceNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(NoWhitespaceNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/noWhitespace.js
  var require_noWhitespace2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespacePart = class extends _terminal.default {
      isNoWhitespacePart() {
        const noWhitespacePart = true;
        return noWhitespacePart;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let noWhitespaceNode = null;
        const savedIndex = state.getSavedIndex(), nextTokenWhitespaceToken = state.isNextTokenWhitespaceToken();
        if (!nextTokenWhitespaceToken) {
          noWhitespaceNode = _noWhitespace.default.fromNothing();
        }
        parsed = noWhitespaceNode !== null;
        if (parsed) {
          nodes.push(noWhitespaceNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = noWhitespace;
        return string;
      }
      static fromNothing() {
        const noWhitespacePart = new NoWhitespacePart();
        return noWhitespacePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/noWhitespacePart.js
  var require_noWhitespacePart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespacePartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const noWhitespacePart = _noWhitespace.default.fromNothing();
        return noWhitespacePart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(NoWhitespacePartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/callAheadModifier.js
  var require_callAheadModifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CallAheadModifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(CallAheadModifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/regularExpression.js
  var require_regularExpression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionPart;
      }
    });
    var _necessary = require_browser();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var RegularExpressionPart = class extends _terminal.default {
      constructor(regularExpression) {
        super();
        this.regularExpression = regularExpression;
      }
      getRegularExpression() {
        return this.regularExpression;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const content = significantToken.getContent(), matches = content.match(this.regularExpression);
          if (matches !== null) {
            const firstMatch = first2(matches);
            if (firstMatch === content) {
              terminalNode = _terminal1.default.fromSignificantToken(significantToken);
            }
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const regularExpressionString = this.regularExpression.toString(), string = regularExpressionString;
        return string;
      }
      static fromRegularExpression(regularExpression) {
        const regularExpressionPart = new RegularExpressionPart(regularExpression);
        return regularExpressionPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/regularExpression.js
  var require_regularExpression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var RegularExpressionBNFNode = class extends _nonTerminal.default {
      regularExpression = /^\/((?:\\.|[^\/])*)\/$/;
      generatePart(callAhead) {
        const regularExpression = this.getRegularExpression(), regularExpressionPart = _regularExpression.default.fromRegularExpression(regularExpression);
        return regularExpressionPart;
      }
      getRegularExpression() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches), pattern = secondMatch, regularExpression = new RegExp(pattern);
        return regularExpression;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(RegularExpressionBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/parseTree/startOfContentNode.js
  var require_startOfContentNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentNodeParseTree;
      }
    });
    var _occamlexers = require_lib3();
    var _verticalBranch = /* @__PURE__ */ _interop_require_default(require_verticalBranch());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentNodeParseTree = class extends _verticalBranch.default {
      static fromNothing() {
        const string = startOfContent, stringLength = string.length, verticalBranchParseTreeWidth = stringLength, verticalBranchParseTree = _verticalBranch.default.fromWidth(verticalBranchParseTreeWidth), verticalBranchPosition = verticalBranchParseTree.getVerticalBranchPosition(), terminalNodeParseTree = _verticalBranch.default.fromStringAndVerticalBranchPosition(StartOfContentNodeParseTree, string, verticalBranchPosition);
        terminalNodeParseTree.appendToTop(verticalBranchParseTree);
        const startOfContentNodeParseTree = terminalNodeParseTree;
        return startOfContentNodeParseTree;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/terminal/startOfContent.js
  var require_startOfContent = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentNode;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _startOfContentNode = /* @__PURE__ */ _interop_require_default(require_startOfContentNode());
    var _constants = require_constants4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentNode = class extends _terminal.default {
      getType() {
        const type = null;
        return type;
      }
      getContent() {
        const content = _constants.EMPTY_STRING;
        return content;
      }
      isStartOfContentNode() {
        const startOfContentNode = true;
        return startOfContentNode;
      }
      asParseTree(tokens) {
        const startOfContentNodeParseTree = _startOfContentNode.default.fromNothing(), parseTree = startOfContentNodeParseTree;
        return parseTree;
      }
      match(node, depth) {
        let matches = false;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node, terminalNodeStartOfContentNode = terminalNode.isStartOfContentNode();
          if (terminalNodeStartOfContentNode) {
            matches = true;
          }
        }
        return matches;
      }
      static fromNothing() {
        return _terminal.default.fromNothing(StartOfContentNode);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/startOfContent.js
  var require_startOfContent2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPart;
      }
    });
    var _occamlexers = require_lib3();
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _startOfContent = /* @__PURE__ */ _interop_require_default(require_startOfContent());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentPart = class extends _terminal.default {
      isStartOfContentPart() {
        const startOfContentPart = true;
        return startOfContentPart;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let startOfContentNode = null;
        const savedIndex = state.getSavedIndex(), atStartOfContent = state.isAtStartOfContent();
        if (atStartOfContent) {
          startOfContentNode = _startOfContent.default.fromNothing();
        }
        parsed = startOfContentNode !== null;
        if (parsed) {
          nodes.push(startOfContentNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = startOfContent;
        return string;
      }
      static fromNothing() {
        const startOfContentPart = new StartOfContentPart();
        return startOfContentPart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/startOfContentPart.js
  var require_startOfContentPart = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _startOfContent = /* @__PURE__ */ _interop_require_default(require_startOfContent2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentPartBNFNode = class extends _nonTerminal.default {
      generatePart(callAhead) {
        const startOfContentPart = _startOfContent.default.fromNothing();
        return startOfContentPart;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(StartOfContentPartBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/optionalQuantifier.js
  var require_optionalQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OptionalQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OptionalQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OptionalQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/oneOneOrMoreQuantifier.js
  var require_oneOneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OneOrMoreQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OneOrMoreQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(OneOrMoreQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/part/terminal/significantTokenType.js
  var require_significantTokenType = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypePart;
      }
    });
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal());
    var _terminal1 = /* @__PURE__ */ _interop_require_default(require_terminal2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantTokenTypePart = class extends _terminal.default {
      constructor(significantTokenType) {
        super();
        this.significantTokenType = significantTokenType;
      }
      getSignificantTokenType() {
        return this.significantTokenType;
      }
      parse(nodes, state, callback, callAhead) {
        let parsed;
        let terminalNode = null;
        const savedIndex = state.getSavedIndex(), nextSignificantToken = state.getNextSignificantToken(), significantToken = nextSignificantToken;
        if (significantToken !== null) {
          const significantTokenType = significantToken.getType();
          if (significantTokenType === this.significantTokenType) {
            terminalNode = _terminal1.default.fromSignificantToken(significantToken);
          }
        }
        parsed = terminalNode !== null;
        if (parsed) {
          nodes.push(terminalNode);
          if (parsed) {
            if (callAhead !== null) {
              parsed = callAhead();
            }
          }
        }
        if (!parsed) {
          state.backtrack(savedIndex);
        }
        return parsed;
      }
      asString() {
        const string = `[${this.significantTokenType}]`;
        return string;
      }
      static fromSignificantTokenType(significantTokenType) {
        const significantTokenTypePart = new SignificantTokenTypePart(significantTokenType);
        return significantTokenTypePart;
      }
    };
  });

  // node_modules/occam-parsers/lib/node/bnf/significantTokenType.js
  var require_significantTokenType2 = __commonJS((exports, module) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeBNFNode;
      }
    });
    var _necessary = require_browser();
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var SignificantTokenTypeBNFNode = class extends _nonTerminal.default {
      regularExpression = /^\[([^\]]+)]$/;
      generatePart(callAhead) {
        const significantTokenType = this.getSignificantTokenType(), significantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType);
        return significantTokenTypePart;
      }
      getSignificantTokenType() {
        const childNodes = this.getChildNodes(), firstChildNode = first2(childNodes), terminalNode = firstChildNode, terminalNodeContent = terminalNode.getContent(), matches = terminalNodeContent.match(this.regularExpression), secondMatch = second(matches), significantTokenType = secondMatch;
        return significantTokenType;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(SignificantTokenTypeBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
    module.exports = SignificantTokenTypeBNFNode;
  });

  // node_modules/occam-parsers/lib/node/bnf/zeroOneOrMoreQuantifier.js
  var require_zeroOneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZerorOrMoreQuantifierBNFNode;
      }
    });
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ZerorOrMoreQuantifierBNFNode = class extends _nonTerminal.default {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _nonTerminal.default.fromRuleNameChildNodesOpacityAndPrecedence(ZerorOrMoreQuantifierBNFNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-parsers/lib/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _part = /* @__PURE__ */ _interop_require_default(require_part());
    var _name = /* @__PURE__ */ _interop_require_default(require_name2());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule3());
    var _error = /* @__PURE__ */ _interop_require_default(require_error());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon3());
    var _document = /* @__PURE__ */ _interop_require_default(require_document2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName3());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard2());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine7());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice2());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence());
    var _quantifier = /* @__PURE__ */ _interop_require_default(require_quantifier());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition2());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions());
    var _terminalPart = /* @__PURE__ */ _interop_require_default(require_terminalPart());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral3());
    var _nonTerminalPart = /* @__PURE__ */ _interop_require_default(require_nonTerminalPart());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts2());
    var _opacityModifier = /* @__PURE__ */ _interop_require_default(require_opacityModifier());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart());
    var _callAheadModifier = /* @__PURE__ */ _interop_require_default(require_callAheadModifier());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression3());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart());
    var _optionalQuantifier = /* @__PURE__ */ _interop_require_default(require_optionalQuantifier());
    var _oneOneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_oneOneOrMoreQuantifier());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType2());
    var _zeroOneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_zeroOneOrMoreQuantifier());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeMap = {
      [_ruleNames.NAME_RULE_NAME]: _name.default,
      [_ruleNames.PART_RULE_NAME]: _part.default,
      [_ruleNames.RULE_RULE_NAME]: _rule.default,
      [_ruleNames.ERROR_RULE_NAME]: _error.default,
      [_ruleNames.EPSILON_RULE_NAME]: _epsilon.default,
      [_ruleNames.DOCUMENT_RULE_NAME]: _document.default,
      [_ruleNames.WILDCARD_RULE_NAME]: _wildcard.default,
      [_ruleNames.RULE_NAME_RULE_NAME]: _ruleName.default,
      [_ruleNames.DEFINITION_RULE_NAME]: _definition.default,
      [_ruleNames.PRECEDENCE_RULE_NAME]: _precedence.default,
      [_ruleNames.QUANTIFIER_RULE_NAME]: _quantifier.default,
      [_ruleNames.END_OF_LINE_RULE_NAME]: _endOfLine.default,
      [_ruleNames.PART_CHOICE_RULE_NAME]: _partChoice.default,
      [_ruleNames.DEFINITIONS_RULE_NAME]: _definitions.default,
      [_ruleNames.TERMINAL_PART_RULE_NAME]: _terminalPart.default,
      [_ruleNames.STRING_LITERAL_RULE_NAME]: _stringLiteral.default,
      [_ruleNames.CHOICE_OF_PARTS_RULE_NAME]: _choiceOfParts.default,
      [_ruleNames.OPACITY_MODIFIER_RULE_NAME]: _opacityModifier.default,
      [_ruleNames.NON_TERMINAL_PART_RULE_NAME]: _nonTerminalPart.default,
      [_ruleNames.SEQUENCE_OF_PARTS_RULE_NAME]: _sequenceOfParts.default,
      [_ruleNames.NO_WHITESPACE_PART_RULE_NAME]: _noWhitespacePart.default,
      [_ruleNames.REGULAR_EXPRESSION_RULE_NAME]: _regularExpression.default,
      [_ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME]: _callAheadModifier.default,
      [_ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME]: _optionalQuantifier.default,
      [_ruleNames.START_OF_CONTENT_PART_RULE_NAME]: _startOfContentPart.default,
      [_ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME]: _significantTokenType.default,
      [_ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME]: _oneOneOrMoreQuantifier.default,
      [_ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME]: _zeroOneOrMoreQuantifier.default
    };
    var _default = NonTerminalNodeMap;
  });

  // node_modules/occam-parsers/lib/state.js
  var require_state2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return State;
      }
    });
    var State = class {
      constructor(index, tokens, ruleMap, precedence, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode) {
        this.index = index;
        this.tokens = tokens;
        this.ruleMap = ruleMap;
        this.precedence = precedence;
        this.startOfContent = startOfContent;
        this.NonTerminalNodeMap = NonTerminalNodeMap;
        this.defaultNonTerminalNode = defaultNonTerminalNode;
      }
      getIndex() {
        return this.index;
      }
      getTokens() {
        return this.tokens;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      getPrecedence() {
        return this.precedence;
      }
      getStartOfContent() {
        return this.startOfContent;
      }
      getNonTerminalNode() {
        return this.NonTerminalNodeMap;
      }
      getDefaultNonTerminalNode() {
        return this.defaultNonTerminalNode;
      }
      setIndex(index) {
        this.index = index;
      }
      setTokens(tokens) {
        this.tokens = tokens;
      }
      setRuleMap(ruleMap) {
        this.ruleMap = ruleMap;
      }
      setPrecedence(precedence) {
        this.precedence = precedence;
      }
      setStartOfContent(startOfContent) {
        this.startOfContent = startOfContent;
      }
      getSavedPrecedence() {
        const savedPrecedence = this.precedence;
        return savedPrecedence;
      }
      getSavedIndex() {
        const savedIndex = this.index;
        return savedIndex;
      }
      getNextToken() {
        let nextToken = null;
        const tokensLength = this.tokens.length;
        if (this.index < tokensLength) {
          nextToken = this.tokens[this.index++];
        }
        return nextToken;
      }
      isAtStartOfContent() {
        const atStartOfContent = this.startOfContent ? this.index === 0 : false;
        return atStartOfContent;
      }
      getNextSignificantToken() {
        let nextSignificantToken = null;
        const tokensLength = this.tokens.length;
        while (this.index < tokensLength) {
          const token = this.tokens[this.index++], tokenSignificant = token.isSignificant();
          if (tokenSignificant) {
            const significantToken = token;
            nextSignificantToken = significantToken;
            break;
          }
        }
        return nextSignificantToken;
      }
      isNextTokenWhitespaceToken() {
        let nextTokenWhitespaceToken = false;
        const tokensLength = this.tokens.length;
        if (this.index < tokensLength) {
          const nextToken = this.tokens[this.index];
          nextTokenWhitespaceToken = nextToken.isWhitespaceToken();
        }
        return nextTokenWhitespaceToken;
      }
      backtrack(savedIndex) {
        this.index = savedIndex;
      }
      resetPrecedence(savedPrecedence) {
        this.precedence = savedPrecedence;
      }
      NonTerminalNodeFromRuleName(ruleName) {
        const NonTerminalNode = Object.hasOwn(this.NonTerminalNodeMap, ruleName) ? this.NonTerminalNodeMap[ruleName] : this.defaultNonTerminalNode;
        return NonTerminalNode;
      }
      static fromTokensRuleMapStartOfContentNonTerminalNodeMapAndDefaultNonTerminalNode(tokens, ruleMap, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode) {
        const index = 0, precedence = null, state = new State(index, tokens, ruleMap, precedence, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode);
        return state;
      }
    };
  });

  // node_modules/occam-parsers/lib/mixins/parser.js
  var require_parser = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _state = /* @__PURE__ */ _interop_require_default(require_state2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    function parse(tokens, rule = this.startRule, startOfContent = true) {
      let node = null;
      const nodes = [], {NonTerminalNodeMap, defaultNonTerminalNode} = this.constructor, state = _state.default.fromTokensRuleMapStartOfContentNonTerminalNodeMapAndDefaultNonTerminalNode(tokens, this.ruleMap, startOfContent, NonTerminalNodeMap, defaultNonTerminalNode), callback = null, callAhead = null, parsed = rule.parse(nodes, state, callback, callAhead);
      if (parsed) {
        const firstNode = first2(nodes);
        node = firstNode;
      }
      return node;
    }
    var parserMixins = {
      parse
    };
    var _default = parserMixins;
  });

  // node_modules/occam-parsers/lib/definition/name.js
  var require_name3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {nameType} = _occamlexers.types;
    var NameDefinition = class extends _definition.default {
      static fromNothing() {
        const significantTokenType = nameType, nameSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), parts = [
          nameSignificantTokenTypePart
        ], precedence = null, nameDefinition = new NameDefinition(parts, precedence);
        return nameDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/name.js
  var require_name4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NameBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _name = /* @__PURE__ */ _interop_require_default(require_name3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NameBNFRule = class extends _rule.default {
      static fromNothing() {
        const nameDefinition = _name.default.fromNothing(), name = _ruleNames.NAME_RULE_NAME, opacity = null, definitions = [
          nameDefinition
        ], nameRule = new NameBNFRule(name, opacity, definitions);
        return nameRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/terminal.js
  var require_terminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.QUANTIFIER_RULE_NAME;
        const quantifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.TERMINAL_PART_RULE_NAME;
        const terminalPartRuleNamePart = _ruleName.default.fromRuleName(ruleName), zeroOrMoreQuantifierRuleNamePartsPart = _zeroOrMoreParts.default.fromPart(quantifierRuleNamePart), parts = [
          terminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ], precedence = null, terminalPartRuleDefinition = new TerminalPartRuleDefinition(parts, precedence);
        return terminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal.js
  var require_nonTerminal3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.QUANTIFIER_RULE_NAME;
        const quantifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NON_TERMINAL_PART_RULE_NAME;
        const nonTerminalPartRuleNamePart = _ruleName.default.fromRuleName(ruleName), zeroOrMoreQuantifierRuleNamePartsPart = _zeroOrMoreParts.default.fromPart(quantifierRuleNamePart), parts = [
          nonTerminalPartRuleNamePart,
          zeroOrMoreQuantifierRuleNamePartsPart
        ], precedence = null, nonTerminalPartRuleDefinition = new NonTerminalPartRuleDefinition(parts, precedence);
        return nonTerminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/part.js
  var require_part2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal3());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PART_RULE_NAME, terminalPartRuleDefinition = _terminal.default.fromNothing(), nonTerminalPartRuleDefinition = _nonTerminal.default.fromNothing(), opacity = null, definitions = [
          nonTerminalPartRuleDefinition,
          terminalPartRuleDefinition
        ], partRule = new PartBNFRule(name, opacity, definitions);
        return partRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/rule.js
  var require_rule4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {separator, terminator} = _occamlexers.specialSymbols;
    var RuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        const separatorStringLiteralContent = separator, terminatorStringLiteralContent = terminator;
        ruleName = _ruleNames.OPACITY_MODIFIER_RULE_NAME;
        const opacityModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NAME_RULE_NAME;
        const nameRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalOpacityRuleNamePartPart = _optionalPart.default.fromPart(opacityModifierRuleNamePart), separatorStringLiteralPart = _stringLiteral.default.fromContent(separatorStringLiteralContent);
        ruleName = _ruleNames.DEFINITIONS_RULE_NAME;
        const definitionsRuleNamePart = _ruleName.default.fromRuleName(ruleName), terminatorStringLiteralPart = _stringLiteral.default.fromContent(terminatorStringLiteralContent), parts = [
          nameRuleNamePart,
          optionalOpacityRuleNamePartPart,
          separatorStringLiteralPart,
          definitionsRuleNamePart,
          terminatorStringLiteralPart
        ], precedence = null, ruleDefinition = new RuleDefinition(parts, precedence);
        return ruleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/rule.js
  var require_rule5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _rule1 = /* @__PURE__ */ _interop_require_default(require_rule4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleBNFRule = class extends _rule.default {
      static fromNothing() {
        const ruleDefinition = _rule1.default.fromNothing(), name = _ruleNames.RULE_RULE_NAME, opacity = null, definitions = [
          ruleDefinition
        ], ruleRule = new RuleBNFRule(name, opacity, definitions);
        return ruleRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/error.js
  var require_error2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ErrorDefinition = class extends _definition.default {
      static fromNothing() {
        const wildcardPart = _wildcard.default.fromNothing(), parts = [
          wildcardPart
        ], precedence = null, errorDefinition = new ErrorDefinition(parts, precedence);
        return errorDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/error.js
  var require_error3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _error = /* @__PURE__ */ _interop_require_default(require_error2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque} = _occamlexers.specialSymbols;
    var ErrorBNFRule = class extends _rule.default {
      static fromNothing() {
        const errorDefinition = _error.default.fromNothing(), name = _ruleNames.ERROR_RULE_NAME, opacity = opaque, definitions = [
          errorDefinition
        ], errorRule = new ErrorBNFRule(name, opacity, definitions);
        return errorRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/stringLiteral.js
  var require_stringLiteral4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StringLiteralDefinition = class extends _definition.default {
      static fromContent(content) {
        const stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, stringLiteralDefinition = new StringLiteralDefinition(parts, precedence);
        return stringLiteralDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/epsilon.js
  var require_epsilon4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {epsilon} = _occamlexers.specialSymbols;
    var EpsilonBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = epsilon, epsilonStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.EPSILON_RULE_NAME, opacity = null, definitions = [
          epsilonStringLiteralDefinition
        ], epsilonRule = new EpsilonBNFRule(name, opacity, definitions);
        return epsilonRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/document.js
  var require_document3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.RULE_RULE_NAME;
        const ruleRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ERROR_RULE_NAME;
        const errorRuleNamePart = _ruleName.default.fromRuleName(ruleName), ruleRuleNamePartChoice = _partChoice.default.fromPart(ruleRuleNamePart), errorRuleNamePartChoice = _partChoice.default.fromPart(errorRuleNamePart), partChoices = [
          ruleRuleNamePartChoice,
          errorRuleNamePartChoice
        ], choiceOfRuleRuleNameAndErrorRuleNamePartsPart = _choiceOfParts.default.fromPartChoices(partChoices), oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart = _oneOrMoreParts.default.fromPart(choiceOfRuleRuleNameAndErrorRuleNamePartsPart), parts = [
          oneOrMoreChoiceOfRuleRuleNameAndErrorRuleNamePartsPartsPart
        ], precedence = null, documentDefinition = new DocumentDefinition(parts, precedence);
        return documentDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/document.js
  var require_document4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _document = /* @__PURE__ */ _interop_require_default(require_document3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DocumentBNFRule = class extends _rule.default {
      static fromNothing() {
        const documentDefinition = _document.default.fromNothing(), name = _ruleNames.DOCUMENT_RULE_NAME, opacity = null, definitions = [
          documentDefinition
        ], documentRule = new DocumentBNFRule(name, opacity, definitions);
        return documentRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/ruleName.js
  var require_ruleName4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _name = /* @__PURE__ */ _interop_require_default(require_name3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameBNFRule = class extends _rule.default {
      static fromNothing() {
        const nameDefinition = _name.default.fromNothing(), name = _ruleNames.RULE_NAME_RULE_NAME, opacity = null, definitions = [
          nameDefinition
        ], ruleNameRule = new RuleNameBNFRule(name, opacity, definitions);
        return ruleNameRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/wildcard.js
  var require_wildcard3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return WildcardBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {wildcard} = _occamlexers.specialSymbols;
    var WildcardBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = wildcard, wildcardStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.WILDCARD_RULE_NAME, opacity = null, definitions = [
          wildcardStringLiteralDefinition
        ], wildcardRule = new WildcardBNFRule(name, opacity, definitions);
        return wildcardRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/endOfLine.js
  var require_endOfLine8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EndOfLineBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral4());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {endOfLine} = _occamlexers.specialSymbols;
    var EndOfLineBNFRule = class extends _rule.default {
      static fromNothing() {
        const content = endOfLine, endOfLineStringLiteralDefinition = _stringLiteral.default.fromContent(content), name = _ruleNames.END_OF_LINE_RULE_NAME, opacity = null, definitions = [
          endOfLineStringLiteralDefinition
        ], endOfLineRule = new EndOfLineBNFRule(name, opacity, definitions);
        return endOfLineRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partChoice.js
  var require_partChoice3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.PART_RULE_NAME;
        const partRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalPrecedenceRuleNamePartPart = _optionalPart.default.fromPart(precedenceRuleNamePart), parts = [
          partRuleNamePart,
          optionalPrecedenceRuleNamePartPart
        ], precedence = null, partChoiceDefinition = new PartChoiceDefinition(parts, precedence);
        return partChoiceDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/partChoice.js
  var require_partChoice4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PartChoiceBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PartChoiceBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PART_CHOICE_RULE_NAME, partChoiceDefinition = _partChoice.default.fromNothing(), opacity = null, definitions = [
          partChoiceDefinition
        ], definitionRule = new PartChoiceBNFRule(name, opacity, definitions);
        return definitionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/ruleName.js
  var require_ruleName5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameDefinition = class extends _definition.default {
      static fromRuleName(ruleName) {
        const ruleNameRuleNamePart = _ruleName.default.fromRuleName(ruleName), parts = [
          ruleNameRuleNamePart
        ], precedence = null, ruleNameDefinition = new RuleNameDefinition(parts, precedence);
        return ruleNameDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/quantifier.js
  var require_quantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.QUANTIFIER_RULE_NAME;
        ruleName = _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME;
        const optionalQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME;
        const oneOrMoreQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME;
        const zeroOrMoreQuantifierRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), opacity = null, definitions = [
          optionalQuantifierRuleNameDefinition,
          oneOrMoreQuantifierRuleNameDefinition,
          zeroOrMoreQuantifierRuleNameDefinition
        ], quantifierRule = new QuantifierBNFRule(name, opacity, definitions);
        return quantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/definition.js
  var require_definition3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.PART_RULE_NAME;
        const partRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.PRECEDENCE_RULE_NAME;
        const precedenceRuleNamePart = _ruleName.default.fromRuleName(ruleName), oneOrMoreRuleNamePartsPart = _oneOrMoreParts.default.fromPart(partRuleNamePart), optionalPrecedenceRuleNamePartPart = _optionalPart.default.fromPart(precedenceRuleNamePart), parts = [
          oneOrMoreRuleNamePartsPart,
          optionalPrecedenceRuleNamePartPart
        ], precedence = null, definitionDefinition = new DefinitionDefinition(parts, precedence);
        return definitionDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/definition.js
  var require_definition4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.DEFINITION_RULE_NAME, definitionDefinition = _definition.default.fromNothing(), opacity = null, definitions = [
          definitionDefinition
        ], definitionRule = new DefinitionBNFRule(name, opacity, definitions);
        return definitionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/precedence.js
  var require_precedence2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {numberType} = _occamlexers.types;
    var {openBracket, closeBracket} = _occamlexers.specialSymbols;
    var PrecedenceDefinition = class extends _definition.default {
      static fromNothing() {
        const significantTokenType = numberType, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), numberSignificantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), optionalNumberSignificantTokenTypePartPart = _optionalPart.default.fromPart(numberSignificantTokenTypePart), parts = [
          openBracketStringLiteralPart,
          optionalNumberSignificantTokenTypePartPart,
          closeBracketStringLiteralPart
        ], precedence = null, precedenceDefinition = new PrecedenceDefinition(parts, precedence);
        return precedenceDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/precedence.js
  var require_precedence3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrecedenceBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrecedenceBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.PRECEDENCE_RULE_NAME, precedenceDefinition = _precedence.default.fromNothing(), opacity = null, definitions = [
          precedenceDefinition
        ], precedenceRule = new PrecedenceBNFRule(name, opacity, definitions);
        return precedenceRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/definitions.js
  var require_definitions2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {verticalBar} = _occamlexers.specialSymbols;
    var DefinitionsDefinition = class extends _definition.default {
      static fromNothing() {
        let parts;
        const content = verticalBar, ruleName = _ruleNames.DEFINITION_RULE_NAME, definitionRuleNamePart = _ruleName.default.fromRuleName(ruleName), verticalBarStringLiteralPart = _stringLiteral.default.fromContent(content);
        parts = [
          verticalBarStringLiteralPart,
          definitionRuleNamePart
        ];
        const sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), zeroOrMoreSequenceOfPartsPart = _zeroOrMoreParts.default.fromPart(sequenceOfPartsPart);
        parts = [
          definitionRuleNamePart,
          zeroOrMoreSequenceOfPartsPart
        ];
        const precedence = null, definitionsDefinition = new DefinitionsDefinition(parts, precedence);
        return definitionsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/definitions.js
  var require_definitions3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DefinitionsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DefinitionsBNFRule = class extends _rule.default {
      static fromNothing() {
        const definitionsDefinition = _definitions.default.fromNothing(), name = _ruleNames.DEFINITIONS_RULE_NAME, opacity = null, definitions = [
          definitionsDefinition
        ], definitionsRule = new DefinitionsBNFRule(name, opacity, definitions);
        return definitionsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/terminalPart.js
  var require_terminalPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TerminalPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TerminalPartBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.TERMINAL_PART_RULE_NAME;
        ruleName = _ruleNames.EPSILON_RULE_NAME;
        const epsilonRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.WILDCARD_RULE_NAME;
        const wildcardRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.END_OF_LINE_RULE_NAME;
        const endOfLineRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.STRING_LITERAL_RULE_NAME;
        const stringLiteralRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.NO_WHITESPACE_PART_RULE_NAME;
        const noWhitespacePartRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.REGULAR_EXPRESSION_RULE_NAME;
        const regularExpressionRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.START_OF_CONTENT_PART_RULE_NAME;
        const startOfContentPartRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME;
        const significantTokenTypeRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), opacity = null, definitions = [
          significantTokenTypeRuleNameDefinition,
          regularExpressionRuleNameDefinition,
          stringLiteralRuleNameDefinition,
          endOfLineRuleNameDefinition,
          wildcardRuleNameDefinition,
          epsilonRuleNameDefinition,
          noWhitespacePartRuleNameDefinition,
          startOfContentPartRuleNameDefinition
        ], terminalPartRule = new TerminalPartBNFRule(name, opacity, definitions);
        return terminalPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/choiceOfParts.js
  var require_choiceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {verticalBar, openBracket, closeBracket} = _occamlexers.specialSymbols;
    var ChoiceOfPartsDefinition = class extends _definition.default {
      static fromNothing() {
        let parts;
        const ruleName = _ruleNames.PART_CHOICE_RULE_NAME, verticalBarStringLiteralContent = verticalBar, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, partChoiceRuleNamePart = _ruleName.default.fromRuleName(ruleName), verticalBarStringLiteralPart = _stringLiteral.default.fromContent(verticalBarStringLiteralContent), openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent);
        parts = [
          verticalBarStringLiteralPart,
          partChoiceRuleNamePart
        ];
        const sequenceOfPartsPart = _sequenceOfParts.default.fromParts(parts), oneOrMoreSequenceOfPartsPart = _oneOrMoreParts.default.fromPart(sequenceOfPartsPart);
        parts = [
          openBracketStringLiteralPart,
          partChoiceRuleNamePart,
          oneOrMoreSequenceOfPartsPart,
          closeBracketStringLiteralPart
        ];
        const precedence = null, choiceOfPartsDefinition = new ChoiceOfPartsDefinition(parts, precedence);
        return choiceOfPartsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/choiceOfParts.js
  var require_choiceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ChoiceOfPartsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ChoiceOfPartsBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.CHOICE_OF_PARTS_RULE_NAME, choiceOfPartsDefinition = _choiceOfParts.default.fromNothing(), opacity = null, definitions = [
          choiceOfPartsDefinition
        ], choiceOfPartsRule = new ChoiceOfPartsBNFRule(name, opacity, definitions);
        return choiceOfPartsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/significantTokenType.js
  var require_significantTokenType3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SignificantTokenTypeDefinition = class extends _definition.default {
      static fromSignificantTokenType(significantTokenType) {
        const significantTokenTypePart = _significantTokenType.default.fromSignificantTokenType(significantTokenType), parts = [
          significantTokenTypePart
        ], precedence = null, significantTokenTypeDefinition = new SignificantTokenTypeDefinition(parts, precedence);
        return significantTokenTypeDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/stringLiteral.js
  var require_stringLiteral5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StringLiteralBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {stringLiteralType} = _occamlexers.types;
    var StringLiteralBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = stringLiteralType, stringLiteralSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.STRING_LITERAL_RULE_NAME, opacity = null, definitions = [
          stringLiteralSignificantTokenTypeDefinition
        ], stringLiteralRule = new StringLiteralBNFRule(name, opacity, definitions);
        return stringLiteralRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/partRule/nonTerminal/ruleName.js
  var require_ruleName6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleNameNonTerminalPartRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameNonTerminalPartRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let ruleName;
        ruleName = _ruleNames.RULE_NAME_RULE_NAME;
        const ruleNameRuleNamePart = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME;
        const callAheadModifierRuleNamePart = _ruleName.default.fromRuleName(ruleName), optionalCallAheadRuleNamePartPart = _optionalPart.default.fromPart(callAheadModifierRuleNamePart), parts = [
          ruleNameRuleNamePart,
          optionalCallAheadRuleNamePartPart
        ], precedence = null, ruleNameNonTerminalPartRuleDefinition = new RuleNameNonTerminalPartRuleDefinition(parts, precedence);
        return ruleNameNonTerminalPartRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/nonTerminalPart.js
  var require_nonTerminalPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName5());
    var _ruleName1 = /* @__PURE__ */ _interop_require_default(require_ruleName6());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalPartBNFRule = class extends _rule.default {
      static fromNothing() {
        let ruleName;
        const name = _ruleNames.NON_TERMINAL_PART_RULE_NAME;
        ruleName = _ruleNames.CHOICE_OF_PARTS_RULE_NAME;
        const choiceOfPartsRuleNameDefinition = _ruleName.default.fromRuleName(ruleName);
        ruleName = _ruleNames.SEQUENCE_OF_PARTS_RULE_NAME;
        const sequenceOfPartsRuleNameDefinition = _ruleName.default.fromRuleName(ruleName), ruleNameNonTerminalPartRuleDefinition = _ruleName1.default.fromNothing(), opacity = null, definitions = [
          choiceOfPartsRuleNameDefinition,
          sequenceOfPartsRuleNameDefinition,
          ruleNameNonTerminalPartRuleDefinition
        ], nonTerminalPartRule = new NonTerminalPartBNFRule(name, opacity, definitions);
        return nonTerminalPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/sequenceOfParts.js
  var require_sequenceOfParts3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {openBracket, closeBracket} = _occamlexers.specialSymbols;
    var SequenceOfPartsDefinition = class extends _definition.default {
      static fromNothing() {
        const ruleName = _ruleNames.PART_RULE_NAME, openBracketStringLiteralContent = openBracket, closeBracketStringLiteralContent = closeBracket, partRuleNamePart = _ruleName.default.fromRuleName(ruleName), openBracketStringLiteralPart = _stringLiteral.default.fromContent(openBracketStringLiteralContent), closeBracketStringLiteralPart = _stringLiteral.default.fromContent(closeBracketStringLiteralContent), oneOrMorePartRuleNamePartsPart = _oneOrMoreParts.default.fromPart(partRuleNamePart), parts = [
          openBracketStringLiteralPart,
          partRuleNamePart,
          oneOrMorePartRuleNamePartsPart,
          closeBracketStringLiteralPart
        ], precedence = null, sequenceOfPartsDefinition = new SequenceOfPartsDefinition(parts, precedence);
        return sequenceOfPartsDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/sequenceOfParts.js
  var require_sequenceOfParts4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SequenceOfPartsBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SequenceOfPartsBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.SEQUENCE_OF_PARTS_RULE_NAME, sequenceOfPartsDefinition = _sequenceOfParts.default.fromNothing(), opacity = null, definitions = [
          sequenceOfPartsDefinition
        ], sequenceOfPartsRule = new SequenceOfPartsBNFRule(name, opacity, definitions);
        return sequenceOfPartsRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/opacityModifierRule.js
  var require_opacityModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierRuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque, semiOpaque} = _occamlexers.specialSymbols;
    var OpacityModifierRuleDefinition = class extends _definition.default {
      static fromNothing() {
        let content;
        content = opaque;
        const opaqueStringLiteralPart = _stringLiteral.default.fromContent(content);
        content = semiOpaque;
        const semiOpaqueStringLiteralPart = _stringLiteral.default.fromContent(content);
        const opaqueStringLiteralPartChoice = _partChoice.default.fromPart(opaqueStringLiteralPart), semiOpaqueStringLiteralPartChoice = _partChoice.default.fromPart(semiOpaqueStringLiteralPart), partChoices = [
          opaqueStringLiteralPartChoice,
          semiOpaqueStringLiteralPartChoice
        ], choiceOfOpaqueStringLiteralAndSemiOpaqueStringLiteralPartsPart = _choiceOfParts.default.fromPartChoices(partChoices), noWhitespacePart = _noWhitespace.default.fromNothing(), parts = [
          noWhitespacePart,
          choiceOfOpaqueStringLiteralAndSemiOpaqueStringLiteralPartsPart
        ], precedence = null, opacityModifierRuleDefinition = new OpacityModifierRuleDefinition(parts, precedence);
        return opacityModifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/opacityModifier.js
  var require_opacityModifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OpacityModifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _opacityModifierRule = /* @__PURE__ */ _interop_require_default(require_opacityModifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var OpacityModifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.OPACITY_MODIFIER_RULE_NAME, opacityModifierRuleDefinition = _opacityModifierRule.default.fromNothing(), opacity = null, definitions = [
          opacityModifierRuleDefinition
        ], opacityModifierRule = new OpacityModifierBNFRule(name, opacity, definitions);
        return opacityModifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/noWhitespacePart.js
  var require_noWhitespacePart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {noWhitespace} = _occamlexers.specialSymbols;
    var NoWhitespacePartDefinition = class extends _definition.default {
      static fromNothing() {
        const content = noWhitespace, stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, noWhitespacePartDefinition = new NoWhitespacePartDefinition(parts, precedence);
        return noWhitespacePartDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/noWhitespacePart.js
  var require_noWhitespacePart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NoWhitespacePartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NoWhitespacePartBNFRule = class extends _rule.default {
      static fromNothing() {
        const noWhitespacePartDefinition = _noWhitespacePart.default.fromNothing(), name = _ruleNames.NO_WHITESPACE_PART_RULE_NAME, opacity = null, definitions = [
          noWhitespacePartDefinition
        ], noWhitespacePartRule = new NoWhitespacePartBNFRule(name, opacity, definitions);
        return noWhitespacePartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/callAheadModifierRule.js
  var require_callAheadModifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierRuleDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {ellipsis} = _occamlexers.specialSymbols;
    var CallAheadModifierRuleDefinition = class extends _definition.default {
      static fromNothing() {
        const content = ellipsis, noWhitespacePart = _noWhitespace.default.fromNothing(), stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          noWhitespacePart,
          stringLiteralPart
        ], precedence = null, callAheadModifierRuleDefinition = new CallAheadModifierRuleDefinition(parts, precedence);
        return callAheadModifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/callAheadModifier.js
  var require_callAheadModifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CallAheadModifierBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _callAheadModifierRule = /* @__PURE__ */ _interop_require_default(require_callAheadModifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CallAheadModifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.CALL_AHEAD_MODIFIER_RULE_NAME, callAheadModifierRuleDefinition = _callAheadModifierRule.default.fromNothing(), opacity = null, definitions = [
          callAheadModifierRuleDefinition
        ], callAheadModifierRule = new CallAheadModifierBNFRule(name, opacity, definitions);
        return callAheadModifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/regularExpression.js
  var require_regularExpression4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RegularExpressionBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {regularExpressionType} = _occamlexers.types;
    var RegularExpressionBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = regularExpressionType, regularExpressionSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.REGULAR_EXPRESSION_RULE_NAME, opacity = null, definitions = [
          regularExpressionSignificantTokenTypeDefinition
        ], regularExpressionRule = new RegularExpressionBNFRule(name, opacity, definitions);
        return regularExpressionRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/quantifierRule.js
  var require_quantifierRule = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return QuantifierRuleDefinition;
      }
    });
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _noWhitespace = /* @__PURE__ */ _interop_require_default(require_noWhitespace2());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var QuantifierRuleDefinition = class extends _definition.default {
      static fromSpecialSymbol(specialSymbol) {
        const content = specialSymbol, noWhitespacePart = _noWhitespace.default.fromNothing(), stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          noWhitespacePart,
          stringLiteralPart
        ], precedence = null, quantifierRuleDefinition = new QuantifierRuleDefinition(parts, precedence);
        return quantifierRuleDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/optionalQuantifier.js
  var require_optionalQuantifier2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OptionalQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {questionMark} = _occamlexers.specialSymbols;
    var OptionalQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.OPTIONAL_QUANTIFIER_RULE_NAME, specialSymbol = questionMark, optionalQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          optionalQuantifierRuleDefinition
        ], optionalQuantifierRule = new OptionalQuantifierBNFRule(name, opacity, definitions);
        return optionalQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/definition/startOfContentPart.js
  var require_startOfContentPart2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartDefinition;
      }
    });
    var _occamlexers = require_lib3();
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {startOfContent} = _occamlexers.specialSymbols;
    var StartOfContentPartDefinition = class extends _definition.default {
      static fromNothing() {
        const content = startOfContent, stringLiteralPart = _stringLiteral.default.fromContent(content), parts = [
          stringLiteralPart
        ], precedence = null, startOfContentPartDefinition = new StartOfContentPartDefinition(parts, precedence);
        return startOfContentPartDefinition;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/startOfContentPart.js
  var require_startOfContentPart3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StartOfContentPartBNFRule;
      }
    });
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart2());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var StartOfContentPartBNFRule = class extends _rule.default {
      static fromNothing() {
        const startOfContentPartDefinition = _startOfContentPart.default.fromNothing(), name = _ruleNames.START_OF_CONTENT_PART_RULE_NAME, opacity = null, definitions = [
          startOfContentPartDefinition
        ], startOfContentPartRule = new StartOfContentPartBNFRule(name, opacity, definitions);
        return startOfContentPartRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/oneOrMoreQuantifier.js
  var require_oneOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return OneOrMoreQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {plus} = _occamlexers.specialSymbols;
    var OneOrMoreQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.ONE_OR_MORE_QUANTIFIER_RULE_NAME, specialSymbol = plus, oneOrMoreQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          oneOrMoreQuantifierRuleDefinition
        ], oneOrMoreQuantifierRule = new OneOrMoreQuantifierBNFRule(name, opacity, definitions);
        return oneOrMoreQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/zeroOrMoreQuantifier.js
  var require_zeroOrMoreQuantifier = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZeroOrMoreQuantifierBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _quantifierRule = /* @__PURE__ */ _interop_require_default(require_quantifierRule());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asterisk} = _occamlexers.specialSymbols;
    var ZeroOrMoreQuantifierBNFRule = class extends _rule.default {
      static fromNothing() {
        const name = _ruleNames.ZERO_OR_MORE_QUANTIFIER_RULE_NAME, specialSymbol = asterisk, zeroOrMoreQuantifierRuleDefinition = _quantifierRule.default.fromSpecialSymbol(specialSymbol), opacity = null, definitions = [
          zeroOrMoreQuantifierRuleDefinition
        ], zeroOrMoreQuantifierRule = new ZeroOrMoreQuantifierBNFRule(name, opacity, definitions);
        return zeroOrMoreQuantifierRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/rule/bnf/significantTokenType.js
  var require_significantTokenType4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SignificantTokenTypeBNFRule;
      }
    });
    var _occamlexers = require_lib3();
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType3());
    var _ruleNames = require_ruleNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {typeType} = _occamlexers.types;
    var SignificantTokenTypeBNFRule = class extends _rule.default {
      static fromNothing() {
        const significantTokenType = typeType, typeSignificantTokenTypeDefinition = _significantTokenType.default.fromSignificantTokenType(significantTokenType), name = _ruleNames.SIGNIFICANT_TOKEN_TYPE_RULE_NAME, opacity = null, definitions = [
          typeSignificantTokenTypeDefinition
        ], significantTokenTypeRule = new SignificantTokenTypeBNFRule(name, opacity, definitions);
        return significantTokenTypeRule;
      }
    };
  });

  // node_modules/occam-parsers/lib/utilities/rules.js
  var require_rules2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get ruleMapFromRules() {
        return ruleMapFromRules;
      },
      get rulesAsString() {
        return rulesAsString;
      },
      get rulesFromStartRuleAndRuleMap() {
        return rulesFromStartRuleAndRuleMap;
      },
      get startRuleFromRules() {
        return startRuleFromRules;
      },
      get startRuleFromRulesAndStartRuleName() {
        return startRuleFromRulesAndStartRuleName;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants4();
    var {first: first2, prune} = _necessary.arrayUtilities;
    function rulesAsString(rules, multiLine) {
      const maximumRuleNameLength = rules.reduce((maximumRuleNameLength2, rule) => {
        const ruleName = rule.getName(), opacity = rule.getOpacity();
        let ruleNameLength = ruleName.length;
        if (opacity !== null) {
          const opacityLength = opacity.length;
          ruleNameLength += opacityLength;
        }
        maximumRuleNameLength2 = Math.max(maximumRuleNameLength2, ruleNameLength);
        return maximumRuleNameLength2;
      }, 0), rulesString = rules.reduce((rulesString2, rule) => {
        const ruleString = rule.asString(maximumRuleNameLength, multiLine);
        rulesString2 += ruleString;
        return rulesString2;
      }, _constants.EMPTY_STRING).replace(/^\n\n/, _constants.EMPTY_STRING);
      return rulesString;
    }
    function ruleMapFromRules(rules) {
      const ruleMap = {};
      rules.forEach((rule) => {
        const ruleName = rule.getName();
        ruleMap[ruleName] = rule;
      });
      return ruleMap;
    }
    function startRuleFromRules(rules) {
      const firstRule = first2(rules), startRule = firstRule;
      return startRule;
    }
    function rulesFromStartRuleAndRuleMap(startRule, ruleMap) {
      const rules = Object.values(ruleMap), startRuleName = startRule.getName();
      startRule = prune(rules, (rule) => {
        const ruleName = rule.getName();
        if (ruleName !== startRuleName) {
          return true;
        }
      });
      rules.unshift(startRule);
      return rules;
    }
    function startRuleFromRulesAndStartRuleName(rules, startRuleName) {
      let startRule = rules.find((rule) => {
        const ruleName = rule.getName();
        if (ruleName === startRuleName) {
          return true;
        }
      }) || null;
      if (startRule === null) {
        startRule = startRuleFromRules(rules);
      }
      return startRule;
    }
    var _default = {
      rulesAsString,
      ruleMapFromRules,
      startRuleFromRules,
      rulesFromStartRuleAndRuleMap,
      startRuleFromRulesAndStartRuleName
    };
  });

  // node_modules/occam-parsers/lib/bnf/parser.js
  var require_parser2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFParser;
      }
    });
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser());
    var _name = /* @__PURE__ */ _interop_require_default(require_name4());
    var _part = /* @__PURE__ */ _interop_require_default(require_part2());
    var _rule1 = /* @__PURE__ */ _interop_require_default(require_rule5());
    var _error = /* @__PURE__ */ _interop_require_default(require_error3());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon4());
    var _document = /* @__PURE__ */ _interop_require_default(require_document4());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName4());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard3());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine8());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice4());
    var _quantifier = /* @__PURE__ */ _interop_require_default(require_quantifier2());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition4());
    var _precedence = /* @__PURE__ */ _interop_require_default(require_precedence3());
    var _definitions = /* @__PURE__ */ _interop_require_default(require_definitions3());
    var _terminalPart = /* @__PURE__ */ _interop_require_default(require_terminalPart2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts4());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral5());
    var _nonTerminalPart = /* @__PURE__ */ _interop_require_default(require_nonTerminalPart2());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts4());
    var _opacityModifier = /* @__PURE__ */ _interop_require_default(require_opacityModifier2());
    var _noWhitespacePart = /* @__PURE__ */ _interop_require_default(require_noWhitespacePart3());
    var _callAheadModifier = /* @__PURE__ */ _interop_require_default(require_callAheadModifier2());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression4());
    var _optionalQuantifier = /* @__PURE__ */ _interop_require_default(require_optionalQuantifier2());
    var _startOfContentPart = /* @__PURE__ */ _interop_require_default(require_startOfContentPart3());
    var _oneOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_oneOrMoreQuantifier());
    var _zeroOrMoreQuantifier = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreQuantifier());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType4());
    var _rules = require_rules2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BNFParser = class {
      constructor(startRule, ruleMap) {
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      getStartRule() {
        return this.startRule;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      rulesFromTokens(tokens) {
        let rules;
        const node = this.parse(tokens);
        if (node === null) {
          throw new Error(`There is no node.`);
        }
        rules = node.generateRules(_rule.default);
        const rulesLength = rules.length;
        if (rulesLength === 0) {
          throw new Error(`There are no rules.`);
        }
        return rules;
      }
      static fromNothing() {
        const nameBNFRule = _name.default.fromNothing(), partBNFRule = _part.default.fromNothing(), ruleBNFRule = _rule1.default.fromNothing(), errorBNFRule = _error.default.fromNothing(), epsilonBNFRule = _epsilon.default.fromNothing(), documentBNFRule = _document.default.fromNothing(), ruleNameBNFRule = _ruleName.default.fromNothing(), wildcardBNFRule = _wildcard.default.fromNothing(), endOfLineBNFRule = _endOfLine.default.fromNothing(), partChoiceBNFRule = _partChoice.default.fromNothing(), quantifierBNFRule = _quantifier.default.fromNothing(), definitionBNFRule = _definition.default.fromNothing(), precedentsBNFRule = _precedence.default.fromNothing(), definitionsBNFRule = _definitions.default.fromNothing(), terminalPartBNFRule = _terminalPart.default.fromNothing(), choiceOfPartsBNFRule = _choiceOfParts.default.fromNothing(), stringLiteralBNFRule = _stringLiteral.default.fromNothing(), nonTerminalPartBNFRule = _nonTerminalPart.default.fromNothing(), sequenceOfPartsBNFRule = _sequenceOfParts.default.fromNothing(), opacityModifierBNFRule = _opacityModifier.default.fromNothing(), noWhitespacePartBNFRule = _noWhitespacePart.default.fromNothing(), regularExpressionBNFRule = _regularExpression.default.fromNothing(), callAheadModifierBNFRule = _callAheadModifier.default.fromNothing(), optionalQuantifierBNFRule = _optionalQuantifier.default.fromNothing(), startOfContentPartBNFRule = _startOfContentPart.default.fromNothing(), oneOrMoreQuantifierBNFRule = _oneOrMoreQuantifier.default.fromNothing(), zeroOrMoreQuantifierBNFRule = _zeroOrMoreQuantifier.default.fromNothing(), significantTokenTypeBNFRule = _significantTokenType.default.fromNothing(), rules = [
          documentBNFRule,
          ruleBNFRule,
          nameBNFRule,
          definitionsBNFRule,
          definitionBNFRule,
          partBNFRule,
          nonTerminalPartBNFRule,
          terminalPartBNFRule,
          startOfContentPartBNFRule,
          noWhitespacePartBNFRule,
          sequenceOfPartsBNFRule,
          choiceOfPartsBNFRule,
          partChoiceBNFRule,
          ruleNameBNFRule,
          significantTokenTypeBNFRule,
          regularExpressionBNFRule,
          stringLiteralBNFRule,
          precedentsBNFRule,
          endOfLineBNFRule,
          wildcardBNFRule,
          epsilonBNFRule,
          quantifierBNFRule,
          opacityModifierBNFRule,
          callAheadModifierBNFRule,
          optionalQuantifierBNFRule,
          oneOrMoreQuantifierBNFRule,
          zeroOrMoreQuantifierBNFRule,
          errorBNFRule
        ], startRule = (0, _rules.startRuleFromRules)(rules), ruleMap = (0, _rules.ruleMapFromRules)(rules), bnfParser = new _BNFParser(startRule, ruleMap);
        return bnfParser;
      }
    };
    var BNFParser = _BNFParser;
    __publicField(BNFParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
    __publicField(BNFParser, "defaultNonTerminalNode", null);
    __publicField(BNFParser, "bnf", _bnf.default);
    Object.assign(BNFParser.prototype, _parser.default);
  });

  // node_modules/occam-parsers/lib/basic/bnf.js
  var require_bnf3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    expressions  ::=  expression+ ;

    expression   ::=  term... "." ;
    
    term         ::=  term_ term~* ;
    
    operator     ::=  "+"
    
                   |  "-"
    
                   |  "*"
    
                   ;
    
    number       ::=  /\\d+/ ;
    
    term_        ::=  "(" term ")"
    
                   |  number
    
                   ;
    
    term~term    ::=  operator term ;
    
    term~        ::=  term~term ;

`;
    var _default = bnf;
  });

  // node_modules/occam-parsers/lib/utilities/parser.js
  var require_parser3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get parserFromRules() {
        return parserFromRules;
      },
      get parserFromRulesAndStartRuleName() {
        return parserFromRulesAndStartRuleName;
      },
      get rulesFromBNF() {
        return rulesFromBNF;
      }
    });
    var _occamlexers = require_lib3();
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser2());
    var _rules = require_rules2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var bnfLexer = _occamlexers.BNFLexer.fromNothing();
    var bnfParser = _parser.default.fromNothing();
    function rulesFromBNF(bnf) {
      const tokens = bnfLexer.tokensFromBNF(bnf), rules = bnfParser.rulesFromTokens(tokens);
      return rules;
    }
    function parserFromRules(Class, rules) {
      const startRule = (0, _rules.startRuleFromRules)(rules), ruleMap = (0, _rules.ruleMapFromRules)(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
    function parserFromRulesAndStartRuleName(Class, rules, startRuleName) {
      const startRule = (0, _rules.startRuleFromRulesAndStartRuleName)(rules, startRuleName), ruleMap = (0, _rules.ruleMapFromRules)(rules), parser = new Class(startRule, ruleMap);
      return parser;
    }
    var _default = {
      rulesFromBNF,
      parserFromRules,
      parserFromRulesAndStartRuleName
    };
  });

  // node_modules/occam-parsers/lib/common/parser.js
  var require_parser4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CommonParser;
      }
    });
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    var _parser1 = require_parser3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CommonParser = class {
      constructor(startRule, ruleMap) {
        this.startRule = startRule;
        this.ruleMap = ruleMap;
      }
      getStartRule() {
        return this.startRule;
      }
      getRuleMap() {
        return this.ruleMap;
      }
      static fromNothing(Class) {
        const {bnf} = Class, rules = (0, _parser1.rulesFromBNF)(bnf), parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
      static fromBNF(Class, bnf) {
        const rules = (0, _parser1.rulesFromBNF)(bnf), parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
      static fromRules(Class, rules) {
        const parser = (0, _parser1.parserFromRules)(Class, rules);
        return parser;
      }
    };
    __publicField(CommonParser, "NonTerminalNodeMap", {});
    __publicField(CommonParser, "defaultNonTerminalNode", _nonTerminal.default);
    Object.assign(CommonParser.prototype, _parser.default);
  });

  // node_modules/occam-parsers/lib/basic/parser.js
  var require_parser5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BasicParser;
      }
    });
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf3());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BasicParser = class extends _parser.default {
      static fromNothing() {
        return _parser.default.fromNothing(_BasicParser);
      }
      static fromBNF(bnf) {
        return _parser.default.fromBNF(_BasicParser, bnf);
      }
      static fromRules(rules) {
        return _parser.default.fromRules(_BasicParser, rules);
      }
    };
    var BasicParser = _BasicParser;
    __publicField(BasicParser, "bnf", _bnf.default);
  });

  // node_modules/occam-parsers/lib/parts.js
  var require_parts = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon2());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName2());
    var _wildcard = /* @__PURE__ */ _interop_require_default(require_wildcard());
    var _endOfLine = /* @__PURE__ */ _interop_require_default(require_endOfLine6());
    var _optionalPart = /* @__PURE__ */ _interop_require_default(require_optionalPart());
    var _stringLiteral = /* @__PURE__ */ _interop_require_default(require_stringLiteral2());
    var _choiceOfParts = /* @__PURE__ */ _interop_require_default(require_choiceOfParts());
    var _oneOrMoreParts = /* @__PURE__ */ _interop_require_default(require_oneOrMoreParts());
    var _sequenceOfParts = /* @__PURE__ */ _interop_require_default(require_sequenceOfParts());
    var _zeroOrMoreParts = /* @__PURE__ */ _interop_require_default(require_zeroOrMoreParts());
    var _regularExpression = /* @__PURE__ */ _interop_require_default(require_regularExpression2());
    var _significantTokenType = /* @__PURE__ */ _interop_require_default(require_significantTokenType());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = {
      EpsilonPart: _epsilon.default,
      RuleNamePart: _ruleName.default,
      WildcardPart: _wildcard.default,
      EndOfLinePart: _endOfLine.default,
      OptionalPartPart: _optionalPart.default,
      ChoiceOfPartsPart: _choiceOfParts.default,
      StringLiteralPart: _stringLiteral.default,
      OneOrMorePartsPart: _oneOrMoreParts.default,
      SequenceOfPartsPart: _sequenceOfParts.default,
      ZeroOrMorePartsPart: _zeroOrMoreParts.default,
      RegularExpressionPart: _regularExpression.default,
      SignificantTokenTypePart: _significantTokenType.default
    };
  });

  // node_modules/occam-parsers/lib/index.js
  var require_lib4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BNFParser() {
        return _parser.default;
      },
      get BasicParser() {
        return _parser1.default;
      },
      get CommonParser() {
        return _parser2.default;
      },
      get Definition() {
        return _definition.default;
      },
      get EpsilonNode() {
        return _epsilon.default;
      },
      get NonTerminalNode() {
        return _nonTerminal.default;
      },
      get PartChoice() {
        return _partChoice.default;
      },
      get Parts() {
        return _parts.default;
      },
      get Rule() {
        return _rule.default;
      },
      get TerminalNode() {
        return _terminal.default;
      },
      get nodeMixins() {
        return _node.default;
      },
      get parserUtilities() {
        return _parser3.default;
      },
      get partTypes() {
        return _partTypes.default;
      },
      get rulesUtilities() {
        return _rules.default;
      }
    });
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser2());
    var _parser1 = /* @__PURE__ */ _interop_require_default(require_parser5());
    var _parser2 = /* @__PURE__ */ _interop_require_default(require_parser4());
    var _node = /* @__PURE__ */ _interop_require_default(require_node());
    var _rules = /* @__PURE__ */ _interop_require_default(require_rules2());
    var _parser3 = /* @__PURE__ */ _interop_require_default(require_parser3());
    var _rule = /* @__PURE__ */ _interop_require_default(require_rule2());
    var _parts = /* @__PURE__ */ _interop_require_default(require_parts());
    var _partTypes = /* @__PURE__ */ _interop_require_default(require_partTypes());
    var _partChoice = /* @__PURE__ */ _interop_require_default(require_partChoice());
    var _definition = /* @__PURE__ */ _interop_require_default(require_definition());
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon());
    var _terminal = /* @__PURE__ */ _interop_require_default(require_terminal2());
    var _nonTerminal = /* @__PURE__ */ _interop_require_default(require_nonTerminal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/css/bnf.js
  var require_bnf4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    stylesheet                 ::= ( media | ruleSet | keyframes | declaration | error )+ ;


    media                      ::= "@media" mediaQueries "{" ( ruleSet | declaration )* "}" ;
                                     
                                                              
    ruleSet                    ::=  selectors "{" declaration* "}" ;
    
    
    keyframes                  ::= "@keyframes" [identifier] "{" keyframe+ "}" ;
                                     
                                                              
    declaration                ::=  propertyName ":" propertyValues important? ";" ;


    error.                     ::=  . ;


    propertyValues             ::=  propertyValue ( "," propertyValue )* ;


    mediaQueries               ::=  mediaQuery ( ( "," | "or" ) mediaQuery )* ;
                                                              
                                                              
    selectors                  ::=  selector ( "," selector )* ;


    keyframe                   ::=  [percentage] "{" declaration+ "}" ;
    
    
    mediaQuery                 ::=  ( "not"? mediaType "and" )? mediaFeatures 
    
                                 |  "not"? mediaType
                                 
                                 ;


    mediaType                  ::=  "all" | "print" | "screen" | "speech" ;
                                                              
                                                              
    mediaFeatures              ::=  ( 
    
                                      mediaFeature 
                                      
                                      | 
                                      
                                      ( "(" "not" mediaFeature ")" ) 
                                      
                                    ) 
    
                                    ( 
                                    
                                      "and" 
                                    
                                      ( 
                                      
                                        mediaFeature 
                                        
                                        | 
                                        
                                        ( "(" "not" mediaFeature ")" ) 
                                        
                                      ) 
                                      
                                    )* 
                                    
                                 ;


    mediaFeature               ::=  "(" [identifier] ( ":" propertyValue )? ")" ;


    propertyValue              ::=  term ( ","? term )* ;


    propertyName               ::=  [identifier] ;


    important                  ::=  "!important" ;


    selector                   ::=  ( class | pseudoClass | pseudoElement | attribute )+ ;


    class                      ::=  "."<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    pseudoClass                ::=  ":"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    pseudoElement              ::=  "::"<NO_WHITESPACE>[identifier] parenthesisedSelector? ;


    parenthesisedSelector      ::=  <NO_WHITESPACE>"(" selector <NO_WHITESPACE>")" ;


    attribute                  ::=  "["

                                       [identifier]

                                       (

                                         ( "=" | "~=" | "|=" )

                                         ( [identifier] | [string-literal] )

                                       )?

                                    "]"

                                 ;


    term                       ::=  [plus-or-minus]?
                                                       
                                    (
                                                     
                                      ( [percentage] | [frequency] | [fraction] | [length] | [angle] | [rems] | [ems] | [time] | [number] )
                                                     
                                      |
                                                     
                                      uri
                                                     
                                      |
                                                     
                                      function
                                                     
                                      |
                                                     
                                      [string-literal]+
                                                     
                                      |
                                                     
                                      [identifier]
                                                     
                                      |
                                                     
                                      [colour]
                                                     
                                    )
                                                       
                                 ;


    uri                        ::=  "url"<NO_WHITESPACE>"(" [string-literal] ")" ;


    function                   ::=  [identifier]<NO_WHITESPACE>"(" propertyValue ")" ;

`;
    var _default = bnf;
  });

  // node_modules/with-style/lib/css/parser.js
  var require_parser6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CSSParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CSSParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CSSParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CSSParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CSSParser, rules);
      }
    };
    var CSSParser = _CSSParser;
    __publicField(CSSParser, "bnf", _bnf.default);
  });

  // node_modules/occam-query/lib/ruleNames.js
  var require_ruleNames2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get END_INDEX_RULE_NAME() {
        return END_INDEX_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get INDEX_RULE_NAME() {
        return INDEX_RULE_NAME;
      },
      get INFINITE_DESCENT_RULE_NAME() {
        return INFINITE_DESCENT_RULE_NAME;
      },
      get RULE_NAME_RULE_NAME() {
        return RULE_NAME_RULE_NAME;
      },
      get SPREAD_RULE_NAME() {
        return SPREAD_RULE_NAME;
      },
      get START_INDEX_RULE_NAME() {
        return START_INDEX_RULE_NAME;
      },
      get SUB_EXPRESSION_RULE_NAME() {
        return SUB_EXPRESSION_RULE_NAME;
      },
      get TOKEN_TYPE_RULE_NAME() {
        return TOKEN_TYPE_RULE_NAME;
      },
      get UNIQUE_RULE_NAME() {
        return UNIQUE_RULE_NAME;
      }
    });
    var ERROR_RULE_NAME = "error";
    var INDEX_RULE_NAME = "index";
    var UNIQUE_RULE_NAME = "unique";
    var SPREAD_RULE_NAME = "spread";
    var END_INDEX_RULE_NAME = "endIndex";
    var RULE_NAME_RULE_NAME = "ruleName";
    var TOKEN_TYPE_RULE_NAME = "tokenType";
    var START_INDEX_RULE_NAME = "startIndex";
    var SUB_EXPRESSION_RULE_NAME = "subExpression";
    var INFINITE_DESCENT_RULE_NAME = "infiniteDescent";
  });

  // node_modules/occam-query/lib/utilities/node.js
  var require_node3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get endIndexFromSpreadNode() {
        return endIndexFromSpreadNode;
      },
      get errorNodesFromExpressionNode() {
        return errorNodesFromExpressionNode;
      },
      get indexFromIndexNode() {
        return indexFromIndexNode;
      },
      get indexFromSpreadNode() {
        return indexFromSpreadNode;
      },
      get infiniteDescentFromPathNode() {
        return infiniteDescentFromPathNode;
      },
      get pathNodeFromExpressionNode() {
        return pathNodeFromExpressionNode;
      },
      get pathNodeFromSubExpressionNode() {
        return pathNodeFromSubExpressionNode;
      },
      get ruleNamesFromPathNode() {
        return ruleNamesFromPathNode;
      },
      get selectorNodesFromPathNode() {
        return selectorNodesFromPathNode;
      },
      get spreadNodeFromExpressionNode() {
        return spreadNodeFromExpressionNode;
      },
      get spreadNodeFromSubExpressionNode() {
        return spreadNodeFromSubExpressionNode;
      },
      get startIndexFromSpreadNode() {
        return startIndexFromSpreadNode;
      },
      get subExpressionNodeFromExpressionNode() {
        return subExpressionNodeFromExpressionNode;
      },
      get subExpressionNodeFromSubExpressionNode() {
        return subExpressionNodeFromSubExpressionNode;
      },
      get tokenTypesFromPathNode() {
        return tokenTypesFromPathNode;
      },
      get uniqueFromSpreadNode() {
        return uniqueFromSpreadNode;
      }
    });
    var _ruleNames = require_ruleNames2();
    function indexFromIndexNode(indexNode) {
      const nonTerminalNode = indexNode, index = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const terminalNode = firstChildNode, content = terminalNode.getContent(), index2 = Number(content);
        return index2;
      });
      return index;
    }
    function ruleNamesFromPathNode(pathNode) {
      const selectorNodes = selectorNodesFromPathNode(pathNode), ruleNameNodes = selectorNodes.reduce((ruleNameNodes2, selectorNode) => {
        const nonTerminalNode = selectorNode, ruleNameNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          let ruleNameNode2 = null;
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameRuleNameRuleName = ruleName === _ruleNames.RULE_NAME_RULE_NAME;
          if (ruleNameRuleNameRuleName) {
            ruleNameNode2 = nonTerminalNode2;
          }
          return ruleNameNode2;
        });
        if (ruleNameNode !== null) {
          ruleNameNodes2.push(ruleNameNode);
        }
        return ruleNameNodes2;
      }, []), ruleNames = ruleNameNodes.map((ruleNameNode) => {
        const nonTerminalNode = ruleNameNode, ruleName = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          const terminalNode = firstChildNode, content = terminalNode.getContent(), ruleName2 = content;
          return ruleName2;
        });
        return ruleName;
      });
      return ruleNames;
    }
    function tokenTypesFromPathNode(pathNode) {
      const selectorNodes = selectorNodesFromPathNode(pathNode), tokenTypeNodes = selectorNodes.reduce((tokenTypeNodes2, selectorNode) => {
        const nonTerminalNode = selectorNode, tokenTypeNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
          let tokenTypeNode2 = null;
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameTokenTypeRuleName = ruleName === _ruleNames.TOKEN_TYPE_RULE_NAME;
          if (ruleNameTokenTypeRuleName) {
            tokenTypeNode2 = nonTerminalNode2;
          }
          return tokenTypeNode2;
        });
        if (tokenTypeNode !== null) {
          tokenTypeNodes2.push(tokenTypeNode);
        }
        return tokenTypeNodes2;
      }, []), tokenTypes = tokenTypeNodes.map((tokenTypeNode) => {
        const nonTerminalNode = tokenTypeNode, tokenType = fromThirdChildNode(nonTerminalNode, (thirdChildNode) => {
          const terminalNode = thirdChildNode, content = terminalNode.getContent(), tokenType2 = content;
          return tokenType2;
        });
        return tokenType;
      });
      return tokenTypes;
    }
    function selectorNodesFromPathNode(pathNode) {
      let nonTerminalNode;
      nonTerminalNode = pathNode;
      const selectorsNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
        const selectorsNode2 = lastChildNode;
        return selectorsNode2;
      });
      nonTerminalNode = selectorsNode;
      const selectorNodes = nonTerminalNode.filterChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          return true;
        }
      });
      return selectorNodes;
    }
    function infiniteDescentFromPathNode(pathNode) {
      const nonTerminalNode = pathNode, infiniteDescent = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
        const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameInfiniteDescentRuleName = ruleName === _ruleNames.INFINITE_DESCENT_RULE_NAME, infiniteDescent2 = ruleNameInfiniteDescentRuleName;
        return infiniteDescent2;
      }) || false;
      return infiniteDescent;
    }
    function uniqueFromSpreadNode(spreadNode) {
      const nonTerminalNode = spreadNode, unique = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        let unique2 = false;
        const firstChildNodeNonTerminalNode = firstChildNode.isNonTerminalNode();
        if (firstChildNodeNonTerminalNode) {
          const nonTerminalNode2 = firstChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameUniqueRuleName = ruleName === _ruleNames.UNIQUE_RULE_NAME;
          if (ruleNameUniqueRuleName) {
            unique2 = true;
          }
        }
        return unique2;
      });
      return unique;
    }
    function indexFromSpreadNode(spreadNode) {
      let index = null;
      const nonTerminalNode = spreadNode, indexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameIndexRuleName = ruleName === _ruleNames.INDEX_RULE_NAME;
          if (ruleNameIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (indexNode !== null) {
        index = indexFromIndexNode(indexNode);
      }
      return index;
    }
    function endIndexFromSpreadNode(spreadNode) {
      let endIndex = Infinity;
      const nonTerminalNode = spreadNode, endIndexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameEndIndexRuleName = ruleName === _ruleNames.END_INDEX_RULE_NAME;
          if (ruleNameEndIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (endIndexNode !== null) {
        endIndex = indexFromIndexNode(endIndexNode);
      }
      return endIndex;
    }
    function startIndexFromSpreadNode(spreadNode) {
      let startIndex = 0;
      const nonTerminalNode = spreadNode, startIndexNode = nonTerminalNode.findChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameStartIndexRuleName = ruleName === _ruleNames.START_INDEX_RULE_NAME;
          if (ruleNameStartIndexRuleName) {
            return true;
          }
        }
      }) || null;
      if (startIndexNode !== null) {
        startIndex = indexFromIndexNode(startIndexNode);
      }
      return startIndex;
    }
    function pathNodeFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, pathNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const pathNode2 = firstChildNode;
        return pathNode2;
      });
      return pathNode;
    }
    function spreadNodeFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, spreadNode = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
        let spreadNode2 = null;
        const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSpreadRuleName = ruleName === _ruleNames.SPREAD_RULE_NAME;
        if (ruleNameSpreadRuleName) {
          spreadNode2 = secondChildNode;
        }
        return spreadNode2;
      }) || null;
      return spreadNode;
    }
    function errorNodesFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, errorNodes = nonTerminalNode.reduceChildNode((errorNodes2, childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const nonTerminalNode2 = childNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameErrorRuleName = ruleName === _ruleNames.ERROR_RULE_NAME;
          if (ruleNameErrorRuleName) {
            const errorNode = nonTerminalNode2;
            errorNodes2.push(errorNode);
          }
        }
        return errorNodes2;
      }, []);
      return errorNodes;
    }
    function subExpressionNodeFromExpressionNode(expressionNode) {
      let subExpressionNode = null;
      const nonTerminalNode = expressionNode, multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        subExpressionNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
          let subExpressionNode2 = null;
          const nonTerminalNode2 = lastChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSubExpressionRuleName = ruleName === _ruleNames.SUB_EXPRESSION_RULE_NAME;
          if (ruleNameSubExpressionRuleName) {
            subExpressionNode2 = lastChildNode;
          }
          return subExpressionNode2;
        });
      }
      return subExpressionNode;
    }
    function pathNodeFromSubExpressionNode(subExpressionNode) {
      const nonTerminalNode = subExpressionNode, pathNode = fromFirstChildNode(nonTerminalNode, (firstChildNode) => {
        const pathNode2 = firstChildNode;
        return pathNode2;
      });
      return pathNode;
    }
    function spreadNodeFromSubExpressionNode(subExpressionNode) {
      let spreadNode = null;
      const nonTerminalNode = subExpressionNode, multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        spreadNode = fromSecondChildNode(nonTerminalNode, (secondChildNode) => {
          let spreadNode2 = null;
          const nonTerminalNode2 = secondChildNode, ruleName = nonTerminalNode2.getRuleName(), ruleNameSpreadRuleName = ruleName === _ruleNames.SPREAD_RULE_NAME;
          if (ruleNameSpreadRuleName) {
            spreadNode2 = secondChildNode;
          }
          return spreadNode2;
        }) || null;
      }
      return spreadNode;
    }
    function subExpressionNodeFromSubExpressionNode(subExpressionNode) {
      const nonTerminalNode = subExpressionNode;
      subExpressionNode = null;
      const multiplicity = nonTerminalNode.getMultiplicity();
      if (multiplicity > 1) {
        subExpressionNode = fromLastChildNode(nonTerminalNode, (lastChildNode) => {
          let subExpressionNode2 = null;
          const nonTerminalNoe = lastChildNode, ruleName = nonTerminalNoe.getRuleName(), ruleNameSubExpressionRuleName = ruleName === _ruleNames.SUB_EXPRESSION_RULE_NAME;
          if (ruleNameSubExpressionRuleName) {
            subExpressionNode2 = lastChildNode;
          }
          return subExpressionNode2;
        });
      }
      return subExpressionNode;
    }
    function fromFirstChildNode(nonTerminalNode, callback) {
      let result;
      const firstIndex = 0;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === firstIndex) {
          const firstChildNode = childNode;
          result = callback(firstChildNode);
          return true;
        }
      });
      return result;
    }
    function fromSecondChildNode(nonTerminalNode, callback) {
      let result;
      const secondIndex = 1;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === secondIndex) {
          const firstChildNode = childNode;
          result = callback(firstChildNode);
          return true;
        }
      });
      return result;
    }
    function fromThirdChildNode(nonTerminalNode, callback) {
      let result;
      const thirdIndex = 2;
      nonTerminalNode.forwardsSomeChildNode((childNode, index) => {
        if (index === thirdIndex) {
          const thirdChildNode = childNode;
          result = callback(thirdChildNode);
          return true;
        }
      });
      return result;
    }
    function fromLastChildNode(nonTerminalNode, callback) {
      let result;
      const multiplicity = nonTerminalNode.getMultiplicity(), lastIndex = multiplicity - 1;
      nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
        if (index === lastIndex) {
          const thirdChildNode = childNode;
          result = callback(thirdChildNode);
          return true;
        }
      });
      return result;
    }
  });

  // node_modules/occam-query/lib/path.js
  var require_path2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Path;
      }
    });
    var _node = require_node3();
    var Path = class {
      constructor(ruleNames, tokenTypes, infiniteDescent) {
        this.ruleNames = ruleNames;
        this.tokenTypes = tokenTypes;
        this.infiniteDescent = infiniteDescent;
      }
      getRuleNames() {
        return this.ruleNames;
      }
      getTokenTypes() {
        return this.tokenTypes;
      }
      isInfiniteDescent() {
        return this.infiniteDescent;
      }
      static fromPathNode(pathNode) {
        const ruleNames = (0, _node.ruleNamesFromPathNode)(pathNode), tokenTypes = (0, _node.tokenTypesFromPathNode)(pathNode), infiniteDescent = (0, _node.infiniteDescentFromPathNode)(pathNode), path = new Path(ruleNames, tokenTypes, infiniteDescent);
        return path;
      }
    };
  });

  // node_modules/occam-query/lib/utilities/array.js
  var require_array3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get clear() {
        return clear;
      },
      get fifth() {
        return fifth;
      },
      get first() {
        return first2;
      },
      get fourth() {
        return fourth;
      },
      get includes() {
        return includes;
      },
      get last() {
        return last;
      },
      get push() {
        return push;
      },
      get second() {
        return second;
      },
      get third() {
        return third;
      },
      get trim() {
        return trim;
      }
    });
    var _necessary = require_browser();
    var {clear, push, first: first2, second, third, fourth, fifth, last} = _necessary.arrayUtilities;
    function trim(array, startIndex, endIndex) {
      if (startIndex < 0) {
        const length = array.length;
        startIndex = length + startIndex;
        endIndex = length + endIndex;
      }
      if (endIndex !== Infinity) {
        const start2 = endIndex + 1;
        array.splice(start2);
      }
      const start = 0, deleteCount = startIndex;
      array.splice(start, deleteCount);
    }
    function includes(array, ...elements) {
      return elements.some((element) => array.includes(element));
    }
  });

  // node_modules/occam-query/lib/spread.js
  var require_spread = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Spread;
      }
    });
    var _necessary = require_browser();
    var _array = require_array3();
    var _node = require_node3();
    var {EXCLAMATION_MARK_CHARACTER} = _necessary.characters;
    var Spread = class {
      constructor(startIndex, endIndex, unique) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.unique = unique;
      }
      adjustNodes(nodes) {
        if (this.unique) {
          const nodesLength = nodes.length;
          if (nodesLength > 1) {
            (0, _array.clear)(nodes);
          }
        } else {
          (0, _array.trim)(nodes, this.startIndex, this.endIndex);
        }
      }
      static fromNothing() {
        const startIndex = 0, endIndex = Infinity, unique = false, spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
      static fromSpreadNode(spreadNode) {
        let startIndex = 0, endIndex = Infinity, unique = false;
        if (spreadNode !== null) {
          const index = (0, _node.indexFromSpreadNode)(spreadNode);
          if (index !== null) {
            startIndex = index;
            endIndex = index;
          } else {
            startIndex = (0, _node.startIndexFromSpreadNode)(spreadNode);
            endIndex = (0, _node.endIndexFromSpreadNode)(spreadNode);
          }
          unique = (0, _node.uniqueFromSpreadNode)(spreadNode);
        }
        const spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
      static fromSpreadExpression(spreadExpression) {
        let startIndex = 0, endIndex = Infinity, unique = false;
        if (spreadExpression !== null) {
          if (spreadExpression === EXCLAMATION_MARK_CHARACTER) {
            unique = true;
          } else {
            const regExp = /\[(-?\d+)?(\.\.\.)?(-?\d+)?]/, matches = spreadExpression.match(regExp), secondMatch = (0, _array.second)(matches) || null, thirdMatch = (0, _array.third)(matches) || null, fourthMatch = (0, _array.fourth)(matches) || null;
            if (secondMatch !== null) {
              startIndex = parseInt(secondMatch);
              if (thirdMatch === null) {
                endIndex = startIndex;
              }
            }
            if (fourthMatch !== null) {
              endIndex = parseInt(fourthMatch);
              if (thirdMatch === null) {
                startIndex = endIndex;
              }
            }
          }
        }
        const spread = new Spread(startIndex, endIndex, unique);
        return spread;
      }
    };
  });

  // node_modules/occam-query/lib/subExpression.js
  var require_subExpression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SubExpression;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path2());
    var _spread = /* @__PURE__ */ _interop_require_default(require_spread());
    var _node = require_node3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SubExpression = class {
      constructor(path, spread, subExpression) {
        this.path = path;
        this.spread = spread;
        this.subExpression = subExpression;
      }
      getPath() {
        return this.path;
      }
      getSpread() {
        return this.spread;
      }
      getSubExpression() {
        return this.subExpression;
      }
      getRuleNames() {
        return this.path.getRuleNames();
      }
      getTokenTypes() {
        return this.path.getTokenTypes();
      }
      isInfiniteDescent() {
        return this.path.isInfiniteDescent();
      }
      static fromSubExpressionNode(subExpressionNode) {
        let subExpression = null;
        if (subExpressionNode !== null) {
          const pathNode = (0, _node.pathNodeFromSubExpressionNode)(subExpressionNode), spreadNode = (0, _node.spreadNodeFromSubExpressionNode)(subExpressionNode);
          subExpressionNode = (0, _node.subExpressionNodeFromSubExpressionNode)(subExpressionNode);
          const path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode);
          subExpression = SubExpression.fromSubExpressionNode(subExpressionNode);
          subExpression = new SubExpression(path, spread, subExpression);
        }
        return subExpression;
      }
    };
  });

  // node_modules/occam-query/lib/expression/entries.js
  var require_entries4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:@|!|\\*|\\||\\/|\\[|\\]|\\.\\.\\.)"
      },
      {
        name: "^[a-zA-Z\\-]+"
      },
      {
        number: "^[0-9]+"
      },
      {
        unassigned: "^."
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-query/lib/expression/lexer.js
  var require_lexer6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries4());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _ExpressionLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_ExpressionLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_ExpressionLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_ExpressionLexer, entries);
      }
    };
    var ExpressionLexer = _ExpressionLexer;
    __publicField(ExpressionLexer, "entries", _entries.default);
    __publicField(ExpressionLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(ExpressionLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(ExpressionLexer, "EndOfLineCommentToken", null);
    __publicField(ExpressionLexer, "SingleLineCommentToken", null);
    __publicField(ExpressionLexer, "RegularExpressionToken", null);
    __publicField(ExpressionLexer, "EndOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "StartOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(ExpressionLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(ExpressionLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-query/lib/expression/bnf.js
  var require_bnf5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    expression       ::=  path spread? subExpression?   
    
                       |  error+ 
                                 
                       ;
  
    path             ::=  "/" infiniteDescent? selectors ;
    
    subExpression    ::=  path spread? subExpression?;

    infiniteDescent  ::=  "/" ;
    
    selectors        ::=  selector ( "|" selector )* ;

    spread           ::=  unique
    
                       |  "[" 

                          ( 
                            
                            ( startIndex "..." endIndex ) 
                            
                            | 
                            
                            ( startIndex "..." ) 
                            
                            | 
                            
                            ( "..." endIndex )
                             
                            | 
                            
                            index 
                            
                          )  
                          
                          "]" ;

    selector         ::=  ruleName | tokenType ;
                       
    ruleName         ::=  [name] | "*" ;
                       
    tokenType        ::=  "@"<NO_WHITESPACE>( [name] | "*" ) ;
                       
    startIndex       ::=  [number] ;
                       
    endIndex         ::=  [number] ;
                       
    index            ::=  [number] ;
                       
    unique           ::=  "!" ;
                       


    error.           ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-query/lib/expression/parser.js
  var require_parser7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _ExpressionParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_ExpressionParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_ExpressionParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_ExpressionParser, rules);
      }
    };
    var ExpressionParser = _ExpressionParser;
    __publicField(ExpressionParser, "bnf", _bnf.default);
  });

  // node_modules/occam-query/lib/expression.js
  var require_expression = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Expression;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path2());
    var _spread = /* @__PURE__ */ _interop_require_default(require_spread());
    var _subExpression = /* @__PURE__ */ _interop_require_default(require_subExpression());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer6());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser7());
    var _node = require_node3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var expressionLexer = _lexer.default.fromNothing();
    var expressionParser = _parser.default.fromNothing();
    var Expression = class {
      constructor(path, spread, subExpression) {
        this.path = path;
        this.spread = spread;
        this.subExpression = subExpression;
      }
      getPath() {
        return this.path;
      }
      getSpread() {
        return this.spread;
      }
      getSubExpression() {
        return this.subExpression;
      }
      getRuleNames() {
        return this.path.getRuleNames();
      }
      getTokenTypes() {
        return this.path.getTokenTypes();
      }
      isInfiniteDescent() {
        return this.path.isInfiniteDescent();
      }
      static fromExpressionNode(expressionNode) {
        const pathNode = (0, _node.pathNodeFromExpressionNode)(expressionNode), spreadNode = (0, _node.spreadNodeFromExpressionNode)(expressionNode), subExpressionNode = (0, _node.subExpressionNodeFromExpressionNode)(expressionNode), path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode), subExpression = _subExpression.default.fromSubExpressionNode(subExpressionNode), expression = new Expression(path, spread, subExpression);
        return expression;
      }
      static fromExpressionString(expressionString) {
        let expression = null;
        const lexer = expressionLexer, parser = expressionParser, content = expressionString, tokens = lexer.tokenise(content), node = parser.parse(tokens);
        if (node !== null) {
          const expressionNode = node, errorNodes = (0, _node.errorNodesFromExpressionNode)(expressionNode), errorNodesLength = errorNodes.length;
          if (errorNodesLength === 0) {
            const pathNode = (0, _node.pathNodeFromExpressionNode)(expressionNode), spreadNode = (0, _node.spreadNodeFromExpressionNode)(expressionNode), subExpressionNode = (0, _node.subExpressionNodeFromExpressionNode)(expressionNode), path = _path.default.fromPathNode(pathNode), spread = _spread.default.fromSpreadNode(spreadNode), subExpression = _subExpression.default.fromSubExpressionNode(subExpressionNode);
            expression = new Expression(path, spread, subExpression);
          }
        }
        return expression;
      }
    };
  });

  // node_modules/occam-query/lib/query.js
  var require_query = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Query;
      }
    });
    var _necessary = require_browser();
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    var _array = require_array3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {WILDCARD_CHARACTER} = _necessary.characters;
    var Query = class {
      constructor(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes) {
        this.spread = spread;
        this.subQuery = subQuery;
        this.ruleNames = ruleNames;
        this.tokenTypes = tokenTypes;
        this.maximumDepth = maximumDepth;
        this.infiniteDescent = infiniteDescent;
        this.intermediateNodes = intermediateNodes;
      }
      getSpread() {
        return this.sprea;
      }
      getSubQuery() {
        return this.subQuery;
      }
      getRuleNames() {
        return this.ruleNames;
      }
      getTokenTypes() {
        return this.tokenTypes;
      }
      getMaximumDepth() {
        return this.maximumDepth;
      }
      isInfiniteDescent() {
        return this.infiniteDescent;
      }
      getIntermediateNodes() {
        return this.intermediateNodes;
      }
      execute(node, depth = 0, maximumDepth = this.maximumDepth) {
        const nodes = [];
        this.clear();
        this.find(node, depth, maximumDepth);
        this.apply(nodes, depth, maximumDepth);
        return nodes;
      }
      clear() {
        (0, _array.clear)(this.intermediateNodes);
      }
      find(node, depth, maximumDepth) {
        if (depth > maximumDepth) {
          return;
        }
        const nodeTerminalNode = node.isTerminalNode(), nodeNonTerminalNode = !nodeTerminalNode;
        let found;
        if (nodeTerminalNode) {
          const terminalNode = node, types = this.tokenTypes, type = terminalNode.getType();
          found = (0, _array.includes)(types, type, WILDCARD_CHARACTER);
        }
        if (nodeNonTerminalNode) {
          const nonTerminalNode = node, ruleName = nonTerminalNode.getRuleName();
          found = (0, _array.includes)(this.ruleNames, ruleName, WILDCARD_CHARACTER);
        }
        if (found) {
          const intermediateNode = node;
          this.intermediateNodes.push(intermediateNode);
        }
        if (this.infiniteDescent) {
          if (nodeNonTerminalNode) {
            depth++;
            const nonTerminalNode = node;
            nonTerminalNode.forEachChildNode((childNode) => {
              this.find(childNode, depth, maximumDepth);
            });
          }
        }
      }
      apply(nodes, depth, maximumDepth) {
        this.spread.adjustNodes(this.intermediateNodes);
        if (this.subQuery === null) {
          (0, _array.push)(nodes, this.intermediateNodes);
        } else {
          this.intermediateNodes.forEach((intermediateNode) => {
            const intermediateNodeNonTerminalNode = intermediateNode.isNonTerminalNode();
            if (intermediateNodeNonTerminalNode) {
              depth++;
              const nonTerminalNode = intermediateNode;
              this.subQuery.clear();
              nonTerminalNode.forEachChildNode((childNode) => {
                this.subQuery.find(childNode, depth, maximumDepth);
              });
              this.subQuery.apply(nodes, depth, maximumDepth);
            }
          });
        }
      }
      static fromExpression(expression, maximumDepth = Infinity) {
        const spread = expression.getSpread(), subQuery = subQueryFromExpression(expression), ruleNames = expression.getRuleNames(), tokenTypes = expression.getTokenTypes(), infiniteDescent = expression.isInfiniteDescent(), intermediateNodes = [], query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        return query;
      }
      static fromSubExpression(subExpression) {
        const spread = subExpression.getSpread(), subQuery = subQueryFromSubExpression(subExpression), ruleNames = subExpression.getRuleNames(), tokenTypes = subExpression.getTokenTypes(), maximumDepth = Infinity, infiniteDescent = subExpression.isInfiniteDescent(), intermediateNodes = [], query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        return query;
      }
      static fromExpressionString(expressionString, maximumDepth = Infinity) {
        let query = null;
        const expression = _expression.default.fromExpressionString(expressionString);
        if (expression !== null) {
          const spread = expression.getSpread(), subQuery = subQueryFromExpression(expression), ruleNames = expression.getRuleNames(), tokenTypes = expression.getTokenTypes(), infiniteDescent = expression.isInfiniteDescent(), intermediateNodes = [];
          query = new Query(spread, subQuery, ruleNames, tokenTypes, maximumDepth, infiniteDescent, intermediateNodes);
        }
        return query;
      }
    };
    function subQueryFromExpression(expression) {
      let subQuery = null;
      const subExpression = expression.getSubExpression();
      if (subExpression !== null) {
        const query = Query.fromSubExpression(subExpression);
        subQuery = query;
      }
      return subQuery;
    }
    function subQueryFromSubExpression(subExpression) {
      let subQuery = null;
      subExpression = subExpression.getSubExpression();
      if (subExpression !== null) {
        const query = Query.fromSubExpression(subExpression);
        subQuery = query;
      }
      return subQuery;
    }
  });

  // node_modules/occam-query/lib/utilities/query.js
  var require_query2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get queryByExpressionString() {
        return queryByExpressionString;
      }
    });
    var _query = /* @__PURE__ */ _interop_require_default(require_query());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function queryByExpressionString(node, expressionString, maximumDepth) {
      let nodes = null;
      const expression = _expression.default.fromExpressionString(expressionString);
      if (expression !== null) {
        const query = _query.default.fromExpression(expression, maximumDepth);
        nodes = query.execute(node);
      }
      return nodes;
    }
    var _default = {
      queryByExpressionString
    };
  });

  // node_modules/occam-query/lib/index.js
  var require_lib5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Expression() {
        return _expression.default;
      },
      get ExpressionLexer() {
        return _lexer.default;
      },
      get ExpressionParser() {
        return _parser.default;
      },
      get Query() {
        return _query.default;
      },
      get queryUtilities() {
        return _query1.default;
      }
    });
    var _query = /* @__PURE__ */ _interop_require_default(require_query());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression());
    var _query1 = /* @__PURE__ */ _interop_require_default(require_query2());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer6());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/with-style/lib/constants.js
  var require_constants5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CHARACTERS() {
        return CHARACTERS;
      },
      get CLASS_NAME_LENGTH() {
        return CLASS_NAME_LENGTH;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get HEAD() {
        return HEAD;
      },
      get STYLE() {
        return STYLE;
      },
      get TWO_SPACES() {
        return TWO_SPACES;
      }
    });
    var HEAD = "head";
    var STYLE = "style";
    var CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var TWO_SPACES = "  ";
    var EMPTY_STRING = "";
    var CLASS_NAME_LENGTH = 6;
  });

  // node_modules/with-style/lib/utilities/content.js
  var require_content2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "contentFromQueryNodeAndTokens", {
      enumerable: true,
      get: function() {
        return contentFromQueryNodeAndTokens;
      }
    });
    var _necessary = require_browser();
    var _constants = require_constants5();
    var {first: first2} = _necessary.arrayUtilities;
    function contentFromQueryNodeAndTokens(query, node, tokens) {
      let content = null;
      const nodes = query.execute(node), nodesLength = nodes.length;
      if (nodesLength > 0) {
        const firstNode = first2(nodes);
        node = firstNode;
        content = contentFromNodeAndTokens(node, tokens);
      }
      return content;
    }
    function contentFromNodeAndTokens(node, tokens) {
      const firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens), lastSignificantTokenIndex = node.getLastSignificantTokenIndex(tokens);
      let content = _constants.EMPTY_STRING;
      for (let index = firstSignificantTokenIndex; index <= lastSignificantTokenIndex; index++) {
        const token = tokens[index], tokenContent = token.getContent();
        content += tokenContent;
      }
      return content;
    }
  });

  // node_modules/with-style/lib/style/declaration.js
  var require_declaration = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Declaration;
      }
    });
    var _occamquery = require_lib5();
    var _constants = require_constants5();
    var _content = require_content2();
    var importantQuery = _occamquery.Query.fromExpressionString("/*/important");
    var propertyNameQuery = _occamquery.Query.fromExpressionString("/*/propertyName");
    var propertyValuesQuery = _occamquery.Query.fromExpressionString("/*/propertyValues");
    var Declaration = class {
      constructor(propertyValues, propertyName, important) {
        this.propertyValues = propertyValues;
        this.propertyName = propertyName;
        this.important = important;
      }
      getPropertyValues() {
        return this.propertyValues;
      }
      getPropertyName() {
        return this.propertyName;
      }
      getImportant() {
        return this.important;
      }
      matchPropertyName(propertyName) {
        const matches = this.propertyName === propertyName;
        return matches;
      }
      matchDeclaration(declaration) {
        const propertyName = declaration.getPropertyName(), matches = this.matchPropertyName(propertyName);
        return matches;
      }
      matchDeclarations(declarations) {
        const matches = declarations.someDeclaration((declaration) => {
          const matches2 = this.matchDeclaration(declaration);
          if (matches2) {
            return true;
          }
        });
        return matches;
      }
      asCSS(indent) {
        indent = indent + _constants.TWO_SPACES;
        const css = `${indent}${this.propertyName}: ${this.propertyValues}${this.important};
`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const propertyValuesContent = (0, _content.contentFromQueryNodeAndTokens)(propertyValuesQuery, node, tokens), propertyNameContent = (0, _content.contentFromQueryNodeAndTokens)(propertyNameQuery, node, tokens), importantContent = (0, _content.contentFromQueryNodeAndTokens)(importantQuery, node, tokens), propertyValues = propertyValuesContent, propertyName = propertyNameContent, important = importantContent === null ? _constants.EMPTY_STRING : ` ${importantContent}`, declaration = new Declaration(propertyValues, propertyName, important);
        return declaration;
      }
    };
  });

  // node_modules/with-style/lib/style/declarations.js
  var require_declarations = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Declarations;
      }
    });
    var _occamquery = require_lib5();
    var _necessary = require_browser();
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forwardsForEach, backwardsForEach} = _necessary.arrayUtilities;
    var declarationQuery = _occamquery.Query.fromExpressionString("/*/declaration");
    var Declarations = class {
      constructor(array) {
        this.array = array;
      }
      someDeclaration(callback) {
        return this.array.some(callback);
      }
      forwardsForEachDeclaration(callback) {
        forwardsForEach(this.array, callback);
      }
      backwardsForEachDeclaration(callback) {
        backwardsForEach(this.array, callback);
      }
      unshift(declarations) {
        declarations.backwardsForEachDeclaration((declaration) => {
          const matches = declaration.matchDeclarations(this);
          if (!matches) {
            this.array.unshift(declaration);
          }
        });
      }
      asCSS(className, indent) {
        const declarationsCSS = this.array.reduce((declarationsCSS2, declaration) => {
          const declarationCSS = declaration.asCSS(indent);
          declarationsCSS2 += declarationCSS;
          return declarationsCSS2;
        }, _constants.EMPTY_STRING), css = className === null ? declarationsCSS : `${indent}.${className} {
${declarationsCSS}${indent}}

`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarationNodes = declarationQuery.execute(node), array = declarationNodes.map((declarationNode) => {
          const node2 = declarationNode, declaration = _declaration.default.fromNodeAndTokens(node2, tokens);
          return declaration;
        }), declarations = new Declarations(array);
        return declarations;
      }
    };
  });

  // node_modules/with-style/lib/style/ruleSet.js
  var require_ruleSet = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleSet;
      }
    });
    var _occamquery = require_lib5();
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var selectorsQuery = _occamquery.Query.fromExpressionString("//selectors");
    var RuleSet = class {
      constructor(selectors, declarations) {
        this.selectors = selectors;
        this.declarations = declarations;
      }
      getSelectors() {
        return this.selectors;
      }
      getDeclarations() {
        return this.declarations;
      }
      unshift(ruleSet) {
        const declarations = ruleSet.getDeclarations();
        this.declarations.unshift(declarations);
      }
      findMatchingRuleSet(ruleSets) {
        const matchingRuleSet = ruleSets.find((ruleSet) => {
          const selectors = ruleSet.getSelectors(), selectorsMatch = selectors === this.selectors, ruleSetsMatch = selectorsMatch;
          if (ruleSetsMatch) {
            return true;
          }
        }) || null;
        return matchingRuleSet;
      }
      asCSS(className, indent) {
        let css = _constants.EMPTY_STRING;
        const declarationsCSS = this.declarations.asCSS(null, indent);
        if (declarationsCSS !== _constants.EMPTY_STRING) {
          css = `${indent}.${className}${this.selectors} {
${declarationsCSS}${indent}}

`;
        }
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const selectors = selectorsFromNodeAndTokens(node, tokens), declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSet = new RuleSet(selectors, declarations);
        return ruleSet;
      }
    };
    function selectorsFromNodeAndTokens(node, tokens) {
      const selectorsNodeContent = (0, _content.contentFromQueryNodeAndTokens)(selectorsQuery, node, tokens), selectors = `${selectorsNodeContent}`;
      return selectors;
    }
  });

  // node_modules/with-style/lib/style/ruleSets.js
  var require_ruleSets = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RuleSets;
      }
    });
    var _occamquery = require_lib5();
    var _ruleSet = /* @__PURE__ */ _interop_require_default(require_ruleSet());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ruleSetQuery = _occamquery.Query.fromExpressionString("/*/ruleSet");
    var RuleSets = class {
      constructor(array) {
        this.array = array;
      }
      unshift(ruleSets) {
        ruleSets.forEach((ruleSet) => {
          const matchingRuleSet = ruleSet.findMatchingRuleSet(this.array);
          matchingRuleSet === null ? this.array.unshift(ruleSet) : matchingRuleSet.unshift(ruleSet);
        });
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, ruleSet) => {
          const ruleSetCSS = ruleSet.asCSS(className, indent);
          css2 += ruleSetCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const ruleSetNodes = ruleSetQuery.execute(node), array = ruleSetNodes.map((ruleSetNode) => {
          const node2 = ruleSetNode, ruleSet = _ruleSet.default.fromNodeAndTokens(node2, tokens);
          return ruleSet;
        }), ruleSets = new RuleSets(array);
        return ruleSets;
      }
    };
  });

  // node_modules/with-style/lib/utilities/string.js
  var require_string4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "trim", {
      enumerable: true,
      get: function() {
        return trim;
      }
    });
    var _constants = require_constants5();
    function trim(string) {
      string = string.replace(/[\n\r]$/g, _constants.EMPTY_STRING);
      return string;
    }
  });

  // node_modules/with-style/lib/style/media.js
  var require_media = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Media;
      }
    });
    var _occamquery = require_lib5();
    var _ruleSets = /* @__PURE__ */ _interop_require_default(require_ruleSets());
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _string = require_string4();
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var queriesQuery = _occamquery.Query.fromExpressionString("/media/mediaQueries");
    var Media = class {
      constructor(declarations, ruleSets, queries) {
        this.declarations = declarations;
        this.ruleSets = ruleSets;
        this.queries = queries;
      }
      getDeclarations() {
        return this.declarations;
      }
      getRuleSets() {
        return this.ruleSets;
      }
      getQueries() {
        return this.queries;
      }
      asCSS(className, indent) {
        indent = indent + _constants.TWO_SPACES;
        let css = _constants.EMPTY_STRING;
        const ruleSetsCSS = this.ruleSets.asCSS(className, indent), declarationsCSS = this.declarations.asCSS(className, indent);
        let ruleSetsDeclarationsCSS = `${declarationsCSS}${ruleSetsCSS}`;
        if (ruleSetsDeclarationsCSS !== _constants.EMPTY_STRING) {
          ruleSetsDeclarationsCSS = (0, _string.trim)(ruleSetsDeclarationsCSS);
          css = `@media ${this.queries} {
${ruleSetsDeclarationsCSS}}

`;
        }
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarations = _declarations.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), queries = queriesFromNodeAndTokens(node, tokens), media = new Media(declarations, ruleSets, queries);
        return media;
      }
    };
    function queriesFromNodeAndTokens(node, tokens) {
      const queriesNodeContent = (0, _content.contentFromQueryNodeAndTokens)(queriesQuery, node, tokens), queries = `${queriesNodeContent}`;
      return queries;
    }
  });

  // node_modules/with-style/lib/style/medias.js
  var require_medias = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Medias;
      }
    });
    var _occamquery = require_lib5();
    var _media = /* @__PURE__ */ _interop_require_default(require_media());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var mediaQuery = _occamquery.Query.fromExpressionString("/stylesheet/media");
    var Medias = class {
      constructor(array) {
        this.array = array;
      }
      unshift(medias) {
        medias.forEach((media) => {
          this.array.unshift(media);
        });
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, media) => {
          const mediaCSS = media.asCSS(className, indent);
          css2 += mediaCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const mediaNodes = mediaQuery.execute(node), array = mediaNodes.map((mediaNode) => {
          const node2 = mediaNode, media = _media.default.fromNodeAndTokens(node2, tokens);
          return media;
        }), medias = new Medias(array);
        return medias;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframe.js
  var require_keyframe = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframe;
      }
    });
    var _occamquery = require_lib5();
    var _necessary = require_browser();
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration());
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var percentageQuery = _occamquery.Query.fromExpressionString("/*/@percentage");
    var declarationQuery = _occamquery.Query.fromExpressionString("/*/declaration");
    var {first: first2} = _necessary.arrayUtilities;
    var Keyframe = class {
      constructor(percentage, declaration) {
        this.percentage = percentage;
        this.declaration = declaration;
      }
      getPercentage() {
        return this.percentage;
      }
      getDeclaration() {
        return this.declaration;
      }
      asCSS(indent) {
        const declarationCSS = this.declaration.asCSS(indent), css = `${indent}${this.percentage} { 
${declarationCSS}${indent}}
`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const percentageContent = (0, _content.contentFromQueryNodeAndTokens)(percentageQuery, node, tokens), percentage = percentageContent, declarationNodes = declarationQuery.execute(node), firstDeclarationNode = first2(declarationNodes), declarationNode = firstDeclarationNode;
        node = declarationNode;
        const declaration = _declaration.default.fromNodeAndTokens(node, tokens), keyframe = new Keyframe(percentage, declaration);
        return keyframe;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframes.js
  var require_keyframes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframes;
      }
    });
    var _occamquery = require_lib5();
    var _keyframe = /* @__PURE__ */ _interop_require_default(require_keyframe());
    var _constants = require_constants5();
    var _content = require_content2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var keyframeQuery = _occamquery.Query.fromExpressionString("/keyframes/keyframe");
    var identifierQuery = _occamquery.Query.fromExpressionString("/keyframes/@identifier");
    var Keyframes = class {
      constructor(array, identifier) {
        this.array = array;
        this.identifier = identifier;
      }
      getIdentifier() {
        return this.identifier;
      }
      asCSS(indent) {
        indent = indent + _constants.TWO_SPACES;
        const keyframesCSS = this.array.reduce((keyframesCSS2, keyframe) => {
          const keyframeCSS = keyframe.asCSS(indent);
          keyframesCSS2 += keyframeCSS;
          return keyframesCSS2;
        }, _constants.EMPTY_STRING), css = `@keyframes ${this.identifier} {
${keyframesCSS}}

`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const keyframeNodes = keyframeQuery.execute(node), array = keyframeNodes.map((keyframeNode) => {
          const node2 = keyframeNode, keyframe = _keyframe.default.fromNodeAndTokens(node2, tokens);
          return keyframe;
        }), identifierContent = (0, _content.contentFromQueryNodeAndTokens)(identifierQuery, node, tokens), identifier = identifierContent, keyframes = new Keyframes(array, identifier);
        return keyframes;
      }
    };
  });

  // node_modules/with-style/lib/style/keyframess.js
  var require_keyframess = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Keyframess;
      }
    });
    var _occamquery = require_lib5();
    var _keyframes = /* @__PURE__ */ _interop_require_default(require_keyframes());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var keyframesQuery = _occamquery.Query.fromExpressionString("/stylesheet/keyframes");
    var Keyframess = class {
      constructor(array) {
        this.array = array;
      }
      unshift(keyframess) {
      }
      forEach(callback) {
        this.array.forEach(callback);
      }
      asCSS(className, indent) {
        const css = this.array.reduce((css2, keyframes) => {
          const keyframesCSS = keyframes.asCSS(indent);
          css2 += keyframesCSS;
          return css2;
        }, _constants.EMPTY_STRING);
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const keyframesNodes = keyframesQuery.execute(node), array = keyframesNodes.map((keyframesNode) => {
          const node2 = keyframesNode, keyframes = _keyframes.default.fromNodeAndTokens(node2, tokens);
          return keyframes;
        }), keyframess = new Keyframess(array);
        return keyframess;
      }
    };
  });

  // node_modules/with-style/lib/style.js
  var require_style = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Style;
      }
    });
    var _medias = /* @__PURE__ */ _interop_require_default(require_medias());
    var _ruleSets = /* @__PURE__ */ _interop_require_default(require_ruleSets());
    var _keyframess = /* @__PURE__ */ _interop_require_default(require_keyframess());
    var _declarations = /* @__PURE__ */ _interop_require_default(require_declarations());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Style = class {
      constructor(declarations, keyframess, ruleSets, medias) {
        this.declarations = declarations;
        this.keyframess = keyframess;
        this.ruleSets = ruleSets;
        this.medias = medias;
      }
      getDeclarations() {
        return this.declarations;
      }
      getKeyframess() {
        return this.keyframess;
      }
      getRuleSets() {
        return this.ruleSets;
      }
      getMedias() {
        return this.medias;
      }
      extends(superStyle) {
        const declarations = superStyle.getDeclarations(), keyframess = superStyle.getKeyframess(), ruleSets = superStyle.getRuleSets(), medias = superStyle.getMedias();
        this.unshift(declarations, keyframess, ruleSets, medias);
      }
      unshift(declarations, keyframess, ruleSets, medias) {
        this.declarations.unshift(declarations);
        this.keyframess.unshift(keyframess);
        this.ruleSets.unshift(ruleSets);
        this.medias.unshift(medias);
      }
      asCSS(className) {
        const indent = _constants.EMPTY_STRING, declarationsCSS = this.declarations.asCSS(className, indent), keyframessCSS = this.keyframess.asCSS(className, indent), ruleSetsCSS = this.ruleSets.asCSS(className, indent), mediasCSS = this.medias.asCSS(className, indent), css = `${declarationsCSS}${keyframessCSS}${ruleSetsCSS}${mediasCSS}`;
        return css;
      }
      static fromNodeAndTokens(node, tokens) {
        const declarations = _declarations.default.fromNodeAndTokens(node, tokens), keyframess = _keyframess.default.fromNodeAndTokens(node, tokens), ruleSets = _ruleSets.default.fromNodeAndTokens(node, tokens), medias = _medias.default.fromNodeAndTokens(node, tokens), style = new Style(declarations, keyframess, ruleSets, medias);
        return style;
      }
    };
  });

  // node_modules/with-style/lib/utilities/styles.js
  var require_styles = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _style = /* @__PURE__ */ _interop_require_default(require_style());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer5());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser6());
    var _constants = require_constants5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var cssLexer = _lexer.default.fromNothing();
    var cssParser = _parser.default.fromNothing();
    if (!globalThis.styleMap) {
      globalThis.styleMap = {};
    }
    var {styleMap} = globalThis;
    function renderStyle(style) {
      const headDOMElement = document.querySelector(_constants.HEAD), styleDOMElement = document.createElement(_constants.STYLE), innerHTML = `        
${style}
`;
      Object.assign(styleDOMElement, {
        innerHTML
      });
      headDOMElement.appendChild(styleDOMElement);
      return styleDOMElement;
    }
    function renderStyles() {
      const stylesCSS = retrieveStylesCSS(), style = stylesCSS;
      renderStyle(style);
    }
    function generateStyle(args, className, superStyle = null) {
      const strings = args.shift(), content = strings.reduce((content2, string, index) => {
        const arg = args[index] || null;
        content2 = arg === null ? `${content2}${string}` : `${content2}${string}${arg}`;
        return content2;
      }, _constants.EMPTY_STRING), tokens = cssLexer.tokenise(content), node = cssParser.parse(tokens), style = _style.default.fromNodeAndTokens(node, tokens);
      if (superStyle !== null) {
        style.extends(superStyle);
      }
      styleMap[className] = style;
    }
    function retrieveStyle(className) {
      const style = styleMap[className] || null;
      return style;
    }
    var _default = {
      renderStyle,
      renderStyles,
      generateStyle,
      retrieveStyle
    };
    function retrieveStylesCSS() {
      const classNames = Object.keys(styleMap), stylesCSS = classNames.reduce((stylesCSS2, className) => {
        const style = retrieveStyle(className), styleCSS = style.asCSS(className);
        stylesCSS2 += styleCSS;
        return stylesCSS2;
      }, _constants.EMPTY_STRING);
      return stylesCSS;
    }
  });

  // node_modules/with-style/lib/utilities/className.js
  var require_className = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get generateClassName() {
        return generateClassName;
      },
      get retrieveClassName() {
        return retrieveClassName;
      }
    });
    var _constants = require_constants5();
    var length = _constants.CLASS_NAME_LENGTH;
    var characters = _constants.CHARACTERS;
    var charactersLength = characters.length;
    var classNames = [];
    function generateClassName() {
      let className = _constants.EMPTY_STRING;
      for (let count = 0; count < length; count++) {
        const index = Math.floor(Math.random() * charactersLength), character = characters[index];
        className += character;
      }
      const classNamesIncludesClassName = classNames.includes(className);
      if (!classNamesIncludesClassName) {
        classNames.push(className);
      } else {
        className = generateClassName();
      }
      return className;
    }
    function retrieveClassName(element) {
      const {className} = element.reactFunction || element.reactComponent.constructor;
      return className;
    }
    var _default = {
      generateClassName,
      retrieveClassName
    };
  });

  // node_modules/with-style/lib/index.js
  var require_lib6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CSSLexer() {
        return _lexer.default;
      },
      get CSSParser() {
        return _parser.default;
      },
      get classNameUtilities() {
        return _className.default;
      },
      get stylesUtilities() {
        return _styles.default;
      },
      get tagNames() {
        return _tagNames.default;
      }
    });
    var _tagNames = /* @__PURE__ */ _interop_require_default(require_tagNames());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer5());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser6());
    var _styles = /* @__PURE__ */ _interop_require_default(require_styles());
    var _className = /* @__PURE__ */ _interop_require_default(require_className());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-with-style/lib/utilities/class.js
  var require_class = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isClass", {
      enumerable: true,
      get: function() {
        return isClass;
      }
    });
    var _easy = require_lib();
    function isClass(argument) {
      return isSubclassOf(argument, _easy.Element);
    }
    function isSubclassOf(argument, Class) {
      const subclassOf = argument.prototype instanceof Class;
      return subclassOf;
    }
  });

  // node_modules/easy-with-style/lib/constants.js
  var require_constants6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CLASS_NAME", {
      enumerable: true,
      get: function() {
        return CLASS_NAME;
      }
    });
    var CLASS_NAME = "className";
  });

  // node_modules/easy-with-style/lib/withStyle.js
  var require_withStyle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easy = require_lib();
    var _withstyle = require_lib6();
    var _class = require_class();
    var _constants = require_constants6();
    var {generateClassName} = _withstyle.classNameUtilities;
    var {renderStyle, renderStyles, generateStyle, retrieveStyle} = _withstyle.stylesUtilities;
    function withStyle(ClassOrFunction) {
      return function() {
        const args = [
          ...arguments
        ];
        let {className = null} = ClassOrFunction;
        const superStyle = retrieveStyle(className);
        className = generateClassName();
        generateStyle(args, className, superStyle);
        const ClassOrFunctionClass = (0, _class.isClass)(ClassOrFunction);
        if (ClassOrFunctionClass) {
          const Class = ClassOrFunction;
          ClassOrFunction = class extends Class {
            static fromClass(_Class, properties, ...remainingArguments) {
              properties = appendClassNameToProperties(className, properties);
              return Class.fromClass(_Class, properties, ...remainingArguments);
            }
          };
        } else {
          const Function2 = ClassOrFunction;
          ClassOrFunction = (properties) => {
            properties = appendClassNameToProperties(className, properties);
            return Function2(properties);
          };
        }
        Object.assign(ClassOrFunction, {
          className
        });
        return ClassOrFunction;
      };
    }
    Object.assign(withStyle, {
      renderStyle,
      renderStyles
    });
    var _default = withStyle;
    _withstyle.tagNames.forEach((tagName) => {
      Object.defineProperty(withStyle, tagName, {
        get: () => function() {
          const args = [
            ...arguments
          ], className = generateClassName();
          generateStyle(args, className);
          const Function2 = (properties) => {
            properties = appendClassNameToProperties(className, properties);
            return _easy.React.createElement(tagName, properties);
          };
          Object.assign(Function2, {
            className
          });
          return Function2;
        }
      });
    });
    function appendClassNameToProperties(className, properties) {
      properties = properties.hasOwnProperty(_constants.CLASS_NAME) ? properties : {
        ...properties,
        className
      };
      return properties;
    }
  });

  // node_modules/easy-with-style/lib/index.js
  var require_lib7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _withStyle = /* @__PURE__ */ _interop_require_default(require_withStyle());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = _withStyle.default;
  });

  // node_modules/easy-layout/lib/constants.js
  var require_constants7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CURSOR", {
      enumerable: true,
      get: function() {
        return CURSOR;
      }
    });
    var CURSOR = "cursor";
  });

  // node_modules/easy-layout/lib/cursors.js
  var require_cursors = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AUTO_CURSOR() {
        return AUTO_CURSOR;
      },
      get COL_RESIZE_CURSOR() {
        return COL_RESIZE_CURSOR;
      },
      get POINTER_CURSOR() {
        return POINTER_CURSOR;
      },
      get ROW_RESIZE_CURSOR() {
        return ROW_RESIZE_CURSOR;
      }
    });
    var AUTO_CURSOR = "auto";
    var POINTER_CURSOR = "pointer";
    var COL_RESIZE_CURSOR = "col-resize";
    var ROW_RESIZE_CURSOR = "row-resize";
  });

  // node_modules/easy-layout/lib/cursor.js
  var require_cursor = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get autoCursor() {
        return autoCursor;
      },
      get columnResizeCursor() {
        return columnResizeCursor;
      },
      get default() {
        return _default;
      },
      get pointerCursor() {
        return pointerCursor;
      },
      get resetCursor() {
        return resetCursor;
      },
      get rowResizeCursor() {
        return rowResizeCursor;
      }
    });
    var _easy = require_lib();
    var _constants = require_constants7();
    var _cursors = require_cursors();
    var body = new _easy.Body();
    var previousCursor;
    function autoCursor() {
      const cursor = _cursors.AUTO_CURSOR;
      updateCursor(cursor);
    }
    function resetCursor() {
      setCursor(previousCursor);
    }
    function pointerCursor() {
      const cursor = _cursors.POINTER_CURSOR;
      updateCursor(cursor);
    }
    function rowResizeCursor() {
      const cursor = _cursors.ROW_RESIZE_CURSOR;
      updateCursor(cursor);
    }
    function columnResizeCursor() {
      const cursor = _cursors.COL_RESIZE_CURSOR;
      updateCursor(cursor);
    }
    var _default = {
      autoCursor,
      resetCursor,
      pointerCursor,
      rowResizeCursor,
      columnResizeCursor
    };
    function setCursor(cursor) {
      const css = {
        cursor
      };
      body.css(css);
    }
    function updateCursor(cursor) {
      const currentCursor = getCurrentCursor();
      if (currentCursor !== cursor) {
        previousCursor = currentCursor;
        setCursor(cursor);
      }
    }
    function getCurrentCursor() {
      const currentCursor = body.css(_constants.CURSOR) || _cursors.AUTO_CURSOR;
      return currentCursor;
    }
  });

  // node_modules/easy-layout/lib/div/row.js
  var require_row = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RowDiv = class extends _easy.Element {
    };
    __publicField(RowDiv, "tagName", "div");
    __publicField(RowDiv, "defaultProperties", {
      className: "row"
    });
    var _default = (0, _easywithstyle.default)(RowDiv)`

  display: flex;
  flex-grow: 1;

`;
  });

  // node_modules/easy-layout/lib/div/rows.js
  var require_rows = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RowsDiv = class extends _easy.Element {
    };
    __publicField(RowsDiv, "tagName", "div");
    __publicField(RowsDiv, "defaultProperties", {
      className: "rows"
    });
    var _default = (0, _easywithstyle.default)(RowsDiv)`

  display: flex;
  flex-grow: 1;
  flex-direction: column;

`;
  });

  // node_modules/easy-layout/lib/div/column.js
  var require_column = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ColumnDiv = class extends _easy.Element {
    };
    __publicField(ColumnDiv, "tagName", "div");
    __publicField(ColumnDiv, "defaultProperties", {
      className: "column"
    });
    var _default = (0, _easywithstyle.default)(ColumnDiv)`

  display: flex;
  flex-grow: 1;

`;
  });

  // node_modules/easy-layout/lib/div/columns.js
  var require_columns = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ColumnsDiv = class extends _easy.Element {
    };
    __publicField(ColumnsDiv, "tagName", "div");
    __publicField(ColumnsDiv, "defaultProperties", {
      className: "columns"
    });
    var _default = (0, _easywithstyle.default)(ColumnsDiv)`

  display: flex;
  flex-grow: 1;
  flex-direction: row;

`;
  });

  // node_modules/easy-drag-and-drop/lib/constants.js
  var require_constants8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "START_DRAGGING_DELAY", {
      enumerable: true,
      get: function() {
        return START_DRAGGING_DELAY;
      }
    });
    var START_DRAGGING_DELAY = 175;
  });

  // node_modules/easy-drag-and-drop/lib/utilities/reference.js
  var require_reference = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "checkDragElementIgnoresDropElement", {
      enumerable: true,
      get: function() {
        return checkDragElementIgnoresDropElement;
      }
    });
    function checkDragElementIgnoresDropElement(dragElement, dropElement) {
      const reference = dropElement.getReference(), references = dragElement.getReferences(), referencesIncludesReference = references.includes(reference), dragElementIgnoresDropElement = !referencesIncludesReference;
      return dragElementIgnoresDropElement;
    }
  });

  // node_modules/easy-drag-and-drop/lib/utilities/event.js
  var require_event2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get mouseLeftFromEvent() {
        return mouseLeftFromEvent;
      },
      get mouseTopFromEvent() {
        return mouseTopFromEvent;
      }
    });
    function mouseTopFromEvent(event) {
      const {pageY} = event, mouseTop = pageY;
      return mouseTop;
    }
    function mouseLeftFromEvent(event) {
      const {pageX} = event, mouseLeft = pageX;
      return mouseLeft;
    }
  });

  // node_modules/easy-drag-and-drop/lib/customEventTypes.js
  var require_customEventTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DRAG_CUSTOM_EVENT_TYPE() {
        return DRAG_CUSTOM_EVENT_TYPE;
      },
      get DRAG_OUT_CUSTOM_EVENT_TYPE() {
        return DRAG_OUT_CUSTOM_EVENT_TYPE;
      },
      get DRAG_OVER_CUSTOM_EVENT_TYPE() {
        return DRAG_OVER_CUSTOM_EVENT_TYPE;
      },
      get DROP_CUSTOM_EVENT_TYPE() {
        return DROP_CUSTOM_EVENT_TYPE;
      },
      get START_DRAG_CUSTOM_EVENT_TYPE() {
        return START_DRAG_CUSTOM_EVENT_TYPE;
      },
      get STOP_DRAG_CUSTOM_EVENT_TYPE() {
        return STOP_DRAG_CUSTOM_EVENT_TYPE;
      },
      get default() {
        return _default;
      }
    });
    var DRAG_CUSTOM_EVENT_TYPE = "drag";
    var DROP_CUSTOM_EVENT_TYPE = "drop";
    var DRAG_OUT_CUSTOM_EVENT_TYPE = "drag-out";
    var DRAG_OVER_CUSTOM_EVENT_TYPE = "drag-over";
    var STOP_DRAG_CUSTOM_EVENT_TYPE = "stop-drag";
    var START_DRAG_CUSTOM_EVENT_TYPE = "start-drag";
    var _default = {
      DRAG_CUSTOM_EVENT_TYPE,
      DROP_CUSTOM_EVENT_TYPE,
      DRAG_OUT_CUSTOM_EVENT_TYPE,
      DRAG_OVER_CUSTOM_EVENT_TYPE,
      STOP_DRAG_CUSTOM_EVENT_TYPE,
      START_DRAG_CUSTOM_EVENT_TYPE
    };
  });

  // node_modules/easy-drag-and-drop/lib/mixins/drag.js
  var require_drag = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _easy = require_lib();
    var _constants = require_constants8();
    var _reference = require_reference();
    var _event = require_event2();
    var _customEventTypes = require_customEventTypes();
    var {ESCAPE_KEY_CODE} = _necessary.keyCodes;
    var {LEFT_MOUSE_BUTTON} = _easy.mouseButtons;
    function getDragElement2() {
      const {dragElement} = globalThis;
      return dragElement;
    }
    function setDragElement(dragElement) {
      Object.assign(globalThis, {
        dragElement
      });
    }
    function resetDragElement() {
      const dragElement = null;
      setDragElement(dragElement);
    }
    Object.assign(globalThis, {
      getDragElement: getDragElement2,
      setDragElement,
      resetDragElement
    });
    resetDragElement();
    function enableDrag() {
      const timeout = null, topOffset = null, leftOffset = null, dragEnabled = true, startMouseTop = null, startMouseLeft = null;
      this.onMouseDown(mouseDownHandler, this);
      this.updateState({
        timeout,
        topOffset,
        leftOffset,
        dragEnabled,
        startMouseTop,
        startMouseLeft
      });
    }
    function disableDrag() {
      const dragEnabled = false;
      this.updateState({
        dragEnabled
      });
      this.offMouseDown(mouseDownHandler, this);
    }
    function onCustomDrag(dragCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, customHandler = dragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDrag(dragCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, customHandler = dragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomStopDrag(stopDragCustomHandler, element) {
      const customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE, customHandler = stopDragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomStopDrag(stopDragCustomHandler, element) {
      const customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE, customHandler = stopDragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomStartDrag(startDragCustomHandler, element) {
      const customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE, customHandler = startDragCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomStartDrag(startDragCustomHandler, element) {
      const customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE, customHandler = startDragCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function isDragEnabled() {
      const {dragEnabled = false} = this.getState();
      return dragEnabled;
    }
    function isDragging() {
      const dragging = this.hasClass("dragging");
      return dragging;
    }
    function startDrag(event, element, mouseTop, mouseLeft) {
      const bounds = this.getBounds(), boundsTop = bounds.getTop(), boundsLeft = bounds.getLeft(), boundsRight = bounds.getRight(), boundsBottom = bounds.getBottom(), boundsWidth = boundsRight - boundsLeft, boundsHeight = boundsBottom - boundsTop, topOffset = Math.floor(boundsHeight / 2), leftOffset = Math.floor(boundsWidth / 2), dragElement = this, startMouseTop = mouseTop, startMouseLeft = mouseLeft, customEventType = _customEventTypes.START_DRAG_CUSTOM_EVENT_TYPE;
      _easy.window.onKeyDown(keyDownHandler, this);
      _easy.window.onMouseMove(mouseMoveHandler, this);
      this.addClass("dragging");
      setDragElement(dragElement);
      this.setTopOffset(topOffset);
      this.setLeftOffset(leftOffset);
      this.setStartMouseTop(startMouseTop);
      this.setStartMouseLeft(startMouseLeft);
      this.callCustomHandlers(customEventType, event, element);
      this.drag(event, element, mouseTop, mouseLeft);
    }
    function stopDrag(event, element, aborted) {
      const dropElement = getDropElement(), customEventType = _customEventTypes.STOP_DRAG_CUSTOM_EVENT_TYPE;
      this.removeClass("dragging");
      _easy.window.offKeyDown(keyDownHandler, this);
      _easy.window.offMouseMove(mouseMoveHandler, this);
      const done = () => {
        this.callCustomHandlersAsync(customEventType, event, element, dropElement, aborted, () => {
          resetDragElement();
        });
      };
      if (dropElement !== null) {
        let dragElement = this;
        const dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
          dragElement = null;
        }
        dropElement.drop(event, element, dragElement, aborted, done);
      } else {
        done();
      }
    }
    function drag(event, element, mouseTop, mouseLeft) {
      const scrollTop = _easy.window.getScrollTop(), scrollLeft = _easy.window.getScrollLeft(), topOffset = this.getTopOffset(), leftOffset = this.getLeftOffset(), startMouseTop = this.getStartMouseTop(), startMouseLeft = this.getStartMouseLeft(), customEventType = _customEventTypes.DRAG_CUSTOM_EVENT_TYPE, relativeMouseTop = mouseTop - startMouseTop, relativeMouseLeft = mouseLeft - startMouseLeft;
      let top = startMouseTop + relativeMouseTop - topOffset - scrollTop, left = startMouseLeft + relativeMouseLeft - leftOffset - scrollLeft;
      top = `${top}px`;
      left = `${left}px`;
      const css = {
        top,
        left
      };
      this.css(css);
      this.callCustomHandlers(customEventType, event, element, relativeMouseTop, relativeMouseLeft);
    }
    function startWaitingToDrag(event, element, mouseTop, mouseLeft) {
      let timeout = this.getTimeout();
      if (timeout === null) {
        timeout = setTimeout(() => {
          this.resetTimeout();
          this.startDrag(event, element, mouseTop, mouseLeft);
        }, _constants.START_DRAGGING_DELAY);
        this.updateTimeout(timeout);
      }
    }
    function stopWaitingToDrag() {
      const timeout = this.getTimeout();
      if (timeout !== null) {
        clearTimeout(timeout);
        this.resetTimeout();
      }
    }
    function getTimeout() {
      const {timeout} = this.getState();
      return timeout;
    }
    function resetTimeout() {
      const timeout = null;
      this.updateTimeout(timeout);
    }
    function updateTimeout(timeout) {
      this.updateState({
        timeout
      });
    }
    function getTopOffset() {
      const {topOffset} = this.getState();
      return topOffset;
    }
    function getLeftOffset() {
      const {leftOffset} = this.getState();
      return leftOffset;
    }
    function getStartMouseTop() {
      const {startMouseTop} = this.getState();
      return startMouseTop;
    }
    function getStartMouseLeft() {
      const {startMouseLeft} = this.getState();
      return startMouseLeft;
    }
    function setTopOffset(topOffset) {
      this.updateState({
        topOffset
      });
    }
    function setLeftOffset(leftOffset) {
      this.updateState({
        leftOffset
      });
    }
    function setStartMouseTop(startMouseTop) {
      this.updateState({
        startMouseTop
      });
    }
    function setStartMouseLeft(startMouseLeft) {
      this.updateState({
        startMouseLeft
      });
    }
    var _default = {
      enableDrag,
      disableDrag,
      onCustomDrag,
      offCustomDrag,
      onCustomStopDrag,
      offCustomStopDrag,
      onCustomStartDrag,
      offCustomStartDrag,
      isDragEnabled,
      isDragging,
      startDrag,
      stopDrag,
      drag,
      startWaitingToDrag,
      stopWaitingToDrag,
      getTimeout,
      resetTimeout,
      updateTimeout,
      getTopOffset,
      getLeftOffset,
      getStartMouseTop,
      getStartMouseLeft,
      setTopOffset,
      setLeftOffset,
      setStartMouseTop,
      setStartMouseLeft
    };
    function keyDownHandler(event, element) {
      const {keyCode} = event, escapeKey = keyCode === ESCAPE_KEY_CODE, aborted = true;
      if (escapeKey) {
        this.stopDrag(event, element, aborted);
        event.stopPropagation();
      }
    }
    function mouseUpHandler(event, element) {
      const dragging = this.isDragging(), aborted = false;
      dragging ? this.stopDrag(event, element, aborted) : this.stopWaitingToDrag();
      event.stopPropagation();
      _easy.window.offBlur(mouseUpHandler, this);
      _easy.window.offMouseUp(mouseUpHandler, this);
    }
    function mouseDownHandler(event, element) {
      const {button} = event;
      if (button === LEFT_MOUSE_BUTTON) {
        const dragging = this.isDragging();
        if (!dragging) {
          const mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
          this.startWaitingToDrag(event, element, mouseTop, mouseLeft);
        }
      }
      event.stopPropagation();
      _easy.window.onBlur(mouseUpHandler, this);
      _easy.window.onMouseUp(mouseUpHandler, this);
    }
    function mouseMoveHandler(event, element) {
      const dragging = this.isDragging();
      if (dragging) {
        const mouseTop = (0, _event.mouseTopFromEvent)(event), mouseLeft = (0, _event.mouseLeftFromEvent)(event);
        this.drag(event, element, mouseTop, mouseLeft);
      }
      event.stopPropagation();
    }
  });

  // node_modules/easy-drag-and-drop/lib/mixins/drop.js
  var require_drop = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _reference = require_reference();
    var _customEventTypes = require_customEventTypes();
    function getDropElement2() {
      const {dropElement} = globalThis;
      return dropElement;
    }
    function setDropElement(dropElement) {
      Object.assign(globalThis, {
        dropElement
      });
    }
    function resetDropElement() {
      const dropElement = null;
      setDropElement(dropElement);
    }
    Object.assign(globalThis, {
      getDropElement: getDropElement2,
      setDropElement,
      resetDropElement
    });
    resetDropElement();
    function drop(event, element, dragElement, aborted, done) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE;
      this.callCustomHandlersAsync(customEventType, event, element, dragElement, aborted, done);
    }
    function dragOut(event, element, dragElement) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE;
      this.callCustomHandlers(customEventType, event, element, dragElement);
    }
    function dragOver(event, element, dragElement) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE;
      this.callCustomHandlers(customEventType, event, element, dragElement);
    }
    function enableDrop() {
      this.onMouseOut(mouseOutHandler, this);
      this.onMouseOver(mouseOverHandler, this);
    }
    function disableDrop() {
      this.offMouseOut(mouseOutHandler, this);
      this.offMouseOver(mouseOverHandler, this);
    }
    function onCustomDrop(dropCustomHandler, element) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE, customHandler = dropCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDrop(dropCustomHandler, element) {
      const customEventType = _customEventTypes.DROP_CUSTOM_EVENT_TYPE, customHandler = dropCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomDragOut(dragOutCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE, customHandler = dragOutCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDragOut(dragOutCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OUT_CUSTOM_EVENT_TYPE, customHandler = dragOutCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    function onCustomDragOver(dragOverCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE, customHandler = dragOverCustomHandler;
      this.onCustomEvent(customEventType, customHandler, element);
    }
    function offCustomDragOver(dragOverCustomHandler, element) {
      const customEventType = _customEventTypes.DRAG_OVER_CUSTOM_EVENT_TYPE, customHandler = dragOverCustomHandler;
      this.offCustomEvent(customEventType, customHandler, element);
    }
    var _default = {
      drop,
      dragOut,
      dragOver,
      enableDrop,
      disableDrop,
      onCustomDrop,
      offCustomDrop,
      onCustomDragOut,
      offCustomDragOut,
      onCustomDragOver,
      offCustomDragOver
    };
    function mouseOutHandler(event, element) {
      const dragElement = getDragElement();
      if (dragElement !== null) {
        resetDropElement();
        this.dragOut(event, element, dragElement);
      }
      event.stopPropagation();
    }
    function mouseOverHandler(event, element) {
      const dragElement = getDragElement();
      if (dragElement !== null) {
        const dropElement = this, dragElementIgnoresDropElement = (0, _reference.checkDragElementIgnoresDropElement)(dragElement, dropElement);
        if (dragElementIgnoresDropElement) {
          return;
        }
        setDropElement(dropElement);
        this.dragOver(event, element, dragElement);
      }
      event.stopPropagation();
    }
  });

  // node_modules/easy-drag-and-drop/lib/element/drag.js
  var require_drag2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _drag = /* @__PURE__ */ _interop_require_default(require_drag());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DragElement = class extends _easy.Element {
      getReferences() {
        const {references = []} = this.properties;
        return references;
      }
      didMount() {
        this.enableDrag();
      }
      willUnmount() {
        this.disableDrag();
      }
    };
    __publicField(DragElement, "ignoredProperties", [
      "references"
    ]);
    Object.assign(DragElement.prototype, _drag.default);
    var _default = (0, _easywithstyle.default)(DragElement)`

  .dragging {
    z-index: 1;
    position: fixed;
    pointer-events: none;
  }
  
`;
  });

  // node_modules/easy-drag-and-drop/lib/element/drop.js
  var require_drop2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DropElement;
      }
    });
    var _easy = require_lib();
    var _drop = /* @__PURE__ */ _interop_require_default(require_drop());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DropElement = class extends _easy.Element {
      getReference() {
        const {reference = null} = this.properties;
        return reference;
      }
      didMount() {
        this.enableDrop();
      }
      willUnmount() {
        this.disableDrop();
      }
    };
    __publicField(DropElement, "ignoredProperties", [
      "reference"
    ]);
    Object.assign(DropElement.prototype, _drop.default);
  });

  // node_modules/easy-drag-and-drop/lib/index.js
  var require_lib8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DragElement() {
        return _drag1.default;
      },
      get DropElement() {
        return _drop1.default;
      },
      get customEventTypes() {
        return _customEventTypes.default;
      },
      get dragMixins() {
        return _drag.default;
      },
      get dropMixins() {
        return _drop.default;
      }
    });
    var _drag = /* @__PURE__ */ _interop_require_default(require_drag());
    var _drop = /* @__PURE__ */ _interop_require_default(require_drop());
    var _drag1 = /* @__PURE__ */ _interop_require_default(require_drag2());
    var _drop1 = /* @__PURE__ */ _interop_require_default(require_drop2());
    var _customEventTypes = /* @__PURE__ */ _interop_require_default(require_customEventTypes());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/easy-layout/lib/div/sizeable.js
  var require_sizeable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SizeableDiv = class extends _easy.Element {
    };
    __publicField(SizeableDiv, "tagName", "div");
    __publicField(SizeableDiv, "defaultProperties", {
      className: "sizeable"
    });
    var _default = (0, _easywithstyle.default)(SizeableDiv)`

  display: flex;
  
`;
  });

  // node_modules/easy-layout/lib/div/splitter.js
  var require_splitter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _easydraganddrop = require_lib8();
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SplitterDiv = class extends _easy.Element {
      stopDragCustomHandler = (event, element, dropElement, aborted, done) => {
        (0, _cursor.resetCursor)();
        done();
      };
      mouseOutHandler = (event, element) => {
        (0, _cursor.resetCursor)();
      };
      getSizeableDiv() {
        let sizeableDiv;
        const nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement(), nextSiblingElementSizeableDiv = nextSiblingElement instanceof _sizeable.default, previousSiblingElementSizeableDiv = previousSiblingElement instanceof _sizeable.default;
        if (nextSiblingElementSizeableDiv) {
          sizeableDiv = nextSiblingElement;
        }
        if (previousSiblingElementSizeableDiv) {
          sizeableDiv = previousSiblingElement;
        }
        return sizeableDiv;
      }
      getDirection() {
        let direction;
        const nextSiblingElement = this.getNextSiblingElement(), previousSiblingElement = this.getPreviousSiblingElement(), nextSiblingElementSizeableDiv = nextSiblingElement instanceof _sizeable.default, previousSiblingElementSizeableDiv = previousSiblingElement instanceof _sizeable.default;
        if (nextSiblingElementSizeableDiv) {
          direction = 1;
        }
        if (previousSiblingElementSizeableDiv) {
          direction = -1;
        }
        return direction;
      }
      getReferences() {
        const references = [];
        return references;
      }
      enable() {
        const dragEnabled = this.isDragEnabled();
        if (!dragEnabled) {
          this.enableDrag();
          this.onCustomDrag(this.dragCustomHandler);
          this.onCustomStopDrag(this.stopDragCustomHandler);
          this.onCustomStartDrag(this.startDragCustomHandler);
        }
      }
      disable() {
        const dragEnabled = this.isDragEnabled();
        if (dragEnabled) {
          this.offCustomStartDrag(this.startDragCustomHandler);
          this.offCustomStopDrag(this.stopDragCustomHandler);
          this.offCustomDrag(this.dragCustomHandler);
          this.disableDrag();
        }
      }
      isDisabled() {
        const dragEnabled = this.isDragEnabled(), disabled = !dragEnabled;
        return disabled;
      }
      didMount() {
        const {disabled = false} = this.properties;
        if (!disabled) {
          this.enable();
        }
        this.onMouseOver(this.mouseOverHandler);
        this.onMouseOut(this.mouseOutHandler);
      }
      willUnmount() {
        const disabled = this.isDisabled();
        this.offMouseOut(this.mouseOutHandler);
        this.offMouseOver(this.mouseOverHandler);
        if (!disabled) {
          this.disable();
        }
      }
      initialise() {
        this.setInitialState();
      }
    };
    __publicField(SplitterDiv, "tagName", "div");
    __publicField(SplitterDiv, "ignoredProperties", [
      "disabled"
    ]);
    __publicField(SplitterDiv, "defaultProperties", {
      className: "splitter"
    });
    Object.assign(SplitterDiv.prototype, _easydraganddrop.dragMixins);
    var _default = (0, _easywithstyle.default)(SplitterDiv)`

  flex-shrink: 0;

`;
  });

  // node_modules/easy-layout/lib/div/splitter/vertical.js
  var require_vertical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VerticalSplitter = class extends _splitter.default {
      startDragCustomHandler = (event, element) => {
        const sizeableDiv = this.getSizeableDiv(), sizeableDivWidth = sizeableDiv.getWidth(), previousSizeableDivWidth = sizeableDivWidth;
        this.setPreviousSizeableDivWidth(previousSizeableDivWidth);
        this.setCursor();
      };
      dragCustomHandler = (event, element, relativeMouseTop, relativeMouseLeft) => {
        const direction = this.getDirection(), sizeableDiv = this.getSizeableDiv(), previousSizeableDivWidth = this.getPreviousSizeableDivWidth(), sizeableDivWidth = previousSizeableDivWidth - direction * relativeMouseLeft, width = sizeableDivWidth;
        sizeableDiv.setWidth(width);
      };
      mouseOverHandler = (event, element) => {
        this.setCursor();
      };
      setCursor() {
        const disabled = this.isDisabled();
        if (!disabled) {
          (0, _cursor.columnResizeCursor)();
        }
      }
      getPreviousSizeableDivWidth() {
        const {previousSizeableDivWidth} = this.getState();
        return previousSizeableDivWidth;
      }
      setPreviousSizeableDivWidth(previousSizeableDivWidth) {
        this.updateState({
          previousSizeableDivWidth
        });
      }
      setInitialState() {
        const previousSizeableDivWidth = null;
        this.setState({
          previousSizeableDivWidth
        });
      }
    };
    __publicField(VerticalSplitter, "defaultProperties", {
      className: "vertical"
    });
    var _default = (0, _easywithstyle.default)(VerticalSplitter)`

  width: 1rem;

`;
  });

  // node_modules/easy-layout/lib/div/splitter/horizontal.js
  var require_horizontal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _cursor = require_cursor();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var HorizontalSplitter = class extends _splitter.default {
      startDragCustomHandler = (event, element) => {
        const sizeableDiv = this.getSizeableDiv(), sizeableDivHeight = sizeableDiv.getHeight(), previousSizeableDivHeight = sizeableDivHeight;
        this.setPreviousSizeableDivHeight(previousSizeableDivHeight);
        this.setCursor();
      };
      dragCustomHandler = (event, element, relativeMouseTop, relativeMouseLeft) => {
        const direction = this.getDirection(), sizeableDiv = this.getSizeableDiv(), previousSizeableDivHeight = this.getPreviousSizeableDivHeight(), sizeableDivHeight = previousSizeableDivHeight - direction * relativeMouseTop, height = sizeableDivHeight;
        sizeableDiv.setHeight(height);
      };
      mouseOverHandler = (event, element) => {
        this.setCursor();
      };
      setCursor() {
        const disabled = this.isDisabled();
        if (!disabled) {
          (0, _cursor.rowResizeCursor)();
        }
      }
      getPreviousSizeableDivHeight() {
        const {previousSizeableDivHeight} = this.getState();
        return previousSizeableDivHeight;
      }
      setPreviousSizeableDivHeight(previousSizeableDivHeight) {
        this.updateState({
          previousSizeableDivHeight
        });
      }
      setInitialState() {
        const previousSizeableDivHeight = null;
        this.setState({
          previousSizeableDivHeight
        });
      }
    };
    __publicField(HorizontalSplitter, "defaultProperties", {
      className: "horizontal"
    });
    var _default = (0, _easywithstyle.default)(HorizontalSplitter)`

  height: 1rem;

`;
  });

  // node_modules/easy-layout/lib/index.js
  var require_lib9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ColumnDiv() {
        return _column.default;
      },
      get ColumnsDiv() {
        return _columns.default;
      },
      get HorizontalSplitterDiv() {
        return _horizontal.default;
      },
      get RowDiv() {
        return _row.default;
      },
      get RowsDiv() {
        return _rows.default;
      },
      get SizeableDiv() {
        return _sizeable.default;
      },
      get SplitterDiv() {
        return _splitter.default;
      },
      get VerticalSplitterDiv() {
        return _vertical.default;
      },
      get cursor() {
        return _cursor.default;
      }
    });
    var _cursor = /* @__PURE__ */ _interop_require_default(require_cursor());
    var _row = /* @__PURE__ */ _interop_require_default(require_row());
    var _rows = /* @__PURE__ */ _interop_require_default(require_rows());
    var _column = /* @__PURE__ */ _interop_require_default(require_column());
    var _columns = /* @__PURE__ */ _interop_require_default(require_columns());
    var _splitter = /* @__PURE__ */ _interop_require_default(require_splitter());
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable());
    var _vertical = /* @__PURE__ */ _interop_require_default(require_vertical());
    var _horizontal = /* @__PURE__ */ _interop_require_default(require_horizontal());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/constants.js
  var require_constants9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BREAK_MESSAGE() {
        return BREAK_MESSAGE;
      },
      get DEBUG_LEVEL() {
        return DEBUG_LEVEL;
      },
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ERROR_LEVEL() {
        return ERROR_LEVEL;
      },
      get INFO_LEVEL() {
        return INFO_LEVEL;
      },
      get LEVELS() {
        return LEVELS;
      },
      get LEVEL_MAXIMUM_LENGTH() {
        return LEVEL_MAXIMUM_LENGTH;
      },
      get SINGLE_SPACE() {
        return SINGLE_SPACE;
      },
      get TRACE_LEVEL() {
        return TRACE_LEVEL;
      },
      get WARNING_LEVEL() {
        return WARNING_LEVEL;
      }
    });
    var _necessary = require_browser();
    var {TRACE_LEVEL, DEBUG_LEVEL, INFO_LEVEL, WARNING_LEVEL, ERROR_LEVEL} = _necessary.levels;
    var LEVELS = [
      TRACE_LEVEL,
      DEBUG_LEVEL,
      INFO_LEVEL,
      WARNING_LEVEL,
      ERROR_LEVEL
    ];
    var EMPTY_STRING = "";
    var SINGLE_SPACE = " ";
    var DOUBLE_SPACE = "  ";
    var BREAK_MESSAGE = ":: BREAK ::";
    var LEVEL_MAXIMUM_LENGTH = 7;
  });

  // node_modules/occam-languages/lib/log.js
  var require_log = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Log;
      }
    });
    var _constants = require_constants9();
    var [TRACE_LEVEL, DEBUG_LEVEL, INFO_LEVEL, WARNING_LEVEL, ERROR_LEVEL] = _constants.LEVELS;
    var Log = class {
      constructor(messages, logLevel, follow) {
        this.messages = messages;
        this.logLevel = logLevel;
        this.follow = follow;
      }
      getMessages() {
        return this.messages;
      }
      getLogLevel() {
        return this.logLevel;
      }
      getFollow() {
        return this.follow;
      }
      trace(message) {
        const level = TRACE_LEVEL;
        this.write(level, message);
      }
      debug(message) {
        const level = DEBUG_LEVEL;
        this.write(level, message);
      }
      info(message) {
        const level = INFO_LEVEL;
        this.write(level, message);
      }
      warning(message) {
        const level = WARNING_LEVEL;
        this.write(level, message);
      }
      error(message) {
        const level = ERROR_LEVEL;
        this.write(level, message);
      }
      write(level, message, filePath = null, lineIndex = null) {
        const levelIndex = _constants.LEVELS.indexOf(level), logLevelIndex = _constants.LEVELS.indexOf(this.logLevel);
        if (levelIndex < logLevelIndex) {
          return;
        }
        message = formatMessage(level, message, filePath, lineIndex);
        this.follow ? console.log(message) : this.messages.push(message);
      }
      static fromNothing() {
        const messages = null, logLevel = TRACE_LEVEL, follow = true, log = new Log(messages, logLevel, follow);
        return log;
      }
      static fromFollowAndLogLevel(follow, logLevel) {
        const messages = follow ? null : [], log = new Log(messages, logLevel, follow);
        return log;
      }
    };
    function formatMessage(level, message, filePath, lineIndex) {
      let formattedMessage = _constants.EMPTY_STRING;
      const leftPaddedLevel = leftPadLevel(level), upperCaseLeftPaddedLevel = leftPaddedLevel.toUpperCase();
      formattedMessage += `${upperCaseLeftPaddedLevel}: `;
      if (filePath !== null) {
        formattedMessage += `${filePath} `;
      }
      if (lineIndex !== null) {
        formattedMessage += `[${lineIndex}] `;
      }
      if (filePath !== null || lineIndex !== null) {
        formattedMessage += `- `;
      }
      formattedMessage += message;
      message = formattedMessage;
      return message;
    }
    function leftPadLevel(level) {
      const maximumLength = _constants.LEVEL_MAXIMUM_LENGTH, leftPaddedLevel = leftPad(level, maximumLength);
      return leftPaddedLevel;
    }
    function leftPad(string, maximumLength) {
      const stringLength = string.length, length = maximumLength - stringLength, indent = _constants.SINGLE_SPACE.repeat(length), leftPaddedString = `${indent}${string}`;
      return leftPaddedString;
    }
  });

  // node_modules/occam-languages/lib/element.js
  var require_element4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Element;
      }
    });
    var Element = class {
      constructor(context2, string, node) {
        this.context = context2;
        this.string = string;
        this.node = node;
      }
      getContext() {
        return this.context;
      }
      getString() {
        return this.string;
      }
      getNode() {
        return this.node;
      }
      setContext(context2) {
        this.context = context2;
      }
      setString(string) {
        this.string = string;
      }
      setNode(node) {
        this.node = node;
      }
      async break(context2) {
        await context2.break(this.node);
      }
      matchNode(node) {
        return this.node.match(node);
      }
    };
  });

  // node_modules/occam-languages/lib/context.js
  var require_context = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Context;
      }
    });
    var _constants = require_constants9();
    var Context = class {
      constructor(context2) {
        this.context = context2;
      }
      getContext() {
        return this.context;
      }
      getDepth() {
        let depth = this.context.getDepth();
        depth++;
        return depth;
      }
      getReleaseContext() {
        return this.context.getReleaseContext();
      }
      nodesAsString(node) {
        return this.context.nodesAsString(node);
      }
      nodeAsString(node) {
        return this.context.nodeAsString(node);
      }
      trace(message) {
        const level = _constants.TRACE_LEVEL;
        this.writeToLog(level, message);
      }
      debug(message) {
        const level = _constants.DEBUG_LEVEL;
        this.writeToLog(level, message);
      }
      info(message) {
        const level = _constants.INFO_LEVEL;
        this.writeToLog(level, message);
      }
      warning(message) {
        const level = _constants.WARNING_LEVEL;
        this.writeToLog(level, message);
      }
      error(message) {
        const level = _constants.ERROR_LEVEL;
        this.writeToLog(level, message);
      }
      writeToLog(level, message) {
        const depth = this.getDepth(), indent = _constants.DOUBLE_SPACE.repeat(depth);
        message = `${indent}${message}`;
        const releaseContext = this.getReleaseContext();
        releaseContext.writeToLog(level, message);
      }
      async break(node) {
        await this.context.break(node);
      }
      static fromNothing(Class, ...remainingArguments) {
        let context2 = remainingArguments.pop();
        context2 = new Class(context2, ...remainingArguments);
        return context2;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/lineIndex.js
  var require_lineIndex = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lineIndexFromNodeAndTokens", {
      enumerable: true,
      get: function() {
        return lineIndexFromNodeAndTokens;
      }
    });
    function lineIndexFromNodeAndTokens(node, tokens) {
      let lineIndex = 0;
      const firstSignificantTokenIndex = node.getFirstSignificantTokenIndex(tokens);
      tokens.some((token, tokenIndex) => {
        const tokenEndOfLineToken = token.isEndOfLineToken();
        if (tokenEndOfLineToken) {
          lineIndex += 1;
        }
        if (tokenIndex === firstSignificantTokenIndex) {
          return true;
        }
      });
      return lineIndex;
    }
  });

  // node_modules/occam-languages/lib/utilities/node.js
  var require_node4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get nodeAsString() {
        return nodeAsString;
      },
      get nodesAsString() {
        return nodesAsString;
      }
    });
    var _constants = require_constants9();
    function nodeAsString(node, tokens) {
      let string;
      tokens = nodeAsTokens(node, tokens);
      string = tokensAsString(tokens);
      string = trimString(string);
      return string;
    }
    function nodesAsString(nodes, tokens) {
      const string = nodes.reduce((string2, node) => {
        const nodeString = nodeAsString(node, tokens);
        string2 = string2 === null ? nodeString : `${string2}, ${nodeString}`;
        return string2;
      }, null);
      return string;
    }
    var _default = {
      nodeAsString,
      nodesAsString
    };
    function trimString(string) {
      string = string.replace(/\s+$/, _constants.EMPTY_STRING);
      return string;
    }
    function tokensAsString(tokens) {
      const string = tokens.reduce((string2, token) => {
        const content = token.getContent();
        string2 = `${string2}${content}`;
        return string2;
      }, _constants.EMPTY_STRING);
      return string;
    }
    function nodeAsTokens(node, tokens) {
      const nodeTerminalNode = node.isTerminalNode();
      if (nodeTerminalNode) {
        const terminalNode = node;
        tokens = terminalNodeAsTokens(terminalNode, tokens);
      } else {
        const nonTerminalNode = node;
        tokens = nonTerminalNodeAsTokens(nonTerminalNode, tokens);
      }
      return tokens;
    }
    function terminalNodeAsTokens(terminalNode, tokens) {
      const significantToken = terminalNode.getSignificantToken(), token = significantToken;
      tokens = [
        token
      ];
      return tokens;
    }
    function nonTerminalNodeAsTokens(nonTerminalNode, tokens) {
      const lastSignificantTokenIndex = nonTerminalNode.getLastSignificantTokenIndex(tokens), firstSignificantTokenIndex = nonTerminalNode.getFirstSignificantTokenIndex(tokens), start = firstSignificantTokenIndex, end = lastSignificantTokenIndex + 1;
      tokens = tokens.slice(start, end);
      return tokens;
    }
  });

  // node_modules/occam-languages/lib/context/file.js
  var require_file = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FileContext;
      }
    });
    var _context = /* @__PURE__ */ _interop_require_default(require_context());
    var _lineIndex = require_lineIndex();
    var _node = require_node4();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FileContext = class extends _context.default {
      constructor(context2, filePath, tokens, node) {
        super(context2);
        this.filePath = filePath;
        this.tokens = tokens;
        this.node = node;
      }
      getFilePath() {
        return this.filePath;
      }
      getTokens() {
        return this.tokens;
      }
      getNode() {
        return this.node;
      }
      getLexer() {
        const lexer = null;
        return lexer;
      }
      getParser() {
        const parser = null;
        return parser;
      }
      getTypePrefix() {
        const context2 = this.getContext(), typePrefix = context2.getTypePrefix();
        return typePrefix;
      }
      matchFilePath(filePath) {
        const filePathMatches = this.filePath === filePath;
        return filePathMatches;
      }
      findFile() {
        const releaseContext = this.getReleaseContext(), file = releaseContext.findFile(this.filePath);
        return file;
      }
      nodeAsString(node) {
        const string = (0, _node.nodeAsString)(node, this.tokens);
        return string;
      }
      nodesAsString(nodes) {
        const string = (0, _node.nodesAsString)(nodes, this.tokens);
        return string;
      }
      prepare() {
        if (this.tokens !== null) {
          return;
        }
        const file = this.findFile(), lexer = this.getLexer(), parser = this.getParser(), content = file.getContent();
        this.tokens = lexer.tokenise(content);
        this.node = parser.parse(this.tokens);
      }
      initialise(json) {
        const {content} = json, lexer = this.getLexer(), parser = this.getParser();
        this.tokens = lexer.tokenise(content);
        this.node = parser.parse(this.tokens);
        this.clear();
        this.addProcedures();
      }
      async break(node) {
        const filePath = this.filePath, lineIndex = (0, _lineIndex.lineIndexFromNodeAndTokens)(node, this.tokens), releaseContext = this.getReleaseContext();
        await releaseContext.break(filePath, lineIndex);
      }
      async verify() {
        let verifies = false;
        this.prepare();
        if (this.node === null) {
          this.warning(`Unable to verify the '${this.filePath}' file because it cannot be parsed.`);
        } else {
          this.debug(`Verifying the '${this.filePath}' file...`);
          const fileVerifies = await this.verifyFile();
          if (fileVerifies) {
            verifies = true;
          }
          verifies ? this.complete() : this.clear();
          if (verifies) {
            this.info(`...verified the '${this.filePath}' file.`);
          }
        }
        return verifies;
      }
      static fromFile(Class, file, ...remainingArguments) {
        const filePath = file.getPath(), tokens = null, node = null, context2 = remainingArguments.pop(), fileContext = new Class(context2, filePath, tokens, node, ...remainingArguments);
        return fileContext;
      }
      static fromJSON(Class, json, ...remainingArguments) {
        const {filePath} = json, tokens = null, node = null, context2 = remainingArguments.pop(), fileContext = new Class(context2, filePath, tokens, node, ...remainingArguments);
        return fileContext;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/asynchronous.js
  var require_asynchronous2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get asyncBackwardsEvery() {
        return asyncBackwardsEvery;
      },
      get asyncEvery() {
        return asyncEvery;
      },
      get asyncForEach() {
        return asyncForEach;
      },
      get asyncForwardsEvery() {
        return asyncForwardsEvery;
      },
      get asyncReduce() {
        return asyncReduce;
      },
      get asyncResolve() {
        return asyncResolve;
      },
      get asyncSome() {
        return asyncSome;
      },
      get default() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var {filter} = _necessary.arrayUtilities;
    async function asyncSome(array, callback) {
      let result = false;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        result = await callback(element, index, array);
        if (result) {
          break;
        }
      }
      return result;
    }
    async function asyncEvery(array, callback) {
      let result = true;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        result = await callback(element, index, array);
        if (!result) {
          break;
        }
      }
      return result;
    }
    async function asyncReduce(array, callback, initialValue) {
      let value = initialValue;
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        value = await callback(value, element, index, array);
      }
      return value;
    }
    async function asyncForEach(array, callback) {
      const length = array.length;
      for (let index = 0; index < length; index += 1) {
        const element = array[index];
        await callback(element, index, array);
      }
    }
    async function asyncResolve(arrayA, arrayB, callback) {
      let resolved;
      arrayA = [
        ...arrayA
      ];
      for (; ; ) {
        const arrayALength2 = arrayA.length;
        if (arrayALength2 === 0) {
          break;
        }
        let resolved2 = false;
        await asyncForEach(arrayA, async (elementA, index) => {
          const passed = await callback(elementA, index, arrayA);
          if (passed) {
            const elementB = elementA;
            arrayB.push(elementB);
            resolved2 = true;
          }
        });
        if (!resolved2) {
          break;
        }
        filter(arrayA, (elementA) => {
          const arrayBIncludesElementA = arrayB.includes(elementA);
          if (!arrayBIncludesElementA) {
            return true;
          }
        });
      }
      const arrayALength = arrayA.length;
      resolved = arrayALength === 0;
      return resolved;
    }
    async function asyncForwardsEvery(array, callback) {
      const length = array.length;
      for (let index = 0; index < length; index++) {
        const element = array[index], passed = await callback(element, index, array);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    async function asyncBackwardsEvery(array, callback) {
      const length = array.length;
      for (let index = length - 1; index >= 0; index--) {
        const element = array[index], passed = await callback(element, index, array);
        if (!passed) {
          return false;
        }
      }
      return true;
    }
    var _default = {
      asyncSome,
      asyncEvery,
      asyncReduce,
      asyncForEach,
      asyncResolve,
      asyncForwardsEvery,
      asyncBackwardsEvery
    };
  });

  // node_modules/occam-languages/lib/utilities/verify.js
  var require_verify = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get verifyFileContexts() {
        return verifyFileContexts;
      },
      get verifyTypePrefixes() {
        return verifyTypePrefixes;
      }
    });
    var _necessary = require_browser();
    var _asynchronous = require_asynchronous2();
    var {first: first2, filter, compress} = _necessary.arrayUtilities;
    async function verifyFileContexts(fileContexts, verifiedFileContexts) {
      const resolved = await (0, _asynchronous.asyncResolve)(fileContexts, verifiedFileContexts, async (fileContext) => {
        const fileContextVerifies = await fileContext.verify();
        if (fileContextVerifies) {
          return true;
        }
      }), fileContextsVerify = resolved;
      return fileContextsVerify;
    }
    function verifyTypePrefixes(typePrefixes, releaseContext) {
      let typePrefixesVerify = true;
      const typePrefixesLength = typePrefixes.length, compressedTypePrefixes = [
        ...typePrefixes
      ];
      compress(compressedTypePrefixes, (typePrefixA, typePrefixB) => {
        const typePrefixAName = typePrefixA.getName(), typePrefixBName = typePrefixB.getName();
        if (typePrefixAName !== typePrefixBName) {
          return true;
        }
      });
      const compressTypePrefixesLength = compressedTypePrefixes.length;
      if (typePrefixesLength > compressTypePrefixesLength) {
        filter(compressedTypePrefixes, (typePrefix2) => {
          const typePrefixesIncludesTypePrefix = typePrefixes.includes(typePrefix2);
          if (!typePrefixesIncludesTypePrefix) {
            return true;
          }
        });
        const firstTypePrefix = first2(typePrefixes), typePrefix = firstTypePrefix, typePrefixString = typePrefix.getString();
        releaseContext.info(`The '${typePrefixString}' type prefix is duplicated.`);
        typePrefixesVerify = false;
      }
      return typePrefixesVerify;
    }
  });

  // node_modules/occam-custom-grammars/lib/grammarNames.js
  var require_grammarNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DEFAULT_CUSTOM_GRAMMAR_NAME", {
      enumerable: true,
      get: function() {
        return DEFAULT_CUSTOM_GRAMMAR_NAME;
      }
    });
    var DEFAULT_CUSTOM_GRAMMAR_NAME = "Default";
  });

  // node_modules/occam-custom-grammars/lib/ruleNames.js
  var require_ruleNames3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get STATEMENT_RULE_NAME() {
        return STATEMENT_RULE_NAME;
      },
      get TERM_RULE_NAME() {
        return TERM_RULE_NAME;
      },
      get default() {
        return _default;
      }
    });
    var TERM_RULE_NAME = "term";
    var STATEMENT_RULE_NAME = "statement";
    var _default = {
      TERM_RULE_NAME,
      STATEMENT_RULE_NAME
    };
  });

  // node_modules/occam-custom-grammars/lib/vocabularyNames.js
  var require_vocabularyNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get SYMBOL_VOCABULARY_NAME() {
        return SYMBOL_VOCABULARY_NAME;
      },
      get TYPE_VOCABULARY_NAME() {
        return TYPE_VOCABULARY_NAME;
      },
      get default() {
        return _default;
      }
    });
    var TYPE_VOCABULARY_NAME = "type";
    var SYMBOL_VOCABULARY_NAME = "symbol";
    var _default = {
      TYPE_VOCABULARY_NAME,
      SYMBOL_VOCABULARY_NAME
    };
  });

  // node_modules/occam-custom-grammars/lib/constants.js
  var require_constants10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BASE_TYPE_SYMBOL() {
        return BASE_TYPE_SYMBOL;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get NONSENSE_RULE_NAME() {
        return NONSENSE_RULE_NAME;
      },
      get STUFF_RULE_NAME() {
        return STUFF_RULE_NAME;
      },
      get UNASSIGNED_TYPE() {
        return UNASSIGNED_TYPE;
      },
      get VERTICAL_BAR() {
        return VERTICAL_BAR;
      },
      get VERTICAL_SPACE() {
        return VERTICAL_SPACE;
      }
    });
    var EMPTY_STRING = "";
    var VERTICAL_BAR = "|";
    var VERTICAL_SPACE = `

`;
    var UNASSIGNED_TYPE = "unassigned";
    var STUFF_RULE_NAME = "stuff";
    var BASE_TYPE_SYMBOL = "<>";
    var NONSENSE_RULE_NAME = "nonsense";
  });

  // node_modules/occam-custom-grammars/lib/customGrammar.js
  var require_customGrammar = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammar;
      }
    });
    var _constants = require_constants10();
    var _grammarNames = require_grammarNames();
    var _ruleNames = require_ruleNames3();
    var _vocabularyNames = require_vocabularyNames();
    var CustomGrammar = class {
      constructor(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary) {
        this.name = name;
        this.termBNF = termBNF;
        this.statementBNF = statementBNF;
        this.typeVocabulary = typeVocabulary;
        this.symbolVocabulary = symbolVocabulary;
      }
      getName() {
        return this.name;
      }
      getTermBNF() {
        return this.termBNF;
      }
      getStatementBNF() {
        return this.statementBNF;
      }
      getTypeVocabulary() {
        return this.typeVocabulary;
      }
      getSymbolVocabulary() {
        return this.symbolVocabulary;
      }
      getBNF(ruleName) {
        let bnf;
        switch (ruleName) {
          case _ruleNames.TERM_RULE_NAME:
            bnf = this.termBNF;
            break;
          case _ruleNames.STATEMENT_RULE_NAME:
            bnf = this.statementBNF;
            break;
        }
        return bnf;
      }
      getVocabulary(vocabularyName) {
        let vocabulary;
        switch (vocabularyName) {
          case _vocabularyNames.TYPE_VOCABULARY_NAME:
            vocabulary = this.typeVocabulary;
            break;
          case _vocabularyNames.SYMBOL_VOCABULARY_NAME:
            vocabulary = this.symbolVocabulary;
            break;
        }
        return vocabulary;
      }
      getVocabularies() {
        const vocabularies = [
          this.typeVocabulary,
          this.symbolVocabulary
        ];
        return vocabularies;
      }
      isDefaultCustomGrammar() {
        const defaultCustomGrammar = this.name === _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
        return defaultCustomGrammar;
      }
      setName(name) {
        this.name = name;
      }
      setBNF(ruleName, bnf) {
        switch (ruleName) {
          case _ruleNames.TERM_RULE_NAME:
            this.termBNF = bnf;
            break;
          case _ruleNames.STATEMENT_RULE_NAME:
            this.statementBNF = bnf;
            break;
        }
      }
      setVocabulary(vocabularyName, vocabulary) {
        switch (vocabularyName) {
          case _vocabularyNames.TYPE_VOCABULARY_NAME:
            this.typeVocabulary = vocabulary;
            break;
          case _vocabularyNames.SYMBOL_VOCABULARY_NAME:
            this.symbolVocabulary = vocabulary;
            break;
        }
      }
      resetBNF(ruleName) {
        const bnf = _constants.EMPTY_STRING;
        this.setBNF(ruleName, bnf);
      }
      resetVocabulary(vocabularyName) {
        const vocabulary = _constants.EMPTY_STRING;
        this.setVocabulary(vocabularyName, vocabulary);
      }
      update(ruleName, bnf, vocabularyName, vocabulary) {
        this.setBNF(ruleName, bnf);
        this.setVocabulary(vocabularyName, vocabulary);
      }
      toJSON() {
        const name = this.name, termBNF = this.termBNF, statementBNF = this.statementBNF, typeVocabulary = this.typeVocabulary, symbolVocabulary = this.symbolVocabulary, json = {
          name,
          termBNF,
          statementBNF,
          typeVocabulary,
          symbolVocabulary
        };
        return json;
      }
      static fromJSON(json) {
        const {name, termBNF, statementBNF, typeVocabulary, symbolVocabulary} = json, customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
      static fromName(name) {
        const termBNF = _constants.EMPTY_STRING, statementBNF = _constants.EMPTY_STRING, typeVocabulary = _constants.EMPTY_STRING, symbolVocabulary = _constants.EMPTY_STRING, customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
      static fromNameTermBNFStatementBNFTypeVocabularyAndSymbolVocabulary(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary) {
        const customGrammar = new CustomGrammar(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
        return customGrammar;
      }
    };
  });

  // node_modules/occam-custom-grammars/lib/customGrammar/default.js
  var require_default = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name2 in all)
        Object.defineProperty(target, name2, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name2).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get statementBNF() {
        return statementBNF;
      },
      get symbolVocabulary() {
        return symbolVocabulary;
      },
      get termBNF() {
        return termBNF;
      },
      get typeVocabulary() {
        return typeVocabulary;
      }
    });
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _grammarNames = require_grammarNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var termBNF = `term                                 ::=  "(" argument ")"

                                       |  variable 
                                       
                                       ;`;
    var statementBNF = `statement                            ::=  "(" metaArgument ")" 
                                                  
                                       |  equality

                                       |  judgement

                                       |  typeAssertion 
                                                  
                                       |  definedAssertion  

                                       |  containedAssertion  
                                       
                                       |  satisfiesAssertion

                                       |  subproofAssertion         

                                       |  propertyAssertion  

                                       |  metavariable ( frameSubstitution | termSubstitution )?

                                       ;

equality                             ::=  term "=" term ;

typeAssertion                        ::=  term ":" type ;

definedAssertion                     ::=  ( frame | term ) "is" ( "defined" | "undefined" );

containedAssertion                   ::=  ( frame | term ) "is" ( "present" | "missing" ) "in" statement ;

satisfiesAssertion                   ::=  signature "satisfies" metavariable ;  

subproofAssertion                    ::=  "[" statement ( "," statement )* "]" "..." statement ;

propertyAssertion                    ::=  term "is" ( "a" | "an" ) propertyRelation ;

propertyRelation                     ::=  property "of" term ;

judgement                            ::=  frame "|"<NO_WHITESPACE>"-" assumption ;

frame                                ::=  "[" ( ( assumption ( "," assumption )* ) | metavariable ) "]" ;
 
assumption                           ::=  metavariable "::" statement ;

termSubstitution                     ::=  "[" term "for" term "]";

frameSubstitution                    ::=  "[" frame "for" frame "]";

statementSubstitution                ::=  "[" statement "for" statement "]";

referenceSubstitution                ::=  "[" reference "for" reference "]";`;
    var typeVocabulary = "";
    var symbolVocabulary = "";
    var name = _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
    var json = {
      name,
      termBNF,
      statementBNF,
      typeVocabulary,
      symbolVocabulary
    };
    var defaultCustomGrammar = _customGrammar.default.fromJSON(json);
    var _default = defaultCustomGrammar;
  });

  // node_modules/occam-grammar-utilities/lib/example/lexer/example.js
  var require_example = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExampleLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _ExampleLexer = class extends _occamlexers.CommonLexer {
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_ExampleLexer, entries);
      }
    };
    var ExampleLexer = _ExampleLexer;
    __publicField(ExampleLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(ExampleLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(ExampleLexer, "RegularExpressionToken", null);
    __publicField(ExampleLexer, "EndOfLineCommentToken", null);
    __publicField(ExampleLexer, "SingleLineCommentToken", null);
    __publicField(ExampleLexer, "EndOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "StartOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(ExampleLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(ExampleLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammar-utilities/lib/example/parser/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamparsers = require_lib4();
    var A = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(A, ruleName, childNodes, opacity, precedence);
      }
    };
    var B = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(B, ruleName, childNodes, opacity, precedence);
      }
    };
    var C = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(C, ruleName, childNodes, opacity, precedence);
      }
    };
    var D = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(D, ruleName, childNodes, opacity, precedence);
      }
    };
    var E = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(E, ruleName, childNodes, opacity, precedence);
      }
    };
    var F = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(F, ruleName, childNodes, opacity, precedence);
      }
    };
    var S = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(S, ruleName, childNodes, opacity, precedence);
      }
    };
    var T = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(T, ruleName, childNodes, opacity, precedence);
      }
    };
    var V = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(V, ruleName, childNodes, opacity, precedence);
      }
    };
    var NonTerminalNodeMap = {
      A,
      B,
      C,
      D,
      E,
      F,
      S,
      T,
      V
    };
    var _default = NonTerminalNodeMap;
  });

  // node_modules/occam-grammar-utilities/lib/example/parser/example.js
  var require_example2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExampleParser;
      }
    });
    var _occamparsers = require_lib4();
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ExampleParser = class extends _occamparsers.CommonParser {
    };
    __publicField(ExampleParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
  });

  // node_modules/occam-grammar-utilities/lib/cycle.js
  var require_cycle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Cycle;
      }
    });
    var _necessary = require_browser();
    var {COMMA_CHARACTER} = _necessary.characters;
    var Cycle = class {
      constructor(edges) {
        this.edges = edges;
      }
      getEdges() {
        return this.edges;
      }
      getLength() {
        const length = this.edges.length;
        return length;
      }
      getEdge(index) {
        const edge = this.edges[index];
        return edge;
      }
      getVertexes() {
        const vertexes = this.mapEdge((edge) => {
          const sourceVertex = edge.getSourceVertex(), vertex = sourceVertex;
          return vertex;
        });
        return vertexes;
      }
      mapEdge(callback) {
        return this.edges.map(callback);
      }
      everyEdge(callback) {
        return this.edges.every(callback);
      }
      forEachEdge(callback) {
        return this.edges.forEach(callback);
      }
      isEqualTo(cycle) {
        let equalTo = false;
        const cycleA = this, cycleB = cycle, cycleALength = cycleA.getLength(), cycleBLength = cycleB.getLength();
        if (cycleALength === cycleBLength) {
          equalTo = cycleA.everyEdge((edgeA, index) => {
            const edgeB = cycleB.getEdge(index), matches = edgeA.match(edgeB);
            if (matches) {
              return true;
            }
          });
        }
        return equalTo;
      }
      permuted() {
        const edges = this.edges.slice(), edge = edges.pop();
        edges.unshift(edge);
        const cycle = new Cycle(edges);
        return cycle;
      }
      asString() {
        const vertexes = this.getVertexes(), string = vertexes.join(COMMA_CHARACTER);
        return string;
      }
      static fromEdge(edge) {
        const edges = [
          edge
        ], cycle = new Cycle(edges);
        return cycle;
      }
      static fromEdges(edges) {
        const cycle = new Cycle(edges);
        return cycle;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/directedGraph.js
  var require_directedGraph = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return DirectedGraph;
      },
      get edgesMatchEdge() {
        return edgesMatchEdge;
      }
    });
    var _necessary = require_browser();
    var _cycle = /* @__PURE__ */ _interop_require_default(require_cycle());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {last, find, compress} = _necessary.arrayUtilities;
    var DirectedGraph = class {
      constructor(edges, startVertex) {
        this.edges = edges;
        this.startVertex = startVertex;
      }
      getEdges() {
        return this.edges;
      }
      getStartVertex() {
        return this.startVertex;
      }
      addEdge(edge) {
        const matches = edgesMatchEdge(this.edges, edge);
        if (!matches) {
          this.edges.push(edge);
        }
      }
      addEdges(edges) {
        edges.forEach((edge) => {
          this.addEdge(edge);
        });
      }
      removeEdge(edge) {
        const index = this.edges.indexOf(edge), start = index, deleteCount = 1;
        this.edges.splice(start, deleteCount);
      }
      depthFirstSearch(vertex, vertexes, callback) {
        const previousVertexes = vertexes, successorVertexes = this.findSuccessorVertexes(vertex);
        successorVertexes.forEach((successorVertex) => {
          const previousVertexesIncludesSuccessorVertex = previousVertexes.includes(successorVertex), vertexes2 = [
            ...previousVertexes,
            successorVertex
          ], vertex2 = successorVertex;
          if (previousVertexesIncludesSuccessorVertex) {
            callback(vertexes2);
          } else {
            this.depthFirstSearch(vertex2, vertexes2, callback);
          }
        });
      }
      findCycles() {
        const trivialCycles = this.findTrivialCycles(), nonTrivialCycles = this.findNonTrivialCycles(), cycles = [
          ...trivialCycles,
          ...nonTrivialCycles
        ];
        compress(cycles, (cycleA, cycleB) => {
          const cyclesCoincident = areCyclesCoincident(cycleA, cycleB);
          if (!cyclesCoincident) {
            return true;
          }
        });
        return cycles;
      }
      findTrivialCycles() {
        const triviallyCyclicEdges = this.findTriviallyCyclicEdges(), trivialCycles = triviallyCyclicEdges.map((triviallyCyclicEdge) => {
          const edge = triviallyCyclicEdge, cycle = _cycle.default.fromEdge(edge), trivialCycle = cycle;
          return trivialCycle;
        });
        return trivialCycles;
      }
      findNonTrivialCycles() {
        const nonTrivialCycles = [], directedGraph = this, vertex = this.startVertex, vertexes = [
          vertex
        ];
        this.depthFirstSearch(vertex, vertexes, (vertexes2) => {
          const nonTrivialCycle = nonTrivialCycleFromVertexes(vertexes2, directedGraph);
          nonTrivialCycles.push(nonTrivialCycle);
        });
        return nonTrivialCycles;
      }
      findSuccessorEdges(vertex) {
        const sourceVertex = vertex, edges = this.findEdgesBySourceVertex(sourceVertex), successorEdges = edges.filter((edge) => {
          const targetVertex = edge.getTargetVertex();
          if (targetVertex !== sourceVertex) {
            return true;
          }
        });
        return successorEdges;
      }
      findSuccessorVertexes(vertex) {
        const successorEdges = this.findSuccessorEdges(vertex), successorVertexes = successorEdges.map((successorEdge) => {
          const successorEdgeTargetVertex = successorEdge.getTargetVertex(), successorVertex = successorEdgeTargetVertex;
          return successorVertex;
        });
        return successorVertexes;
      }
      findEdgesBySourceVertex(sourceVertex) {
        const edges = find(this.edges, (edge) => {
          const edgeMatchesSourceVertex = edge.matchSourceVertex(sourceVertex);
          if (edgeMatchesSourceVertex) {
            return true;
          }
        });
        return edges;
      }
      findTriviallyCyclicEdges() {
        const triviallyCyclicEdges = find(this.edges, (edge) => {
          const edgeTriviallyCyclic = edge.isTriviallyCyclic();
          if (edgeTriviallyCyclic) {
            return true;
          }
        });
        return triviallyCyclicEdges;
      }
      findEdgeBySourceVertexAndTargetVertex(sourceVertex, targetVertex) {
        const edge = this.edges.find((edge2) => {
          const matches = edge2.matchSourceVertexAndTargetVertex(sourceVertex, targetVertex);
          if (matches) {
            return true;
          }
        }) || null;
        return edge;
      }
      static fromEdgesAndStartVertex(edges, startVertex) {
        const directedGraph = new DirectedGraph(edges, startVertex);
        return directedGraph;
      }
    };
    function edgesMatchEdge(edges, edge) {
      const edgeA = edge, matches = edges.some((edge2) => {
        const edgeB = edge2, edgeAMatchesEdgeB = edgeA.match(edgeB);
        if (edgeAMatchesEdgeB) {
          return true;
        }
      });
      return matches;
    }
    function nonTrivialCycleFromVertexes(vertexes, directedGraph) {
      const lastVertex = last(vertexes), index = vertexes.indexOf(lastVertex), start = index;
      vertexes = vertexes.slice(start);
      vertexes.pop();
      const length = vertexes.length, edges = vertexes.map((vertex, index2) => {
        const nextIndex = (index2 + 1) % length, nextVertex = vertexes[nextIndex], sourceVertex = vertex, targetVertex = nextVertex, edge = directedGraph.findEdgeBySourceVertexAndTargetVertex(sourceVertex, targetVertex);
        return edge;
      }), cycle = _cycle.default.fromEdges(edges);
      return cycle;
    }
    function someCyclePermutation(cycle, callback) {
      let result = false;
      const length = cycle.getLength();
      for (let offset = 0; offset < length; offset++) {
        result = callback(cycle);
        if (result) {
          break;
        }
        cycle = cycle.permuted();
      }
      return result;
    }
    function areCyclesCoincident(cycleA, cycleB) {
      let cyclesCoincident = false;
      const cycleALength = cycleA.getLength(), cycleBLength = cycleB.getLength();
      if (cycleALength === cycleBLength) {
        cyclesCoincident = someCyclePermutation(cycleA, (cycleA2) => {
          const cycleAEqualTo = cycleA2.isEqualTo(cycleB);
          if (cycleAEqualTo) {
            return true;
          }
        });
      }
      return cyclesCoincident;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/reduced.js
  var require_reduced = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReducedNode;
      }
    });
    var _occamparsers = require_lib4();
    var ReducedNode = class extends _occamparsers.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReducedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/constants.js
  var require_constants11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "EMPTY_STRING", {
      enumerable: true,
      get: function() {
        return EMPTY_STRING;
      }
    });
    var EMPTY_STRING = "";
  });

  // node_modules/occam-grammar-utilities/lib/utilities/ruleName.js
  var require_ruleName7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get directlyRepeatedRuleNameFromRuleName() {
        return directlyRepeatedRuleNameFromRuleName;
      },
      get indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName() {
        return indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName;
      },
      get leftRecursiveRuleNameFromIndirectlyRepeatedRuleName() {
        return leftRecursiveRuleNameFromIndirectlyRepeatedRuleName;
      },
      get reducedRuleNameFromRuleName() {
        return reducedRuleNameFromRuleName;
      },
      get ruleNameFromIndirectlyRepeatedRuleName() {
        return ruleNameFromIndirectlyRepeatedRuleName;
      },
      get ruleNameFromReducedRuleName() {
        return ruleNameFromReducedRuleName;
      }
    });
    var _constants = require_constants11();
    function reducedRuleNameFromRuleName(ruleName) {
      const reducedRuleName = `${ruleName}_`;
      return reducedRuleName;
    }
    function ruleNameFromReducedRuleName(reducedRuleName) {
      const ruleName = reducedRuleName.replace(/_$/g, _constants.EMPTY_STRING);
      return ruleName;
    }
    function directlyRepeatedRuleNameFromRuleName(ruleName) {
      const directlyRepeatedRuleName = `${ruleName}~`;
      return directlyRepeatedRuleName;
    }
    function ruleNameFromIndirectlyRepeatedRuleName(indirectlyRepeatedRuleName) {
      const ruleName = indirectlyRepeatedRuleName.replace(/~.+$/g, _constants.EMPTY_STRING);
      return ruleName;
    }
    function leftRecursiveRuleNameFromIndirectlyRepeatedRuleName(indirectlyRepeatedRuleName) {
      const leftRecursiveRuleName = indirectlyRepeatedRuleName.replace(/^[^~]+~/g, _constants.EMPTY_STRING);
      return leftRecursiveRuleName;
    }
    function indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = `${ruleName}~${leftRecursiveRuleName}`;
      return indirectlyRepeatedRuleName;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/cycle.js
  var require_cycle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isCycleIrreducible() {
        return isCycleIrreducible;
      },
      get ruleCyclesFromRuleNameAndCycles() {
        return ruleCyclesFromRuleNameAndCycles;
      },
      get ruleNamesFromCycle() {
        return ruleNamesFromCycle;
      },
      get ruleNamesFromCycles() {
        return ruleNamesFromCycles;
      }
    });
    var _necessary = require_browser();
    var _ruleName = require_ruleName7();
    var {push, compress} = _necessary.arrayUtilities;
    function isCycleIrreducible(cycle, ruleMap) {
      const ruleNames = ruleNamesFromCycle(cycle), reducedRules = ruleNames.reduce((reducedRules2, ruleName) => {
        const reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName), reducedRule = ruleMap[reducedRuleName] || null;
        if (reducedRule !== null) {
          reducedRules2.push(reducedRule);
        }
        return reducedRules2;
      }, []), reducedRulesLength = reducedRules.length, cycleIrreducible = reducedRulesLength === 0;
      return cycleIrreducible;
    }
    function ruleNamesFromCycle(cycle, ruleNames = []) {
      const cycleVertexes = cycle.getVertexes(), cycleRuleNames = cycleVertexes;
      push(ruleNames, cycleRuleNames);
      return ruleNames;
    }
    function ruleNamesFromCycles(cycles, ruleNames = []) {
      cycles.forEach((cycle) => {
        ruleNamesFromCycle(cycle, ruleNames);
      });
      compress(ruleNames, (ruleNameA, ruleNameB) => {
        if (ruleNameA !== ruleNameB) {
          return true;
        }
      });
      return ruleNames;
    }
    function ruleCyclesFromRuleNameAndCycles(ruleName, cycles) {
      const ruleCycles = cycles.reduce((ruleCycles2, cycle) => {
        const ruleNames = ruleNamesFromCycle(cycle), ruleNamesIncludeRuleName = ruleNames.includes(ruleName);
        if (ruleNamesIncludeRuleName) {
          const ruleCycle = cycle;
          ruleCycles2.push(ruleCycle);
        }
        return ruleCycles2;
      }, []);
      return ruleCycles;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/nonConsuming.js
  var require_nonConsuming = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isPartNonConsuming() {
        return isPartNonConsuming;
      },
      get isRuleNonConsuming() {
        return isRuleNonConsuming;
      }
    });
    var _occamparsers = require_lib4();
    var _occamlexers = require_lib3();
    var {epsilon, noWhitespace, startOfContent} = _occamlexers.specialSymbols;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isRuleNonConsuming(rule, ruleMap, ruleNames = []) {
      let ruleNonConsuming = false;
      const ruleName = rule.getName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
      if (!ruleNamesIncludesRuleName) {
        ruleNames = [
          ...ruleNames,
          ruleName
        ];
        const definitions = rule.getDefinitions(), definitionsNonConsuming = areDefinitionsNonConsuming(definitions, ruleMap, ruleNames);
        ruleNonConsuming = definitionsNonConsuming;
      }
      return ruleNonConsuming;
    }
    function isPartNonConsuming(part, ruleMap, ruleNames = []) {
      let partNonConsuming;
      const parTerminalPart = part.isTerminalPart();
      if (parTerminalPart) {
        const terminalPart = part, terminalPartNonConsuming = isTerminalPartNonConsuming(terminalPart);
        partNonConsuming = terminalPartNonConsuming;
      } else {
        const nonTerminalNPart = part, nonTerminalPartNonConsuming = isNonTerminalPartNonConsuming(nonTerminalNPart, ruleMap, ruleNames);
        partNonConsuming = nonTerminalPartNonConsuming;
      }
      return partNonConsuming;
    }
    function areDefinitionsNonConsuming(definitions, ruleMap, ruleNames) {
      const definitionsNonConsuming = definitions.some((definition) => {
        const definitionNonConsuming = isDefinitionNonConsuming(definition, ruleMap, ruleNames);
        if (definitionNonConsuming) {
          return true;
        }
      });
      return definitionsNonConsuming;
    }
    function isDefinitionNonConsuming(definition, ruleMap, ruleNames) {
      const parts = definition.getParts(), partsNonConsuming = arePartsNonConsuming(parts, ruleMap, ruleNames), definitionNonConsuming = partsNonConsuming;
      return definitionNonConsuming;
    }
    function arePartsNonConsuming(parts, ruleMap, ruleNames) {
      const partsNonConsuming = parts.every((part) => {
        const partNonConsuming = isPartNonConsuming(part, ruleMap, ruleNames);
        if (partNonConsuming) {
          return true;
        }
      });
      return partsNonConsuming;
    }
    function isTerminalPartNonConsuming(terminalPart) {
      let terminalPartNonConsuming;
      const terminalPartString = terminalPart.asString();
      switch (terminalPartString) {
        case epsilon:
        case noWhitespace:
        case startOfContent: {
          terminalPartNonConsuming = true;
          break;
        }
        default: {
          terminalPartNonConsuming = false;
          break;
        }
      }
      return terminalPartNonConsuming;
    }
    function isNonTerminalPartNonConsuming(nonTerminalPart, ruleMap, ruleNames) {
      let partNonConsuming = false;
      const type = nonTerminalPart.getType();
      switch (type) {
        case RuleNamePartType: {
          const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), rule = ruleMap[ruleName] || null;
          if (rule !== null) {
            const ruleNonConsuming = isRuleNonConsuming(rule, ruleMap, ruleNames);
            partNonConsuming = ruleNonConsuming;
          }
          break;
        }
        case OptionalPartPartType: {
          partNonConsuming = true;
          break;
        }
        case OneOrMorePartsPartType: {
          const oneOrMorePartsPart = nonTerminalPart, part = oneOrMorePartsPart.getPart();
          partNonConsuming = isPartNonConsuming(part, ruleMap, ruleNames);
          break;
        }
        case ZeroOrMorePartsPartType: {
          partNonConsuming = true;
          break;
        }
        case SequenceOfPartsPartType: {
          const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), partsNonConsuming = arePartsNonConsuming(parts, ruleMap, ruleNames);
          partNonConsuming = partsNonConsuming;
          break;
        }
        case ChoiceOfPartsPartType: {
          const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts(), partsNonConsuming = parts.some((part) => {
            const partNonConsuming2 = isPartNonConsuming(part, ruleMap, ruleNames);
            return partNonConsuming2;
          });
          partNonConsuming = partsNonConsuming;
          break;
        }
      }
      return partNonConsuming;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/leftRecursive.js
  var require_leftRecursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isDefinitionLeftRecursive() {
        return isDefinitionLeftRecursive;
      },
      get leftRecursiveRuleNamesFromDefinition() {
        return leftRecursiveRuleNamesFromDefinition;
      },
      get leftRecursiveRuleNamesFromRule() {
        return leftRecursiveRuleNamesFromRule;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var _nonConsuming = require_nonConsuming();
    var {first: first2} = _necessary.arrayUtilities;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isDefinitionLeftRecursive(definition, ruleMap) {
      const parts = definition.getParts(), partsLeftRecursive = arePartsLeftRecursive(parts, ruleMap), definitionLeftRecursive = partsLeftRecursive;
      return definitionLeftRecursive;
    }
    function leftRecursiveRuleNamesFromRule(rule, ruleMap, leftRecursiveRuleNames = []) {
      const definitions = rule.getDefinitions();
      definitions.forEach((definition) => {
        leftRecursiveRuleNamesFromDefinition(definition, ruleMap, leftRecursiveRuleNames);
      });
      return leftRecursiveRuleNames;
    }
    function leftRecursiveRuleNamesFromDefinition(definition, ruleMap, leftRecursiveRuleNames = []) {
      const parts = definition.getParts();
      leftRecursiveRuleNamesFromParts(parts, ruleMap, leftRecursiveRuleNames);
      return leftRecursiveRuleNames;
    }
    function arePartsLeftRecursive(parts, ruleMap) {
      const leftRecursiveRuleNames = leftRecursiveRuleNamesFromParts(parts, ruleMap), leftRecursiveRuleNamesLength = leftRecursiveRuleNames.length, partsLeftRecursive = leftRecursiveRuleNamesLength > 0;
      return partsLeftRecursive;
    }
    function leftRecursiveRuleNamesFromPart(part, ruleMap, leftRecursiveRuleNames) {
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), leftRecursiveRuleNamesIncludesRuleName = leftRecursiveRuleNames.includes(ruleName);
            if (!leftRecursiveRuleNamesIncludesRuleName) {
              const leftRecursiveRuleName = ruleName;
              leftRecursiveRuleNames.push(leftRecursiveRuleName);
            }
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case SequenceOfPartsPartType: {
            const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), firstPart = first2(parts), part2 = firstPart;
            leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            break;
          }
          case ChoiceOfPartsPartType: {
            const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts();
            parts.forEach((part2) => {
              leftRecursiveRuleNamesFromPart(part2, ruleMap, leftRecursiveRuleNames);
            });
            break;
          }
        }
      }
    }
    function leftRecursiveRuleNamesFromParts(parts, ruleMap, leftRecursiveRuleNames = []) {
      parts.every((part) => {
        const partNonConsuming = (0, _nonConsuming.isPartNonConsuming)(part, ruleMap);
        if (!partNonConsuming) {
          leftRecursiveRuleNamesFromPart(part, ruleMap, leftRecursiveRuleNames);
        } else {
          return true;
        }
      });
      return leftRecursiveRuleNames;
    }
  });

  // node_modules/occam-grammar-utilities/lib/edge.js
  var require_edge = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Edge;
      }
    });
    var Edge = class {
      constructor(label, sourceVertex, targetVertex) {
        this.label = label;
        this.sourceVertex = sourceVertex;
        this.targetVertex = targetVertex;
      }
      getLabel() {
        return this.label;
      }
      getSourceVertex() {
        return this.sourceVertex;
      }
      getTargetVertex() {
        return this.targetVertex;
      }
      isTriviallyCyclic() {
        const triviallyCyclic = this.sourceVertex === this.targetVertex;
        return triviallyCyclic;
      }
      match(edge) {
        const label = this.getLabel(), sourceVertex = edge.getSourceVertex(), targetVertex = edge.getTargetVertex(), matches = this.matchLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex);
        return matches;
      }
      matchSourceVertex(sourceVertex) {
        const matchesSourceVertex = this.sourceVertex === sourceVertex;
        return matchesSourceVertex;
      }
      matchTargetVertex(targetVertex) {
        const matchesTargetVertex = this.targetVertex === targetVertex;
        return matchesTargetVertex;
      }
      matchSourceVertexAndTargetVertex(sourceVertex, targetVertex) {
        const matches = this.sourceVertex === sourceVertex && this.targetVertex === targetVertex;
        return matches;
      }
      matchLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex) {
        const matches = this.label === label && this.sourceVertex === sourceVertex && this.targetVertex === targetVertex;
        return matches;
      }
      static fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex) {
        const edge = new Edge(label, sourceVertex, targetVertex);
        return edge;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/recursive.js
  var require_recursive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "recursiveRuleNamesFromRule", {
      enumerable: true,
      get: function() {
        return recursiveRuleNamesFromRule;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, SequenceOfPartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    function recursiveRuleNamesFromRule(rule, recursiveRuleNames = []) {
      const definitions = rule.getDefinitions();
      definitions.forEach((definition) => {
        recursiveRuleNamesFromDefinition(definition, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromDefinition(definition, recursiveRuleNames = []) {
      const parts = definition.getParts();
      recursiveRuleNamesFromParts(parts, recursiveRuleNames);
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromParts(parts, recursiveRuleNames = []) {
      parts.forEach((part) => {
        recursiveRuleNamesFromPart(part, recursiveRuleNames);
      });
      return recursiveRuleNames;
    }
    function recursiveRuleNamesFromPart(part, recursiveRuleNames) {
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), recursiveRuleNamesIncludesRuleName = recursiveRuleNames.includes(ruleName);
            if (!recursiveRuleNamesIncludesRuleName) {
              const recursiveRuleName = ruleName;
              recursiveRuleNames.push(recursiveRuleName);
            }
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            break;
          }
          case SequenceOfPartsPartType: {
            const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts();
            parts.forEach((part2) => {
              recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            });
            break;
          }
          case ChoiceOfPartsPartType: {
            const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts();
            parts.forEach((part2) => {
              recursiveRuleNamesFromPart(part2, recursiveRuleNames);
            });
            break;
          }
        }
      }
    }
  });

  // node_modules/occam-grammar-utilities/lib/labels.js
  var require_labels = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get LEFT_RECURSIVE_LABEL() {
        return LEFT_RECURSIVE_LABEL;
      },
      get RECURSIVE_LABEL() {
        return RECURSIVE_LABEL;
      }
    });
    var RECURSIVE_LABEL = "recursive";
    var LEFT_RECURSIVE_LABEL = "left-recursive";
  });

  // node_modules/occam-grammar-utilities/lib/utilities/directedGraph.js
  var require_directedGraph2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get edgeFromRuleNameAndLeftRecursiveRuleName() {
        return edgeFromRuleNameAndLeftRecursiveRuleName;
      },
      get edgesFromRuleNames() {
        return edgesFromRuleNames;
      },
      get edgesFromStartRule() {
        return edgesFromStartRule;
      }
    });
    var _edge = /* @__PURE__ */ _interop_require_default(require_edge());
    var _directedGraph = require_directedGraph();
    var _recursive = require_recursive();
    var _labels = require_labels();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function edgesFromRuleNames(ruleNames) {
      const length = ruleNames.length, edges = ruleNames.map((ruleName, index) => {
        const nextIndex = (index + 1) % length, nextRuleName = ruleNames[nextIndex], leftRecursiveRuleName = nextRuleName, edge = edgeFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName);
        return edge;
      });
      return edges;
    }
    function edgesFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const rule = startRule, edges = [], vertexes = [];
      edgesFromRule(rule, edges, vertexes, ruleMap, ruleNamesMap);
      return edges;
    }
    function edgeFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const label = _labels.LEFT_RECURSIVE_LABEL, sourceVertex = ruleName, targetVertex = leftRecursiveRuleName, edge = _edge.default.fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex);
      return edge;
    }
    function edgesFromRule(rule, edges, vertexes, ruleMap, ruleNamesMap) {
      const ruleName = rule.getName(), vertex = ruleName, vertexesIncludesVertex = vertexes.includes(vertex);
      if (vertexesIncludesVertex) {
        return;
      }
      vertexes = [
        ...vertexes,
        vertex
      ];
      const ruleNames = ruleNamesMap[ruleName], recursiveRuleNames = (0, _recursive.recursiveRuleNamesFromRule)(rule), leftRecursiveRuleNames = ruleNames;
      recursiveRuleNames.forEach((recursiveRuleName) => {
        const leftRecursiveRuleNamesIncludesRecursiveRuleName = leftRecursiveRuleNames.includes(recursiveRuleName), leftRecursiveRuleName = recursiveRuleName, label = leftRecursiveRuleNamesIncludesRecursiveRuleName ? _labels.LEFT_RECURSIVE_LABEL : _labels.RECURSIVE_LABEL, sourceVertex = ruleName, targetVertex = leftRecursiveRuleName, edge = _edge.default.fromLabelSourceVertexAndTargetVertex(label, sourceVertex, targetVertex), matches = (0, _directedGraph.edgesMatchEdge)(edges, edge);
        if (!matches) {
          edges.push(edge);
        }
        const recursiveRule = ruleMap[recursiveRuleName] || null;
        if (recursiveRule !== null) {
          const rule2 = recursiveRule;
          edgesFromRule(rule2, edges, vertexes, ruleMap, ruleNamesMap);
        }
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/reduced.js
  var require_reduced2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReducedRule;
      }
    });
    var _occamparsers = require_lib4();
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced());
    var _directedGraph = require_directedGraph();
    var _cycle = require_cycle2();
    var _ruleName = require_ruleName7();
    var _leftRecursive = require_leftRecursive();
    var _directedGraph1 = require_directedGraph2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ReducedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _reduced.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles, ruleMap) {
        const ruleName = rule.getName();
        let reducedRule = null, definitions = rule.getDefinitions();
        definitions = definitions.filter((definition) => {
          const definitionLeftReducible = isDefinitionReducible(definition, ruleName, cycles, ruleMap);
          if (definitionLeftReducible) {
            return true;
          }
        });
        const definitionsLength = definitions.length;
        if (definitionsLength > 0) {
          const ruleName2 = rule.getName(), reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName2), name = reducedRuleName, opacity = rule.getOpacity();
          reducedRule = new ReducedRule(name, opacity, definitions);
        }
        return reducedRule;
      }
    };
    function isDefinitionReducible(definition, ruleName, cycles, ruleMap) {
      const leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromDefinition)(definition, ruleMap), definitionReducible = leftRecursiveRuleNames.every((leftRecursiveRuleName) => {
        const cyclesIncludeRuleNameAndLeftRecursiveRuleName = cycles.some((cycle) => {
          const cycleIncludesRuleNameAndLeftRecursiveRuleName = doesCycleIncludeRuleNameAndLeftRecursiveRuleName(cycle, ruleName, leftRecursiveRuleName);
          if (cycleIncludesRuleNameAndLeftRecursiveRuleName) {
            return true;
          }
        });
        if (!cyclesIncludeRuleNameAndLeftRecursiveRuleName) {
          return true;
        }
      });
      return definitionReducible;
    }
    function doesCycleIncludeRuleNameAndLeftRecursiveRuleName(cycle, ruleName, leftRecursiveRuleName) {
      const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), edge = (0, _directedGraph1.edgeFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), edges = (0, _directedGraph1.edgesFromRuleNames)(ruleNames), matches = (0, _directedGraph.edgesMatchEdge)(edges, edge), cycleIncludesRuleNameAndLeftRecursiveRuleName = matches;
      return cycleIncludesRuleNameAndLeftRecursiveRuleName;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createReducedRules.js
  var require_createReducedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createReducedRules;
      }
    });
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced2());
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createReducedRules(cycles, ruleMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], reducedRule = _reduced.default.fromRuleAndCycles(rule, cycles, ruleMap);
        if (reducedRule !== null) {
          const reducedRuleName = reducedRule.getName();
          ruleMap[reducedRuleName] = reducedRule;
        }
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/precedence.js
  var require_precedence4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isNonTerminalNodeUnprecedented", {
      enumerable: true,
      get: function() {
        return isNonTerminalNodeUnprecedented;
      }
    });
    function isNonTerminalNodeUnprecedented(nonTerminalNode) {
      let nonTerminalNodeUnprecedented;
      const childNonTerminalNodeUnprecedented = nonTerminalNode.someChildNode((childNode) => {
        const childNodeNonTerminalNode = childNode.isNonTerminalNode();
        if (childNodeNonTerminalNode) {
          const childNonTerminalNode = childNode, childNonTerminalNodeUnprecedented2 = isNonTerminalNodeUnprecedented(childNonTerminalNode);
          if (childNonTerminalNodeUnprecedented2) {
            return true;
          }
        }
      });
      if (childNonTerminalNodeUnprecedented) {
        nonTerminalNodeUnprecedented = true;
      } else {
        const precedence = nonTerminalNode.getPrecedence();
        if (precedence !== null) {
          const ruleName = nonTerminalNode.getRuleName();
          nonTerminalNodeUnprecedented = nonTerminalNode.someChildNode((childNode) => {
            const childNodeLowerPrecedence = childNode.isLowerPrecedence(ruleName, precedence);
            if (childNodeLowerPrecedence) {
              return true;
            }
          });
        }
      }
      return nonTerminalNodeUnprecedented;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/repeated/directly.js
  var require_directly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedNode;
      }
    });
    var _occamparsers = require_lib4();
    var _rewrite = require_rewrite();
    var DirectlyRepeatedNode = class extends _occamparsers.NonTerminalNode {
      rewrite(state) {
        const nonTerminalNode = this.clone();
        (0, _rewrite.rewriteDirectlyRepeatedNodes)(nonTerminalNode, state);
        return nonTerminalNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(DirectlyRepeatedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/node/repeated/indirectly.js
  var require_indirectly = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return IndirectlyRepeatedNode;
      }
    });
    var _occamparsers = require_lib4();
    var IndirectlyRepeatedNode = class extends _occamparsers.NonTerminalNode {
      isNullary() {
        let nullary = false;
        const singular = this.isSingular();
        if (singular) {
          nullary = this.everyChildNode((childNode) => {
            if (childNode instanceof _occamparsers.EpsilonNode) {
              return true;
            }
          });
        }
        return nullary;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(IndirectlyRepeatedNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/rewrite.js
  var require_rewrite = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get rewriteDirectlyRepeatedNodes() {
        return rewriteDirectlyRepeatedNodes;
      },
      get rewriteIndirectlyRepeatedNodes() {
        return rewriteIndirectlyRepeatedNodes;
      },
      get rewriteReducedNodes() {
        return rewriteReducedNodes;
      }
    });
    var _necessary = require_browser();
    var _reduced = /* @__PURE__ */ _interop_require_default(require_reduced());
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly());
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly());
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {push} = _necessary.arrayUtilities;
    function rewriteReducedNodes(nonTerminalNode, state) {
      let reducedChildNode;
      const firstChildNodeReducedNode = nonTerminalNode.someChildNode((childNode, index) => {
        if (index === 0) {
          if (childNode instanceof _reduced.default) {
            reducedChildNode = childNode;
            return true;
          }
        }
      });
      if (!firstChildNodeReducedNode) {
        return;
      }
      const parentNode = nonTerminalNode, replacedChildNode = reducedChildNode, replacedChildNodeOpacity = replacedChildNode.getOpacity(), replacedChildNodeRuleName = replacedChildNode.getRuleName(), replacedChildNodePrecedence = replacedChildNode.getPrecedence(), replacedChildNodeChildNodes = replacedChildNode.removeChildNodes(), parentNodeRuleName = parentNode.getRuleName(), reducedRuleName = replacedChildNodeRuleName, parentRuleName = parentNodeRuleName, precedence = replacedChildNodePrecedence, opacity = replacedChildNodeOpacity, ruleName = (0, _ruleName.ruleNameFromReducedRuleName)(reducedRuleName);
      let replacementChildNodes;
      if (ruleName === parentRuleName) {
        replacementChildNodes = replacedChildNodeChildNodes;
        parentNode.setPrecedence(precedence);
      } else {
        const childNodes = replacedChildNodeChildNodes, NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName), nonTerminalNode2 = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), replacementChildNode = nonTerminalNode2;
        replacementChildNodes = [
          replacementChildNode
        ];
      }
      parentNode.replaceChildNode(replacedChildNode, replacementChildNodes);
    }
    function rewriteDirectlyRepeatedNodes(nonTerminalNode, state) {
      let directlyRepeatedNodesReplaced;
      directlyRepeatedNodesReplaced = replaceDirectlyRepeatedNodes(nonTerminalNode);
      while (directlyRepeatedNodesReplaced) {
        directlyRepeatedNodesReplaced = replaceDirectlyRepeatedNodes(nonTerminalNode);
      }
    }
    function rewriteIndirectlyRepeatedNodes(nonTerminalNode, state) {
      let parentNode = nonTerminalNode;
      const indirectlyRepeatedNodes = findIndirectlyRepeatedNodes(nonTerminalNode);
      indirectlyRepeatedNodes.forEach((indirectlyRepeatedNode) => {
        const leftRecursiveNode = leftRecursiveNodeFromParentNodeAndIndirectlyRepeatedNode(parentNode, indirectlyRepeatedNode, state), childNodes = childNodesFromLeftRecursiveNodeNodeAndIndirectlyRepeatedNode(leftRecursiveNode, indirectlyRepeatedNode);
        adjustParentNodePrecedence(parentNode, indirectlyRepeatedNode);
        parentNode.setChildNodes(childNodes);
        parentNode = leftRecursiveNode;
      });
      return parentNode;
    }
    function findRepeatedNodes(nonTerminalNode, RepeatedNode) {
      let repeatedNodes;
      let endIndex = -1;
      nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
        const childNodeRepeatedNode = childNode instanceof RepeatedNode;
        if (childNodeRepeatedNode) {
          endIndex = index + 1;
          return true;
        }
      });
      if (endIndex === -1) {
        repeatedNodes = [];
      } else {
        let startIndex;
        nonTerminalNode.backwardsSomeChildNode((childNode, index) => {
          const childNodeRepeatedNode = childNode instanceof RepeatedNode;
          if (!childNodeRepeatedNode) {
            if (index < endIndex) {
              return true;
            }
          }
          startIndex = index;
        });
        const childNodes = nonTerminalNode.sliceChildNodes(startIndex, endIndex);
        repeatedNodes = childNodes;
      }
      return repeatedNodes;
    }
    function removeFrontChildNodes(parentNode) {
      const multiplicity = parentNode.getMultiplicity(), deleteCount = multiplicity - 1, start = 0, removedFrontChildNodes = parentNode.spliceChildNodes(start, deleteCount);
      return removedFrontChildNodes;
    }
    function findDirectlyRepeatedNodes(nonTerminalNode) {
      const directlyRepeatedNodes = findRepeatedNodes(nonTerminalNode, _directly.default);
      return directlyRepeatedNodes;
    }
    function findIndirectlyRepeatedNodes(nonTerminalNode) {
      const indirectlyRepeatedNodes = findRepeatedNodes(nonTerminalNode, _indirectly.default);
      indirectlyRepeatedNodes.reverse();
      return indirectlyRepeatedNodes;
    }
    function replaceDirectlyRepeatedNodes(nonTerminalNode) {
      let directlyRepeatedNodesReplaced = false;
      const directlyRepeatedNodes = findDirectlyRepeatedNodes(nonTerminalNode), directlyRepeatedNodesLength = directlyRepeatedNodes.length;
      if (directlyRepeatedNodesLength > 0) {
        const parentNode = nonTerminalNode, replacedChildNodes = directlyRepeatedNodes, replacementChildNodes = [];
        directlyRepeatedNodes.forEach((directlyRepeatedNode) => {
          const directlyRepeatedNodesChildNodes = directlyRepeatedNode.removeChildNodes();
          push(replacementChildNodes, directlyRepeatedNodesChildNodes);
        });
        parentNode.replaceChildNodes(replacedChildNodes, replacementChildNodes);
        directlyRepeatedNodesReplaced = true;
      }
      return directlyRepeatedNodesReplaced;
    }
    function adjustParentNodePrecedence(parentNode, indirectlyRepeatedNode) {
      const indirectlyRepeatedNodeRuleName = indirectlyRepeatedNode.getRuleName(), indirectlyRepeatedRuleName = indirectlyRepeatedNodeRuleName, parentNodeNodeRuleName = parentNode.getRuleName(), ruleName = (0, _ruleName.ruleNameFromIndirectlyRepeatedRuleName)(indirectlyRepeatedRuleName);
      if (parentNodeNodeRuleName === ruleName) {
        const precedence = indirectlyRepeatedNode.getPrecedence();
        parentNode.setPrecedence(precedence);
      }
    }
    function leftRecursiveNodeFromParentNodeAndIndirectlyRepeatedNode(parentNode, indirectlyRepeatedNode, state) {
      const indirectlyRepeatedNodeRuleName = indirectlyRepeatedNode.getRuleName(), indirectlyRepeatedNodeOpacity = indirectlyRepeatedNode.getOpacity(), indirectlyRepeatedRuleName = indirectlyRepeatedNodeRuleName, removedFrontChildNodes = removeFrontChildNodes(parentNode), leftRecursiveRuleName = (0, _ruleName.leftRecursiveRuleNameFromIndirectlyRepeatedRuleName)(indirectlyRepeatedRuleName), ruleName = leftRecursiveRuleName, childNodes = removedFrontChildNodes, opacity = indirectlyRepeatedNodeOpacity, precedence = null, NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName), nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence), leftRecursiveNode = nonTerminalNode;
      return leftRecursiveNode;
    }
    function childNodesFromLeftRecursiveNodeNodeAndIndirectlyRepeatedNode(leftRecursiveNode, indirectlyRepeatedNode) {
      const childNodes = [
        leftRecursiveNode
      ], indirectlyRepeatedNodeNullary = indirectlyRepeatedNode.isNullary();
      if (!indirectlyRepeatedNodeNullary) {
        const removedChildNodes = indirectlyRepeatedNode.removeChildNodes();
        push(childNodes, removedChildNodes);
      }
      return childNodes;
    }
  });

  // node_modules/occam-grammar-utilities/lib/node/rewritten.js
  var require_rewritten = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenNode;
      }
    });
    var _occamparsers = require_lib4();
    var _precedence = require_precedence4();
    var _rewrite = require_rewrite();
    var RewrittenNode = class extends _occamparsers.NonTerminalNode {
      rewrite(state) {
        let nonTerminalNode;
        const ruleName = this.getRuleName(), NonTerminalNode = state.NonTerminalNodeFromRuleName(ruleName);
        nonTerminalNode = this.clone();
        const opacity = nonTerminalNode.getOpacity(), childNodes = nonTerminalNode.getChildNodes(), precedence = nonTerminalNode.getPrecedence();
        nonTerminalNode = NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence);
        (0, _rewrite.rewriteDirectlyRepeatedNodes)(nonTerminalNode, state);
        const parentNode = (0, _rewrite.rewriteIndirectlyRepeatedNodes)(nonTerminalNode, state);
        {
          const nonTerminalNode2 = parentNode;
          (0, _rewrite.rewriteReducedNodes)(nonTerminalNode2, state);
        }
        return nonTerminalNode;
      }
      isUnprecedented() {
        const nonTerminalNode = this, nonTerminalNodeUnprecedented = (0, _precedence.isNonTerminalNodeUnprecedented)(nonTerminalNode), unprecedented = nonTerminalNodeUnprecedented;
        return unprecedented;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(RewrittenNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/ruleNames.js
  var require_ruleNames4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get forEachRuleNameAndLeftRecursiveRuleName() {
        return forEachRuleNameAndLeftRecursiveRuleName;
      },
      get permuteRuleNames() {
        return permuteRuleNames;
      }
    });
    function permuteRuleNames(ruleNames, ruleName) {
      let start, end;
      const index = ruleNames.indexOf(ruleName);
      start = 0;
      end = index;
      const leadingRuleNames = ruleNames.slice(start, end);
      start = index;
      const trailingRuleNames = ruleNames.slice(start), permutedRuleNames = [
        ...trailingRuleNames,
        ...leadingRuleNames
      ];
      return permutedRuleNames;
    }
    function forEachRuleNameAndLeftRecursiveRuleName(ruleNames, callback) {
      const ruleNamesLength = ruleNames.length, lastIndex = ruleNamesLength - 1;
      ruleNames.forEach((ruleName, index) => {
        const nextIndex = index === lastIndex ? 0 : index + 1, leftRecursiveRuleName = ruleNames[nextIndex];
        callback(ruleName, leftRecursiveRuleName, index);
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/part.js
  var require_part3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ruleNamePartFromRuleName() {
        return ruleNamePartFromRuleName;
      },
      get zeroOrMorePartsPartFromPart() {
        return zeroOrMorePartsPartFromPart;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePart, ZeroOrMorePartsPart} = _occamparsers.Parts;
    function ruleNamePartFromRuleName(ruleName) {
      const ruleNamePart = RuleNamePart.fromRuleName(ruleName);
      return ruleNamePart;
    }
    function zeroOrMorePartsPartFromPart(part) {
      const zeroOrMorePartsPart = ZeroOrMorePartsPart.fromPart(part);
      return zeroOrMorePartsPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/path.js
  var require_path3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get arePathsEqual() {
        return arePathsEqual;
      },
      get differenceFromPaths() {
        return differenceFromPaths;
      },
      get pathsFromRuleNameAndCycles() {
        return pathsFromRuleNameAndCycles;
      },
      get reducedRuleNameFromPath() {
        return reducedRuleNameFromPath;
      },
      get reducedRuleNamePartFromPath() {
        return reducedRuleNamePartFromPath;
      }
    });
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames4();
    var _cycle = require_cycle2();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var {last, match, compress} = _necessary.arrayUtilities;
    function arePathsEqual(pathA, pathB) {
      const ruleNamesA = pathA, ruleNamesB = pathB, ruleNamesMatch = match(ruleNamesA, ruleNamesB, (ruleNameA, ruleNameB) => {
        if (ruleNameA === ruleNameB) {
          return true;
        }
      }), pathsEqual = ruleNamesMatch;
      return pathsEqual;
    }
    function differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap) {
      let difference;
      const pathALength = pathA.length, pathBLength = pathB.length;
      if (false) {
      } else if (pathALength === 1) {
        difference = -1;
      } else if (pathBLength === 1) {
        difference = 1;
      } else if (pathALength === 0 && pathBLength === 0) {
        difference = 0;
      } else if (pathALength === 0) {
        difference = 1;
      } else if (pathBLength === 0) {
        difference = -1;
      } else {
        const ruleNamesA = pathA.slice(), ruleNamesB = pathB.slice(), ruleNameA = ruleNamesA.shift(), ruleNameB = ruleNamesB.shift();
        if (ruleNameA === ruleNameB) {
          pathA = ruleNamesA;
          pathB = ruleNamesB;
          ruleName = ruleNameA;
          difference = differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap);
        } else {
          const ruleNames = ruleNamesMap[ruleName], indexA = ruleNames.indexOf(ruleNameA), indexB = ruleNames.indexOf(ruleNameB);
          difference = indexA - indexB;
        }
      }
      return difference;
    }
    function reducedRuleNameFromPath(path) {
      const ruleNames = path, lastRuleName = last(ruleNames), ruleName = lastRuleName, reducedRuleName = (0, _ruleName.reducedRuleNameFromRuleName)(ruleName);
      return reducedRuleName;
    }
    function pathsFromRuleNameAndCycles(ruleName, cycles, ruleMap, ruleNamesMap) {
      const paths = cycles.reduce((paths2, cycle) => {
        const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
        if (ruleNamesIncludesRuleName) {
          const permutedRuleNames = (0, _ruleNames.permuteRuleNames)(ruleNames, ruleName), path = permutedRuleNames;
          paths2.push(path);
        }
        return paths2;
      }, []);
      let length;
      paths.forEach((path) => {
        length = path.length;
        while (length > 1) {
          path = path.slice();
          path.pop();
          paths.push(path);
          length = path.length;
        }
      });
      compress(paths, (pathA, pathB) => {
        const pathsEqual = arePathsEqual(pathA, pathB);
        if (!pathsEqual) {
          return true;
        }
      });
      ruleName = null;
      paths.sort((pathA, pathB) => {
        const difference = differenceFromPaths(pathA, pathB, ruleName, ruleMap, ruleNamesMap);
        return difference;
      });
      return paths;
    }
    function reducedRuleNamePartFromPath(path) {
      const reducedRuleName = reducedRuleNameFromPath(path), reducedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(reducedRuleName);
      return reducedRuleNamePart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/definition/rewritten.js
  var require_rewritten2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var _ruleNames = require_ruleNames4();
    var _path = require_path3();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var {first: first2} = _necessary.arrayUtilities;
    var RewrittenDefinition = class extends _occamparsers.Definition {
      static fromPath(path, ruleMap) {
        let rewrittenDefinition = null;
        const reducedRuleName = (0, _path.reducedRuleNameFromPath)(path), reducedRule = ruleMap[reducedRuleName] || null;
        if (reducedRule !== null) {
          rewrittenDefinition = rewrittenDefinitionFromPath(path);
        }
        return rewrittenDefinition;
      }
    };
    function reversePath(path) {
      const reversedPath = path.slice();
      reversedPath.reverse();
      return reversedPath;
    }
    function rewrittenDefinitionFromPath(path) {
      const reducedRuleNamePart = (0, _path.reducedRuleNamePartFromPath)(path), reversedPath = reversePath(path), ruleNames = reversedPath, ruleNamesLength = ruleNames.length, lastIndex = ruleNamesLength - 1, parts = [];
      parts.push(reducedRuleNamePart);
      (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName, index) => {
        if (index < lastIndex) {
          const directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
          parts.push(directlyRepeatedPart);
          const temporaryRuleName = leftRecursiveRuleName;
          leftRecursiveRuleName = ruleName;
          ruleName = temporaryRuleName;
          const indirectlyRepeatedPart = indirectlyRepeatedPartFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName);
          parts.push(indirectlyRepeatedPart);
        }
      });
      if (ruleNamesLength === 1) {
        const firstRuleName = first2(ruleNames), ruleName = firstRuleName, directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
        parts.push(directlyRepeatedPart);
      }
      const precedence = null, rewrittenDefinition = new RewrittenDefinition(parts, precedence);
      return rewrittenDefinition;
    }
    function directlyRepeatedPartFromRuleName(ruleName) {
      const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), directlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(directlyRepeatedRuleName), zeroOrMoreDirectlyRepeatedRuleNamePartsPart = (0, _part.zeroOrMorePartsPartFromPart)(directlyRepeatedRuleNamePart), directlyRepeatedPart = zeroOrMoreDirectlyRepeatedRuleNamePartsPart;
      return directlyRepeatedPart;
    }
    function indirectlyRepeatedPartFromRuleNameAndLeftRecursiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), indirectlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(indirectlyRepeatedRuleName), indirectlyRepeatedPart = indirectlyRepeatedRuleNamePart;
      return indirectlyRepeatedPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/rewritten.js
  var require_rewritten3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RewrittenRule;
      }
    });
    var _occamparsers = require_lib4();
    var _rewritten = /* @__PURE__ */ _interop_require_default(require_rewritten());
    var _rewritten1 = /* @__PURE__ */ _interop_require_default(require_rewritten2());
    var _path = require_path3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RewrittenRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _rewritten.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles, ruleMap, ruleNamesMap) {
        const definitions = [], ruleName = rule.getName(), paths = (0, _path.pathsFromRuleNameAndCycles)(ruleName, cycles, ruleMap, ruleNamesMap);
        paths.forEach((path) => {
          const rewrittenDefinition = _rewritten1.default.fromPath(path, ruleMap);
          if (rewrittenDefinition !== null) {
            const definition = rewrittenDefinition;
            definitions.push(definition);
          }
        });
        const name = ruleName, opacity = rule.getOpacity(), rewrittenRule = new RewrittenRule(name, opacity, definitions);
        return rewrittenRule;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/definition/repeated/directly.js
  var require_directly2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var _cycle = require_cycle2();
    var _ruleNames = require_ruleNames4();
    var _part = require_part3();
    var _ruleName = require_ruleName7();
    var DirectlyRepeatedDefinition = class extends _occamparsers.Definition {
      static fromRuleAndCycle(rule, cycle) {
        let directlyRepeatedDefinition = null;
        const ruleName = rule.getName(), ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle), ruleNameIncludesRuleName = ruleNames.includes(ruleName);
        if (ruleNameIncludesRuleName) {
          const permutedRuleNames = (0, _ruleNames.permuteRuleNames)(ruleNames, ruleName), path = permutedRuleNames, parts = partsFromPath(path), precedence = null;
          directlyRepeatedDefinition = new DirectlyRepeatedDefinition(parts, precedence);
        }
        return directlyRepeatedDefinition;
      }
    };
    function permutePath(path) {
      const permutedPath = path.slice();
      permutedPath.reverse();
      const ruleName = permutedPath.pop();
      permutedPath.unshift(ruleName);
      return permutedPath;
    }
    function partsFromPath(path) {
      const permutedPath = permutePath(path), ruleNames = permutedPath, parts = [];
      (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName) => {
        const temporaryRuleName = leftRecursiveRuleName;
        leftRecursiveRuleName = ruleName;
        ruleName = temporaryRuleName;
        const indirectlyRepeatedPart = indirectlyRepeatedPartFromRuleNameAndLeftReucrsiveRuleName(ruleName, leftRecursiveRuleName), directlyRepeatedPart = directlyRepeatedPartFromRuleName(ruleName);
        parts.push(indirectlyRepeatedPart);
        parts.push(directlyRepeatedPart);
      });
      parts.pop();
      return parts;
    }
    function directlyRepeatedPartFromRuleName(ruleName) {
      const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), directlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(directlyRepeatedRuleName), zeroOrMoreDirectlyRepeatedRuleNamePartsPart = (0, _part.zeroOrMorePartsPartFromPart)(directlyRepeatedRuleNamePart), directlyRepeatedPart = zeroOrMoreDirectlyRepeatedRuleNamePartsPart;
      return directlyRepeatedPart;
    }
    function indirectlyRepeatedPartFromRuleNameAndLeftReucrsiveRuleName(ruleName, leftRecursiveRuleName) {
      const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), indirectlyRepeatedRuleNamePart = (0, _part.ruleNamePartFromRuleName)(indirectlyRepeatedRuleName), indirectlyRepeatedPart = indirectlyRepeatedRuleNamePart;
      return indirectlyRepeatedPart;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/repeated/directly.js
  var require_directly3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DirectlyRepeatedRule;
      }
    });
    var _occamparsers = require_lib4();
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly());
    var _directly1 = /* @__PURE__ */ _interop_require_default(require_directly2());
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var DirectlyRepeatedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _directly.default;
        return NonTerminalNode;
      }
      static fromRuleAndCycles(rule, cycles) {
        const ruleName = rule.getName(), definitions = [];
        cycles.map((cycle) => {
          const directlyRepeatedDefinition = _directly1.default.fromRuleAndCycle(rule, cycle);
          if (directlyRepeatedDefinition !== null) {
            const definition = directlyRepeatedDefinition;
            definitions.push(definition);
          }
        });
        const directlyRepeatedRuleName = (0, _ruleName.directlyRepeatedRuleNameFromRuleName)(ruleName), name = directlyRepeatedRuleName, opacity = rule.getOpacity(), directlyRepeatedRule = new DirectlyRepeatedRule(name, opacity, definitions);
        return directlyRepeatedRule;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/rewriteLeftRecursiveRules.js
  var require_rewriteLeftRecursiveRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return rewriteLeftRecursiveRules;
      }
    });
    var _necessary = require_browser();
    var _rewritten = /* @__PURE__ */ _interop_require_default(require_rewritten3());
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly3());
    var _nonConsuming = require_nonConsuming();
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {filter} = _necessary.arrayUtilities;
    function rewriteLeftRecursiveRules(cycles, ruleMap, ruleNamesMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        let rule = ruleMap[ruleName];
        const rewrittenRule = _rewritten.default.fromRuleAndCycles(rule, cycles, ruleMap, ruleNamesMap);
        rule = rewrittenRule;
        ruleMap[ruleName] = rule;
      });
      const directlyRepeatedRules = rulesFromRule(_directly.default, ruleMap);
      directlyRepeatedRules.forEach((directlyRepeatedRule) => {
        const directlyRepeatedRuleNonConsuming = (0, _nonConsuming.isRuleNonConsuming)(directlyRepeatedRule, ruleMap);
        if (directlyRepeatedRuleNonConsuming) {
          const directlyRepeatedRuleName = directlyRepeatedRule.getName();
          throw new Error(`The directly repeated '${directlyRepeatedRuleName}' rule is non-consuming.`);
        }
      });
      ruleNames.forEach((ruleName) => {
        const ruleCycles = (0, _cycle.ruleCyclesFromRuleNameAndCycles)(ruleName, cycles), ruleCyclesIrreducible = ruleCycles.every((ruleCycle) => {
          const ruleCycleIrreducible = (0, _cycle.isCycleIrreducible)(ruleCycle, ruleMap);
          if (ruleCycleIrreducible) {
            return true;
          }
        });
        if (ruleCyclesIrreducible) {
          throw new Error(`None of the cycles including the '${ruleName}' rule have a reduced rule.`);
        }
      });
    }
    function rulesFromRule(Rule, ruleMap) {
      const rules = Object.values(ruleMap);
      filter(rules, (rule) => {
        const ruleRule = rule instanceof Rule;
        if (ruleRule) {
          return true;
        }
      });
      return rules;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createDirectlyRepeatedRules.js
  var require_createDirectlyRepeatedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createDirectlyRepeatedRules;
      }
    });
    var _directly = /* @__PURE__ */ _interop_require_default(require_directly3());
    var _cycle = require_cycle2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createDirectlyRepeatedRules(cycles, ruleMap) {
      const ruleNames = (0, _cycle.ruleNamesFromCycles)(cycles);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], directlyRepeatedRule = _directly.default.fromRuleAndCycles(rule, cycles, ruleMap), directlyRepeatedRuleName = directlyRepeatedRule.getName();
        ruleMap[directlyRepeatedRuleName] = directlyRepeatedRule;
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/definition/epsilon.js
  var require_epsilon5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EpsilonDefinition;
      }
    });
    var _occamparsers = require_lib4();
    var {EpsilonPart} = _occamparsers.Parts;
    var EpsilonDefinition = class extends _occamparsers.Definition {
      static fromPrecedence(precedence) {
        const epsilonPart = EpsilonPart.fromNothing(), parts = [
          epsilonPart
        ], epsilonDefinition = EpsilonDefinition.fromPartsAndPrecedence(parts, precedence);
        return epsilonDefinition;
      }
    };
  });

  // node_modules/occam-grammar-utilities/lib/utilities/parts.js
  var require_parts2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "arePartsEqual", {
      enumerable: true,
      get: function() {
        return arePartsEqual;
      }
    });
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    function arePartsEqual(parts) {
      const firstPart = first2(parts), firstPartString = firstPart.asString(), partsEqual = parts.every((part) => {
        const partString = part.asString(), partStringFirstPartString = partString === firstPartString;
        if (partStringFirstPartString) {
          return true;
        }
      });
      return partsEqual;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/nonProducing.js
  var require_nonProducing = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isRuleNonProducing", {
      enumerable: true,
      get: function() {
        return isRuleNonProducing;
      }
    });
    var _occamparsers = require_lib4();
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType, SequenceOfPartsPartType} = _occamparsers.partTypes;
    function isRuleNonProducing(rule, ruleMap, ruleNames = []) {
      let ruleNonProducing = false;
      const ruleName = rule.getName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
      if (!ruleNamesIncludesRuleName) {
        ruleNames = [
          ...ruleNames,
          ruleName
        ];
        const definitions = rule.getDefinitions(), definitionsNonProducing = areDefinitionsNonProducing(definitions, ruleMap, ruleNames);
        ruleNonProducing = definitionsNonProducing;
      }
      return ruleNonProducing;
    }
    function areDefinitionsNonProducing(definitions, ruleMap, ruleNames) {
      const definitionsNonProducing = definitions.every((definition) => {
        const definitionNonProducing = isDefinitionNonProducing(definition, ruleMap, ruleNames);
        if (definitionNonProducing) {
          return true;
        }
      });
      return definitionsNonProducing;
    }
    function isDefinitionNonProducing(definition, ruleMap, ruleNames) {
      const parts = definition.getParts(), partsNonProducing = arePartsNonProducing(parts, ruleMap, ruleNames), definitionNonProducing = partsNonProducing;
      return definitionNonProducing;
    }
    function arePartsNonProducing(parts, ruleMap, ruleNames) {
      const partsNonProducing = parts.every((part) => {
        const partNonProducing = isPartNonProducing(part, ruleMap, ruleNames);
        if (partNonProducing) {
          return true;
        }
      });
      return partsNonProducing;
    }
    function isPartNonProducing(part, ruleMap, ruleNames) {
      let partNonProducing;
      const parTerminalPart = part.isTerminalPart();
      if (parTerminalPart) {
        const terminalPart = part, terminalPartUseless = isTerminalPartNonProducing(terminalPart);
        partNonProducing = terminalPartUseless;
      } else {
        const nonTerminalNPart = part, nonTerminalPartNonProducing = isNonTerminalPartNonProducing(nonTerminalNPart, ruleMap, ruleNames);
        partNonProducing = nonTerminalPartNonProducing;
      }
      return partNonProducing;
    }
    function isTerminalPartNonProducing(terminalPart) {
      const terminalPartNonProducing = false;
      return terminalPartNonProducing;
    }
    function isNonTerminalPartNonProducing(nonTerminalPart, ruleMap, ruleNames) {
      let partNonProducing = false;
      const type = nonTerminalPart.getType();
      switch (type) {
        case RuleNamePartType: {
          const ruleNamePart = nonTerminalPart, ruleName = ruleNamePart.getRuleName(), rule = ruleMap[ruleName] || null;
          if (rule !== null) {
            const ruleNonProducing = isRuleNonProducing(rule, ruleMap, ruleNames);
            partNonProducing = ruleNonProducing;
          }
          break;
        }
        case OptionalPartPartType: {
          partNonProducing = true;
          break;
        }
        case OneOrMorePartsPartType: {
          const oneOrMorePartsPart = nonTerminalPart, part = oneOrMorePartsPart.getPart();
          partNonProducing = isPartNonProducing(part, ruleMap, ruleNames);
          break;
        }
        case ZeroOrMorePartsPartType: {
          partNonProducing = true;
          break;
        }
        case SequenceOfPartsPartType: {
          const sequenceOfPartsPart = nonTerminalPart, parts = sequenceOfPartsPart.getParts(), partsNonProducing = arePartsNonProducing(parts, ruleMap, ruleNames);
          partNonProducing = partsNonProducing;
          break;
        }
        case ChoiceOfPartsPartType: {
          const choiceOfPartsPart = nonTerminalPart, parts = choiceOfPartsPart.getParts(), partsNonProducing = parts.every((part) => {
            const partNonProducing2 = isPartNonProducing(part, ruleMap, ruleNames);
            return partNonProducing2;
          });
          partNonProducing = partsNonProducing;
          break;
        }
      }
      return partNonProducing;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/complex.js
  var require_complex = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionComplex", {
      enumerable: true,
      get: function() {
        return isDefinitionComplex;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    var {RuleNamePartType, OptionalPartPartType, ChoiceOfPartsPartType, OneOrMorePartsPartType, SequenceOfPartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    function isDefinitionComplex(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartComplex = isPartComplex(firstPart), definitionComplex = firstPartComplex;
      return definitionComplex;
    }
    function isPartComplex(part) {
      let partComplex = true;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case RuleNamePartType: {
            partComplex = false;
            break;
          }
          case OptionalPartPartType: {
            const optionalPartPart = nonTerminalPart, part2 = optionalPartPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case OneOrMorePartsPartType: {
            const oneOrMorePartsPart = nonTerminalPart, part2 = oneOrMorePartsPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case ZeroOrMorePartsPartType: {
            const zeroOrMorePartsPart = nonTerminalPart, part2 = zeroOrMorePartsPart.getPart();
            partComplex = isPartComplex(part2);
            break;
          }
          case SequenceOfPartsPartType:
          case ChoiceOfPartsPartType: {
            partComplex = true;
            break;
          }
        }
      }
      return partComplex;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/occluded.js
  var require_occluded = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionOccluded", {
      enumerable: true,
      get: function() {
        return isDefinitionOccluded;
      }
    });
    var _necessary = require_browser();
    var _nonConsuming = require_nonConsuming();
    var {first: first2} = _necessary.arrayUtilities;
    function isDefinitionOccluded(definition, ruleMap, ruleNames = []) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartNonConsuming = (0, _nonConsuming.isPartNonConsuming)(firstPart, ruleMap, ruleNames), definitionOccluded = firstPartNonConsuming;
      return definitionOccluded;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/callAhead.js
  var require_callAhead = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDefinitionCallAhead", {
      enumerable: true,
      get: function() {
        return isDefinitionCallAhead;
      }
    });
    var _necessary = require_browser();
    var {first: first2} = _necessary.arrayUtilities;
    function isDefinitionCallAhead(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartCallAhead = isPartCallAhead(firstPart), definitionCallAhead = firstPartCallAhead;
      return definitionCallAhead;
    }
    function isPartCallAhead(part) {
      let partCallAhead = false;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, nonTerminalPartRuleNamePart = nonTerminalPart.isRuleNamePart();
        if (nonTerminalPartRuleNamePart) {
          const ruleNamePart = nonTerminalPart, callAhead = ruleNamePart.isCallAhead();
          partCallAhead = callAhead;
        }
      }
      return partCallAhead;
    }
  });

  // node_modules/occam-grammar-utilities/lib/utilities/qualified.js
  var require_qualified = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isDefinitionQualified() {
        return isDefinitionQualified;
      },
      get isPartQualified() {
        return isPartQualified;
      }
    });
    var _occamparsers = require_lib4();
    var _necessary = require_browser();
    var {OptionalPartPartType, OneOrMorePartsPartType, ZeroOrMorePartsPartType} = _occamparsers.partTypes;
    var {first: first2} = _necessary.arrayUtilities;
    function isPartQualified(part) {
      let partQualified = false;
      const partNonTerminalPart = part.isNonTerminalPart();
      if (partNonTerminalPart) {
        const nonTerminalPart = part, type = nonTerminalPart.getType();
        switch (type) {
          case OptionalPartPartType:
          case OneOrMorePartsPartType:
          case ZeroOrMorePartsPartType: {
            partQualified = true;
            break;
          }
        }
      }
      return partQualified;
    }
    function isDefinitionQualified(definition) {
      const parts = definition.getParts(), firstPart = first2(parts), firstPartQualified = isPartQualified(firstPart), definitionQualified = firstPartQualified;
      return definitionQualified;
    }
  });

  // node_modules/occam-grammar-utilities/lib/rule/repeated/indirectly.js
  var require_indirectly2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return IndirectlyRepeatedRule;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var _epsilon = /* @__PURE__ */ _interop_require_default(require_epsilon5());
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly());
    var _parts = require_parts2();
    var _nonProducing = require_nonProducing();
    var _complex = require_complex();
    var _occluded = require_occluded();
    var _callAhead = require_callAhead();
    var _qualified = require_qualified();
    var _ruleName = require_ruleName7();
    var _leftRecursive = require_leftRecursive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var IndirectlyRepeatedRule = class extends _occamparsers.Rule {
      NonTerminalNodeFromRuleName(ruleName, state) {
        const NonTerminalNode = _indirectly.default;
        return NonTerminalNode;
      }
      static fromRuleAndLeftRecursiveRule(rule, leftRecursiveRule, ruleMap) {
        let definitions = rule.getDefinitions();
        const leftRecursiveRuleName = leftRecursiveRule.getName();
        let leftRecursiveDefinitions = definitions.filter((definition) => {
          const definitionLeftRecursive = (0, _leftRecursive.isDefinitionLeftRecursive)(definition, ruleMap);
          if (definitionLeftRecursive) {
            const leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromDefinition)(definition, ruleMap), firstLeftRecursiveRuleName = first2(leftRecursiveRuleNames);
            if (firstLeftRecursiveRuleName === leftRecursiveRuleName) {
              const ruleName2 = rule.getName(), definitionString = definition.asString();
              const definitionComplex = (0, _complex.isDefinitionComplex)(definition);
              if (definitionComplex) {
                throw new Error(`The '${definitionString}' left recursive-definition of the '${ruleName2}' rule is complex.`);
              }
              const definitionOccluded = (0, _occluded.isDefinitionOccluded)(definition, ruleMap);
              if (definitionOccluded) {
                const definitionString2 = definition.asString();
                throw new Error(`The '${definitionString2}' left recursive definition of the '${ruleName2}' rule is occluded.`);
              }
              const definitionCallAhead = (0, _callAhead.isDefinitionCallAhead)(definition);
              if (definitionCallAhead) {
                throw new Error(`The first part of the '${definitionString}' left recursive definition of the '${ruleName2}' rule is look-ahead.`);
              }
              const definitionQualified = (0, _qualified.isDefinitionQualified)(definition);
              if (definitionQualified) {
                throw new Error(`The first part of the '${definitionString}' left recursive definition of the '${ruleName2}' rule is qualified.`);
              }
              return true;
            }
          }
        });
        const firstPartsEqual = areFirstPartsEqual(leftRecursiveDefinitions);
        if (!firstPartsEqual) {
          const ruleName2 = rule.getName();
          throw new Error(`The first parts of the '${leftRecursiveRuleName}' left recursive definitions in the '${ruleName2}' rule are not equal.`);
        }
        let precedence = null;
        leftRecursiveDefinitions = leftRecursiveDefinitions.filter((leftRecursiveDefinition) => {
          const parts = leftRecursiveDefinition.getParts(), partsLength = parts.length;
          if (partsLength === 1) {
            precedence = leftRecursiveDefinition.getPrecedence();
          } else {
            return true;
          }
        });
        const ruleName = rule.getName(), leftRecursiveRuleOpacity = leftRecursiveRule.getOpacity(), indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName), name = indirectlyRepeatedRuleName, opacity = leftRecursiveRuleOpacity;
        definitions = definitionsFromLeftRecursiveDefinitions(leftRecursiveDefinitions);
        const indirectlyRepeatedRule = new IndirectlyRepeatedRule(name, opacity, definitions), indirectlyRepeatedRuleNonProducing = (0, _nonProducing.isRuleNonProducing)(indirectlyRepeatedRule, ruleMap);
        if (indirectlyRepeatedRuleNonProducing) {
          const epsilonDefinition = _epsilon.default.fromPrecedence(precedence);
          definitions.push(epsilonDefinition);
        }
        return indirectlyRepeatedRule;
      }
    };
    function areFirstPartsEqual(definitions) {
      const firstParts = definitions.map((definition) => {
        const parts = definition.getParts(), firstPart = first2(parts);
        return firstPart;
      }), firstPartsEqual = (0, _parts.arePartsEqual)(firstParts);
      return firstPartsEqual;
    }
    function definitionsFromLeftRecursiveDefinitions(leftRecursiveDefinitions) {
      const definitions = leftRecursiveDefinitions.map((leftRecursiveDefinition) => {
        let parts = leftRecursiveDefinition.getParts();
        parts = [
          ...parts
        ];
        parts.shift();
        const precedence = leftRecursiveDefinition.getPrecedence(), definition = _occamparsers.Definition.fromPartsAndPrecedence(parts, precedence);
        return definition;
      });
      return definitions;
    }
  });

  // node_modules/occam-grammar-utilities/lib/createIndirectlyRepeatedRules.js
  var require_createIndirectlyRepeatedRules = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return createIndirectlyRepeatedRules;
      }
    });
    var _indirectly = /* @__PURE__ */ _interop_require_default(require_indirectly2());
    var _cycle = require_cycle2();
    var _ruleNames = require_ruleNames4();
    var _ruleName = require_ruleName7();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function createIndirectlyRepeatedRules(cycles, ruleMap) {
      cycles.forEach((cycle) => {
        const ruleNames = (0, _cycle.ruleNamesFromCycle)(cycle);
        (0, _ruleNames.forEachRuleNameAndLeftRecursiveRuleName)(ruleNames, (ruleName, leftRecursiveRuleName) => {
          const indirectlyRepeatedRuleName = (0, _ruleName.indirectlyRepeatedRuleNameFromRuleNameAndLeftRecursiveRuleName)(ruleName, leftRecursiveRuleName);
          let indirectlyRepeatedRule = ruleMap[indirectlyRepeatedRuleName] || null;
          if (indirectlyRepeatedRule === null) {
            const rule = ruleMap[ruleName], leftRecursiveRule = ruleMap[leftRecursiveRuleName];
            indirectlyRepeatedRule = _indirectly.default.fromRuleAndLeftRecursiveRule(rule, leftRecursiveRule, ruleMap);
            ruleMap[indirectlyRepeatedRuleName] = indirectlyRepeatedRule;
          }
        });
      });
    }
  });

  // node_modules/occam-grammar-utilities/lib/eliminateLeftRecursion.js
  var require_eliminateLeftRecursion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return eliminateLeftRecursion;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var _directedGraph = /* @__PURE__ */ _interop_require_default(require_directedGraph());
    var _createReducedRules = /* @__PURE__ */ _interop_require_default(require_createReducedRules());
    var _rewriteLeftRecursiveRules = /* @__PURE__ */ _interop_require_default(require_rewriteLeftRecursiveRules());
    var _createDirectlyRepeatedRules = /* @__PURE__ */ _interop_require_default(require_createDirectlyRepeatedRules());
    var _createIndirectlyRepeatedRules = /* @__PURE__ */ _interop_require_default(require_createIndirectlyRepeatedRules());
    var _directedGraph1 = require_directedGraph2();
    var _labels = require_labels();
    var _leftRecursive = require_leftRecursive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {filter} = _necessary.arrayUtilities;
    var {ruleMapFromRules, startRuleFromRules, rulesFromStartRuleAndRuleMap} = _occamparsers.rulesUtilities;
    function eliminateLeftRecursion(rules) {
      const ruleMap = ruleMapFromRules(rules), startRule = startRuleFromRules(rules), ruleNamesMap = ruleNamesMapFromNothing(ruleMap), cycles = cyclesFromStartRule(startRule, ruleMap, ruleNamesMap);
      (0, _createReducedRules.default)(cycles, ruleMap);
      (0, _createIndirectlyRepeatedRules.default)(cycles, ruleMap);
      (0, _createDirectlyRepeatedRules.default)(cycles, ruleMap);
      (0, _rewriteLeftRecursiveRules.default)(cycles, ruleMap, ruleNamesMap);
      rules = rulesFromStartRuleAndRuleMap(startRule, ruleMap);
      return rules;
    }
    function directedGraphFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const startRuleName = startRule.getName(), edges = (0, _directedGraph1.edgesFromStartRule)(startRule, ruleMap, ruleNamesMap), startVertex = startRuleName, directedGraph = _directedGraph.default.fromEdgesAndStartVertex(edges, startVertex);
      return directedGraph;
    }
    function ruleNamesMapFromNothing(ruleMap) {
      const ruleNamesMap = {}, ruleNames = Object.keys(ruleMap);
      ruleNames.forEach((ruleName) => {
        const rule = ruleMap[ruleName], leftRecursiveRuleNames = (0, _leftRecursive.leftRecursiveRuleNamesFromRule)(rule, ruleMap), ruleNames2 = leftRecursiveRuleNames;
        ruleNamesMap[ruleName] = ruleNames2;
      });
      return ruleNamesMap;
    }
    function isCycleLeftRecursive(cycle) {
      const cycleLeftRecursive = cycle.everyEdge((edge) => {
        const label = edge.getLabel(), labelLeftRecursiveLabel = label === _labels.LEFT_RECURSIVE_LABEL, edgeLeftRecursive = labelLeftRecursiveLabel;
        if (edgeLeftRecursive) {
          return true;
        }
      });
      return cycleLeftRecursive;
    }
    function cyclesFromStartRule(startRule, ruleMap, ruleNamesMap) {
      const directedGraph = directedGraphFromStartRule(startRule, ruleMap, ruleNamesMap), cycles = directedGraph.findCycles();
      filter(cycles, (cycle) => {
        const cycleLeftRecursive = isCycleLeftRecursive(cycle);
        if (cycleLeftRecursive) {
          return true;
        }
      });
      return cycles;
    }
  });

  // node_modules/occam-grammar-utilities/lib/index.js
  var require_lib10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ExampleLexer() {
        return _example.default;
      },
      get ExampleParser() {
        return _example1.default;
      },
      get eliminateLeftRecursion() {
        return _eliminateLeftRecursion.default;
      }
    });
    var _example = /* @__PURE__ */ _interop_require_default(require_example());
    var _example1 = /* @__PURE__ */ _interop_require_default(require_example2());
    var _eliminateLeftRecursion = /* @__PURE__ */ _interop_require_default(require_eliminateLeftRecursion());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/query.js
  var require_query3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
  });

  // node_modules/occam-grammars/lib/teX/entries.js
  var require_entries5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\$\\$|\\$|\\\\\\(|\\\\\\)|\\\\\\[|\\\\\\])"
      },
      {
        unassigned: "^(?:.+?(?=\\$\\$|\\$|\\\\\\(|\\\\\\)|\\\\\\[|\\\\\\])|.+)"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/teX/lexer.js
  var require_lexer7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TeXLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries5());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _TeXLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_TeXLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_TeXLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_TeXLexer, entries);
      }
    };
    var TeXLexer = _TeXLexer;
    __publicField(TeXLexer, "entries", _entries.default);
    __publicField(TeXLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(TeXLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(TeXLexer, "EndOfLineCommentToken", null);
    __publicField(TeXLexer, "SingleLineCommentToken", null);
    __publicField(TeXLexer, "RegularExpressionToken", null);
    __publicField(TeXLexer, "EndOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "StartOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(TeXLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(TeXLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/json/entries.js
  var require_entries6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:,|:|\\{|\\}|\\[|\\])"
      },
      {
        number: "^-?[1-9][0-9]*(\\.[0-9]+)?"
      },
      {
        boolean: "^(?:true|false)"
      },
      {
        null: "^(?:null)"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/json/lexer.js
  var require_lexer8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return JSONLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries6());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _JSONLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_JSONLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_JSONLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_JSONLexer, entries);
      }
    };
    var JSONLexer = _JSONLexer;
    __publicField(JSONLexer, "entries", _entries.default);
    __publicField(JSONLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(JSONLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(JSONLexer, "EndOfLineCommentToken", null);
    __publicField(JSONLexer, "SingleLineCommentToken", null);
    __publicField(JSONLexer, "RegularExpressionToken", null);
    __publicField(JSONLexer, "EndOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "StartOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(JSONLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(JSONLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/furtle/entries.js
  var require_entries7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var LATIN = "[\\p{Script=Latin}]";
    var DECIMAL = "[0-9]";
    var entries = [
      {
        type: "^(?:Nodes|Node|String|Number|Boolean)"
      },
      {
        query: "^(?:nodeQuery|nodesQuery)"
      },
      {
        "primary-keyword": "^return"
      },
      {
        "secondary-keyword": "^(?:if|else|reduce|every|some|as)"
      },
      {
        null: "^null"
      },
      {
        boolean: "^(?:true|false)"
      },
      {
        bracket: "^(?:\\{|\\})"
      },
      {
        special: "^(?:!=|==|!|=|,|;|_|&&|\\|\\||\\(|\\)|\\[|\\])"
      },
      {
        name: `^${LATIN}+${DECIMAL}*`
      },
      {
        number: `^${DECIMAL}+`
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/furtle/lexer.js
  var require_lexer9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _FurtleLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_FurtleLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_FurtleLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_FurtleLexer, entries);
      }
    };
    var FurtleLexer = _FurtleLexer;
    __publicField(FurtleLexer, "entries", _entries.default);
    __publicField(FurtleLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(FurtleLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(FurtleLexer, "RegularExpressionToken", null);
    __publicField(FurtleLexer, "EndOfLineCommentToken", _occamlexers.EndOfLineCommentNonSignificantToken);
    __publicField(FurtleLexer, "SingleLineCommentToken", _occamlexers.PythonStyleSingleLineCommentToken);
    __publicField(FurtleLexer, "EndOfMultiLineCommentToken", _occamlexers.PythonStyleEndOfMultiLineCommentToken);
    __publicField(FurtleLexer, "StartOfMultiLineCommentToken", _occamlexers.PythonStyleStartOfMultiLineCommentToken);
    __publicField(FurtleLexer, "MiddleOfMultiLineCommentToken", _occamlexers.PythonStyleMiddleOfMultiLineCommentToken);
    __publicField(FurtleLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(FurtleLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/nominal/entries.js
  var require_entries8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var GREEK = "[\\p{Script=Greek}]";
    var LATIN = "[\\p{Script=Latin}]";
    var DECIMAL = "[0-9]";
    var LATIN_LOWER_CASE = "[\\p{Script=Latin}&&\\p{Lowercase}]";
    var LATIN_UPPER_CASE = "[\\p{Script=Latin}&&\\p{Uppercase}]";
    var MATHEMATICAL_SANS_SERIF_BOLD = "[\\u{1D5D4}-\\u{1D607}]";
    var MATHEMATICAL_ITALIC_UPPER_CASE = "[\\u{1D434}-\\u{1D44D}]";
    var MATHEMATICAL_SCRIPT_UPPER_CASE = "[\\u{1D49C}\\u{212C}\\u{1D49E}\\u{1D49F}\\u{2130}\\u{2131}\\u{1D4A2}\\u{210B}\\u{2110}\\u{1D4A5}\\u{1D4A6}\\u{2112}\\u{2133}\\u{1D4A9}-\\u{1D4AC}\\u{211B}\\u{1D4AE}-\\u{1D4B5}]";
    var MATHEMATICAL_FRAKTUR_UPPER_CASE = "[\\u{1D504}\\u{1D505}\\u{212D}\\u{1D507}-\\u{1D50A}\\u{210C}\\u{2111}\\u{1D50D}-\\u{1D514}\\u{211C}\\u{1D516}-\\u{1D51C}\\u{2128}]";
    var entries = [
      {
        "primary-keyword": "^(?:Rule|Axiom|Theorem|Lemma|Conjecture|MetaLemma|Metatheorem|Premises|Premise|Conclusion|Proof|Therefore|Suppose|Hence|Then|Provisional|Type|TypePrefix|Properties|Property|Variable|Constructor|Combinator|Metavariable|Given)\\b"
      },
      {
        "secondary-keyword": "^(?:is|in|an|a|of|by|from|because|for|satisfies|provisionally|defined|undefined|missing|present)\\b"
      },
      {
        "meta-type": "^(?:Statement|Reference|Frame)\\b"
      },
      {
        name: `^(?:${LATIN_UPPER_CASE}${LATIN}*${DECIMAL}*|${LATIN_LOWER_CASE}${LATIN}+${DECIMAL}*)`
      },
      {
        identifier: `^(?:${LATIN_LOWER_CASE}${DECIMAL}*|${GREEK}+|${MATHEMATICAL_SANS_SERIF_BOLD}+|${MATHEMATICAL_ITALIC_UPPER_CASE}+|${MATHEMATICAL_SCRIPT_UPPER_CASE}+|${MATHEMATICAL_FRAKTUR_UPPER_CASE}+)`
      },
      {
        primitive: "^(?:\\||\\.\\.\\.|\\(|\\)|\\[|\\]|\\+|-|,|<|>)"
      },
      {
        special: "^(?:@|::|:|=)"
      },
      {
        unassigned: "^[^\\s\\(\\)\\[\\]:,]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/nominal/lexer.js
  var require_lexer10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NominalLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries8());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NominalLexer = class extends _occamlexers.CommonLexer {
    };
    __publicField(NominalLexer, "entries", _entries.default);
    __publicField(NominalLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(NominalLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(NominalLexer, "RegularExpressionToken", null);
    __publicField(NominalLexer, "EndOfLineCommentToken", _occamlexers.EndOfLineCommentSignificantToken);
    __publicField(NominalLexer, "SingleLineCommentToken", _occamlexers.PythonStyleSingleLineCommentToken);
    __publicField(NominalLexer, "EndOfMultiLineCommentToken", _occamlexers.PythonStyleEndOfMultiLineCommentToken);
    __publicField(NominalLexer, "StartOfMultiLineCommentToken", _occamlexers.PythonStyleStartOfMultiLineCommentToken);
    __publicField(NominalLexer, "MiddleOfMultiLineCommentToken", _occamlexers.PythonStyleMiddleOfMultiLineCommentToken);
    __publicField(NominalLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(NominalLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/plainText/entries.js
  var require_entries9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        "alpha-numeric": "^[a-zA-Z0-9]+"
      },
      {
        punctuation: "^[@,\\.\"'`]+"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/plainText/lexer.js
  var require_lexer11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PlainTextLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries9());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PlainTextLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_PlainTextLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_PlainTextLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_PlainTextLexer, entries);
      }
    };
    var PlainTextLexer = _PlainTextLexer;
    __publicField(PlainTextLexer, "entries", _entries.default);
    __publicField(PlainTextLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(PlainTextLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(PlainTextLexer, "EndOfLineCommentToken", null);
    __publicField(PlainTextLexer, "SingleLineCommentToken", null);
    __publicField(PlainTextLexer, "RegularExpressionToken", null);
    __publicField(PlainTextLexer, "EndOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "StartOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(PlainTextLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(PlainTextLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/entries.js
  var require_entries10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        special: "^(?:\\||\\(|\\)|\\?|\\*|\\+|::=|;|<NO_WHITESPACE>|<END_OF_LINE>)"
      },
      {
        number: "^(?:0|[1-9][0-9]*)"
      },
      {
        name: "^[\\w~]+"
      },
      {
        type: "^\\[[^\\]]+\\]"
      },
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/lexer.js
  var require_lexer12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarBNFnLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries10());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarBNFnLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CustomGrammarBNFnLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CustomGrammarBNFnLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CustomGrammarBNFnLexer, entries);
      }
    };
    var CustomGrammarBNFnLexer = _CustomGrammarBNFnLexer;
    __publicField(CustomGrammarBNFnLexer, "entries", _entries.default);
    __publicField(CustomGrammarBNFnLexer, "EndOfLineToken", _occamlexers.EndOfLineNonSignificantToken);
    __publicField(CustomGrammarBNFnLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CustomGrammarBNFnLexer, "EndOfLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "RegularExpressionToken", null);
    __publicField(CustomGrammarBNFnLexer, "SingleLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CustomGrammarBNFnLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CustomGrammarBNFnLexer, "DoublyQuotedStringLiteralToken", _occamlexers.DoublyQuotedStringLiteralToken);
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/entries.js
  var require_entries11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var entries = [
      {
        unassigned: "^[^\\s]+"
      }
    ];
    var _default = entries;
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/lexer.js
  var require_lexer13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarVocabularyLexer;
      }
    });
    var _occamlexers = require_lib3();
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries11());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarVocabularyLexer = class extends _occamlexers.CommonLexer {
      static fromNothing() {
        return _occamlexers.CommonLexer.fromNothing(_CustomGrammarVocabularyLexer);
      }
      static fromRules(rules) {
        return _occamlexers.CommonLexer.fromRules(_CustomGrammarVocabularyLexer, rules);
      }
      static fromEntries(entries) {
        return _occamlexers.CommonLexer.fromEntries(_CustomGrammarVocabularyLexer, entries);
      }
    };
    var CustomGrammarVocabularyLexer = _CustomGrammarVocabularyLexer;
    __publicField(CustomGrammarVocabularyLexer, "entries", _entries.default);
    __publicField(CustomGrammarVocabularyLexer, "EndOfLineToken", _occamlexers.EndOfLineSignificantToken);
    __publicField(CustomGrammarVocabularyLexer, "WhitespaceToken", _occamlexers.WhitespaceToken);
    __publicField(CustomGrammarVocabularyLexer, "EndOfLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "SingleLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "RegularExpressionToken", null);
    __publicField(CustomGrammarVocabularyLexer, "EndOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "StartOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "MiddleOfMultiLineCommentToken", null);
    __publicField(CustomGrammarVocabularyLexer, "SinglyQuotedStringLiteralToken", null);
    __publicField(CustomGrammarVocabularyLexer, "DoublyQuotedStringLiteralToken", null);
  });

  // node_modules/occam-grammars/lib/teX/bnf.js
  var require_bnf6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document                        ::=   ( delimitedTeX | plainMarkup )+ ;
    
    
    
    delimitedTeX                    ::=   dollarDelimiter inlineTeX dollarDelimiter 
    
                                      |   doubleDollarDelimiter displayTeX doubleDollarDelimiter 
    
                                      |   openingBracketDelimiter inlineTeX closingBracketDelimiter 
    
                                      |   openingSquareBracketDelimiter displayTeX closingSquareBracketDelimiter 
                                      
                                      ;
    

    
    inlineTeX                       ::=   [unassigned]* ;

    displayTeX                      ::=   [unassigned]* ;



    dollarDelimiter                 ::=   "$" ;
 
    doubleDollarDelimiter           ::=   "$$" ;
    

    
    openingBracketDelimiter         ::=   "\\(" ;

    closingBracketDelimiter         ::=   "\\)" ;

    openingSquareBracketDelimiter   ::=   "\\[" ;
    
    closingSquareBracketDelimiter   ::=   "\\]" ;
    
    
    
    plainMarkup                     ::=   . ;


`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/teX/parser.js
  var require_parser8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TeXParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf6());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _TeXParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_TeXParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_TeXParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_TeXParser, rules);
      }
    };
    var TeXParser = _TeXParser;
    __publicField(TeXParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/json/bnf.js
  var require_bnf7 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document     ::=  json error* 
    
                   |  error+ 
                                 
                   ;
  
  
  
    json         ::=  array 
    
                   |  object 
    
                   |  [string-literal] 
    
                   |  [boolean] 
    
                   |  [number] 
    
                   |  [null] 
    
                   ;
  
  
  
    array..      ::=  "[" ( element ( "," element )* )? nonsense? "]" ;
  
  
     
    object..     ::=  "{" ( property ( "," property )* )? nonsense? "}" ;
  
  
    
    property     ::=  [string-literal] ":" json ;
  
    

    element      ::=  json ;
  
    

    nonsense.    ::=  ( ":" | "," | [string-literal] | [number] | [boolean] | [null] | [unassigned] )+ ;
    


    error.       ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/json/parser.js
  var require_parser9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return JSONParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _JSONParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_JSONParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_JSONParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_JSONParser, rules);
      }
    };
    var JSONParser = _JSONParser;
    __publicField(JSONParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/furtle/bnf.js
  var require_bnf8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document                ::=  ( procedureDeclaration | error )+ ;
    
    
    
    procedureDeclaration    ::=  [type] label<NO_WHITESPACE>"(" parameters? ")" returnBlock ;
    
    anonymousProcedure      ::=  [type] "(" parameters? ")" returnBlock ;
    
    returnStatement         ::=  "return" term ";" ; 
    
    
    
    step                    ::=  arrayAssignment
                              
                              |  objectAssignment
                              
                              |  variableAssignments
     
                              ;  
      
      
    
    arrayAssignment         ::=  "[" parameters "]" "=" variable ";" ;
    
    objectAssignment        ::=  "{" namedParameters "}" "=" variable ";" ;
    
    variableAssignments     ::=  [type] variableAssignment ( "," variableAssignment )* ";" ;
    
    variableAssignment      ::=  variable "=" expression ;
    


    namedParameters         ::=  namedParameter ( "," namedParameter )* ;
    
    parameters              ::=  parameter ( "," parameter )* ;
    
    terms                   ::=  term ( "," term )* ;
    


    namedParameter          ::=  [type] [name] ( "as" [name] )? ;   
    
    parameter               ::=  [type] [name]
    
                              |  "_" 
    
                              ;


    
    procedureCall           ::=  reference<NO_WHITESPACE>"(" terms? ")" ;
    
    returnBlock..           ::=  "{" ( step | nonsense )* returnStatement "}" ;
                                     
    nodesQuery              ::=  "nodesQuery"<NO_WHITESPACE>"(" variable "," [string-literal] ")" ;
    
    nodeQuery               ::=  "nodeQuery"<NO_WHITESPACE>"(" variable "," [string-literal] ")" ;
    
    ternary                 ::=  "if" "(" term ")" expression "else" expression ;
    
    reduce                  ::=  "reduce"<NO_WHITESPACE>"(" variable "," anonymousProcedure "," expression ")" ;
    
    every                   ::=  "every"<NO_WHITESPACE>"(" variable "," anonymousProcedure ")" ;
    
    some                    ::=  "some"<NO_WHITESPACE>"(" variable "," anonymousProcedure ")" ;
    
    
    
    comparisonTerm          ::=  term ( "==" | "!=" ) term ; 
    
    bracketedTerm           ::=  "(" term ")" ; 
    
    negatedTerm             ::=  "!"<NO_WHITESPACE>term ; 
    
    logicalTerm             ::=  term ( "||" | "&&" ) term ; 


    
    expression              ::=  procedureCall
     
                              |  returnBlock
    
                              |  nodesQuery
                              
                              |  nodeQuery
                              
                              |  ternary
                              
                              |  reduce
    
                              |  every
    
                              |  some
                             
                              |  term
                              
                              ;
    
    
    
    term                    ::=  comparisonTerm 
    
                              |  bracketedTerm 
    
                              |  logicalTerm 
    
                              |  negatedTerm 
    
                              |  primitive 
    
                              |  variable 
                              
                              ;


    
    primitive               ::=  [string-literal]
                              
                              |  [boolean]
                              
                              |  [number] 
                              
                              |  [null]
                             
                              ;



    reference.              ::=  [name] ;
    
    variable                ::=  [name] ;
    
    label.                  ::=  [name] ;
    
    
    
    nonsense.               ::=  [secondary-keyword] | [type] | [null] | [boolean] | [string-literal] | [query] | [special] | [name] | [number] | [unassigned] ;


    
    error.                  ::=  . ;
    
`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/furtle/parser.js
  var require_parser10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf8());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _FurtleParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_FurtleParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_FurtleParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_FurtleParser, rules);
      }
    };
    var FurtleParser = _FurtleParser;
    __publicField(FurtleParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/nominal/bnf.js
  var require_bnf9 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `document                             ::=  ( variableDeclaration 
                                           
                                          | combinatorDeclaration 
                                                          
                                          | constructorDeclaration 
                                                          
                                          | metavariableDeclaration 
                                                          
                                          | typePrefixDeclaration  
                                                                                                     
                                          | simpleTypeDeclaration 
                                                          
                                          | complexTypeDeclaration 
                                                      
                                          | rule 
               
                                          | axiom 
               
                                          | lemma 
               
                                          | theorem 
               
                                          | conjecture 
               
                                          | metaLemma 
               
                                          | metatheorem  
                                                      
                                          | section 
                                                      
                                          | verticalSpace 
                                                      
                                          | error )+ ;



section                              ::=  "Given" <END_OF_LINE>

                                          hypothesis+
                                          
                                          <END_OF_LINE>
                                          
                                          ( axiom 
                                          
                                          | lemma 
                                          
                                          | theorem 
                                          
                                          | conjecture ) ; 



verticalSpace                        ::=  <END_OF_LINE>+ ;



error.                               ::=  . ;



variableDeclaration                  ::=  "Variable" variable ( ":" type "provisionally"? )? <END_OF_LINE> ;
 
combinatorDeclaration                ::=  "Combinator" combinator... <END_OF_LINE> ;
 
constructorDeclaration               ::=  "Constructor" constructor... ( ":" type "provisionally"? )? <END_OF_LINE> ;
 
metavariableDeclaration              ::=  "Metavariable" metavariable... ":" metaType <END_OF_LINE> ;
 
typePrefixDeclaration                ::=  "TypePrefix" typePrefix <END_OF_LINE> ;

simpleTypeDeclaration                ::=  "Provisional"? "Type" type ( ":" types )? <END_OF_LINE> ;
 
complexTypeDeclaration               ::=  "Provisional"? "Type" <END_OF_LINE> 

                                          type ( ":" types )? <END_OF_LINE>
                                          
                                          (
                                          
                                            ( "Properties" <END_OF_LINE> propertyDeclaration propertyDeclaration+ ) 
                                             
                                            | 
                                             
                                            ( "Property" <END_OF_LINE> propertyDeclaration ) 
                                             
                                          );
  

  
rule                                 ::=  ruleHeader ruleBody ;                                         

metaLemma                            ::=  metaLemmaHeader metaLemmaBody ;

metatheorem                          ::=  metatheoremHeader metatheoremBody ;

axiom                                ::=  axiomHeader axiomBody ;

lemma                                ::=  lemmaHeader lemmaBody ;

theorem                              ::=  theoremHeader theoremBody ;

conjecture                           ::=  conjectureHeader conjectureBody ;



ruleHeader                          ::=  "Rule" parenthesisedLabels... <END_OF_LINE> ; 

metaLemmaHeader                     ::=  "MetaLemma" parenthesisedLabel... <END_OF_LINE> | "MetaLemma" <END_OF_LINE> ;

metatheoremHeader                   ::=  "Metatheorem" parenthesisedLabel... <END_OF_LINE> ; 

axiomHeader                         ::=  "Axiom" signature? parenthesisedLabels... <END_OF_LINE> ; 

lemmaHeader                         ::=  "Lemma" parenthesisedLabels... <END_OF_LINE> | "Lemma" <END_OF_LINE> ; 

theoremHeader                       ::=  "Theorem" parenthesisedLabels... <END_OF_LINE> ; 

conjectureHeader                    ::=  "Conjecture" parenthesisedLabels... <END_OF_LINE> ;



ruleBody                             ::=  ( 

                                            ( "Premises" <END_OF_LINE> premise premise+ ) 
                                             
                                            | 
                                             
                                            ( "Premise" <END_OF_LINE> premise ) 
                                             
                                          )?
                                             
                                          "Conclusion" <END_OF_LINE> conclusion 
                                           
                                          proof? ;                                         

metaLemmaBody                        ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+ 

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                                                                         
                                          proof ;

metatheoremBody                      ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+ 

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                           
                                          proof ;

axiomBody                            ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+
    
                                            "Then" <END_OF_LINE> 
                                                 
                                          )?
                                                 
                                          deduction ;

lemmaBody                            ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                            
                                          deduction
                                           
                                          proof ;

theoremBody                          ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                             
                                          deduction
                                           
                                          proof ;

conjectureBody                       ::=  (
                                           
                                            "Suppose" <END_OF_LINE> supposition+

                                            "Then" <END_OF_LINE> 
                                             
                                          )?
                                             
                                          deduction
                                           
                                          proof? ;



proof                                ::=  "Proof" <END_OF_LINE> derivation ;

subproof                             ::=  "Suppose" <END_OF_LINE> supposition+ subDerivation ;

derivation                           ::=  ( 

                                            ( step | subproof )+ 
                                            
                                            "Therefore" <END_OF_LINE> 
                                            
                                          )? 
                                          
                                          step ;                                        

subDerivation                        ::=  (

                                            "Hence" <END_OF_LINE>
    
                                            ( step | subproof )+ 
                                                                                         
                                          )? 
                                           
                                          "Then" <END_OF_LINE> 
                                           
                                          step ;                                        



propertyDeclaration.                 ::=  property ( ":" type )? <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;



combinator                           ::=  statement ;

constructor                          ::=  term ; 

 

premise.                             ::=  procedureCall <END_OF_LINE>  

                                       |  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

supposition.                         ::=  procedureCall <END_OF_LINE>  

                                       |  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

conclusion.                          ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

deduction.                           ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;

hypothesis.                          ::=  statement... <END_OF_LINE>  

                                       |  nonsense... <END_OF_LINE>
                                       
                                       ;



step.                                ::=  statement... qualification? <END_OF_LINE>  

                                       |  nonsense... qualification? <END_OF_LINE>
                                       
                                       ;



qualification                        ::=  "because" satisfiesAssertion

                                       |  ( "by" | "from" ) reference
                                       
                                       ; 



parenthesisedLabels                  ::=  "(" labels ")" ; 

parenthesisedLabel                   ::=  "(" label ")" ; 



procedureCall                        ::=  "@"<NO_WHITESPACE>procedureReference<NO_WHITESPACE>"(" parameter ( "," parameter )* ")" ;



signature                            ::=  "[" term ( "," term )* "]" ;



arguments                            ::=  argument ( "," argument )* ;

labels                               ::=  label ( "," label )* ;

types                                ::=  type ( "," type )* ;



argument                             ::=  term ( ) 

                                       |  type ( )
                                       
                                       ;

metaArgument                         ::=  statement ( ) 

                                       |  metaType ( ) 
                                       
                                       ;

frameArgument                        ::=  frame ( ) 

                                       |  metaType ( ) 
                                       
                                       ;


procedureReference.                  ::=  [name] ;

reference.                           ::=  metavariable ;

label.                               ::=  metavariable ;



equivalences                         ::=  equivalence ( "," equivalence )* ;

equivalence                          ::=  "[" term ( "," term )+ "]" ;



metavariable.                        ::=  [name] ( <NO_WHITESPACE>"(" ( term | type | stuff ) ")" )? ;

parameter.                           ::=  [name] | [identifier] ;

variable.                            ::=  [identifier] ;

metaType.                            ::=  [meta-type] ;

property.                            ::=  [name]+ ;

typePrefix.                          ::=  [type] ;

type.                                ::=  [type] ( <NO_WHITESPACE>[type] )? 

                                       |  "<"<NO_WHITESPACE>">"

                                       ;



stuff.                               ::=  ( [string-literal] | [symbol] | [type] | [name] | [identifier] | [primitive] | [unassigned] )+ ;

nonsense.                            ::=  ( [secondary-keyword] | [meta-type] | [special] | [symbol] | [type] | [name] | [identifier] | [primitive] | [unassigned] )+ ;`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/nominal/parser.js
  var require_parser11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NominalParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf9());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NominalParser = class extends _occamparsers.CommonParser {
    };
    __publicField(NominalParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/plainText/bnf.js
  var require_bnf10 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document       ::=  ( block | verticalSpace )+ ;

    block          ::=  endedLine* lastLine 
                          
                     |  endedLine+
                          
                     ;

    lastLine       ::=  ( [alpha-numeric] | [punctuation] | [unassigned] )+ ;

    endedLine      ::=  ( [alpha-numeric] | [punctuation] | [unassigned] )+ <END_OF_LINE> ;

    verticalSpace  ::=  <END_OF_LINE>+ ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/plainText/parser.js
  var require_parser12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PlainTextParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf10());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _PlainTextParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_PlainTextParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_PlainTextParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_PlainTextParser, rules);
      }
    };
    var PlainTextParser = _PlainTextParser;
    __publicField(PlainTextParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/bnf.js
  var require_bnf11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

      document                 ::=  ( rule | error )+ ;

      rule                     ::=  name "::=" definitions ";" ;

      name                     ::=  [name] ;

      definitions              ::=  definition ( "|" definition )* ;

      definition               ::=  part+ precedence? ;
 
      part                     ::=  nonTerminalPart quantifier*

                                 |  terminalPart quantifier*

                                 ;

      nonTerminalPart          ::=  choiceOfParts

                                 |  sequenceOfParts

                                 |  ruleName 

                                 ;

      terminalPart             ::=  significantTokenType
  
                                 |  stringLiteral
  
                                 |  endOfLine
  
                                 |  noWhitespace
                              
                                 ;
                              
      sequenceOfParts          ::=  "(" part part+ ")" ;

      choiceOfParts            ::=  "(" partChoice ( "|" partChoice )+ ")" ;

      partChoice               ::=  part precedence? ;

      ruleName                 ::=  [name] ;

      significantTokenType     ::=  [type] ;

      stringLiteral            ::=  [string-literal] ;

      precedence               ::=  "(" [number]? ")" ;
      
      endOfLine                ::=  "<END_OF_LINE>" ;
      
      noWhitespace             ::=  "<NO_WHITESPACE>" ;                              

      quantifier               ::=  optionalQuantifier
 
                                 |  oneOrMoreQuantifier
  
                                 |  zeroOrMoreQuantifier
  
                                 ;

      optionalQuantifier       ::=  <NO_WHITESPACE>"?" ;

      oneOrMoreQuantifier      ::=  <NO_WHITESPACE>"+" ;

      zeroOrMoreQuantifier     ::=  <NO_WHITESPACE>"*" ;

      error.                   ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/customGrammarBNF/parser.js
  var require_parser13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarBNFParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf11());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarBNFParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CustomGrammarBNFParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CustomGrammarBNFParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CustomGrammarBNFParser, rules);
      }
    };
    var CustomGrammarBNFParser = _CustomGrammarBNFParser;
    __publicField(CustomGrammarBNFParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/bnf.js
  var require_bnf12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var bnf = `

    document       ::=  ( expression | verticalSpace | error )+ ;

    expression     ::=  <NO_WHITESPACE>[unassigned]<NO_WHITESPACE><END_OF_LINE> ;

    verticalSpace  ::=  <END_OF_LINE>+ ;
   
    error.         ::=  . ;

`;
    var _default = bnf;
  });

  // node_modules/occam-grammars/lib/customGrammarVocabulary/parser.js
  var require_parser14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CustomGrammarVocabularyParser;
      }
    });
    var _occamparsers = require_lib4();
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf12());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _CustomGrammarVocabularyParser = class extends _occamparsers.CommonParser {
      static fromNothing() {
        return _occamparsers.CommonParser.fromNothing(_CustomGrammarVocabularyParser);
      }
      static fromBNF(bnf) {
        return _occamparsers.CommonParser.fromBNF(_CustomGrammarVocabularyParser, bnf);
      }
      static fromRules(rules) {
        return _occamparsers.CommonParser.fromRules(_CustomGrammarVocabularyParser, rules);
      }
    };
    var CustomGrammarVocabularyParser = _CustomGrammarVocabularyParser;
    __publicField(CustomGrammarVocabularyParser, "bnf", _bnf.default);
  });

  // node_modules/occam-grammars/lib/index.js
  var require_lib11 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CustomGrammarBNFLexer() {
        return _lexer5.default;
      },
      get CustomGrammarBNFParser() {
        return _parser5.default;
      },
      get CustomGrammarVocabularyLexer() {
        return _lexer6.default;
      },
      get CustomGrammarVocabularyParser() {
        return _parser6.default;
      },
      get FurtleLexer() {
        return _lexer2.default;
      },
      get FurtleParser() {
        return _parser2.default;
      },
      get JSONLexer() {
        return _lexer1.default;
      },
      get JSONParser() {
        return _parser1.default;
      },
      get NominalLexer() {
        return _lexer3.default;
      },
      get NominalParser() {
        return _parser3.default;
      },
      get PlainTextLexer() {
        return _lexer4.default;
      },
      get PlainTextParser() {
        return _parser4.default;
      },
      get TeXLexer() {
        return _lexer.default;
      },
      get TeXParser() {
        return _parser.default;
      }
    });
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer7());
    var _lexer1 = /* @__PURE__ */ _interop_require_default(require_lexer8());
    var _lexer2 = /* @__PURE__ */ _interop_require_default(require_lexer9());
    var _lexer3 = /* @__PURE__ */ _interop_require_default(require_lexer10());
    var _lexer4 = /* @__PURE__ */ _interop_require_default(require_lexer11());
    var _lexer5 = /* @__PURE__ */ _interop_require_default(require_lexer12());
    var _lexer6 = /* @__PURE__ */ _interop_require_default(require_lexer13());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser8());
    var _parser1 = /* @__PURE__ */ _interop_require_default(require_parser9());
    var _parser2 = /* @__PURE__ */ _interop_require_default(require_parser10());
    var _parser3 = /* @__PURE__ */ _interop_require_default(require_parser11());
    var _parser4 = /* @__PURE__ */ _interop_require_default(require_parser12());
    var _parser5 = /* @__PURE__ */ _interop_require_default(require_parser13());
    var _parser6 = /* @__PURE__ */ _interop_require_default(require_parser14());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/grammar.js
  var require_grammar = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get customGrammarBNFLexer() {
        return customGrammarBNFLexer;
      },
      get customGrammarBNFParser() {
        return customGrammarBNFParser;
      },
      get customGrammarVocabularyLexer() {
        return customGrammarVocabularyLexer;
      },
      get customGrammarVocabularyParser() {
        return customGrammarVocabularyParser;
      }
    });
    var _occamgrammars = require_lib11();
    var customGrammarBNFLexer = _occamgrammars.CustomGrammarBNFLexer.fromNothing();
    var customGrammarBNFParser = _occamgrammars.CustomGrammarBNFParser.fromNothing();
    var customGrammarVocabularyLexer = _occamgrammars.CustomGrammarVocabularyLexer.fromNothing();
    var customGrammarVocabularyParser = _occamgrammars.CustomGrammarVocabularyParser.fromNothing();
  });

  // node_modules/occam-custom-grammars/lib/utilities/vocabulary.js
  var require_vocabulary = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "expressionsFromVocabulary", {
      enumerable: true,
      get: function() {
        return expressionsFromVocabulary;
      }
    });
    var _necessary = require_browser();
    var _query = require_query3();
    var _grammar = require_grammar();
    var {second} = _necessary.arrayUtilities;
    var expressionNodesQuery = (0, _query.nodesQuery)("//expression");
    function expressionsFromVocabulary(vocabulary, expressions) {
      const content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
      if (node === null) {
        return;
      }
      const expressionNodes = expressionNodesQuery(node);
      expressionNodes.forEach((expressionNode) => {
        const content2 = contentFromExpressionNode(expressionNode), expression = escape(content2);
        expressions.push(expression);
      });
    }
    function contentFromExpressionNode(expressionNode) {
      const nonTerminalNode = expressionNode, childNodes = nonTerminalNode.getChildNodes(), secondChildNode = second(childNodes), unassignedTerminalNode = secondChildNode, content = unassignedTerminalNode.getContent();
      return content;
    }
    function escape(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/nominal.js
  var require_nominal = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nominalLexer() {
        return nominalLexer;
      },
      get nominalParser() {
        return nominalParser;
      }
    });
    var _occamlexers = require_lib3();
    var _occamparsers = require_lib4();
    var _occamgrammars = require_lib11();
    var nominalLexer = _occamlexers.CommonLexer.fromNothing(_occamgrammars.NominalLexer);
    var nominalParser = _occamparsers.CommonParser.fromNothing(_occamgrammars.NominalParser);
  });

  // node_modules/occam-custom-grammars/lib/typesMap.js
  var require_typesMap = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _nominal = require_nominal();
    var _ruleNames = require_ruleNames3();
    var _constants = require_constants10();
    var {first: first2} = _necessary.arrayUtilities;
    var ruleMap = _nominal.nominalParser.getRuleMap();
    var stuffRule = ruleMap[_constants.STUFF_RULE_NAME];
    var nonsenseRule = ruleMap[_constants.NONSENSE_RULE_NAME];
    var stuffTypes = typesFromRule(stuffRule);
    var nonsenseTypes = typesFromRule(nonsenseRule);
    var termTypes = stuffTypes;
    var statementTypes = nonsenseTypes;
    var typesMap = {
      [_ruleNames.TERM_RULE_NAME]: termTypes,
      [_ruleNames.STATEMENT_RULE_NAME]: statementTypes
    };
    var _default = typesMap;
    function typesFromRule(rule) {
      let parts;
      const definitions = rule.getDefinitions(), firstDDefinition = first2(definitions), definition = firstDDefinition;
      parts = definition.getParts();
      const firstPart = first2(parts), oneOrMorePartsPart = firstPart, part = oneOrMorePartsPart.getPart(), choiceOrPartsPart = part;
      parts = choiceOrPartsPart.getParts();
      const types = parts.map((part2) => {
        const significantTokenTypePart = part2, significantTokenType = significantTokenTypePart.getSignificantTokenType(), type = significantTokenType;
        return type;
      });
      return types;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/validate.js
  var require_validate = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get validateBNF() {
        return validateBNF;
      },
      get validateVocabulary() {
        return validateVocabulary;
      }
    });
    var _necessary = require_browser();
    var _typesMap = /* @__PURE__ */ _interop_require_default(require_typesMap());
    var _nominal = require_nominal();
    var _query = require_query3();
    var _constants = require_constants10();
    var _grammar = require_grammar();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var expressionNodesQuery = (0, _query.nodesQuery)("//expression");
    var ruleNameTerminalNodeQuery = (0, _query.nodeQuery)("/document/rule/name/@*!");
    var unassignedTerminalNodeQuery = (0, _query.nodeQuery)("/expression/@unassigned");
    var stringLiteralTerminalNodesQuery = (0, _query.nodesQuery)("//stringLiteral/@*!");
    var significantTokenTypeTerminalNodesQuery = (0, _query.nodesQuery)("//significantTokenType/@*!");
    function validateBNF(bnf, ruleName) {
      const content = bnf, tokens = _grammar.customGrammarBNFLexer.tokenise(content), node = _grammar.customGrammarBNFParser.parse(tokens);
      if (node === null) {
        return;
      }
      const ruleNameTerminalNode = ruleNameTerminalNodeQuery(node);
      if (ruleNameTerminalNode !== null) {
        const name = nameFromRuleNameTerminalNode(ruleNameTerminalNode);
        if (name !== ruleName) {
          throw new Error(`The '${name}' rule should be named '${ruleName}'.`);
        }
      }
      const types = _typesMap.default[ruleName], significantTokenTypeTerminalNodes = significantTokenTypeTerminalNodesQuery(node);
      significantTokenTypeTerminalNodes.forEach((significantTokenTypeTerminalNode) => {
        const type = typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
          throw new Error(`The '${type}' type is not included in the '${ruleName}' rule's types.`);
        }
      });
      const stringLiteralTerminalNodes = stringLiteralTerminalNodesQuery(node);
      stringLiteralTerminalNodes.forEach((stringLiteralTerminalNode) => {
        const content2 = contentFromStringLiteralTerminalNode(stringLiteralTerminalNode);
        if (content2 === _constants.BASE_TYPE_SYMBOL) {
          throw new Error(`The "${content2}" string literal cannot be the same as the base type symbol.`);
        }
        const tokens2 = _nominal.nominalLexer.tokenise(content2), tokensLength = tokens2.length;
        if (tokensLength !== 1) {
          throw new Error(`Tokenising the "${content2}" string literal does not result in a single token.`);
        }
        const firstToken = first2(tokens2), token = firstToken, type = token.getType(), typesIncludeType = types.includes(type);
        if (!typesIncludeType) {
          throw new Error(`The "${content2}" string literal's token's '${type}' type is not included in the '${ruleName}' rule's types.`);
        }
      });
    }
    function validateVocabulary(vocabulary) {
      const content = vocabulary, tokens = _grammar.customGrammarVocabularyLexer.tokenise(content), node = _grammar.customGrammarVocabularyParser.parse(tokens);
      if (node === null) {
        return;
      }
      const expressionNodes = expressionNodesQuery(node);
      expressionNodes.forEach((expressionNode) => {
        const content2 = contentFromExpressionNode(expressionNode), tokens2 = _nominal.nominalLexer.tokenise(content2), tokensLength = tokens2.length;
        if (tokensLength > 1) {
          throw new Error(`Tokenising the '${content2}' content results in more than one token.`);
        }
        const firstToken = first2(tokens2), token = firstToken, type = token.getType();
        if (type !== _constants.UNASSIGNED_TYPE) {
          throw new Error(`The '${type}' type of the '${content2}' token is not 'unassigned'.`);
        }
        if (content2 === _constants.BASE_TYPE_SYMBOL) {
          throw new Error(`The '${content2}' token cannot be the same as the base type symbol.`);
        }
      });
    }
    function contentFromExpressionNode(expressionNode) {
      let content;
      const unassignedTerminalNode = unassignedTerminalNodeQuery(expressionNode);
      content = unassignedTerminalNode.getContent();
      return content;
      ;
    }
    function nameFromRuleNameTerminalNode(ruleNameTerminalNode) {
      let name;
      const content = ruleNameTerminalNode.getContent();
      name = content;
      return name;
    }
    function contentFromStringLiteralTerminalNode(stringLiteralTerminalNode) {
      let content;
      content = stringLiteralTerminalNode.getContent();
      const matches = content.match(/"([^"]*)"/), secondMatch = second(matches);
      content = secondMatch;
      return content;
    }
    function typeFromSignificantTokenTypeTerminalNode(significantTokenTypeTerminalNode) {
      let type;
      const content = significantTokenTypeTerminalNode.getContent(), matches = content.match(/\[([^\]]*)\]/), secondMatch = second(matches);
      type = secondMatch;
      return type;
    }
  });

  // node_modules/occam-custom-grammars/lib/customGrammar/combined.js
  var require_combined = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return CombinedCustomGrammar;
      }
    });
    var _necessary = require_browser();
    var _occamlexers = require_lib3();
    var _occamparsers = require_lib4();
    var _occamgrammarutilities = require_lib10();
    var _default = /* @__PURE__ */ _interop_require_default(require_default());
    var _vocabulary = require_vocabulary();
    var _constants = require_constants10();
    var _validate = require_validate();
    var _ruleNames = require_ruleNames3();
    var _vocabularyNames = require_vocabularyNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {opaque} = _occamlexers.specialSymbols;
    var {rulesFromBNF} = _occamparsers.parserUtilities;
    var {unshift, forwardsForEach, backwardsForEach} = _necessary.arrayUtilities;
    var CombinedCustomGrammar = class {
      constructor(rules, entries) {
        this.rules = rules;
        this.entries = entries;
      }
      getRules() {
        return this.rules;
      }
      getEntries() {
        return this.entries;
      }
      postProcess(rules) {
        rules = [
          ...rules,
          ...this.rules
        ];
        rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
        return rules;
      }
      static fromNothing(includeDefault = true) {
        let customGrammars = [];
        if (includeDefault) {
          customGrammars = [
            _default.default,
            ...customGrammars
          ];
        }
        const rules = rulesFromCustomGrammars(customGrammars), entries = entriesFromCustomGrammars(customGrammars), combinedCustomGrammar = new CombinedCustomGrammar(rules, entries);
        return combinedCustomGrammar;
      }
      static fromCustomGrammars(customGrammars, includeDefault = true) {
        if (includeDefault) {
          customGrammars = [
            _default.default,
            ...customGrammars
          ];
        }
        const rules = rulesFromCustomGrammars(customGrammars), entries = entriesFromCustomGrammars(customGrammars), combinedCustomGrammar = new CombinedCustomGrammar(rules, entries);
        return combinedCustomGrammar;
      }
    };
    function rulesFromCustomGrammars(customGrammars) {
      const ruleNames = [
        _ruleNames.TERM_RULE_NAME,
        _ruleNames.STATEMENT_RULE_NAME
      ], bnfs = ruleNames.map((ruleName) => {
        const bnf2 = bnfFromCustomGrammars(customGrammars, ruleName);
        return bnf2;
      }), bnf = bnfs.join(_constants.VERTICAL_SPACE), rules = rulesFromBNF(bnf);
      combineRules(rules);
      const opacity = opaque;
      ruleNames.forEach((ruleName) => {
        const rule = rules.find((rule2) => {
          const name = rule2.getName();
          if (name === ruleName) {
            return true;
          }
        });
        rule.setOpacity(opacity);
      });
      return rules;
    }
    function entriesFromCustomGrammars(customGrammars) {
      const vocabularyNames = [
        _vocabularyNames.TYPE_VOCABULARY_NAME,
        _vocabularyNames.SYMBOL_VOCABULARY_NAME
      ], entries = vocabularyNames.map((vocabularyName) => {
        const entry = entryFromCustomGrammars(customGrammars, vocabularyName);
        return entry;
      });
      return entries;
    }
    function entryFromCustomGrammars(customGrammars, vocabularyName) {
      const expressions = [];
      backwardsForEach(customGrammars, (customGrammar) => {
        const vocabulary = customGrammar.getVocabulary(vocabularyName), customGrammarDefaultCustomGrammar = customGrammar.isDefaultCustomGrammar();
        if (!customGrammarDefaultCustomGrammar) {
          (0, _validate.validateVocabulary)(vocabulary);
        }
        (0, _vocabulary.expressionsFromVocabulary)(vocabulary, expressions);
      });
      const pattern = expressions.join(_constants.VERTICAL_BAR), entryName = vocabularyName, entryValue = `^(?:${pattern})`, entry = {
        [entryName]: entryValue
      };
      return entry;
    }
    function bnfFromCustomGrammars(customGrammars, ruleName) {
      const bnfs = [];
      forwardsForEach(customGrammars, (customGrammar) => {
        const bnf2 = customGrammar.getBNF(ruleName), customGrammarDefaultCustomGrammar = customGrammar.isDefaultCustomGrammar();
        if (!customGrammarDefaultCustomGrammar) {
          (0, _validate.validateBNF)(bnf2, ruleName);
        }
        bnfs.push(bnf2);
      });
      const bnf = bnfs.join(_constants.VERTICAL_SPACE);
      return bnf;
    }
    function combineRules(rules) {
      let outerIndex = 0, length = rules.length;
      while (outerIndex < length) {
        const outerRule = rules[outerIndex], outerRuleName = outerRule.getName();
        let innerIndex = outerIndex + 1;
        while (innerIndex < length) {
          const innerRule = rules[innerIndex], innerRuleName = innerRule.getName();
          if (innerRuleName === outerRuleName) {
            const innerRuleDefinitions = innerRule.getDefinitions(), outerRuleDefinitions = outerRule.getDefinitions();
            unshift(outerRuleDefinitions, innerRuleDefinitions);
            const start = innerIndex, deleteCount = 1;
            rules.splice(start, deleteCount);
            length = rules.length;
          } else {
            innerIndex++;
          }
        }
        outerIndex++;
        length = rules.length;
      }
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/lexers.js
  var require_lexers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get lexerFromCombinedCustomGrammar() {
        return lexerFromCombinedCustomGrammar;
      },
      get lexerFromEntriesAndCombinedCustomGrammar() {
        return lexerFromEntriesAndCombinedCustomGrammar;
      },
      get lexerFromNothing() {
        return lexerFromNothing;
      }
    });
    var _occamlexers = require_lib3();
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {lexerFromRules, rulesFromEntries} = _occamlexers.lexerUtilities;
    function lexerFromNothing(Class) {
      const {entries} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    function lexerFromCombinedCustomGrammar(Class, combinedCustomGrammar) {
      const {entries} = Class, rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    function lexerFromEntriesAndCombinedCustomGrammar(Class, entries, combinedCustomGrammar) {
      const rules = rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar), lexer = lexerFromRules(Class, rules);
      return lexer;
    }
    var _default = {
      lexerFromNothing,
      lexerFromCombinedCustomGrammar,
      lexerFromEntriesAndCombinedCustomGrammar
    };
    function rulesFromEntriesAndCombinedCustomGrammar(entries, combinedCustomGrammar) {
      const customGrammarEntries = combinedCustomGrammar.getEntries();
      entries = [
        ...customGrammarEntries,
        ...entries
      ];
      const rules = rulesFromEntries(entries);
      return rules;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/parsers.js
  var require_parsers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get parserFromBNFAndCombinedCustomGrammar() {
        return parserFromBNFAndCombinedCustomGrammar;
      },
      get parserFromBNFStartRuleNameAndCombinedCustomGrammar() {
        return parserFromBNFStartRuleNameAndCombinedCustomGrammar;
      },
      get parserFromCombinedCustomGrammar() {
        return parserFromCombinedCustomGrammar;
      },
      get parserFromNothing() {
        return parserFromNothing;
      },
      get parserFromStartRuleName() {
        return parserFromStartRuleName;
      },
      get parserFromStartRuleNameAndCombinedCustomGrammar() {
        return parserFromStartRuleNameAndCombinedCustomGrammar;
      }
    });
    var _occamparsers = require_lib4();
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {rulesFromBNF, parserFromRules, parserFromRulesAndStartRuleName} = _occamparsers.parserUtilities;
    function parserFromNothing(Class) {
      const {bnf} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromStartRuleName(Class, startRuleName) {
      const {bnf} = Class, combinedCustomGrammar = _combined.default.fromNothing(), rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    function parserFromCombinedCustomGrammar(Class, combinedCustomGrammar) {
      const {bnf} = Class, rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromBNFAndCombinedCustomGrammar(Class, bnf, combinedCustomGrammar) {
      const rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRules(Class, rules);
      return parser;
    }
    function parserFromStartRuleNameAndCombinedCustomGrammar(Class, startRuleName, combinedCustomGrammar) {
      const {bnf} = Class, rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    function parserFromBNFStartRuleNameAndCombinedCustomGrammar(Class, bnf, startRuleName, combinedCustomGrammar) {
      const rules = rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar), parser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return parser;
    }
    var _default = {
      parserFromNothing,
      parserFromStartRuleName,
      parserFromCombinedCustomGrammar,
      parserFromBNFAndCombinedCustomGrammar,
      parserFromStartRuleNameAndCombinedCustomGrammar,
      parserFromBNFStartRuleNameAndCombinedCustomGrammar
    };
    function rulesFromBNFAndCombinedCustomGrammar(bnf, combinedCustomGrammar) {
      let rules = rulesFromBNF(bnf);
      rules = combinedCustomGrammar.postProcess(rules);
      return rules;
    }
  });

  // node_modules/occam-custom-grammars/lib/utilities/customGrammar.js
  var require_customGrammar2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combinedCustomGrammarFromCustomGrammars() {
        return combinedCustomGrammarFromCustomGrammars;
      },
      get combinedCustomGrammarFromJSON() {
        return combinedCustomGrammarFromJSON;
      },
      get combinedCustomGrammarFromNothing() {
        return combinedCustomGrammarFromNothing;
      },
      get default() {
        return _default;
      }
    });
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function combinedCustomGrammarFromJSON(json) {
      const customGrammarsJSON = json, customGrammars = customGrammarsJSON.map((customGrammarJSON) => {
        const json2 = customGrammarJSON, customGrammar = _customGrammar.default.fromJSON(json2);
        return customGrammar;
      });
      customGrammars.reverse();
      const combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    function combinedCustomGrammarFromNothing() {
      const customGrammars = [], combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    function combinedCustomGrammarFromCustomGrammars(customGrammars) {
      customGrammars = [
        ...customGrammars
      ];
      customGrammars.reverse();
      const combinedCustomGrammar = _combined.default.fromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
    var _default = {
      combinedCustomGrammarFromJSON,
      combinedCustomGrammarFromNothing,
      combinedCustomGrammarFromCustomGrammars
    };
  });

  // node_modules/occam-custom-grammars/lib/index.js
  var require_lib12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CombinedCustomGrammar() {
        return _combined.default;
      },
      get CustomGrammar() {
        return _customGrammar.default;
      },
      get DEFAULT_CUSTOM_GRAMMAR_NAME() {
        return _grammarNames.DEFAULT_CUSTOM_GRAMMAR_NAME;
      },
      get customGrammarUtilities() {
        return _customGrammar1.default;
      },
      get defaultCustomGrammar() {
        return _default.default;
      },
      get lexersUtilities() {
        return _lexers.default;
      },
      get parsersUtilities() {
        return _parsers.default;
      },
      get ruleNames() {
        return _ruleNames.default;
      },
      get vocabularyNames() {
        return _vocabularyNames.default;
      }
    });
    var _grammarNames = require_grammarNames();
    var _ruleNames = /* @__PURE__ */ _interop_require_default(require_ruleNames3());
    var _vocabularyNames = /* @__PURE__ */ _interop_require_default(require_vocabularyNames());
    var _customGrammar = /* @__PURE__ */ _interop_require_default(require_customGrammar());
    var _default = /* @__PURE__ */ _interop_require_default(require_default());
    var _combined = /* @__PURE__ */ _interop_require_default(require_combined());
    var _lexers = /* @__PURE__ */ _interop_require_default(require_lexers());
    var _parsers = /* @__PURE__ */ _interop_require_default(require_parsers());
    var _customGrammar1 = /* @__PURE__ */ _interop_require_default(require_customGrammar2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/utilities/customGrammar.js
  var require_customGrammar3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get combinedCustomGrammarFromReleaseContexts() {
        return combinedCustomGrammarFromReleaseContexts;
      },
      get customGrammarFromNameAndEntries() {
        return customGrammarFromNameAndEntries;
      }
    });
    var _occamcustomgrammars = require_lib12();
    var {combinedCustomGrammarFromCustomGrammars} = _occamcustomgrammars.customGrammarUtilities;
    function customGrammarFromNameAndEntries(name, entries) {
      const termBNF = entries.getTermBNF(), statementBNF = entries.getStatementBNF(), typeVocabulary = entries.getTypeVocabulary(), symbolVocabulary = entries.getSymbolVocabulary(), customGrammar = _occamcustomgrammars.CustomGrammar.fromNameTermBNFStatementBNFTypeVocabularyAndSymbolVocabulary(name, termBNF, statementBNF, typeVocabulary, symbolVocabulary);
      return customGrammar;
    }
    function combinedCustomGrammarFromReleaseContexts(releaseContexts) {
      const customGrammars = releaseContexts.map((releaseContext) => {
        const customGrammar = releaseContext.getCustomGrammar();
        return customGrammar;
      });
      const combinedCustomGrammar = combinedCustomGrammarFromCustomGrammars(customGrammars);
      return combinedCustomGrammar;
    }
  });

  // node_modules/occam-languages/lib/utilities/fileContext.js
  var require_fileContext = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get fileContextsFromEntries() {
        return fileContextsFromEntries;
      },
      get fileContextsFromJSON() {
        return fileContextsFromJSON;
      }
    });
    function fileContextsFromJSON(json, fileContexts, releaseContext, FileContextFromFilePath) {
      const fileContextsJSON = json;
      fileContextsJSON.forEach((fileContextJSON) => {
        const {filePath} = fileContextJSON, FileContext = FileContextFromFilePath(filePath);
        if (FileContext !== null) {
          const json2 = fileContextJSON, fileContext = FileContext.fromJSON(json2, releaseContext);
          fileContexts.push(fileContext);
        }
      });
    }
    function fileContextsFromEntries(entries, fileContexts, releaseContext, FileContextFromFilePath) {
      entries.forEachFile((file) => {
        const filePath = file.getPath(), FileContext = FileContextFromFilePath(filePath);
        if (FileContext !== null) {
          const fileContext = FileContext.fromFile(file, releaseContext);
          fileContexts.push(fileContext);
        }
      });
    }
    var _default = {
      fileContextsFromJSON,
      fileContextsFromEntries
    };
  });

  // node_modules/occam-languages/lib/context/release.js
  var require_release = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReleaseContext;
      }
    });
    var _necessary = require_browser();
    var _verify = require_verify();
    var _customGrammar = require_customGrammar3();
    var _fileContext = require_fileContext();
    var _constants = require_constants9();
    var {push, tail, first: first2} = _necessary.arrayUtilities;
    var ReleaseContext = class {
      constructor(log, name, json, entries, callback, customGrammar, verifies, initialised, fileContexts, combinedCustomGrammar, dependencyReleaseContexts) {
        this.log = log;
        this.name = name;
        this.json = json;
        this.entries = entries;
        this.callback = callback;
        this.customGrammar = customGrammar;
        this.verifies = verifies;
        this.initialised = initialised;
        this.fileContexts = fileContexts;
        this.combinedCustomGrammar = combinedCustomGrammar;
        this.dependencyReleaseContexts = dependencyReleaseContexts;
      }
      getLog() {
        return this.log;
      }
      getName() {
        return this.name;
      }
      getJSON() {
        return this.json;
      }
      getEntries() {
        return this.entries;
      }
      getCallback() {
        return this.callback;
      }
      getCustomGrammar() {
        return this.customGrammar;
      }
      getVerifies() {
        return this.verifies;
      }
      isInitialised() {
        return this.initialised;
      }
      getFileContexts() {
        return this.fileContexts;
      }
      getCombinedCustomGrammar() {
        return this.combinedCustomGrammar;
      }
      getDependencyReleaseContexts() {
        return this.dependencyReleaseContexts;
      }
      getReleaseContext() {
        const releaseContext = this;
        return releaseContext;
      }
      getDepth() {
        const depth = 0;
        return depth;
      }
      hasVerified() {
        const verified = this.verifies;
        return verified;
      }
      isReleased() {
        const released = this.json !== null;
        return released;
      }
      getTypePrefix() {
        let typePrefix = null;
        const includeDependencies = false, typePrefixes = this.getTypePrefixes(includeDependencies), typePrefixesLength = typePrefixes.length;
        if (typePrefixesLength === 1) {
          const firstTypePrefix = first2(typePrefixes);
          typePrefix = firstTypePrefix;
        }
        return typePrefix;
      }
      getLabels(includeDependencies = true) {
        const labels = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextLabels = fileContext.getLabels(includeRelease);
          push(labels, fileContextLabels);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextLabels = releaseContext.getLabels(includeDependencies2);
            push(labels, releaseContextLabels);
          });
        }
        return labels;
      }
      getTypes(includeDependencies = true) {
        const types = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTypes = fileContext.getTypes(includeRelease);
          push(types, fileContextTypes);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTypes = releaseContext.getTypes(includeDependencies2);
            push(types, releaseContextTypes);
          });
        }
        return types;
      }
      getRules(includeDependencies = true) {
        const rules = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextRules = fileContext.getRules(includeRelease);
          push(rules, fileContextRules);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextRules = releaseContext.getRules(includeDependencies2);
            push(rules, releaseContextRules);
          });
        }
        return rules;
      }
      getAxioms(includeDependencies = true) {
        const axioms = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextAxioms = fileContext.getAxioms(includeRelease);
          push(axioms, fileContextAxioms);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextAxioms = releaseContext.getAxioms(includeDependencies2);
            push(axioms, releaseContextAxioms);
          });
        }
        return axioms;
      }
      getLemmas(includeDependencies = true) {
        const lemmas = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextLemmas = fileContext.getLemmas(includeRelease);
          push(lemmas, fileContextLemmas);
        });
        return lemmas;
      }
      getTheorems(includeDependencies = true) {
        const theorems = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTheorems = fileContext.getTheorems(includeRelease);
          push(theorems, fileContextTheorems);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTheorems = releaseContext.getTheorems(includeDependencies2);
            push(theorems, releaseContextTheorems);
          });
        }
        return theorems;
      }
      getProcedures(includeDependencies = true) {
        const procedures = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextProcedures = fileContext.getProcedures(includeRelease);
          push(procedures, fileContextProcedures);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextProcedures = releaseContext.getProcedures(includeDependencies2);
            push(procedures, releaseContextProcedures);
          });
        }
        return procedures;
      }
      getMetaLemmas(includeDependencies = true) {
        const metaLemmas = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextMetaLemmas = fileContext.getMetaLemmas(includeRelease);
          push(metaLemmas, fileContextMetaLemmas);
        });
        return metaLemmas;
      }
      getConjectures(includeDependencies = true) {
        const conjectures = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextConjectures = fileContext.getConjectures(includeRelease);
          push(conjectures, fileContextConjectures);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextConjectures = releaseContext.getConjectures(includeDependencies2);
            push(conjectures, releaseContextConjectures);
          });
        }
        return conjectures;
      }
      getCombinators(includeDependencies = true) {
        const combinators = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextCombinators = fileContext.getCombinators(includeRelease);
          push(combinators, fileContextCombinators);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextCombinators = releaseContext.getCombinators(includeDependencies2);
            push(combinators, releaseContextCombinators);
          });
        }
        return combinators;
      }
      getTypePrefixes(includeDependencies = true) {
        const typePrefixes = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextTypePrefixes = fileContext.getTypePrefixes(includeRelease);
          push(typePrefixes, fileContextTypePrefixes);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextTypePrefixes = releaseContext.getTypePrefixes(includeDependencies2);
            push(typePrefixes, releaseContextTypePrefixes);
          });
        }
        return typePrefixes;
      }
      getConstructors(includeDependencies = true) {
        const constructors = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextConstructors = fileContext.getConstructors(includeRelease);
          push(constructors, fileContextConstructors);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextConstructors = releaseContext.getConstructors(includeDependencies2);
            push(constructors, releaseContextConstructors);
          });
        }
        return constructors;
      }
      getMetatheorems(includeDependencies = true) {
        const metatheorems = [];
        this.fileContexts.forEach((fileContext) => {
          const includeRelease = false, fileContextMetatheorems = fileContext.getMetatheorems(includeRelease);
          push(metatheorems, fileContextMetatheorems);
        });
        if (includeDependencies) {
          this.dependencyReleaseContexts.forEach((releaseContext) => {
            const includeDependencies2 = false, releaseContextMetatheorems = releaseContext.getMetatheorems(includeDependencies2);
            push(metatheorems, releaseContextMetatheorems);
          });
        }
        return metatheorems;
      }
      getDependencies() {
        return this.entries.getDependencies();
      }
      matchShortenedVersion(shortenedVersion) {
        return this.entries.matchShortenedVersion(shortenedVersion);
      }
      findFile(filePath) {
        return this.entries.findFile(filePath);
      }
      findFileContext(filePath) {
        const fileContext = this.fileContexts.find((fileContext2) => {
          const filePathMatches = fileContext2.matchFilePath(filePath);
          if (filePathMatches) {
            return true;
          }
        }) || null;
        return fileContext;
      }
      trace(message) {
        const level = _constants.TRACE_LEVEL;
        this.writeToLog(level, message);
      }
      debug(message) {
        const level = _constants.DEBUG_LEVEL;
        this.writeToLog(level, message);
      }
      info(message) {
        const level = _constants.INFO_LEVEL;
        this.writeToLog(level, message);
      }
      warning(message) {
        const level = _constants.WARNING_LEVEL;
        this.writeToLog(level, message);
      }
      error(message) {
        const level = _constants.ERROR_LEVEL;
        this.writeToLog(level, message);
      }
      writeToLog(level, message, filePath = null, lineIndex = null) {
        this.log.write(level, message, filePath, lineIndex);
      }
      initialise(releaseContexts, FileContextFromFilePath) {
        const released = this.isReleased(), releaseContext = this, releaseContextsTail = tail(releaseContexts);
        this.dependencyReleaseContexts = releaseContextsTail;
        this.combinedCustomGrammar = (0, _customGrammar.combinedCustomGrammarFromReleaseContexts)(releaseContexts);
        released ? (0, _fileContext.fileContextsFromJSON)(this.json, this.fileContexts, releaseContext, FileContextFromFilePath) : (0, _fileContext.fileContextsFromEntries)(this.entries, this.fileContexts, releaseContext, FileContextFromFilePath);
        this.initialised = true;
      }
      async break(filePath, lineIndex) {
        const level = _constants.TRACE_LEVEL, message = _constants.BREAK_MESSAGE;
        this.writeToLog(level, message, filePath, lineIndex);
        const context2 = this;
        await this.callback(context2, filePath, lineIndex);
      }
      async verify() {
        let verifies = false;
        const typePrefixes = this.getTypePrefixes(), releaseContext = this, typePrefixesVerify = (0, _verify.verifyTypePrefixes)(typePrefixes, releaseContext);
        if (typePrefixesVerify) {
          const verifiedFileContexts = [], fileContextsVerify = await (0, _verify.verifyFileContexts)(this.fileContexts, verifiedFileContexts);
          if (fileContextsVerify) {
            verifies = true;
            this.verifies = verifies;
            this.fileContexts = verifiedFileContexts;
          }
        }
        return verifies;
      }
      toJSON() {
        const fileContextsJSON = this.fileContexts.map((fileContext) => {
          const fileContextJSON = fileContext.toJSON();
          return fileContextJSON;
        }), json = fileContextsJSON;
        return json;
      }
      static fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar) {
        const verifies = false, initialised = false, fileContexts = [], combinedCustomGrammar = null, dependencyReleaseContexts = null, releaseContext = new ReleaseContext(log, name, json, entries, callback, customGrammar, verifies, initialised, fileContexts, combinedCustomGrammar, dependencyReleaseContexts);
        return releaseContext;
      }
    };
  });

  // node_modules/occam-languages/lib/nonTerminalNode.js
  var require_nonTerminalNode2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonTerminalNode;
      }
    });
    var _necessary = require_browser();
    var _occamparsers = require_lib4();
    var {first: first2} = _necessary.arrayUtilities;
    var NonTerminalNode = class extends _occamparsers.NonTerminalNode {
      someTerminalNode(callback, tokenType) {
        return this.someChildNode((childNode, index) => {
          const childNodeTerminalNode = childNode.isTerminalNode();
          if (childNodeTerminalNode) {
            const terminalNode = childNode, terminalNodeType = terminalNode.getType();
            if (terminalNodeType === tokenType) {
              return callback(terminalNode, index);
            }
          }
        });
      }
      getNodeByRuleName(...ruleNames) {
        const node = this.findChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        }) || null;
        return node;
      }
      getNodesByRuleName(...ruleNames) {
        const nodes = this.filterChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        });
        return nodes;
      }
      getLastNodeByRuleName(...ruleNames) {
        let lastNode = null;
        this.backwardsSomeChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              lastNode = childNode;
              return true;
            }
          }
        });
        return lastNode;
      }
      getFirstNodeByRuleName(...ruleNames) {
        let firstNode = null;
        this.forwardsSomeChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              firstNode = childNode;
              return true;
            }
          }
        });
        return firstNode;
      }
      getSingularNodeByRuleName(...ruleNames) {
        let singularNode = null;
        const nodes = this.filterChildNode((childNode) => {
          const childNodeNonTerminalNode = childNode.isNonTerminalNode();
          if (childNodeNonTerminalNode) {
            const nonTerminalNode = childNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        }), nodesLength = nodes.length;
        if (nodesLength === 1) {
          const firstNode = first2(nodes);
          singularNode = firstNode;
        }
        return singularNode;
      }
      getDescendantNodesByRuleName(...ruleNames) {
        const nodes = this.filterDescendantNode((descendantNode) => {
          const descendantNodeNonTerminalNode = descendantNode.isNonTerminalNode();
          if (descendantNodeNonTerminalNode) {
            const nonTerminalNode = descendantNode, ruleName = nonTerminalNode.getRuleName(), ruleNamesIncludesRuleName = ruleNames.includes(ruleName);
            if (ruleNamesIncludesRuleName) {
              return true;
            }
          }
        });
        return nodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamparsers.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/query.js
  var require_query4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
    var _default = {
      nodeQuery,
      nodesQuery
    };
  });

  // node_modules/occam-languages/lib/utilities/pass.js
  var require_pass = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get areTerminalNodeMapsEqual() {
        return areTerminalNodeMapsEqual;
      },
      get nonTerminalNodeQuery() {
        return nonTerminalNodeQuery;
      },
      get terminalNodeMapFromNodes() {
        return terminalNodeMapFromNodes;
      }
    });
    var _necessary = require_browser();
    var _query = require_query4();
    var {match} = _necessary.arrayUtilities;
    var nonTerminalNodeQuery = (0, _query.nodeQuery)("/*");
    function terminalNodeMapFromNodes(nodes) {
      const terminalNodeMap = {};
      nodes.forEach((node, index) => {
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          terminalNodeMap[index] = terminalNode;
        }
      });
      return terminalNodeMap;
    }
    function areTerminalNodeMapsEqual(generalTerminalNodeMap, specificTerminalNodeMap) {
      let terminalNodeMapsEqual = false;
      const generalIndexes = Object.keys(generalTerminalNodeMap), specificIndexes = Object.keys(specificTerminalNodeMap), terminalNodeMapKeysMatch = match(generalIndexes, specificIndexes, (generalIndex, specificIndex) => {
        if (generalIndex === specificIndex) {
          return true;
        }
      });
      if (terminalNodeMapKeysMatch) {
        const generalTerminalNodes = Object.values(generalTerminalNodeMap), specificTerminalNodes = Object.values(specificTerminalNodeMap), terminalNodeMapValuesMatch = match(generalTerminalNodes, specificTerminalNodes, (generalTerminalNode, specificTerminalNode) => {
          const generalTerminalNodeMatchesSpecificTerminalNode = generalTerminalNode.match(specificTerminalNode);
          if (generalTerminalNodeMatchesSpecificTerminalNode) {
            return true;
          }
        });
        terminalNodeMapsEqual = terminalNodeMapValuesMatch;
      }
      return terminalNodeMapsEqual;
    }
  });

  // node_modules/occam-languages/lib/pass/zip.js
  var require_zip = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ZipPass;
      }
    });
    var _pass = require_pass();
    var ZipPass = class {
      run(generalNode, specificNode, ...remainingArguments) {
        let success;
        const visited = this.visitNode(generalNode, specificNode, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(generalChildNodes, specificChildNodes, ...remainingArguments) {
        let descended = false;
        const generalChildNodesLength = generalChildNodes.length, specificChildNodesLength = specificChildNodes.length;
        if (generalChildNodesLength === specificChildNodesLength) {
          const specificTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(specificChildNodes), generalTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(generalChildNodes), terminalNodeMapsEqual = (0, _pass.areTerminalNodeMapsEqual)(generalTerminalNodeMap, specificTerminalNodeMap);
          if (terminalNodeMapsEqual) {
            const visited = generalChildNodes.every((generalChildNode, index) => {
              const specificChildNode = specificChildNodes[index], specificNode = specificChildNode, generalNode = generalChildNode, visited2 = this.visitNode(generalNode, specificNode, ...remainingArguments);
              if (visited2) {
                return true;
              }
            });
            if (visited) {
              descended = true;
            }
          }
        }
        return descended;
      }
      visitNode(generalNode, specificNode, ...remainingArguments) {
        let visited = false;
        const generalNodeTerminalNode = generalNode.isTerminalNode(), specificNodeTerminalNode = specificNode.isTerminalNode(), generalNodeNonTerminalNode = generalNode.isNonTerminalNode(), specificNodeNonTerminalNode = specificNode.isNonTerminalNode();
        if (false) {
        } else if (generalNodeTerminalNode && specificNodeTerminalNode) {
          const generalTerminalNode = generalNode, specificTerminalNode = specificNode;
          visited = this.visitTerminalNode(generalTerminalNode, specificTerminalNode, ...remainingArguments);
        } else if (generalNodeNonTerminalNode && specificNodeNonTerminalNode) {
          const generalNonTerminalNode = generalNode, specificNonTerminalNode = specificNode;
          visited = this.visitNonTerminalNode(generalNonTerminalNode, specificNonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(generalTerminalNode, specificTerminalNode, ...remainingArguments) {
        let visited;
        visited = true;
        return visited;
      }
      visitNonTerminalNode(generalNonTerminalNode, specificNonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            generalNodeQuery: _pass.nonTerminalNodeQuery,
            specificNodeQuery: _pass.nonTerminalNodeQuery,
            run: (generalNode, specificNode, ...remainingArguments2) => {
              let visited2 = false;
              const generalNonTerminalNodeRuleName = generalNonTerminalNode.getRuleName(), specificNonTerminalNodeRuleName = specificNonTerminalNode.getRuleName();
              if (generalNonTerminalNodeRuleName === specificNonTerminalNodeRuleName) {
                const generalNonTerminalNodeChildNodes = generalNonTerminalNode.getChildNodes(), specificNonTerminalNodeChildNodes = specificNonTerminalNode.getChildNodes(), generalChildNodes = generalNonTerminalNodeChildNodes, specificChildNodes = specificNonTerminalNodeChildNodes, descended = this.descend(generalChildNodes, specificChildNodes, ...remainingArguments2);
                if (descended) {
                  visited2 = true;
                }
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {generalNodeQuery, specificNodeQuery, run} = map;
          const generalNode = generalNodeQuery(generalNonTerminalNode), specificNode = specificNodeQuery(specificNonTerminalNode);
          if (generalNode !== null && specificNode !== null) {
            const success = run(generalNode, specificNode, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/async.js
  var require_async2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AsyncPass;
      }
    });
    var _pass = require_pass();
    var _asynchronous = require_asynchronous2();
    var AsyncPass = class {
      async run(node, ...remainingArguments) {
        let success;
        const visited = await this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      async descend(childNodes, ...remainingArguments) {
        let descended = false;
        const visited = await (0, _asynchronous.asyncEvery)(childNodes, async (childNode) => {
          const node = childNode, visited2 = await this.visitNode(node, ...remainingArguments);
          if (visited2) {
            return true;
          }
        });
        if (visited) {
          descended = true;
        }
        return descended;
      }
      async visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = await this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = await this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      async visitTerminalNode(terminalNode, ...remainingArguments) {
        const visited = true;
        return visited;
      }
      async visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: async (node, ...remainingArguments2) => {
              let visited2 = false;
              const childNodes = nonTerminalNode.getChildNodes(), descended = await this.descend(childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        await (0, _asynchronous.asyncSome)(maps, async (map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = await run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/simple.js
  var require_simple = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SimplePass;
      }
    });
    var _pass = require_pass();
    var SimplePass = class {
      run(node, ...remainingArguments) {
        let success;
        const visited = this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(childNodes, ...remainingArguments) {
        let descended = false;
        const visited = childNodes.every((childNode) => {
          const node = childNode, visited2 = this.visitNode(node, ...remainingArguments);
          if (visited2) {
            return true;
          }
        });
        if (visited) {
          descended = true;
        }
        return descended;
      }
      visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(terminalNode, ...remainingArguments) {
        const visited = true;
        return visited;
      }
      visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: (node, ...remainingArguments2) => {
              let visited2 = false;
              const childNodes = nonTerminalNode.getChildNodes(), descended = this.descend(childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/forward.js
  var require_forward = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ForwardPass;
      }
    });
    var _pass = require_pass();
    var ForwardPass = class {
      run(node, ...remainingArguments) {
        let success;
        const visited = this.visitNode(node, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(index, childNodes, ...remainingArguments) {
        let descendedForward = false;
        const descendForward = remainingArguments.pop(), childNodesLength = childNodes.length;
        if (index === childNodesLength) {
          descendedForward = descendForward();
        } else {
          const childNode = childNodes[index], node = childNode, visited = this.visitNode(node, ...remainingArguments, () => {
            remainingArguments.push(descendForward);
            const aheadIndex = index + 1, descendedForward2 = this.descend(aheadIndex, childNodes, ...remainingArguments);
            return descendedForward2;
          });
          if (visited) {
            descendedForward = true;
          }
        }
        return descendedForward;
      }
      visitNode(node, ...remainingArguments) {
        let visited;
        const nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
          const terminalNode = node;
          visited = this.visitTerminalNode(terminalNode, ...remainingArguments);
        } else {
          const nonTerminalNode = node;
          visited = this.visitNonTerminalNode(nonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(terminalNode, ...remainingArguments) {
        let visited = false;
        const descendForward = remainingArguments.pop(), descendedForward = descendForward();
        if (descendedForward) {
          visited = true;
        }
        remainingArguments.push(descendForward);
        return visited;
      }
      visitNonTerminalNode(nonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            nodeQuery: _pass.nonTerminalNodeQuery,
            run: (node, ...remainingArguments2) => {
              let visited2 = false;
              const index = 0, childNodes = nonTerminalNode.getChildNodes(), descended = this.descend(index, childNodes, ...remainingArguments2);
              if (descended) {
                visited2 = true;
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {nodeQuery, run} = map;
          const node = nodeQuery(nonTerminalNode);
          if (node !== null) {
            const success = run(node, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/pass/equivalence.js
  var require_equivalence = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EquivalencePass;
      }
    });
    var _pass = require_pass();
    var EquivalencePass = class {
      run(leftNode, rightNode, ...remainingArguments) {
        let success;
        const visited = this.visitNode(leftNode, rightNode, ...remainingArguments);
        success = visited;
        return success;
      }
      descend(leftChildNodes, rightChildNodes, ...remainingArguments) {
        let descended = false;
        const leftChildNodesLength = leftChildNodes.length, rightChildNodesLength = rightChildNodes.length;
        if (leftChildNodesLength === rightChildNodesLength) {
          const leftTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(leftChildNodes), rightTerminalNodeMap = (0, _pass.terminalNodeMapFromNodes)(rightChildNodes), terminalNodeMapsEqual = (0, _pass.areTerminalNodeMapsEqual)(leftTerminalNodeMap, rightTerminalNodeMap);
          if (terminalNodeMapsEqual) {
            descended = leftChildNodes.every((leftChildNode, index) => {
              const rightChildNode = rightChildNodes[index], leftNode = leftChildNode, rightNode = rightChildNode, visited = this.visitNode(leftNode, rightNode, ...remainingArguments);
              if (visited) {
                return true;
              }
            });
          }
        }
        return descended;
      }
      visitNode(leftNode, rightNode, ...remainingArguments) {
        let visited = false;
        const leftNodeTerminalNode = leftNode.isTerminalNode(), rightNodeTerminalNode = rightNode.isTerminalNode(), leftNodeNonTerminalNode = leftNode.isNonTerminalNode(), rightNodeNonTerminalNode = rightNode.isNonTerminalNode();
        if (false) {
        } else if (leftNodeTerminalNode && rightNodeTerminalNode) {
          const leftTerminalNode = leftNode, rightTerminalNode = rightNode;
          visited = this.visitTerminalNode(leftTerminalNode, rightTerminalNode, ...remainingArguments);
        } else if (leftNodeNonTerminalNode && rightNodeNonTerminalNode) {
          const leftNonTerminalNode = leftNode, rightNonTerminalNode = rightNode;
          visited = this.visitNonTerminalNode(leftNonTerminalNode, rightNonTerminalNode, ...remainingArguments);
        }
        return visited;
      }
      visitTerminalNode(leftTerminalNode, rightTerminalNode, ...remainingArguments) {
        let visited;
        visited = true;
        return visited;
      }
      visitNonTerminalNode(leftNonTerminalNode, rightNonTerminalNode, ...remainingArguments) {
        let visited = false;
        let {maps} = this.constructor;
        maps = [
          ...maps,
          {
            leftNodeQuery: _pass.nonTerminalNodeQuery,
            rightNodeQuery: _pass.nonTerminalNodeQuery,
            run: (leftNode, rightNode, ...remainingArguments2) => {
              let visited2 = false;
              const leftNonTerminalNodeRuleName = leftNonTerminalNode.getRuleName(), rightNonTerminalNodeRuleName = rightNonTerminalNode.getRuleName();
              if (leftNonTerminalNodeRuleName === rightNonTerminalNodeRuleName) {
                const leftNonTerminalNodeChildNodes = leftNonTerminalNode.getChildNodes(), rightNonTerminalNodeChildNodes = rightNonTerminalNode.getChildNodes(), leftChildNodes = leftNonTerminalNodeChildNodes, rightChildNodes = rightNonTerminalNodeChildNodes, descended = this.descend(leftChildNodes, rightChildNodes, ...remainingArguments2);
                if (descended) {
                  visited2 = true;
                }
              }
              return visited2;
            }
          }
        ];
        maps.some((map) => {
          const {leftNodeQuery, rightNodeQuery, run} = map;
          const leftNode = leftNodeQuery(leftNonTerminalNode), rightNode = rightNodeQuery(rightNonTerminalNode);
          if (leftNode !== null && rightNode !== null) {
            const success = run(leftNode, rightNode, ...remainingArguments);
            visited = success;
            return true;
          }
        });
        return visited;
      }
    };
  });

  // node_modules/occam-languages/lib/utilities/dependency.js
  var require_dependency = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "asyncEveryDependency", {
      enumerable: true,
      get: function() {
        return asyncEveryDependency;
      }
    });
    var _asynchronous = require_asynchronous2();
    async function asyncEveryDependency(dependencies, callback) {
      const array = dependencies.getArray();
      return await (0, _asynchronous.asyncEvery)(array, callback);
    }
  });

  // node_modules/occam-languages/lib/utilities/verification.js
  var require_verification = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get createReleaseContext() {
        return createReleaseContext;
      },
      get default() {
        return _default;
      },
      get initialiseReleaseContext() {
        return initialiseReleaseContext;
      },
      get verifyReleaseContext() {
        return verifyReleaseContext;
      }
    });
    var _necessary = require_browser();
    var _dependency = require_dependency();
    var {last} = _necessary.arrayUtilities;
    function initialiseReleaseContext(dependency, context2) {
      const {releaseContextMap} = context2, dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext = releaseContextMap[releaseName] || null;
      if (releaseContext === null) {
        const {log} = context2;
        log.warning(`Unable to initialise the '${dependencyName}' context because it has not been created.`);
      } else {
        const releaseContextInitialised = releaseContext.isInitialised();
        if (!releaseContextInitialised) {
          initialiseDependencyReleaseContexts(dependency, releaseContext, context2);
          const {log} = context2, releaseContexts = retrieveReleaseContexts(releaseContext, releaseContextMap);
          log.info(`Initialising the '${dependencyName}' context...`);
          const {FileContextFromFilePath} = context2;
          releaseContext.initialise(releaseContexts, FileContextFromFilePath);
          log.debug(`...initialised the '${dependencyName}' context.`);
        }
      }
    }
    async function createReleaseContext(dependency, dependentNames, context2) {
      let success = false;
      const {releaseContextMap} = context2, dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext = releaseContextMap[releaseName] || null;
      if (releaseContext !== null) {
        const {log} = context2, releaseMatchesDependency = checkReleaseMatchesDependency(releaseContext, dependency, dependentNames, context2);
        if (releaseMatchesDependency) {
          log.debug(`The '${releaseName}' context has already been created.`);
          success = true;
        }
      } else {
        const {log} = context2, dependencyString = dependency.asString(), dependentNamesLength = dependentNames.length;
        if (dependentNamesLength === 0) {
          log.info(`Creating the '${releaseName}' context...`);
        } else {
          const lastDependentName = last(dependentNames), dependentName = lastDependentName;
          log.info(`Creating the '${releaseName}' context given the '${dependentName}' dependant's '${dependencyString}' dependency...`);
        }
        const {releaseContextFromDependency} = context2, releaseContext2 = await releaseContextFromDependency(dependency, context2), releaseContextCreated = checkReleaseContextCreated(releaseContext2, dependency, context2);
        if (releaseContextCreated) {
          const releaseMatchesDependency = checkReleaseMatchesDependency(releaseContext2, dependency, dependentNames, context2);
          if (releaseMatchesDependency) {
            releaseContextMap[releaseName] = releaseContext2;
            success = await createDependencyReleaseContexts(dependency, releaseContext2, dependentNames, context2);
          }
        }
        success ? log.debug(`...created the '${releaseName}' context.`) : log.warning(`...unable to create the '${releaseName}' context.`);
      }
      return success;
    }
    async function verifyReleaseContext(releaseName, dependentName, dependentReleased, releaseContextMap) {
      let releaseVerifies = false;
      const releaseContext = releaseContextMap[releaseName];
      if (releaseContext !== null) {
        const released = releaseContext.isReleased();
        if (released) {
          releaseVerifies = true;
        } else {
          if (dependentReleased) {
            releaseContext.warning(`The '${releaseName}' project cannot be verifies because its '${dependentName}' dependent is a package.`);
          } else {
            const dependentName2 = releaseName, dependentReleased2 = released, dependencyReleaseContextsVerify = await verifyDependencyReleaseContexts(releaseContext, dependentName2, dependentReleased2, releaseContextMap);
            if (dependencyReleaseContextsVerify) {
              const releaseContextVerified = releaseContext.hasVerified();
              if (releaseContextVerified) {
                releaseVerifies = true;
              } else {
                releaseContext.info(`Verifying the '${releaseName}' project...`);
                const releaseContextVerifies = await releaseContext.verify();
                if (releaseContextVerifies) {
                  releaseContext.info(`...verified the '${releaseName}' project.`);
                  releaseVerifies = true;
                }
              }
            }
          }
        }
      }
      return releaseVerifies;
    }
    var _default = {
      createReleaseContext,
      verifyReleaseContext,
      initialiseReleaseContext
    };
    async function createDependencyReleaseContexts(dependency, releaseContext, dependentNames, context2) {
      let success;
      const dependencyName = dependency.getName(), dependencies = releaseContext.getDependencies();
      dependentNames = [
        ...dependentNames,
        dependencyName
      ];
      success = await (0, _dependency.asyncEveryDependency)(dependencies, async (dependency2) => {
        let success2 = false;
        const cyclicDependencyExists = checkCyclicDependencyExists(dependency2, dependentNames, context2);
        if (!cyclicDependencyExists) {
          success2 = await createReleaseContext(dependency2, dependentNames, context2);
        }
        return success2;
      });
      return success;
    }
    async function verifyDependencyReleaseContexts(releaseContext, dependentName, dependentReleased, releaseContextMap) {
      const dependencies = releaseContext.getDependencies(), dependencyReleaseContextsVerify = await (0, _dependency.asyncEveryDependency)(dependencies, async (dependency) => {
        const name = dependency.getName(), releaseName = name, releaseContextVerifies = await verifyReleaseContext(releaseName, dependentName, dependentReleased, releaseContextMap);
        if (releaseContextVerifies) {
          return true;
        }
      });
      return dependencyReleaseContextsVerify;
    }
    function retrieveReleaseContexts(releaseContext, releaseContextMap) {
      const releaseContexts = [], remainingReleaseContext = releaseContext, remainingReleaseContexts = [
        remainingReleaseContext
      ];
      let remainingReleaseContextsLength = remainingReleaseContexts.length;
      while (remainingReleaseContextsLength > 0) {
        const remainingReleaseContext2 = remainingReleaseContexts.shift(), releaseContext2 = remainingReleaseContext2;
        releaseContexts.push(releaseContext2);
        const dependencies = releaseContext2.getDependencies();
        dependencies.forEachDependency((dependency) => {
          const dependencyName = dependency.getName(), releaseName = dependencyName, releaseContext3 = releaseContextMap[releaseName], releaseContextsIncludesReleaseContext = releaseContexts.includes(releaseContext3), remainingReleaseContextsIncludesReleaseContext = remainingReleaseContexts.includes(releaseContext3);
          if (!releaseContextsIncludesReleaseContext && !remainingReleaseContextsIncludesReleaseContext) {
            const remainingReleaseContext3 = releaseContext3;
            remainingReleaseContexts.push(remainingReleaseContext3);
          }
        });
        remainingReleaseContextsLength = remainingReleaseContexts.length;
      }
      return releaseContexts;
    }
    function checkReleaseContextCreated(releaseContext, dependency, context2) {
      const releaseContextCreated = releaseContext !== null;
      if (!releaseContextCreated) {
        const {log} = context2, dependencyName = dependency.getName(), releaseName = dependencyName;
        log.warning(`The '${releaseName}' context could not be created. Perhaps the 'meta.json' file is missing or invalid. Or there could be a dependency mismatch.`);
      }
      return releaseContextCreated;
    }
    function checkCyclicDependencyExists(dependency, dependentNames, context2) {
      const dependencyName = dependency.getName(), dependentNamesIncludesDependencyName = dependentNames.includes(dependencyName), cyclicDependencyExists = dependentNamesIncludesDependencyName;
      if (cyclicDependencyExists) {
        const {log} = context2, firstDependentName = first(dependentNames), dependencyNames = [
          ...dependentNames,
          firstDependentName
        ], dependencyNamesString = dependencyNames.join(`' -> '`);
        log.warning(`There is a cyclic dependency, '${dependencyNamesString}'.`);
      }
      return cyclicDependencyExists;
    }
    function checkReleaseMatchesDependency(releaseContext, dependency, dependentNames, context2) {
      let releaseMatchesDependency = true;
      const shortenedVersion = dependency.getShortedVersion();
      if (shortenedVersion !== null) {
        const entriesMatchShortenedVersion = releaseContext.matchShortenedVersion(shortenedVersion);
        if (!entriesMatchShortenedVersion) {
          const {log} = context2, version = releaseContext.getVersion(), lastDependentName = last(dependentNames), dependentName = lastDependentName, versionString = version.toString(), dependencyString = dependency.asString();
          log.warning(`The '${dependentName}' dependent requires the '${dependencyString}' dependency but a context with version '${versionString}' was provided.`);
          releaseMatchesDependency = false;
        }
      }
      return releaseMatchesDependency;
    }
    function initialiseDependencyReleaseContexts(dependency, releaseContext, context2) {
      const dependencies = releaseContext.getDependencies();
      dependencies.forEachDependency((dependency2) => {
        initialiseReleaseContext(dependency2, context2);
      });
    }
  });

  // node_modules/occam-model/lib/types.js
  var require_types2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DIRECTORY_TYPE() {
        return DIRECTORY_TYPE;
      },
      get FILE_TYPE() {
        return FILE_TYPE;
      }
    });
    var FILE_TYPE = "File";
    var DIRECTORY_TYPE = "Directory";
  });

  // node_modules/occam-model/lib/constants.js
  var require_constants12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DOUBLE_SPACE() {
        return DOUBLE_SPACE;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get ESCAPED_AMPERSAND() {
        return ESCAPED_AMPERSAND;
      },
      get ESCAPED_GREATER_THAN() {
        return ESCAPED_GREATER_THAN;
      },
      get ESCAPED_LESS_THAN() {
        return ESCAPED_LESS_THAN;
      }
    });
    var EMPTY_STRING = "";
    var DOUBLE_SPACE = "  ";
    var ESCAPED_AMPERSAND = "&amp;";
    var ESCAPED_LESS_THAN = "&lt;";
    var ESCAPED_GREATER_THAN = "&gt;";
  });

  // node_modules/occam-model/lib/utilities/content.js
  var require_content3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get convertContentTabsToWhitespace() {
        return convertContentTabsToWhitespace;
      },
      get default() {
        return _default;
      },
      get sanitiseContent() {
        return sanitiseContent;
      },
      get trimDoubleQuotes() {
        return trimDoubleQuotes;
      }
    });
    var _constants = require_constants12();
    function sanitiseContent(content) {
      const sanitisedContent = content.replace(/&/g, _constants.ESCAPED_AMPERSAND).replace(/</g, _constants.ESCAPED_LESS_THAN).replace(/>/g, _constants.ESCAPED_GREATER_THAN);
      return sanitisedContent;
    }
    function trimDoubleQuotes(content) {
      return content.replace(/(^"|"$)/g, _constants.EMPTY_STRING);
    }
    function convertContentTabsToWhitespace(content) {
      return content.replace(/\t/g, _constants.DOUBLE_SPACE);
    }
    var _default = {
      sanitiseContent,
      trimDoubleQuotes,
      convertContentTabsToWhitespace
    };
  });

  // node_modules/occam-model/lib/file.js
  var require_file2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return File;
      }
    });
    var _types = require_types2();
    var _content = require_content3();
    var _File = class {
      constructor(path, content, released) {
        this.path = path;
        this.content = content;
        this.released = released;
      }
      getPath() {
        return this.path;
      }
      getContent() {
        return this.content;
      }
      isReleased() {
        return this.released;
      }
      isFile() {
        const file = true;
        return file;
      }
      isDirectory() {
        const directory = false;
        return directory;
      }
      setPath(path) {
        this.path = path;
      }
      setContent(content) {
        this.content = content;
      }
      setReleased(released) {
        this.released = released;
      }
      matchFilePath(filePath) {
        const filePathMatches = this.path === filePath;
        return filePathMatches;
      }
      toJSON() {
        const {type} = _File, path = this.path, content = this.content, released = this.released, json = {
          type,
          path,
          content,
          released
        };
        return json;
      }
      static fromJSON(json) {
        let file = null;
        if (json !== null) {
          const {type} = json;
          if (type === _types.FILE_TYPE) {
            let {content} = json;
            const {path, released} = json;
            content = (0, _content.convertContentTabsToWhitespace)(content);
            file = new _File(path, content, released);
          }
        }
        return file;
      }
      static fromDocument(document2) {
        const filePath = document2.getFilePath(), released = document2.isReleased(), path = filePath;
        let content = document2.getContent();
        content = (0, _content.convertContentTabsToWhitespace)(content);
        const file = new _File(path, content, released);
        return file;
      }
      static fromPathContentAndReleased(path, content, released) {
        content = (0, _content.convertContentTabsToWhitespace)(content);
        const file = new _File(path, content, released);
        return file;
      }
    };
    var File = _File;
    __publicField(File, "type", _types.FILE_TYPE);
  });

  // node_modules/occam-model/lib/files.js
  var require_files = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Files;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Files = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getFilePaths() {
        const filePaths = this.mapFile((file) => {
          const filePath = file.getPath();
          return filePath;
        });
        return filePaths;
      }
      addFile(file) {
        this.array.push(file);
      }
      mapFile(callback) {
        return this.array.map(callback);
      }
      someFile(callback) {
        return this.array.some(callback);
      }
      reduceFile(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachFile(callback) {
        this.array.forEach(callback);
      }
      findFile(callback) {
        return this.array.find(callback) || null;
      }
      toJSON() {
        const filesJSON = this.array.map((file) => {
          const fileJSON = file !== null ? file.toJSON() : null;
          return fileJSON;
        }), json = filesJSON;
        return json;
      }
      static fromJSON(json) {
        const filesJSON = json, array = [], files = new Files(array);
        filesJSON.forEach((fileJSON) => {
          const json2 = fileJSON, file = _file.default.fromJSON(json2);
          files.addFile(file);
        });
        return files;
      }
      static fromNothing() {
        const array = [], files = new Files(array);
        return files;
      }
    };
  });

  // node_modules/occam-model/lib/multiplers.js
  var require_multiplers = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get MAJOR_NUMBER_MULTIPLIER() {
        return MAJOR_NUMBER_MULTIPLIER;
      },
      get MINOR_NUMBER_MULTIPLIER() {
        return MINOR_NUMBER_MULTIPLIER;
      },
      get PATCH_NUMBER_MULTIPLIER() {
        return PATCH_NUMBER_MULTIPLIER;
      }
    });
    var MAJOR_NUMBER_MULTIPLIER = 1e12;
    var MINOR_NUMBER_MULTIPLIER = 1e6;
    var PATCH_NUMBER_MULTIPLIER = 1;
  });

  // node_modules/occam-model/lib/utilities/version.js
  var require_version2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get majorNumberFromNumber() {
        return majorNumberFromNumber;
      },
      get majorNumberFromString() {
        return majorNumberFromString;
      },
      get minorNumberFromNumber() {
        return minorNumberFromNumber;
      },
      get minorNumberFromString() {
        return minorNumberFromString;
      },
      get patchNumberFromNumber() {
        return patchNumberFromNumber;
      },
      get patchNumberFromString() {
        return patchNumberFromString;
      }
    });
    var _necessary = require_browser();
    var _multiplers = require_multiplers();
    var {second} = _necessary.arrayUtilities;
    function majorNumberFromNumber(number) {
      const majorNumber = number !== null ? Math.floor(number / _multiplers.MAJOR_NUMBER_MULTIPLIER) : 0;
      return majorNumber;
    }
    function minorNumberFromNumber(number) {
      const minorNumber = number !== null ? Math.floor(number % _multiplers.MAJOR_NUMBER_MULTIPLIER / _multiplers.MINOR_NUMBER_MULTIPLIER) : 0;
      return minorNumber;
    }
    function patchNumberFromNumber(number) {
      const patchNumber = number !== null ? Math.floor(number % _multiplers.MINOR_NUMBER_MULTIPLIER / _multiplers.PATCH_NUMBER_MULTIPLIER) : 0;
      return patchNumber;
    }
    function majorNumberFromString(string) {
      let majorNumber = 0;
      if (string) {
        const matches = string.match(/^(\d+)/), secondMatch = second(matches);
        majorNumber = Number(secondMatch);
      }
      return majorNumber;
    }
    function minorNumberFromString(string) {
      let minorNumber = 0;
      if (string) {
        const matches = string.match(/^\d+\.(\d+)/), secondMatch = second(matches);
        minorNumber = Number(secondMatch);
      }
      return minorNumber;
    }
    function patchNumberFromString(string) {
      let patchNumber = 0;
      if (string) {
        const matches = string.match(/^\d+\.\d+\.(\d+)/), secondMatch = second(matches);
        patchNumber = Number(secondMatch);
      }
      return patchNumber;
    }
  });

  // node_modules/occam-model/lib/version.js
  var require_version3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Version;
      }
    });
    var _multiplers = require_multiplers();
    var _version = require_version2();
    var Version = class {
      constructor(majorNumber, minorNumber, patchNumber) {
        this.majorNumber = majorNumber;
        this.minorNumber = minorNumber;
        this.patchNumber = patchNumber;
      }
      getMajorNumber() {
        return this.majorNumber;
      }
      getMinorNumber() {
        return this.minorNumber;
      }
      getPatchNumber() {
        return this.patchNumber;
      }
      bumpMajorNumber() {
        this.majorNumber += 1;
      }
      bumpMinorNumber() {
        this.minorNumber += 1;
      }
      bumpPatchNumber() {
        this.patchNumber += 1;
      }
      resetMajorNumber() {
        this.majorNumber = 0;
      }
      resetMinorNumber() {
        this.minorNumber = 0;
      }
      resetPatchNumber() {
        this.patchNumber = 0;
      }
      matchShortenedVersion(shortenedVersion) {
        let matchesShortenedVersion = false;
        if (shortenedVersion === null) {
          matchesShortenedVersion = true;
        } else {
          const majorNumber = shortenedVersion.getMajorNumber();
          if (this.majorNumber === majorNumber) {
            const minorNumber = shortenedVersion.getMinorNumber();
            if (this.minorNumber >= minorNumber) {
              matchesShortenedVersion = true;
            }
          }
        }
        return matchesShortenedVersion;
      }
      toString() {
        const string = `${this.majorNumber}.${this.minorNumber}.${this.patchNumber}`;
        return string;
      }
      toVersionNumber() {
        const versionNumber = this.majorNumber * _multiplers.MAJOR_NUMBER_MULTIPLIER + this.minorNumber * _multiplers.MINOR_NUMBER_MULTIPLIER + this.patchNumber * _multiplers.PATCH_NUMBER_MULTIPLIER;
        return versionNumber;
      }
      static fromString(string) {
        const majorNumber = (0, _version.majorNumberFromString)(string), minorNumber = (0, _version.minorNumberFromString)(string), patchNumber = (0, _version.patchNumberFromString)(string), version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromNothing() {
        const majorNumber = 0, minorNumber = 0, patchNumber = 0, version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromVersion(version) {
        const majorNumber = version.getMajorNumber(), minorNumber = version.getMinorNumber(), patchNumber = version.getPatchNumber();
        version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
      static fromVersionNumber(versionNumber) {
        const number = versionNumber, majorNumber = (0, _version.majorNumberFromNumber)(number), minorNumber = (0, _version.minorNumberFromNumber)(number), patchNumber = (0, _version.patchNumberFromNumber)(number), version = new Version(majorNumber, minorNumber, patchNumber);
        return version;
      }
    };
  });

  // node_modules/occam-model/lib/directory.js
  var require_directory = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Directory;
      }
    });
    var _types = require_types2();
    var _Directory = class {
      constructor(path) {
        this.path = path;
      }
      getPath() {
        return this.path;
      }
      isFile() {
        const file = false;
        return file;
      }
      isDirectory() {
        const directory = true;
        return directory;
      }
      toJSON() {
        const {type} = _Directory, path = this.path, json = {
          type,
          path
        };
        return json;
      }
      static fromPath(path) {
        const directory = new _Directory(path);
        return directory;
      }
      static fromJSON(json) {
        let directory = null;
        if (json !== null) {
          const {type} = json;
          if (type === _types.DIRECTORY_TYPE) {
            const {path} = json;
            directory = new _Directory(path);
          }
        }
        return directory;
      }
    };
    var Directory = _Directory;
    __publicField(Directory, "type", _types.DIRECTORY_TYPE);
  });

  // node_modules/occam-model/lib/utilities/name.js
  var require_name5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "fileNameFromFilePath", {
      enumerable: true,
      get: function() {
        return fileNameFromFilePath;
      }
    });
    var _necessary = require_browser();
    var {bottommostNameFromPath} = _necessary.pathUtilities;
    function fileNameFromFilePath(filePath) {
      const path = filePath, bottommostName = bottommostNameFromPath(path), fileName = bottommostName;
      return fileName;
    }
  });

  // node_modules/occam-model/lib/fileNames.js
  var require_fileNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get META_JSON_FILE_NAME() {
        return META_JSON_FILE_NAME;
      },
      get README_MD_FILE_NAME() {
        return README_MD_FILE_NAME;
      },
      get STATEMENT_BNF_FILE_NAME() {
        return STATEMENT_BNF_FILE_NAME;
      },
      get SYMBOL_VOCABULARY_FILE_NAME() {
        return SYMBOL_VOCABULARY_FILE_NAME;
      },
      get TERM_BNF_FILE_NAME() {
        return TERM_BNF_FILE_NAME;
      },
      get TYPE_VOCABULARY_FILE_NAME() {
        return TYPE_VOCABULARY_FILE_NAME;
      },
      get default() {
        return _default;
      }
    });
    var README_MD_FILE_NAME = "README.md";
    var META_JSON_FILE_NAME = "meta.json";
    var TERM_BNF_FILE_NAME = "term.bnf";
    var STATEMENT_BNF_FILE_NAME = "statement.bnf";
    var TYPE_VOCABULARY_FILE_NAME = "type.vcb";
    var SYMBOL_VOCABULARY_FILE_NAME = "symbol.vcb";
    var _default = {
      README_MD_FILE_NAME,
      META_JSON_FILE_NAME,
      TERM_BNF_FILE_NAME,
      STATEMENT_BNF_FILE_NAME,
      TYPE_VOCABULARY_FILE_NAME,
      SYMBOL_VOCABULARY_FILE_NAME
    };
  });

  // node_modules/occam-model/lib/mixins/bnf.js
  var require_bnf13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants12();
    var _name = require_name5();
    var _fileNames = require_fileNames();
    function getBNF(bnfFileName) {
      let bnf = _constants.EMPTY_STRING;
      const customGrammarBNFFiles = this.getCustomGrammarBNFFiles(), customGrammarBNFFile = customGrammarBNFFiles.find((customGrammarBNFFile2) => {
        const customGrammarBNFFilePath = customGrammarBNFFile2.getPath(), customGrammarBNFFileName = (0, _name.fileNameFromFilePath)(customGrammarBNFFilePath);
        if (customGrammarBNFFileName === bnfFileName) {
          return true;
        }
      }) || null;
      if (customGrammarBNFFile !== null) {
        const customGrammarBNFFileContent = customGrammarBNFFile.getContent();
        bnf = customGrammarBNFFileContent;
      }
      return bnf;
    }
    function getTermBNF() {
      const fileName = _fileNames.TERM_BNF_FILE_NAME, bnf = this.getBNF(fileName), termBNF = bnf;
      return termBNF;
    }
    function getStatementBNF() {
      const fileName = _fileNames.STATEMENT_BNF_FILE_NAME, bnf = this.getBNF(fileName), statementBNF = bnf;
      return statementBNF;
    }
    var bnfMixins = {
      getBNF,
      getTermBNF,
      getStatementBNF
    };
    var _default = bnfMixins;
  });

  // node_modules/occam-model/lib/utilities/filePath.js
  var require_filePath = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get isFilePathCustomGrammarBNFFilePath() {
        return isFilePathCustomGrammarBNFFilePath;
      },
      get isFilePathCustomGrammarVocabularyFilePath() {
        return isFilePathCustomGrammarVocabularyFilePath;
      },
      get isFilePathDefaultMarkdownStyleFilePath() {
        return isFilePathDefaultMarkdownStyleFilePath;
      },
      get isFilePathFurtleFilePath() {
        return isFilePathFurtleFilePath;
      },
      get isFilePathIndexJSONFilePath() {
        return isFilePathIndexJSONFilePath;
      },
      get isFilePathMarkdownFilePath() {
        return isFilePathMarkdownFilePath;
      },
      get isFilePathMarkdownStyleFilePath() {
        return isFilePathMarkdownStyleFilePath;
      },
      get isFilePathMetaJSONFilePath() {
        return isFilePathMetaJSONFilePath;
      },
      get isFilePathNominalFilePath() {
        return isFilePathNominalFilePath;
      },
      get isFilePathReadmeFilePath() {
        return isFilePathReadmeFilePath;
      },
      get isFilePathRecognisedFilePath() {
        return isFilePathRecognisedFilePath;
      },
      get isFilePathReleaseFilePath() {
        return isFilePathReleaseFilePath;
      }
    });
    var readmeFilePathPattern = "^(?:[^\\/]+\\/){1}README\\.md$";
    var furtleFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.ftl$";
    var nominalFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.nml$";
    var markdownFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.md$";
    var metaJSONFilePathPattern = "^(?:[^\\/]+\\/){1}meta\\.json$";
    var indexJSONFilePathPattern = "^(?:[^\\/]+\\/){1}index\\.json$";
    var markdownStyleFilePathPattern = "^(?:[^\\/]+\\/){1,}[^\\.]+\\.mds$";
    var customGrammarBNFFilePathPattern = "^(?:[^\\/]+\\/){1}(term|statement)\\.bnf$";
    var defaultMarkdownStyleFilePathPattern = "^[^\\/]+\\/default\\.mds$";
    var customGrammarVocabularyFilePathPattern = "^(?:[^\\/]+\\/){1}(type|symbol)\\.vcb$";
    var releaseFilePathPattern = `${readmeFilePathPattern}|${furtleFilePathPattern}|${nominalFilePathPattern}|${metaJSONFilePathPattern}|${customGrammarBNFFilePathPattern}|${customGrammarVocabularyFilePathPattern}`;
    var recognisedFilePathPattern = `${releaseFilePathPattern}|${indexJSONFilePathPattern}|${markdownFilePathPattern}|${markdownStyleFilePathPattern}`;
    var readmeFilePathRegularExpression = new RegExp(readmeFilePathPattern);
    var furtleFilePathRegularExpression = new RegExp(furtleFilePathPattern);
    var releaseFilePathRegularExpression = new RegExp(releaseFilePathPattern);
    var nominalFilePathRegularExpression = new RegExp(nominalFilePathPattern);
    var markdownFilePathRegularExpression = new RegExp(markdownFilePathPattern);
    var metaJSONFilePathRegularExpression = new RegExp(metaJSONFilePathPattern);
    var indexJSONFilePathRegularExpression = new RegExp(indexJSONFilePathPattern);
    var recognisedFilePathRegularExpression = new RegExp(recognisedFilePathPattern);
    var markdownStyleFilePathRegularExpression = new RegExp(markdownStyleFilePathPattern);
    var customGrammarBNFFilePathRegularExpression = new RegExp(customGrammarBNFFilePathPattern);
    var defaultMarkdownStyleFilePathRegularExpression = new RegExp(defaultMarkdownStyleFilePathPattern);
    var customGrammarVocabularyFilePathRegularExpression = new RegExp(customGrammarVocabularyFilePathPattern);
    function isFilePathReadmeFilePath(filePath) {
      return readmeFilePathRegularExpression.test(filePath);
    }
    function isFilePathFurtleFilePath(filePath) {
      return furtleFilePathRegularExpression.test(filePath);
    }
    function isFilePathReleaseFilePath(filePath) {
      return releaseFilePathRegularExpression.test(filePath);
    }
    function isFilePathNominalFilePath(filePath) {
      return nominalFilePathRegularExpression.test(filePath);
    }
    function isFilePathMarkdownFilePath(filePath) {
      return markdownFilePathRegularExpression.test(filePath);
    }
    function isFilePathMetaJSONFilePath(filePath) {
      return metaJSONFilePathRegularExpression.test(filePath);
    }
    function isFilePathIndexJSONFilePath(filePath) {
      return indexJSONFilePathRegularExpression.test(filePath);
    }
    function isFilePathRecognisedFilePath(filePath) {
      return recognisedFilePathRegularExpression.test(filePath);
    }
    function isFilePathMarkdownStyleFilePath(filePath) {
      return markdownStyleFilePathRegularExpression.test(filePath);
    }
    function isFilePathCustomGrammarBNFFilePath(filePath) {
      return customGrammarBNFFilePathRegularExpression.test(filePath);
    }
    function isFilePathDefaultMarkdownStyleFilePath(filePath) {
      return defaultMarkdownStyleFilePathRegularExpression.test(filePath);
    }
    function isFilePathCustomGrammarVocabularyFilePath(filePath) {
      return customGrammarVocabularyFilePathRegularExpression.test(filePath);
    }
    var _default = {
      isFilePathReadmeFilePath,
      isFilePathFurtleFilePath,
      isFilePathReleaseFilePath,
      isFilePathNominalFilePath,
      isFilePathMarkdownFilePath,
      isFilePathMetaJSONFilePath,
      isFilePathIndexJSONFilePath,
      isFilePathRecognisedFilePath,
      isFilePathMarkdownStyleFilePath,
      isFilePathCustomGrammarBNFFilePath,
      isFilePathDefaultMarkdownStyleFilePath,
      isFilePathCustomGrammarVocabularyFilePath
    };
  });

  // node_modules/occam-model/lib/utilities/files.js
  var require_files2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get customGrammarBNFFilesFromFiles() {
        return customGrammarBNFFilesFromFiles;
      },
      get customGrammarVocabularyFilesFromFiles() {
        return customGrammarVocabularyFilesFromFiles;
      },
      get furtleFilesFromFiles() {
        return furtleFilesFromFiles;
      },
      get metaJSONFileFromFiles() {
        return metaJSONFileFromFiles;
      },
      get nominalFilesFromFiles() {
        return nominalFilesFromFiles;
      },
      get readmeFileFromFiles() {
        return readmeFileFromFiles;
      }
    });
    var _filePath = require_filePath();
    function readmeFileFromFiles(files) {
      let readmeFile = null;
      files.someFile((file) => {
        const filePath = file.getPath(), filePathReadmeFilePath = (0, _filePath.isFilePathReadmeFilePath)(filePath);
        if (filePathReadmeFilePath) {
          readmeFile = file;
          return true;
        }
      });
      return readmeFile;
    }
    function furtleFilesFromFiles(files) {
      const furtleFiles = files.reduceFile((furtleFiles2, file) => {
        const filePath = file.getPath(), filePathFurtleFilePath = (0, _filePath.isFilePathFurtleFilePath)(filePath), fileFurtleFile = filePathFurtleFilePath;
        if (fileFurtleFile) {
          const furtleFile = file;
          furtleFiles2.push(furtleFile);
        }
        return furtleFiles2;
      }, []);
      return furtleFiles;
    }
    function nominalFilesFromFiles(files) {
      const nominalFiles = files.reduceFile((nominalFiles2, file) => {
        const filePath = file.getPath(), filePathNominalFilePath = (0, _filePath.isFilePathNominalFilePath)(filePath), fileNominalFile = filePathNominalFilePath;
        if (fileNominalFile) {
          const nominalFile = file;
          nominalFiles2.push(nominalFile);
        }
        return nominalFiles2;
      }, []);
      return nominalFiles;
    }
    function metaJSONFileFromFiles(files) {
      let metaJSONFile = null;
      files.someFile((file) => {
        const filePath = file.getPath(), filePathMetaJSONFilePath = (0, _filePath.isFilePathMetaJSONFilePath)(filePath);
        if (filePathMetaJSONFilePath) {
          metaJSONFile = file;
          return true;
        }
      });
      return metaJSONFile;
    }
    function customGrammarBNFFilesFromFiles(files) {
      const customGrammarBNFFiles = files.reduceFile((customGrammarBNFFiles2, file) => {
        const filePath = file.getPath(), filePathCustomGrammarBNFFilePath = (0, _filePath.isFilePathCustomGrammarBNFFilePath)(filePath), fileCustomGrammarBNFFile = filePathCustomGrammarBNFFilePath;
        if (fileCustomGrammarBNFFile) {
          const customGrammarBNFFile = file;
          customGrammarBNFFiles2.push(customGrammarBNFFile);
        }
        return customGrammarBNFFiles2;
      }, []);
      return customGrammarBNFFiles;
    }
    function customGrammarVocabularyFilesFromFiles(files) {
      const customGrammarVocabularyFiles = files.reduceFile((customGrammarVocabularyFiles2, file) => {
        const filePath = file.getPath(), filePathCustomGrammarVocabularyFilePath = (0, _filePath.isFilePathCustomGrammarVocabularyFilePath)(filePath), fileCustomGrammarVocabularyFile = filePathCustomGrammarVocabularyFilePath;
        if (fileCustomGrammarVocabularyFile) {
          const customGrammarVocabularyFile = file;
          customGrammarVocabularyFiles2.push(customGrammarVocabularyFile);
        }
        return customGrammarVocabularyFiles2;
      }, []);
      return customGrammarVocabularyFiles;
    }
  });

  // node_modules/occam-model/lib/mixins/files.js
  var require_files3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _files = require_files2();
    function getReadmeFile() {
      const files = this.getFiles(), readmeFile = (0, _files.readmeFileFromFiles)(files);
      return readmeFile;
    }
    function getFurtleFiles() {
      const files = this.getFiles(), furtleFiles = (0, _files.furtleFilesFromFiles)(files);
      return furtleFiles;
    }
    function getNominalFiles() {
      const files = this.getFiles(), nominalFiles = (0, _files.nominalFilesFromFiles)(files);
      return nominalFiles;
    }
    function getMetaJSONFile() {
      const files = this.getFiles(), metaJSONFile = (0, _files.metaJSONFileFromFiles)(files);
      return metaJSONFile;
    }
    function getCustomGrammarBNFFiles() {
      const files = this.getFiles(), customGrammarBNFFiles = (0, _files.customGrammarBNFFilesFromFiles)(files);
      return customGrammarBNFFiles;
    }
    function getCustomGrammarVocabularyFiles() {
      const files = this.getFiles(), customGrammarVocabularyFiles = (0, _files.customGrammarVocabularyFilesFromFiles)(files);
      return customGrammarVocabularyFiles;
    }
    var filesMixins = {
      getReadmeFile,
      getFurtleFiles,
      getNominalFiles,
      getMetaJSONFile,
      getCustomGrammarBNFFiles,
      getCustomGrammarVocabularyFiles
    };
    var _default = filesMixins;
  });

  // node_modules/occam-model/lib/dependency.js
  var require_dependency2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Dependency;
      }
    });
    var Dependency = class {
      constructor(name, shortenedVersion) {
        this.name = name;
        this.shortenedVersion = shortenedVersion;
      }
      getName() {
        return this.name;
      }
      getShortedVersion() {
        return this.shortenedVersion;
      }
      asString() {
        let string;
        if (this.shortenedVersion !== null) {
          const shortenedVersionString = this.shortenedVersion.toString();
          string = `${this.name}@${shortenedVersionString}`;
        } else {
          string = this.name;
        }
        return string;
      }
      static fromName(name) {
        const shortenedVersion = null, dependency = new Dependency(name, shortenedVersion);
        return dependency;
      }
      static fromNameAndShortenedVersion(name, shortenedVersion) {
        const dependency = new Dependency(name, shortenedVersion);
        return dependency;
      }
    };
  });

  // node_modules/occam-model/lib/shortenedVersion.js
  var require_shortenedVersion = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ShortenedVersion;
      }
    });
    var _multiplers = require_multiplers();
    var _version = require_version2();
    var ShortenedVersion = class {
      constructor(majorNumber, minorNumber) {
        this.majorNumber = majorNumber;
        this.minorNumber = minorNumber;
      }
      getMajorNumber() {
        return this.majorNumber;
      }
      getMinorNumber() {
        return this.minorNumber;
      }
      toString() {
        const string = `${this.majorNumber}.${this.minorNumber}`;
        return string;
      }
      toVersionNumber() {
        const versionNumber = this.majorNumber * _multiplers.MAJOR_NUMBER_MULTIPLIER + this.minorNumber * _multiplers.MINOR_NUMBER_MULTIPLIER;
        return versionNumber;
      }
      getLeastMatchingVersionNumber() {
        const versionNumber = this.toVersionNumber(), leastMatchingVersionNumber = versionNumber;
        return leastMatchingVersionNumber;
      }
      getGreatestMatchingVersionNumber() {
        const majorNumber = this.majorNumber + 1, minorNumber = 0, shortenedVersion = ShortenedVersion.fromMajorNumberAndMinorNumber(majorNumber, minorNumber), shortenedVersionNumber = shortenedVersion.toVersionNumber(), greatestMatchingVersionNumber = shortenedVersionNumber - 1;
        return greatestMatchingVersionNumber;
      }
      static fromString(string) {
        const majorNumber = (0, _version.majorNumberFromString)(string), minorNumber = (0, _version.minorNumberFromString)(string), shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
      static fromVersionNumber(versionNumber) {
        const number = versionNumber, majorNumber = (0, _version.majorNumberFromNumber)(number), minorNumber = (0, _version.minorNumberFromNumber)(number), shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
      static fromMajorNumberAndMinorNumber(majorNumber, minorNumber) {
        const shortenedVersion = new ShortenedVersion(majorNumber, minorNumber);
        return shortenedVersion;
      }
    };
  });

  // node_modules/occam-model/lib/dependencies.js
  var require_dependencies = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Dependencies;
      }
    });
    var _necessary = require_browser();
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Dependencies = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      addDependency(dependency) {
        this.array.push(dependency);
      }
      mapDependency(callback) {
        return this.array.map(callback);
      }
      everyDependency(callback) {
        return this.array.every(callback);
      }
      reduceDependency(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachDependency(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachDependency(operation, done) {
        forEach(this.array, operation, done);
      }
      toJSON() {
        const dependenciesJSON = this.array.reduce((dependenciesJSON2, dependency) => {
          const name = dependency.getName(), shortenedVersion = dependency.getShortedVersion(), shortenedVersionString = shortenedVersion.toString();
          dependenciesJSON2[name] = shortenedVersionString;
          return dependenciesJSON2;
        }, {}), json = dependenciesJSON;
        return json;
      }
      static fromJSON(json) {
        const dependenciesJSON = json, dependenciesJSONKeys = Object.keys(dependenciesJSON), names = dependenciesJSONKeys, array = names.map((name) => {
          const shortenedVersionString = dependenciesJSON[name], string = shortenedVersionString, shortenedVersion = _shortenedVersion.default.fromString(string), dependency = _dependency.default.fromNameAndShortenedVersion(name, shortenedVersion);
          return dependency;
        }), dependencies = new Dependencies(array);
        return dependencies;
      }
      static fromNothing() {
        const array = [], dependencies = new Dependencies(array);
        return dependencies;
      }
    };
  });

  // node_modules/occam-model/lib/utilities/query.js
  var require_query5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get nodeQuery() {
        return nodeQuery;
      },
      get nodesQuery() {
        return nodesQuery;
      }
    });
    var _occamquery = require_lib5();
    function nodeQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        node = nodes.shift() || null;
        return node;
      };
    }
    function nodesQuery(expressionString) {
      const query = _occamquery.Query.fromExpressionString(expressionString);
      return function(node) {
        const nodes = query.execute(node);
        return nodes;
      };
    }
  });

  // node_modules/occam-model/lib/utilities/validate.js
  var require_validate2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get isStringShortenedVersionString() {
        return isStringShortenedVersionString;
      },
      get isStringVersionString() {
        return isStringVersionString;
      }
    });
    function isStringVersionString(string) {
      return /(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))/.test(string);
    }
    function isStringShortenedVersionString(string) {
      return /(?:0|([1-9]\d*))\.(?:0|([1-9]\d*))/.test(string);
    }
  });

  // node_modules/occam-model/lib/propertyNames.js
  var require_propertyNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get DEPENDENCIES_PROPERTY_NAME() {
        return DEPENDENCIES_PROPERTY_NAME;
      },
      get REPOSITORY_PROPERTY_NAME() {
        return REPOSITORY_PROPERTY_NAME;
      },
      get VERSION_PROPERTY_NAME() {
        return VERSION_PROPERTY_NAME;
      }
    });
    var VERSION_PROPERTY_NAME = "version";
    var REPOSITORY_PROPERTY_NAME = "repository";
    var DEPENDENCIES_PROPERTY_NAME = "dependencies";
  });

  // node_modules/occam-model/lib/utilities/metaJSON.js
  var require_metaJSON = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get dependenciesFromDocumentNode() {
        return dependenciesFromDocumentNode;
      },
      get dependencyNamesFromDocumentNode() {
        return dependencyNamesFromDocumentNode;
      },
      get documentNodeFromMetaJSONFile() {
        return documentNodeFromMetaJSONFile;
      },
      get isMetaJSONFileValid() {
        return isMetaJSONFileValid;
      },
      get repositoryFromDocumentNode() {
        return repositoryFromDocumentNode;
      },
      get updateMetaJSONFileVersion() {
        return updateMetaJSONFileVersion;
      },
      get versionFromDocumentNode() {
        return versionFromDocumentNode;
      }
    });
    var _occamgrammars = require_lib11();
    var _version = /* @__PURE__ */ _interop_require_default(require_version3());
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _dependencies = /* @__PURE__ */ _interop_require_default(require_dependencies());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    var _constants = require_constants12();
    var _content = require_content3();
    var _query = require_query5();
    var _validate = require_validate2();
    var _propertyNames = require_propertyNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var jsonLexer = _occamgrammars.JSONLexer.fromNothing();
    var jsonParser = _occamgrammars.JSONParser.fromNothing();
    var errorNodesQuery = (0, _query.nodesQuery)("/*/error");
    var propertyNodesQuery = (0, _query.nodesQuery)("/property/json/object/property");
    var documentPropertyNodesQuery = (0, _query.nodesQuery)("/document/json/object/property");
    var propertyStringLiteralTerminalNodeQuery = (0, _query.nodeQuery)("/property/@string-literal");
    var propertyJSONStringLiteralTerminalNodeQuery = (0, _query.nodeQuery)("/property/json/@string-literal!");
    function isMetaJSONFileValid(metaJSONFile) {
      let metaJSONFileValid = false;
      const documentNode = documentNodeFromMetaJSONFile(metaJSONFile);
      if (documentNode !== null) {
        const errorNodes = errorNodesQuery(documentNode), errorNodesLength = errorNodes.length;
        if (errorNodesLength === 0) {
          const version = versionFromDocumentNode(documentNode), repository = repositoryFromDocumentNode(documentNode), dependencies = dependenciesFromDocumentNode(documentNode);
          metaJSONFileValid = version !== null && repository !== null && dependencies !== null;
        }
      }
      return metaJSONFileValid;
    }
    function updateMetaJSONFileVersion(metaJSONFile, version) {
      const documentNode = documentNodeFromMetaJSONFile(metaJSONFile), repository = repositoryFromDocumentNode(documentNode);
      let dependencies = dependenciesFromDocumentNode(documentNode);
      const string = version.toString(), dependenciesJSON = dependencies.toJSON();
      version = string;
      dependencies = dependenciesJSON;
      const metaJSON = {
        version,
        repository,
        dependencies
      }, metaJSONString = JSON.stringify(metaJSON, null, _constants.DOUBLE_SPACE), metaJSONFileContent = metaJSONString;
      metaJSONFile.setContent(metaJSONFileContent);
    }
    function documentNodeFromMetaJSONFile(metaJSONFile) {
      let documentNode = null;
      if (metaJSONFile !== null) {
        const content = metaJSONFile.getContent(), tokens = jsonLexer.tokenise(content), node = jsonParser.parse(tokens);
        documentNode = node;
      }
      return documentNode;
    }
    function versionFromDocumentNode(documentNode) {
      let version = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.VERSION_PROPERTY_NAME) {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringVersionString = (0, _validate.isStringVersionString)(string);
            if (stringVersionString) {
              version = _version.default.fromString(string);
            }
            return true;
          }
        }
      });
      return version;
    }
    function repositoryFromDocumentNode(documentNode) {
      let repository = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.REPOSITORY_PROPERTY_NAME) {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode);
          if (stringPropertyValue !== null) {
            repository = stringPropertyValue;
            return true;
          }
        }
      });
      return repository;
    }
    function dependenciesFromDocumentNode(documentNode) {
      let dependencies = null;
      const dependenciesPropertyNode = dependenciesPropertyNodeFromDocumentNode(documentNode);
      if (dependenciesPropertyNode !== null) {
        dependencies = _dependencies.default.fromNothing();
        const propertyNode = dependenciesPropertyNode, propertyNodes = propertyNodesQuery(propertyNode);
        propertyNodes.forEach((propertyNode2) => {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode2);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringShortenedVersionString = (0, _validate.isStringShortenedVersionString)(string);
            if (stringShortenedVersionString) {
              const propertyName = propertyNameFromPropertyNode(propertyNode2), name = propertyName, shortenedVersion = _shortenedVersion.default.fromString(string), dependency = _dependency.default.fromNameAndShortenedVersion(name, shortenedVersion);
              dependencies.addDependency(dependency);
            }
          }
        });
      }
      return dependencies;
    }
    function dependencyNamesFromDocumentNode(documentNode) {
      let dependencyNames = null;
      const dependenciesPropertyNode = dependenciesPropertyNodeFromDocumentNode(documentNode);
      if (dependenciesPropertyNode !== null) {
        dependencyNames = [];
        const propertyNode = dependenciesPropertyNode, propertyNodes = propertyNodesQuery(propertyNode);
        propertyNodes.forEach((propertyNode2) => {
          const stringPropertyValue = stringPropertyValueFromPropertyNode(propertyNode2);
          if (stringPropertyValue !== null) {
            const string = stringPropertyValue, stringShortenedVersionString = (0, _validate.isStringShortenedVersionString)(string);
            if (stringShortenedVersionString) {
              const propertyName = propertyNameFromPropertyNode(propertyNode2), dependencyName = propertyName;
              dependencyNames.push(dependencyName);
            }
          }
        });
      }
      return dependencyNames;
    }
    var _default = {
      isMetaJSONFileValid,
      updateMetaJSONFileVersion,
      documentNodeFromMetaJSONFile,
      versionFromDocumentNode,
      repositoryFromDocumentNode,
      dependenciesFromDocumentNode,
      dependencyNamesFromDocumentNode
    };
    function propertyNameFromPropertyNode(propertyNode) {
      const propertyStringLiteralTerminalNode = propertyStringLiteralTerminalNodeQuery(propertyNode), propertyStringLiteralTerminalNodeContent = propertyStringLiteralTerminalNode.getContent(), propertyName = (0, _content.trimDoubleQuotes)(propertyStringLiteralTerminalNodeContent);
      return propertyName;
    }
    function stringPropertyValueFromPropertyNode(propertyNode) {
      let stringPropertyValue = null;
      const propertyJSONStringLiteralTerminalNode = propertyJSONStringLiteralTerminalNodeQuery(propertyNode);
      if (propertyJSONStringLiteralTerminalNode !== null) {
        const propertyJSONStringLiteralTerminalNodeContent = propertyJSONStringLiteralTerminalNode.getContent();
        stringPropertyValue = (0, _content.trimDoubleQuotes)(propertyJSONStringLiteralTerminalNodeContent);
      }
      return stringPropertyValue;
    }
    function documentPropertyNodesFromDocumentNode(documentNode) {
      const documentPropertyNodes = documentPropertyNodesQuery(documentNode);
      return documentPropertyNodes;
    }
    function dependenciesPropertyNodeFromDocumentNode(documentNode) {
      let dependenciesPropertyNode = null;
      const documentPropertyNodes = documentPropertyNodesFromDocumentNode(documentNode);
      documentPropertyNodes.some((documentPropertyNode) => {
        const propertyNode = documentPropertyNode, propertyName = propertyNameFromPropertyNode(propertyNode);
        if (propertyName === _propertyNames.DEPENDENCIES_PROPERTY_NAME) {
          dependenciesPropertyNode = propertyNode;
          return true;
        }
      });
      return dependenciesPropertyNode;
    }
  });

  // node_modules/occam-model/lib/mixins/metaJSON.js
  var require_metaJSON2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _metaJSON = require_metaJSON();
    function getVersion() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), version = (0, _metaJSON.versionFromDocumentNode)(documentNode);
      return version;
    }
    function getRepository() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), repository = (0, _metaJSON.repositoryFromDocumentNode)(documentNode);
      return repository;
    }
    function getDependencies() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), dependencies = (0, _metaJSON.dependenciesFromDocumentNode)(documentNode);
      return dependencies;
    }
    function getDependencyNames() {
      const metaJSONFile = this.getMetaJSONFile(), documentNode = (0, _metaJSON.documentNodeFromMetaJSONFile)(metaJSONFile), dependencyNames = (0, _metaJSON.dependencyNamesFromDocumentNode)(documentNode);
      return dependencyNames;
    }
    var metaJSONMixins = {
      getVersion,
      getRepository,
      getDependencies,
      getDependencyNames
    };
    var _default = metaJSONMixins;
  });

  // node_modules/occam-model/lib/mixins/vocabulary.js
  var require_vocabulary2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _constants = require_constants12();
    var _name = require_name5();
    var _fileNames = require_fileNames();
    function getVocabulary(vocabularyFileName) {
      let vocabulary = _constants.EMPTY_STRING;
      const customGrammarVocabularyFiles = this.getCustomGrammarVocabularyFiles(), customGrammarVocabularyFile = customGrammarVocabularyFiles.find((customGrammarVocabularyFile2) => {
        const customGrammarVocabularyFilePath = customGrammarVocabularyFile2.getPath(), customGrammarVocabularyFileName = (0, _name.fileNameFromFilePath)(customGrammarVocabularyFilePath);
        if (customGrammarVocabularyFileName === vocabularyFileName) {
          return true;
        }
      }) || null;
      if (customGrammarVocabularyFile !== null) {
        const customGrammarVocabularyFileContent = customGrammarVocabularyFile.getContent();
        vocabulary = customGrammarVocabularyFileContent;
      }
      return vocabulary;
    }
    function getTypeVocabulary() {
      const fileName = _fileNames.TYPE_VOCABULARY_FILE_NAME, vocabulary = this.getVocabulary(fileName), typeVocabulary = vocabulary;
      return typeVocabulary;
    }
    function getSymbolVocabulary() {
      const fileName = _fileNames.SYMBOL_VOCABULARY_FILE_NAME, vocabulary = this.getVocabulary(fileName), symbolVocabulary = vocabulary;
      return symbolVocabulary;
    }
    var vocabularyMixins = {
      getVocabulary,
      getTypeVocabulary,
      getSymbolVocabulary
    };
    var _default = vocabularyMixins;
  });

  // node_modules/occam-model/lib/entries.js
  var require_entries12 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _necessary = require_browser();
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _files = /* @__PURE__ */ _interop_require_default(require_files());
    var _directory = /* @__PURE__ */ _interop_require_default(require_directory());
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf13());
    var _files1 = /* @__PURE__ */ _interop_require_default(require_files3());
    var _metaJSON = /* @__PURE__ */ _interop_require_default(require_metaJSON2());
    var _vocabulary = /* @__PURE__ */ _interop_require_default(require_vocabulary2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, filter} = _necessary.arrayUtilities;
    var {topmostDirectoryNameFromPath} = _necessary.pathUtilities;
    var Entries = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getTopmostDirectoryName() {
        let topmostDirectoryName = null;
        const firstEntry = first2(this.array);
        if (firstEntry) {
          const firstEntryPath = firstEntry.getPath();
          topmostDirectoryName = topmostDirectoryNameFromPath(firstEntryPath);
          if (topmostDirectoryName === null) {
            topmostDirectoryName = firstEntryPath;
          }
        }
        return topmostDirectoryName;
      }
      removeFileByPath(path) {
        filter(this.array, (entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry, filePath = file.getPath();
            if (filePath === path) {
              return false;
            }
          }
          return true;
        });
      }
      findFile(filePath) {
        const files = this.getFiles(), file = files.findFile((file2) => {
          const filePathMatches = file2.matchFilePath(filePath);
          if (filePathMatches) {
            return true;
          }
        }) || null;
        return file;
      }
      getFiles() {
        const files = _files.default.fromNothing();
        this.mapEntry((entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry;
            files.addFile(file);
          }
        });
        return files;
      }
      getFilePaths() {
        const filePaths = this.reduceEntry((filePaths2, entry) => {
          const entryFile = entry.isFile();
          if (entryFile) {
            const file = entry, filePath = file.getPath();
            filePaths2.push(filePath);
          }
          return filePaths2;
        }, []);
        return filePaths;
      }
      getDirectoryPaths() {
        const directoryPaths = this.reduceEntry((directoryPaths2, entry) => {
          const entryDirectory = entry.isDirectory();
          if (entryDirectory) {
            const directory = entry, directoryPath = directory.getPath();
            directoryPaths2.push(directoryPath);
          }
          return directoryPaths2;
        }, []);
        return directoryPaths;
      }
      matchShortenedVersion(shortenedVersion) {
        const version = this.getVersion(), versionMatchesShortenedVersion = version.matchShortenedVersion(shortenedVersion);
        return versionMatchesShortenedVersion;
      }
      addFile(file) {
        const entry = file;
        this.addEntry(entry);
      }
      addEntry(entry) {
        this.array.push(entry);
      }
      addDirectory(directory) {
        const entry = directory;
        this.addEntry(entry);
      }
      forEachFile(callback) {
        const files = this.getFiles();
        files.forEachFile(callback);
      }
      mapEntry(callback) {
        return this.array.map(callback);
      }
      someEntry(callback) {
        return this.array.some(callback);
      }
      everyEntry(callback) {
        return this.array.every(callback);
      }
      forEachEntry(callback) {
        this.array.forEach(callback);
      }
      reduceEntry(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      toJSON() {
        const entriesJSON = this.array.map((entry) => {
          const entryJSON = entry.toJSON();
          return entryJSON;
        }), json = entriesJSON;
        return json;
      }
      static fromJSON(json) {
        const array = [], entries = new Entries(array), entriesJSON = json;
        entriesJSON.map((entryJSON) => {
          const json2 = entryJSON, file = _file.default.fromJSON(json2), directory = _directory.default.fromJSON(json2), entry = file || directory;
          entries.addEntry(entry);
        });
        return entries;
      }
      static fromEntry(entry) {
        const array = [
          entry
        ], entries = new Entries(array);
        return entries;
      }
      static fromNothing() {
        const array = [], entries = new Entries(array);
        return entries;
      }
    };
    Object.assign(Entries.prototype, _bnf.default);
    Object.assign(Entries.prototype, _files1.default);
    Object.assign(Entries.prototype, _metaJSON.default);
    Object.assign(Entries.prototype, _vocabulary.default);
    var _default = Entries;
  });

  // node_modules/occam-model/lib/mixins/entries.js
  var require_entries13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    function forEachFile(callback) {
      return this.entries.forEachFile(callback);
    }
    function findFile(filePath) {
      return this.entries.findFile(filePath);
    }
    function getBNF() {
      return this.entries.getBNF();
    }
    function getFiles() {
      return this.entries.getFiles();
    }
    function getTermBNF() {
      return this.entries.getTermBNF();
    }
    function getVersion() {
      return this.entries.getVersion();
    }
    function getFilePaths() {
      return this.entries.getFilePaths();
    }
    function getVocabulary() {
      return this.entries.getVocabulary();
    }
    function getRepository() {
      return this.entries.getRepository();
    }
    function getReadmeFile() {
      return this.entries.getReadmeFile();
    }
    function getStatementBNF() {
      return this.entries.getStatementBNF();
    }
    function getDependencies() {
      return this.entries.getDependencies();
    }
    function getTypeVocabulary() {
      return this.entries.getTypeVocabulary();
    }
    function getSymbolVocabulary() {
      return this.entries.getSymbolVocabulary();
    }
    function getMetaJSONFile() {
      return this.entries.getMetaJSONFile();
    }
    function getFurtleFiles() {
      return this.entries.getFurtleFiles();
    }
    function getNominalFiles() {
      return this.entries.getNominalFiles();
    }
    function getDirectoryPaths() {
      return this.entries.getDirectoryPaths();
    }
    function getDependencyNames() {
      return this.entries.getDependencyNames();
    }
    function getCustomGrammarBNFFiles() {
      return this.entries.getCustomGrammarBNFFiles();
    }
    function getCustomGrammarVocabularyFiles() {
      return this.entries.getCustomGrammarVocabularyFiles();
    }
    var entriesMixins = {
      forEachFile,
      findFile,
      getBNF,
      getFiles,
      getTermBNF,
      getVersion,
      getFilePaths,
      getVocabulary,
      getRepository,
      getReadmeFile,
      getStatementBNF,
      getDependencies,
      getTypeVocabulary,
      getSymbolVocabulary,
      getMetaJSONFile,
      getFurtleFiles,
      getNominalFiles,
      getDirectoryPaths,
      getDependencyNames,
      getCustomGrammarBNFFiles,
      getCustomGrammarVocabularyFiles
    };
    var _default = entriesMixins;
  });

  // node_modules/occam-model/lib/project.js
  var require_project = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _entries1 = /* @__PURE__ */ _interop_require_default(require_entries13());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Project = class {
      constructor(name, entries) {
        this.name = name;
        this.entries = entries;
      }
      getName() {
        return this.name;
      }
      getEntries() {
        return this.entries;
      }
      toJSON() {
        const entriesJSON = this.entries.toJSON(), name = this.name, entries = entriesJSON, json = {
          name,
          entries
        };
        return json;
      }
      static fromJSON(json) {
        let {entries} = json;
        const {name} = json, entriesJSON = entries;
        json = entriesJSON;
        entries = _entries.default.fromJSON(json);
        const project = new Project(name, entries);
        return project;
      }
      static fromName(name) {
        const entries = _entries.default.fromNothing(), project = new Project(name, entries);
        return project;
      }
      static fromNameAndEntries(name, entries) {
        const project = new Project(name, entries);
        return project;
      }
    };
    Object.assign(Project.prototype, _entries1.default);
    var _default = Project;
  });

  // node_modules/occam-model/lib/release.js
  var require_release2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _entries1 = /* @__PURE__ */ _interop_require_default(require_entries13());
    var _constants = require_constants12();
    var _metaJSON = require_metaJSON();
    var _filePath = require_filePath();
    var _files = require_files2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Release = class {
      constructor(name, entries) {
        this.name = name;
        this.entries = entries;
      }
      getName() {
        return this.name;
      }
      getEntries() {
        return this.entries;
      }
      updateVersion(version) {
        let repository = this.getRepository(), dependencies = this.getDependencies();
        const versionString = version.toString(), repositoryJSON = repository, dependenciesJSON = dependencies.toJSON();
        version = versionString;
        repository = repositoryJSON;
        dependencies = dependenciesJSON;
        const metaJSONFile = this.getMetaJSONFile(), json = {
          version,
          repository,
          dependencies
        }, jsonString = JSON.stringify(json, null, _constants.DOUBLE_SPACE), file = metaJSONFile, content = jsonString;
        file.setContent(content);
      }
      toJSON() {
        const entriesJSON = this.entries.toJSON(), name = this.name, entries = entriesJSON, json = {
          name,
          entries
        };
        return json;
      }
      static fromJSON(json) {
        let {entries} = json;
        const {name} = json, entriesJSON = entries;
        json = entriesJSON;
        entries = _entries.default.fromJSON(json);
        const release = new Release(name, entries);
        return release;
      }
      static fromProject(project) {
        let release = null, entries = project.getEntries();
        const entriesReleasable = areEntriesReleasable(entries);
        if (entriesReleasable) {
          const name = project.getName(), releasedEntries = releaseEntriesFromEntries(entries);
          entries = releasedEntries;
          release = new Release(name, entries);
        }
        return release;
      }
      static fromNameAndEntries(name, entries) {
        let release = null;
        const entriesReleasable = areEntriesReleasable(entries);
        if (entriesReleasable) {
          release = new Release(name, entries);
        }
        return release;
      }
    };
    Object.assign(Release.prototype, _entries1.default);
    var _default = Release;
    function releaseEntriesFromEntries(entries) {
      const releasedEntries = _entries.default.fromNothing(), files = entries.getFiles();
      files.forEachFile((file) => {
        const filePath = file.getPath(), filePathReleaseFilePath = (0, _filePath.isFilePathReleaseFilePath)(filePath);
        if (filePathReleaseFilePath) {
          const path = filePath, content = file.getContent(), released = true;
          file = _file.default.fromPathContentAndReleased(path, content, released);
          releasedEntries.addFile(file);
        }
      });
      return releasedEntries;
    }
    function areEntriesReleasable(entries) {
      let entriesReleasable = false;
      const files = entries.getFiles(), readmeFile = (0, _files.readmeFileFromFiles)(files), metaJSONFile = (0, _files.metaJSONFileFromFiles)(files);
      if (readmeFile !== null && metaJSONFile !== null) {
        const metaJSONFileValid = (0, _metaJSON.isMetaJSONFileValid)(metaJSONFile);
        if (metaJSONFileValid) {
          entriesReleasable = true;
        }
      }
      return entriesReleasable;
    }
  });

  // node_modules/occam-model/lib/projects.js
  var require_projects = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Projects;
      }
    });
    var _necessary = require_browser();
    var _project = /* @__PURE__ */ _interop_require_default(require_project());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Projects = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        return this.array.length;
      }
      addProject(project) {
        this.array.push(project);
      }
      mapProject(callback) {
        return this.array.map(callback);
      }
      reduceProject(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachProject(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachProject(callback, done) {
        forEach(this.array, callback, done);
      }
      toJSON() {
        const json = this.array.map((project) => {
          const projectJSON = project.toJSON();
          return projectJSON;
        });
        return json;
      }
      static fromJSON(json) {
        const array = json.map((json2) => {
          const project = _project.default.fromJSON(json2);
          return project;
        }), projects = new Projects(array);
        return projects;
      }
      static fromNothing() {
        const array = [], projects = new Projects(array);
        return projects;
      }
    };
  });

  // node_modules/occam-model/lib/releases.js
  var require_releases = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Releases;
      }
    });
    var _necessary = require_browser();
    var _release = /* @__PURE__ */ _interop_require_default(require_release2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {forEach} = _necessary.asynchronousUtilities;
    var Releases = class {
      constructor(array) {
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        return this.array.length;
      }
      addRelease(release) {
        this.array.push(release);
      }
      mapRelease(callback) {
        return this.array.map(callback);
      }
      reduceRelease(callback, initialValue) {
        return this.array.reduce(callback, initialValue);
      }
      forEachRelease(callback) {
        this.array.forEach(callback);
      }
      asynchronousForEachRelease(callback, done) {
        forEach(this.array, callback, done);
      }
      toJSON() {
        const json = this.array.map((release) => {
          const releaseJSON = release.toJSON();
          return releaseJSON;
        });
        return json;
      }
      static fromJSON(json) {
        const array = json.map((json2) => {
          const release = _release.default.fromJSON(json2);
          return release;
        }), releases = new Releases(array);
        return releases;
      }
      static fromNothing() {
        const array = [], releases = new Releases(array);
        return releases;
      }
    };
  });

  // node_modules/occam-model/lib/index.js
  var require_lib13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get Dependencies() {
        return _dependencies.default;
      },
      get Dependency() {
        return _dependency.default;
      },
      get Directory() {
        return _directory.default;
      },
      get Entries() {
        return _entries.default;
      },
      get File() {
        return _file.default;
      },
      get Files() {
        return _files.default;
      },
      get Project() {
        return _project.default;
      },
      get Projects() {
        return _projects.default;
      },
      get Release() {
        return _release.default;
      },
      get Releases() {
        return _releases.default;
      },
      get ShortenedVersion() {
        return _shortenedVersion.default;
      },
      get Version() {
        return _version.default;
      },
      get contentUtilities() {
        return _content.default;
      },
      get fileNames() {
        return _fileNames.default;
      },
      get filePathUtilities() {
        return _filePath.default;
      },
      get metaJSONUtilities() {
        return _metaJSON.default;
      }
    });
    var _file = /* @__PURE__ */ _interop_require_default(require_file2());
    var _files = /* @__PURE__ */ _interop_require_default(require_files());
    var _version = /* @__PURE__ */ _interop_require_default(require_version3());
    var _entries = /* @__PURE__ */ _interop_require_default(require_entries12());
    var _project = /* @__PURE__ */ _interop_require_default(require_project());
    var _release = /* @__PURE__ */ _interop_require_default(require_release2());
    var _projects = /* @__PURE__ */ _interop_require_default(require_projects());
    var _releases = /* @__PURE__ */ _interop_require_default(require_releases());
    var _directory = /* @__PURE__ */ _interop_require_default(require_directory());
    var _fileNames = /* @__PURE__ */ _interop_require_default(require_fileNames());
    var _dependency = /* @__PURE__ */ _interop_require_default(require_dependency2());
    var _dependencies = /* @__PURE__ */ _interop_require_default(require_dependencies());
    var _shortenedVersion = /* @__PURE__ */ _interop_require_default(require_shortenedVersion());
    var _content = /* @__PURE__ */ _interop_require_default(require_content3());
    var _filePath = /* @__PURE__ */ _interop_require_default(require_filePath());
    var _metaJSON = /* @__PURE__ */ _interop_require_default(require_metaJSON());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // node_modules/occam-languages/lib/utilities/releaseContext.js
  var require_releaseContext = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get releaseContextFromJSON() {
        return releaseContextFromJSON;
      },
      get releaseContextFromProject() {
        return releaseContextFromProject;
      },
      get releaseContextFromRelease() {
        return releaseContextFromRelease;
      }
    });
    var _occammodel = require_lib13();
    var _release = /* @__PURE__ */ _interop_require_default(require_release());
    var _customGrammar = require_customGrammar3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {isMetaJSONFileValid} = _occammodel.metaJSONUtilities;
    function releaseContextFromJSON(json, context2) {
      const {log, callback} = context2, {name} = json;
      ({context: context2} = json);
      let {entries} = json;
      json = entries;
      entries = _occammodel.Entries.fromJSON(json);
      const contextJSON = context2;
      json = contextJSON;
      const customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries), releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
      return releaseContext;
    }
    function releaseContextFromProject(project, context2) {
      let releaseContext = null;
      if (project !== null) {
        const metaJSONFile = project.getMetaJSONFile();
        if (metaJSONFile !== null) {
          const metaJSONFileValid = isMetaJSONFileValid(metaJSONFile);
          if (metaJSONFileValid) {
            const {log, callback} = context2, name = project.getName(), json = null, entries = project.getEntries(), customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries);
            releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
          }
        }
      }
      return releaseContext;
    }
    function releaseContextFromRelease(release, context2) {
      let releaseContext = null;
      if (release !== null) {
        const {log, callback} = context2, name = release.getName(), json = null, entries = release.getEntries(), customGrammar = (0, _customGrammar.customGrammarFromNameAndEntries)(name, entries);
        releaseContext = _release.default.fromLogNameJSONEntriesCallbackAndCustomGrammar(log, name, json, entries, callback, customGrammar);
      }
      return releaseContext;
    }
    var _default = {
      releaseContextFromJSON,
      releaseContextFromProject,
      releaseContextFromRelease
    };
  });

  // node_modules/occam-languages/lib/index.js
  var require_lib14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get AsyncPass() {
        return _async.default;
      },
      get Context() {
        return _context.default;
      },
      get Element() {
        return _element.default;
      },
      get EquivalencePass() {
        return _equivalence.default;
      },
      get FileContext() {
        return _file.default;
      },
      get ForwardPass() {
        return _forward.default;
      },
      get Log() {
        return _log.default;
      },
      get NonTerminalNode() {
        return _nonTerminalNode.default;
      },
      get ReleaseContext() {
        return _release.default;
      },
      get SimplePass() {
        return _simple.default;
      },
      get ZipPass() {
        return _zip.default;
      },
      get asynchronousUtilities() {
        return _asynchronous.default;
      },
      get fileContextUtilities() {
        return _fileContext.default;
      },
      get nodeUtilities() {
        return _node.default;
      },
      get queryUtilities() {
        return _query.default;
      },
      get releaseContextUtilities() {
        return _releaseContext.default;
      },
      get verificationUtilities() {
        return _verification.default;
      }
    });
    var _log = /* @__PURE__ */ _interop_require_default(require_log());
    var _element = /* @__PURE__ */ _interop_require_default(require_element4());
    var _context = /* @__PURE__ */ _interop_require_default(require_context());
    var _file = /* @__PURE__ */ _interop_require_default(require_file());
    var _release = /* @__PURE__ */ _interop_require_default(require_release());
    var _nonTerminalNode = /* @__PURE__ */ _interop_require_default(require_nonTerminalNode2());
    var _zip = /* @__PURE__ */ _interop_require_default(require_zip());
    var _async = /* @__PURE__ */ _interop_require_default(require_async2());
    var _simple = /* @__PURE__ */ _interop_require_default(require_simple());
    var _forward = /* @__PURE__ */ _interop_require_default(require_forward());
    var _equivalence = /* @__PURE__ */ _interop_require_default(require_equivalence());
    var _node = /* @__PURE__ */ _interop_require_default(require_node4());
    var _query = /* @__PURE__ */ _interop_require_default(require_query4());
    var _fileContext = /* @__PURE__ */ _interop_require_default(require_fileContext());
    var _verification = /* @__PURE__ */ _interop_require_default(require_verification());
    var _asynchronous = /* @__PURE__ */ _interop_require_default(require_asynchronous2());
    var _releaseContext = /* @__PURE__ */ _interop_require_default(require_releaseContext());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/elements.js
  var require_elements2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get define() {
        return define;
      }
    });
    var elements = {};
    function define(Element) {
      const {name} = Element;
      elements[name] = Element;
      return Element;
    }
    var _default = elements;
  });

  // lib/element/step.js
  var require_step = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, arrayAssignment, objectAssigment, variablessAssignment) {
        super(context2, string, node);
        this.arrayAssignment = arrayAssignment;
        this.objectAssigment = objectAssigment;
        this.variablessAssignment = variablessAssignment;
      }
      getArrayAssignment() {
        return this.arrayAssignment;
      }
      getObjectAssigment() {
        return this.objectAssigment;
      }
      getVariablessAssignment() {
        return this.variablessAssignment;
      }
      async evaluate(context2) {
        if (false) {
        } else if (this.arrayAssignment !== null) {
          this.arrayAssignment.evaluate(context2);
        } else if (this.objectAssigment !== null) {
          this.objectAssigment.evaluate(context2);
        } else if (this.variablessAssignment !== null) {
          await this.variablessAssignment.evaluate(context2);
        }
      }
    }, __publicField(_a, "name", "Step"), _a));
  });

  // lib/exception.js
  var require_exception = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Exception;
      }
    });
    var Exception = class {
      constructor(message) {
        this.message = message;
      }
      getMessage() {
        return this.message;
      }
      static fromMessage(message) {
        const exception = new Exception(message);
        return exception;
      }
    };
  });

  // lib/types.js
  var require_types3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN_TYPE() {
        return BOOLEAN_TYPE;
      },
      get NODES_TYPE() {
        return NODES_TYPE;
      },
      get NODE_TYPE() {
        return NODE_TYPE;
      },
      get NUMBER_TYPE() {
        return NUMBER_TYPE;
      },
      get STRING_TYPE() {
        return STRING_TYPE;
      }
    });
    var NODE_TYPE = "Node";
    var NODES_TYPE = "Nodes";
    var STRING_TYPE = "String";
    var NUMBER_TYPE = "Number";
    var BOOLEAN_TYPE = "Boolean";
  });

  // lib/nullNode.js
  var require_nullNode = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var NullNode = class {
      static fromNothing() {
        const nullNode2 = new NullNode();
        return nullNode2;
      }
    };
    var nullNode = NullNode.fromNothing();
    var _default = nullNode;
  });

  // lib/constants.js
  var require_constants13 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CONJUNCTION_OPERATOR() {
        return CONJUNCTION_OPERATOR;
      },
      get DISJUNCTION_OPERATOR() {
        return DISJUNCTION_OPERATOR;
      },
      get EMPTY_STRING() {
        return EMPTY_STRING;
      },
      get FALSE() {
        return FALSE;
      },
      get NOT_EQUAL_TO() {
        return NOT_EQUAL_TO;
      },
      get NULL() {
        return NULL;
      },
      get TRUE() {
        return TRUE;
      }
    });
    var NULL = "null";
    var TRUE = "true";
    var FALSE = "false";
    var EMPTY_STRING = "";
    var NOT_EQUAL_TO = "!=";
    var CONJUNCTION_OPERATOR = "&&";
    var DISJUNCTION_OPERATOR = "||";
  });

  // lib/utilities/stringLiteral.js
  var require_stringLiteral6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get stringFromStringLiteral() {
        return stringFromStringLiteral;
      },
      get stringLiteralFromString() {
        return stringLiteralFromString;
      }
    });
    var _constants = require_constants13();
    function stringFromStringLiteral(stringLiteral) {
      const string = stringLiteral.replace(/(^"|"$)/g, _constants.EMPTY_STRING);
      return string;
    }
    function stringLiteralFromString(string) {
      const stringLiteral = `"${string}"`;
      return stringLiteral;
    }
  });

  // lib/utilities/string.js
  var require_string5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get anonymousProcedureStringFromTypeParametersAndReturnBlock() {
        return anonymousProcedureStringFromTypeParametersAndReturnBlock;
      },
      get everyStringFromVariableAndAnonymousProcedure() {
        return everyStringFromVariableAndAnonymousProcedure;
      },
      get expressionStringFromProperties() {
        return expressionStringFromProperties;
      },
      get nodePropertiesStringFromNodePropertiesArray() {
        return nodePropertiesStringFromNodePropertiesArray;
      },
      get nodePropertyStringFromNameAndType() {
        return nodePropertyStringFromNameAndType;
      },
      get primtiveStringFromBoolean() {
        return primtiveStringFromBoolean;
      },
      get primtiveStringFromNode() {
        return primtiveStringFromNode;
      },
      get primtiveStringFromNodes() {
        return primtiveStringFromNodes;
      },
      get primtiveStringFromStringLiteral() {
        return primtiveStringFromStringLiteral;
      },
      get procedureDeclarationStringFromProcedure() {
        return procedureDeclarationStringFromProcedure;
      },
      get procedureStringFromTypeLabelParametersAndReturnBlock() {
        return procedureStringFromTypeLabelParametersAndReturnBlock;
      },
      get reduceStringFromVariableInitialExpressionAndAnonymousProcedure() {
        return reduceStringFromVariableInitialExpressionAndAnonymousProcedure;
      },
      get returnBlockStringFromReturnStatementNode() {
        return returnBlockStringFromReturnStatementNode;
      },
      get someStringFromVariableAndAnonymousProcedure() {
        return someStringFromVariableAndAnonymousProcedure;
      },
      get termStringFromProperties() {
        return termStringFromProperties;
      },
      get termsStringFromTermsArray() {
        return termsStringFromTermsArray;
      },
      get ternaryStringFromTerm() {
        return ternaryStringFromTerm;
      },
      get variableAssignmentStringFromTypeAndVariable() {
        return variableAssignmentStringFromTypeAndVariable;
      },
      get variableAssignmentStringFromTypeAndVariableAssignmentsArray() {
        return variableAssignmentStringFromTypeAndVariableAssignmentsArray;
      },
      get variableAssignmentStringFromVariableAssignment() {
        return variableAssignmentStringFromVariableAssignment;
      },
      get variableStringFromName() {
        return variableStringFromName;
      }
    });
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _constants = require_constants13();
    var _stringLiteral = require_stringLiteral6();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ternaryStringFromTerm(term) {
      const termString = term.getString(), ternaryString = `if (${termString}) { ... } else { ... }`;
      return ternaryString;
    }
    function variableStringFromName(name) {
      const variableString = name;
      return variableString;
    }
    function primtiveStringFromNode(node, context2) {
      const primtiveString = node === _nullNode.default ? _constants.NULL : context2.nodeAsString(node);
      return primtiveString;
    }
    function primtiveStringFromNodes(nodes, context2) {
      const string = context2.nodesAsString(nodes), primtiveString = string;
      return primtiveString;
    }
    function termStringFromProperties(properties) {
      let termString;
      properties.forEach((property) => {
        if (property !== null) {
          const propertyString = property.getString();
          termString = propertyString;
        }
      });
      return termString;
    }
    function primtiveStringFromBoolean(boolean) {
      const expresssionString = `${boolean}`;
      return expresssionString;
    }
    function termsStringFromTermsArray(termsArray) {
      const termsString = termsArray.reduce((termsString2, term) => {
        const termString = term.getString();
        termsString2 = termsString2 === null ? termString : `${termsString2}, ${termString}`;
        return termsString2;
      }, null);
      return termsString;
    }
    function expressionStringFromProperties(properties) {
      let expressionString;
      properties.forEach((property) => {
        if (property !== null) {
          const propertyString = property.getString();
          expressionString = propertyString;
        }
      });
      return expressionString;
    }
    function primtiveStringFromStringLiteral(stringLiteral) {
      const string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral), primtiveString = string;
      return primtiveString;
    }
    function nodePropertyStringFromNameAndType(name, type) {
      const typeString = type, nameString = name, nodePropertyString = `${typeString} ${nameString}`;
      return nodePropertyString;
    }
    function procedureDeclarationStringFromProcedure(procedure) {
      const type = procedure.getType(), label = procedure.getLabel(), parameters = procedure.getParameters(), returnStatement = procedure.getReturnStatement(), labelString = label.getString(), parametersString = parameters.getString(), returnStatementString = returnStatement.getString(), procedureDelcarationString = `${type} ${labelString}(${parametersString}) { ... ${returnStatementString} }`;
      return procedureDelcarationString;
    }
    function returnBlockStringFromReturnStatementNode(returnStatement) {
      const returnStatementString = returnStatement.getString(), returnBlockString = `{ ... ${returnStatementString} }`;
      return returnBlockString;
    }
    function nodePropertiesStringFromNodePropertiesArray(nodePropertiesArray) {
      const nodePropertiesString = nodePropertiesArray.reduce((nodePropertiesString2, nodeProperty) => {
        const nodePropertyString = nodeProperty.getString();
        nodePropertiesString2 = nodePropertiesString2 === null ? nodePropertyString : `${nodePropertiesString2}, ${nodePropertyString}`;
        return nodePropertiesString2;
      }, null);
      return nodePropertiesString;
    }
    function variableAssignmentStringFromTypeAndVariable(type, variable) {
      const variableString = variable.getString(), variableAssignmentString = `${type} ${variableString} = ... ;`;
      return variableAssignmentString;
    }
    function someStringFromVariableAndAnonymousProcedure(variable, anonymousProcedure) {
      const variableString = variable.getString(), anonymousProcedureString = anonymousProcedure.getString(), someString = `Some(${variableString}, ${anonymousProcedureString}) `;
      return someString;
    }
    function everyStringFromVariableAndAnonymousProcedure(variable, anonymousProcedure) {
      const variableString = variable.getString(), anonymousProcedureString = anonymousProcedure.getString(), everyString = `Every(${variableString}, ${anonymousProcedureString}) `;
      return everyString;
    }
    function variableAssignmentStringFromVariableAssignment(variableAssignment) {
      const variable = variableAssignment.getVariable(), variableString = variable.getString(), variableAssignmentString = `${variableString} = ...`;
      return variableAssignmentString;
    }
    function procedureStringFromTypeLabelParametersAndReturnBlock(type, label, parameters, returnBlock) {
      const typeString = type, labelString = label.getString(), parametersString = parameters.getString(), returnBlockString = returnBlock.getString(), procedureString = `${typeString} ${labelString}(${parametersString}) ${returnBlockString}`;
      return procedureString;
    }
    function anonymousProcedureStringFromTypeParametersAndReturnBlock(type, parameters, returnBlock) {
      const typeString = type, parametersString = parameters.getString(), returnBlockString = returnBlock.getString(), anonymousProcedureString = `${typeString} (${parametersString}) ${returnBlockString}`;
      return anonymousProcedureString;
    }
    function variableAssignmentStringFromTypeAndVariableAssignmentsArray(type, variableAssignmentsArray) {
      let variableAssignmentsString = variableAssignmentsArray.reduce((variableAssignmentsString2, variableAssignment) => {
        const variableAssignmentString = variableAssignmentStringFromVariableAssignment(variableAssignment);
        variableAssignmentsString2 = variableAssignmentsString2 === null ? variableAssignmentString : `${variableAssignmentsString2}, ${variableAssignmentString}`;
        return variableAssignmentsString2;
      }, null);
      variableAssignmentsString = `${type} ${variableAssignmentsString} ;`;
      return variableAssignmentsString;
    }
    function reduceStringFromVariableInitialExpressionAndAnonymousProcedure(variable, initialExpression, anonymousProcedure) {
      const variableString = variable.getString(), initialExpressionString = initialExpression.getString(), anonymousProcedureString = anonymousProcedure.getString(), reduceString = `Reduce(${variableString}, ${anonymousProcedureString}, ${initialExpressionString})`;
      return reduceString;
    }
  });

  // lib/utilities/primitive.js
  var require_primitive = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get primitiveFromBoolean() {
        return primitiveFromBoolean;
      },
      get primitiveFromNode() {
        return primitiveFromNode;
      },
      get primitiveFromNodes() {
        return primitiveFromNodes;
      },
      get primitiveFromStringLiteral() {
        return primitiveFromStringLiteral;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _types = require_types3();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function primitiveFromNode(node, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromNode)(node, context2), string = primitiveString, type = _types.NODE_TYPE, value = node;
      node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromNodes(nodes, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromNodes)(nodes, context2), string = primitiveString, type = _types.NODES_TYPE, value = nodes, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromBoolean(boolean, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromBoolean)(boolean), string = primitiveString, type = _types.BOOLEAN_TYPE, value = boolean, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function primitiveFromStringLiteral(stringLiteral, context2) {
      const {Primitive} = _elements.default, primitiveString = (0, _string.primtiveStringFromStringLiteral)(stringLiteral), string = primitiveString, type = _types.STRING_TYPE, value = stringLiteral, node = null;
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    var _default = {
      primitiveFromNode,
      primitiveFromNodes,
      primitiveFromBoolean,
      primitiveFromStringLiteral
    };
  });

  // lib/utilities/term.js
  var require_term = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get termFromBoolean() {
        return termFromBoolean;
      },
      get termFromNode() {
        return termFromNode;
      },
      get termFromNodes() {
        return termFromNodes;
      },
      get termFromPrimitive() {
        return termFromPrimitive;
      },
      get termFromStringLiteral() {
        return termFromStringLiteral;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _primitive = require_primitive();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function termFromNode(node, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromNode)(node, context2), string = primitive.getString();
      node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromNodes(nodes, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromNodes)(nodes, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromBoolean(boolean, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromBoolean)(boolean, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromStringLiteral(stringLiteral, context2) {
      const {Term} = _elements.default, variable = null, primitive = (0, _primitive.primitiveFromStringLiteral)(stringLiteral, context2), string = primitive.getString(), node = null;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    function termFromPrimitive(primitive) {
      const {Term} = _elements.default, context2 = null, string = primitive.getString(), node = null, variable = null, term = new Term(context2, string, node, variable, primitive);
      return term;
    }
    var _default = {
      termFromNode,
      termFromNodes,
      termFromBoolean,
      termFromStringLiteral,
      termFromPrimitive
    };
  });

  // lib/element/some.js
  var require_some = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncSome} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, anonymousProcedure) {
        super(context2, string, node);
        this.variable = variable;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const someString = this.getString();
        context2.trace(`Evaluating the '${someString}' some...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), nodes = primitiveValue, boolean = await asyncSome(nodes, async (node) => {
          let term2;
          term2 = (0, _term.termFromNode)(node, context2);
          const {Terms} = _elements.default, terms = Terms.fromTerm(term2, context2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          const termType2 = term2.getType();
          if (termType2 !== _types.BOOLEAN_TYPE) {
            const termString2 = term2.getString(), message = `The '${termString2}' term's type is '${termType2}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
            throw exception;
          }
          const primitiveValue2 = term2.getPrimitiveValue(), boolean2 = primitiveValue2;
          return boolean2;
        });
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.trace(`...evaluated the '${someString}' some as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Some"), _a));
  });

  // lib/element/term.js
  var require_term2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _types = require_types3();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm) {
        super(context2, string, node);
        this.variable = variable;
        this.primitive = primitive;
        this.negatedTerm = negatedTerm;
        this.logicalTerm = logicalTerm;
        this.bracketedTerm = bracketedTerm;
        this.comparisonTerm = comparisonTerm;
      }
      getVariable() {
        return this.variable;
      }
      getPrimitive() {
        return this.primitive;
      }
      getNegatedTerm() {
        return this.negatedTerm;
      }
      getLogicalTerm() {
        return this.logicalTerm;
      }
      getBreedingTerm() {
        return this.bracketedTerm;
      }
      getComparisonTerm() {
        return this.comparisonTerm;
      }
      getPrimitiveValue() {
        const primitiveValue = this.primitive.getValue();
        return primitiveValue;
      }
      getType() {
        let type;
        if (false) {
        } else if (this.variable !== null) {
          type = this.variable.getType();
        } else if (this.primitive !== null) {
          type = this.primitive.getType();
        } else if (this.negatedTerm !== null) {
          type = this.negatedTerm.getType();
        } else if (this.logicalTerm !== null) {
          type = this.logicalTerm.getType();
        } else if (this.bracketedTerm !== null) {
          type = this.bracketedTerm.getType();
        } else if (this.comparisonTerm !== null) {
          type = this.comparisonTerm.getType();
        }
        return type;
      }
      isBoolean() {
        const type = this.getType(), boolean = type === _types.BOOLEAN_TYPE;
        return boolean;
      }
      evaluate(context2) {
        let term;
        if (false) {
        } else if (this.variable !== null) {
          term = this.variable.evaluate(context2);
        } else if (this.primitive !== null) {
          term = this.primitive.evaluate(context2);
        } else if (this.negatedTerm !== null) {
          term = this.negatedTerm.evaluate(context2);
        } else if (this.logicalTerm !== null) {
          term = this.logicalTerm.evaluate(context2);
        } else if (this.bracketedTerm !== null) {
          term = this.bracketedTerm.evaluate(context2);
        } else if (this.comparisonTerm !== null) {
          term = this.comparisonTerm.evaluate(context2);
        }
        return term;
      }
      isEqualTo(term) {
        let equalTo = false;
        if (false) {
        } else if (this.variable !== null) {
          const variable = term.getVariable();
          if (variable !== null) {
            equalTo = this.variable.isEqualTo(variable);
          }
        } else if (this.primitive !== null) {
          const primitive = term.getPrimitive();
          if (primitive !== null) {
            equalTo = this.primitive.isEqualTo(primitive);
          }
        }
        return equalTo;
      }
      static fromPrimitive(primitive, context2) {
        const primitiveString = primitive.getString(), string = primitiveString, node = null, variable = null, negatedTerm = null, logicalTerm = null, bracketedTerm = null, comparisonTerm = null;
        context2 = null;
        const term = new _a(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm);
        return term;
      }
    }, __publicField(_a, "name", "Term"), _a));
  });

  // lib/element/terms.js
  var require_terms = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _string = require_string5();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getTerm(index) {
        const term = this.array[index] || null;
        return term;
      }
      addTerm(term) {
        this.array.push(term);
      }
      mapTerm(callback) {
        return this.array.map(callback);
      }
      forEachTerm(callback) {
        this.array.forEach(callback);
      }
      evaluate(context2) {
        const termsArray = this.mapTerm((term) => {
          term = term.evaluate(context2);
          return term;
        }), termsString = (0, _string.termsStringFromTermsArray)(termsArray, context2), string = termsString, array = termsArray, node = null;
        context2 = null;
        const terms = new _a(context2, string, node, array);
        return terms;
      }
      static fromTerm(term, context2) {
        const termsArray = [
          term
        ], termsString = (0, _string.termsStringFromTermsArray)(termsArray, context2), string = termsString, array = termsArray, node = null;
        context2 = null;
        const terms = new _a(context2, string, node, array);
        return terms;
      }
    }, __publicField(_a, "name", "Terms"), _a));
  });

  // lib/element/label.js
  var require_label = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, name) {
        super(context2, string, node);
        this.name = name;
      }
      getName() {
        return this.name;
      }
      compareProcedureName(procedureName) {
        const procedureNameCompares = this.name === procedureName;
        return procedureNameCompares;
      }
    }, __publicField(_a, "name", "Label"), _a));
  });

  // lib/element/error.js
  var require_error4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(conterxt, string, node) {
        super(context, string, node);
      }
      verify(context1) {
        const verifies = false, errorString = this.getString();
        context1.warning(`The '${errorString}' error cannot be verified.`);
        return verifies;
      }
    }, __publicField(_a, "name", "Error"), _a));
  });

  // lib/element/every.js
  var require_every = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncEvery} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, anonymousProcedure) {
        super(context2, string, node);
        this.string = string;
        this.variable = variable;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const everyString = this.getString();
        context2.trace(`Evaluating the '${everyString}' every...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = term.getNodes(), boolean = await asyncEvery(nodes, async (node) => {
          let term2;
          const {Terms} = _elements.default;
          term2 = (0, _term.termFromNode)(node, context2);
          const terms = Terms.fromTerm(term2, context2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          const termType2 = term2.getType();
          if (termType2 !== _types.BOOLEAN_TYPE) {
            const termString2 = term2.getString(), message = `The '${termString2}' term's type is '${termType2}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
            throw exception;
          }
          const boolean2 = term2.getBoolean();
          return boolean2;
        });
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.trace(`...evaluated the '${everyString}' every as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Every"), _a));
  });

  // lib/element/reduce.js
  var require_reduce = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {asyncReduce} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, initialExpression, anonymousProcedure) {
        super(context2, string, node);
        this.variable = variable;
        this.initialExpression = initialExpression;
        this.anonymousProcedure = anonymousProcedure;
      }
      getVariable() {
        return this.variable;
      }
      getInitialExpression() {
        return this.initialExpression;
      }
      getAnonymousProcedure() {
        return this.anonymousProcedure;
      }
      async evaluate(context2) {
        let term;
        await this.break(context2);
        const reduceString = this.getString();
        context2.trace(`Evaluating the '${reduceString}' reduce...`);
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = term.getNodes(), initialExpression = await this.initialExpression.evaluate(context2);
        term = await asyncReduce(nodes, async (currentExpression, node) => {
          let term2;
          const {Terms} = _elements.default;
          term2 = currentTerm;
          const terms = Terms.fromTerm(term2, context2);
          term2 = (0, _term.termFromNode)(node, context2);
          terms.addTerm(term2);
          term2 = await this.anonymousProcedure.call(terms, context2);
          return term2;
        }, initialExpression);
        const termString = term.getString();
        context2.trace(`...evaluated the '${reduceString}' reduce as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Reduce"), _a));
  });

  // lib/element/ternary.js
  var require_ternary = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term, ifExpression, elseExpression) {
        super(context2, string, node);
        this.term = term;
        this.ifExpression = ifExpression;
        this.elseExpression = elseExpression;
      }
      getTerm() {
        return this.term;
      }
      getIfBlock() {
        return this.ifExpression;
      }
      getElseBlock() {
        return this.elseExpression;
      }
      async evaluate(context2) {
        let term;
        const ternaryString = this.getString();
        context2.trace(`Evaluating the '${ternaryString}' ternary...`);
        term = this.term.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.BOOLEAN_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's type is '${termType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), boolean = primitiveValue;
        term = boolean ? await this.ifExpression.evaluate(context2) : await this.elseExpression.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${ternaryString}' ternary as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "Ternary"), _a));
  });

  // lib/element/variable.js
  var require_variable = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name, term) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
        this.term = term;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      getTerm() {
        return this.term;
      }
      compareVariableName(variableName) {
        const comparesToVariableName = this.name === variableName;
        return comparesToVariableName;
      }
      evaluate(context2) {
        const variableString = this.getString();
        context2.trace(`Evaluating the '${variableString}' variable...`);
        const nested = true, variableName = this.name, variablePresent = context2.isVariablePresentByVariableName(variableName, nested);
        if (!variablePresent) {
          const message = `The '${variableString}' variable is not present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const variable = context2.findVariableByVariableName(variableName), term = variable.getTerm(), termString = term.getString();
        context2.debug(`...evaluated the '${variableString}' variable as the '${termString}' term.`);
        return term;
      }
      assign(term, context2) {
        const nested = false, termString = term.getString(), variableName = this.name, variableString = this.getString(), variablePresent = context2.isVariablePresentByVariableName(variableName, nested);
        context2.trace(`Assigning the '${termString}' term to the '${variableString}' variable...`);
        if (variablePresent) {
          const message = `The '${variableString}' variable is already present.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const termType = term.getType(), variableType = this.type;
        if (termType !== variableType) {
          const message = `The '${variableString} variable's '${variableType}' type does not compare to the term's '${termType}' type.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.term = term;
        const variable = this;
        context2.addVariable(variable);
        context2.debug(`...assigned the '${termString}' term to the '${variableString}' variable.`);
      }
      static fromParameter(parameter, context2) {
        const type = parameter.getType(), name = parameter.getName(), term = null, variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
      static fromNamedParameter(namedParameter, context2) {
        const aliasedName = namedParameter.getAliasedName(), type = namedParameter.getType(), name = aliasedName, term = null, variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
      static fromTermAndParameter(term, parameter, context2) {
        const type = parameter.getType(), name = parameter.getName(), variableString = (0, _string.variableStringFromName)(name), string = variableString, node = null;
        context2 = null;
        const variable = new _a(context2, string, node, type, name, term);
        return variable;
      }
    }, __publicField(_a, "name", "Variable"), _a));
  });

  // lib/element/primitive.js
  var require_primitive2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var {match} = _necessary.arrayUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, value) {
        super(context2, string, node);
        this.type = type;
        this.value = value;
      }
      getType() {
        return this.type;
      }
      getValue() {
        return this.value;
      }
      evaluate(context2) {
        const {Term} = _elements.default, primitive = this, term = Term.fromPrimitive(primitive, context2);
        return term;
      }
      isEqualTo(primitive) {
        let equalTo = false;
        const type = primitive.getType();
        if (this.type === type) {
          const value = primitive.getValue();
          switch (type) {
            case _types.NODE_TYPE: {
              const nodeA = this.value, nodeB = value, nodeMatches = matchNode(nodeA, nodeB);
              if (nodeMatches) {
                equalTo = true;
              }
              break;
            }
            case _types.NODES_TYPE: {
              const nodesA = this.value, nodesB = value, nodesMatch = matchNodes(nodesA, nodesB);
              if (nodesMatch) {
                equalTo = true;
              }
              break;
            }
            case _types.STRING_TYPE: {
              const stringLiteralA = this.value, stringLiteralB = value;
              if (stringLiteralA === stringLiteralB) {
                equalTo = true;
              }
              break;
            }
            case _types.NUMBER_TYPE: {
              const numberA = this.value, numberB = value;
              if (numberA === numberB) {
                equalTo = true;
              }
              break;
            }
            case _types.BOOLEAN_TYPE: {
              const booleanA = this.value, booleanB = value;
              if (booleanA === booleanB) {
                equalTo = true;
              }
              break;
            }
          }
        }
        return equalTo;
      }
    }, __publicField(_a, "name", "Primitive"), _a));
    function matchNode(nodeA, nodeB) {
      let nodeMatches;
      if (nodeA === _nullNode.default || nodeB === _nullNode.default) {
        nodeMatches = nodeA === nodeB;
      } else if (nodeA === _nullNode.default) {
        nodeMatches = false;
      } else if (nodeB === _nullNode.default) {
        nodeMatches = false;
      } else {
        const nodeAMatchesNodeB = nodeA.match(nodeB);
        nodeMatches = nodeAMatchesNodeB;
      }
      return nodeMatches;
    }
    function matchNodes(nodesA, nodesB) {
      const nodesMatch = match(nodesA, nodesB, (nodeA, nodeB) => {
        const nodeMatches = matchNode(nodeA, nodeB);
        if (nodeMatches) {
          return true;
        }
      });
      return nodesMatch;
    }
  });

  // lib/element/reference.js
  var require_reference2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, name) {
        super(context2, string, node);
        this.name = name;
      }
      getName() {
        return this.name;
      }
      getProcedureName() {
        const procedureName = this.name;
        return procedureName;
      }
    }, __publicField(_a, "name", "Reference"), _a));
  });

  // lib/element/procedure.js
  var require_procedure = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get variablesFromTermsAndParameters() {
        return variablesFromTermsAndParameters;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, label, parameters, returnBlock) {
        super(context2, string, node);
        this.type = type;
        this.label = label;
        this.parameters = parameters;
        this.returnBlock = returnBlock;
      }
      getType() {
        return this.type;
      }
      getLabel() {
        return this.label;
      }
      getParameters() {
        return this.parameters;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      isBoolean() {
        const typeBooleanType = this.type === _types.BOOLEAN_TYPE, boolean = typeBooleanType;
        return boolean;
      }
      getName() {
        return this.label.getName();
      }
      getReturnStatement() {
        return this.returnBlock.getReturnStatement();
      }
      compareProcedureName(procedureName) {
        return this.label.compareProcedureName(procedureName);
      }
      async call(terms, context2) {
        await this.break(context2);
        const procedureString = this.getString();
        context2.trace(`Calling the '${procedureString}' procedure...`);
        this.parameters.compareTerms(terms, context2);
        const variables = variablesFromTermsAndParameters(terms, this.parameters, context2), term = await this.returnBlock.evaluate(variables, context2), termType = term.getType();
        if (this.type !== termType) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type is not equal to the '${procedureString}' procedure's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...called the '${procedureString}' procedure.`);
        return term;
      }
    }, __publicField(_a, "name", "Procedure"), _a));
    function variablesFromTermsAndParameters(terms, parameters, context2) {
      const variables = [];
      terms.forEachTerm((term, index) => {
        const parameter = parameters.getParameter(index);
        if (parameter !== null) {
          const {Variable} = _elements.default, variable = Variable.fromTermAndParameter(term, parameter, context2);
          variables.push(variable);
        }
      });
      return variables;
    }
  });

  // lib/element/nodeQuery.js
  var require_nodeQuery = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2} = _necessary.arrayUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, query) {
        super(context2, string, node);
        this.variable = variable;
        this.query = query;
      }
      getVariable() {
        return this.variable;
      }
      getQuery() {
        return this.query;
      }
      evaluate(context2) {
        let term;
        const nodeQueryString = this.getString();
        context2.trace(`Evaluating the '${nodeQueryString}' node query...`);
        if (this.query === null) {
          const message = `Cannot evaluate the '${nodeQueryString}' node query because its expression is malformed.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let node;
        const primitiveValue = term.getPrimitiveValue();
        node = primitiveValue;
        if (node === null) {
          const termString2 = term.getString(), message = `The '${termString2}' term's node is null.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = this.query.execute(node), nodesLength = nodes.length;
        if (nodesLength !== 1) {
          const message = `The length of the returned nodes is ${nodesLength} when it should be 1.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const firstNode = first2(nodes);
        node = firstNode;
        term = (0, _term.termFromNode)(node, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${nodeQueryString}' node query as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NodeQuery"), _a));
  });

  // lib/element/parameter.js
  var require_parameter = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      compareTerm(term, context2) {
        const termString = term.getString(), parameterString = this.getString();
        context2.trace(`Comparing the '${termString}' term against the '${parameterString}' parameter...`);
        const termType = term.getType();
        if (this.type !== termType) {
          const message = `The '${termString}' term's '${termType}' type is not equal to the '${parameterString}' parameter's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...comparing the '${termString}' term against the '${parameterString}' parameter.`);
      }
    }, __publicField(_a, "name", "Parameter"), _a));
  });

  // lib/element/parameters.js
  var require_parameters = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getParameter(index) {
        const parameter = this.array[index] || null;
        return parameter;
      }
      forEachParameter(callback) {
        this.array.forEach(callback);
      }
      compareTerms(terms, context2) {
        const termsString = terms.getString(), parametersString = this.getString();
        context2.trace(`Comparing the '${termsString}' terms against the '${parametersString}' parameters...`);
        const termsLength = terms.getLength(), parametersLength = this.getLength();
        if (termsLength !== parametersLength) {
          const message = `The '${termsString}' expressions and '${parametersString}' parameters are not of the same length.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.forEachParameter((parameter, index) => {
          if (parameter !== null) {
            const term = terms.getTerm(index);
            parameter.compareTerm(term, context2);
          }
        });
        context2.debug(`...compared the '${termsString}' terms against the '${parametersString}' parameters.`);
      }
    }, __publicField(_a, "name", "Parameters"), _a));
  });

  // lib/element/nodesQuery.js
  var require_nodesQuery = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, query) {
        super(context2, string, node);
        this.variable = variable;
        this.query = query;
      }
      getVariable() {
        return this.variable;
      }
      getQuery() {
        return this.query;
      }
      evaluate(context2) {
        let term;
        const nodesQueryString = this.getString();
        context2.trace(`Evaluating the '${nodesQueryString}' nodes query...`);
        if (this.query === null) {
          const message = `Cannot evaluate the '${nodesQueryString}' nodes query because its expression is malformed.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        term = this.variable.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let node;
        const primitiveValue = term.getPrimitiveValue();
        node = primitiveValue;
        if (node === null) {
          const termString2 = term.getString(), message = `The '${termString2}' term's node is null.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nodes = this.query.execute(node);
        term = (0, _term.termFromNodes)(nodes, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${nodesQueryString}' nodes query as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NodesQuery"), _a));
  });

  // lib/element/expression.js
  var require_expression2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term, some, every, reduce, ternary, nodeQuery, nodesQuery, returnBlock, procedureCall) {
        super(context2, string, node);
        this.term = term;
        this.some = some;
        this.every = every;
        this.reduce = reduce;
        this.ternary = ternary;
        this.nodeQuery = nodeQuery;
        this.nodesQuery = nodesQuery;
        this.returnBlock = returnBlock;
        this.procedureCall = procedureCall;
      }
      getTerm() {
        return this.term;
      }
      getSome() {
        return this.some;
      }
      getEvery() {
        return this.every;
      }
      getReduce() {
        return this.reduce;
      }
      getTernary() {
        return this.ternay;
      }
      getNodeQuery() {
        return this.nodeQuery;
      }
      getNodesQuery() {
        return this.nodesQuery;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      getProcedureCall() {
        return this.procedureCall;
      }
      getType() {
        let type;
        if (false) {
        } else if (this.term !== null) {
          type = this.term.getType();
        } else if (this.some !== null) {
          type = this.some.getType();
        } else if (this.every !== null) {
          type = this.every.getType();
        } else if (this.reduce !== null) {
          type = this.reduce.getType();
        } else if (this.ternary !== null) {
          type = this.ternary.getType();
        } else if (this.nodeQuery !== null) {
          type = this.nodeQuery.getType();
        } else if (this.nodesQuery !== null) {
          type = this.nodesQuery.getType();
        } else if (this.returnBlock !== null) {
          type = this.returnBlock.getType();
        } else if (this.procedureCall !== null) {
          type = this.procedureCall.getType();
        }
        return type;
      }
      async evaluate(context2) {
        let term;
        if (false) {
        } else if (this.term !== null) {
          term = this.term.evaluate(context2);
        } else if (this.nodeQuery !== null) {
          term = this.nodeQuery.evaluate(context2);
        } else if (this.nodesQuery !== null) {
          term = this.nodesQuery.evaluate(context2);
        } else if (this.some !== null) {
          term = await this.some.evaluate(context2);
        } else if (this.every !== null) {
          term = await this.every.evaluate(context2);
        } else if (this.reduce !== null) {
          term = await this.reduce.evaluate(context2);
        } else if (this.ternary !== null) {
          term = await this.ternary.evaluate(context2);
        } else if (this.returnBlock !== null) {
          term = await this.returnBlock.evaluate(context2);
        } else if (this.procedureCall !== null) {
          term = await this.procedureCall.evaluate(context2);
        }
        return term;
      }
    }, __publicField(_a, "name", "Expression"), _a));
  });

  // lib/context/block.js
  var require_block = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BlockContext;
      }
    });
    var _occamlanguages = require_lib14();
    var _necessary = require_browser();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {push} = _necessary.arrayUtilities;
    var BlockContext = class extends _occamlanguages.Context {
      constructor(context2, variables) {
        super(context2);
        this.variables = variables;
      }
      getVariables(nested = true) {
        const variables = [];
        push(variables, this.variables);
        if (nested) {
          const context2 = this.getContext(), contextVariables = context2.getVariables();
          push(variables, contextVariables);
        }
        return variables;
      }
      addVariable(variable) {
        const nested = false, variableName = variable.getName(), variableString = variable.getString(), variablePresent = this.isVariablePresentByVariableName(variableName, nested);
        if (variablePresent) {
          const message = `The '${variableString}' variable is already present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const context2 = this;
        context2.trace(`Added the '${variableString}' variable to the context.`);
        this.variables.push(variable);
      }
      findProcedureByProcedureName(procedureName) {
        const context2 = this.getContext(), procedure = context2.findProcedureByProcedureName(procedureName);
        return procedure;
      }
      isProcedurePresentByProcedureName(procedureName) {
        const context2 = this.getContext(), procedurePresent = context2.isProcedurePresentByProcedureName(procedureName);
        return procedurePresent;
      }
      findVariableByVariableName(variableName, nested = true) {
        const variables = this.getVariables(nested), variable = variables.find((variable2) => {
          const variableComparesToVariableName = variable2.compareVariableName(variableName);
          if (variableComparesToVariableName) {
            return true;
          }
        }) || null;
        return variable;
      }
      isVariablePresentByVariableName(variableName, nested = true) {
        const variable = this.findVariableByVariableName(variableName, nested), variablePresent = variable !== null;
        return variablePresent;
      }
      static fromVariables(variables, context2) {
        const blockContext = _occamlanguages.Context.fromNothing(BlockContext, variables, context2);
        return blockContext;
      }
    };
  });

  // lib/element/returnBlock.js
  var require_returnBlock = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _block = /* @__PURE__ */ _interop_require_default(require_block());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {asyncForEach} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, steps, nonsensical, returnStatement) {
        super(context2, string, node);
        this.steps = steps;
        this.nonsensical = nonsensical;
        this.returnStatement = returnStatement;
      }
      getSteps() {
        return this.steps;
      }
      isNonsensical() {
        return this.nonsensical;
      }
      getReturnStatement() {
        return this.returnStatement;
      }
      async evaluate(variables, context2) {
        if (context2 === void 0) {
          context2 = variables;
          variables = [];
        }
        const returnBlockString = this.getString();
        context2.trace(`Evaluating the '${returnBlockString}' return block...`);
        if (this.nonsensical) {
          const message = `The return block is nonsensical.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const blockContext = _block.default.fromVariables(variables, context2);
        context2 = blockContext;
        await asyncForEach(this.steps, async (step) => {
          await step.evaluate(context2);
        });
        const term = this.returnStatement.evaluate(context2), termString = term.getString();
        context2.debug(`Evaluated... the '${returnBlockString}' return block as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ReturnBlock"), _a));
  });

  // lib/element/term/negated.js
  var require_negated = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, term) {
        super(context2, string, node);
        this.type = type;
        this.term = term;
      }
      getType() {
        return this.type;
      }
      getTerm() {
        return this.term;
      }
      evaluate(context2) {
        let term;
        const negatedTermString = this.getString();
        context2.trace(`Evaluating the '${negatedTermString}' negated term...`);
        term = this.term.evaluate(context2);
        const termType = term.getType();
        if (termType !== _types.BOOLEAN_TYPE) {
          const termString2 = term.getString(), message = `The '${termString2}' left term's type is '${termType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        let boolean;
        const primitiveValue = term.getPrimitiveValue();
        boolean = primitiveValue;
        boolean = !boolean;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${negatedTermString}' negated term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "NegatedTerm"), _a));
  });

  // lib/element/term/logical.js
  var require_logical = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _types = require_types3();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, disjunction, leftTerm, rightTerm) {
        super(context2, string, node);
        this.type = type;
        this.disjunction = disjunction;
        this.leftTerm = leftTerm;
        this.rightTerm = rightTerm;
      }
      getType() {
        return this.type;
      }
      isDisjunction() {
        return this.disjunction;
      }
      getLeftTerm() {
        return this.leftTerm;
      }
      getRightTerm() {
        return this.rightTerm;
      }
      evaluate(context2) {
        let term;
        const logicalTermString = this.getString();
        context2.trace(`Evaluating the '${logicalTermString}' logical term...`);
        const leftTerm = this.leftTerm.evaluate(context2), rightTerm = this.rightTerm.evaluate(context2), leftTermType = leftTerm.getType(), rightTermType = rightTerm.getType();
        if (leftTermType !== _types.BOOLEAN_TYPE) {
          const leftTermString = leftTerm.getString(), message = `The '${leftTermString}' left term's type is '${leftTermType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        if (rightTermType !== _types.BOOLEAN_TYPE) {
          const rightTermString = rightTerm.getString(), message = `The '${rightTermString}' right term's type is '${rightTermType}' when it should be of type '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const leftTermPrimitiveValue = leftTerm.getPrimitiveValue(), rightTermPrimitiveValue = rightTerm.getPrimitiveValue(), leftBoolean = leftTermPrimitiveValue, rightBoolean = rightTermPrimitiveValue, boolean = this.disjunction ? leftBoolean || rightBoolean : leftBoolean && rightBoolean;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${logicalTermString}' logical term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "LogicalTerm"), _a));
  });

  // lib/element/term/bracketed.js
  var require_bracketed = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term) {
        super(context2, string, node);
        this.term = term;
      }
      getTerm() {
        return this.term;
      }
      getType() {
        return this.term.getType();
      }
      evaluate(context2) {
        let term;
        const bracketedTermString = this.getString();
        context2.trace(`Evaluating the '${bracketedTermString}' bracketed term...`);
        term = this.term.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${bracketedTermString}' bracketed term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "BracketedTerm"), _a));
  });

  // lib/element/procedureCall.js
  var require_procedureCall = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, reference, terms) {
        super(context2, string, node);
        this.reference = reference;
        this.terms = terms;
      }
      getReference() {
        return this.reference;
      }
      getTerms() {
        return this.terms;
      }
      getProcedureName() {
        return this.reference.getProcedureName();
      }
      async evaluate(context2) {
        await this.break(context2);
        const procedureCallString = this.getString();
        context2.trace(`Evaluating the '${procedureCallString}' procedure call...`);
        const procedureName = this.getProcedureName(), procedurePresent = context2.isProcedurePresentByProcedureName(procedureName);
        if (!procedurePresent) {
          const message = `The '${procedureCallString} procedure is not present.'`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const procedure = context2.findProcedureByProcedureName(procedureName), terms = this.terms.evaluate(context2), term = await procedure.call(terms, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${procedureCallString}' procedure call as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ProcedureCall"), _a));
  });

  // lib/element/term/comparison.js
  var require_comparison = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, negated, leftTerm, rightTerm) {
        super(context2, string, node);
        this.negated = negated;
        this.leftTerm = leftTerm;
        this.rightTerm = rightTerm;
      }
      isNegated() {
        return this.negated;
      }
      getLeftTerm() {
        return this.leftTerm;
      }
      getRightTerm() {
        return this.rightTerm;
      }
      evaluate(context2) {
        let term;
        const comparisonTermString = this.getString();
        context2.trace(`Evaluating the '${comparisonTermString}' comparison term...`);
        const leftTerm = this.leftTerm.evaluate(context2), rightTerm = this.rightTerm.evaluate(context2), leftTermType = leftTerm.getType(), rightTermType = rightTerm.getType();
        if (leftTermType !== rightTermType) {
          const leftTermString = leftTerm.getString(), rightTermString = rightTerm.getString(), message = `The '${leftTermString}' left term's type is '${leftTermType}' whereas the '${rightTermString}' right term's type is '${rightTermType}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const leftTermEqualToRightTerm = leftTerm.isEqualTo(rightTerm);
        let boolean = leftTermEqualToRightTerm;
        if (this.negated) {
          boolean = !boolean;
        }
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${comparisonTermString}' comparison term as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ComparisonTerm"), _a));
  });

  // lib/element/parameter/named.js
  var require_named = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, name, alias) {
        super(context2, string, node);
        this.type = type;
        this.name = name;
        this.alias = alias;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      getAlias() {
        return this.alias;
      }
      isAliased() {
        const aliased = this.alias !== null;
        return aliased;
      }
      getAliasedName() {
        const aliased = this.isAliased(), aliasedName = aliased ? this.alias : this.name;
        return aliasedName;
      }
      compareTerm(term, context2) {
        const termString = term.getString(), namedParameterString = this.getString();
        context2.trace(`Comparing the '${termString}' term with the '${namedParameterString}' named parameter...`);
        const termType = term.getType();
        if (this.type !== termType) {
          const message = `The '${termString}' term's '${termType}' type is not equal to '${namedParameterString}' named parameter's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${termString}' term with the '${namedParameterString}' named parameter.`);
      }
      compareNamedParameter(namedParameter, context2) {
        let namedParameterCompares;
        const namedParameterA = this, namedParameterB = namedParameter;
        const namedParameterAString = namedParameterA.getString(), namedParameterBString = namedParameterB.getString();
        context2.trace(`Comparing the '${namedParameterAString}' named parameter with the '${namedParameterBString}' named parameter...`);
        const name = namedParameter.getName(), type = namedParameter.getType();
        namedParameterCompares = this.name === name && this.type === type;
        if (namedParameterCompares) {
          context2.debug(`...compared the '${namedParameterAString}' named parameter with the '${namedParameterBString}' named parameter.`);
        }
        return namedParameterCompares;
      }
    }, __publicField(_a, "name", "NamedParameter"), _a));
  });

  // lib/element/assignment/array.js
  var require_array4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _term = require_term();
    var _types = require_types3();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, parameters) {
        super(context2, string, node);
        this.variable = variable;
        this.parameters = parameters;
      }
      getVariable() {
        return this.variable;
      }
      getParameters() {
        return this.parameters;
      }
      evaluate(context2) {
        const arrayAssignmentString = this.getString();
        context2.trace(`Evaluating the '${arrayAssignmentString}' array assignment...`);
        const term = this.variable.evaluate(context2), termType = term.getType();
        if (termType !== _types.NODES_TYPE) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), nodes = primitiveValue, nodesLength = nodes.length, parametersLength = this.parameters.getLength();
        if (parametersLength > nodesLength) {
          const parametersString = this.parameters.getString(), nodesString = context2.nodesAsString(nodex), message = `The length of the '${parametersString}' parameters is greater than the length of the '${nodesString}' nodes.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.parameters.forEachParameter((parameter, index) => {
          if (parameter !== null) {
            const node = nodes[index], term2 = (0, _term.termFromNode)(node, context2);
            this.evaluateParameter(parameter, term2, context2);
          }
        });
        context2.debug(`...evaluated the '${arrayAssignmentString}' array assignment.`);
      }
      evaluateParameter(parameter, expression, context2) {
        const expressionString = expression.getString(), parameterString = parameter.getString();
        context2.trace(`Evaluating the '${parameterString}' parameter against the '${expressionString}' expression...`);
        const parameterType = parameter.getType();
        if (parameterType !== _types.NODE_TYPE) {
          const message = `The type of the '${parameterString}' parameter should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const {Variable} = _elements.default, variable = Variable.fromParameter(parameter, context2);
        variable.assign(expression, context2);
        context2.debug(`...evaluated the '${parameterString}' parameter against the '${expressionString}' expression.`);
      }
    }, __publicField(_a, "name", "ArrayAssignment"), _a));
  });

  // lib/element/statement/return.js
  var require_return = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, term) {
        super(context2, string, node);
        this.term = term;
      }
      getExpression() {
        return this.term;
      }
      evaluate(context2) {
        let term;
        const returnStatementString = this.getString();
        context2.trace(`Evaluating the '${returnStatementString}' return statement...`);
        term = this.term.evaluate(context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${returnStatementString}' return statement as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ReturnStatement"), _a));
  });

  // lib/element/parameters/named.js
  var require_named2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      getLength() {
        const length = this.array.length;
        return length;
      }
      getNamedParameter(index) {
        const namedParameter = this.array[index] || null;
        return namedParameter;
      }
      someNamedParameter(callback) {
        return this.array.some(callback);
      }
      forEachNamedParameter(callback) {
        this.array.forEach(callback);
      }
      compareTerms(terms, context2) {
        const termsString = terms.getString(), namedParametersString = this.getString();
        context2.trace(`Comparing the '${termsString}' terms with the '${namedParametersString}' named parameters...`);
        const termsLength = terms.getLength(), namedParametersLength = this.getLength();
        if (termsLength !== namedParametersLength) {
          const message = `The '${termsString}' terms and '${namedParametersString}' named parameters are not of the same length.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        this.forEachNamedParameter((namedParameter, index) => {
          if (namedParameter !== null) {
            const term = terms.getTerm(index);
            namedParameter.compareTerm(term, context2);
          }
        });
        context2.debug(`...compared the '${termsString}' terms with the '${namedParametersString}' named parameters.`);
      }
      compareNamedParameter(namedParameter, context2) {
        const namedParameterString = namedParameter.getString(), namedParametersString = this.getString();
        context2.trace(`Comparing the '${namedParameterString}' namedParameter with the '${namedParametersString}' named parameters...`);
        const namedParameterA = namedParameter, namedParameterCompares = this.someNamedParameter((namedParameter2) => {
          if (namedParameter2 !== null) {
            const namedParameterB = namedParameter2, namedParameterBComparesToNamedParameterA = namedParameterA.compareNamedParameter(namedParameterB, context2);
            if (namedParameterBComparesToNamedParameterA) {
              return true;
            }
          }
        });
        if (!namedParameterCompares) {
          const message = `The '${namedParameterString}' namedParameter does not compare to any of the '${namedParametersString}' named parameters.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${namedParameterString}' namedParameter with the '${namedParametersString}' named parameters.`);
      }
      compareNamedParameters(namedParameters, context2) {
        namedParameters.forEachNamedParameter((namedParameter) => {
          if (namedParameter !== null) {
            this.compareNamedParameter(namedParameter, context2);
          }
        });
      }
    }, __publicField(_a, "name", "NamedParameters"), _a));
  });

  // lib/nodeProperty.js
  var require_nodeProperty = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodeProperty;
      }
    });
    var _string = require_string5();
    var _NodeProperty = class {
      constructor(string, type, name) {
        this.string = string;
        this.type = type;
        this.name = name;
      }
      getString() {
        return this.string;
      }
      getType() {
        return this.type;
      }
      getName() {
        return this.name;
      }
      compareNamedParameter(namedParameter, context2) {
        let namedParameterCompares;
        const nodePropertyString = this.string, namedParameterString = namedParameter.getString();
        context2.trace(`Comparing the '${nodePropertyString}' node property with the '${namedParameterString}' named parameter...`);
        const name = namedParameter.getName(), type = namedParameter.getType();
        namedParameterCompares = this.name === name && this.type === type;
        if (namedParameterCompares) {
          context2.debug(`...compared the '${nodePropertyString}' node property with the '${namedParameterString}' named parameter.`);
        }
        return namedParameterCompares;
      }
      static fromNameAndType(name, type) {
        const nodePropertyString = (0, _string.nodePropertyStringFromNameAndType)(name, type), string = nodePropertyString, nodeProperty = new _NodeProperty(string, type, name);
        return nodeProperty;
      }
    };
    var NodeProperty = _NodeProperty;
    __publicField(NodeProperty, "name", "Parameter");
  });

  // lib/parameterNames.js
  var require_parameterNames = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get CHILD_NODES_PARAMETER_NAME() {
        return CHILD_NODES_PARAMETER_NAME;
      },
      get CONTENT_PARAMETER_NAME() {
        return CONTENT_PARAMETER_NAME;
      },
      get TERMINAL_PARAMETER_NAME() {
        return TERMINAL_PARAMETER_NAME;
      }
    });
    var CONTENT_PARAMETER_NAME = "content";
    var TERMINAL_PARAMETER_NAME = "terminal";
    var CHILD_NODES_PARAMETER_NAME = "childNodes";
  });

  // lib/nodeProperties.js
  var require_nodeProperties = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _nodeProperty = /* @__PURE__ */ _interop_require_default(require_nodeProperty());
    var _types = require_types3();
    var _string = require_string5();
    var _parameterNames = require_parameterNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NodeProperties = class {
      constructor(string, array) {
        this.string = string;
        this.array = array;
      }
      getString() {
        return this.string;
      }
      getArray() {
        return this.array;
      }
      someNodeProperty(callback) {
        return this.array.some(callback);
      }
      compareNamedParameter(namedParameter, context2) {
        const nodePropertiesString = this.string, namedParameterString = namedParameter.getString();
        context2.trace(`Comparing the '${namedParameterString}' named parameter with the '${nodePropertiesString}' node properties...`);
        const namedParametersCompare = this.someNodeProperty((nodeProperty) => {
          const namedParameterComparesToNodeProperty = nodeProperty.compareNamedParameter(namedParameter, context2);
          if (namedParameterComparesToNodeProperty) {
            return true;
          }
        });
        if (!namedParametersCompare) {
          const message = `The '${namedParameterString}' named parameter does not compmare to any of the '${nodePropertiesString}' node properties.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...compared the '${namedParameterString}' named parameter with the '${nodePropertiesString}' node properties.`);
      }
      compareNamedParameters(namedParameters, context2) {
        namedParameters.forEachNamedParameter((namedParameter) => {
          this.compareNamedParameter(namedParameter, context2);
        });
      }
      static fromNothing() {
        const nodePropertiesArray = nodePropertiesArrayFromNothing(), string = (0, _string.nodePropertiesStringFromNodePropertiesArray)(nodePropertiesArray), array = nodePropertiesArray, nodeProperties2 = new NodeProperties(string, array);
        return nodeProperties2;
      }
    };
    var nodeProperties = NodeProperties.fromNothing();
    var _default = nodeProperties;
    function nodePropertiesArrayFromNothing() {
      const types = [
        _types.STRING_TYPE,
        _types.BOOLEAN_TYPE,
        _types.NODES_TYPE
      ], names = [
        _parameterNames.CONTENT_PARAMETER_NAME,
        _parameterNames.TERMINAL_PARAMETER_NAME,
        _parameterNames.CHILD_NODES_PARAMETER_NAME
      ], nodePropertiesArray = names.map((name, index) => {
        const type = types[index], nodeProperty = _nodeProperty.default.fromNameAndType(name, type);
        return nodeProperty;
      });
      return nodePropertiesArray;
    }
  });

  // lib/element/assignment/object.js
  var require_object2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = /* @__PURE__ */ _interop_require_wildcard(require_elements2());
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _nodeProperties = /* @__PURE__ */ _interop_require_default(require_nodeProperties());
    var _stringLiteral = require_stringLiteral6();
    var _types = require_types3();
    var _term = require_term();
    var _parameterNames = require_parameterNames();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, namedParameters) {
        super(context2, string, node);
        this.variable = variable;
        this.namedParameters = namedParameters;
      }
      getVariable() {
        return this.variable;
      }
      getNamedParameters() {
        return this.namedParameters;
      }
      evaluate(context2) {
        const objectAssignmentString = this.getString();
        context2.trace(`Evaluating the '${objectAssignmentString}' object assignment...`);
        const term = this.variable.evaluate(context2), termType = term.getType();
        if (termType !== _types.NODE_TYPE) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type should be '${_types.NODE_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        _nodeProperties.default.compareNamedParameters(this.namedParameters, context2);
        this.namedParameters.forEachNamedParameter((namedParameter) => {
          this.evaluateNamedParameter(namedParameter, term, context2);
        });
        context2.debug(`...evaluated the '${objectAssignmentString}' object assignment.`);
      }
      evaluateNamedParameter(namedParameter, term, context2) {
        const termString = term.getString(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the '${namedParameterString}' named parameter against the '${termString}' term...`);
        const name = namedParameter.getName();
        switch (name) {
          case _parameterNames.CONTENT_PARAMETER_NAME: {
            term = this.evaluateContentNamedParameter(namedParameter, term, context2);
            break;
          }
          case _parameterNames.TERMINAL_PARAMETER_NAME: {
            term = this.evaluateTerminalNamedParameter(namedParameter, term, context2);
            break;
          }
          case _parameterNames.CHILD_NODES_PARAMETER_NAME: {
            term = this.evaluateChildNodesNamedParameter(namedParameter, term, context2);
            break;
          }
        }
        const {Variable} = _elements.default, variable = Variable.fromNamedParameter(namedParameter, context2);
        variable.assign(term, context2);
        context2.debug(`...evaluated the '${namedParameterString}' parameter named against the '${termString}' term.`);
      }
      evaluateContentNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the content '${namedParameterString}' named parameter...`);
        if (type !== _types.STRING_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.STRING_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeTerminalNode = node.isTerminalNode();
        if (!nodeTerminalNode) {
          const termString = term.getString(), message = `The '${termString}' term's node must be terminal.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const terminalNode = node, content = terminalNode.getContent(), string = content, stringLiteral = (0, _stringLiteral.stringLiteralFromString)(string);
        term = (0, _term.termFromStringLiteral)(stringLiteral, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the content '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
      evaluateTerminalNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the terminal '${namedParameterString}' named parameter...`);
        if (type !== _types.BOOLEAN_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.BOOLEAN_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeTerminalNode = node.isTerminalNode(), terminal = nodeTerminalNode;
        const boolean = terminal;
        term = (0, _term.termFromBoolean)(boolean, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the terminal '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
      evaluateChildNodesNamedParameter(namedParameter, term, context2) {
        const type = namedParameter.getType(), namedParameterString = namedParameter.getString();
        context2.trace(`Evaluating the child nodes '${namedParameterString}' named parameter...`);
        if (type !== _types.NODES_TYPE) {
          const namedParameterString2 = namedParameter.getString(), message = `The '${namedParameterString2}' named parameter's type should be '${_types.NODES_TYPE}'.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const primitiveValue = term.getPrimitiveValue(), node = primitiveValue, nodeNonTerminalNode = node.isNonTerminalNode();
        if (!nodeNonTerminalNode) {
          const termString = term.getString(), message = `The '${termString}' term's node must be non-terminal.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        const nonTerminalNode = node, childNodes = nonTerminalNode.getChildNodes(), nodes = childNodes;
        term = (0, _term.termFromNodes)(nodes, context2);
        const termSttring = term.getString();
        context2.debug(`...evaluated the childNodes '${namedParameterString}' named parameter as '${termSttring}'.`);
        return term;
      }
    }, __publicField(_a, "name", "ObjectAssigment"), _a));
  });

  // lib/element/procedure/anonymous.js
  var require_anonymous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _exception = /* @__PURE__ */ _interop_require_default(require_exception());
    var _elements = require_elements2();
    var _procedure = require_procedure();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, type, parameters, returnBlock) {
        super(context2, string, node);
        this.type = type;
        this.parameters = parameters;
        this.returnBlock = returnBlock;
      }
      getType() {
        return this.type;
      }
      getParameters() {
        return this.parameters;
      }
      getReturnBlock() {
        return this.returnBlock;
      }
      async call(terms, context2) {
        const anonymousProcedureString = this.getString();
        context2.trace(`Calling the '${anonymousProcedureString}' anonymous procedure...`);
        this.parameters.compareTerms(terms, context2);
        const variables = (0, _procedure.variablesFromTermsAndParameters)(terms, this.parameters, context2), term = await this.returnBlock.evaluate(variables, context2), termType = term.getType();
        if (this.type !== termType) {
          const termString = term.getString(), message = `The '${termString}' term's '${termType}' type is not equal to the '${anonymousProcedureString}' anonymous procedure's '${this.type}' type.`, exception = _exception.default.fromMessage(message);
          throw exception;
        }
        context2.debug(`...called the '${anonymousProcedureString}' anonymous procedure.`);
        return term;
      }
    }, __publicField(_a, "name", "AnonymousProcedure"), _a));
  });

  // lib/element/assignment/variable.js
  var require_variable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, variable, expression) {
        super(context2, string, node);
        this.variable = variable;
        this.expression = expression;
      }
      getVariable() {
        return this.variable;
      }
      getExpression() {
        return this.expression;
      }
      async evaluate(context2) {
        let term;
        const variableAssignmentString = this.getString();
        context2.trace(`Evaluating the '${variableAssignmentString}' variable assignment...`);
        term = await this.expression.evaluate(context2);
        this.variable.assign(term, context2);
        const termString = term.getString();
        context2.debug(`...evaluated the '${variableAssignmentString}' variable assignment as '${termString}'.`);
        return term;
      }
    }, __publicField(_a, "name", "VariableAssignment"), _a));
  });

  // lib/element/assignments/variable.js
  var require_variable3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var {asyncForEach} = _occamlanguages.asynchronousUtilities;
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, array) {
        super(context2, string, node);
        this.array = array;
      }
      getArray() {
        return this.array;
      }
      async evaluate(context2) {
        await this.break(context2);
        const variableAssignmentsString = this.getString();
        context2.trace(`Evaluating the '${variableAssignmentsString}' variable assignments...`);
        await asyncForEach(this.array, async (variableAssignment) => {
          await variableAssignment.evaluate(context2);
        });
        context2.debug(`...evaluated the '${variableAssignmentsString}' variable assignments.`);
      }
    }, __publicField(_a, "name", "VariableAssignments"), _a));
  });

  // lib/element/declaration/procedure.js
  var require_procedure2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _occamlanguages = require_lib14();
    var _elements = require_elements2();
    var _a;
    var _default = (0, _elements.define)((_a = class extends _occamlanguages.Element {
      constructor(context2, string, node, procedure) {
        super(context2, string, node);
        this.string = string;
        this.procedure = procedure;
      }
      getProcedure() {
        return this.procedure;
      }
      verify(context2) {
        const verifies = true;
        const procedureDeclarationString = this.getString();
        context2.trace(`Verifying the '${procedureDeclarationString}' procedure declaration...`);
        const procedure = this.getProcedure();
        context2.addProcedure(procedure);
        if (verifies) {
          context2.debug(`...verified the '${procedureDeclarationString}' procedure declaration.`);
        }
        return verifies;
      }
    }, __publicField(_a, "name", "ProcedureDeclaration"), _a));
  });

  // lib/preamble.js
  var require_preamble = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _step = /* @__PURE__ */ _interop_require_default(require_step());
    var _some = /* @__PURE__ */ _interop_require_default(require_some());
    var _term = /* @__PURE__ */ _interop_require_default(require_term2());
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms());
    var _label = /* @__PURE__ */ _interop_require_default(require_label());
    var _error = /* @__PURE__ */ _interop_require_default(require_error4());
    var _every = /* @__PURE__ */ _interop_require_default(require_every());
    var _reduce = /* @__PURE__ */ _interop_require_default(require_reduce());
    var _ternary = /* @__PURE__ */ _interop_require_default(require_ternary());
    var _variable = /* @__PURE__ */ _interop_require_default(require_variable());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive2());
    var _reference = /* @__PURE__ */ _interop_require_default(require_reference2());
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure());
    var _nodeQuery = /* @__PURE__ */ _interop_require_default(require_nodeQuery());
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter());
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters());
    var _nodesQuery = /* @__PURE__ */ _interop_require_default(require_nodesQuery());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression2());
    var _returnBlock = /* @__PURE__ */ _interop_require_default(require_returnBlock());
    var _negated = /* @__PURE__ */ _interop_require_default(require_negated());
    var _logical = /* @__PURE__ */ _interop_require_default(require_logical());
    var _bracketed = /* @__PURE__ */ _interop_require_default(require_bracketed());
    var _procedureCall = /* @__PURE__ */ _interop_require_default(require_procedureCall());
    var _comparison = /* @__PURE__ */ _interop_require_default(require_comparison());
    var _named = /* @__PURE__ */ _interop_require_default(require_named());
    var _array = /* @__PURE__ */ _interop_require_default(require_array4());
    var _return = /* @__PURE__ */ _interop_require_default(require_return());
    var _named1 = /* @__PURE__ */ _interop_require_default(require_named2());
    var _object = /* @__PURE__ */ _interop_require_default(require_object2());
    var _anonymous = /* @__PURE__ */ _interop_require_default(require_anonymous());
    var _variable1 = /* @__PURE__ */ _interop_require_default(require_variable2());
    var _variable2 = /* @__PURE__ */ _interop_require_default(require_variable3());
    var _procedure1 = /* @__PURE__ */ _interop_require_default(require_procedure2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/furtle/lexer.js
  var require_lexer14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleLexer;
      }
    });
    var _occamgrammars = require_lib11();
    var FurtleLexer = class extends _occamgrammars.FurtleLexer {
    };
  });

  // lib/ruleNames.js
  var require_ruleNames5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get ANONYMOUS_PROCEDURE_RULE_NAME() {
        return ANONYMOUS_PROCEDURE_RULE_NAME;
      },
      get ARRAY_ASSIGNMENT_RULE_NAME() {
        return ARRAY_ASSIGNMENT_RULE_NAME;
      },
      get BRACKETED_TERM_RULE_NAME() {
        return BRACKETED_TERM_RULE_NAME;
      },
      get COMPARISON_TERM_RULE_NAME() {
        return COMPARISON_TERM_RULE_NAME;
      },
      get DOCUMENT_RULE_NAME() {
        return DOCUMENT_RULE_NAME;
      },
      get ERROR_RULE_NAME() {
        return ERROR_RULE_NAME;
      },
      get EVERY_RULE_NAME() {
        return EVERY_RULE_NAME;
      },
      get EXPRESSION_RULE_NAME() {
        return EXPRESSION_RULE_NAME;
      },
      get LABEL_RULE_NAME() {
        return LABEL_RULE_NAME;
      },
      get LOGICAL_TERM_RULE_NAME() {
        return LOGICAL_TERM_RULE_NAME;
      },
      get NAMED_PARAMETERS_RULE_NAME() {
        return NAMED_PARAMETERS_RULE_NAME;
      },
      get NAMED_PARAMETER_RULE_NAME() {
        return NAMED_PARAMETER_RULE_NAME;
      },
      get NEGATED_TERM_RULE_NAME() {
        return NEGATED_TERM_RULE_NAME;
      },
      get NODES_QUERY_RULE_NAME() {
        return NODES_QUERY_RULE_NAME;
      },
      get NODE_QUERY_RULE_NAME() {
        return NODE_QUERY_RULE_NAME;
      },
      get NONSENSE_RULE_NAME() {
        return NONSENSE_RULE_NAME;
      },
      get OBJECT_ASSIGNMENT_RULE_NAME() {
        return OBJECT_ASSIGNMENT_RULE_NAME;
      },
      get PARAMETERS_RULE_NAME() {
        return PARAMETERS_RULE_NAME;
      },
      get PARAMETER_RULE_NAME() {
        return PARAMETER_RULE_NAME;
      },
      get PRIMITIVE_RULE_NAME() {
        return PRIMITIVE_RULE_NAME;
      },
      get PROCEDURE_CALL_RULE_NAME() {
        return PROCEDURE_CALL_RULE_NAME;
      },
      get PROCEDURE_DECLARATION_RULE_NAME() {
        return PROCEDURE_DECLARATION_RULE_NAME;
      },
      get REDUCE_RULE_NAME() {
        return REDUCE_RULE_NAME;
      },
      get REFERENCE_RULE_NAME() {
        return REFERENCE_RULE_NAME;
      },
      get RETURN_BLOCK_RULE_NAME() {
        return RETURN_BLOCK_RULE_NAME;
      },
      get RETURN_STATEMENT_RULE_NAME() {
        return RETURN_STATEMENT_RULE_NAME;
      },
      get SOME_RULE_NAME() {
        return SOME_RULE_NAME;
      },
      get STEP_RULE_NAME() {
        return STEP_RULE_NAME;
      },
      get TERMS_RULE_NAME() {
        return TERMS_RULE_NAME;
      },
      get TERM_RULE_NAME() {
        return TERM_RULE_NAME;
      },
      get TERNARY_RULE_NAME() {
        return TERNARY_RULE_NAME;
      },
      get VARIABLE_ASSIGNMENTS_RULE_NAME() {
        return VARIABLE_ASSIGNMENTS_RULE_NAME;
      },
      get VARIABLE_ASSIGNMENT_RULE_NAME() {
        return VARIABLE_ASSIGNMENT_RULE_NAME;
      },
      get VARIABLE_RULE_NAME() {
        return VARIABLE_RULE_NAME;
      }
    });
    var STEP_RULE_NAME = "step";
    var SOME_RULE_NAME = "some";
    var TERM_RULE_NAME = "term";
    var TERMS_RULE_NAME = "terms";
    var EVERY_RULE_NAME = "every";
    var LABEL_RULE_NAME = "label";
    var ERROR_RULE_NAME = "error";
    var REDUCE_RULE_NAME = "reduce";
    var TERNARY_RULE_NAME = "ternary";
    var VARIABLE_RULE_NAME = "variable";
    var NONSENSE_RULE_NAME = "nonsense";
    var DOCUMENT_RULE_NAME = "document";
    var PRIMITIVE_RULE_NAME = "primitive";
    var REFERENCE_RULE_NAME = "reference";
    var PARAMETER_RULE_NAME = "parameter";
    var NODE_QUERY_RULE_NAME = "nodeQuery";
    var EXPRESSION_RULE_NAME = "expression";
    var PARAMETERS_RULE_NAME = "parameters";
    var NODES_QUERY_RULE_NAME = "nodesQuery";
    var RETURN_BLOCK_RULE_NAME = "returnBlock";
    var LOGICAL_TERM_RULE_NAME = "logicalTerm";
    var NEGATED_TERM_RULE_NAME = "negatedTerm";
    var BRACKETED_TERM_RULE_NAME = "bracketedTerm";
    var PROCEDURE_CALL_RULE_NAME = "procedureCall";
    var COMPARISON_TERM_RULE_NAME = "comparisonTerm";
    var NAMED_PARAMETER_RULE_NAME = "namedParameter";
    var NAMED_PARAMETERS_RULE_NAME = "namedParameters";
    var RETURN_STATEMENT_RULE_NAME = "returnStatement";
    var ARRAY_ASSIGNMENT_RULE_NAME = "arrayAssignment";
    var OBJECT_ASSIGNMENT_RULE_NAME = "objectAssignment";
    var VARIABLE_ASSIGNMENT_RULE_NAME = "variableAssignment";
    var ANONYMOUS_PROCEDURE_RULE_NAME = "anonymousProcedure";
    var VARIABLE_ASSIGNMENTS_RULE_NAME = "variableAssignments";
    var PROCEDURE_DECLARATION_RULE_NAME = "procedureDeclaration";
  });

  // lib/node/step.js
  var require_step2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StepNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var StepNode = class extends _occamlanguages.NonTerminalNode {
      getArrayAssignmentNode() {
        const ruleName = _ruleNames.ARRAY_ASSIGNMENT_RULE_NAME, arrayAssignmentNode = this.getNodeByRuleName(ruleName);
        return arrayAssignmentNode;
      }
      getObjectAssignmentNode() {
        const ruleName = _ruleNames.OBJECT_ASSIGNMENT_RULE_NAME, objectAssignmentNode = this.getNodeByRuleName(ruleName);
        return objectAssignmentNode;
      }
      getVariableAssignmentsNode() {
        const ruleName = _ruleNames.VARIABLE_ASSIGNMENTS_RULE_NAME, variableAssignmentsNode = this.getNodeByRuleName(ruleName);
        return variableAssignmentsNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(StepNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/some.js
  var require_some2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return SomeNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var SomeNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variabloeNode = this.getNodeByRuleName(ruleName);
        return variabloeNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(SomeNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term.js
  var require_term3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TermNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var TermNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getPrimitiveNode() {
        const ruleName = _ruleNames.PRIMITIVE_RULE_NAME, primitiveNode = this.getNodeByRuleName(ruleName);
        return primitiveNode;
      }
      getNegatedTermNode() {
        const ruleName = _ruleNames.NEGATED_TERM_RULE_NAME, negatedTermNode = this.getNodeByRuleName(ruleName);
        return negatedTermNode;
      }
      getLogicalTermNode() {
        const ruleName = _ruleNames.LOGICAL_TERM_RULE_NAME, logicalTermRuleName = this.getNodeByRuleName(ruleName);
        return logicalTermRuleName;
      }
      getBracketedTermNode() {
        const ruleName = _ruleNames.BRACKETED_TERM_RULE_NAME, bracketedTermRuleName = this.getNodeByRuleName(ruleName);
        return bracketedTermRuleName;
      }
      getComparisonTermNode() {
        const ruleName = _ruleNames.COMPARISON_TERM_RULE_NAME, comparisonNode = this.getNodeByRuleName(ruleName);
        return comparisonNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = TermNode;
        }
        const termNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return termNode;
      }
    };
  });

  // lib/node/terms.js
  var require_terms2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TermNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var TermNode = class extends _occamlanguages.NonTerminalNode {
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(TermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/every.js
  var require_every2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return EveryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var EveryNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(EveryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/tokenTypes.js
  var require_tokenTypes = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get BOOLEAN_TOKEN_TYPE() {
        return BOOLEAN_TOKEN_TYPE;
      },
      get NAME_TOKEN_TYPE() {
        return NAME_TOKEN_TYPE;
      },
      get NULL_TOKEN_TYPE() {
        return NULL_TOKEN_TYPE;
      },
      get NUMBER_TOKEN_TYPE() {
        return NUMBER_TOKEN_TYPE;
      },
      get SPECIAL_TOKEN_TYPE() {
        return SPECIAL_TOKEN_TYPE;
      },
      get STRING_LITERAL_TOKEN_TYPE() {
        return STRING_LITERAL_TOKEN_TYPE;
      },
      get TYPE_TOKEN_TYPE() {
        return TYPE_TOKEN_TYPE;
      }
    });
    var TYPE_TOKEN_TYPE = "type";
    var NAME_TOKEN_TYPE = "name";
    var NULL_TOKEN_TYPE = "null";
    var NUMBER_TOKEN_TYPE = "number";
    var SPECIAL_TOKEN_TYPE = "special";
    var BOOLEAN_TOKEN_TYPE = "boolean";
    var STRING_LITERAL_TOKEN_TYPE = "string-literal";
  });

  // lib/node/label.js
  var require_label2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LabelNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var LabelNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(LabelNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/error.js
  var require_error5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ErrorNode;
      }
    });
    var _occamlanguages = require_lib14();
    var ErrorNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ErrorNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/reduce.js
  var require_reduce2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReduceNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ReduceNode = class extends _occamlanguages.NonTerminalNode {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getExpressionNode() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNode = this.getNodeByRuleName(ruleName);
        return expressionNode;
      }
      getAnonymousProcedureNode() {
        const ruleName = _ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME, anonymousProcedureNode = this.getNodeByRuleName(ruleName);
        return anonymousProcedureNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReduceNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/ternary.js
  var require_ternary2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TernaryNode;
      }
    });
    var _necessary = require_browser();
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var {first: first2, second} = _necessary.arrayUtilities;
    var TernaryNode = class extends _occamlanguages.NonTerminalNode {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      getExpressionNodes() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNodes = this.getNodesByRuleName(ruleName);
        return expressionNodes;
      }
      getIfExpressionNode() {
        const firstExpressionNode = this.getFirstExpressionNode(), ifExpressionNode = firstExpressionNode;
        return ifExpressionNode;
      }
      getElseExpressionNode() {
        const secondExpressionNode = this.getSecondExpressionNode(), elseExpressionNode = secondExpressionNode;
        return elseExpressionNode;
      }
      getFirstExpressionNode() {
        const expressionNodes = this.getExpressionNodes(), firstExpressionNode = first2(expressionNodes);
        return firstExpressionNode;
      }
      getSecondExpressionNode() {
        const expressionNodes = this.getExpressionNodes(), secondExpressionNode = second(expressionNodes);
        return secondExpressionNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(TernaryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/document.js
  var require_document5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DocumentNode;
      }
    });
    var _occamlanguages = require_lib14();
    var DocumentNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(DocumentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/variable.js
  var require_variable4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var VariableNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(VariableNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/nonsense.js
  var require_nonsense = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NonsenseNode;
      }
    });
    var _occamlanguages = require_lib14();
    var NonsenseNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NonsenseNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/primitive.js
  var require_primitive3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return PrimitiveNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _nullNode = /* @__PURE__ */ _interop_require_default(require_nullNode());
    var _constants = require_constants13();
    var _types = require_types3();
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrimitiveNode = class extends _occamlanguages.NonTerminalNode {
      getType() {
        let type;
        const node = this.getNode(), number = this.getNumber(), boolean = this.getBoolean(), stringLiteral = this.getStringLiteral();
        if (false) {
        } else if (node !== null) {
          type = _types.NODE_TYPE;
        } else if (number !== null) {
          type = _types.NUMBER_TYPE;
        } else if (boolean !== null) {
          type = _types.BOOLEAN_TYPE;
        } else if (stringLiteral !== null) {
          type = _types.STRING_TYPE;
        }
        return type;
      }
      getValue() {
        let value;
        const node = this.getNode(), number = this.getNumber(), boolean = this.getBoolean(), stringLiteral = this.getStringLiteral();
        if (false) {
        } else if (node !== null) {
          value = node;
        } else if (number !== null) {
          value = number;
        } else if (boolean !== null) {
          value = boolean;
        } else if (stringLiteral !== null) {
          value = stringLiteral;
        }
        return value;
      }
      getNode() {
        let node = null;
        const tokenType = _tokenTypes.NULL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.NULL) {
            node = _nullNode.default;
            return true;
          }
        }, tokenType);
        return node;
      }
      getNumber() {
        let number = null;
        const tokenType = _tokenTypes.NUMBER_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.TRUE) {
            number = Number(content);
            return true;
          }
        }, tokenType);
        return number;
      }
      getBoolean() {
        let boolean = null;
        const tokenType = _tokenTypes.BOOLEAN_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.TRUE) {
            boolean = true;
            return true;
          }
          if (content === _constants.FALSE) {
            boolean = false;
            return true;
          }
        }, tokenType);
        return boolean;
      }
      getStringLiteral() {
        let stringLiteral = null;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(PrimitiveNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/reference.js
  var require_reference3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReferenceNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var ReferenceNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReferenceNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameter.js
  var require_parameter2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParamterNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _tokenTypes = require_tokenTypes();
    var ParamterNode = class extends _occamlanguages.NonTerminalNode {
      getName() {
        let name = null;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          name = content;
          return true;
        }, tokenType);
        return name;
      }
      getType() {
        let type = null;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
          return true;
        }, tokenType);
        return type;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = ParamterNode;
        }
        const parameterNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return parameterNode;
      }
    };
  });

  // lib/node/nodeQuery.js
  var require_nodeQuery2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodeQueryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var _stringLiteral = require_stringLiteral6();
    var _tokenTypes = require_tokenTypes();
    var NodeQueryNode = class extends _occamlanguages.NonTerminalNode {
      getString() {
        const stringLiteral = this.getStringLiteral(), string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral);
        return string;
      }
      getStringLiteral() {
        let stringLiteral;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NodeQueryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/expression.js
  var require_expression3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ExpressionNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ExpressionNode = class extends _occamlanguages.NonTerminalNode {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      getSomeNode() {
        const ruleName = _ruleNames.SOME_RULE_NAME, someNode = this.getNodeByRuleName(ruleName);
        return someNode;
      }
      getEveryNode() {
        const ruleName = _ruleNames.EVERY_RULE_NAME, everyNode = this.getNodeByRuleName(ruleName);
        return everyNode;
      }
      getReduceNode() {
        const ruleName = _ruleNames.REDUCE_RULE_NAME, reduceNode = this.getNodeByRuleName(ruleName);
        return reduceNode;
      }
      getTernaryNode() {
        const ruleName = _ruleNames.TERNARY_RULE_NAME, ternaryNode = this.getNodeByRuleName(ruleName);
        return ternaryNode;
      }
      getNodeQueryNode() {
        const ruleName = _ruleNames.NODE_QUERY_RULE_NAME, nodeQueryNode = this.getNodeByRuleName(ruleName);
        return nodeQueryNode;
      }
      getNodesQueryNode() {
        const ruleName = _ruleNames.NODES_QUERY_RULE_NAME, nodeSQueryNode = this.getNodeByRuleName(ruleName);
        return nodeSQueryNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      getProcedureCallNode() {
        const ruleName = _ruleNames.PROCEDURE_CALL_RULE_NAME, procedureCallNode = this.getNodeByRuleName(ruleName);
        return procedureCallNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ExpressionNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameters.js
  var require_parameters2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParamtersNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ParamtersNode = class extends _occamlanguages.NonTerminalNode {
      getParameterNodes() {
        const ruleName = _ruleNames.PARAMETER_RULE_NAME, parameterNodes = this.getNodesByRuleName(ruleName);
        return parameterNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        if (precedence === void 0) {
          precedence = opacity;
          opacity = childNodes;
          childNodes = ruleName;
          ruleName = Class;
          Class = ParamtersNode;
        }
        const parametersNode = _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
        return parametersNode;
      }
    };
  });

  // lib/node/nodesQuery.js
  var require_nodesQuery2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NodesQueryNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var _stringLiteral = require_stringLiteral6();
    var _tokenTypes = require_tokenTypes();
    var NodesQueryNode = class extends _occamlanguages.NonTerminalNode {
      getString() {
        const stringLiteral = this.getStringLiteral(), string = (0, _stringLiteral.stringFromStringLiteral)(stringLiteral);
        return string;
      }
      getStringLiteral() {
        let stringLiteral = null;
        const tokenType = _tokenTypes.STRING_LITERAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          stringLiteral = content;
          return true;
        }, tokenType);
        return stringLiteral;
      }
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(NodesQueryNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/returnBlock.js
  var require_returnBlock2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReturnBlockNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ReturnBlockNode = class extends _occamlanguages.NonTerminalNode {
      isNonsensical() {
        const nonsenseNodes = this.getNonsenseNodes(), nonsenseNodesLength = nonsenseNodes.length, nonsensical = nonsenseNodesLength > 0;
        return nonsensical;
      }
      getStepNodes() {
        const ruleName = _ruleNames.STEP_RULE_NAME, stepNodes = this.getNodesByRuleName(ruleName);
        return stepNodes;
      }
      getNonsenseNodes() {
        const ruleName = _ruleNames.NONSENSE_RULE_NAME, nonsenseNodes = this.getNodesByRuleName(ruleName);
        return nonsenseNodes;
      }
      getReturnStatementNode() {
        const ruleName = _ruleNames.RETURN_STATEMENT_RULE_NAME, returnStatement = this.getNodeByRuleName(ruleName);
        return returnStatement;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ReturnBlockNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/logical.js
  var require_logical2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LogicalTermNode;
      }
    });
    var _necessary = require_browser();
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    var _tokenTypes = require_tokenTypes();
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, last} = _necessary.arrayUtilities;
    var LogicalTermNode = class extends _term.default {
      getOperator() {
        let operator = null;
        const tokenType = _tokenTypes.SPECIAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          operator = content;
          return true;
        }, tokenType);
        return operator;
      }
      isConjection() {
        const operator = this.getOperator(), conjection = operator === _constants.CONJUNCTION_OPERATOR;
        return conjection;
      }
      isDisjunction() {
        const operator = this.getOperator(), disjunction = operator === _constants.DISJUNCTION_OPERATOR;
        return disjunction;
      }
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      getLeftTermNode() {
        const firstExpresionNode = this.getFirstTermNode(), leftTermNode = firstExpresionNode;
        return leftTermNode;
      }
      getRightTermNode() {
        const lastTermNode = this.getLastTermNode(), rightTermNode = lastTermNode;
        return rightTermNode;
      }
      getLastTermNode() {
        const termNodes = this.getTermNodes(), lastTermNode = last(termNodes);
        return lastTermNode;
      }
      getFirstTermNode() {
        const termNodes = this.getTermNodes(), firstTermNode = first2(termNodes);
        return firstTermNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(LogicalTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/negated.js
  var require_negated2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NegatedTermNode;
      }
    });
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NegatedTermNode = class extends _term.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(NegatedTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedureCall.js
  var require_procedureCall2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureCallNode;
      }
    });
    var _occamlanguages = require_lib14();
    var _ruleNames = require_ruleNames5();
    var ProcedureCallNode = class extends _occamlanguages.NonTerminalNode {
      getTermsNode() {
        const ruleName = _ruleNames.TERMS_RULE_NAME, termsNode = this.getNodeByRuleName(ruleName);
        return termsNode;
      }
      getReferenceNode() {
        const ruleName = _ruleNames.REFERENCE_RULE_NAME, referenceNode = this.getNodeByRuleName(ruleName);
        return referenceNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(ProcedureCallNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/bracketed.js
  var require_bracketed2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BracketedTermNode;
      }
    });
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BracketedTermNode = class extends _term.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(BracketedTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/term/comparison.js
  var require_comparison2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ComparisonTermNode;
      }
    });
    var _necessary = require_browser();
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _constants = require_constants13();
    var _ruleNames = require_ruleNames5();
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {first: first2, second} = _necessary.arrayUtilities;
    var ComparisonTermNode = class extends _term.default {
      isNegated() {
        let negated = false;
        const tokenType = _tokenTypes.SPECIAL_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          if (content === _constants.NOT_EQUAL_TO) {
            negated = true;
          }
          return true;
        }, tokenType);
        return negated;
      }
      getTermNodes() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNodes = this.getNodesByRuleName(ruleName);
        return termNodes;
      }
      getLeftTermNode() {
        const firstTermNode = this.getFirstTermNode(), leftTermNode = firstTermNode;
        return leftTermNode;
      }
      getRightTermNode() {
        const secondTermNode = this.getSecondTermNode(), rightTermNode = secondTermNode;
        return rightTermNode;
      }
      getFirstTermNode() {
        const termNodes = this.getTermNodes(), firstTermNode = first2(termNodes);
        return firstTermNode;
      }
      getSecondTermNode() {
        const termNodes = this.getTermNodes(), secondTermNode = second(termNodes);
        return secondTermNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _term.default.fromRuleNameChildNodesOpacityAndPrecedence(ComparisonTermNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameter/named.js
  var require_named3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NamedParamterNode;
      }
    });
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter2());
    var _tokenTypes = require_tokenTypes();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NamedParamterNode = class extends _parameter.default {
      getAlias() {
        let alias = null;
        const tokenType = _tokenTypes.NAME_TOKEN_TYPE;
        this.someTerminalNode((terminalNode, index) => {
          if (index === 3) {
            const content = terminalNode.getContent();
            alias = content;
            return true;
          }
        }, tokenType);
        return alias;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _parameter.default.fromRuleNameChildNodesOpacityAndPrecedence(NamedParamterNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/parameters/named.js
  var require_named4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NamedParamtersNode;
      }
    });
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters2());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NamedParamtersNode = class extends _parameters.default {
      getNamedParameterNodes() {
        const ruleName = _ruleNames.NAMED_PARAMETER_RULE_NAME, namedParamterNodes = this.getNodesByRuleName(ruleName);
        return namedParamterNodes;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _parameters.default.fromRuleNameChildNodesOpacityAndPrecedence(NamedParamtersNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/statement.js
  var require_statement = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return StatementNode;
      }
    });
    var _occamlanguages = require_lib14();
    var StatementNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/statement/return.js
  var require_return2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ReturnStatementNode;
      }
    });
    var _statement = /* @__PURE__ */ _interop_require_default(require_statement());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ReturnStatementNode = class extends _statement.default {
      getTermNode() {
        const ruleName = _ruleNames.TERM_RULE_NAME, termNode = this.getNodeByRuleName(ruleName);
        return termNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _statement.default.fromRuleNameChildNodesOpacityAndPrecedence(ReturnStatementNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment.js
  var require_assignment = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AssignmentrNode;
      }
    });
    var _occamlanguages = require_lib14();
    var AssignmentrNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/array.js
  var require_array5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ArrayAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ArrayAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(ArrayAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/object.js
  var require_object3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ObjectAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ObjectAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getNamedParametersNode() {
        const ruleName = _ruleNames.NAMED_PARAMETERS_RULE_NAME, namedParametersNode = this.getNodeByRuleName(ruleName);
        return namedParametersNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(ObjectAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedure.js
  var require_procedure3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureNode;
      }
    });
    var _occamlanguages = require_lib14();
    var ProcedureNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/procedure/anoymous.js
  var require_anoymous = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return AnonymousProcedureNode;
      }
    });
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure3());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AnonymousProcedureNode = class extends _procedure.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _procedure.default.fromRuleNameChildNodesOpacityAndPrecedence(AnonymousProcedureNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignment/variable.js
  var require_variable5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableAssignmentNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VariableAssignmentNode = class extends _assignment.default {
      getVariableNode() {
        const ruleName = _ruleNames.VARIABLE_RULE_NAME, variableNode = this.getNodeByRuleName(ruleName);
        return variableNode;
      }
      getExpressionNode() {
        const ruleName = _ruleNames.EXPRESSION_RULE_NAME, expressionNode = this.getNodeByRuleName(ruleName);
        return expressionNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(VariableAssignmentNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/assignments/variable.js
  var require_variable6 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return VariableAssignmentsNode;
      }
    });
    var _assignment = /* @__PURE__ */ _interop_require_default(require_assignment());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var VariableAssignmentsNode = class extends _assignment.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getVariableAssignmentNodes() {
        const ruleName = _ruleNames.VARIABLE_ASSIGNMENT_RULE_NAME, variableAssingnmentNodss = this.getNodesByRuleName(ruleName);
        return variableAssingnmentNodss;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _assignment.default.fromRuleNameChildNodesOpacityAndPrecedence(VariableAssignmentsNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/declaration.js
  var require_declaration2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return DeclarationNode;
      }
    });
    var _occamlanguages = require_lib14();
    var DeclarationNode = class extends _occamlanguages.NonTerminalNode {
      static fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence) {
        return _occamlanguages.NonTerminalNode.fromRuleNameChildNodesOpacityAndPrecedence(Class, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/node/declaration/procedure.js
  var require_procedure4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ProcedureDeclarationNode;
      }
    });
    var _declaration = /* @__PURE__ */ _interop_require_default(require_declaration2());
    var _tokenTypes = require_tokenTypes();
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ProcedureDeclarationNode = class extends _declaration.default {
      getType() {
        let type;
        const tokenType = _tokenTypes.TYPE_TOKEN_TYPE;
        this.someTerminalNode((terminalNode) => {
          const content = terminalNode.getContent();
          type = content;
        }, tokenType);
        return type;
      }
      getLabelNode() {
        const ruleName = _ruleNames.LABEL_RULE_NAME, labelNode = this.getNodeByRuleName(ruleName);
        return labelNode;
      }
      getParametersNode() {
        const ruleName = _ruleNames.PARAMETERS_RULE_NAME, parametersNode = this.getNodeByRuleName(ruleName);
        return parametersNode;
      }
      getReturnBlockNode() {
        const ruleName = _ruleNames.RETURN_BLOCK_RULE_NAME, returnBlockNode = this.getNodeByRuleName(ruleName);
        return returnBlockNode;
      }
      static fromRuleNameChildNodesOpacityAndPrecedence(ruleName, childNodes, opacity, precedence) {
        return _declaration.default.fromRuleNameChildNodesOpacityAndPrecedence(ProcedureDeclarationNode, ruleName, childNodes, opacity, precedence);
      }
    };
  });

  // lib/nonTerminalNodeMap.js
  var require_nonTerminalNodeMap3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _step = /* @__PURE__ */ _interop_require_default(require_step2());
    var _some = /* @__PURE__ */ _interop_require_default(require_some2());
    var _term = /* @__PURE__ */ _interop_require_default(require_term3());
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms2());
    var _every = /* @__PURE__ */ _interop_require_default(require_every2());
    var _label = /* @__PURE__ */ _interop_require_default(require_label2());
    var _error = /* @__PURE__ */ _interop_require_default(require_error5());
    var _reduce = /* @__PURE__ */ _interop_require_default(require_reduce2());
    var _ternary = /* @__PURE__ */ _interop_require_default(require_ternary2());
    var _document = /* @__PURE__ */ _interop_require_default(require_document5());
    var _variable = /* @__PURE__ */ _interop_require_default(require_variable4());
    var _nonsense = /* @__PURE__ */ _interop_require_default(require_nonsense());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive3());
    var _reference = /* @__PURE__ */ _interop_require_default(require_reference3());
    var _parameter = /* @__PURE__ */ _interop_require_default(require_parameter2());
    var _nodeQuery = /* @__PURE__ */ _interop_require_default(require_nodeQuery2());
    var _expression = /* @__PURE__ */ _interop_require_default(require_expression3());
    var _parameters = /* @__PURE__ */ _interop_require_default(require_parameters2());
    var _nodesQuery = /* @__PURE__ */ _interop_require_default(require_nodesQuery2());
    var _returnBlock = /* @__PURE__ */ _interop_require_default(require_returnBlock2());
    var _logical = /* @__PURE__ */ _interop_require_default(require_logical2());
    var _negated = /* @__PURE__ */ _interop_require_default(require_negated2());
    var _procedureCall = /* @__PURE__ */ _interop_require_default(require_procedureCall2());
    var _bracketed = /* @__PURE__ */ _interop_require_default(require_bracketed2());
    var _comparison = /* @__PURE__ */ _interop_require_default(require_comparison2());
    var _named = /* @__PURE__ */ _interop_require_default(require_named3());
    var _named1 = /* @__PURE__ */ _interop_require_default(require_named4());
    var _return = /* @__PURE__ */ _interop_require_default(require_return2());
    var _array = /* @__PURE__ */ _interop_require_default(require_array5());
    var _object = /* @__PURE__ */ _interop_require_default(require_object3());
    var _anoymous = /* @__PURE__ */ _interop_require_default(require_anoymous());
    var _variable1 = /* @__PURE__ */ _interop_require_default(require_variable5());
    var _variable2 = /* @__PURE__ */ _interop_require_default(require_variable6());
    var _procedure = /* @__PURE__ */ _interop_require_default(require_procedure4());
    var _ruleNames = require_ruleNames5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NonTerminalNodeMap = {
      [_ruleNames.STEP_RULE_NAME]: _step.default,
      [_ruleNames.SOME_RULE_NAME]: _some.default,
      [_ruleNames.TERM_RULE_NAME]: _term.default,
      [_ruleNames.TERMS_RULE_NAME]: _terms.default,
      [_ruleNames.EVERY_RULE_NAME]: _every.default,
      [_ruleNames.LABEL_RULE_NAME]: _label.default,
      [_ruleNames.ERROR_RULE_NAME]: _error.default,
      [_ruleNames.REDUCE_RULE_NAME]: _reduce.default,
      [_ruleNames.TERNARY_RULE_NAME]: _ternary.default,
      [_ruleNames.VARIABLE_RULE_NAME]: _variable.default,
      [_ruleNames.NONSENSE_RULE_NAME]: _nonsense.default,
      [_ruleNames.DOCUMENT_RULE_NAME]: _document.default,
      [_ruleNames.PRIMITIVE_RULE_NAME]: _primitive.default,
      [_ruleNames.REFERENCE_RULE_NAME]: _reference.default,
      [_ruleNames.PARAMETER_RULE_NAME]: _parameter.default,
      [_ruleNames.NODE_QUERY_RULE_NAME]: _nodeQuery.default,
      [_ruleNames.EXPRESSION_RULE_NAME]: _expression.default,
      [_ruleNames.PARAMETERS_RULE_NAME]: _parameters.default,
      [_ruleNames.NODES_QUERY_RULE_NAME]: _nodesQuery.default,
      [_ruleNames.RETURN_BLOCK_RULE_NAME]: _returnBlock.default,
      [_ruleNames.LOGICAL_TERM_RULE_NAME]: _logical.default,
      [_ruleNames.NEGATED_TERM_RULE_NAME]: _negated.default,
      [_ruleNames.PROCEDURE_CALL_RULE_NAME]: _procedureCall.default,
      [_ruleNames.BRACKETED_TERM_RULE_NAME]: _bracketed.default,
      [_ruleNames.COMPARISON_TERM_RULE_NAME]: _comparison.default,
      [_ruleNames.NAMED_PARAMETER_RULE_NAME]: _named.default,
      [_ruleNames.NAMED_PARAMETERS_RULE_NAME]: _named1.default,
      [_ruleNames.RETURN_STATEMENT_RULE_NAME]: _return.default,
      [_ruleNames.ARRAY_ASSIGNMENT_RULE_NAME]: _array.default,
      [_ruleNames.OBJECT_ASSIGNMENT_RULE_NAME]: _object.default,
      [_ruleNames.ANONYMOUS_PROCEDURE_RULE_NAME]: _anoymous.default,
      [_ruleNames.VARIABLE_ASSIGNMENT_RULE_NAME]: _variable1.default,
      [_ruleNames.VARIABLE_ASSIGNMENTS_RULE_NAME]: _variable2.default,
      [_ruleNames.PROCEDURE_DECLARATION_RULE_NAME]: _procedure.default
    };
    var _default = NonTerminalNodeMap;
  });

  // lib/furtle/parser.js
  var require_parser15 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleParser;
      }
    });
    var _occamlanguages = require_lib14();
    var _occamgrammars = require_lib11();
    var _nonTerminalNodeMap = /* @__PURE__ */ _interop_require_default(require_nonTerminalNodeMap3());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FurtleParser = class extends _occamgrammars.FurtleParser {
    };
    __publicField(FurtleParser, "NonTerminalNodeMap", _nonTerminalNodeMap.default);
    __publicField(FurtleParser, "defaultNonTerminalNode", _occamlanguages.NonTerminalNode);
  });

  // lib/utilities/element.js
  var require_element5 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get aliasFromNamedParameterNode() {
        return aliasFromNamedParameterNode;
      },
      get anonymousProcedureFromAnonymousProcedureNode() {
        return anonymousProcedureFromAnonymousProcedureNode;
      },
      get anonymousProcedureFromEveryNode() {
        return anonymousProcedureFromEveryNode;
      },
      get anonymousProcedureFromReduceNode() {
        return anonymousProcedureFromReduceNode;
      },
      get anonymousProcedureFromSomeNode() {
        return anonymousProcedureFromSomeNode;
      },
      get arrayAssignmentFromArrayAssignmentNode() {
        return arrayAssignmentFromArrayAssignmentNode;
      },
      get arrayAssignmentFromStepNode() {
        return arrayAssignmentFromStepNode;
      },
      get bracketedTermFromBracketedTermNode() {
        return bracketedTermFromBracketedTermNode;
      },
      get bracketedTermFromTermNode() {
        return bracketedTermFromTermNode;
      },
      get comparisonTermFromComparisonTermNode() {
        return comparisonTermFromComparisonTermNode;
      },
      get comparisonTermFromTermNode() {
        return comparisonTermFromTermNode;
      },
      get disjunctionFromLogicalTermNode() {
        return disjunctionFromLogicalTermNode;
      },
      get elseExpressionFromTernaryNode() {
        return elseExpressionFromTernaryNode;
      },
      get errorFromErrorNode() {
        return errorFromErrorNode;
      },
      get everyFromEveryNode() {
        return everyFromEveryNode;
      },
      get everyFromExpressionNode() {
        return everyFromExpressionNode;
      },
      get expressionFromExpressionNode() {
        return expressionFromExpressionNode;
      },
      get expressionFromReduceNode() {
        return expressionFromReduceNode;
      },
      get expressionFromTypeAndVariableNode() {
        return expressionFromTypeAndVariableNode;
      },
      get expressionFromVariableAssignmentNode() {
        return expressionFromVariableAssignmentNode;
      },
      get expressionFromVariableNode() {
        return expressionFromVariableNode;
      },
      get ifExpressionFromTernaryNode() {
        return ifExpressionFromTernaryNode;
      },
      get initialExpressionFromReduceNode() {
        return initialExpressionFromReduceNode;
      },
      get labelFromLabelNode() {
        return labelFromLabelNode;
      },
      get labelFromProcedureDeclarationNode() {
        return labelFromProcedureDeclarationNode;
      },
      get leftTermFromCompzrisonTermNode() {
        return leftTermFromCompzrisonTermNode;
      },
      get leftTermFromLogicalTermNode() {
        return leftTermFromLogicalTermNode;
      },
      get logicalTermFromLogicalTermNode() {
        return logicalTermFromLogicalTermNode;
      },
      get logicalTermFromTermNode() {
        return logicalTermFromTermNode;
      },
      get nameFromLabelNode() {
        return nameFromLabelNode;
      },
      get nameFromNamedParameterNode() {
        return nameFromNamedParameterNode;
      },
      get nameFromParaneterNode() {
        return nameFromParaneterNode;
      },
      get nameFromReferenceNode() {
        return nameFromReferenceNode;
      },
      get nameFromVariableNode() {
        return nameFromVariableNode;
      },
      get namedParameterFromNamedParameterNode() {
        return namedParameterFromNamedParameterNode;
      },
      get namedParametersFromNamedParametersNode() {
        return namedParametersFromNamedParametersNode;
      },
      get namedParametersFromObjectAssignmentNode() {
        return namedParametersFromObjectAssignmentNode;
      },
      get namedParamtersArrayFromNamedParameterNodes() {
        return namedParamtersArrayFromNamedParameterNodes;
      },
      get negatedFromComparisonTermNode() {
        return negatedFromComparisonTermNode;
      },
      get negatedTermFromNegatedTermNode() {
        return negatedTermFromNegatedTermNode;
      },
      get negatedTermFromTermNode() {
        return negatedTermFromTermNode;
      },
      get nodeQueryFromExpressionNode() {
        return nodeQueryFromExpressionNode;
      },
      get nodeQueryFromNodeQueryNode() {
        return nodeQueryFromNodeQueryNode;
      },
      get nodesQueryFromExpressionNode() {
        return nodesQueryFromExpressionNode;
      },
      get nodesQueryFromNodesQueryNode() {
        return nodesQueryFromNodesQueryNode;
      },
      get nonsensicalFromReturnBlockNode() {
        return nonsensicalFromReturnBlockNode;
      },
      get objectAssignmentFromObjectAssignmentNode() {
        return objectAssignmentFromObjectAssignmentNode;
      },
      get objectAssignmentFromStepNode() {
        return objectAssignmentFromStepNode;
      },
      get parameterFromParameterNode() {
        return parameterFromParameterNode;
      },
      get parametersFromAnonymousProcedureNode() {
        return parametersFromAnonymousProcedureNode;
      },
      get parametersFromArrayAssignmentNode() {
        return parametersFromArrayAssignmentNode;
      },
      get parametersFromParametersNode() {
        return parametersFromParametersNode;
      },
      get parametersFromProcedureDeclarationNode() {
        return parametersFromProcedureDeclarationNode;
      },
      get paramtersArrayFromParametersNode() {
        return paramtersArrayFromParametersNode;
      },
      get primitiveFromPrimitiveNode() {
        return primitiveFromPrimitiveNode;
      },
      get primitiveFromTermNode() {
        return primitiveFromTermNode;
      },
      get procedureCallFromExpressionNode() {
        return procedureCallFromExpressionNode;
      },
      get procedureCallFromProcedureCallNode() {
        return procedureCallFromProcedureCallNode;
      },
      get procedureDeclarationFromProcedureDeclarationNode() {
        return procedureDeclarationFromProcedureDeclarationNode;
      },
      get procedureFromProcedureDeclarationNode() {
        return procedureFromProcedureDeclarationNode;
      },
      get queryFromNodeQueryNode() {
        return queryFromNodeQueryNode;
      },
      get queryFromNodesQueryNode() {
        return queryFromNodesQueryNode;
      },
      get reduceFromExpressionNode() {
        return reduceFromExpressionNode;
      },
      get reduceFromReduceNode() {
        return reduceFromReduceNode;
      },
      get referenceFromProcedureCallNode() {
        return referenceFromProcedureCallNode;
      },
      get referenceFromReferenceNode() {
        return referenceFromReferenceNode;
      },
      get returnBlockFromAnonymousProcedureNode() {
        return returnBlockFromAnonymousProcedureNode;
      },
      get returnBlockFromExpressionNode() {
        return returnBlockFromExpressionNode;
      },
      get returnBlockFromProcedureDeclarationNode() {
        return returnBlockFromProcedureDeclarationNode;
      },
      get returnBlockFromReturnBlockNode() {
        return returnBlockFromReturnBlockNode;
      },
      get returnStatementFromReturnBlockNode() {
        return returnStatementFromReturnBlockNode;
      },
      get returnStatementFromReturnStatementNode() {
        return returnStatementFromReturnStatementNode;
      },
      get rightTermFromCompzrisonTermNode() {
        return rightTermFromCompzrisonTermNode;
      },
      get rightTermFromLogicalTermNode() {
        return rightTermFromLogicalTermNode;
      },
      get someFromExpressionNode() {
        return someFromExpressionNode;
      },
      get someFromSomeNode() {
        return someFromSomeNode;
      },
      get stepFromStepNode() {
        return stepFromStepNode;
      },
      get stepsFromReturnBlockNode() {
        return stepsFromReturnBlockNode;
      },
      get termFromBracketedTermNode() {
        return termFromBracketedTermNode;
      },
      get termFromExpressionNode() {
        return termFromExpressionNode;
      },
      get termFromNegatedTermNode() {
        return termFromNegatedTermNode;
      },
      get termFromReturnStatementNode() {
        return termFromReturnStatementNode;
      },
      get termFromTermNode() {
        return termFromTermNode;
      },
      get termFromTernaryNode() {
        return termFromTernaryNode;
      },
      get termsArrayFromTermNodes() {
        return termsArrayFromTermNodes;
      },
      get termsFromProcedureCallNode() {
        return termsFromProcedureCallNode;
      },
      get termsFromTermsNode() {
        return termsFromTermsNode;
      },
      get ternaryFromExpressionNode() {
        return ternaryFromExpressionNode;
      },
      get ternaryFromTernaryNode() {
        return ternaryFromTernaryNode;
      },
      get typeFromLogicalTermNode() {
        return typeFromLogicalTermNode;
      },
      get typeFromNamedParameterNode() {
        return typeFromNamedParameterNode;
      },
      get typeFromNegatedTermNode() {
        return typeFromNegatedTermNode;
      },
      get typeFromParaneterNode() {
        return typeFromParaneterNode;
      },
      get typeFromPrimitiveNode() {
        return typeFromPrimitiveNode;
      },
      get typeFromProcedureAnonymousProcedureNode() {
        return typeFromProcedureAnonymousProcedureNode;
      },
      get typeFromProcedureDeclarationNode() {
        return typeFromProcedureDeclarationNode;
      },
      get typeFromVariableAssignmentsNode() {
        return typeFromVariableAssignmentsNode;
      },
      get typeFromVariableNode() {
        return typeFromVariableNode;
      },
      get valueFromPrimitiveNode() {
        return valueFromPrimitiveNode;
      },
      get variableAssignmentFromTypeAndVariableAssignmentNode() {
        return variableAssignmentFromTypeAndVariableAssignmentNode;
      },
      get variableAssignmentsArrayFromTypeAndVariableAssignmentsNode() {
        return variableAssignmentsArrayFromTypeAndVariableAssignmentsNode;
      },
      get variableAssignmentsFromStepNode() {
        return variableAssignmentsFromStepNode;
      },
      get variableAssignmentsFromVariableAssignmentsNode() {
        return variableAssignmentsFromVariableAssignmentsNode;
      },
      get variableFromArrayAssignmentNode() {
        return variableFromArrayAssignmentNode;
      },
      get variableFromEveryNode() {
        return variableFromEveryNode;
      },
      get variableFromNodeQueryNode() {
        return variableFromNodeQueryNode;
      },
      get variableFromNodesQueryNode() {
        return variableFromNodesQueryNode;
      },
      get variableFromObjectAssignmentNode() {
        return variableFromObjectAssignmentNode;
      },
      get variableFromReduceNode() {
        return variableFromReduceNode;
      },
      get variableFromSomeNode() {
        return variableFromSomeNode;
      },
      get variableFromTermNode() {
        return variableFromTermNode;
      },
      get variableFromTypeAndVariableAssignmentNode() {
        return variableFromTypeAndVariableAssignmentNode;
      },
      get variableFromTypeAndVariableNode() {
        return variableFromTypeAndVariableNode;
      },
      get variableFromVariableNode() {
        return variableFromVariableNode;
      }
    });
    var _occamquery = require_lib5();
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _types = require_types3();
    var _string = require_string5();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function stepFromStepNode(stepNode, context2) {
      const {Step} = _elements.default, node = stepNode, string = context2.nodeAsString(node), arrayAssignment = arrayAssignmentFromStepNode(stepNode, context2), objectAssigment = objectAssignmentFromStepNode(stepNode, context2), variablesDeclaration = variableAssignmentsFromStepNode(stepNode, context2);
      context2 = null;
      const step = new Step(context2, string, node, arrayAssignment, objectAssigment, variablesDeclaration);
      return step;
    }
    function someFromSomeNode(someNode, context2) {
      const {Some} = _elements.default, node = someNode, variable = variableFromSomeNode(someNode, context2), anonymousProcedure = anonymousProcedureFromSomeNode(someNode, context2), someString = (0, _string.someStringFromVariableAndAnonymousProcedure)(variable, anonymousProcedure), string = someString;
      context2 = null;
      const some = new Some(context2, string, node, variable, anonymousProcedure);
      return some;
    }
    function termFromTermNode(termNode, context2) {
      const {Term} = _elements.default, node = termNode, variable = variableFromTermNode(termNode, context2), primitive = primitiveFromTermNode(termNode, context2), negatedTerm = negatedTermFromTermNode(termNode, context2), logicalTerm = logicalTermFromTermNode(termNode, context2), bracketedTerm = bracketedTermFromTermNode(termNode, context2), comparisonTerm = comparisonTermFromTermNode(termNode, context2), properties = [
        variable,
        primitive,
        negatedTerm,
        logicalTerm,
        bracketedTerm,
        comparisonTerm
      ], termString = (0, _string.termStringFromProperties)(properties, context2), string = termString;
      context2 = null;
      const term = new Term(context2, string, node, variable, primitive, negatedTerm, logicalTerm, bracketedTerm, comparisonTerm);
      return term;
    }
    function termsFromTermsNode(termsNode, context2) {
      const {Terms} = _elements.default, node = termsNode, string = context2.nodeAsString(node), termNodes = termsNode.getTermNodes(), termsArray = termsArrayFromTermNodes(termNodes, context2), array = termsArray;
      context2 = null;
      const terms = new Terms(context2, string, node, array);
      return terms;
    }
    function errorFromErrorNode(errorNode, context2) {
      const {Error: Error2} = _elements.default, node = errorNode, string = context2.nodeAsString(node);
      context2 = null;
      const error = new Error2(context2, string, node);
      return error;
    }
    function everyFromEveryNode(everyNode, context2) {
      const {Every} = _elements.default, node = everyNode, variable = variableFromEveryNode(everyNode, context2), anonymousProcedure = anonymousProcedureFromEveryNode(everyNode, context2), everyString = (0, _string.everyStringFromVariableAndAnonymousProcedure)(variable, anonymousProcedure), string = everyString;
      context2 = null;
      const every = new Every(context2, string, node, variable, anonymousProcedure);
      return every;
    }
    function labelFromLabelNode(labelNode, context2) {
      const {Label} = _elements.default, node = labelNode, string = context2.nodeAsString(node), name = nameFromLabelNode(labelNode, context2);
      context2 = null;
      const label = new Label(context2, string, node, name);
      return label;
    }
    function reduceFromReduceNode(reduceNode, context2) {
      const {Reduce} = _elements.default, node = reduceNode, variable = variableFromReduceNode(reduceNode, context2), initialExpression = initialExpressionFromReduceNode(reduceNode, context2), anonymousProcedure = anonymousProcedureFromReduceNode(reduceNode, context2), reduceString = (0, _string.reduceStringFromVariableInitialExpressionAndAnonymousProcedure)(variable, initialExpression, anonymousProcedure), string = reduceString;
      context2 = null;
      const reduce = new Reduce(context2, string, node, variable, initialExpression, anonymousProcedure);
      return reduce;
    }
    function ternaryFromTernaryNode(ternaryNode, context2) {
      const {Ternary} = _elements.default, node = ternaryNode, term = termFromTernaryNode(ternaryNode, context2), ifExpression = ifExpressionFromTernaryNode(ternaryNode, context2), elseExpression = elseExpressionFromTernaryNode(ternaryNode, context2), ternaryString = (0, _string.ternaryStringFromTerm)(term), string = ternaryString;
      context2 = null;
      const ternary = new Ternary(context2, string, node, term, ifExpression, elseExpression);
      return ternary;
    }
    function variableFromVariableNode(variableNode, context2) {
      const {Variable} = _elements.default, node = variableNode, string = context2.nodeAsString(node), type = typeFromVariableNode(variableNode, context2), name = nameFromVariableNode(variableNode, context2), expression = expressionFromVariableNode(variableNode, context2);
      context2 = null;
      const variable = new Variable(context2, string, node, type, name, expression);
      return variable;
    }
    function referenceFromReferenceNode(referenceNode, context2) {
      const {Reference} = _elements.default, node = referenceNode, string = context2.nodeAsString(node), name = nameFromReferenceNode(referenceNode, context2);
      context2 = null;
      const reference = new Reference(context2, string, node, name);
      return reference;
    }
    function parameterFromParameterNode(parameterNode, context2) {
      let parameter = null;
      const type = typeFromParaneterNode(parameterNode, context2);
      if (type !== null) {
        const {Parameter} = _elements.default, node = parameterNode, string = context2.nodeAsString(node), name = nameFromParaneterNode(parameterNode, context2);
        context2 = null;
        parameter = new Parameter(context2, string, node, type, name);
      }
      return parameter;
    }
    function nodeQueryFromNodeQueryNode(nodeQueryNode, context2) {
      const {NodeQuery} = _elements.default, node = nodeQueryNode, string = context2.nodeAsString(node), variable = variableFromNodeQueryNode(nodeQueryNode, context2), query = queryFromNodeQueryNode(nodeQueryNode, context2);
      context2 = null;
      const nodeQuery = new NodeQuery(context2, string, node, variable, query);
      return nodeQuery;
    }
    function primitiveFromPrimitiveNode(primitiveNode, context2) {
      const {Primitive} = _elements.default, node = primitiveNode, string = context2.nodeAsString(node), type = typeFromPrimitiveNode(primitiveNode, context2), value = valueFromPrimitiveNode(primitiveNode, context2);
      context2 = null;
      const primitive = new Primitive(context2, string, node, type, value);
      return primitive;
    }
    function nodesQueryFromNodesQueryNode(nodesQueryNode, context2) {
      const {NodesQuery} = _elements.default, node = nodesQueryNode, string = context2.nodeAsString(node), variable = variableFromNodesQueryNode(nodesQueryNode, context2), query = queryFromNodesQueryNode(nodesQueryNode, context2);
      context2 = null;
      const nodesQuery = new NodesQuery(context2, string, node, variable, query);
      return nodesQuery;
    }
    function parametersFromParametersNode(parametersNode, context2) {
      const {Parameters} = _elements.default, node = parametersNode, string = context2.nodeAsString(node), paramtersArray = paramtersArrayFromParametersNode(parametersNode, context2), array = paramtersArray;
      context2 = null;
      const parameters = new Parameters(context2, string, node, array);
      return parameters;
    }
    function expressionFromExpressionNode(expressionNode, context2) {
      const {Expression} = _elements.default, node = expressionNode, term = termFromExpressionNode(expressionNode, context2), some = someFromExpressionNode(expressionNode, context2), every = everyFromExpressionNode(expressionNode, context2), reduce = reduceFromExpressionNode(expressionNode, context2), ternary = ternaryFromExpressionNode(expressionNode, context2), nodeQuery = nodeQueryFromExpressionNode(expressionNode, context2), nodesQuery = nodesQueryFromExpressionNode(expressionNode, context2), returnBlock = returnBlockFromExpressionNode(expressionNode, context2), procedureCall = procedureCallFromExpressionNode(expressionNode, context2), properties = [
        term,
        some,
        every,
        reduce,
        ternary,
        nodeQuery,
        nodesQuery,
        returnBlock,
        procedureCall
      ], expressionString = (0, _string.expressionStringFromProperties)(properties, context2), string = expressionString;
      context2 = null;
      const expression = new Expression(context2, string, node, term, some, every, reduce, ternary, nodeQuery, nodesQuery, returnBlock, procedureCall);
      return expression;
    }
    function returnBlockFromReturnBlockNode(returnBlockNode, context2) {
      const {ReturnBlock} = _elements.default, node = returnBlockNode, steps = stepsFromReturnBlockNode(returnBlockNode, context2), nonsensical = nonsensicalFromReturnBlockNode(returnBlockNode, context2), returnStatement = returnStatementFromReturnBlockNode(returnBlockNode, context2), returnBlockString = (0, _string.returnBlockStringFromReturnStatementNode)(returnStatement), string = returnBlockString;
      context2 = null;
      const returnBlock = new ReturnBlock(context2, string, node, steps, nonsensical, returnStatement);
      return returnBlock;
    }
    function procedureCallFromProcedureCallNode(procedureCallNode, context2) {
      const {ProcedureCall} = _elements.default, node = procedureCallNode, string = context2.nodeAsString(node), reference = referenceFromProcedureCallNode(procedureCallNode, context2), terms = termsFromProcedureCallNode(procedureCallNode, context2);
      context2 = null;
      const procedureCall = new ProcedureCall(context2, string, node, reference, terms);
      return procedureCall;
    }
    function namedParameterFromNamedParameterNode(namedParameterNode, context2) {
      const {NamedParameter} = _elements.default, node = namedParameterNode, string = context2.nodeAsString(node), type = typeFromNamedParameterNode(namedParameterNode, context2), name = nameFromNamedParameterNode(namedParameterNode, context2), alias = aliasFromNamedParameterNode(namedParameterNode, context2);
      context2 = null;
      const namedParameter = new NamedParameter(context2, string, node, type, name, alias);
      return namedParameter;
    }
    function namedParametersFromNamedParametersNode(namedParametersNode, context2) {
      const {NamedParameters} = _elements.default, node = namedParametersNode, string = context2.nodeAsString(node), namedParameterNodes = namedParametersNode.getNamedParameterNodes(), namedParametersArray = namedParamtersArrayFromNamedParameterNodes(namedParameterNodes, context2), array = namedParametersArray;
      context2 = null;
      const namedParameters = new NamedParameters(context2, string, node, array);
      return namedParameters;
    }
    function arrayAssignmentFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const {ArrayAssignment} = _elements.default, node = arrayAssignmentNode, string = context2.nodeAsString(node), variable = variableFromArrayAssignmentNode(arrayAssignmentNode, context2), parameters = parametersFromArrayAssignmentNode(arrayAssignmentNode, context2);
      context2 = null;
      const arrayAssignment = new ArrayAssignment(context2, string, node, variable, parameters);
      return arrayAssignment;
    }
    function returnStatementFromReturnStatementNode(returnStatementNode, context2) {
      const {ReturnStatement} = _elements.default, node = returnStatementNode, string = context2.nodeAsString(node), term = termFromReturnStatementNode(returnStatementNode, context2);
      context2 = null;
      const returnStatement = new ReturnStatement(context2, string, node, term);
      return returnStatement;
    }
    function namedParametersFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const namedParametersNode = objectAssignmentNode.getNamedParametersNode(), namedParameters = namedParametersFromNamedParametersNode(namedParametersNode, context2);
      return namedParameters;
    }
    function objectAssignmentFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const {ObjectAssigment} = _elements.default, node = objectAssignmentNode, string = context2.nodeAsString(node), variable = variableFromObjectAssignmentNode(objectAssignmentNode, context2), namedParameters = namedParametersFromObjectAssignmentNode(objectAssignmentNode, context2);
      context2 = null;
      const objectAssignment = new ObjectAssigment(context2, string, node, variable, namedParameters);
      return objectAssignment;
    }
    function anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const {AnonymousProcedure} = _elements.default, node = anonymousProcedureNode, type = typeFromProcedureAnonymousProcedureNode(anonymousProcedureNode, context2), parameters = parametersFromAnonymousProcedureNode(anonymousProcedureNode, context2), returnBlock = returnBlockFromAnonymousProcedureNode(anonymousProcedureNode, context2), nonymousProcedureString = (0, _string.anonymousProcedureStringFromTypeParametersAndReturnBlock)(type, parameters, returnBlock), string = nonymousProcedureString;
      context2 = null;
      const anonymousProcedure = new AnonymousProcedure(context2, string, node, type, parameters, returnBlock);
      return anonymousProcedure;
    }
    function variableAssignmentsFromVariableAssignmentsNode(variableAssignmentsNode, context2) {
      const {VariableAssignments} = _elements.default, node = variableAssignmentsNode, type = typeFromVariableAssignmentsNode(variableAssignmentsNode, context2), variableAssignmentsArray = variableAssignmentsArrayFromTypeAndVariableAssignmentsNode(type, variableAssignmentsNode, context2), variableAssignmentString = (0, _string.variableAssignmentStringFromTypeAndVariableAssignmentsArray)(type, variableAssignmentsArray), array = variableAssignmentsArray, string = variableAssignmentString;
      context2 = null;
      const variableAssignments = new VariableAssignments(context2, string, node, array);
      return variableAssignments;
    }
    function procedureDeclarationFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const {ProcedureDeclaration} = _elements.default, node = procedureDeclarationNode, procedure = procedureFromProcedureDeclarationNode(procedureDeclarationNode, context2), procedureDeclarationString = (0, _string.procedureDeclarationStringFromProcedure)(procedure), string = procedureDeclarationString;
      context2 = null;
      const procedureDeclaration = new ProcedureDeclaration(context2, string, node, procedure);
      return procedureDeclaration;
    }
    function nameFromLabelNode(labelNode, context2) {
      const name = labelNode.getName();
      return name;
    }
    function termFromTernaryNode(ternaryNode, context2) {
      const termNode = ternaryNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function variableFromSomeNode(someNode, context2) {
      const variableNode = someNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function variableFromTermNode(termNode, context2) {
      let variable = null;
      const variableNode = termNode.getVariableNode();
      if (variableNode !== null) {
        variable = variableFromVariableNode(variableNode, context2);
      }
      return variable;
    }
    function nameFromVariableNode(variableNode) {
      const name = variableNode.getName();
      return name;
    }
    function typeFromVariableNode(variableNode, context2) {
      const type = null;
      return type;
    }
    function primitiveFromTermNode(termNode, context2) {
      let primitive = null;
      const primitiveNode = termNode.getPrimitiveNode();
      if (primitiveNode !== null) {
        primitive = primitiveFromPrimitiveNode(primitiveNode, context2);
      }
      return primitive;
    }
    function variableFromEveryNode(everyNode, context2) {
      const variableNode = everyNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromParaneterNode(parameterNode, context2) {
      const type = parameterNode.getType();
      return type;
    }
    function nameFromParaneterNode(parameterNode, context2) {
      const name = parameterNode.getName();
      return name;
    }
    function nameFromReferenceNode(referenceNode, context2) {
      const name = referenceNode.getName();
      return name;
    }
    function typeFromPrimitiveNode(primitiveNode, context2) {
      const type = primitiveNode.getType();
      return type;
    }
    function variableFromReduceNode(reduceNode, context2) {
      const variableNode = reduceNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function termFromExpressionNode(expressionNode, context2) {
      let term = null;
      const termNode = expressionNode.getTermNode();
      if (termNode !== null) {
        term = termFromTermNode(termNode, context2);
      }
      return term;
    }
    function someFromExpressionNode(expressionNode, context2) {
      let some = null;
      const someNode = expressionNode.getSomeNode();
      if (someNode !== null) {
        some = someFromSomeNode(someNode, context2);
      }
      return some;
    }
    function queryFromNodeQueryNode(nodeQueryNode, context2) {
      const string = nodeQueryNode.getString(), expressionString = string, query = _occamquery.Query.fromExpressionString(expressionString);
      return query;
    }
    function valueFromPrimitiveNode(primitiveNode, context2) {
      const value = primitiveNode.getValue();
      return value;
    }
    function queryFromNodesQueryNode(nodesQueryNode, context2) {
      const string = nodesQueryNode.getString(), expressionString = string, query = _occamquery.Query.fromExpressionString(expressionString);
      return query;
    }
    function everyFromExpressionNode(expressionNode, context2) {
      let every = null;
      const everyNode = expressionNode.getEveryNode();
      if (everyNode !== null) {
        every = everyFromEveryNode(everyNode, context2);
      }
      return every;
    }
    function negatedTermFromTermNode(termNode, context2) {
      let negatedTerm = null;
      const negatedTermNode = termNode.getNegatedTermNode();
      if (negatedTermNode !== null) {
        negatedTerm = negatedTermFromNegatedTermNode(negatedTermNode, context2);
      }
      return negatedTerm;
    }
    function logicalTermFromTermNode(termNode, context2) {
      let logicalTerm = null;
      const logicalTermNode = termNode.getLogicalTermNode();
      if (logicalTermNode !== null) {
        logicalTerm = logicalTermFromLogicalTermNode(logicalTermNode, context2);
      }
      return logicalTerm;
    }
    function typeFromLogicalTermNode(logicalTermNode, context2) {
      const type = _types.BOOLEAN_TYPE;
      return type;
    }
    function typeFromNegatedTermNode(logicalTermNode, context2) {
      const type = _types.BOOLEAN_TYPE;
      return type;
    }
    function termFromNegatedTermNode(negatedTermNode, context2) {
      const termNode = negatedTermNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function expressionFromReduceNode(reduceNode, context2) {
      const expressionNode = reduceNode.getExpressionNode(), expression = expressionFromExpressionNode(expressionNode, context2);
      return expression;
    }
    function reduceFromExpressionNode(expressionNode, context2) {
      let reduce = null;
      const reduceNode = expressionNode.getReduceNode();
      if (reduceNode !== null) {
        reduce = reduceFromReduceNode(reduceNode, context2);
      }
      return reduce;
    }
    function stepsFromReturnBlockNode(returnBlockNode, context2) {
      const stepNodes = returnBlockNode.getStepNodes(), steps = stepNodes.map((stepNode) => {
        const step = stepFromStepNode(stepNode, context2);
        return step;
      });
      return steps;
    }
    function variableFromNodeQueryNode(nodeQueryNode, context2) {
      const variableNode = nodeQueryNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function ternaryFromExpressionNode(expressionNode, context2) {
      let ternary = null;
      const ternaryNode = expressionNode.getTernaryNode();
      if (ternaryNode !== null) {
        ternary = ternaryFromTernaryNode(ternaryNode, context2);
      }
      return ternary;
    }
    function bracketedTermFromTermNode(termNode, context2) {
      let bracketedTerm = null;
      const bracketedTermNode = termNode.getBracketedTermNode();
      if (bracketedTermNode !== null) {
        bracketedTerm = bracketedTermFromBracketedTermNode(bracketedTermNode, context2);
      }
      return bracketedTerm;
    }
    function termFromBracketedTermNode(bracketedTermNode, context2) {
      const termNode = bracketedTermNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function comparisonTermFromTermNode(termNOde, context2) {
      let comparisonTerm = null;
      const comparisonTermNode = termNOde.getComparisonTermNode();
      if (comparisonTermNode !== null) {
        comparisonTerm = comparisonTermFromComparisonTermNode(comparisonTermNode, context2);
      }
      return comparisonTerm;
    }
    function expressionFromVariableNode(variableNode, context2) {
      const expression = null;
      return expression;
    }
    function variableFromNodesQueryNode(nodesQueryNode, context2) {
      const variableNode = nodesQueryNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function termsFromProcedureCallNode(procedureCallNode, context2) {
      const termsNode = procedureCallNode.getTermsNode(), terms = termsFromTermsNode(termsNode, context2);
      return terms;
    }
    function typeFromNamedParameterNode(namedParameterNode, context2) {
      const type = namedParameterNode.getType();
      return type;
    }
    function nameFromNamedParameterNode(namedParameterNode, context2) {
      const name = namedParameterNode.getName();
      return name;
    }
    function leftTermFromLogicalTermNode(logicalTermNode, context2) {
      const leftTermNode = logicalTermNode.getLeftTermNode(), leftTerm = termFromTermNode(leftTermNode, context2);
      return leftTerm;
    }
    function arrayAssignmentFromStepNode(stepNode, context2) {
      let arrayAssignment = null;
      const arrayAssignmentNode = stepNode.getArrayAssignmentNode();
      if (arrayAssignmentNode !== null) {
        arrayAssignment = arrayAssignmentFromArrayAssignmentNode(arrayAssignmentNode, context2);
      }
      return arrayAssignment;
    }
    function ifExpressionFromTernaryNode(ternaryNode, context2) {
      const ifExpressionNode = ternaryNode.getIfExpressionNode(), ifExpression = expressionFromExpressionNode(ifExpressionNode, context2);
      return ifExpression;
    }
    function nodeQueryFromExpressionNode(expressionNode, context2) {
      let nodeQuery = null;
      const nodeQueryNode = expressionNode.getNodeQueryNode();
      if (nodeQueryNode !== null) {
        nodeQuery = nodeQueryFromNodeQueryNode(nodeQueryNode, context2);
      }
      return nodeQuery;
    }
    function aliasFromNamedParameterNode(namedParameterNode, context2) {
      const alias = namedParameterNode.getAlias();
      return alias;
    }
    function termFromReturnStatementNode(returnStatementNode, context2) {
      const termNode = returnStatementNode.getTermNode(), term = termFromTermNode(termNode, context2);
      return term;
    }
    function objectAssignmentFromStepNode(stepNode, context2) {
      let objectAssignment = null;
      const objectAssignmentNode = stepNode.getObjectAssignmentNode();
      if (objectAssignmentNode !== null) {
        objectAssignment = objectAssignmentFromObjectAssignmentNode(objectAssignmentNode, context2);
      }
      return objectAssignment;
    }
    function nodesQueryFromExpressionNode(expressionNode, context2) {
      let nodesQuery = null;
      const nodesQueryNode = expressionNode.getNodesQueryNode();
      if (nodesQueryNode !== null) {
        nodesQuery = nodesQueryFromNodesQueryNode(nodesQueryNode, context2);
      }
      return nodesQuery;
    }
    function rightTermFromLogicalTermNode(logicalTermNode, context2) {
      const rightTermNode = logicalTermNode.getRightTermNode(), rightTerm = termFromTermNode(rightTermNode, context2);
      return rightTerm;
    }
    function negatedFromComparisonTermNode(comparisonTermNode, context2) {
      const negated = comparisonTermNode.isNegated();
      return negated;
    }
    function elseExpressionFromTernaryNode(ternaryNode, context2) {
      const elseExpressionNode = ternaryNode.getElseExpressionNode(), elseExpression = expressionFromExpressionNode(elseExpressionNode, context2);
      return elseExpression;
    }
    function returnBlockFromExpressionNode(expressionNode, context2) {
      let returnBlock = null;
      const returnBlockNode = expressionNode.getReturnBlockNode();
      if (returnBlockNode !== null) {
        returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      }
      return returnBlock;
    }
    function anonymousProcedureFromSomeNode(someNode, context2) {
      const anonymousProcedureNode = someNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function nonsensicalFromReturnBlockNode(returnBlockNode, context2) {
      const nonsensical = returnBlockNode.isNonsensical();
      return nonsensical;
    }
    function referenceFromProcedureCallNode(procedureCallNode, context2) {
      const referenceNode = procedureCallNode.getReferenceNode(), reference = referenceFromReferenceNode(referenceNode, context2);
      return reference;
    }
    function leftTermFromCompzrisonTermNode(comparisonTermNode, context2) {
      const leftTermNode = comparisonTermNode.getLeftTermNode(), leftTerm = termFromTermNode(leftTermNode, context2);
      return leftTerm;
    }
    function disjunctionFromLogicalTermNode(logicalTermNode, context2) {
      const disjunction = logicalTermNode.isDisjunction();
      return disjunction;
    }
    function negatedTermFromNegatedTermNode(negatedTermNode, context2) {
      const {NegatedTerm} = _elements.default, node = negatedTermNode, string = context2.nodeAsString(node), termNode = negatedTermNode.getTermNode(), type = typeFromNegatedTermNode(termNode, context2), term = termFromNegatedTermNode(negatedTermNode, context2), negatedTerm = new NegatedTerm(context2, string, node, type, term);
      return negatedTerm;
    }
    function logicalTermFromLogicalTermNode(logicalTermNode, context2) {
      const {LogicalTerm} = _elements.default, node = logicalTermNode, string = context2.nodeAsString(node), type = typeFromLogicalTermNode(logicalTermNode, context2), disjunction = disjunctionFromLogicalTermNode(logicalTermNode, context2), leftTerm = leftTermFromLogicalTermNode(logicalTermNode, context2), rightTerm = rightTermFromLogicalTermNode(logicalTermNode, context2), logicalTerm = new LogicalTerm(context2, string, node, type, disjunction, leftTerm, rightTerm);
      return logicalTerm;
    }
    function variableFromTypeAndVariableNode(type, variableNode, context2) {
      const {Variable} = _elements.default, node = variableNode, name = nameFromVariableNode(variableNode), expression = expressionFromTypeAndVariableNode(type, variableNode, context2), variableString = (0, _string.variableStringFromName)(name), string = variableString, variable = new Variable(context2, string, node, type, name, expression);
      return variable;
    }
    function variableAssignmentsFromStepNode(stepNode, context2) {
      let variableAssignments = null;
      const variableAssignmentsNode = stepNode.getVariableAssignmentsNode();
      if (variableAssignmentsNode !== null) {
        variableAssignments = variableAssignmentsFromVariableAssignmentsNode(variableAssignmentsNode, context2);
      }
      return variableAssignments;
    }
    function anonymousProcedureFromEveryNode(everyNode, context2) {
      const anonymousProcedureNode = everyNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function initialExpressionFromReduceNode(reduceNode, context2) {
      const expression = expressionFromReduceNode(reduceNode, context2), initialExpression = expression;
      return initialExpression;
    }
    function procedureCallFromExpressionNode(expressionNode, context2) {
      let procedureCall = null;
      const procedureCallNode = expressionNode.getProcedureCallNode();
      if (procedureCallNode !== null) {
        procedureCall = procedureCallFromProcedureCallNode(procedureCallNode, context2);
      }
      return procedureCall;
    }
    function rightTermFromCompzrisonTermNode(comparisonTermNode, context2) {
      const rightTermNode = comparisonTermNode.getRightTermNode(), rightTerm = termFromTermNode(rightTermNode, context2);
      return rightTerm;
    }
    function variableFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const variableNode = arrayAssignmentNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromVariableAssignmentsNode(variableAssignmentsNode, context2) {
      const type = variableAssignmentsNode.getType();
      return type;
    }
    function anonymousProcedureFromReduceNode(reduceNode, context2) {
      const anonymousProcedureNode = reduceNode.getAnonymousProcedureNode(), anonymousProcedure = anonymousProcedureFromAnonymousProcedureNode(anonymousProcedureNode, context2);
      return anonymousProcedure;
    }
    function variableFromObjectAssignmentNode(objectAssignmentNode, context2) {
      const variableNode = objectAssignmentNode.getVariableNode(), variable = variableFromVariableNode(variableNode, context2);
      return variable;
    }
    function typeFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const type = procedureDeclarationNode.getType();
      return type;
    }
    function expressionFromTypeAndVariableNode(type, variableNode, context2) {
      const expression = null;
      return expression;
    }
    function parametersFromArrayAssignmentNode(arrayAssignmentNode, context2) {
      const parametersNode = arrayAssignmentNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function labelFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const labelNode = procedureDeclarationNode.getLabelNode(), label = labelFromLabelNode(labelNode, context2);
      return label;
    }
    function returnStatementFromReturnBlockNode(returnBlockNode, context2) {
      const returnStatementNode = returnBlockNode.getReturnStatementNode(), returnStatement = returnStatementFromReturnStatementNode(returnStatementNode, context2);
      return returnStatement;
    }
    function bracketedTermFromBracketedTermNode(bracketedTermNode, context2) {
      const {BracketedTerm} = _elements.default, node = bracketedTermNode, string = context2.nodeAsString(node), term = termFromBracketedTermNode(bracketedTermNode, context2), bracketedTerm = new BracketedTerm(context2, string, node, term);
      return bracketedTerm;
    }
    function expressionFromVariableAssignmentNode(variableAssigmentNode, context2) {
      const expressionNode = variableAssigmentNode.getExpressionNode(), expression = expressionFromExpressionNode(expressionNode, context2);
      return expression;
    }
    function parametersFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const parametersNode = anonymousProcedureNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function comparisonTermFromComparisonTermNode(comparisonTermNode, context2) {
      const {ComparisonTerm} = _elements.default, node = comparisonTermNode, string = context2.nodeAsString(node), negated = negatedFromComparisonTermNode(comparisonTermNode, context2), leftTerm = leftTermFromCompzrisonTermNode(comparisonTermNode, context2), rightTerm = rightTermFromCompzrisonTermNode(comparisonTermNode, context2), comparisonTerm = new ComparisonTerm(context2, string, node, negated, leftTerm, rightTerm);
      return comparisonTerm;
    }
    function returnBlockFromAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const returnBlockNode = anonymousProcedureNode.getReturnBlockNode(), returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      return returnBlock;
    }
    function procedureFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const {Procedure} = _elements.default, node = procedureDeclarationNode, type = typeFromProcedureDeclarationNode(procedureDeclarationNode, context2), label = labelFromProcedureDeclarationNode(procedureDeclarationNode, context2), parameters = parametersFromProcedureDeclarationNode(procedureDeclarationNode, context2), returnBlock = returnBlockFromProcedureDeclarationNode(procedureDeclarationNode, context2), procedureString = (0, _string.procedureStringFromTypeLabelParametersAndReturnBlock)(type, label, parameters, returnBlock), string = procedureString, procedure = new Procedure(context2, string, node, type, label, parameters, returnBlock);
      return procedure;
    }
    function parametersFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const parametersNode = procedureDeclarationNode.getParametersNode(), parameters = parametersFromParametersNode(parametersNode, context2);
      return parameters;
    }
    function typeFromProcedureAnonymousProcedureNode(anonymousProcedureNode, context2) {
      const type = anonymousProcedureNode.getType();
      return type;
    }
    function returnBlockFromProcedureDeclarationNode(procedureDeclarationNode, context2) {
      const returnBlockNode = procedureDeclarationNode.getReturnBlockNode(), returnBlock = returnBlockFromReturnBlockNode(returnBlockNode, context2);
      return returnBlock;
    }
    function variableFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2) {
      const variableNode = variableAssignmentNode.getVariableNode(), variable = variableFromTypeAndVariableNode(type, variableNode, context2);
      return variable;
    }
    function variableAssignmentFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2) {
      const {VariableAssignment} = _elements.default, node = variableAssignmentNode, variable = variableFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2), expression = expressionFromVariableAssignmentNode(variableAssignmentNode, context2), variableAssignmentString = (0, _string.variableAssignmentStringFromTypeAndVariable)(type, variable, context2), string = variableAssignmentString, assignment = new VariableAssignment(context2, string, node, variable, expression);
      return assignment;
    }
    function termsArrayFromTermNodes(termNodes, context2) {
      const termsArray = termNodes.map((termNode) => {
        const term = termFromTermNode(termNode, context2);
        return term;
      });
      return termsArray;
    }
    function paramtersArrayFromParametersNode(parametersNode, context2) {
      const parameterNodes = parametersNode.getParameterNodes(), paramtersArray = parameterNodes.map((parameterNode) => {
        const parameter = parameterFromParameterNode(parameterNode, context2);
        return parameter;
      });
      return paramtersArray;
    }
    function namedParamtersArrayFromNamedParameterNodes(namedParameterNodes, context2) {
      const namedParamtersArray = namedParameterNodes.map((namedParameterNode) => {
        const namedParameter = namedParameterFromNamedParameterNode(namedParameterNode, context2);
        return namedParameter;
      });
      return namedParamtersArray;
    }
    function variableAssignmentsArrayFromTypeAndVariableAssignmentsNode(type, variableAssignmentsNode, context2) {
      const variableAssignmentNodes = variableAssignmentsNode.getVariableAssignmentNodes(), variableAssignmentsArray = variableAssignmentNodes.map((variableAssignmentNode) => {
        const variableAssignment = variableAssignmentFromTypeAndVariableAssignmentNode(type, variableAssignmentNode, context2);
        return variableAssignment;
      });
      return variableAssignmentsArray;
    }
  });

  // lib/process/verify.js
  var require_verify2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "verifyFile", {
      enumerable: true,
      get: function() {
        return verifyFile;
      }
    });
    var _occamlanguages = require_lib14();
    var _element = require_element5();
    var {nodeQuery} = _occamlanguages.queryUtilities;
    var errorNodeQuery = nodeQuery("/error");
    var procedureDeclarationNodeQuery = nodeQuery("/procedureDeclaration");
    var TopLevelPass = class extends _occamlanguages.SimplePass {
    };
    __publicField(TopLevelPass, "maps", [
      {
        nodeQuery: errorNodeQuery,
        run: (errorNode, context2) => {
          let success = false;
          const error = (0, _element.errorFromErrorNode)(errorNode, context2), errorVerifies = error.verify(context2);
          if (errorVerifies) {
            success = true;
          }
          return success;
        }
      },
      {
        nodeQuery: procedureDeclarationNodeQuery,
        run: (procedureDeclarationNode, context2) => {
          let success = false;
          const procedureDeclaration = (0, _element.procedureDeclarationFromProcedureDeclarationNode)(procedureDeclarationNode, context2), procedureDeclarationVerifies = procedureDeclaration.verify(context2);
          if (procedureDeclarationVerifies) {
            success = true;
          }
          return success;
        }
      }
    ]);
    var topLevelPass = new TopLevelPass();
    function verifyFile(fileNode, context2) {
      let fileVerifies = false;
      const node = fileNode, sucess = topLevelPass.run(node, context2);
      if (sucess) {
        fileVerifies = true;
      }
      return fileVerifies;
    }
  });

  // lib/utilities/lexers.js
  var require_lexers2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get furtleLexerFromEntries() {
        return furtleLexerFromEntries;
      },
      get furtleLexerFromNothing() {
        return furtleLexerFromNothing;
      }
    });
    var _occamlexers = require_lib3();
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {lexerFromRules, rulesFromEntries} = _occamlexers.lexerUtilities;
    function furtleLexerFromNothing(Class) {
      if (Class === void 0) {
        Class = _lexer.default;
      }
      const {entries} = _lexer.default;
      let rules;
      rules = rulesFromEntries(entries);
      const furtleLexer = lexerFromRules(Class, rules);
      return furtleLexer;
    }
    function furtleLexerFromEntries(Class, entries) {
      if (entries === void 0) {
        entries = Class;
        Class = _lexer.default;
      }
      let rules;
      rules = rulesFromEntries(entries);
      const furtleLexer = lexerFromRules(Class, rules);
      return furtleLexer;
    }
    var _default = {
      furtleLexerFromEntries,
      furtleLexerFromNothing
    };
  });

  // lib/utilities/parsers.js
  var require_parsers2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get furtleParserFromBNF() {
        return furtleParserFromBNF;
      },
      get furtleParserFromBNFAndStartRuleName() {
        return furtleParserFromBNFAndStartRuleName;
      },
      get furtleParserFromNothing() {
        return furtleParserFromNothing;
      }
    });
    var _occamparsers = require_lib4();
    var _occamgrammarutilities = require_lib10();
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {rulesFromBNF, parserFromRules, parserFromRulesAndStartRuleName} = _occamparsers.parserUtilities;
    function furtleParserFromBNF(Class, bnf) {
      if (bnf === void 0) {
        bnf = Class;
        Class = _parser.default;
      }
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRules(Class, rules);
      return furtleParser;
    }
    function furtleParserFromNothing(Class) {
      if (Class === void 0) {
        Class = _parser.default;
      }
      const {bnf} = _parser.default;
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRules(Class, rules);
      return furtleParser;
    }
    function furtleParserFromBNFAndStartRuleName(Class, bnf, startRuleName) {
      if (startRuleName === void 0) {
        startRuleName = bnf;
        bnf = Class;
        Class = _parser.default;
      }
      let rules;
      rules = rulesFromBNF(bnf);
      rules = (0, _occamgrammarutilities.eliminateLeftRecursion)(rules);
      const furtleParser = parserFromRulesAndStartRuleName(Class, rules, startRuleName);
      return furtleParser;
    }
    var _default = {
      furtleParserFromBNF,
      furtleParserFromNothing,
      furtleParserFromBNFAndStartRuleName
    };
  });

  // lib/utilities/furtle.js
  var require_furtle = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get furtleLexer() {
        return furtleLexer;
      },
      get furtleParser() {
        return furtleParser;
      }
    });
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    var _lexers = require_lexers2();
    var _parsers = require_parsers2();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var furtleLexer = (0, _lexers.furtleLexerFromNothing)(_lexer.default);
    var furtleParser = (0, _parsers.furtleParserFromNothing)(_parser.default);
  });

  // lib/context/file/furtle.js
  var require_furtle2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FurtleFileContext;
      }
    });
    var _occamlanguages = require_lib14();
    var _verify = require_verify2();
    var _furtle = require_furtle();
    var FurtleFileContext = class extends _occamlanguages.FileContext {
      constructor(context2, filePath, tokens, node, procedures) {
        super(context2, filePath, tokens, node);
        this.procedures = procedures;
      }
      getProcedures(includeRelease = true) {
        const procedures = includeRelease ? this.context.getProcedures() : this.procedures;
        return procedures;
      }
      getLexer() {
        const lexer = _furtle.furtleLexer;
        return lexer;
      }
      getParser() {
        const parser = _furtle.furtleParser;
        return parser;
      }
      getLabels(includeRelease = true) {
        const labels = [];
        return labels;
      }
      getTypes(includeRelease = true) {
        const types = [];
        return types;
      }
      getRules(includeRelease = true) {
        const rules = [];
        return rules;
      }
      getAxioms(includeRelease = true) {
        const axioms = [];
        return axioms;
      }
      getLemmas(includeRelease = true) {
        const lemmas = [];
        return lemmas;
      }
      getTheorems(includeRelease = true) {
        const theorems = [];
        return theorems;
      }
      getVariables(includeRelease = true) {
        const variables = [];
        return variables;
      }
      getMetaLemmas(includeRelease = true) {
        const metaLemmas = [];
        return metaLemmas;
      }
      getConjectures(includeRelease = true) {
        const conjectures = [];
        return conjectures;
      }
      getCombinators(includeRelease = true) {
        const combinators = [];
        return combinators;
      }
      getTypePrefixes(includeRelease = true) {
        const typePrefixes = [];
        return typePrefixes;
      }
      getConstructors(includeRelease = true) {
        const constructors = [];
        return constructors;
      }
      getMetatheorems(includeRelease = true) {
        const metatheorems = [];
        return metatheorems;
      }
      getMetavariables(includeRelease = true) {
        const metavariables = [];
        return metavariables;
      }
      addProcedure(procedure) {
        const procedureString = procedure.getString();
        this.procedures.push(procedure);
        const filePath = this.getFilePath();
        this.debug(`Added the '${procedureString}' procedure to the '${filePath}' file context.`);
      }
      findProcedureByProcedureName(procedureName) {
        const procedures = this.getProcedures(), procedure = procedures.find((procedure2) => {
          const procedureComparesToProcedureName = procedure2.compareProcedureName(procedureName);
          if (procedureComparesToProcedureName) {
            return true;
          }
        }) || null;
        return procedure;
      }
      isProcedurePresentByProcedureName(procedureName) {
        const procedure = this.findProcedureByProcedureName(procedureName), procedurePresent = procedure !== null;
        return procedurePresent;
      }
      clear() {
        this.procedures = [];
      }
      complete() {
      }
      async verifyFile() {
        const node = this.getNode(), context2 = this, fileNode = node, fileVerifies = (0, _verify.verifyFile)(fileNode, context2);
        return fileVerifies;
      }
      static fromFile(file, context2) {
        const procedures = [], furtleFileContext = _occamlanguages.FileContext.fromFile(FurtleFileContext, file, procedures, context2);
        return furtleFileContext;
      }
      static fromFilePath(filePath, context2) {
        const procedures = null, furtleFileContext = ileContext.fromFilePath(FurtleFileContext, filePath, procedures, context2);
        return furtleFileContext;
      }
    };
  });

  // lib/utilities/terms.js
  var require_terms3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get default() {
        return _default;
      },
      get termsFromNodes() {
        return termsFromNodes;
      },
      get termsFromPrimitives() {
        return termsFromPrimitives;
      }
    });
    var _elements = /* @__PURE__ */ _interop_require_default(require_elements2());
    var _string = require_string5();
    var _term = require_term();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function termsFromNodes(nodes, context2) {
      const {Terms} = _elements.default, termsArray = termsArrayFromNodes(nodes, context2), termsString = (0, _string.termsStringFromTermsArray)(termsArray), string = termsString, array = termsArray, node = null;
      context2 = null;
      const terms = new Terms(context2, string, node, array);
      return terms;
    }
    function termsFromPrimitives(primitives) {
      const {Terms} = _elements.default, termsArray = termsArrayFromPrimitives(primitives), termsString = (0, _string.termsStringFromTermsArray)(termsArray), context2 = null, string = termsString, array = termsArray, node = null, terms = new Terms(context2, string, node, array);
      return terms;
    }
    var _default = {
      termsFromNodes,
      termsFromPrimitives
    };
    function termsArrayFromNodes(nodes, context2) {
      const termsArray = nodes.map((node) => {
        const term = (0, _term.termFromNode)(node, context2);
        return term;
      });
      return termsArray;
    }
    function termsArrayFromPrimitives(primitives) {
      const termsArray = primitives.map((primitive) => {
        const term = (0, _term.termFromPrimitive)(primitive);
        return term;
      });
      return termsArray;
    }
  });

  // lib/index.js
  var require_lib15 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: Object.getOwnPropertyDescriptor(all, name).get
        });
    }
    _export(exports, {
      get FurtleFileContext() {
        return _furtle.default;
      },
      get FurtleLexer() {
        return _lexer.default;
      },
      get FurtleParser() {
        return _parser.default;
      },
      get Terms() {
        return _terms.default;
      },
      get lexersUtilities() {
        return _lexers.default;
      },
      get parsersUtilities() {
        return _parsers.default;
      },
      get primitiveUtilities() {
        return _primitive.default;
      },
      get termUtilities() {
        return _term.default;
      },
      get termsUtilities() {
        return _terms1.default;
      }
    });
    require_preamble();
    var _terms = /* @__PURE__ */ _interop_require_default(require_terms());
    var _lexer = /* @__PURE__ */ _interop_require_default(require_lexer14());
    var _parser = /* @__PURE__ */ _interop_require_default(require_parser15());
    var _furtle = /* @__PURE__ */ _interop_require_default(require_furtle2());
    var _term = /* @__PURE__ */ _interop_require_default(require_term());
    var _terms1 = /* @__PURE__ */ _interop_require_default(require_terms3());
    var _lexers = /* @__PURE__ */ _interop_require_default(require_lexers2());
    var _parsers = /* @__PURE__ */ _interop_require_default(require_parsers2());
    var _primitive = /* @__PURE__ */ _interop_require_default(require_primitive());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  // lib/example/view/subHeading.js
  var require_subHeading = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SubHeading = _easywithstyle.default.h2`

  margin: 1rem 0 0.5rem 0;
  font-size: 2rem;
  
  :first-of-type {
    margin-top: 0;
  }

`;
    var _default = SubHeading;
  });

  // lib/example/view/div/sizeable.js
  var require_sizeable2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easylayout = require_lib9();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = (0, _easywithstyle.default)(_easylayout.SizeableDiv)`

  width: 80rem;
  min-width: 48rem;
  
`;
  });

  // lib/example/view/textarea.js
  var require_textarea2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = (0, _easywithstyle.default)(_easy.Textarea)`

  border: 1px solid darkgrey;
  height: 36rem;
  resize: vertical;
  padding: 0.25rem;
  font-size: 1.2rem;
  line-height: 1.5rem;
  white-space: pre;
  font-family: monospace;

`;
  });

  // lib/example/view/textarea/bnf.js
  var require_bnf14 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return BNFTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BNFTextarea = class extends _textarea.default {
      getBNF() {
        const value = this.getValue(), bnf = value;
        return bnf;
      }
      setBNF(bnf) {
        const value = bnf;
        this.setValue(value);
      }
      parentContext() {
        const getBNF = this.getBNF.bind(this), setBNF = this.setBNF.bind(this);
        return {
          getBNF,
          setBNF
        };
      }
    };
    __publicField(BNFTextarea, "defaultProperties", {
      className: "bnf",
      spellCheck: "false"
    });
  });

  // lib/example/view/input/ruleName.js
  var require_ruleName8 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RuleNameInput = class extends _easy.Input {
      getRuleName() {
        const value = this.getValue(), ruleName = value;
        return ruleName;
      }
      setRuleName(ruleName) {
        const value = ruleName;
        this.setValue(value);
      }
      parentContext() {
        const getRuleName = this.getRuleName.bind(this), setRuleName = this.setRuleName.bind(this);
        return {
          getRuleName,
          setRuleName
        };
      }
    };
    __publicField(RuleNameInput, "defaultProperties", {
      className: "rule-name",
      spellCheck: "false"
    });
    var _default = (0, _easywithstyle.default)(RuleNameInput)`

  border: 1px solid darkgrey;
  padding: 0.25rem;
  font-size: 1.2rem;
  font-family: monospace;
  
`;
  });

  // lib/example/view/textarea/tokens.js
  var require_tokens2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return TokensTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TokensTextarea = class extends _textarea.default {
      setTokens(tokens) {
        let lineNumber = 1, previousToken = null;
        const html = tokens.reduce((html2, token) => {
          const tokenHTML = token.asHTML();
          if (previousToken === null) {
            html2 += `${lineNumber++}: `;
          } else {
            const previousTokenEndOfLineToken = previousToken.isEndOfLineToken();
            if (previousTokenEndOfLineToken) {
              html2 += `${lineNumber++}: `;
            }
          }
          html2 += tokenHTML;
          previousToken = token;
          return html2;
        }, _constants.EMPTY_STRING);
        this.html(html);
      }
      clearTokens() {
        const html = _constants.EMPTY_STRING;
        this.html(html);
      }
      parentContext() {
        const setTokens = this.setTokens.bind(this), clearTokens = this.clearTokens.bind(this);
        return {
          setTokens,
          clearTokens
        };
      }
    };
    __publicField(TokensTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/view/textarea/content.js
  var require_content4 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ContentTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ContentTextarea = class extends _textarea.default {
      getContent() {
        const value = this.getValue(), content = value;
        return content;
      }
      setContent(content) {
        const value = content;
        this.setValue(value);
      }
      parentContext() {
        const getContent = this.getContent.bind(this), setContent = this.setContent.bind(this);
        return {
          getContent,
          setContent
        };
      }
    };
    __publicField(ContentTextarea, "defaultProperties", {
      className: "content",
      spellCheck: "false"
    });
  });

  // lib/example/view/textarea/parseTree.js
  var require_parseTree2 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ParseTreeTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    var _constants = require_constants13();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ParseTreeTextarea = class extends _textarea.default {
      setParseTree(parseTree) {
        if (parseTree !== null) {
          parseTree.shiftLine();
          const parseTreeString = parseTree.asString(), value = parseTreeString;
          this.setValue(value);
        } else {
          this.clearParseTree();
        }
      }
      clearParseTree() {
        const value = _constants.EMPTY_STRING;
        this.setValue(value);
      }
      parentContext() {
        const setParseTree = this.setParseTree.bind(this), clearParseTree = this.clearParseTree.bind(this);
        return {
          setParseTree,
          clearParseTree
        };
      }
    };
    __publicField(ParseTreeTextarea, "defaultProperties", {
      className: "tokens",
      spellCheck: "false",
      readOnly: true
    });
  });

  // lib/example/view/textarea/lexicalEntries.js
  var require_lexicalEntries = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return LexicalEntriesTextarea;
      }
    });
    var _textarea = /* @__PURE__ */ _interop_require_default(require_textarea2());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var LexicalEntriesTextarea = class extends _textarea.default {
      getLexicalEntries() {
        const value = this.getValue(), lexicalEntries = JSON.parse(value);
        return lexicalEntries;
      }
      setLexicalEntries(lexicalEntries) {
        const value = JSON.stringify(lexicalEntries, null, "  ");
        this.setValue(value);
      }
      parentContext() {
        const getLexicalEntries = this.getLexicalEntries.bind(this), setLexicalEntries = this.setLexicalEntries.bind(this);
        return {
          getLexicalEntries,
          setLexicalEntries
        };
      }
    };
    __publicField(LexicalEntriesTextarea, "defaultProperties", {
      className: "lexical-entries",
      spellCheck: "false"
    });
  });

  // lib/example/view.js
  var require_view = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _easylayout = require_lib9();
    var _index = require_lib15();
    var _subHeading = /* @__PURE__ */ _interop_require_default(require_subHeading());
    var _sizeable = /* @__PURE__ */ _interop_require_default(require_sizeable2());
    var _bnf = /* @__PURE__ */ _interop_require_default(require_bnf14());
    var _ruleName = /* @__PURE__ */ _interop_require_default(require_ruleName8());
    var _tokens = /* @__PURE__ */ _interop_require_default(require_tokens2());
    var _content = /* @__PURE__ */ _interop_require_default(require_content4());
    var _parseTree = /* @__PURE__ */ _interop_require_default(require_parseTree2());
    var _lexicalEntries = /* @__PURE__ */ _interop_require_default(require_lexicalEntries());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {furtleParserFromBNF} = _index.parsersUtilities;
    var {furtleLexerFromEntries} = _index.lexersUtilities;
    var {bnf} = _index.FurtleParser;
    var {entries} = _index.FurtleLexer;
    var View = class extends _easy.Element {
      keyUpHandler = (event, element) => {
        const tokens = this.getTokens(), parseTree = this.getParseTree(tokens);
        this.setTokens(tokens);
        this.setParseTree(parseTree);
      };
      getTokens() {
        const lexicalEntries = this.getLexicalEntries(), entries2 = lexicalEntries, furtleLexer = furtleLexerFromEntries(entries2), lexer = furtleLexer, content = this.getContent(), tokens = lexer.tokenise(content);
        return tokens;
      }
      getParseTree(tokens) {
        let parseTree = null;
        const bnf2 = this.getBNF(), furtleParser = furtleParserFromBNF(bnf2), parser = furtleParser, ruleName = this.getRuleName(), ruleMap = parser.getRuleMap(), rule = ruleMap[ruleName], node = parser.parse(tokens, rule);
        if (node !== null) {
          parseTree = node.asParseTree(tokens);
        }
        return parseTree;
      }
      childElements() {
        return /* @__PURE__ */ React.createElement(_easylayout.ColumnsDiv, null, /* @__PURE__ */ React.createElement(_sizeable.default, null, /* @__PURE__ */ React.createElement(_easylayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Lexical entries"), /* @__PURE__ */ React.createElement(_lexicalEntries.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "BNF"), /* @__PURE__ */ React.createElement(_bnf.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Rule name"), /* @__PURE__ */ React.createElement(_ruleName.default, {
          onKeyUp: this.keyUpHandler
        }))), /* @__PURE__ */ React.createElement(_easylayout.VerticalSplitterDiv, null), /* @__PURE__ */ React.createElement(_easylayout.ColumnDiv, null, /* @__PURE__ */ React.createElement(_easylayout.RowsDiv, null, /* @__PURE__ */ React.createElement(_subHeading.default, null, "Content"), /* @__PURE__ */ React.createElement(_content.default, {
          onKeyUp: this.keyUpHandler
        }), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Tokens"), /* @__PURE__ */ React.createElement(_tokens.default, null), /* @__PURE__ */ React.createElement(_subHeading.default, null, "Parse tree"), /* @__PURE__ */ React.createElement(_parseTree.default, null))));
      }
      initialise() {
        this.assignContext();
        const {initialContent, initialRuleName} = this.constructor, content = initialContent, ruleName = initialRuleName, lexicalEntries = entries;
        this.setBNF(bnf);
        this.setContent(content);
        this.setRuleName(ruleName);
        this.setLexicalEntries(lexicalEntries);
        this.keyUpHandler();
      }
    };
    __publicField(View, "initialRuleName", "variableAssignment");
    __publicField(View, "initialContent", `Boolean variableBound = isVariableBound(termNode, statementNode);`);
    __publicField(View, "tagName", "div");
    __publicField(View, "defaultProperties", {
      className: "view"
    });
    var _default = (0, _easywithstyle.default)(View)`

  padding: 1rem;
 
`;
  });

  // lib/example.js
  var require_example3 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_lib2();
    var _easywithstyle = /* @__PURE__ */ _interop_require_default(require_lib7());
    var _easy = require_lib();
    var _view = /* @__PURE__ */ _interop_require_default(require_view());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var {renderStyles} = _easywithstyle.default;
    renderStyles();
    var body = new _easy.Body();
    body.mount(/* @__PURE__ */ React.createElement(_view.default, null));
  });
  require_example3();
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL29mZnNldC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvYm91bmRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL29iamVjdC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdXRpbGl0aWVzL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9lbGVtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvZG9tLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvdGV4dEVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL3V0aWxpdGllcy9lbGVtZW50cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZXZlbnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2pzeC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2tleS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9tb3VzZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2NsaWNrLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvdG91Y2guanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zY3JvbGwuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9yZXNpemUuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9mdWxsU2NyZWVuLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy91dGlsaXRpZXMvYXN5bmMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9jdXN0b21FdmVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvcmVhY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21vdXNlQnV0dG9ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvbWl4aW5zL2lucHV0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9taXhpbnMvZm9jdXMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL21peGlucy9zZWxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2RvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy93aW5kb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvYm9keS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9saW5rLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2lucHV0LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5L3NyYy9lbGVtZW50L2J1dHRvbi5qcyIsICJub2RlX21vZHVsZXMvZWFzeS9zcmMvZWxlbWVudC9zZWxlY3QuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvY2hlY2tib3guanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2VsZW1lbnQvdGV4dGFyZWEuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3kvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9qdXh0YXBvc2Uvc3JjL2p1eHRhcG9zZS5qcyIsICJub2RlX21vZHVsZXMvanV4dGFwb3NlL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdGFnTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvbGV2ZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL21ldGhvZHMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvaGVhZGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9rZXlDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9lbmNvZGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY2hhcmFjdGVycy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9zdGF0dXNDb2Rlcy5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy9jb250ZW50VHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvc3RhdHVzTWVzc2FnZXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvaHR0cC5qcyIsICJub2RlX21vZHVsZXMvbmVjZXNzYXJ5L3NyYy91dGlsaXRpZXMvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9uZWNlc3Nhcnkvc3JjL3V0aWxpdGllcy9hc3luY2hyb25vdXMuanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvdXRpbGl0aWVzL2FqYXguanMiLCAibm9kZV9tb2R1bGVzL25lY2Vzc2FyeS9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2NvbnRlbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdHlwZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9zcGVjaWFsU3ltYm9scy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy91dGlsaXRpZXMvcnVsZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdXRpbGl0aWVzL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL2JuZi9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3V0aWxpdGllcy90b2tlbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9jb21tb24vbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvd2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9ibmYvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvYmFzaWMvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9weXRob25TdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9weXRob25TdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy9iYXNpYy9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9zaWduaWZpY2FudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9zaW5nbGVMaW5lL2NTdHlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGV4ZXJzL3NyYy90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZi9jU3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxleGVycy9zcmMvdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvbWlkZGxlT2YvY1N0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sZXhlcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jc3MvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ibmYvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL21peGlucy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnNlVHJlZS92ZXJ0aWNhbEJyYW5jaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvdXRpbGl0aWVzL3Rva2Vucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUvaG9yaXpvbnRhbEJyYW5jaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2NoaWxkTm9kZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnNlVHJlZS9ub25UZXJtaW5hbE5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlTmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9ydWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL3Rlcm1pbmFsTm9kZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS90ZXJtaW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2Vwc2lsb25Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL3Rlcm1pbmFsL2Vwc2lsb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvdGVybWluYWwvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL3dpbGRjYXJkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL2VuZE9mTGluZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvdGVybWluYWwvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0Q2hvaWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9wYXJ0Q2hvaWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9xdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvcGFyc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL2RlZmluaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL2RlZmluaXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi90ZXJtaW5hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvY2hvaWNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zdHJpbmdMaXRlcmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9ub25UZXJtaW5hbFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvbm9uVGVybWluYWwvc2VxdWVuY2VPZlBhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL29wYWNpdHlNb2RpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFyc2VUcmVlL25vV2hpdGVzcGFjZU5vZGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvdGVybWluYWwvbm9XaGl0ZXNwYWNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL25vV2hpdGVzcGFjZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvY2FsbEFoZWFkTW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnQvdGVybWluYWwvcmVndWxhckV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJzZVRyZWUvc3RhcnRPZkNvbnRlbnROb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9wYXJ0L3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub2RlL2JuZi9zdGFydE9mQ29udGVudFBhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL29wdGlvbmFsUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvb25lT25lT3JNb3JlUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvbm9kZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL25vZGUvYm5mL3plcm9PbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ub25UZXJtaW5hbE5vZGVNYXAuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9taXhpbnMvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL25hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3BhcnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvcnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZXJyb3IuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vc3RyaW5nTGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZXBzaWxvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9kb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3J1bGVOYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi93aWxkY2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZW5kT2ZMaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL3BhcnRDaG9pY2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3BhcnRDaG9pY2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3F1YW50aWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvZGVmaW5pdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9wcmVjZWRlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL2RlZmluaXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9kZWZpbml0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvdGVybWluYWxQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL2Nob2ljZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3N0cmluZ0xpdGVyYWwuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL25vblRlcm1pbmFsUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9zZXF1ZW5jZU9mUGFydHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL3NlcXVlbmNlT2ZQYXJ0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9vcGFjaXR5TW9kaWZpZXJSdWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9vcGFjaXR5TW9kaWZpZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL2RlZmluaXRpb24vbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvbm9XaGl0ZXNwYWNlUGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9jYWxsQWhlYWRNb2RpZmllclJ1bGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3J1bGUvYm5mL2NhbGxBaGVhZE1vZGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9yZWd1bGFyRXhwcmVzc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvZGVmaW5pdGlvbi9xdWFudGlmaWVyUnVsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvb3B0aW9uYWxRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9kZWZpbml0aW9uL3N0YXJ0T2ZDb250ZW50UGFydC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvc3RhcnRPZkNvbnRlbnRQYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi9vbmVPck1vcmVRdWFudGlmaWVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9ydWxlL2JuZi96ZXJvT3JNb3JlUXVhbnRpZmllci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvcnVsZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3V0aWxpdGllcy9ydWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvYm5mL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcGFyc2Vycy9zcmMvYmFzaWMvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy91dGlsaXRpZXMvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9jb21tb24vcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9iYXNpYy9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXBhcnNlcnMvc3JjL3BhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1wYXJzZXJzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL2JuZi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvY3NzL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1xdWVyeS9zcmMvcGF0aC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9hcnJheS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3NwcmVhZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3N1YkV4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL2VudHJpZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1xdWVyeS9zcmMvZXhwcmVzc2lvbi9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL2V4cHJlc3Npb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLXF1ZXJ5L3NyYy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL3V0aWxpdGllcy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tcXVlcnkvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9kZWNsYXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvZGVjbGFyYXRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0LmpzIiwgIm5vZGVfbW9kdWxlcy93aXRoLXN0eWxlL3NyYy9zdHlsZS9ydWxlU2V0cy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUvbWVkaWEuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL21lZGlhcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUva2V5ZnJhbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3N0eWxlL2tleWZyYW1lcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUva2V5ZnJhbWVzcy5qcyIsICJub2RlX21vZHVsZXMvd2l0aC1zdHlsZS9zcmMvc3R5bGUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9zdHlsZXMuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzc05hbWUuanMiLCAibm9kZV9tb2R1bGVzL3dpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL3V0aWxpdGllcy9jbGFzcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS13aXRoLXN0eWxlL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktd2l0aC1zdHlsZS9zcmMvd2l0aFN0eWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LXdpdGgtc3R5bGUvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvY3Vyc29ycy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2N1cnNvci5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9yb3cuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvcm93cy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1sYXlvdXQvc3JjL2Rpdi9jb2x1bW4uanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9kaXYvY29sdW1ucy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvdXRpbGl0aWVzL3JlZmVyZW5jZS5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy91dGlsaXRpZXMvZXZlbnQuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvY3VzdG9tRXZlbnRUeXBlcy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9taXhpbnMvZHJhZy5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9taXhpbnMvZHJvcC5qcyIsICJub2RlX21vZHVsZXMvZWFzeS1kcmFnLWFuZC1kcm9wL3NyYy9lbGVtZW50L2RyYWcuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktZHJhZy1hbmQtZHJvcC9zcmMvZWxlbWVudC9kcm9wLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWRyYWctYW5kLWRyb3Avc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NpemVhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyL3ZlcnRpY2FsLmpzIiwgIm5vZGVfbW9kdWxlcy9lYXN5LWxheW91dC9zcmMvZGl2L3NwbGl0dGVyL2hvcml6b250YWwuanMiLCAibm9kZV9tb2R1bGVzL2Vhc3ktbGF5b3V0L3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2VsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvY29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvbGluZUluZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2NvbnRleHQvZmlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvYXN5bmNocm9ub3VzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy92ZXJpZnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvZ3JhbW1hck5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy92b2NhYnVsYXJ5TmFtZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hci9kZWZhdWx0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9sZXhlci9leGFtcGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9wYXJzZXIvbm9uVGVybWluYWxOb2RlTWFwLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZXhhbXBsZS9wYXJzZXIvZXhhbXBsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2N5Y2xlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGlyZWN0ZWRHcmFwaC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmVkdWNlZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9ydWxlTmFtZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9jeWNsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9ub25Db25zdW1pbmcuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2VkZ2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcmVjdXJzaXZlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvbGFiZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL2RpcmVjdGVkR3JhcGguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ydWxlL3JlZHVjZWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9jcmVhdGVSZWR1Y2VkUnVsZXMuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcHJlY2VkZW5jZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmVwZWF0ZWQvZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ub2RlL3JlcGVhdGVkL2luZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy91dGlsaXRpZXMvcmV3cml0ZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL25vZGUvcmV3cml0dGVuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3J1bGVOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9wYXJ0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3BhdGguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9kZWZpbml0aW9uL3Jld3JpdHRlbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3J1bGUvcmV3cml0dGVuLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGVmaW5pdGlvbi9yZXBlYXRlZC9kaXJlY3RseS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9yZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvY3JlYXRlRGlyZWN0bHlSZXBlYXRlZFJ1bGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvZGVmaW5pdGlvbi9lcHNpbG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL3BhcnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL25vblByb2R1Y2luZy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9jb21wbGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL29jY2x1ZGVkLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFyLXV0aWxpdGllcy9zcmMvdXRpbGl0aWVzL2NhbGxBaGVhZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL3V0aWxpdGllcy9xdWFsaWZpZWQuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9ydWxlL3JlcGVhdGVkL2luZGlyZWN0bHkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9jcmVhdGVJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hci11dGlsaXRpZXMvc3JjL2VsaW1pbmF0ZUxlZnRSZWN1cnNpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXItdXRpbGl0aWVzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvcXVlcnkuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy90ZVgvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL3RlWC9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9mdXJ0bGUvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2Z1cnRsZS9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9wbGFpblRleHQvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL3BsYWluVGV4dC9sZXhlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hclZvY2FidWxhcnkvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy90ZVgvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvdGVYL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2pzb24vYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvanNvbi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9mdXJ0bGUvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvZnVydGxlL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL25vbWluYWwvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvbm9taW5hbC9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9wbGFpblRleHQvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvcGxhaW5UZXh0L3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tZ3JhbW1hcnMvc3JjL2N1c3RvbUdyYW1tYXJCTkYvYm5mLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hckJORi9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9ibmYuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9wYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWdyYW1tYXJzL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvZ3JhbW1hci5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvdm9jYWJ1bGFyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvbm9taW5hbC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy90eXBlc01hcC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvdmFsaWRhdGUuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWN1c3RvbS1ncmFtbWFycy9zcmMvY3VzdG9tR3JhbW1hci9jb21iaW5lZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tY3VzdG9tLWdyYW1tYXJzL3NyYy91dGlsaXRpZXMvbGV4ZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3V0aWxpdGllcy9wYXJzZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1jdXN0b20tZ3JhbW1hcnMvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9maWxlQ29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9jb250ZXh0L3JlbGVhc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvbm9uVGVybWluYWxOb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9xdWVyeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy91dGlsaXRpZXMvcGFzcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL3ppcC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL2FzeW5jLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3Bhc3Mvc2ltcGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3Bhc3MvZm9yd2FyZC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbGFuZ3VhZ2VzL3NyYy9wYXNzL2VxdWl2YWxlbmNlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy9kZXBlbmRlbmN5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL3V0aWxpdGllcy92ZXJpZmljYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy90eXBlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2NvbnN0YW50cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9jb250ZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZmlsZS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2ZpbGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvbXVsdGlwbGVycy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdmVyc2lvbi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2RpcmVjdG9yeS5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9uYW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZmlsZU5hbWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvbWl4aW5zL2JuZi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9maWxlUGF0aC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9maWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9maWxlcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL2RlcGVuZGVuY3kuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy9zaG9ydGVuZWRWZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZGVwZW5kZW5jaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdXRpbGl0aWVzL3F1ZXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvdXRpbGl0aWVzL3ZhbGlkYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvcHJvcGVydHlOYW1lcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3V0aWxpdGllcy9tZXRhSlNPTi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9tZXRhSlNPTi5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy92b2NhYnVsYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvZW50cmllcy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL21peGlucy9lbnRyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvcHJvamVjdC5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3JlbGVhc2UuanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLW1vZGVsL3NyYy9wcm9qZWN0cy5qcyIsICJub2RlX21vZHVsZXMvb2NjYW0tbW9kZWwvc3JjL3JlbGVhc2VzLmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1tb2RlbC9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL29jY2FtLWxhbmd1YWdlcy9zcmMvdXRpbGl0aWVzL3JlbGVhc2VDb250ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9vY2NhbS1sYW5ndWFnZXMvc3JjL2luZGV4LmpzIiwgInNyYy9lbGVtZW50cy5qcyIsICJzcmMvZWxlbWVudC9zdGVwLmpzIiwgInNyYy9leGNlcHRpb24uanMiLCAic3JjL3R5cGVzLmpzIiwgInNyYy9udWxsTm9kZS5qcyIsICJzcmMvY29uc3RhbnRzLmpzIiwgInNyYy91dGlsaXRpZXMvc3RyaW5nTGl0ZXJhbC5qcyIsICJzcmMvdXRpbGl0aWVzL3N0cmluZy5qcyIsICJzcmMvdXRpbGl0aWVzL3ByaW1pdGl2ZS5qcyIsICJzcmMvdXRpbGl0aWVzL3Rlcm0uanMiLCAic3JjL2VsZW1lbnQvc29tZS5qcyIsICJzcmMvZWxlbWVudC90ZXJtLmpzIiwgInNyYy9lbGVtZW50L3Rlcm1zLmpzIiwgInNyYy9lbGVtZW50L2xhYmVsLmpzIiwgInNyYy9lbGVtZW50L2Vycm9yLmpzIiwgInNyYy9lbGVtZW50L2V2ZXJ5LmpzIiwgInNyYy9lbGVtZW50L3JlZHVjZS5qcyIsICJzcmMvZWxlbWVudC90ZXJuYXJ5LmpzIiwgInNyYy9lbGVtZW50L3ZhcmlhYmxlLmpzIiwgInNyYy9lbGVtZW50L3ByaW1pdGl2ZS5qcyIsICJzcmMvZWxlbWVudC9yZWZlcmVuY2UuanMiLCAic3JjL2VsZW1lbnQvcHJvY2VkdXJlLmpzIiwgInNyYy9lbGVtZW50L25vZGVRdWVyeS5qcyIsICJzcmMvZWxlbWVudC9wYXJhbWV0ZXIuanMiLCAic3JjL2VsZW1lbnQvcGFyYW1ldGVycy5qcyIsICJzcmMvZWxlbWVudC9ub2Rlc1F1ZXJ5LmpzIiwgInNyYy9lbGVtZW50L2V4cHJlc3Npb24uanMiLCAic3JjL2NvbnRleHQvYmxvY2suanMiLCAic3JjL2VsZW1lbnQvcmV0dXJuQmxvY2suanMiLCAic3JjL2VsZW1lbnQvdGVybS9uZWdhdGVkLmpzIiwgInNyYy9lbGVtZW50L3Rlcm0vbG9naWNhbC5qcyIsICJzcmMvZWxlbWVudC90ZXJtL2JyYWNrZXRlZC5qcyIsICJzcmMvZWxlbWVudC9wcm9jZWR1cmVDYWxsLmpzIiwgInNyYy9lbGVtZW50L3Rlcm0vY29tcGFyaXNvbi5qcyIsICJzcmMvZWxlbWVudC9wYXJhbWV0ZXIvbmFtZWQuanMiLCAic3JjL2VsZW1lbnQvYXNzaWdubWVudC9hcnJheS5qcyIsICJzcmMvZWxlbWVudC9zdGF0ZW1lbnQvcmV0dXJuLmpzIiwgInNyYy9lbGVtZW50L3BhcmFtZXRlcnMvbmFtZWQuanMiLCAic3JjL25vZGVQcm9wZXJ0eS5qcyIsICJzcmMvcGFyYW1ldGVyTmFtZXMuanMiLCAic3JjL25vZGVQcm9wZXJ0aWVzLmpzIiwgInNyYy9lbGVtZW50L2Fzc2lnbm1lbnQvb2JqZWN0LmpzIiwgInNyYy9lbGVtZW50L3Byb2NlZHVyZS9hbm9ueW1vdXMuanMiLCAic3JjL2VsZW1lbnQvYXNzaWdubWVudC92YXJpYWJsZS5qcyIsICJzcmMvZWxlbWVudC9hc3NpZ25tZW50cy92YXJpYWJsZS5qcyIsICJzcmMvZWxlbWVudC9kZWNsYXJhdGlvbi9wcm9jZWR1cmUuanMiLCAic3JjL3ByZWFtYmxlLmpzIiwgInNyYy9mdXJ0bGUvbGV4ZXIuanMiLCAic3JjL3J1bGVOYW1lcy5qcyIsICJzcmMvbm9kZS9zdGVwLmpzIiwgInNyYy9ub2RlL3NvbWUuanMiLCAic3JjL25vZGUvdGVybS5qcyIsICJzcmMvbm9kZS90ZXJtcy5qcyIsICJzcmMvbm9kZS9ldmVyeS5qcyIsICJzcmMvdG9rZW5UeXBlcy5qcyIsICJzcmMvbm9kZS9sYWJlbC5qcyIsICJzcmMvbm9kZS9lcnJvci5qcyIsICJzcmMvbm9kZS9yZWR1Y2UuanMiLCAic3JjL25vZGUvdGVybmFyeS5qcyIsICJzcmMvbm9kZS9kb2N1bWVudC5qcyIsICJzcmMvbm9kZS92YXJpYWJsZS5qcyIsICJzcmMvbm9kZS9ub25zZW5zZS5qcyIsICJzcmMvbm9kZS9wcmltaXRpdmUuanMiLCAic3JjL25vZGUvcmVmZXJlbmNlLmpzIiwgInNyYy9ub2RlL3BhcmFtZXRlci5qcyIsICJzcmMvbm9kZS9ub2RlUXVlcnkuanMiLCAic3JjL25vZGUvZXhwcmVzc2lvbi5qcyIsICJzcmMvbm9kZS9wYXJhbWV0ZXJzLmpzIiwgInNyYy9ub2RlL25vZGVzUXVlcnkuanMiLCAic3JjL25vZGUvcmV0dXJuQmxvY2suanMiLCAic3JjL25vZGUvdGVybS9sb2dpY2FsLmpzIiwgInNyYy9ub2RlL3Rlcm0vbmVnYXRlZC5qcyIsICJzcmMvbm9kZS9wcm9jZWR1cmVDYWxsLmpzIiwgInNyYy9ub2RlL3Rlcm0vYnJhY2tldGVkLmpzIiwgInNyYy9ub2RlL3Rlcm0vY29tcGFyaXNvbi5qcyIsICJzcmMvbm9kZS9wYXJhbWV0ZXIvbmFtZWQuanMiLCAic3JjL25vZGUvcGFyYW1ldGVycy9uYW1lZC5qcyIsICJzcmMvbm9kZS9zdGF0ZW1lbnQuanMiLCAic3JjL25vZGUvc3RhdGVtZW50L3JldHVybi5qcyIsICJzcmMvbm9kZS9hc3NpZ25tZW50LmpzIiwgInNyYy9ub2RlL2Fzc2lnbm1lbnQvYXJyYXkuanMiLCAic3JjL25vZGUvYXNzaWdubWVudC9vYmplY3QuanMiLCAic3JjL25vZGUvcHJvY2VkdXJlLmpzIiwgInNyYy9ub2RlL3Byb2NlZHVyZS9hbm95bW91cy5qcyIsICJzcmMvbm9kZS9hc3NpZ25tZW50L3ZhcmlhYmxlLmpzIiwgInNyYy9ub2RlL2Fzc2lnbm1lbnRzL3ZhcmlhYmxlLmpzIiwgInNyYy9ub2RlL2RlY2xhcmF0aW9uLmpzIiwgInNyYy9ub2RlL2RlY2xhcmF0aW9uL3Byb2NlZHVyZS5qcyIsICJzcmMvbm9uVGVybWluYWxOb2RlTWFwLmpzIiwgInNyYy9mdXJ0bGUvcGFyc2VyLmpzIiwgInNyYy91dGlsaXRpZXMvZWxlbWVudC5qcyIsICJzcmMvcHJvY2Vzcy92ZXJpZnkuanMiLCAic3JjL3V0aWxpdGllcy9sZXhlcnMuanMiLCAic3JjL3V0aWxpdGllcy9wYXJzZXJzLmpzIiwgInNyYy91dGlsaXRpZXMvZnVydGxlLmpzIiwgInNyYy9jb250ZXh0L2ZpbGUvZnVydGxlLmpzIiwgInNyYy91dGlsaXRpZXMvdGVybXMuanMiLCAic3JjL2luZGV4LmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvc3ViSGVhZGluZy5qcyIsICJzcmMvZXhhbXBsZS92aWV3L2Rpdi9zaXplYWJsZS5qcyIsICJzcmMvZXhhbXBsZS92aWV3L3RleHRhcmVhLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvYm5mLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvaW5wdXQvcnVsZU5hbWUuanMiLCAic3JjL2V4YW1wbGUvdmlldy90ZXh0YXJlYS90b2tlbnMuanMiLCAic3JjL2V4YW1wbGUvdmlldy90ZXh0YXJlYS9jb250ZW50LmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvcGFyc2VUcmVlLmpzIiwgInNyYy9leGFtcGxlL3ZpZXcvdGV4dGFyZWEvbGV4aWNhbEVudHJpZXMuanMiLCAic3JjL2V4YW1wbGUvdmlldy5qcyIsICJzcmMvZXhhbXBsZS5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9mZnNldCB7XG4gIGNvbnN0cnVjdG9yKHRvcCwgbGVmdCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21ET01FbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCB9ID0gZG9tRWxlbWVudCxcbiAgICAgICAgICB0b3AgPSBvZmZzZXRUb3AsICAvLy9cbiAgICAgICAgICBsZWZ0ID0gb2Zmc2V0TGVmdCwgIC8vL1xuICAgICAgICAgIG9mZnNldCA9IG5ldyBPZmZzZXQodG9wLCBsZWZ0KTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm91bmRzIHtcbiAgY29uc3RydWN0b3IodG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKSB7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gIH1cblxuICBnZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wO1xuICB9XG5cbiAgZ2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0O1xuICB9XG5cbiAgZ2V0UmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHQ7XG4gIH1cblxuICBnZXRCb3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgY29uc3Qgd2lkdGggPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCk7XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBnZXRIZWlnaHQoKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuYm90dG9tIC0gdGhpcy50b3ApO1xuXG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuICBcbiAgc2V0VG9wKHRvcCkge1xuICAgIHRoaXMudG9wID0gdG9wO1xuICB9XG5cbiAgc2V0TGVmdChsZWZ0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgfVxuXG4gIHNldFJpZ2h0KHJpZ2h0KSB7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB9XG5cbiAgc2V0Qm90dG9tKGJvdHRvbSkge1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG5cbiAgYXJlT3ZlcmxhcHBpbmcoYm91bmRzKSB7XG4gICAgY29uc3QgYm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICAgIHJpZ2h0ID0gYm91bmRzLmdldFJpZ2h0KCksXG4gICAgICAgICAgbGVmdCA9IGJvdW5kcy5nZXRMZWZ0KCksXG4gICAgICAgICAgdG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICAgIG92ZXJsYXBwaW5nID0gKCh0aGlzLnRvcCA8IGJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDwgcmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IHRvcCkpO1xuXG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nO1xuICB9XG5cbiAgYXJlT3ZlcmxhcHBpbmdCeVRvcEFuZExlZnQodG9wLCBsZWZ0KSB7XG4gICAgY29uc3Qgb3ZlcmxhcHBpbmcgPSAoKHRoaXMudG9wIDw9IHRvcClcbiAgICAgICAgICAgICAgICAgICAgICAmJiAodGhpcy5sZWZ0IDw9IGxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMucmlnaHQgPiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLmJvdHRvbSA+IHRvcCkpO1xuXG4gICAgcmV0dXJuIG92ZXJsYXBwaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21ET01FbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHBhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCB9ID0gd2luZG93LFxuICAgICAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgd2luZG93U2Nyb2xsVG9wID0gcGFnZVlPZmZzZXQsIC8vL1xuICAgICAgICAgIHdpbmRvd1Njcm9sbExlZnQgPSBwYWdlWE9mZnNldCwgIC8vL1xuICAgICAgICAgIHRvcCA9IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyB3aW5kb3dTY3JvbGxUb3AsXG4gICAgICAgICAgbGVmdCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgd2luZG93U2Nyb2xsTGVmdCxcbiAgICAgICAgICByaWdodCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5yaWdodCArIHdpbmRvd1Njcm9sbExlZnQsXG4gICAgICAgICAgYm90dG9tID0gYm91bmRpbmdDbGllbnRSZWN0LmJvdHRvbSArIHdpbmRvd1Njcm9sbFRvcCxcbiAgICAgICAgICBib3VuZHMgPSBuZXcgQm91bmRzKHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSk7XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ub3BMZWZ0V2lkdGhBbmRIZWlnaHQodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0LFxuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoLFxuICAgICAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHModG9wLCBsZWZ0LCByaWdodCwgYm90dG9tKTtcblxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7IHJldHVybiBhcnJheVswXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheTEsIGFycmF5MikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheTEsIGFycmF5Mik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnQoYXJyYXkxLCBhcnJheTIsIHRlc3QpIHtcbiAgYXJyYXkxID0gWyAuLi5hcnJheTEgXTsgLy8vXG5cbiAgYXJyYXkyLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gdGVzdChlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheTEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGFycmF5LCBlbGVtZW50KSA9PiB7XG4gICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZWxlbWVudCk7ICAvLy9cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSwgW10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3VhcmFudGVlKGFycmF5T3JFbGVtZW50KSB7XG4gIGFycmF5T3JFbGVtZW50ID0gYXJyYXlPckVsZW1lbnQgfHwgW107XG5cbiAgcmV0dXJuIChhcnJheU9yRWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICBhcnJheU9yRWxlbWVudCA6XG4gICAgICAgICAgICAgIFthcnJheU9yRWxlbWVudF07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBGT1IgPSBcImZvclwiO1xuZXhwb3J0IGNvbnN0IEJPRFkgPSBcImJvZHlcIjtcbmV4cG9ydCBjb25zdCBOT05FID0gXCJub25lXCI7XG5leHBvcnQgY29uc3QgU1BBQ0UgPSBcIiBcIjtcbmV4cG9ydCBjb25zdCBDTEFTUyA9IFwiY2xhc3NcIjtcbmV4cG9ydCBjb25zdCBXSURUSCA9IFwid2lkdGhcIjtcbmV4cG9ydCBjb25zdCBCTE9DSyA9IFwiYmxvY2tcIjtcbmV4cG9ydCBjb25zdCBIRUlHSFQgPSBcImhlaWdodFwiO1xuZXhwb3J0IGNvbnN0IE9CSkVDVCA9IFwib2JqZWN0XCI7XG5leHBvcnQgY29uc3QgU1RSSU5HID0gXCJzdHJpbmdcIjtcbmV4cG9ydCBjb25zdCBESVNQTEFZID0gXCJkaXNwbGF5XCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuZXhwb3J0IGNvbnN0IERJU0FCTEVEID0gXCJkaXNhYmxlZFwiO1xuZXhwb3J0IGNvbnN0IEZVTkNUSU9OID0gXCJmdW5jdGlvblwiO1xuZXhwb3J0IGNvbnN0IFdJTERDQVJEID0gXCIqXCI7XG5leHBvcnQgY29uc3QgSFRNTF9GT1IgPSBcImh0bWxGb3JcIjtcbmV4cG9ydCBjb25zdCBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FID0gXCJjbGFzc05hbWVcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IFNWR19OQU1FU1BBQ0VfVVJJID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJPUEVSVElFUyA9IFwiZGVmYXVsdFByb3BlcnRpZXNcIjtcbmV4cG9ydCBjb25zdCBJR05PUkVEX1BST1BFUlRJRVMgPSBcImlnbm9yZWRQcm9wZXJ0aWVzXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJPT0xFQU4gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKHRhcmdldCwgc291cmNlID0ge30pIHtcbiAgdGFyZ2V0ID0geyAgLy8vXG4gICAgLi4udGFyZ2V0XG4gIH07XG5cbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyAgLy8vXG5cbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W25hbWVdLFxuICAgICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW25hbWVdLFxuICAgICAgICAgIHRhcmdldEhhc093blByb3BlcnR5ID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpO1xuXG4gICAgdGFyZ2V0W25hbWVdID0gdGFyZ2V0SGFzT3duUHJvcGVydHkgP1xuICAgICAgICAgICAgICAgICAgICAgY29tYmluZVZhbHVlcyh0YXJnZXRWYWx1ZSwgc291cmNlVmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU7IC8vL1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJ1bmUodGFyZ2V0LCBuYW1lcyA9IFtdKSB7XG4gIHRhcmdldCA9IHsgIC8vL1xuICAgIC4uLnRhcmdldFxuICB9O1xuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB0YXJnZXRIYXNPd25Qcm9wZXJ0eSA9IHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcblxuICAgIGlmICh0YXJnZXRIYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgZGVsZXRlIHRhcmdldFtuYW1lXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVWYWx1ZXModGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gIGNvbnN0IHRhcmdldFZhbHVlQm9vbGVhbiA9IGlzVmFsdWVCb29sZWFuKHRhcmdldFZhbHVlKSxcbiAgICAgICAgc291cmNlVmFsdWVCb29sZWFuID0gaXNWYWx1ZUJvb2xlYW4oc291cmNlVmFsdWUpLFxuICAgICAgICBjb21iaW5lZFZhbHVlID0gKHRhcmdldFZhbHVlQm9vbGVhbiAmJiBzb3VyY2VWYWx1ZUJvb2xlYW4pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgOiAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0YXJnZXRWYWx1ZX0gJHtzb3VyY2VWYWx1ZX1gO1xuXG4gIHJldHVybiBjb21iaW5lZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbHVlQm9vbGVhbih2YWx1ZSkge1xuICBjb25zdCB2YWx1ZUJvb2xlYW4gPSAodHlwZW9mIHZhbHVlID09PSBCT09MRUFOKTtcblxuICByZXR1cm4gdmFsdWVCb29sZWFuO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxDYXNlVG9TbmFrZUNhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKykvZywgKG1hdGNoLCBjaGFyYWN0ZXJzKSA9PiB7XG4gICAgY29uc3QgdXBwZXJDYXNlQ2hhcmFjdGVycyA9IGNoYXJhY3RlcnMudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICBzbmFrZUNhc2VDaGFyYWN0ZXJzID0gYC0ke3VwcGVyQ2FzZUNoYXJhY3RlcnN9YDtcblxuICAgIHJldHVybiBzbmFrZUNhc2VDaGFyYWN0ZXJzO1xuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZHVGFnTmFtZSh0YWdOYW1lKSB7XG4gIHJldHVybiBzdmdUYWdOYW1lcy5pbmNsdWRlcyh0YWdOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZHQXR0cmlidXRlTmFtZShhdHRyaWJ1dGVOYW1lKSB7XG4gIHJldHVybiBzdmdBdHRyaWJ1dGVOYW1lcy5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSkge1xuICByZXR1cm4gaHRtbEF0dHJpYnV0ZU5hbWVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpO1xufVxuXG5jb25zdCBzdmdUYWdOYW1lcyA9IFtcbiAgICAgICAgXCJhbHRHbHlwaFwiLCBcImFuaW1hdGVcIiwgXCJhbmltYXRlQ29sb3JcIiwgXCJhbmltYXRlTW90aW9uXCIsIFwiYW5pbWF0ZVRyYW5zZm9ybVwiLCBcImFuaW1hdGlvblwiLCBcImF1ZGlvXCIsXG4gICAgICAgIFwiY2lyY2xlXCIsIFwiY2xpcFBhdGhcIiwgXCJjb2xvci1wcm9maWxlXCIsIFwiY3Vyc29yXCIsXG4gICAgICAgIFwiZGVmc1wiLCBcImRlc2NcIiwgXCJkaXNjYXJkXCIsXG4gICAgICAgIFwiZWxsaXBzZVwiLFxuICAgICAgICBcImZlQmxlbmRcIiwgXCJmZUNvbG9yTWF0cml4XCIsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLCBcImZlQ29tcG9zaXRlXCIsIFwiZmVDb252b2x2ZU1hdHJpeFwiLCBcImZlRGlmZnVzZUxpZ2h0aW5nXCIsIFwiZmVEaXNwbGFjZW1lbnRNYXBcIiwgXCJmZURpc3RhbnRMaWdodFwiLCBcImZlRHJvcFNoYWRvd1wiLCBcImZlRmxvb2RcIiwgXCJmZUZ1bmNBXCIsIFwiZmVGdW5jQlwiLCBcImZlRnVuY0dcIiwgXCJmZUZ1bmNSXCIsIFwiZmVHYXVzc2lhbkJsdXJcIiwgXCJmZUltYWdlXCIsIFwiZmVNZXJnZVwiLCBcImZlTWVyZ2VOb2RlXCIsIFwiZmVNb3JwaG9sb2d5XCIsIFwiZmVPZmZzZXRcIiwgXCJmZVBvaW50TGlnaHRcIiwgXCJmZVNwZWN1bGFyTGlnaHRpbmdcIiwgXCJmZVNwb3RMaWdodFwiLCBcImZlVGlsZVwiLCBcImZlVHVyYnVsZW5jZVwiLCBcImZpbHRlclwiLCBcImZvbnRcIiwgXCJmb250LWZhY2VcIiwgXCJmb250LWZhY2UtZm9ybWF0XCIsIFwiZm9udC1mYWNlLW5hbWVcIiwgXCJmb250LWZhY2UtdXJpXCIsIFwiZm9yZWlnbk9iamVjdFwiLFxuICAgICAgICBcImdcIiwgXCJnbHlwaFwiLCBcImdseXBoUmVmXCIsXG4gICAgICAgIFwiaGFuZGxlclwiLCBcImhhdGNoXCIsIFwiaGF0Y2hwYXRoXCIsIFwiaGtlcm5cIixcbiAgICAgICAgXCJpbWFnZVwiLCBcImxpbmVcIiwgXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgICAgICBcImxpc3RlbmVyXCIsXG4gICAgICAgIFwibWFya2VyXCIsIFwibWFza1wiLCBcIm1lc2hcIiwgXCJtZXNoZ3JhZGllbnRcIiwgXCJtZXNocGF0Y2hcIiwgXCJtZXNocm93XCIsIFwibWV0YWRhdGFcIiwgXCJtaXNzaW5nLWdseXBoXCIsIFwibXBhdGhcIixcbiAgICAgICAgXCJwYXRoXCIsIFwicGF0dGVyblwiLCBcInBvbHlnb25cIiwgXCJwb2x5bGluZVwiLCBcInByZWZldGNoXCIsXG4gICAgICAgIFwicmFkaWFsR3JhZGllbnRcIiwgXCJyZWN0XCIsXG4gICAgICAgIFwic2NyaXB0XCIsIFwic2V0XCIsIFwic29saWRjb2xvclwiLCBcInN0b3BcIiwgXCJzdHlsZVwiLCBcInN2Z1wiLCBcInN3aXRjaFwiLCBcInN5bWJvbFwiLFxuICAgICAgICBcInRicmVha1wiLCBcInRleHRcIiwgXCJ0ZXh0QXJlYVwiLCBcInRleHRQYXRoXCIsIFwidGl0bGVcIiwgXCJ0cmVmXCIsIFwidHNwYW5cIixcbiAgICAgICAgXCJ1bmtub3duXCIsIFwidXNlXCIsXG4gICAgICAgIFwidmlkZW9cIiwgXCJ2aWV3XCIsIFwidmtlcm5cIlxuICAgICAgXSxcbiAgICAgIHN2Z0F0dHJpYnV0ZU5hbWVzID0gW1xuICAgICAgICBcImFjY2VudC1oZWlnaHRcIiwgXCJhY2N1bXVsYXRlXCIsIFwiYWRkaXRpdmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJhbHBoYWJldGljXCIsIFwiYW1wbGl0dWRlXCIsIFwiYXJhYmljLWZvcm1cIiwgXCJhc2NlbnRcIiwgXCJhdHRyaWJ1dGVOYW1lXCIsIFwiYXR0cmlidXRlVHlwZVwiLCBcImF6aW11dGhcIixcbiAgICAgICAgXCJiYW5kd2lkdGhcIiwgXCJiYXNlRnJlcXVlbmN5XCIsIFwiYmFzZVByb2ZpbGVcIiwgXCJiYXNlbGluZS1zaGlmdFwiLCBcImJib3hcIiwgXCJiZWdpblwiLCBcImJpYXNcIiwgXCJieVwiLFxuICAgICAgICBcImNhbGNNb2RlXCIsIFwiY2FwLWhlaWdodFwiLCBcImNsaXBcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGlwLXBhdGhcIiwgXCJjbGlwLXJ1bGVcIiwgXCJjbGlwUGF0aFVuaXRzXCIsIFwiY29sb3JcIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsIFwiY29sb3ItcHJvZmlsZVwiLCBcImNvbG9yLXJlbmRlcmluZ1wiLCBcImNvbnRlbnRTY3JpcHRUeXBlXCIsIFwiY29udGVudFN0eWxlVHlwZVwiLCBcImNyb3Nzb3JpZ2luXCIsIFwiY3Vyc29yXCIsIFwiY3hcIiwgXCJjeVwiLFxuICAgICAgICBcImRcIiwgXCJkZWZhdWx0QWN0aW9uXCIsIFwiZGVzY2VudFwiLCBcImRpZmZ1c2VDb25zdGFudFwiLCBcImRpcmVjdGlvblwiLCBcImRpc3BsYXlcIiwgXCJkaXZpc29yXCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJkb3dubG9hZFwiLCBcImR1clwiLCBcImR4XCIsIFwiZHlcIixcbiAgICAgICAgXCJlZGdlTW9kZVwiLCBcImVkaXRhYmxlXCIsIFwiZWxldmF0aW9uXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIiwgXCJlbmRcIiwgXCJldmVudFwiLCBcImV4cG9uZW50XCIsIFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFxuICAgICAgICBcImZpbGxcIiwgXCJmaWxsLW9wYWNpdHlcIiwgXCJmaWxsLXJ1bGVcIiwgXCJmaWx0ZXJcIiwgXCJmaWx0ZXJSZXNcIiwgXCJmaWx0ZXJVbml0c1wiLCBcImZsb29kLWNvbG9yXCIsIFwiZmxvb2Qtb3BhY2l0eVwiLCBcImZvY3VzSGlnaGxpZ2h0XCIsIFwiZm9jdXNhYmxlXCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXNpemUtYWRqdXN0XCIsIFwiZm9udC1zdHJldGNoXCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9ybWF0XCIsIFwiZnJcIiwgXCJmcm9tXCIsIFwiZnhcIiwgXCJmeVwiLFxuICAgICAgICBcImcxXCIsIFwiZzJcIiwgXCJnbHlwaC1uYW1lXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLCBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCIsIFwiZ2x5cGhSZWZcIiwgXCJncmFkaWVudFRyYW5zZm9ybVwiLCBcImdyYWRpZW50VW5pdHNcIixcbiAgICAgICAgXCJoYW5kbGVyXCIsIFwiaGFuZ2luZ1wiLCBcImhhdGNoQ29udGVudFVuaXRzXCIsIFwiaGF0Y2hVbml0c1wiLCBcImhlaWdodFwiLCBcImhvcml6LWFkdi14XCIsIFwiaG9yaXotb3JpZ2luLXhcIiwgXCJob3Jpei1vcmlnaW4teVwiLCBcImhyZWZcIiwgXCJocmVmbGFuZ1wiLFxuICAgICAgICBcImlkXCIsIFwiaWRlb2dyYXBoaWNcIiwgXCJpbWFnZS1yZW5kZXJpbmdcIiwgXCJpblwiLCBcImluMlwiLCBcImluaXRpYWxWaXNpYmlsaXR5XCIsIFwiaW50ZXJjZXB0XCIsXG4gICAgICAgIFwia1wiLCBcImsxXCIsIFwiazJcIiwgXCJrM1wiLCBcIms0XCIsIFwia2VybmVsTWF0cml4XCIsIFwia2VybmVsVW5pdExlbmd0aFwiLCBcImtlcm5pbmdcIiwgXCJrZXlQb2ludHNcIiwgXCJrZXlTcGxpbmVzXCIsIFwia2V5VGltZXNcIixcbiAgICAgICAgXCJsZW5ndGhBZGp1c3RcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLCBcImxpZ2h0aW5nLWNvbG9yXCIsIFwibGltaXRpbmdDb25lQW5nbGVcIiwgXCJsb2NhbFwiLFxuICAgICAgICBcIm1hcmtlci1lbmRcIiwgXCJtYXJrZXItbWlkXCIsIFwibWFya2VyLXN0YXJ0XCIsIFwibWFya2VySGVpZ2h0XCIsIFwibWFya2VyVW5pdHNcIiwgXCJtYXJrZXJXaWR0aFwiLCBcIm1hc2tcIiwgXCJtYXNrQ29udGVudFVuaXRzXCIsIFwibWFza1VuaXRzXCIsIFwibWF0aGVtYXRpY2FsXCIsIFwibWF4XCIsIFwibWVkaWFcIiwgXCJtZWRpYUNoYXJhY3RlckVuY29kaW5nXCIsIFwibWVkaWFDb250ZW50RW5jb2RpbmdzXCIsIFwibWVkaWFTaXplXCIsIFwibWVkaWFUaW1lXCIsIFwibWV0aG9kXCIsIFwibWluXCIsIFwibW9kZVwiLFxuICAgICAgICBcIm5hbWVcIiwgXCJuYXYtZG93blwiLCBcIm5hdi1kb3duLWxlZnRcIiwgXCJuYXYtZG93bi1yaWdodFwiLCBcIm5hdi1sZWZ0XCIsIFwibmF2LW5leHRcIiwgXCJuYXYtcHJldlwiLCBcIm5hdi1yaWdodFwiLCBcIm5hdi11cFwiLCBcIm5hdi11cC1sZWZ0XCIsIFwibmF2LXVwLXJpZ2h0XCIsIFwibnVtT2N0YXZlc1wiLFxuICAgICAgICBcIm9ic2VydmVyXCIsIFwib2Zmc2V0XCIsIFwib3BhY2l0eVwiLCBcIm9wZXJhdG9yXCIsIFwib3JkZXJcIiwgXCJvcmllbnRcIiwgXCJvcmllbnRhdGlvblwiLCBcIm9yaWdpblwiLCBcIm92ZXJmbG93XCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lLXBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtdGhpY2tuZXNzXCIsXG4gICAgICAgIFwicGFub3NlLTFcIiwgXCJwYXRoXCIsIFwicGF0aExlbmd0aFwiLCBcInBhdHRlcm5Db250ZW50VW5pdHNcIiwgXCJwYXR0ZXJuVHJhbnNmb3JtXCIsIFwicGF0dGVyblVuaXRzXCIsIFwicGhhc2VcIiwgXCJwaXRjaFwiLCBcInBsYXliYWNrT3JkZXJcIiwgXCJwbGF5YmFja29yZGVyXCIsIFwicG9pbnRlci1ldmVudHNcIiwgXCJwb2ludHNcIiwgXCJwb2ludHNBdFhcIiwgXCJwb2ludHNBdFlcIiwgXCJwb2ludHNBdFpcIiwgXCJwcmVzZXJ2ZUFscGhhXCIsIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcInByaW1pdGl2ZVVuaXRzXCIsIFwicHJvcGFnYXRlXCIsXG4gICAgICAgIFwiclwiLCBcInJhZGl1c1wiLCBcInJlZlhcIiwgXCJyZWZZXCIsIFwicmVuZGVyaW5nLWludGVudFwiLCBcInJlcGVhdENvdW50XCIsIFwicmVwZWF0RHVyXCIsIFwicmVxdWlyZWRFeHRlbnNpb25zXCIsIFwicmVxdWlyZWRGZWF0dXJlc1wiLCBcInJlcXVpcmVkRm9udHNcIiwgXCJyZXF1aXJlZEZvcm1hdHNcIiwgXCJyZXN0YXJ0XCIsIFwicmVzdWx0XCIsIFwicm90YXRlXCIsIFwicnhcIiwgXCJyeVwiLFxuICAgICAgICBcInNjYWxlXCIsIFwic2VlZFwiLCBcInNoYXBlLXJlbmRlcmluZ1wiLCBcInNpZGVcIiwgXCJzbG9wZVwiLCBcInNuYXBzaG90VGltZVwiLCBcInNwYWNpbmdcIiwgXCJzcGVjdWxhckNvbnN0YW50XCIsIFwic3BlY3VsYXJFeHBvbmVudFwiLCBcInNwcmVhZE1ldGhvZFwiLCBcInNyY1wiLCBcInN0YXJ0T2Zmc2V0XCIsIFwic3RkRGV2aWF0aW9uXCIsIFwic3RlbWhcIiwgXCJzdGVtdlwiLCBcInN0aXRjaFRpbGVzXCIsIFwic3RvcC1jb2xvclwiLCBcInN0b3Atb3BhY2l0eVwiLCBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiLCBcInN0cmluZ1wiLCBcInN0cm9rZVwiLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBcInN0cm9rZS1saW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVqb2luXCIsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiLCBcInN0eWxlXCIsIFwic3VyZmFjZVNjYWxlXCIsIFwic3luY0JlaGF2aW9yXCIsIFwic3luY0JlaGF2aW9yRGVmYXVsdFwiLCBcInN5bmNNYXN0ZXJcIiwgXCJzeW5jVG9sZXJhbmNlXCIsIFwic3luY1RvbGVyYW5jZURlZmF1bHRcIiwgXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgICAgICBcInRhYmxlVmFsdWVzXCIsIFwidGFyZ2V0XCIsIFwidGFyZ2V0WFwiLCBcInRhcmdldFlcIiwgXCJ0ZXh0LWFuY2hvclwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtcmVuZGVyaW5nXCIsIFwidGV4dExlbmd0aFwiLCBcInRpbWVsaW5lQmVnaW5cIiwgXCJ0aW1lbGluZWJlZ2luXCIsIFwidGl0bGVcIiwgXCJ0b1wiLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybUJlaGF2aW9yXCIsIFwidHlwZVwiLFxuICAgICAgICBcInUxXCIsIFwidTJcIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCIsIFwidW5pY29kZVwiLCBcInVuaWNvZGUtYmlkaVwiLCBcInVuaWNvZGUtcmFuZ2VcIiwgXCJ1bml0cy1wZXItZW1cIixcbiAgICAgICAgXCJ2LWFscGhhYmV0aWNcIiwgXCJ2LWhhbmdpbmdcIiwgXCJ2LWlkZW9ncmFwaGljXCIsIFwidi1tYXRoZW1hdGljYWxcIiwgXCJ2YWx1ZXNcIiwgXCJ2ZXJzaW9uXCIsIFwidmVydC1hZHYteVwiLCBcInZlcnQtb3JpZ2luLXhcIiwgXCJ2ZXJ0LW9yaWdpbi15XCIsIFwidmlld0JveFwiLCBcInZpZXdUYXJnZXRcIiwgXCJ2aXNpYmlsaXR5XCIsXG4gICAgICAgIFwid2lkdGhcIiwgXCJ3aWR0aHNcIiwgXCJ3b3JkLXNwYWNpbmdcIiwgXCJ3cml0aW5nLW1vZGVcIixcbiAgICAgICAgXCJ4XCIsIFwieC1oZWlnaHRcIiwgXCJ4MVwiLCBcIngyXCIsIFwieENoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICBcInlcIiwgXCJ5MVwiLCBcInkyXCIsIFwieUNoYW5uZWxTZWxlY3RvclwiLFxuICAgICAgICBcInpcIiwgXCJ6b29tQW5kUGFuXCJcbiAgICAgIF0sXG4gICAgICBodG1sQXR0cmlidXRlTmFtZXMgPSBbXG4gICAgICAgIFwiYWNjZXB0XCIsIFwiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2Vzc0tleVwiLCBcImFjdGlvblwiLCBcImFsbG93XCIsIFwiYWxsb3dGdWxsU2NyZWVuXCIsIFwiYWxsb3dUcmFuc3BhcmVuY3lcIiwgXCJhbHRcIiwgXCJhc3luY1wiLCBcImF1dG9Db21wbGV0ZVwiLCBcImF1dG9Gb2N1c1wiLCBcImF1dG9QbGF5XCIsXG4gICAgICAgIFwiY2FwdHVyZVwiLCBcImNlbGxQYWRkaW5nXCIsIFwiY2VsbFNwYWNpbmdcIiwgXCJjaGFsbGVuZ2VcIiwgXCJjaGFyU2V0XCIsIFwiY2hlY2tlZFwiLCBcImNpdGVcIiwgXCJjbGFzc0lEXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sU3BhblwiLCBcImNvbHNcIiwgXCJjb250ZW50XCIsIFwiY29udGVudEVkaXRhYmxlXCIsIFwiY29udGV4dE1lbnVcIiwgXCJjb250cm9sc1wiLCBcImNvb3Jkc1wiLCBcImNyb3NzT3JpZ2luXCIsXG4gICAgICAgIFwiZGF0YVwiLCBcImRhdGVUaW1lXCIsIFwiZGVmYXVsdFwiLCBcImRlZmVyXCIsIFwiZGlyXCIsIFwiZGlzYWJsZWRcIiwgXCJkb3dubG9hZFwiLCBcImRyYWdnYWJsZVwiLFxuICAgICAgICBcImVuY1R5cGVcIixcbiAgICAgICAgXCJmb3JtXCIsIFwiZm9ybUFjdGlvblwiLCBcImZvcm1FbmNUeXBlXCIsIFwiZm9ybU1ldGhvZFwiLCBcImZvcm1Ob1ZhbGlkYXRlXCIsIFwiZm9ybVRhcmdldFwiLCBcImZyYW1lQm9yZGVyXCIsXG4gICAgICAgIFwiaGVhZGVyc1wiLCBcImhlaWdodFwiLCBcImhpZGRlblwiLCBcImhpZ2hcIiwgXCJocmVmXCIsIFwiaHJlZkxhbmdcIiwgXCJodG1sRm9yXCIsIFwiaHR0cEVxdWl2XCIsXG4gICAgICAgIFwiaWNvblwiLCBcImlkXCIsIFwiaW5wdXRNb2RlXCIsIFwiaW50ZWdyaXR5XCIsIFwiaXNcIixcbiAgICAgICAgXCJrZXlQYXJhbXNcIiwgXCJrZXlUeXBlXCIsIFwia2luZFwiLFxuICAgICAgICBcImxhYmVsXCIsIFwibGFuZ1wiLCBcImxpc3RcIiwgXCJsb29wXCIsIFwibG93XCIsXG4gICAgICAgIFwibWFuaWZlc3RcIiwgXCJtYXJnaW5IZWlnaHRcIiwgXCJtYXJnaW5XaWR0aFwiLCBcIm1heFwiLCBcIm1heExlbmd0aFwiLCBcIm1lZGlhXCIsIFwibWVkaWFHcm91cFwiLCBcIm1ldGhvZFwiLCBcIm1pblwiLCBcIm1pbkxlbmd0aFwiLCBcIm11bHRpcGxlXCIsIFwibXV0ZWRcIixcbiAgICAgICAgXCJuYW1lXCIsIFwibm9WYWxpZGF0ZVwiLCBcIm5vbmNlXCIsXG4gICAgICAgIFwib3BlblwiLCBcIm9wdGltdW1cIixcbiAgICAgICAgXCJwYXR0ZXJuXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJwb3N0ZXJcIiwgXCJwcmVsb2FkXCIsIFwicHJvZmlsZVwiLFxuICAgICAgICBcInJhZGlvR3JvdXBcIiwgXCJyZWFkT25seVwiLCBcInJlbFwiLCBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJyb2xlXCIsIFwicm93U3BhblwiLCBcInJvd3NcIixcbiAgICAgICAgXCJzYW5kYm94XCIsIFwic2NvcGVcIiwgXCJzY29wZWRcIiwgXCJzY3JvbGxpbmdcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCIsIFwic2hhcGVcIiwgXCJzaXplXCIsIFwic2l6ZXNcIiwgXCJzcGFuXCIsIFwic3BlbGxDaGVja1wiLCBcInNyY1wiLCBcInNyY0RvY1wiLCBcInNyY0xhbmdcIiwgXCJzcmNTZXRcIiwgXCJzdGFydFwiLCBcInN0ZXBcIiwgXCJzdHlsZVwiLCBcInN1bW1hcnlcIixcbiAgICAgICAgXCJ0YWJJbmRleFwiLCBcInRhcmdldFwiLCBcInRpdGxlXCIsIFwidHlwZVwiLFxuICAgICAgICBcInVzZU1hcFwiLFxuICAgICAgICBcInZhbHVlXCIsXG4gICAgICAgIFwid2lkdGhcIixcbiAgICAgICAgXCJ3bW9kZVwiLFxuICAgICAgICBcIndyYXBcIlxuICAgICAgXTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdEVsZW1lbnQoZWxlbWVudCwgZG9tRWxlbWVudCkge1xuICBlbGVtZW50LmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXG4gIGRvbUVsZW1lbnQuX19lbGVtZW50X18gPSBlbGVtZW50OyAvLy9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgZGVzY2VuZGFudEVsZW1lbnRzID0gZWxlbWVudC5nZXREZXNjZW5kYW50RWxlbWVudHMoKSxcbiAgICAgICAgZWxlbWVudHMgPSBbXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAuLi5kZXNjZW5kYW50RWxlbWVudHNcbiAgICAgICAgXTtcblxuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZ2V0RE9NRWxlbWVudCgpO1xuXG4gICAgZGVsZXRlIGVsZW1lbnQuZG9tRWxlbWVudDtcblxuICAgIGRlbGV0ZSBkb21FbGVtZW50Ll9fZWxlbWVudF9fO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IGRlc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnQuZ2V0RGVzY2VuZGFudEVsZW1lbnRzKCksXG4gICAgICAgIGVsZW1lbnRzID0gW1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgLi4uZGVzY2VuZGFudEVsZW1lbnRzXG4gICAgICAgIF07XG5cbiAgZWxlbWVudHMucmV2ZXJzZSgpOyAvLy9cblxuICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgZWxlbWVudC5kaWRNb3VudCAmJiBlbGVtZW50LmRpZE1vdW50KCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudEVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50LmdldERlc2NlbmRhbnRFbGVtZW50cygpLFxuICAgICAgICBlbGVtZW50cyA9IFtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIC4uLmRlc2NlbmRhbnRFbGVtZW50c1xuICAgICAgICBdO1xuXG4gIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICBlbGVtZW50LndpbGxVbm1vdW50ICYmIGVsZW1lbnQud2lsbFVubW91bnQoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29uc3RydWN0RWxlbWVudCxcbiAgZGVzdHJveUVsZW1lbnQsXG4gIG1vdW50RWxlbWVudCxcbiAgdW5tb3VudEVsZW1lbnRcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHB1c2ggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBXSUxEQ0FSRCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGRvbUVsZW1lbnRzKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnRzV2l0aEVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXMoZG9tRWxlbWVudHMsIChkb21FbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKChkb21FbGVtZW50Ll9fZWxlbWVudF9fKSkgeyAvLy9cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGVsZW1lbnRzID0gZG9tRWxlbWVudHNXaXRoRWxlbWVudHMubWFwKChkb21FbGVtZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvbUVsZW1lbnQuX19lbGVtZW50X187IC8vL1xuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUoZG9tTm9kZSwgaGVpZ2h0LCBhc2NlbmRhbnRET01Ob2RlcyA9IFtdKSB7XG4gIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IGRvbU5vZGUucGFyZW50RWxlbWVudDsgIC8vL1xuXG4gICAgaWYgKHBhcmVudERPTU5vZGUgIT09IG51bGwpIHtcbiAgICAgIGFzY2VuZGFudERPTU5vZGVzLnB1c2gocGFyZW50RE9NTm9kZSk7XG5cbiAgICAgIGhlaWdodC0tO1xuXG4gICAgICBhc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKHBhcmVudERPTU5vZGUsIGhlaWdodCwgYXNjZW5kYW50RE9NTm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhc2NlbmRhbnRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoLCBkZXNjZW5kYW50RE9NTm9kZXMgPSBbXSkge1xuICBpZiAoZGVwdGggPiAwKSB7XG4gICAgY29uc3QgY2hpbGRET01Ob2RlcyA9IGRvbU5vZGUuY2hpbGROb2RlczsgIC8vL1xuXG4gICAgcHVzaChkZXNjZW5kYW50RE9NTm9kZXMsIGNoaWxkRE9NTm9kZXMpO1xuXG4gICAgZGVwdGgtLTtcblxuICAgIGNoaWxkRE9NTm9kZXMuZm9yRWFjaCgoY2hpbGRET01Ob2RlKSA9PiB7XG4gICAgICBkZXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShjaGlsZERPTU5vZGUsIGRlcHRoLCBkZXNjZW5kYW50RE9NTm9kZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzQnlTZWxlY3Rvcihkb21Ob2Rlcywgc2VsZWN0b3IpIHtcbiAgY29uc3QgZmlsdGVyZWRET01Ob2RlcyA9IGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCAoZG9tTm9kZSkgPT4ge1xuICAgIGlmIChkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKGRvbU5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZmlsdGVyZWRET01Ob2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvbU5vZGVNYXRjaGVzU2VsZWN0b3IoZG9tTm9kZSwgc2VsZWN0b3IpIHtcbiAgY29uc3QgZG9tTm9kZVR5cGUgPSBkb21Ob2RlLm5vZGVUeXBlOyAvLy9cblxuICBzd2l0Y2ggKGRvbU5vZGVUeXBlKSB7XG4gICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvbU5vZGU7IC8vL1xuXG4gICAgICByZXR1cm4gZG9tRWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckRPTU5vZGVzKGRvbU5vZGVzLCB0ZXN0KSB7XG4gIGNvbnN0IGZpbHRlcmVkRE9NTm9kZXMgPSBbXSxcbiAgICAgICAgZG9tTm9kZXNMZW5ndGggPSBkb21Ob2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRvbU5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZG9tTm9kZSA9IGRvbU5vZGVzW2luZGV4XSxcbiAgICAgICAgICByZXN1bHQgPSB0ZXN0KGRvbU5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgZmlsdGVyZWRET01Ob2Rlcy5wdXNoKGRvbU5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZERPTU5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFdJTERDQVJEIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG9tTm9kZU1hdGNoZXNTZWxlY3RvciwgZWxlbWVudHNGcm9tRE9NRWxlbWVudHMsIGZpbHRlckRPTU5vZGVzQnlTZWxlY3RvciwgYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZSwgZGVzY2VuZGFudERPTU5vZGVzRnJvbURPTU5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2RvbVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwYXJlbnRFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwYXJlbnRET01FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7IC8vL1xuXG4gIGlmIChwYXJlbnRET01FbGVtZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKHBhcmVudERPTUVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgIGNvbnN0IHBhcmVudERPTUVsZW1lbnRzID0gW1xuICAgICAgICAgICAgICBwYXJlbnRET01FbGVtZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcGFyZW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhwYXJlbnRET01FbGVtZW50cyksXG4gICAgICAgICAgICBmaXJzdFBhcmVudEVsZW1lbnQgPSBmaXJzdChwYXJlbnRFbGVtZW50cyk7XG5cbiAgICAgIHBhcmVudEVsZW1lbnQgPSBmaXJzdFBhcmVudEVsZW1lbnQgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50RWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkRWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBjb25zdCBjaGlsZERPTU5vZGVzID0gdGhpcy5kb21FbGVtZW50LmNoaWxkTm9kZXMsIC8vL1xuICAgICAgICBjaGlsZERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGNoaWxkRE9NTm9kZXMsIHNlbGVjdG9yKSxcbiAgICAgICAgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGNoaWxkRE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBjaGlsZEVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bUhlaWdodCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IGhlaWdodCA9IG1heGltdW1IZWlnaHQsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGFzY2VuZGFudERPTU5vZGVzID0gYXNjZW5kYW50RE9NTm9kZXNGcm9tRE9NTm9kZShkb21Ob2RlLCBoZWlnaHQpLFxuICAgICAgICBhc2NlbmRhbnRET01FbGVtZW50cyA9IGZpbHRlckRPTU5vZGVzQnlTZWxlY3Rvcihhc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBhc2NlbmRhbnRFbGVtZW50cyA9IGVsZW1lbnRzRnJvbURPTUVsZW1lbnRzKGFzY2VuZGFudERPTUVsZW1lbnRzKTtcblxuICByZXR1cm4gYXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXNjZW5kYW50RWxlbWVudHMoc2VsZWN0b3IgPSBXSUxEQ0FSRCwgbWF4aW11bURlcHRoID0gSW5maW5pdHkpIHtcbiAgY29uc3QgZGVwdGggPSBtYXhpbXVtRGVwdGgsIC8vL1xuICAgICAgICBkb21Ob2RlID0gdGhpcy5kb21FbGVtZW50LCAgLy8vXG4gICAgICAgIGRlc2NlbmRhbnRET01Ob2RlcyA9IGRlc2NlbmRhbnRET01Ob2Rlc0Zyb21ET01Ob2RlKGRvbU5vZGUsIGRlcHRoKSxcbiAgICAgICAgZGVzY2VuZGFudERPTUVsZW1lbnRzID0gZmlsdGVyRE9NTm9kZXNCeVNlbGVjdG9yKGRlc2NlbmRhbnRET01Ob2Rlcywgc2VsZWN0b3IpLFxuICAgICAgICBkZXNjZW5kYW50RWxlbWVudHMgPSBlbGVtZW50c0Zyb21ET01FbGVtZW50cyhkZXNjZW5kYW50RE9NRWxlbWVudHMpO1xuXG4gIHJldHVybiBkZXNjZW5kYW50RWxlbWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0U2libGluZ0VsZW1lbnQoc2VsZWN0b3IgPSBXSUxEQ0FSRCkge1xuICBsZXQgbmV4dFNpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBuZXh0U2libGluZ0RPTU5vZGUgPSB0aGlzLmRvbUVsZW1lbnQubmV4dFNpYmxpbmc7IC8vL1xuXG4gIGlmICgobmV4dFNpYmxpbmdET01Ob2RlICE9PSBudWxsKSAmJiBkb21Ob2RlTWF0Y2hlc1NlbGVjdG9yKG5leHRTaWJsaW5nRE9NTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgbmV4dFNpYmxpbmdFbGVtZW50ID0gbmV4dFNpYmxpbmdET01Ob2RlLl9fZWxlbWVudF9fIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gbmV4dFNpYmxpbmdFbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudChzZWxlY3RvciA9IFdJTERDQVJEKSB7XG4gIGxldCBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gbnVsbDtcblxuICBjb25zdCBwcmV2aW91c1NpYmxpbmdET01Ob2RlID0gdGhpcy5kb21FbGVtZW50LnByZXZpb3VzU2libGluZzsgIC8vL1xuXG4gIGlmICgocHJldmlvdXNTaWJsaW5nRE9NTm9kZSAhPT0gbnVsbCkgJiYgZG9tTm9kZU1hdGNoZXNTZWxlY3RvcihwcmV2aW91c1NpYmxpbmdET01Ob2RlLCBzZWxlY3RvcikpIHtcbiAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gcHJldmlvdXNTaWJsaW5nRE9NTm9kZS5fX2VsZW1lbnRfXyB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzU2libGluZ0VsZW1lbnQ7XG59XG5cbmNvbnN0IGVsZW1lbnRNaXhpbnMgPSB7XG4gIGdldFBhcmVudEVsZW1lbnQsXG4gIGdldENoaWxkRWxlbWVudHMsXG4gIGdldEFzY2VuZGFudEVsZW1lbnRzLFxuICBnZXREZXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudE1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE9mZnNldCBmcm9tIFwiLi9vZmZzZXRcIjtcbmltcG9ydCBCb3VuZHMgZnJvbSBcIi4vYm91bmRzXCI7XG5cbmltcG9ydCB7IGNvbnN0cnVjdEVsZW1lbnQsIGRlc3Ryb3lFbGVtZW50IH0gZnJvbSBcIi4vdXRpbGl0aWVzL2VsZW1lbnRcIjtcbmltcG9ydCB7IGdldFBhcmVudEVsZW1lbnQsIGdldEFzY2VuZGFudEVsZW1lbnRzLCBnZXROZXh0U2libGluZ0VsZW1lbnQsIGdldFByZXZpb3VzU2libGluZ0VsZW1lbnQgfSBmcm9tIFwiLi9taXhpbnMvZWxlbWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcywgLy8vXG4gICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpOyAvLy9cblxuICAgIGNvbnN0cnVjdEVsZW1lbnQoZWxlbWVudCwgZG9tRWxlbWVudCk7XG4gIH1cblxuICBnZXRET01FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gT2Zmc2V0LmZyb21ET01FbGVtZW50KHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IEJvdW5kcy5mcm9tRE9NRWxlbWVudCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50Lm9mZnNldFdpZHRoOyB9ICAvLy9cblxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyB9ICAvLy9cblxuICBnZXRUZXh0KCkge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuZG9tRWxlbWVudC5ub2RlVmFsdWUsXG4gICAgICAgICAgdGV4dCA9IG5vZGVWYWx1ZTsgLy8vXG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHNldFRleHQodGV4dCkge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRleHQ7IC8vL1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lm5vZGVWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIGFwcGVuZFRvKHBhcmVudEVsZW1lbnQpIHsgcGFyZW50RWxlbWVudC5hcHBlbmQodGhpcyk7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgcmVtb3ZlRnJvbShwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucmVtb3ZlKHRoaXMpOyB9XG5cbiAgaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSwgLy8vXG4gICAgICAgICAgc2libGluZ0RPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50RE9NTm9kZSA9IHNpYmxpbmdFbGVtZW50LmRvbUVsZW1lbnQucGFyZW50Tm9kZSwgLy8vXG4gICAgICAgICAgc2libGluZ0RPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHNpYmxpbmdET01FbGVtZW50Lm5leHRTaWJsaW5nKTsgIC8vL1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgZGVzdHJveUVsZW1lbnQoZWxlbWVudCk7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0RWxlbWVudC5wcm90b3R5cGUsIHtcbiAgZ2V0UGFyZW50RWxlbWVudCxcbiAgZ2V0QXNjZW5kYW50RWxlbWVudHMsXG4gIGdldE5leHRTaWJsaW5nRWxlbWVudCxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0RWxlbWVudCBmcm9tIFwiLi4vdGV4dEVsZW1lbnRcIjtcblxuaW1wb3J0IHsgU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmFsc2V5RWxlbWVudHMoZWxlbWVudHMpIHtcbiAgZWxlbWVudHMgPSBlbGVtZW50cy5yZWR1Y2UoKGVsZW1lbnRzLCBlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gIGVsZW1lbnRzID0gZWxlbWVudHMubWFwKChlbGVtZW50KSA9PiB7ICAvLy9cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFNUUklORykge1xuICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQsICAvLy9cbiAgICAgICAgICAgIHRleHRFbGVtZW50ID0gbmV3IFRleHRFbGVtZW50KHRleHQpO1xuXG4gICAgICBlbGVtZW50ID0gdGV4dEVsZW1lbnQ7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcblxuICByZXR1cm4gZWxlbWVudHM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDVVRfRVZFTlRfVFlQRSA9IFwiY3V0XCI7XG5leHBvcnQgY29uc3QgQ09QWV9FVkVOVF9UWVBFID0gXCJjb3B5XCI7XG5leHBvcnQgY29uc3QgQkxVUl9FVkVOVF9UWVBFID0gXCJibHVyXCI7XG5leHBvcnQgY29uc3QgRVJST1JfRVZFTlRfVFlQRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBQQVNURV9FVkVOVF9UWVBFID0gXCJwYXN0ZVwiO1xuZXhwb3J0IGNvbnN0IFdIRUVMX0VWRU5UX1RZUEUgPSBcIndoZWVsXCI7XG5leHBvcnQgY29uc3QgSU5QVVRfRVZFTlRfVFlQRSA9IFwiaW5wdXRcIjtcbmV4cG9ydCBjb25zdCBGT0NVU19FVkVOVF9UWVBFID0gXCJmb2N1c1wiO1xuZXhwb3J0IGNvbnN0IENMSUNLX0VWRU5UX1RZUEUgPSBcImNsaWNrXCI7XG5leHBvcnQgY29uc3QgS0VZVVBfRVZFTlRfVFlQRSA9IFwia2V5dXBcIjtcbmV4cG9ydCBjb25zdCBTRUxFQ1RfRVZFTlRfVFlQRSA9IFwic2VsZWN0XCI7XG5leHBvcnQgY29uc3QgQ0hBTkdFX0VWRU5UX1RZUEUgPSBcImNoYW5nZVwiO1xuZXhwb3J0IGNvbnN0IFJFU0laRV9FVkVOVF9UWVBFID0gXCJyZXNpemVcIjtcbmV4cG9ydCBjb25zdCBTQ1JPTExfRVZFTlRfVFlQRSA9IFwic2Nyb2xsXCI7XG5leHBvcnQgY29uc3QgS0VZRE9XTl9FVkVOVF9UWVBFID0gXCJrZXlkb3duXCI7XG5leHBvcnQgY29uc3QgTU9VU0VVUF9FVkVOVF9UWVBFID0gXCJtb3VzZXVwXCI7XG5leHBvcnQgY29uc3QgQVVYQ0xJQ0tfRVZFTlRfVFlQRSA9IFwiYXV4Y2xpY2tcIjtcbmV4cG9ydCBjb25zdCBNT1VTRU9VVF9FVkVOVF9UWVBFID0gXCJtb3VzZW91dFwiO1xuZXhwb3J0IGNvbnN0IERCTENMSUNLX0VWRU5UX1RZUEUgPSBcImRibGNsaWNrXCI7XG5leHBvcnQgY29uc3QgVE9VQ0hFTkRfRVZFTlRfVFlQRSA9IFwidG91Y2hlbmRcIjtcbmV4cG9ydCBjb25zdCBUT1VDSE1PVkVfRVZFTlRfVFlQRSA9IFwidG91Y2htb3ZlXCI7XG5leHBvcnQgY29uc3QgTU9VU0VPVkVSX0VWRU5UX1RZUEUgPSBcIm1vdXNlb3ZlclwiO1xuZXhwb3J0IGNvbnN0IE1PVVNFRE9XTl9FVkVOVF9UWVBFID0gXCJtb3VzZWRvd25cIjtcbmV4cG9ydCBjb25zdCBNT1VTRU1PVkVfRVZFTlRfVFlQRSA9IFwibW91c2Vtb3ZlXCI7XG5leHBvcnQgY29uc3QgVE9VQ0hTVEFSVF9FVkVOVF9UWVBFID0gXCJ0b3VjaHN0YXJ0XCI7XG5leHBvcnQgY29uc3QgQ09OVEVYVE1FTlVfRVZFTlRfVFlQRSA9IFwiY29udGV4dG1lbnVcIjtcbmV4cG9ydCBjb25zdCBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRSA9IFwic2VsZWN0aW9uY2hhbmdlXCI7XG5leHBvcnQgY29uc3QgRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFID0gXCJmdWxsc2NyZWVuY2hhbmdlXCI7XG5leHBvcnQgY29uc3QgVU5IQU5ETEVEUkVKRUNUSU9OX0VWRU5UX1RZUEUgPSBcInVuaGFuZGxlZHJlamVjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIENVVF9FVkVOVF9UWVBFLFxuICBDT1BZX0VWRU5UX1RZUEUsXG4gIEJMVVJfRVZFTlRfVFlQRSxcbiAgRVJST1JfRVZFTlRfVFlQRSxcbiAgUEFTVEVfRVZFTlRfVFlQRSxcbiAgV0hFRUxfRVZFTlRfVFlQRSxcbiAgSU5QVVRfRVZFTlRfVFlQRSxcbiAgRk9DVVNfRVZFTlRfVFlQRSxcbiAgQ0xJQ0tfRVZFTlRfVFlQRSxcbiAgS0VZVVBfRVZFTlRfVFlQRSxcbiAgU0VMRUNUX0VWRU5UX1RZUEUsXG4gIENIQU5HRV9FVkVOVF9UWVBFLFxuICBSRVNJWkVfRVZFTlRfVFlQRSxcbiAgU0NST0xMX0VWRU5UX1RZUEUsXG4gIEtFWURPV05fRVZFTlRfVFlQRSxcbiAgTU9VU0VVUF9FVkVOVF9UWVBFLFxuICBBVVhDTElDS19FVkVOVF9UWVBFLFxuICBNT1VTRU9VVF9FVkVOVF9UWVBFLFxuICBEQkxDTElDS19FVkVOVF9UWVBFLFxuICBUT1VDSEVORF9FVkVOVF9UWVBFLFxuICBUT1VDSE1PVkVfRVZFTlRfVFlQRSxcbiAgTU9VU0VPVkVSX0VWRU5UX1RZUEUsXG4gIE1PVVNFRE9XTl9FVkVOVF9UWVBFLFxuICBNT1VTRU1PVkVfRVZFTlRfVFlQRSxcbiAgVE9VQ0hTVEFSVF9FVkVOVF9UWVBFLFxuICBDT05URVhUTUVOVV9FVkVOVF9UWVBFLFxuICBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRSxcbiAgRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFLFxuICBVTkhBTkRMRURSRUpFQ1RJT05fRVZFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VhcmFudGVlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgY29tYmluZSwgcHJ1bmUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL29iamVjdFwiO1xuaW1wb3J0IHsgY2FtZWxDYXNlVG9TbmFrZUNhc2UgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgaXNIVE1MQXR0cmlidXRlTmFtZSwgaXNTVkdBdHRyaWJ1dGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9uYW1lXCI7XG5pbXBvcnQgeyByZW1vdmVGYWxzZXlFbGVtZW50cywgcmVwbGFjZVN0cmluZ3NXaXRoVGV4dEVsZW1lbnRzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9lbGVtZW50c1wiO1xuaW1wb3J0IHsgREJMQ0xJQ0tfRVZFTlRfVFlQRSwgU0VMRUNUSU9OQ0hBTkdFX0VWRU5UX1RZUEUsIEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5pbXBvcnQgeyBGT1IsIENMQVNTLCBPQkpFQ1QsIEhUTUxfRk9SLCBDTEFTU19OQU1FLCBCT09MRUFOLCBGVU5DVElPTiwgU1ZHX05BTUVTUEFDRV9VUkkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IERPVUJMRV9DTElDS19FVkVOVF9UWVBFID0gXCJkb3VibGVjbGlja1wiLFxuICAgICAgU0VMRUNUSU9OX0NIQU5HRV9FVkVOVF9UWVBFID0gXCJzZWxlY3Rpb25DaGFuZ2VcIixcbiAgICAgIEZVTExfU0NSRUVOX0NIQU5HRV9FVkVOVF9UWVBFID0gXCJmdWxsU2NyZWVuQ2hhbmdlXCI7XG5cbmZ1bmN0aW9uIGFwcGx5UHJvcGVydGllcyhwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gY29tYmluZShwcm9wZXJ0aWVzLCBkZWZhdWx0UHJvcGVydGllcyk7XG5cbiAgcHJvcGVydGllcyA9IHBydW5lKHRoaXMucHJvcGVydGllcywgaWdub3JlZFByb3BlcnRpZXMpOyAvLy9cblxuICBjb25zdCBuYW1lc3BhY2VVUkkgPSB0aGlzLmRvbUVsZW1lbnQubmFtZXNwYWNlVVJJLFxuICAgICAgICBzdmcgPSAobmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFX1VSSSksIC8vL1xuICAgICAgICBwcm9wZXJ0aWVzS2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLFxuICAgICAgICBuYW1lcyA9IHByb3BlcnRpZXNLZXlzOyAgLy8vPVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbbmFtZV0sXG4gICAgICAgICAgbmFtZUhhbmRsZXJOYW1lID0gaXNOYW1lSGFuZGxlck5hbWUobmFtZSksXG4gICAgICAgICAgbmFtZUN1c3RvbUhhbmRsZXJOYW1lID0gaXNOYW1lQ3VzdG9tSGFuZGxlck5hbWUobmFtZSk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobmFtZUhhbmRsZXJOYW1lKSB7XG4gICAgICBhZGRIYW5kbGVyKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWVDdXN0b21IYW5kbGVyTmFtZSkge1xuICAgICAgYWRkQ3VzdG9tSGFuZGxlcih0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVBdHRyaWJ1dGVOYW1lID0gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpO1xuXG4gICAgICBpZiAobmFtZUF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgYWRkQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGNoaWxkRWxlbWVudHMgPSBjaGlsZEVsZW1lbnRzRnJvbUVsZW1lbnQodGhpcykgfHwgcHJvcGVydGllcy5jaGlsZEVsZW1lbnRzLCAgLy8vXG4gICAgICAgIGNvbnRleHQgPSB7fTtcblxuICBjaGlsZEVsZW1lbnRzLmZvckVhY2goKGNoaWxkRWxlbWVudCkgPT4ge1xuICAgIHVwZGF0ZUNvbnRleHQoY2hpbGRFbGVtZW50LCBjb250ZXh0KTtcblxuICAgIHRoaXMuYWRkKGNoaWxkRWxlbWVudCk7XG4gIH0pO1xuXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnRpZXMoKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNvbnRleHQobmFtZXMpIHtcbiAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29udGV4dClcbiAgfVxuXG4gIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29udGV4dFtuYW1lXSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBuYW1lLCAgLy8vXG4gICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRbbmFtZV07XG4gIH0pO1xufVxuXG5jb25zdCBqc3hNaXhpbnMgPSB7XG4gIGFwcGx5UHJvcGVydGllcyxcbiAgZ2V0UHJvcGVydGllcyxcbiAgZ2V0Q29udGV4dCxcbiAgYXNzaWduQ29udGV4dFxufTtcblxuZXhwb3J0IGRlZmF1bHQganN4TWl4aW5zO1xuXG5mdW5jdGlvbiBjaGlsZEVsZW1lbnRzRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICBsZXQgY2hpbGRFbGVtZW50cyA9IG51bGw7XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50LmNoaWxkRWxlbWVudHMgPT09IEZVTkNUSU9OKSB7XG4gICAgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnQuY2hpbGRFbGVtZW50cy5jYWxsKGVsZW1lbnQpO1xuXG4gICAgY2hpbGRFbGVtZW50cyA9IGd1YXJhbnRlZShjaGlsZEVsZW1lbnRzKTtcblxuICAgIGNoaWxkRWxlbWVudHMgPSByZW1vdmVGYWxzZXlFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTtcblxuICAgIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRFbGVtZW50cztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChjaGlsZEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9ICh0eXBlb2YgY2hpbGRFbGVtZW50LnBhcmVudENvbnRleHQgPT09IEZVTkNUSU9OKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudC5wYXJlbnRDb250ZXh0KCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlbWVudC5jb250ZXh0OyAvLy9cblxuICBPYmplY3QuYXNzaWduKGNvbnRleHQsIHBhcmVudENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGxldCBldmVudFR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpOyAvLy9cblxuICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgIGNhc2UgRE9VQkxFX0NMSUNLX0VWRU5UX1RZUEU6IHtcbiAgICAgIGV2ZW50VHlwZSA9IERCTENMSUNLX0VWRU5UX1RZUEU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgU0VMRUNUSU9OX0NIQU5HRV9FVkVOVF9UWVBFOiB7XG4gICAgICBldmVudFR5cGUgPSBTRUxFQ1RJT05DSEFOR0VfRVZFTlRfVFlQRTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBGVUxMX1NDUkVFTl9DSEFOR0VfRVZFTlRfVFlQRToge1xuICAgICAgZXZlbnRUeXBlID0gRlVMTFNDUkVFTkNIQU5HRV9FVkVOVF9UWVBFO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZXIgPSB2YWx1ZTsgIC8vL1xuXG4gIGVsZW1lbnQub25FdmVudChldmVudFR5cGUsIGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRDdXN0b21IYW5kbGVyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IGNhbWVsQ2FzZVRvU25ha2VDYXNlKG5hbWUpLnJlcGxhY2UoL29uLWN1c3RvbS0vLCBcIlwiKSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHZhbHVlOyAgLy8vXG5cbiAgZWxlbWVudC5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBpZiAobmFtZSA9PT0gQ0xBU1NfTkFNRSkge1xuICAgIG5hbWUgPSBDTEFTUztcbiAgfVxuXG4gIGlmIChuYW1lID09PSBIVE1MX0ZPUikge1xuICAgIG5hbWUgPSBGT1I7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBPQkpFQ1QpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtuYW1lXVtrZXldID0gdmFsdWVba2V5XTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IEJPT0xFQU4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmFtZTsgLy8vXG5cbiAgICAgIGVsZW1lbnQuYWRkQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5hZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTmFtZUhhbmRsZXJOYW1lKG5hbWUpIHtcbiAgY29uc3QgbmFtZUhhbmRsZXJOYW1lID0gIC9eb24oPyFDdXN0b20pLy50ZXN0KG5hbWUpOyAgLy8vXG5cbiAgcmV0dXJuIG5hbWVIYW5kbGVyTmFtZTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lQXR0cmlidXRlTmFtZShuYW1lLCBzdmcpIHtcbiAgY29uc3QgbmFtZUF0dHJpYnV0ZU5hbWUgPSBzdmcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NWR0F0dHJpYnV0ZU5hbWUobmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSFRNTEF0dHJpYnV0ZU5hbWUobmFtZSk7XG5cbiAgcmV0dXJuIG5hbWVBdHRyaWJ1dGVOYW1lO1xufVxuXG5mdW5jdGlvbiBpc05hbWVDdXN0b21IYW5kbGVyTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVDdXN0b21IYW5kbGVyTmFtZSA9IC9eb25DdXN0b20vLnRlc3QobmFtZSk7XG5cbiAgcmV0dXJuIG5hbWVDdXN0b21IYW5kbGVyTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgS0VZVVBfRVZFTlRfVFlQRSwgS0VZRE9XTl9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25LZXlVcChrZXlVcEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEtFWVVQX0VWRU5UX1RZUEUsIGtleVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmS2V5VXAoa2V5VXBIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoS0VZVVBfRVZFTlRfVFlQRSwga2V5VXBIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEtFWURPV05fRVZFTlRfVFlQRSwga2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZktleURvd24oa2V5RG93bkhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChLRVlET1dOX0VWRU5UX1RZUEUsIGtleURvd25IYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5jb25zdCBrZXlNaXhpbnMgPSB7XG4gIG9uS2V5VXAsXG4gIG9mZktleVVwLFxuICBvbktleURvd24sXG4gIG9mZktleURvd25cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtleU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlO1xufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICh0aGlzLnN0YXRlID09PSB1bmRlZmluZWQpID9cbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgOlxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCBzdGF0ZSk7XG59XG5cbmNvbnN0IHN0YXRlTWl4aW5zID0ge1xuICBnZXRTdGF0ZSxcbiAgc2V0U3RhdGUsXG4gIHVwZGF0ZVN0YXRlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdGF0ZU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgU1BBQ0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBSRVNJWkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uRXZlbnQoZXZlbnRUeXBlcywgaGFuZGxlciwgZWxlbWVudCA9IHRoaXMpIHtcbiAgZXZlbnRUeXBlcyA9IGV2ZW50VHlwZXMuc3BsaXQoU1BBQ0UpOyAvLy9cblxuICBldmVudFR5cGVzLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgIGlmIChldmVudFR5cGUgPT09IFJFU0laRV9FVkVOVF9UWVBFKSB7XG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc2l6ZUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kRXZlbnRMaXN0ZW5lcnMoUkVTSVpFX0VWRU5UX1RZUEUpO1xuXG4gICAgICAgICAgcmVzaXplRXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgocmVzaXplRXZlbnRMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICByZXNpemVFdmVudExpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tRWxlbWVudClcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZFdmVudChldmVudFR5cGVzLCBoYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBldmVudFR5cGVzID0gZXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGV2ZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gUkVTSVpFX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgICBjb25zdCByZXNpemVFdmVudExpc3RlbmVycyA9IHRoaXMuZmluZEV2ZW50TGlzdGVuZXJzKFJFU0laRV9FVkVOVF9UWVBFKSxcbiAgICAgICAgICAgIHJlc2l6ZUV2ZW50TGlzdGVuZXJzTGVuZ3RoID0gcmVzaXplRXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICBpZiAocmVzaXplRXZlbnRMaXN0ZW5lcnNMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICBkZWxldGUgdGhpcy5yZXNpemVPYnNlcnZlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KTtcblxuICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG4gIH1cblxuICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmZpbmRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCksXG4gICAgICAgIGluZGV4ID0gdGhpcy5ldmVudExpc3RlbmVycy5pbmRleE9mKGV2ZW50TGlzdGVuZXIpLFxuICAgICAgICBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gMTtcblxuICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB0aGlzLmV2ZW50TGlzdGVuZXJzO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmZ1bmN0aW9uIGZpbmRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBldmVudExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVycy5maW5kKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgaWYgKChldmVudExpc3RlbmVyLmVsZW1lbnQgPT09IGVsZW1lbnQpICYmIChldmVudExpc3RlbmVyLmhhbmRsZXIgPT09IGhhbmRsZXIpICYmIChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmluZEV2ZW50TGlzdGVuZXJzKGV2ZW50VHlwZSkge1xuICBjb25zdCBldmVudExpc3RlbmVycyA9IFtdO1xuXG4gIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKChldmVudExpc3RlbmVyKSA9PiB7XG4gICAgICBjb25zdCBmb3VuZCA9IChldmVudExpc3RlbmVyLmV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlKTtcblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXJzLnB1c2goZXZlbnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXZlbnRMaXN0ZW5lcnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBlbGVtZW50KSB7XG4gIGxldCBldmVudExpc3RlbmVyO1xuXG4gIGNvbnN0IGhhbmRsZXJFbGVtZW50ID0gZWxlbWVudDsgLy8vXG5cbiAgZXZlbnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oZXZlbnRMaXN0ZW5lciwge1xuICAgIGVsZW1lbnQsXG4gICAgaGFuZGxlcixcbiAgICBldmVudFR5cGVcbiAgfSk7XG5cbiAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG59XG5cbmNvbnN0IGV2ZW50TWl4aW5zID0ge1xuICBvbkV2ZW50LFxuICBvZmZFdmVudCxcbiAgYWRkRXZlbnRMaXN0ZW5lcixcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcixcbiAgZmluZEV2ZW50TGlzdGVuZXIsXG4gIGZpbmRFdmVudExpc3RlbmVycyxcbiAgY3JlYXRlRXZlbnRMaXN0ZW5lclxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXZlbnRNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE1PVVNFVVBfRVZFTlRfVFlQRSwgTU9VU0VPVVRfRVZFTlRfVFlQRSwgTU9VU0VET1dOX0VWRU5UX1RZUEUsIE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBNT1VTRU1PVkVfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoTU9VU0VVUF9FVkVOVF9UWVBFLCBtb3VzZVVwSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VVcChtb3VzZVVwSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFVVBfRVZFTlRfVFlQRSwgbW91c2VVcEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdXQobW91c2VPdXRIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChNT1VTRU9VVF9FVkVOVF9UWVBFLCBtb3VzZU91dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFT1VUX0VWRU5UX1RZUEUsIG1vdXNlT3V0SGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoTU9VU0VET1dOX0VWRU5UX1RZUEUsIG1vdXNlRG93bkhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBtb3VzZU92ZXJIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZNb3VzZU92ZXIobW91c2VPdmVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KE1PVVNFT1ZFUl9FVkVOVF9UWVBFLCBtb3VzZU92ZXJIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbk1vdXNlTW92ZShtb3VzZU1vdmVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChNT1VTRU1PVkVfRVZFTlRfVFlQRSwgbW91c2VNb3ZlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuY29uc3QgbW91c2VNaXhpbnMgPSB7XG4gIG9uTW91c2VVcCxcbiAgb2ZmTW91c2VVcCxcbiAgb25Nb3VzZU91dCxcbiAgb2ZmTW91c2VPdXQsXG4gIG9uTW91c2VEb3duLFxuICBvZmZNb3VzZURvd24sXG4gIG9uTW91c2VPdmVyLFxuICBvZmZNb3VzZU92ZXIsXG4gIG9uTW91c2VNb3ZlLFxuICBvZmZNb3VzZU1vdmVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vdXNlTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDTElDS19FVkVOVF9UWVBFLCBEQkxDTElDS19FVkVOVF9UWVBFLCBBVVhDTElDS19FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25DbGljayhjbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KENMSUNLX0VWRU5UX1RZUEUsIGNsaWNrSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ2xpY2soY2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoQ0xJQ0tfRVZFTlRfVFlQRSwgY2xpY2tIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvbkF1eENsaWNrKGF1eENsaWNrSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQVVYQ0xJQ0tfRVZFTlRfVFlQRSwgYXV4Q2xpY2tIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZBdXhDbGljayhhdXhDbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChBVVhDTElDS19FVkVOVF9UWVBFLCBhdXhDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZG91YmxlQ2xpY2tIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChEQkxDTElDS19FVkVOVF9UWVBFLCBkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9IC8vL1xuXG5mdW5jdGlvbiBvZmZEb3VibGVDbGljayhkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChEQkxDTElDS19FVkVOVF9UWVBFLCBkb3VibGVDbGlja0hhbmRsZXIsIGVsZW1lbnQpOyB9IC8vL1xuXG5jb25zdCBjbGlja01peGlucyA9IHtcbiAgb25DbGljayxcbiAgb2ZmQ2xpY2ssXG4gIG9uQXV4Q2xpY2ssXG4gIG9mZkF1eENsaWNrLFxuICBvbkRvdWJsZUNsaWNrLFxuICBvZmZEb3VibGVDbGlja1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpY2tNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFRPVUNIU1RBUlRfRVZFTlRfVFlQRSwgVE9VQ0hNT1ZFX0VWRU5UX1RZUEUsIFRPVUNIRU5EX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vbkV2ZW50KFRPVUNIU1RBUlRfRVZFTlRfVFlQRSwgdG91Y2hTdGFydEhhbmRsZXIpOyB9XG5cbmZ1bmN0aW9uIG9mZlRvdWNoU3RhcnQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vZmZFdmVudChUT1VDSFNUQVJUX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvblRvdWNoTW92ZSh0b3VjaFN0YXJ0SGFuZGxlcikgeyB0aGlzLm9uRXZlbnQoVE9VQ0hNT1ZFX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvZmZUb3VjaE1vdmUodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vZmZFdmVudChUT1VDSE1PVkVfRVZFTlRfVFlQRSwgdG91Y2hTdGFydEhhbmRsZXIpOyB9XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQodG91Y2hTdGFydEhhbmRsZXIpIHsgdGhpcy5vbkV2ZW50KFRPVUNIRU5EX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5mdW5jdGlvbiBvZmZUb3VjaEVuZCh0b3VjaFN0YXJ0SGFuZGxlcikgeyB0aGlzLm9mZkV2ZW50KFRPVUNIRU5EX0VWRU5UX1RZUEUsIHRvdWNoU3RhcnRIYW5kbGVyKTsgfVxuXG5jb25zdCBjbGlja01peGlucyA9IHtcbiAgb25Ub3VjaFN0YXJ0LFxuICBvZmZUb3VjaFN0YXJ0LFxuICBvblRvdWNoTW92ZSxcbiAgb2ZmVG91Y2hNb3ZlLFxuICBvblRvdWNoRW5kLFxuICBvZmZUb3VjaEVuZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xpY2tNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNDUk9MTF9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9uU2Nyb2xsKHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KFNDUk9MTF9FVkVOVF9UWVBFLCBzY3JvbGxIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZmU2Nyb2xsKHNjcm9sbEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChTQ1JPTExfRVZFTlRfVFlQRSwgc2Nyb2xsSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gc2Nyb2xsVG8oc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0KSB7IHRoaXMuZG9tRWxlbWVudC5zY3JvbGxUbyhzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApOyB9IC8vL1xuXG5mdW5jdGlvbiBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsVG9wOyB9XG5cbmZ1bmN0aW9uIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsTGVmdDsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxXaWR0aCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5zY3JvbGxXaWR0aDsgfVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2Nyb2xsSGVpZ2h0OyB9XG5cbmZ1bmN0aW9uIHNldFNjcm9sbFRvcChzY3JvbGxUb3ApIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDsgfVxuXG5mdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KHNjcm9sbExlZnQpIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0OyB9XG5cbmNvbnN0IHNjcm9sbE1peGlucyA9IHtcbiAgb25TY3JvbGwsXG4gIG9mZlNjcm9sbCxcbiAgc2Nyb2xsVG8sXG4gIGdldFNjcm9sbFRvcCxcbiAgZ2V0U2Nyb2xsTGVmdCxcbiAgZ2V0U2Nyb2xsV2lkdGgsXG4gIGdldFNjcm9sbEhlaWdodCxcbiAgc2V0U2Nyb2xsVG9wLFxuICBzZXRTY3JvbGxMZWZ0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzY3JvbGxNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJFU0laRV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25SZXNpemUocmVzaXplSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoUkVTSVpFX0VWRU5UX1RZUEUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmNvbnN0IHJlc2l6ZU1peGlucyA9IHtcbiAgb25SZXNpemUsXG4gIG9mZlJlc2l6ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVzaXplTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBGVUxMU0NSRUVOQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbkZ1bGxTY3JlZW5DaGFuZ2UoZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSwgZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9ICAvLy9cblxuZnVuY3Rpb24gb2ZmRnVsbFNjcmVlbkNoYW5nZShmdWxsU2NyZWVuQ2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEZVTExTQ1JFRU5DSEFOR0VfRVZFTlRfVFlQRSwgZnVsbFNjcmVlbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpOyB9ICAvLy9cblxuZnVuY3Rpb24gcmVxdWVzdEZ1bGxTY3JlZW4oZXJyb3JIYW5kbGVyKSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB0aGlzLmdldERPTUVsZW1lbnQoKTtcblxuICBkb21FbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gZXhpdEZ1bGxTY3JlZW4oKSB7XG4gIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVsbFNjcmVlbigpIHtcbiAgY29uc3QgeyBmdWxsc2NyZWVuRWxlbWVudCB9ID0gZG9jdW1lbnQsXG4gICAgICAgIGZ1bGxTY3JlZW4gPSAoZnVsbHNjcmVlbkVsZW1lbnQgIT09IG51bGwpO1xuXG4gIHJldHVybiBmdWxsU2NyZWVuO1xufVxuXG5jb25zdCBmdWxsc2NyZWVuTWl4aW5zID0ge1xuICBvbkZ1bGxTY3JlZW5DaGFuZ2UsXG4gIG9mZkZ1bGxTY3JlZW5DaGFuZ2UsXG4gIHJlcXVlc3RGdWxsU2NyZWVuLFxuICBleGl0RnVsbFNjcmVlbixcbiAgaXNGdWxsU2NyZWVuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdWxsc2NyZWVuTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChhcnJheSwgb3BlcmF0aW9uLCBkb25lLCBjb250ZXh0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xuXG4gIGxldCBjb3VudCA9IC0xO1xuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgY291bnQrKztcblxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xuICAgICAgICAgICAgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNQQUNFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNcIjtcblxuZnVuY3Rpb24gb25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGVzLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBjdXN0b21FdmVudFR5cGVzID0gY3VzdG9tRXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGN1c3RvbUV2ZW50VHlwZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnRUeXBlKSA9PiB7XG4gICAgdGhpcy5hZGRDdXN0b21FdmVudExpc3RlbmVyKGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGVzLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50ID0gdGhpcykge1xuICBjdXN0b21FdmVudFR5cGVzID0gY3VzdG9tRXZlbnRUeXBlcy5zcGxpdChTUEFDRSk7IC8vL1xuXG4gIGN1c3RvbUV2ZW50VHlwZXMuZm9yRWFjaCgoY3VzdG9tRXZlbnRUeXBlKSA9PiB7XG4gICAgdGhpcy5yZW1vdmVDdXN0b21FdmVudExpc3RlbmVyKGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQ3VzdG9tSGFuZGxlcnMoY3VzdG9tRXZlbnRUeXBlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmZpbmRDdXN0b21FdmVudExpc3RlbmVycyhjdXN0b21FdmVudFR5cGUpO1xuXG4gIGN1c3RvbUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQ6IGN1c3RvbUhhbmRsZXJFbGVtZW50IH0gPSBjdXN0b21FdmVudExpc3RlbmVyOyAvLy9cblxuICAgIGN1c3RvbUhhbmRsZXIuY2FsbChjdXN0b21IYW5kbGVyRWxlbWVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxDdXN0b21IYW5kbGVyc0FzeW5jKGN1c3RvbUV2ZW50VHlwZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXJzID0gdGhpcy5maW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMoY3VzdG9tRXZlbnRUeXBlKSxcbiAgICAgICAgZG9uZSA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKTsgIC8vL1xuXG4gIGZvckVhY2goY3VzdG9tRXZlbnRMaXN0ZW5lcnMsIChjdXN0b21FdmVudExpc3RlbmVyLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b21IYW5kbGVyLCBlbGVtZW50OiBjdXN0b21IYW5kbGVyRWxlbWVudCB9ID0gY3VzdG9tRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgICBkb25lID0gbmV4dDsgIC8vL1xuXG4gICAgY3VzdG9tSGFuZGxlci5jYWxsKGN1c3RvbUhhbmRsZXJFbGVtZW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMsIGRvbmUpO1xuICB9LCBkb25lKTtcbn1cblxuZnVuY3Rpb24gYWRkQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lciA9IHRoaXMuY3JlYXRlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gIGlmICghdGhpcy5jdXN0b21FdmVudExpc3RlbmVycykge1xuICAgIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMucHVzaChjdXN0b21FdmVudExpc3RlbmVyKTtcblxuICByZXR1cm4gY3VzdG9tRXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRMaXN0ZW5lciA9IHRoaXMuZmluZEN1c3RvbUV2ZW50TGlzdGVuZXIoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY3VzdG9tRXZlbnRMaXN0ZW5lciksXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG5cbiAgaWYgKHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnM7XG4gIH1cblxuICByZXR1cm4gY3VzdG9tRXZlbnRMaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZmluZEN1c3RvbUV2ZW50TGlzdGVuZXIoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXIgPSB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmZpbmQoKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBpZiAoKGN1c3RvbUV2ZW50TGlzdGVuZXIuZWxlbWVudCA9PT0gZWxlbWVudCkgJiYgKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tSGFuZGxlciA9PT0gY3VzdG9tSGFuZGxlcikgJiYgKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tRXZlbnRUeXBlID09PSBjdXN0b21FdmVudFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMoY3VzdG9tRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgaWYgKHRoaXMuY3VzdG9tRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmN1c3RvbUV2ZW50TGlzdGVuZXJzLmZvckVhY2goKGN1c3RvbUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgIGNvbnN0IGZvdW5kID0gKGN1c3RvbUV2ZW50TGlzdGVuZXIuY3VzdG9tRXZlbnRUeXBlID09PSBjdXN0b21FdmVudFR5cGUpO1xuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY3VzdG9tRXZlbnRMaXN0ZW5lcnMucHVzaChjdXN0b21FdmVudExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnRMaXN0ZW5lcihjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgbGV0IGN1c3RvbUV2ZW50TGlzdGVuZXI7XG5cbiAgY3VzdG9tRXZlbnRMaXN0ZW5lciA9ICgpID0+IHt9OyAvLy9cblxuICBPYmplY3QuYXNzaWduKGN1c3RvbUV2ZW50TGlzdGVuZXIsIHtcbiAgICBlbGVtZW50LFxuICAgIGN1c3RvbUhhbmRsZXIsXG4gICAgY3VzdG9tRXZlbnRUeXBlXG4gIH0pO1xuXG4gIHJldHVybiBjdXN0b21FdmVudExpc3RlbmVyO1xufVxuXG5jb25zdCBjdXN0b21FdmVudE1peGlucyA9IHtcbiAgb25DdXN0b21FdmVudCxcbiAgb2ZmQ3VzdG9tRXZlbnQsXG4gIGNhbGxDdXN0b21IYW5kbGVycyxcbiAgY2FsbEN1c3RvbUhhbmRsZXJzQXN5bmMsXG4gIGFkZEN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIHJlbW92ZUN1c3RvbUV2ZW50TGlzdGVuZXIsXG4gIGZpbmRDdXN0b21FdmVudExpc3RlbmVyLFxuICBmaW5kQ3VzdG9tRXZlbnRMaXN0ZW5lcnMsXG4gIGNyZWF0ZUN1c3RvbUV2ZW50TGlzdGVuZXJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbUV2ZW50TWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgT2Zmc2V0IGZyb20gXCIuL29mZnNldFwiO1xuaW1wb3J0IEJvdW5kcyBmcm9tIFwiLi9ib3VuZHNcIjtcbmltcG9ydCBqc3hNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2pzeFwiO1xuaW1wb3J0IGtleU1peGlucyBmcm9tIFwiLi9taXhpbnMva2V5XCI7XG5pbXBvcnQgc3RhdGVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3N0YXRlXCI7XG5pbXBvcnQgZXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2V2ZW50XCI7XG5pbXBvcnQgbW91c2VNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL21vdXNlXCI7XG5pbXBvcnQgY2xpY2tNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2NsaWNrXCI7XG5pbXBvcnQgdG91Y2hNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3RvdWNoXCI7XG5pbXBvcnQgc2Nyb2xsTWl4aW5zIGZyb20gXCIuL21peGlucy9zY3JvbGxcIjtcbmltcG9ydCByZXNpemVNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3Jlc2l6ZVwiO1xuaW1wb3J0IGVsZW1lbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2VsZW1lbnRcIjtcbmltcG9ydCBmdWxsU2NyZWVuTWl4aW5zIGZyb20gXCIuL21peGlucy9mdWxsU2NyZWVuXCI7XG5pbXBvcnQgY3VzdG9tRXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2N1c3RvbUV2ZW50XCI7XG5cbmltcG9ydCB7IGF1Z21lbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tIFwiLi91dGlsaXRpZXMvb2JqZWN0XCI7XG5pbXBvcnQgeyBpc1NWR1RhZ05hbWUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbmFtZVwiO1xuaW1wb3J0IHsgY29uc3RydWN0RWxlbWVudCwgZGVzdHJveUVsZW1lbnQsIG1vdW50RWxlbWVudCwgdW5tb3VudEVsZW1lbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudFwiO1xuaW1wb3J0IHsgTk9ORSxcbiAgICAgICAgIEJMT0NLLFxuICAgICAgICAgV0lEVEgsXG4gICAgICAgICBTVFJJTkcsXG4gICAgICAgICBIRUlHSFQsXG4gICAgICAgICBESVNQTEFZLFxuICAgICAgICAgRElTQUJMRUQsXG4gICAgICAgICBFTVBUWV9TVFJJTkcsXG4gICAgICAgICBTVkdfTkFNRVNQQUNFX1VSSSxcbiAgICAgICAgIERFRkFVTFRfUFJPUEVSVElFUyxcbiAgICAgICAgIElHTk9SRURfUFJPUEVSVElFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPXRoaXMsICAvLy9cbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgICAgY29uc3RydWN0RWxlbWVudChlbGVtZW50LCBkb21FbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBnZXRET01FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQ7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gT2Zmc2V0LmZyb21ET01FbGVtZW50KHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGJvdW5kcyA9IEJvdW5kcy5mcm9tRE9NRWxlbWVudCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGdldFdpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50Lm9mZnNldFdpZHRoOyB9ICAvLy9cblxuICBnZXRIZWlnaHQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyB9ICAvLy9cblxuICBnZXRJbm5lcldpZHRoKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmNsaWVudFdpZHRoOyB9IC8vL1xuXG4gIGdldElubmVySGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmNsaWVudEhlaWdodDsgfSAvLy9cblxuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIHdpZHRoID0gYCR7d2lkdGh9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoV0lEVEgsIHdpZHRoKTtcbiAgfVxuXG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSBgJHtoZWlnaHR9cHhgOyAvLy9cblxuICAgIHRoaXMuc3R5bGUoSEVJR0hULCBoZWlnaHQpO1xuICB9XG5cbiAgaGFzQXR0cmlidXRlKG5hbWUpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUobmFtZSk7IH1cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfVxuXG4gIGNsZWFyQXR0cmlidXRlKG5hbWUpIHsgdGhpcy5kb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgfVxuXG4gIGFkZEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgeyB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7IH1cblxuICByZW1vdmVBdHRyaWJ1dGUobmFtZSkgeyB0aGlzLmNsZWFyQXR0cmlidXRlKG5hbWUpOyB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7IH1cblxuICBzZXRDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkgeyB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpOyB9XG5cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH1cblxuICB0b2dnbGVDbGFzcyhjbGFzc05hbWUpIHsgdGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTsgfVxuXG4gIHJlbW92ZUFsbENsYXNzZXMoKSB7IHRoaXMuZG9tRWxlbWVudC5jbGFzc05hbWUgPSBFTVBUWV9TVFJJTkc7IH1cblxuICBhZGRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQuYWRkKHRoaXMpOyB9XG5cbiAgYXBwZW5kVG8ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LmFwcGVuZCh0aGlzKTsgfVxuXG4gIHByZXBlbmRUbyhwYXJlbnRFbGVtZW50KSB7IHBhcmVudEVsZW1lbnQucHJlcGVuZCh0aGlzKTsgfVxuXG4gIHJlbW92ZUZyb20ocGFyZW50RWxlbWVudCkgeyBwYXJlbnRFbGVtZW50LnJlbW92ZSh0aGlzKTsgfVxuXG4gIGluc2VydChlbGVtZW50KSB7IHRoaXMuYXBwZW5kKGVsZW1lbnQpOyB9XG5cbiAgYWRkKGVsZW1lbnQpIHsgdGhpcy5hcHBlbmQoZWxlbWVudCk7IH1cblxuICByZW1vdmUoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZSgpO1xuICB9XG5cbiAgcHJlcGVuZChlbGVtZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudCA9IGVsZW1lbnQuZG9tRWxlbWVudCxcbiAgICAgICAgICByZWZlcmVuY2VET01FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50LmZpcnN0Q2hpbGQ7ICAvLy9cblxuICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoZG9tRWxlbWVudCwgcmVmZXJlbmNlRE9NRWxlbWVudCk7XG4gIH1cblxuICBhcHBlbmQoZWxlbWVudCkge1xuICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBlbGVtZW50LmRvbUVsZW1lbnQsXG4gICAgICAgICAgcmVmZXJlbmNlRE9NRWxlbWVudCA9IG51bGw7IC8vL1xuXG4gICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZShkb21FbGVtZW50LCByZWZlcmVuY2VET01FbGVtZW50KTtcbiAgfVxuXG4gIGluc2VydEJlZm9yZShzaWJsaW5nRWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGUgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50LnBhcmVudE5vZGUsIC8vL1xuICAgICAgICAgIHJlZmVyZW5jZURPTUVsZW1lbnQgPSBzaWJsaW5nRWxlbWVudC5kb21FbGVtZW50OyAgLy8vXG5cbiAgICBwYXJlbnRET01Ob2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbUVsZW1lbnQsIHJlZmVyZW5jZURPTUVsZW1lbnQpO1xuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnRET01Ob2RlID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5wYXJlbnROb2RlLCAvLy9cbiAgICAgICAgICByZWZlcmVuY2VET01FbGVtZW50ID0gc2libGluZ0VsZW1lbnQuZG9tRWxlbWVudC5uZXh0U2libGluZzsgIC8vL1xuXG4gICAgcGFyZW50RE9NTm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21FbGVtZW50LCByZWZlcmVuY2VET01FbGVtZW50KTtcbiAgfVxuXG4gIG1vdW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLmFkZChlbGVtZW50KTtcblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHVubW91bnQoZWxlbWVudCkge1xuICAgIHVubW91bnRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gIH1cblxuICBtb3VudEJlZm9yZShzaWJsaW5nRWxlbWVudCkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHNpYmxpbmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIG1vdW50QWZ0ZXIoc2libGluZ0VsZW1lbnQpIHtcbiAgICB0aGlzLmluc2VydEFmdGVyKHNpYmxpbmdFbGVtZW50KTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzOyAvLy9cblxuICAgIG1vdW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHNob3coZGlzcGxheVN0eWxlID0gQkxPQ0spIHsgdGhpcy5kaXNwbGF5KGRpc3BsYXlTdHlsZSk7IH1cblxuICBoaWRlKCkgeyB0aGlzLnN0eWxlKERJU1BMQVksIE5PTkUpOyB9XG5cbiAgZGlzcGxheShkaXNwbGF5KSB7IHRoaXMuc3R5bGUoRElTUExBWSwgZGlzcGxheSk7IH1cblxuICBlbmFibGUoKSB7IHRoaXMuY2xlYXJBdHRyaWJ1dGUoRElTQUJMRUQpOyB9XG5cbiAgZGlzYWJsZSgpIHsgdGhpcy5zZXRBdHRyaWJ1dGUoRElTQUJMRUQsIERJU0FCTEVEKTsgfVxuXG4gIGlzRW5hYmxlZCgpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpLFxuICAgICAgICAgIGVuYWJsZWQgPSAhZGlzYWJsZWQ7XG5cbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZShESVNBQkxFRCk7XG5cbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cbiAgXG4gIGlzRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLmNzcyhESVNQTEFZKSxcbiAgICAgICAgICBkaXNwbGF5ZWQgPSAoZGlzcGxheSAhPT0gTk9ORSk7XG4gICAgXG4gICAgcmV0dXJuIGRpc3BsYXllZDtcbiAgfVxuXG4gIGlzU2hvd2luZygpIHtcbiAgICBjb25zdCBkaXNwbGF5ZWQgPSB0aGlzLmlzRGlzcGxheWVkKCksXG4gICAgICAgICAgc2hvd2luZyA9IGRpc3BsYXllZDsgIC8vL1xuXG4gICAgcmV0dXJuIHNob3dpbmc7XG4gIH1cblxuICBpc0hpZGRlbigpIHtcbiAgICBjb25zdCBkaXNwbGF5ZWQgPSB0aGlzLmlzRGlzcGxheWVkKCksXG4gICAgICAgICAgaGlkZGVuID0gIWRpc3BsYXllZDtcblxuICAgIHJldHVybiBoaWRkZW47XG4gIH1cblxuICBzdHlsZShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGVbbmFtZV07XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBodG1sKGh0bWwgPSBudWxsKSB7XG4gICAgaWYgKGh0bWwgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGlubmVySFRNTCA9IGh0bWw7IC8vL1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gaW5uZXJIVE1MXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbm5lckhUTUwgPSB0aGlzLmRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuXG4gICAgaHRtbCA9IGlubmVySFRNTDsgLy8vXG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGNzcyhjc3MgPSBudWxsKSB7XG4gICAgaWYgKGNzcyA9PT0gbnVsbCkge1xuICAgICAgY3NzID0ge307XG5cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpOyAvLy9cblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNvbXB1dGVkU3R5bGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZXNbaW5kZXhdLFxuICAgICAgICAgICAgICBuYW1lID0gY29tcHV0ZWRTdHlsZSwgIC8vL1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUobmFtZSk7IC8vL1xuXG4gICAgICAgIGNzc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNzcyA9PT0gU1RSSU5HKSB7XG4gICAgICBsZXQgbmFtZSA9IGNzczsgLy8vXG5cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbUVsZW1lbnQpLCAvLy9cbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTsgLy8vXG5cbiAgICAgIGNzcyA9IHZhbHVlOyAgLy8vXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoY3NzKTsgLy8vXG5cbiAgICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgdGhpcy5zdHlsZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICBkZXN0cm95RWxlbWVudChlbGVtZW50KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ2xhc3MoQ2xhc3MsIHByb3BlcnRpZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGNvbnN0IHsgdGFnTmFtZSB9ID0gQ2xhc3MsXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSxcbiAgICAgICAgICBkZWZhdWx0UHJvcGVydGllcyA9IGRlZmF1bHRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzKSxcbiAgICAgICAgICBpZ25vcmVkUHJvcGVydGllcyA9IGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzKTtcblxuICAgIGVsZW1lbnQuYXBwbHlQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGRlZmF1bHRQcm9wZXJ0aWVzLCBpZ25vcmVkUHJvcGVydGllcyk7XG5cbiAgICBlbGVtZW50LmluaXRpYWxpc2UgJiYgZWxlbWVudC5pbml0aWFsaXNlKCk7IC8vL1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRhZ05hbWUodGFnTmFtZSwgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSBFbGVtZW50LCAgLy8vXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSxcbiAgICAgICAgICBkZWZhdWx0UHJvcGVydGllcyA9IHt9LCAvLy9cbiAgICAgICAgICBpZ25vcmVkUHJvcGVydGllcyA9IFtdOyAvLy9cblxuICAgIGVsZW1lbnQuYXBwbHlQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGRlZmF1bHRQcm9wZXJ0aWVzLCBpZ25vcmVkUHJvcGVydGllcyk7XG5cbiAgICBlbGVtZW50LmluaXRpYWxpc2UgJiYgZWxlbWVudC5pbml0aWFsaXNlKCk7IC8vL1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwganN4TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBtb3VzZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzdGF0ZU1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBldmVudE1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCB0b3VjaE1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBzY3JvbGxNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgcmVzaXplTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRWxlbWVudC5wcm90b3R5cGUsIGVsZW1lbnRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgZnVsbFNjcmVlbk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBjdXN0b21FdmVudE1peGlucyk7XG5cbmZ1bmN0aW9uIGVsZW1lbnRGcm9tVGFnTmFtZShDbGFzcywgdGFnTmFtZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gbnVsbCxcbiAgICAgICAgZWxlbWVudCA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChDbGFzcywgbnVsbCwgc2VsZWN0b3IsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykpLFxuICAgICAgICBkb21FbGVtZW50ID0gaXNTVkdUYWdOYW1lKHRhZ05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0VfVVJJLCB0YWdOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBjb25zdHJ1Y3RFbGVtZW50KGVsZW1lbnQsIGRvbUVsZW1lbnQpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhDbGFzcywgZGVmYXVsdFByb3BlcnRpZXMgPSB7fSkge1xuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoREVGQVVMVF9QUk9QRVJUSUVTKSkge1xuICAgIGRlZmF1bHRQcm9wZXJ0aWVzID0gY29tYmluZShkZWZhdWx0UHJvcGVydGllcywgQ2xhc3NbREVGQVVMVF9QUk9QRVJUSUVTXSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTsgIC8vL1xuXG4gIGlmIChzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgZGVmYXVsdFByb3BlcnRpZXMgPSBkZWZhdWx0UHJvcGVydGllc0Zyb21DbGFzcyhzdXBlckNsYXNzLCBkZWZhdWx0UHJvcGVydGllcyk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRQcm9wZXJ0aWVzRnJvbUNsYXNzKENsYXNzLCBpZ25vcmVkUHJvcGVydGllcyA9IFtdKSB7XG4gIGlmIChDbGFzcy5oYXNPd25Qcm9wZXJ0eShJR05PUkVEX1BST1BFUlRJRVMpKSB7XG4gICAgaWdub3JlZFByb3BlcnRpZXMgPSBhdWdtZW50KGlnbm9yZWRQcm9wZXJ0aWVzLCBDbGFzc1tJR05PUkVEX1BST1BFUlRJRVNdLCAoaWdub3JlZFByb3BlcnR5KSA9PiB7XG4gICAgICBpZiAoIWlnbm9yZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKGlnbm9yZWRQcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBzdXBlckNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKENsYXNzKTtcblxuICBpZiAoc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIGlnbm9yZWRQcm9wZXJ0aWVzID0gaWdub3JlZFByb3BlcnRpZXNGcm9tQ2xhc3Moc3VwZXJDbGFzcywgaWdub3JlZFByb3BlcnRpZXMpO1xuICB9XG5cbiAgcmV0dXJuIGlnbm9yZWRQcm9wZXJ0aWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi9lbGVtZW50XCI7XG5cbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IFNUUklORywgRlVOQ1RJT04gfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHJlbW92ZUZhbHNleUVsZW1lbnRzLCByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudHNcIjtcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChmaXJzdEFyZ3VtZW50LCBwcm9wZXJ0aWVzLCAuLi5jaGlsZEVsZW1lbnRzKSB7XG4gIGxldCBlbGVtZW50ID0gbnVsbDtcblxuICBpZiAoZmlyc3RBcmd1bWVudCkge1xuICAgIGNoaWxkRWxlbWVudHMgPSBzYW5pdGlzZUNoaWxkRWxlbWVudHMoY2hpbGRFbGVtZW50cyk7XG5cbiAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjaGlsZEVsZW1lbnRzXG4gICAgfSwgcHJvcGVydGllcyk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAoaXNTdWJjbGFzc09mKGZpcnN0QXJndW1lbnQsIEVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBDbGFzcyA9IGZpcnN0QXJndW1lbnQ7ICAvLy9cblxuICAgICAgZWxlbWVudCA9IENsYXNzLmZyb21DbGFzcyhDbGFzcywgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmd1bWVudCA9PT0gU1RSSU5HKSB7XG4gICAgICBjb25zdCB0YWdOYW1lID0gZmlyc3RBcmd1bWVudDsgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBFbGVtZW50LmZyb21UYWdOYW1lKHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0QXJndW1lbnQgPT09IEZVTkNUSU9OKSB7XG4gICAgICBjb25zdCBlbGVtZW50RnVuY3Rpb24gPSBmaXJzdEFyZ3VtZW50OyAgLy8vXG5cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50RnVuY3Rpb24ocHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmNvbnN0IFJlYWN0ID0ge1xuICBjcmVhdGVFbGVtZW50XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSZWFjdDtcblxuZnVuY3Rpb24gc2FuaXRpc2VDaGlsZEVsZW1lbnRzKGNoaWxkRWxlbWVudHMpIHtcbiAgY2hpbGRFbGVtZW50cyA9IGZsYXR0ZW4oY2hpbGRFbGVtZW50cyk7IC8vL1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZW1vdmVGYWxzZXlFbGVtZW50cyhjaGlsZEVsZW1lbnRzKTsgIC8vL1xuXG4gIGNoaWxkRWxlbWVudHMgPSByZXBsYWNlU3RyaW5nc1dpdGhUZXh0RWxlbWVudHMoY2hpbGRFbGVtZW50cyk7ICAvLy9cblxuICByZXR1cm4gY2hpbGRFbGVtZW50cztcbn1cblxuXG5mdW5jdGlvbiBpc1N1YmNsYXNzT2YoYXJndW1lbnQsIENsYXNzKSB7XG4gIGNvbnN0IHN1YmNsYXNzT2YgPSAoYXJndW1lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQ2xhc3MpO1xuXG4gIHJldHVybiBzdWJjbGFzc09mO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgTEVGVF9NT1VTRV9CVVRUT04gPSAwO1xuZXhwb3J0IGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7XG5leHBvcnQgY29uc3QgTUlERExFX01PVVNFX0JVVFRPTiA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEVGVF9NT1VTRV9CVVRUT04sXG4gIFJJR0hUX01PVVNFX0JVVFRPTixcbiAgTUlERExFX01PVVNFX0JVVFRPTlxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgSU5QVVRfRVZFTlRfVFlQRSwgQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vZXZlbnRUeXBlc1wiO1xuXG5mdW5jdGlvbiBvbklucHV0KGlucHV0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoSU5QVVRfRVZFTlRfVFlQRSwgaW5wdXRIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZJbnB1dChpbnB1dEhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vZmZFdmVudChJTlBVVF9FVkVOVF9UWVBFLCBpbnB1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlKGNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KENIQU5HRV9FVkVOVF9UWVBFLCBjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBvZmZDaGFuZ2UoY2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KENIQU5HRV9FVkVOVF9UWVBFLCBjaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC52YWx1ZTsgfVxuXG5mdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkgeyB0aGlzLmRvbUVsZW1lbnQudmFsdWUgPSB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBpc1JlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnJlYWRPbmx5OyB9XG5cbmZ1bmN0aW9uIHNldFJlYWRPbmx5KHJlYWRPbmx5KSB7IHRoaXMuZG9tRWxlbWVudC5yZWFkT25seSA9IHJlYWRPbmx5OyB9XG5cbmNvbnN0IGlucHV0TWl4aW5zID0ge1xuICBvbklucHV0LFxuICBvZmZJbnB1dCxcbiAgb25DaGFuZ2UsXG4gIG9mZkNoYW5nZSxcbiAgZ2V0VmFsdWUsXG4gIHNldFZhbHVlLFxuICBpc1JlYWRPbmx5LFxuICBzZXRSZWFkT25seVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5wdXRNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJMVVJfRVZFTlRfVFlQRSwgRk9DVVNfRVZFTlRfVFlQRSB9IGZyb20gXCIuLi9ldmVudFR5cGVzXCI7XG5cbmZ1bmN0aW9uIG9uQmx1cihibHVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQkxVUl9FVkVOVF9UWVBFLCBibHVySGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQmx1cihibHVySGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEJMVVJfRVZFTlRfVFlQRSwgYmx1ckhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uRm9jdXMoZm9jdXNIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChGT0NVU19FVkVOVF9UWVBFLCBmb2N1c0hhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZkZvY3VzKGZvY3VzSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KEZPQ1VTX0VWRU5UX1RZUEUsIGZvY3VzSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gYmx1cigpIHsgdGhpcy5kb21FbGVtZW50LmJsdXIoKTsgfVxuXG5mdW5jdGlvbiBmb2N1cygpIHsgdGhpcy5kb21FbGVtZW50LmZvY3VzKCk7IH1cblxuZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gIGNvbnN0IGZvY3VzID0gKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZG9tRWxlbWVudCk7ICAvLy9cblxuICByZXR1cm4gZm9jdXM7XG59XG5cbmNvbnN0IGZvY3VzTWl4aW5zID0ge1xuICBvbkJsdXIsXG4gIG9mZkJsdXIsXG4gIG9uRm9jdXMsXG4gIG9mZkZvY3VzLFxuICBibHVyLFxuICBmb2N1cyxcbiAgaGFzRm9jdXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZvY3VzTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDVVRfRVZFTlRfVFlQRSwgQ09QWV9FVkVOVF9UWVBFLCBQQVNURV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2V2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gb25DdXQoY3V0SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQ1VUX0VWRU5UX1RZUEUsIGN1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZkN1dChjdXRIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub2ZmRXZlbnQoQ1VUX0VWRU5UX1RZUEUsIGN1dEhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uQ29weShjb3B5SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9uRXZlbnQoQ09QWV9FVkVOVF9UWVBFLCBjb3B5SGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gb2ZmQ29weShjb3B5SGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KENPUFlfRVZFTlRfVFlQRSwgY29weUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9uUGFzdGUocGFzdGVIYW5kbGVyLCBlbGVtZW50KSB7IHRoaXMub25FdmVudChQQVNURV9FVkVOVF9UWVBFLCBwYXN0ZUhhbmRsZXIsIGVsZW1lbnQpOyB9XG5cbmZ1bmN0aW9uIG9mZlBhc3RlKHBhc3RlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KFBBU1RFX0VWRU5UX1RZUEUsIHBhc3RlSGFuZGxlciwgZWxlbWVudCk7IH1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uU3RhcnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7IH1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRW5kKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNlbGVjdGlvbkVuZDsgfVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25TdGFydChzZWxlY3Rpb25TdGFydCkgeyB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDsgfVxuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25FbmQoc2VsZWN0aW9uRW5kKSB7IHRoaXMuZG9tRWxlbWVudC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7IH1cblxuZnVuY3Rpb24gc2VsZWN0KCkgeyB0aGlzLmRvbUVsZW1lbnQuc2VsZWN0KCk7IH1cblxuY29uc3Qgc2VsZWN0aW9uTWl4aW5zID0ge1xuICBvbkN1dCxcbiAgb2ZmQ3V0LFxuICBvbkNvcHksXG4gIG9mZkNvcHksXG4gIG9uUGFzdGUsXG4gIG9mZlBhc3RlLFxuICBnZXRTZWxlY3Rpb25TdGFydCxcbiAgZ2V0U2VsZWN0aW9uRW5kLFxuICBzZXRTZWxlY3Rpb25TdGFydCxcbiAgc2V0U2VsZWN0aW9uRW5kLFxuICBzZWxlY3Rcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNlbGVjdGlvbk1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGtleU1peGlucyBmcm9tIFwiLi9taXhpbnMva2V5XCI7XG5pbXBvcnQgZXZlbnRNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2V2ZW50XCI7XG5pbXBvcnQgbW91c2VNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL21vdXNlXCI7XG5pbXBvcnQgY2xpY2tNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2NsaWNrXCI7XG5cbmltcG9ydCB7IFVOREVGSU5FRCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgU0VMRUNUSU9OQ0hBTkdFX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi9ldmVudFR5cGVzXCI7XG5cbmNsYXNzIERvY3VtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQ7IC8vL1xuICB9XG5cbiAgZ2V0RE9NRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50O1xuICB9XG5cbiAgZ2V0U2VsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldFNlbGVjdGlvbigpOyB9XG5cbiAgY3JlYXRlUmFuZ2UoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuY3JlYXRlUmFuZ2UoKTsgfVxuXG4gIGNyZWF0ZVRleHROb2RlKGRhdGEpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTsgfVxuXG4gIG9uU2VsZWN0aW9uQ2hhbmdlKHNlbGVjdGlvbkNoYW5nZUhhbmRsZXIsIGVsZW1lbnQpIHsgdGhpcy5vbkV2ZW50KFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfSAvLy9cblxuICBvZmZTZWxlY3Rpb25DaGFuZ2Uoc2VsZWN0aW9uQ2hhbmdlSGFuZGxlciwgZWxlbWVudCkgeyB0aGlzLm9mZkV2ZW50KFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFLCBzZWxlY3Rpb25DaGFuZ2VIYW5kbGVyLCBlbGVtZW50KTsgfSAvLy9cblxuICBjcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgZWxlbWVudCkge1xuICAgIGxldCBldmVudExpc3RlbmVyO1xuXG4gICAgY29uc3QgaGFuZGxlckVsZW1lbnQgPSBlbGVtZW50OyAvLy9cblxuICAgIGV2ZW50TGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudFR5cGUgPT09IFNFTEVDVElPTkNIQU5HRV9FVkVOVF9UWVBFKSB7XG4gICAgICAgIGNvbnN0IHsgZG9tRWxlbWVudCB9ID0gaGFuZGxlckVsZW1lbnQsXG4gICAgICAgICAgICAgIHsgY3VycmVudFRhcmdldCB9ID0gZXZlbnQsXG4gICAgICAgICAgICAgIHsgYWN0aXZlRWxlbWVudCB9ID0gY3VycmVudFRhcmdldDtcblxuICAgICAgICBpZiAoZG9tRWxlbWVudCAhPT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpczsgLy8vXG5cbiAgICAgIGhhbmRsZXIuY2FsbChoYW5kbGVyRWxlbWVudCwgZXZlbnQsIGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKGV2ZW50TGlzdGVuZXIsIHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBoYW5kbGVyLFxuICAgICAgZXZlbnRUeXBlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwga2V5TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oRG9jdW1lbnQucHJvdG90eXBlLCBldmVudE1peGlucyk7XG5PYmplY3QuYXNzaWduKERvY3VtZW50LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihEb2N1bWVudC5wcm90b3R5cGUsIGNsaWNrTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiBkb2N1bWVudCA9PT0gVU5ERUZJTkVEKSA/IHVuZGVmaW5lZCA6IG5ldyBEb2N1bWVudCgpOyAgLy8vXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBrZXlNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2tleVwiO1xuaW1wb3J0IGV2ZW50TWl4aW5zIGZyb20gXCIuL21peGlucy9ldmVudFwiO1xuaW1wb3J0IG1vdXNlTWl4aW5zIGZyb20gXCIuL21peGlucy9tb3VzZVwiO1xuaW1wb3J0IGNsaWNrTWl4aW5zIGZyb20gXCIuL21peGlucy9jbGlja1wiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuL21peGlucy9mb2N1c1wiO1xuXG5pbXBvcnQgeyBVTkRFRklORUQgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJFU0laRV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4vZXZlbnRUeXBlc1wiO1xuaW1wb3J0IHsgb25TY3JvbGwsIG9mZlNjcm9sbCB9IGZyb20gXCIuL21peGlucy9zY3JvbGxcIjtcblxuY2xhc3MgV2luZG93IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gd2luZG93OyAvLy9cbiAgfVxuXG4gIGdldERPTUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudDtcbiAgfVxuXG4gIGFzc2lnbiguLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kb21FbGVtZW50OyAvLy9cblxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKTtcbiAgfVxuXG4gIHJlbG9hZCgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7IC8vL1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuaW5uZXJXaWR0aDsgfSAvLy9cbiAgXG4gIGdldEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5pbm5lckhlaWdodDsgfSAvLy9cblxuICBnZXRTY3JvbGxUb3AoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQucGFnZVlPZmZzZXQ7IH0gIC8vL1xuXG4gIGdldFNjcm9sbExlZnQoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQucGFnZVhPZmZzZXQ7IH0gLy8vXG5cbiAgZ2V0U2VsZWN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LmdldFNlbGVjdGlvbigpOyB9XG5cbiAgZ2V0U2NyZWVuV2lkdGgoKSB7IHJldHVybiB0aGlzLmRvbUVsZW1lbnQuc2NyZWVuLndpZHRoOyB9XG5cbiAgZ2V0U2NyZWVuSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5kb21FbGVtZW50LnNjcmVlbi5oZWlnaHQ7IH1cblxuICBzY3JvbGxUbyhzY3JvbGxUb3AsIHNjcm9sbExlZnQpIHsgdGhpcy5kb21FbGVtZW50LnNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7IH1cblxuICBvblJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gUkVTSVpFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgfVxuXG4gIG9mZlJlc2l6ZShyZXNpemVIYW5kbGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gUkVTSVpFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgZXZlbnRMaXN0ZW5lciA9IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIHJlc2l6ZUhhbmRsZXIsIGVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudExpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGtleU1peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGV2ZW50TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwgbW91c2VNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihXaW5kb3cucHJvdG90eXBlLCBjbGlja01peGlucyk7XG5PYmplY3QuYXNzaWduKFdpbmRvdy5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oV2luZG93LnByb3RvdHlwZSwge1xuICBvblNjcm9sbCxcbiAgb2ZmU2Nyb2xsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiB3aW5kb3cgPT09IFVOREVGSU5FRCkgPyB1bmRlZmluZWQgOiBuZXcgV2luZG93KCk7ICAvLy9cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcblxuaW1wb3J0IHsgQk9EWSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm9keSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihzZWxlY3RvciA9IEJPRFkpIHtcbiAgICBzdXBlcihzZWxlY3Rvcik7XG4gIH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYm9keVwiO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vZWxlbWVudFwiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZm9jdXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluayBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRIUmVmKCkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpOyB9XG5cbiAgc2V0SFJlZihocmVmKSB7IHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgaHJlZik7IH1cblxuICBzdGF0aWMgdGFnTmFtZSA9IFwiYVwiO1xufVxuXG5PYmplY3QuYXNzaWduKExpbmsucHJvdG90eXBlLCBmb2N1c01peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgaW5wdXRNaXhpbnMgZnJvbSBcIi4uL21peGlucy9pbnB1dFwiO1xuaW1wb3J0IGZvY3VzTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZm9jdXNcIjtcbmltcG9ydCBzZWxlY3Rpb25NaXhpbnMgZnJvbSBcIi4uL21peGlucy9zZWxlY3Rpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG59XG5cbk9iamVjdC5hc3NpZ24oSW5wdXQucHJvdG90eXBlLCBpbnB1dE1peGlucyk7XG5PYmplY3QuYXNzaWduKElucHV0LnByb3RvdHlwZSwgZm9jdXNNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihJbnB1dC5wcm90b3R5cGUsIHNlbGVjdGlvbk1peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi9lbGVtZW50XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImJ1dHRvblwiO1xufVxuXG5PYmplY3QuYXNzaWduKEJ1dHRvbi5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBpbnB1dE1peGlucyBmcm9tIFwiLi4vbWl4aW5zL2lucHV0XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcInNlbGVjdFwiO1xufVxuXG5PYmplY3QuYXNzaWduKFNlbGVjdC5wcm90b3R5cGUsIGlucHV0TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oU2VsZWN0LnByb3RvdHlwZSwgZm9jdXNNaXhpbnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi4vZWxlbWVudFwiO1xuaW1wb3J0IGlucHV0TWl4aW5zIGZyb20gXCIuLi9taXhpbnMvaW5wdXRcIjtcbmltcG9ydCBmb2N1c01peGlucyBmcm9tIFwiLi4vbWl4aW5zL2ZvY3VzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgRWxlbWVudCB7XG4gIGlzQ2hlY2tlZCgpIHsgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5jaGVja2VkOyB9XG5cbiAgY2hlY2soY2hlY2tlZCA9IHRydWUpIHsgdGhpcy5kb21FbGVtZW50LmNoZWNrZWQgPSBjaGVja2VkOyB9XG5cbiAgc3RhdGljIHRhZ05hbWUgPSBcImlucHV0XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIHR5cGU6IFwiY2hlY2tib3hcIlxuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKENoZWNrYm94LnByb3RvdHlwZSwgaW5wdXRNaXhpbnMpO1xuT2JqZWN0LmFzc2lnbihDaGVja2JveC5wcm90b3R5cGUsIGZvY3VzTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL2VsZW1lbnRcIjtcbmltcG9ydCBpbnB1dE1peGlucyBmcm9tIFwiLi4vbWl4aW5zL2lucHV0XCI7XG5pbXBvcnQgZm9jdXNNaXhpbnMgZnJvbSBcIi4uL21peGlucy9mb2N1c1wiO1xuaW1wb3J0IHNlbGVjdGlvbk1peGlucyBmcm9tIFwiLi4vbWl4aW5zL3NlbGVjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0YXJlYSBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwidGV4dGFyZWFcIjtcbn1cblxuT2JqZWN0LmFzc2lnbihUZXh0YXJlYS5wcm90b3R5cGUsIGlucHV0TWl4aW5zKTtcbk9iamVjdC5hc3NpZ24oVGV4dGFyZWEucHJvdG90eXBlLCBmb2N1c01peGlucyk7XG5PYmplY3QuYXNzaWduKFRleHRhcmVhLnByb3RvdHlwZSwgc2VsZWN0aW9uTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFjdCB9IGZyb20gXCIuL3JlYWN0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJvdW5kcyB9IGZyb20gXCIuL2JvdW5kc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRUeXBlcyB9IGZyb20gXCIuL2V2ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbW91c2VCdXR0b25zIH0gZnJvbSBcIi4vbW91c2VCdXR0b25zXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGVsZW1lbnRVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZWxlbWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnB1dE1peGlucyB9IGZyb20gXCIuL21peGlucy9pbnB1dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmb2N1c01peGlucyB9IGZyb20gXCIuL21peGlucy9mb2N1c1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZWxlY3Rpb25NaXhpbnMgfSBmcm9tIFwiLi9taXhpbnMvc2VsZWN0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGN1c3RvbUV2ZW50TWl4aW5zIH0gZnJvbSBcIi4vbWl4aW5zL2N1c3RvbUV2ZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZW1lbnQgfSBmcm9tIFwiLi9lbGVtZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRFbGVtZW50IH0gZnJvbSBcIi4vdGV4dEVsZW1lbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZG9jdW1lbnQgfSBmcm9tIFwiLi9kb2N1bWVudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aW5kb3cgfSBmcm9tIFwiLi93aW5kb3dcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm9keSB9IGZyb20gXCIuL2VsZW1lbnQvYm9keVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5rIH0gZnJvbSBcIi4vZWxlbWVudC9saW5rXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIElucHV0IH0gZnJvbSBcIi4vZWxlbWVudC9pbnB1dFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b24gfSBmcm9tIFwiLi9lbGVtZW50L2J1dHRvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWxlY3QgfSBmcm9tIFwiLi9lbGVtZW50L3NlbGVjdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVja2JveCB9IGZyb20gXCIuL2VsZW1lbnQvY2hlY2tib3hcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dGFyZWEgfSBmcm9tIFwiLi9lbGVtZW50L3RleHRhcmVhXCI7XG5cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSZWFjdCB9IGZyb20gXCJlYXN5XCI7XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywge1xuICBSZWFjdFxufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcIi4vanV4dGFwb3NlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHRhZ05hbWVzID0gW1xuICBcImFcIiwgXCJhYmJyXCIsIFwiYWRkcmVzc1wiLCBcImFzaWRlXCIsIFwiYXVkaW9cIixcbiAgXCJiXCIsIFwiYmFzZVwiLCBcImJkaVwiLCBcImJkb1wiLCBcImJsb2NrcXVvdGVcIiwgXCJib2R5XCIsIFwiYnJcIiwgXCJidXR0b25cIixcbiAgXCJjYW52YXNcIiwgXCJjYXB0aW9uXCIsIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJjb2xcIiwgXCJjb2xncm91cFwiLFxuICBcImRhdGFcIiwgXCJkYXRhbGlzdFwiLCBcImRkXCIsIFwiZGVsXCIsIFwiZGV0YWlsc1wiLCBcImRmblwiLCBcImRpYWxvZ1wiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImVtYmVkXCIsIFwiZmllbGRzZXRcIiwgXCJmaWdjYXB0aW9uXCIsIFwiZmlndXJlXCIsIFwiZm9vdGVyXCIsIFwiZm9ybVwiLFxuICBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLCBcImhlYWRcIiwgXCJoZWFkZXJcIiwgXCJoclwiLCBcImh0bWxcIixcbiAgXCJpXCIsIFwiaWZyYW1lXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibGlua1wiLFxuICBcIm1haW5cIiwgXCJtYXBcIiwgXCJtYXJrXCIsIFwibWV0YVwiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwibm9zY3JpcHRcIixcbiAgXCJvYmplY3RcIiwgXCJvbFwiLCBcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwib3V0cHV0XCIsXG4gIFwicFwiLCBcInBhcmFtXCIsIFwicGljdHVyZVwiLCBcInByZVwiLCBcInByb2dyZXNzXCIsXG4gIFwicVwiLCBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsXG4gIFwic1wiLCBcInNhbXBcIiwgXCJzY3JpcHRcIiwgXCJzZWN0aW9uXCIsIFwic2VsZWN0XCIsIFwic21hbGxcIiwgXCJzb3VyY2VcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3R5bGVcIiwgXCJzdWJcIiwgXCJzdW1tYXJ5XCIsIFwic3VwXCIsIFwic3ZnXCIsXG4gIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGVtcGxhdGVcIiwgXCJ0ZXh0YXJlYVwiLCBcInRmb290XCIsIFwidGhcIiwgXCJ0aGVhZFwiLCBcInRpbWVcIiwgXCJ0aXRsZVwiLCBcInRyXCIsIFwidHJhY2tcIixcbiAgXCJ1XCIsIFwidWxcIixcbiAgXCJ2YXJcIiwgXCJ2aWRlb1wiLFxuICBcIndiclwiXG5dO1xuXG5leHBvcnQgZGVmYXVsdCB0YWdOYW1lcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRSQUNFX0xFVkVMID0gXCJ0cmFjZVwiO1xuZXhwb3J0IGNvbnN0IERFQlVHX0xFVkVMID0gXCJkZWJ1Z1wiO1xuZXhwb3J0IGNvbnN0IElORk9fTEVWRUwgPSBcImluZm9cIjtcbmV4cG9ydCBjb25zdCBXQVJOSU5HX0xFVkVMID0gXCJ3YXJuaW5nXCI7XG5leHBvcnQgY29uc3QgRVJST1JfTEVWRUwgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgRkFUQUxfTEVWRUwgPSBcImZhdGFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTCxcbiAgRkFUQUxfTEVWRUxcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBHRVRfTUVUSE9EID0gXCJHRVRcIjtcbmV4cG9ydCBjb25zdCBQT1NUX01FVEhPRCA9IFwiUE9TVFwiO1xuZXhwb3J0IGNvbnN0IFBBVENIX01FVEhPRCA9IFwiUEFUQ0hcIjtcbmV4cG9ydCBjb25zdCBERUxFVEVfTUVUSE9EID0gXCJERUxFVEVcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05TX01FVEhPRCA9IFwiT1BUSU9OU1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEdFVF9NRVRIT0QsXG4gIFBPU1RfTUVUSE9ELFxuICBQQVRDSF9NRVRIT0QsXG4gIERFTEVURV9NRVRIT0QsXG4gIE9QVElPTlNfTUVUSE9EXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgUFJBR01BX0hFQURFUiA9IFwicHJhZ21hXCI7XG5leHBvcnQgY29uc3QgQUNDRVBUX0hFQURFUiA9IFwiYWNjZXB0XCI7XG5leHBvcnQgY29uc3QgTE9DQVRJT05fSEVBREVSID0gXCJsb2NhdGlvblwiO1xuZXhwb3J0IGNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gXCJ1c2VyLWFnZW50XCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9UWVBFX0hFQURFUiA9IFwiY29udGVudC10eXBlXCI7XG5leHBvcnQgY29uc3QgQVVUSE9SSVpBVElPTl9IRUFERVIgPSBcImF1dGhvcml6YXRpb25cIjtcbmV4cG9ydCBjb25zdCBDQUNIRV9DT05UUk9MX0hFQURFUiA9IFwiY2FjaGUtY29udHJvbFwiO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfTEVOR1RIX0hFQURFUiA9IFwiY29udGVudC1sZW5ndGhcIjtcbmV4cG9ydCBjb25zdCBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIgPSBcInRyYW5zZmVyLWVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgQ09OVEVOVF9ESVNQT1NJVElPTl9IRUFERVIgPSBcImNvbnRlbnQtZGlzcG9zaXRpb25cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1vcmlnaW5cIjtcbmV4cG9ydCBjb25zdCBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUiA9IFwiYWNjZXNzLWNvbnRyb2wtYWxsb3ctbWV0aG9kc1wiO1xuZXhwb3J0IGNvbnN0IEFDQ0VTU19DT05UUk9MX0FMTE9XX0hFQURFUlNfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzXCI7XG5leHBvcnQgY29uc3QgQUNDRVNTX0NPTlRST0xfUkVRVUVTVF9NRVRIT0RfSEVBREVSID0gXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSQUdNQV9IRUFERVIsXG4gIEFDQ0VQVF9IRUFERVIsXG4gIExPQ0FUSU9OX0hFQURFUixcbiAgVVNFUl9BR0VOVF9IRUFERVIsXG4gIENPTlRFTlRfVFlQRV9IRUFERVIsXG4gIEFVVEhPUklaQVRJT05fSEVBREVSLFxuICBDQUNIRV9DT05UUk9MX0hFQURFUixcbiAgQ09OVEVOVF9MRU5HVEhfSEVBREVSLFxuICBUUkFOU0ZFUl9FTkNPRElOR19IRUFERVIsXG4gIENPTlRFTlRfRElTUE9TSVRJT05fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19PUklHSU5fSEVBREVSLFxuICBBQ0NFU1NfQ09OVFJPTF9BTExPV19NRVRIT0RTX0hFQURFUixcbiAgQUNDRVNTX0NPTlRST0xfQUxMT1dfSEVBREVSU19IRUFERVIsXG4gIEFDQ0VTU19DT05UUk9MX1JFUVVFU1RfTUVUSE9EX0hFQURFUlxufTsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUQUJfS0VZX0NPREUgPSA5O1xuZXhwb3J0IGNvbnN0IFNISUZUX0tFWV9DT0RFID0gMTY7XG5leHBvcnQgY29uc3QgRU5URVJfS0VZX0NPREUgPSAxMztcbmV4cG9ydCBjb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcbmV4cG9ydCBjb25zdCBERUxFVEVfS0VZX0NPREUgPSA0NjtcbmV4cG9ydCBjb25zdCBCQUNLU1BBQ0VfS0VZX0NPREUgPSA4O1xuZXhwb3J0IGNvbnN0IEFSUk9XX1VQX0tFWV9DT0RFID0gMzg7XG5leHBvcnQgY29uc3QgQVJST1dfRE9XTl9LRVlfQ09ERSA9IDQwO1xuZXhwb3J0IGNvbnN0IEFSUk9XX0xFRlRfS0VZX0NPREUgPSAzNztcbmV4cG9ydCBjb25zdCBBUlJPV19SSUdIVF9LRVlfQ09ERSA9IDM5O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRBQl9LRVlfQ09ERSxcbiAgU0hJRlRfS0VZX0NPREUsXG4gIEVOVEVSX0tFWV9DT0RFLFxuICBFU0NBUEVfS0VZX0NPREUsXG4gIERFTEVURV9LRVlfQ09ERSxcbiAgQkFDS1NQQUNFX0tFWV9DT0RFLFxuICBBUlJPV19VUF9LRVlfQ09ERSxcbiAgQVJST1dfRE9XTl9LRVlfQ09ERSxcbiAgQVJST1dfTEVGVF9LRVlfQ09ERSxcbiAgQVJST1dfUklHSFRfS0VZX0NPREVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVVEY4X0VOQ09ESU5HID0gXCJ1dGY4XCI7XG5leHBvcnQgY29uc3QgVVRGXzhfRU5DT0RJTkcgPSBcInV0Zi04XCI7XG5leHBvcnQgY29uc3QgQkFTRTY0X0VOQ09ESU5HID0gXCJiYXNlNjRcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBVVEY4X0VOQ09ESU5HLFxuICBVVEZfOF9FTkNPRElORyxcbiAgQkFTRTY0X0VOQ09ESU5HXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgVVBfQ0hBUkFDVEVSID0gXCJcdTAwMWJbQVwiO1xuZXhwb3J0IGNvbnN0IEVUWF9DSEFSQUNURVIgPSBcIlxcdTAwMDNcIjtcbmV4cG9ydCBjb25zdCBCQVJfQ0hBUkFDVEVSID0gXCJ8XCI7XG5leHBvcnQgY29uc3QgSEFUX0NIQVJBQ1RFUiA9IFwiXlwiO1xuZXhwb3J0IGNvbnN0IFBMVVNfQ0hBUkFDVEVSID0gXCIrXCI7XG5leHBvcnQgY29uc3QgREFTSF9DSEFSQUNURVIgPSBcIi1cIjtcbmV4cG9ydCBjb25zdCBET1dOX0NIQVJBQ1RFUiA9IFwiXHUwMDFiW0JcIjtcbmV4cG9ydCBjb25zdCBMRUZUX0NIQVJBQ1RFUiA9IFwiXHUwMDFiW0RcIjtcbmV4cG9ydCBjb25zdCBSSUdIVF9DSEFSQUNURVIgPSBcIlx1MDAxYltDXCI7XG5leHBvcnQgY29uc3QgU1BBQ0VfQ0hBUkFDVEVSID0gXCIgXCI7XG5leHBvcnQgY29uc3QgQ09NTUFfQ0hBUkFDVEVSID0gXCIsXCI7XG5leHBvcnQgY29uc3QgQ09MT05fQ0hBUkFDVEVSID0gXCI6XCI7XG5leHBvcnQgY29uc3QgUEVSSU9EX0NIQVJBQ1RFUiA9IFwiLlwiO1xuZXhwb3J0IGNvbnN0IERPTExBUl9DSEFSQUNURVIgPSBcIiRcIjtcbmV4cG9ydCBjb25zdCBDVFJMX0NfQ0hBUkFDVEVSID0gXCJeQ1wiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRV9DSEFSQUNURVIgPSBcIlxcdTAwMWJcIjtcbmV4cG9ydCBjb25zdCBBU1RFUklTS19DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9DSEFSQUNURVIgPSBcIipcIjtcbmV4cG9ydCBjb25zdCBCQUNLVElDS19ERUxJTUlURVIgPSBcImBcIjtcbmV4cG9ydCBjb25zdCBORVdfTElORV9DSEFSQUNURVIgPSBcIlxcblwiO1xuZXhwb3J0IGNvbnN0IEFNUEVSU0FORF9DSEFSQUNURVIgPSBcIiZcIjtcbmV4cG9ydCBjb25zdCBCQUNLU0xBU0hfQ0hBUkFDVEVSID0gXCJcXFxcXCI7XG5leHBvcnQgY29uc3QgQkFDS1NQQUNFX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbmV4cG9ydCBjb25zdCBRVUVTVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiP1wiO1xuZXhwb3J0IGNvbnN0IEZPUldBUkRfU0xBU0hfQ0hBUkFDVEVSID0gXCIvXCI7XG5leHBvcnQgY29uc3QgT1BFTklOR19CUkFDS0VUX0NIQVJBQ1RFUiA9IFwiKFwiO1xuZXhwb3J0IGNvbnN0IENMT1NJTkdfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIilcIjtcbmV4cG9ydCBjb25zdCBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSID0gXCJcXHJcIjtcbmV4cG9ydCBjb25zdCBFWENMQU1BVElPTl9NQVJLX0NIQVJBQ1RFUiA9IFwiIVwiO1xuZXhwb3J0IGNvbnN0IE9QRU5JTkdfQ1VSTFlfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIntcIjtcbmV4cG9ydCBjb25zdCBDTE9TSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSID0gXCJ9XCI7XG5leHBvcnQgY29uc3QgT1BFTklOR19TUVVBUkVfQlJBQ0tFVF9DSEFSQUNURVIgPSBcIltcIjtcbmV4cG9ydCBjb25zdCBDTE9TSU5HX1NRVUFSRV9CUkFDS0VUX0NIQVJBQ1RFUiA9IFwiXVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVQX0NIQVJBQ1RFUixcbiAgRVRYX0NIQVJBQ1RFUixcbiAgQkFSX0NIQVJBQ1RFUixcbiAgSEFUX0NIQVJBQ1RFUixcbiAgUExVU19DSEFSQUNURVIsXG4gIERBU0hfQ0hBUkFDVEVSLFxuICBET1dOX0NIQVJBQ1RFUixcbiAgTEVGVF9DSEFSQUNURVIsXG4gIFJJR0hUX0NIQVJBQ1RFUixcbiAgU1BBQ0VfQ0hBUkFDVEVSLFxuICBDT01NQV9DSEFSQUNURVIsXG4gIENPTE9OX0NIQVJBQ1RFUixcbiAgUEVSSU9EX0NIQVJBQ1RFUixcbiAgRE9MTEFSX0NIQVJBQ1RFUixcbiAgQ1RSTF9DX0NIQVJBQ1RFUixcbiAgRVNDQVBFX0NIQVJBQ1RFUixcbiAgQVNURVJJU0tfQ0hBUkFDVEVSLFxuICBXSUxEQ0FSRF9DSEFSQUNURVIsXG4gIEJBQ0tUSUNLX0RFTElNSVRFUixcbiAgTkVXX0xJTkVfQ0hBUkFDVEVSLFxuICBBTVBFUlNBTkRfQ0hBUkFDVEVSLFxuICBCQUNLU0xBU0hfQ0hBUkFDVEVSLFxuICBCQUNLU1BBQ0VfQ0hBUkFDVEVSLFxuICBRVUVTVElPTl9NQVJLX0NIQVJBQ1RFUixcbiAgRk9SV0FSRF9TTEFTSF9DSEFSQUNURVIsXG4gIE9QRU5JTkdfQlJBQ0tFVF9DSEFSQUNURVIsXG4gIENMT1NJTkdfQlJBQ0tFVF9DSEFSQUNURVIsXG4gIENBUlJJQUdFX1JFVFVSTl9DSEFSQUNURVIsXG4gIEVYQ0xBTUFUSU9OX01BUktfQ0hBUkFDVEVSLFxuICBPUEVOSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSLFxuICBDTE9TSU5HX0NVUkxZX0JSQUNLRVRfQ0hBUkFDVEVSLFxuICBPUEVOSU5HX1NRVUFSRV9CUkFDS0VUX0NIQVJBQ1RFUixcbiAgQ0xPU0lOR19TUVVBUkVfQlJBQ0tFVF9DSEFSQUNURVJcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBaRVJPXzBfU1RBVFVTX0NPREUgPSAwO1xuZXhwb3J0IGNvbnN0IE9LXzIwMF9TVEFUVVNfQ09ERSA9IDIwMDtcbmV4cG9ydCBjb25zdCBGT1VORF8zMDJfU1RBVFVTX0NPREUgPSAzMDI7XG5leHBvcnQgY29uc3QgQ1JFQVRFRF8yMDFfU1RBVFVTX0NPREUgPSAyMDE7XG5leHBvcnQgY29uc3QgQ09ORkxJQ1RfNDA5X1NUQVRVU19DT0RFID0gNDA5O1xuZXhwb3J0IGNvbnN0IFNFRV9PVEhFUl8zMDNfU1RBVFVTX0NPREUgPSAzMDM7XG5leHBvcnQgY29uc3QgRk9SQklEREVOXzQwM19TVEFUVVNfQ09ERSA9IDQwMztcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkRfNDA0X1NUQVRVU19DT0RFID0gNDA0O1xuZXhwb3J0IGNvbnN0IE5PX0NPTlRFTlRfMjA0X1NUQVRVU19DT0RFID0gMjA0O1xuZXhwb3J0IGNvbnN0IEJBRF9HQVRFV0FZXzUwMl9TVEFUVVNfQ09ERSA9IDUwMjtcbmV4cG9ydCBjb25zdCBCQURfUkVRVUVTVF80MDBfU1RBVFVTX0NPREUgPSA0MDA7XG5leHBvcnQgY29uc3QgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfQ09ERSA9IDQwMTtcbmV4cG9ydCBjb25zdCBOT1RfQUNDRVBUQUJMRV80MDZfU1RBVFVTX0NPREUgPSA0MDY7XG5leHBvcnQgY29uc3QgUkVRVUVTVF9USU1FT1VUXzQwOF9TVEFUVVNfQ09ERSA9IDQwODtcbmV4cG9ydCBjb25zdCBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX0NPREUgPSA0Mjk7XG5leHBvcnQgY29uc3QgTUVUSE9EX05PVF9BTExPV0VEXzQwNV9TVEFUVVNfQ09ERSA9IDQwNTtcbmV4cG9ydCBjb25zdCBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfQ09ERSA9IDUwMztcbmV4cG9ydCBjb25zdCBVTlBST0NFU1NBQkxFX0VOVElUWV80MjJfU1RBVFVTX0NPREUgPSA0MjI7XG5leHBvcnQgY29uc3QgSU5URVJOQUxfU0VSVkVSX0VSUk9SXzUwMF9TVEFUVVNfQ09ERSA9IDUwMDtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFpFUk9fMF9TVEFUVVNfQ09ERSxcbiAgT0tfMjAwX1NUQVRVU19DT0RFLFxuICBGT1VORF8zMDJfU1RBVFVTX0NPREUsXG4gIENSRUFURURfMjAxX1NUQVRVU19DT0RFLFxuICBDT05GTElDVF80MDlfU1RBVFVTX0NPREUsXG4gIFNFRV9PVEhFUl8zMDNfU1RBVFVTX0NPREUsXG4gIEZPUkJJRERFTl80MDNfU1RBVFVTX0NPREUsXG4gIE5PVF9GT1VORF80MDRfU1RBVFVTX0NPREUsXG4gIE5PX0NPTlRFTlRfMjA0X1NUQVRVU19DT0RFLFxuICBCQURfR0FURVdBWV81MDJfU1RBVFVTX0NPREUsXG4gIEJBRF9SRVFVRVNUXzQwMF9TVEFUVVNfQ09ERSxcbiAgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfQ09ERSxcbiAgTk9UX0FDQ0VQVEFCTEVfNDA2X1NUQVRVU19DT0RFLFxuICBSRVFVRVNUX1RJTUVPVVRfNDA4X1NUQVRVU19DT0RFLFxuICBUT09fTUFOWV9SRVFVRVNUU180MjlfU1RBVFVTX0NPREUsXG4gIE1FVEhPRF9OT1RfQUxMT1dFRF80MDVfU1RBVFVTX0NPREUsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEVfNTAzX1NUQVRVU19DT0RFLFxuICBVTlBST0NFU1NBQkxFX0VOVElUWV80MjJfU1RBVFVTX0NPREUsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUl81MDBfU1RBVFVTX0NPREVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBURVhUX0hUTUxfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWxcIjtcbmV4cG9ydCBjb25zdCBURVhUX1BMQUlOX0NPTlRFTlRfVFlQRSA9IFwidGV4dC9wbGFpblwiO1xuZXhwb3J0IGNvbnN0IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5leHBvcnQgY29uc3QgVEVYVF9IVE1MX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLThcIjtcbmV4cG9ydCBjb25zdCBURVhUX1BMQUlOX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fT0NURVRfU1RSRUFNX0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fWF9XV1dfRk9STV9FTkNPREVEX0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5leHBvcnQgY29uc3QgQVBQTElDQVRJT05fSlNPTl9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuZXhwb3J0IGNvbnN0IEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVEVYVF9IVE1MX0NPTlRFTlRfVFlQRSxcbiAgVEVYVF9QTEFJTl9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFLFxuICBURVhUX0hUTUxfQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIFRFWFRfUExBSU5fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX09DVEVUX1NUUkVBTV9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX0pTT05fQ0hBUlNFVF9VVEZfOF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DT05URU5UX1RZUEUsXG4gIEFQUExJQ0FUSU9OX1hfV1dXX0ZPUk1fRU5DT0RFRF9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFpFUk9fMF9TVEFUVVNfTUVTU0FHRSA9IFwiXCI7XG5leHBvcnQgY29uc3QgT0tfMjAwX1NUQVRVU19NRVNTQUdFID0gXCJPS1wiO1xuZXhwb3J0IGNvbnN0IEZPVU5EXzMwMl9TVEFUVVNfTUVTU0FHRSA9IFwiRm91bmRcIjtcbmV4cG9ydCBjb25zdCBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSA9IFwiQ3JlYXRlZFwiO1xuZXhwb3J0IGNvbnN0IENPTkZMSUNUXzQwOV9TVEFUVVNfTUVTU0FHRSA9IFwiQ29uZmxpY3RcIjtcbmV4cG9ydCBjb25zdCBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFID0gXCJTZWUgb3RoZXJcIjtcbmV4cG9ydCBjb25zdCBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFID0gXCJGb3JiaWRkZW5cIjtcbmV4cG9ydCBjb25zdCBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFID0gXCJOb3QgZm91bmRcIjtcbmV4cG9ydCBjb25zdCBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSA9IFwiTm8gY29udGVudFwiO1xuZXhwb3J0IGNvbnN0IEJBRF9HQVRFV0FZXzUwMl9TVEFUVVNfTUVTU0FHRSA9IFwiQmFkIGdhdGV3YXlcIjtcbmV4cG9ydCBjb25zdCBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UgPSBcIkJhZCByZXF1ZXN0XCI7XG5leHBvcnQgY29uc3QgVU5BVVRIT1JJWkVEXzQwMV9TVEFUVVNfTUVTU0FHRSA9IFwiVW5hdXRob3JpemVkXCI7XG5leHBvcnQgY29uc3QgTk9UX0FDQ0VQVEFCTEVfNDA2X1NUQVRVU19NRVNTQUdFID0gXCJOb3QgQWNjZXB0YWJsZVwiO1xuZXhwb3J0IGNvbnN0IFJFUVVFU1RfVElNRU9VVF80MDhfU1RBVFVTX01FU1NBR0UgPSBcIlJlcXVlc3QgdGltZW91dFwiO1xuZXhwb3J0IGNvbnN0IFRPT19NQU5ZX1JFUVVFU1RTXzQyOV9TVEFUVVNfTUVTU0FHRSA9IFwiVG9vIG1hbnkgcmVxdWVzdHNcIjtcbmV4cG9ydCBjb25zdCBNRVRIT0RfTk9UX0FMTE9XRURfNDA1X1NUQVRVU19NRVNTQUdFID0gXCJNZXRob2Qgbm90IGFsbG93ZWRcIjtcbmV4cG9ydCBjb25zdCBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfTUVTU0FHRSA9IFwiU2VydmljZSB1bmF2YWlsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IFVOUFJPQ0VTU0FCTEVfRU5USVRZXzQyMl9TVEFUVVNfTUVTU0FHRSA9IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIjtcbmV4cG9ydCBjb25zdCBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19NRVNTQUdFID0gXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBaRVJPXzBfU1RBVFVTX01FU1NBR0UsXG4gIE9LXzIwMF9TVEFUVVNfTUVTU0FHRSxcbiAgRk9VTkRfMzAyX1NUQVRVU19NRVNTQUdFLFxuICBDUkVBVEVEXzIwMV9TVEFUVVNfTUVTU0FHRSxcbiAgQ09ORkxJQ1RfNDA5X1NUQVRVU19NRVNTQUdFLFxuICBTRUVfT1RIRVJfMzAzX1NUQVRVU19NRVNTQUdFLFxuICBGT1JCSURERU5fNDAzX1NUQVRVU19NRVNTQUdFLFxuICBOT1RfRk9VTkRfNDA0X1NUQVRVU19NRVNTQUdFLFxuICBOT19DT05URU5UXzIwNF9TVEFUVVNfTUVTU0FHRSxcbiAgQkFEX0dBVEVXQVlfNTAyX1NUQVRVU19NRVNTQUdFLFxuICBCQURfUkVRVUVTVF80MDBfU1RBVFVTX01FU1NBR0UsXG4gIFVOQVVUSE9SSVpFRF80MDFfU1RBVFVTX01FU1NBR0UsXG4gIE5PVF9BQ0NFUFRBQkxFXzQwNl9TVEFUVVNfTUVTU0FHRSxcbiAgUkVRVUVTVF9USU1FT1VUXzQwOF9TVEFUVVNfTUVTU0FHRSxcbiAgVE9PX01BTllfUkVRVUVTVFNfNDI5X1NUQVRVU19NRVNTQUdFLFxuICBNRVRIT0RfTk9UX0FMTE9XRURfNDA1X1NUQVRVU19NRVNTQUdFLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFXzUwM19TVEFUVVNfTUVTU0FHRSxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFlfNDIyX1NUQVRVU19NRVNTQUdFLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1JfNTAwX1NUQVRVU19NRVNTQUdFXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgWkVSTyA9IFwiMFwiO1xuZXhwb3J0IGNvbnN0IERBVEEgPSBcImRhdGFcIjtcbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBTVFJJTkcgPSBcInN0cmluZ1wiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUiA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFwiYm9vbGVhblwiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFQgPSBcImRlZmF1bHRcIjtcbmV4cG9ydCBjb25zdCBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVCA9IFwiRU5WSVJPTk1FTlRcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IERPVUJMRV9TUEFDRSA9IFwiICBcIjtcbmV4cG9ydCBjb25zdCBQQUNLQUdFX0pTT04gPSBcInBhY2thZ2UuanNvblwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzBdO31cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZChhcnJheSkgeyByZXR1cm4gYXJyYXlbMV07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkKGFycmF5KSB7IHJldHVybiBhcnJheVsyXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZm91cnRoKGFycmF5KSB7IHJldHVybiBhcnJheVszXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlmdGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzRdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXh0aChhcnJheSkgeyByZXR1cm4gYXJyYXlbNV07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldmVudGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzZdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBlaWdodGgoYXJyYXkpIHsgcmV0dXJuIGFycmF5WzddOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBuaW50aChhcnJheSkgeyByZXR1cm4gYXJyYXlbOF07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbnRoKGFycmF5KSB7IHJldHVybiBhcnJheVs5XTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RMYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vjb25kTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMl07IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRoaXJkTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gM107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvdXJ0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDRdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWZ0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDVdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzaXh0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDZdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXZlbnRoTGFzdChhcnJheSkgeyByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gN107IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGVpZ2h0aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDhdOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBuaW50aExhc3QoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDldOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycmF5KSB7IHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCwgMSk7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDEpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZShhcnJheS5sZW5ndGggLSAxKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbnQoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDAsIE1hdGgubWF4KDEsIGFycmF5Lmxlbmd0aCAtIDEpKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaChhcnJheUEsIGFycmF5QikgeyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcnJheUEsIGFycmF5Qik7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2hpZnQoYXJyYXlBLCBhcnJheUIpIHsgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYXJyYXlBLCBhcnJheUIpOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoYXJyYXlBLCBlbGVtZW50T3JBcnJheTIpIHtcbiAgY29uc3QgYXJyYXlCID0gKGVsZW1lbnRPckFycmF5MiBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRPckFycmF5MiA6XG4gICAgICAgICAgICAgICAgICAgICBbIGVsZW1lbnRPckFycmF5MiBdO1xuICBcbiAgcHVzaChhcnJheUEsIGFycmF5Qik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihhcnJheSkge1xuICBjb25zdCBzdGFydCA9IDA7XG4gIFxuICByZXR1cm4gYXJyYXkuc3BsaWNlKHN0YXJ0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoYXJyYXlBLCBhcnJheUIpIHtcbiAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICBkZWxldGVDb3VudCA9IGFycmF5Qi5sZW5ndGg7ICAvLy9cbiAgXG4gIHNwbGljZShhcnJheUEsIHN0YXJ0LCBkZWxldGVDb3VudCwgYXJyYXlCKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKGFycmF5QSwgYXJyYXlCKSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFycmF5QSwgYXJyYXlCKTsgfVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2goYXJyYXlBLCBhcnJheUIsIGNhbGxiYWNrKSB7XG4gIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aCxcbiAgICAgICAgYXJyYXlCTGVuZ3RoID0gYXJyYXlCLmxlbmd0aDtcblxuICBpZiAoYXJyYXlBTGVuZ3RoID09PSBhcnJheUJMZW5ndGgpIHtcbiAgICBtYXRjaGVzID0gYXJyYXlBLmV2ZXJ5KChlbGVtZW50QSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRCID0gYXJyYXlCW2luZGV4XSxcbiAgICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBLCBlbGVtZW50QiwgaW5kZXgpO1xuXG4gICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBsZXQgY291cGxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGFycmF5QUxlbmd0aCA9IGFycmF5QS5sZW5ndGgsXG4gICAgICAgIGFycmF5Qkxlbmd0aCA9IGFycmF5Qi5sZW5ndGg7XG5cbiAgaWYgKGFycmF5QUxlbmd0aCA9PT0gYXJyYXlCTGVuZ3RoKSB7XG4gICAgYXJyYXlCID0gWyAgLy8vXG4gICAgICAuLi5hcnJheUJcbiAgICBdO1xuXG4gICAgY291cGxlZCA9IGFycmF5QS5ldmVyeSgoZWxlbWVudEEsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50QiA9IGV4dHJhY3QoYXJyYXlCLCAoZWxlbWVudEIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudEEsIGVsZW1lbnRCKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pIHx8IG51bGw7XG5cbiAgICAgIGlmIChlbGVtZW50QiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3VwbGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29ycmVsYXRlKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheUIgPSBbICAvLy9cbiAgICAuLi5hcnJheUJcbiAgXTtcblxuICBjb25zdCBjb3JyZWxhdGVzID0gYXJyYXlBLmV2ZXJ5KChlbGVtZW50QSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRCID0gZXh0cmFjdChhcnJheUIsIChlbGVtZW50QikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZWxlbWVudEEsIGVsZW1lbnRCKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsO1xuXG4gICAgaWYgKGVsZW1lbnRCICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb3JyZWxhdGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShhcnJheUEsIGFycmF5QiwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc29sdmVkO1xuXG4gIGFycmF5QSA9IFsgIC8vL1xuICAgIC4uLmFycmF5QVxuICBdO1xuXG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBhcnJheUFMZW5ndGggPSBhcnJheUEubGVuZ3RoO1xuXG4gICAgaWYgKGFycmF5QUxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICBhcnJheUEuZm9yRWFjaCgoZWxlbWVudEEpID0+IHtcbiAgICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBKTtcblxuICAgICAgaWYgKHBhc3NlZCkge1xuICAgICAgICBjb25zdCBlbGVtZW50QiA9IGVsZW1lbnRBOyAgLy8vXG5cbiAgICAgICAgYXJyYXlCLnB1c2goZWxlbWVudEIpO1xuXG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZpbHRlcihhcnJheUEsIChlbGVtZW50QSkgPT4ge1xuICAgICAgY29uc3QgYXJyYXlCSW5jbHVkZXNFbGVtZW50QSA9IGFycmF5Qi5pbmNsdWRlcyhlbGVtZW50QSk7XG5cbiAgICAgIGlmICghYXJyYXlCSW5jbHVkZXNFbGVtZW50QSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGFycmF5QUxlbmd0aCA9IGFycmF5QS5sZW5ndGg7XG5cbiAgcmVzb2x2ZWQgPSAoYXJyYXlBTGVuZ3RoID09PSAwKTtcblxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gIGZvcndhcmRzRm9yRWFjaChhcnJheSwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2UoYXJyYXksIGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gIGxldCBzdGFydDtcbiAgXG4gIGNvbnN0IGZvdW5kID0gYXJyYXkuc29tZSgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBzdGFydCA9IGluZGV4OyAgLy8vXG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIFxuICBpZiAoZm91bmQpIHtcbiAgICBjb25zdCBkZWxldGVDb3VudCA9IDE7XG5cbiAgICBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGljZShhcnJheUEsIHN0YXJ0LCBkZWxldGVDb3VudCA9IEluZmluaXR5LCBhcnJheUIgPSBbXSkge1xuICBjb25zdCBhcmdzID0gWyBzdGFydCwgZGVsZXRlQ291bnQsIC4uLmFycmF5QiBdLFxuICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGFycmF5QSwgYXJncyk7XG5cbiAgcmV0dXJuIGRlbGV0ZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgZGVsZXRlZEVsZW1lbnRzID0gW107XG4gIFxuICBiYWNrd2FyZHNGb3JFYWNoKGFycmF5LCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpbmRleCwgIC8vL1xuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxLFxuICAgICAgICAgICAgZGVsZXRlZEVsZW1lbnRzID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCksXG4gICAgICAgICAgICBmaXJzdERlbGV0ZWRFbGVtZW50ID0gZmlyc3QoZGVsZXRlZEVsZW1lbnRzKTtcbiAgICAgIFxuICAgICAgZGVsZXRlZEVsZW1lbnRzLnVuc2hpZnQoZmlyc3REZWxldGVkRWxlbWVudCk7ICAvLy9cbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGRlbGV0ZWRFbGVtZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lKGFycmF5LCBjYWxsYmFjaykge1xuICBsZXQgZGVsZXRlZEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gIFxuICBhcnJheS5zb21lKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgICAgICBkZWxldGVDb3VudCA9IDEsXG4gICAgICAgICAgICBkZWxldGVkRWxlbWVudHMgPSBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSxcbiAgICAgICAgICAgIGZpcnN0RGVsZXRlZEVsZW1lbnQgPSBmaXJzdChkZWxldGVkRWxlbWVudHMpO1xuICAgICAgXG4gICAgICBkZWxldGVkRWxlbWVudCA9IGZpcnN0RGVsZXRlZEVsZW1lbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBkZWxldGVkRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGxldCBkZWxldGVkRWxlbWVudCA9IHVuZGVmaW5lZDtcblxuICBhcnJheS5zb21lKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMSxcbiAgICAgICAgICAgIGRlbGV0ZWRFbGVtZW50cyA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpLFxuICAgICAgICAgICAgZmlyc3REZWxldGVkRWxlbWVudCA9IGZpcnN0KGRlbGV0ZWRFbGVtZW50cyk7XG5cbiAgICAgIGRlbGV0ZWRFbGVtZW50ID0gZmlyc3REZWxldGVkRWxlbWVudDsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWxldGVkRWxlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoKGFycmF5LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICBjb25zdCBmb3VuZCA9IGFycmF5LnNvbWUoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuXG4gIGlmIChmb3VuZCkge1xuICAgIGFycmF5LnB1c2goZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZm91bmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzcyhhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IGluZGV4MSA9IDAsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4MSA8IGxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnRCID0gYXJyYXlbaW5kZXgxXTtcblxuICAgIGZvciAobGV0IGluZGV4MiA9IGxlbmd0aCAtIDE7IGluZGV4MiA+IGluZGV4MTsgaW5kZXgyLS0pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRBID0gYXJyYXlbaW5kZXgyXSxcbiAgICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnRBLCBlbGVtZW50Qik7XG5cbiAgICAgIGlmICghcGFzc2VkKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgyLCAvLy9cbiAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgICAgIGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4MSsrO1xuXG4gICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheSA9IFtcbiAgICAuLi5hcnJheUEsXG4gICAgLi4uYXJyYXlCXG4gIF07XG5cbiAgY29tcHJlc3MoYXJyYXksIGNhbGxiYWNrKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gIGFycmF5ID0gWyAvLy9cbiAgICAuLi5hcnJheVxuICBdLnJldmVyc2UoKTtcblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdWdtZW50KGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheUIuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICBhcnJheUEucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGUoYXJyYXksIGFycmF5QSwgYXJyYXlCLCBjYWxsYmFjaykge1xuICBhcnJheS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIHBhc3NlZCA/XG4gICAgICBhcnJheUEucHVzaChlbGVtZW50KSA6XG4gICAgICAgIGFycmF5Qi5wdXNoKGVsZW1lbnQpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRmluZChhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGaW5kKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcbiAgICBcbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNTb21lKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgaWYgKHBhc3NlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzRXZlcnkoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNSZWR1Y2UoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlOyAvLy9cblxuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja3dhcmRzUmVkdWNlKGFycmF5LCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTsgLy8vXG5cbiAgY29uc3QgYXJyYXlMZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSBhcnJheUxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgZWxlbWVudCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZHNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IGFycmF5TGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRzRmluZEluZGV4KGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4KTtcblxuICAgIGlmIChwYXNzZWQpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZHNGaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFycmF5TGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gYXJyYXlMZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBwYXNzZWQgPSBjYWxsYmFjayhlbGVtZW50LCBpbmRleCk7XG5cbiAgICBpZiAocGFzc2VkKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpcnN0LFxuICBzZWNvbmQsXG4gIHRoaXJkLFxuICBmb3VydGgsXG4gIGZpZnRoLFxuICBzaXh0aCxcbiAgc2V2ZW50aCxcbiAgZWlnaHRoLFxuICBuaW50aCxcbiAgZmlyc3RMYXN0LFxuICBzZWNvbmRMYXN0LFxuICB0aGlyZExhc3QsXG4gIGZvdXJ0aExhc3QsXG4gIGZpZnRoTGFzdCxcbiAgc2l4dGhMYXN0LFxuICBzZXZlbnRoTGFzdCxcbiAgZWlnaHRoTGFzdCxcbiAgbmludGhMYXN0LFxuICBsYXN0LFxuICBoZWFkLFxuICB0YWlsLFxuICBiYWNrLFxuICBmcm9udCxcbiAgcHVzaCxcbiAgdW5zaGlmdCxcbiAgY29uY2F0LFxuICBjbGVhcixcbiAgY29weSxcbiAgbWVyZ2UsXG4gIG1hdGNoLFxuICBjb21wYXJlLFxuICBjb3JyZWxhdGUsXG4gIHJlc29sdmUsXG4gIGZpbmQsXG4gIHJlcGxhY2UsXG4gIHNwbGljZSxcbiAgZmlsdGVyLFxuICBwcnVuZSxcbiAgZXh0cmFjdCxcbiAgcGF0Y2gsXG4gIGNvbXByZXNzLFxuICBjb21iaW5lLFxuICByZXZlcnNlLFxuICBhdWdtZW50LFxuICBzZXBhcmF0ZSxcbiAgZm9yd2FyZHNGaW5kLFxuICBiYWNrd2FyZHNGaW5kLFxuICBmb3J3YXJkc1NvbWUsXG4gIGJhY2t3YXJkc1NvbWUsXG4gIGZvcndhcmRzRXZlcnksXG4gIGJhY2t3YXJkc0V2ZXJ5LFxuICBmb3J3YXJkc1JlZHVjZSxcbiAgYmFja3dhcmRzUmVkdWNlLFxuICBmb3J3YXJkc0ZvckVhY2gsXG4gIGJhY2t3YXJkc0ZvckVhY2gsXG4gIGZvcndhcmRzRmluZEluZGV4LFxuICBiYWNrd2FyZHNGaW5kSW5kZXhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQsIGxhc3QgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhOYW1lKHBhdGgpIHtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIEVNUFRZX1NUUklORykucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7IC8vL1xuXG4gIGNvbnN0IHBhdGhOYW1lID0gKC9cXC8vLnRlc3QocGF0aCkgPT09IGZhbHNlKTtcblxuICByZXR1cm4gcGF0aE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhUb3Btb3N0TmFtZShwYXRoKSB7XG4gIGNvbnN0IHBhdGhOYW1lID0gaXNQYXRoTmFtZShwYXRoKSxcbiAgICAgICAgcGF0aEFic29sdXRlUGF0aCA9IGlzUGF0aEFic29sdXRlUGF0aChwYXRoKSxcbiAgICAgICAgcGF0aFRvcG1vc3ROYW1lID0gKHBhdGhOYW1lICYmIHBhdGhBYnNvbHV0ZVBhdGgpO1xuXG4gIHJldHVybiBwYXRoVG9wbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhSZWxhdGl2ZVBhdGgocGF0aCkge1xuICBjb25zdCBwYXRoUmVsYXRpdmVQYXRoID0gIS9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoUmVsYXRpdmVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXRoQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgY29uc3QgcGF0aEFic29sdXRlUGF0aCA9IC9eXFwvLy50ZXN0KHBhdGgpO1xuXG4gIHJldHVybiBwYXRoQWJzb2x1dGVQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoKHRvcG1vc3ROYW1lLCBhYnNvbHV0ZVBhdGgpIHtcbiAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cChgXiR7dG9wbW9zdE5hbWV9KD86XFxcXC8uKyk/JGApLFxuICAgICAgICB0b3Btb3N0TmFtZUluQWJzb2x1dGVQYXRoID0gcmVnRXhwLnRlc3QoYWJzb2x1dGVQYXRoKTtcblxuICByZXR1cm4gdG9wbW9zdE5hbWVJbkFic29sdXRlUGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVBhdGhzKHBhdGgsIHJlbGF0aXZlUGF0aCkge1xuICBsZXQgY29tYmluZWRQYXRoID0gbnVsbDtcblxuICBjb25zdCBwYXRoTmFtZXMgPSBwYXRoLnNwbGl0KC9cXC8vKSxcbiAgICAgICAgcmVsYXRpdmVQYXRoTmFtZXMgPSByZWxhdGl2ZVBhdGguc3BsaXQoL1xcLy8pO1xuXG4gIGxldCBsYXN0UGF0aE5hbWUsXG4gICAgICBmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPSBmaXJzdChyZWxhdGl2ZVBhdGhOYW1lcyk7XG5cbiAgaWYgKGZpcnN0UmVsYXRpdmVQYXRoTmFtZSA9PT0gXCIuXCIpIHtcbiAgICByZWxhdGl2ZVBhdGhOYW1lcy5zaGlmdCgpO1xuICB9XG5cbiAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICBsYXN0UGF0aE5hbWUgPSBsYXN0KHBhdGhOYW1lcyk7XG5cbiAgd2hpbGUgKChmaXJzdFJlbGF0aXZlUGF0aE5hbWUgPT09IFwiLi5cIikgJiYgKGxhc3RQYXRoTmFtZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHJlbGF0aXZlUGF0aE5hbWVzLnNoaWZ0KCk7XG4gICAgcGF0aE5hbWVzLnBvcCgpO1xuXG4gICAgZmlyc3RSZWxhdGl2ZVBhdGhOYW1lID0gZmlyc3QocmVsYXRpdmVQYXRoTmFtZXMpO1xuICAgIGxhc3RQYXRoTmFtZSA9IGxhc3QocGF0aE5hbWVzKTtcbiAgfVxuXG4gIGlmIChsYXN0UGF0aE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbWJpbmVkUGF0aE5hbWVzID0gW10uY29uY2F0KHBhdGhOYW1lcykuY29uY2F0KHJlbGF0aXZlUGF0aE5hbWVzKTtcblxuICAgIGNvbWJpbmVkUGF0aCA9IGNvbWJpbmVkUGF0aE5hbWVzLmpvaW4oXCIvXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkUGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgbGV0IGNvbmNhdGVuYXRlZFBhdGg7XG5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sIEVNUFRZX1NUUklORyk7ICAvLy9cblxuICBjb25jYXRlbmF0ZWRQYXRoID0gYCR7cGF0aH0vJHtyZWxhdGl2ZVBhdGh9YDtcblxuICBjb25zdCByZW1haW5pbmdBQXJndW1lbnRzTGVuZ3RoID0gcmVtYWluaW5nQXJndW1lbnRzLmxlbmd0aDtcblxuICBpZiAocmVtYWluaW5nQUFyZ3VtZW50c0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXRoID0gY29uY2F0ZW5hdGVkUGF0aCwgIC8vL1xuICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5zaGlmdCgpO1xuXG4gICAgY29uY2F0ZW5hdGVkUGF0aCA9IGNvbmNhdGVuYXRlUGF0aHMocGF0aCwgcmVsYXRpdmVQYXRoLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZFBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IGJvdHRvbW1vc3ROYW1lID0gbnVsbDtcblxuICBjb25zdCBtYXRjaGVzID0gcGF0aC5tYXRjaCgvXi4qXFwvKFteXFwvXStcXC8/KSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgYm90dG9tbW9zdE5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGJvdHRvbW1vc3ROYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4rKVxcL1teXFwvXStcXC8/JC8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgdG9wbW9zdERpcmVjdG9yeVBhdGggPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlQYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aChwYXRoKSB7XG4gIGxldCB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL14oW15cXC9dKylcXC8uKyQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBzZWNvbmRNYXRjaDsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWUgPSBudWxsO1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9eKC4qKVxcL1teXFwvXStcXC8/JC8pO1xuXG4gIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBwYXRoV2l0aG91dEJvdHRvbW1vc3ROYW1lID0gc2Vjb25kTWF0Y2g7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0Qm90dG9tbW9zdE5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IG51bGw7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL15bXlxcL10rXFwvKC4rKSQvKTtcblxuICBpZiAobWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgcGF0aFdpdGhvdXRUb3Btb3N0RGlyZWN0b3J5TmFtZSA9IHNlY29uZE1hdGNoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhXaXRob3V0VG9wbW9zdERpcmVjdG9yeU5hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNQYXRoTmFtZSxcbiAgaXNQYXRoVG9wbW9zdE5hbWUsXG4gIGlzUGF0aFJlbGF0aXZlUGF0aCxcbiAgaXNQYXRoQWJzb2x1dGVQYXRoLFxuICBpc1RvcG1vc3ROYW1lSW5BYnNvbHV0ZVBhdGgsXG4gIGNvbWJpbmVQYXRocyxcbiAgY29uY2F0ZW5hdGVQYXRocyxcbiAgYm90dG9tbW9zdE5hbWVGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeVBhdGhGcm9tUGF0aCxcbiAgdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aCxcbiAgcGF0aFdpdGhvdXRCb3R0b21tb3N0TmFtZUZyb21QYXRoLFxuICBwYXRoV2l0aG91dFRvcG1vc3REaXJlY3RvcnlOYW1lRnJvbVBhdGhcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNlY29uZCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IENPTE9OX0NIQVJBQ1RFUiwgQU1QRVJTQU5EX0NIQVJBQ1RFUiB9IGZyb20gXCIuLi9jaGFyYWN0ZXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVyd3JpdGUoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgZXhpc3RpbmdOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLCAgLy8vXG4gICAgICAgIGV4aXN0aW5nTmFtZSA9IGV4aXN0aW5nTmFtZXMuZmluZCgoZXhpc3RpbmdOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdMb3dlckNhc2VOYW1lID0gZXhpc3RpbmdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAoZXhpc3RpbmdMb3dlckNhc2VOYW1lID09PSBsb3dlckNhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IG51bGw7XG5cbiAgaWYgKGV4aXN0aW5nTmFtZSAhPT0gbnVsbCkge1xuICAgIGhlYWRlcnNbZXhpc3RpbmdOYW1lXSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmRlcndyaXRlKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGxvd2VyQ2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGV4aXN0aW5nTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKSwgIC8vL1xuICAgICAgICBleGlzdGluZ05hbWUgPSBleGlzdGluZ05hbWVzLmZpbmQoKGV4aXN0aW5nTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTG93ZXJDYXNlTmFtZSA9IGV4aXN0aW5nTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKGV4aXN0aW5nTG93ZXJDYXNlTmFtZSA9PT0gbG93ZXJDYXNlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChleGlzdGluZ05hbWUgPT09IG51bGwpIHtcbiAgICBoZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcnRGcm9tSG9zdChob3N0KSB7XG4gIGxldCBwb3J0O1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKC9eaHR0cHM/OlxcL1xcLyhbXlxcL10rKS8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgaW5kZXggPSBzZWNvbmRNYXRjaC5pbmRleE9mKENPTE9OX0NIQVJBQ1RFUik7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIGNvbnN0IHNlY3VyZSA9IHNlY3VyZUZyb21Ib3N0KGhvc3QpO1xuXG4gICAgcG9ydCA9IHNlY3VyZSA/IDQ0MyA6IDgwOyAvLy9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGFydCA9IGluZGV4ICsgMSxcbiAgICAgICAgICBwb3J0U3RyaW5nID0gc2Vjb25kTWF0Y2guc3Vic3RyaW5nKHN0YXJ0KTtcblxuICAgIHBvcnQgPSBOdW1iZXIocG9ydFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gcG9ydDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY3VyZUZyb21Ib3N0KGhvc3QpIHtcbiAgY29uc3Qgc2VjdXJlID0gL15odHRwczpcXC9cXC8vLnRlc3QoaG9zdCk7XG5cbiAgcmV0dXJuIHNlY3VyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvc3RuYW1lRnJvbUhvc3QoaG9zdCkge1xuICBjb25zdCBtYXRjaGVzID0gaG9zdC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8oW146XFwvXSspLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpLFxuICAgICAgICBob3N0bmFtZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICByZXR1cm4gaG9zdG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVN0cmluZ0Zyb21RdWVyeShxdWVyeSkge1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHF1ZXJ5KSxcbiAgICAgICAgbmFtZXNMZW5ndGggPSBuYW1lcy5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IG5hbWVzTGVuZ3RoIC0gMSxcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBuYW1lcy5yZWR1Y2UoKHF1ZXJ5U3RyaW5nLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlbbmFtZV0sXG4gICAgICAgICAgICAgICAgZW5jb2RlZE5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSksXG4gICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSxcbiAgICAgICAgICAgICAgICBhbXBlcnNhbmRPck5vdGhpbmcgPSAoaW5kZXggIT09IGxhc3RJbmRleCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQU1QRVJTQU5EX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORztcbiAgXG4gICAgICAgICAgcXVlcnlTdHJpbmcgKz0gYCR7ZW5jb2RlZE5hbWV9PSR7ZW5jb2RlZFZhbHVlfSR7YW1wZXJzYW5kT3JOb3RoaW5nfWA7XG4gIFxuICAgICAgICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcXVlcnlTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxGcm9tSG9zdFVSSUFuZFF1ZXJ5KGhvc3QsIHVyaSwgcXVlcnkpIHtcbiAgY29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZ0Zyb21RdWVyeShxdWVyeSksXG4gICAgICAgIHVybCA9IChxdWVyeVN0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSA/XG4gICAgICAgICAgICAgICAgYCR7aG9zdH0ke3VyaX1gIDpcbiAgICAgICAgICAgICAgICAgIGAke2hvc3R9JHt1cml9PyR7cXVlcnlTdHJpbmd9YDtcblxuICByZXR1cm4gdXJsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG92ZXJ3cml0ZSxcbiAgdW5kZXJ3cml0ZSxcbiAgcG9ydEZyb21Ib3N0LFxuICBzZWN1cmVGcm9tSG9zdCxcbiAgaG9zdG5hbWVGcm9tSG9zdCxcbiAgcXVlcnlTdHJpbmdGcm9tUXVlcnksXG4gIHVybEZyb21Ib3N0VVJJQW5kUXVlcnlcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmxlbihzdHJpbmcpIHtcbiAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXG4gIGxldCBjaGFyYWN0ZXIgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgd2hpbGUgKCFjaGFyYWN0ZXIuZG9uZSkge1xuICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgIGxlbmd0aCsrXG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyY21wKHN0cmluZ0EsIHN0cmluZ0IpIHtcbiAgbGV0IGRpZmZlcmVuY2U7XG5cbiAgY29uc3QgaXRlcmF0b3JBID0gc3RyaW5nQVtTeW1ib2wuaXRlcmF0b3JdKCksIC8vL1xuICAgICAgICBpdGVyYXRvckIgPSBzdHJpbmdCW1N5bWJvbC5pdGVyYXRvcl0oKTsgLy8vXG5cbiAgbGV0IGNoYXJhY3RlckEgPSBpdGVyYXRvckEubmV4dCgpLFxuICAgICAgY2hhcmFjdGVyQiA9IGl0ZXJhdG9yQi5uZXh0KCksXG4gICAgICBjb2RlUG9pbnRBLFxuICAgICAgY29kZVBvaW50QjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvZGVQb2ludEEgPSBjaGFyYWN0ZXJBLnZhbHVlID8gLy8vXG4gICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQS52YWx1ZS5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAwO1xuICAgIGNvZGVQb2ludEIgPSBjaGFyYWN0ZXJCLnZhbHVlID8gLy8vXG4gICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQi52YWx1ZS5jb2RlUG9pbnRBdCgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgZGlmZmVyZW5jZSA9IGNvZGVQb2ludEIgLSBjb2RlUG9pbnRBO1xuXG4gICAgaWYgKGRpZmZlcmVuY2UgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjaGFyYWN0ZXJBLmRvbmUgfHwgY2hhcmFjdGVyQi5kb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGFyYWN0ZXJBID0gaXRlcmF0b3JBLm5leHQoKTtcbiAgICBjaGFyYWN0ZXJCID0gaXRlcmF0b3JCLm5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICBsZXQgaW5kZXggPSAtMSxcbiAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgY29uc3Qgc2VhcmNoU3RyaW5nTGVuZ3RoID0gc3RybGVuKHNlYXJjaFN0cmluZyk7XG5cbiAgaWYgKHNlYXJjaFN0cmluZ0xlbmd0aCA+IDApIHtcbiAgICBsZXQgY2hhcmFjdGVyO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICAgIHNlYXJjaEl0ZXJhdG9yID0gc2VhcmNoU3RyaW5nW1N5bWJvbC5pdGVyYXRvcl0oKSxcbiAgICAgICAgICBzZWFyY2hDaGFyYWN0ZXIgPSBzZWFyY2hJdGVyYXRvci5uZXh0KCk7XG5cbiAgICBjaGFyYWN0ZXIgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICBpbmRleCsrO1xuXG4gICAgd2hpbGUgKCFjaGFyYWN0ZXIuZG9uZSkge1xuICAgICAgaWYgKGNoYXJhY3Rlci52YWx1ZSA9PT0gc2VhcmNoQ2hhcmFjdGVyLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXgsICAvLy9cbiAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBzZWFyY2hTdHJpbmdMZW5ndGgsXG4gICAgICAgICAgICAgIHN1YlN0cmluZyA9IHN1YnN0cmluZyhzdHJpbmcsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICBkaWZmZXJlbmNlID0gc3RyY21wKHN1YlN0cmluZywgc2VhcmNoU3RyaW5nKTtcblxuICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaW5kZXgrK1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQpIHtcbiAgICBpbmRleCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic3RyaW5nKHN0cmluZywgc3RhcnQsIGVuZCA9IEluZmluaXR5KSB7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBzdHJpbmdbU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICBjaGFyYWN0ZXJzID0gW107XG5cbiAgbGV0IGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICB3aGlsZSAoIWNoYXJhY3Rlci5kb25lKSB7XG4gICAgaWYgKGluZGV4ID09PSBlbmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBzdGFydCkge1xuICAgICAgY2hhcmFjdGVycy5wdXNoKGNoYXJhY3Rlci52YWx1ZSk7IC8vL1xuICAgIH1cblxuICAgIGluZGV4KytcblxuICAgIGNoYXJhY3RlciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfVxuXG4gIGNvbnN0IHN1YnN0cmluZyA9IGNoYXJhY3RlcnMuam9pbihFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdWJzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RyY21wLFxuICBzdHJsZW4sXG4gIGluZGV4T2YsXG4gIHN1YnN0cmluZ1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1pZ3JhdGUoanNvbiwgbWlncmF0aW9uTWFwLCBsYXRlc3RWZXJzaW9uKSB7XG4gIGxldCB7IHZlcnNpb24gfSA9IGpzb247XG5cbiAgd2hpbGUgKHZlcnNpb24gIT09IGxhdGVzdFZlcnNpb24pIHtcbiAgICBjb25zdCBtaWdyYXRlRnVuY3Rpb24gPSBtaWdyYXRpb25NYXBbdmVyc2lvbl07XG5cbiAgICBqc29uID0gbWlncmF0ZUZ1bmN0aW9uKGpzb24pO1xuXG4gICAgKHsgdmVyc2lvbiB9ID0ganNvbik7XG4gIH1cblxuICByZXR1cm4ganNvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtaWdyYXRlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdoaWxzdChvcGVyYXRpb24sIGRvbmUsIGNvbnRleHQpIHtcclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgaW5kZXggPSBjb3VudDsgIC8vL1xyXG5cclxuICAgIG9wZXJhdGlvbihuZXh0LCBkb25lLCBjb250ZXh0LCBpbmRleCk7XHJcbiAgfVxyXG5cclxuICBuZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBvcGVyYXRpb24sIGRvbmUsIGNvbnRleHQpIHtcclxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7ICAvLy9cclxuXHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY291bnQsICAvLy9cclxuICAgICAgICAgICAgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcclxuXHJcbiAgICAgIG9wZXJhdGlvbihlbGVtZW50LCBuZXh0LCBkb25lLCBjb250ZXh0LCBpbmRleCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW5jZShvcGVyYXRpb25zLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9ucy5sZW5ndGg7ICAvLy9cclxuXHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gY291bnQsICAvLy9cclxuICAgICAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpbmRleF07XHJcblxyXG4gICAgICBvcGVyYXRpb24obmV4dCwgZG9uZSwgY29udGV4dCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXZlbnR1YWxseShvcGVyYXRpb25zLCBkb25lLCBjb250ZXh0KSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9ucy5sZW5ndGg7ICAvLy9cclxuXHJcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgZG9uZSgpO1xyXG5cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGxldCBjb3VudCA9IDA7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudCsrO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gbGVuZ3RoKTtcclxuXHJcbiAgICBpZiAodGVybWluYXRlKSB7XHJcbiAgICAgIGRvbmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9wZXJhdGlvbnMuZm9yRWFjaCgob3BlcmF0aW9uLCBpbmRleCkgPT4ge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdGVkbHkob3BlcmF0aW9uLCBsZW5ndGgsIGRvbmUsIGNvbnRleHQpIHtcclxuICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICBkb25lKCk7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSBsZW5ndGgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgb3BlcmF0aW9uKG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkc0ZvckVhY2goYXJyYXksIG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xyXG5cclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgZnVuY3Rpb24gbmV4dCgpIHtcclxuICAgIGNvdW50Kys7XHJcblxyXG4gICAgY29uc3QgdGVybWluYXRlID0gKGNvdW50ID09PSBsZW5ndGgpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkc0ZvckVhY2goYXJyYXksIG9wZXJhdGlvbiwgZG9uZSwgY29udGV4dCkge1xyXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgIC8vL1xyXG5cclxuICBsZXQgY291bnQgPSBsZW5ndGg7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBjb3VudC0tO1xyXG5cclxuICAgIGNvbnN0IHRlcm1pbmF0ZSA9IChjb3VudCA9PT0gLTEpO1xyXG5cclxuICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgZG9uZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBjb3VudCwgIC8vL1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xyXG5cclxuICAgICAgb3BlcmF0aW9uKGVsZW1lbnQsIG5leHQsIGRvbmUsIGNvbnRleHQsIGluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5leHQoKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHdoaWxzdCxcclxuICBmb3JFYWNoLFxyXG4gIHNlcXVlbmNlLFxyXG4gIGV2ZW50dWFsbHksXHJcbiAgcmVwZWF0ZWRseSxcclxuICBmb3J3YXJkc0ZvckVhY2gsXHJcbiAgYmFja3dhcmRzRm9yRWFjaFxyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFNUUklORywgRlVOQ1RJT04gfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBHRVRfTUVUSE9ELCBQT1NUX01FVEhPRCB9IGZyb20gXCIuLi9tZXRob2RzXCI7XG5pbXBvcnQgeyBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSB9IGZyb20gXCIuLi9jb250ZW50VHlwZXNcIjtcbmltcG9ydCB7IEFDQ0VQVF9IRUFERVIsIENPTlRFTlRfVFlQRV9IRUFERVIgfSBmcm9tIFwiLi4vaGVhZGVyc1wiO1xuaW1wb3J0IHsgdW5kZXJ3cml0ZSwgdXJsRnJvbUhvc3RVUklBbmRRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvaHR0cFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGhvc3QsIHVyaSwgcXVlcnksIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSBGVU5DVElPTikge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG5cbiAgICByZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZVR5cGUgPT09IEZVTkNUSU9OKSB7XG4gICAgY2FsbGJhY2sgPSByZXNwb25zZVR5cGU7ICAvLy9cblxuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gU1RSSU5HKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBoZWFkZXJzOyAvLy9cblxuICAgICAgaGVhZGVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gR0VUX01FVEhPRCxcbiAgICAgICAgYWNjZXB0ID0gQVBQTElDQVRJT05fSlNPTl9DT05URU5UX1RZUEUsXG4gICAgICAgIGNvbnRlbnQgPSBudWxsO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICByZXF1ZXN0KGhvc3QsIHVyaSwgcXVlcnksIG1ldGhvZCwgY29udGVudCwgaGVhZGVycywgcmVzcG9uc2VUeXBlLCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0KGhvc3QsIHVyaSwgcXVlcnksIGNvbnRlbnQsIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSBGVU5DVElPTikge1xuICAgIGNhbGxiYWNrID0gaGVhZGVyczsgLy8vXG5cbiAgICByZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgaGVhZGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZVR5cGUgPT09IEZVTkNUSU9OKSB7XG4gICAgY2FsbGJhY2sgPSByZXNwb25zZVR5cGU7ICAvLy9cblxuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gU1RSSU5HKSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBoZWFkZXJzOyAvLy9cblxuICAgICAgaGVhZGVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZVR5cGUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWV0aG9kID0gUE9TVF9NRVRIT0QsXG4gICAgICAgIGFjY2VwdCA9IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFLFxuICAgICAgICBjb250ZW50VHlwZSA9IEFQUExJQ0FUSU9OX0pTT05fQ09OVEVOVF9UWVBFO1xuXG4gIHVuZGVyd3JpdGVBY2NlcHRIZWFkZXIoaGVhZGVycywgYWNjZXB0KTtcblxuICB1bmRlcndyaXRlQ29udGVudFR5cGVIZWFkZXIoaGVhZGVycywgY29udGVudFR5cGUpO1xuXG4gIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBjb250ZW50LCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3QoaG9zdCwgdXJpLCBxdWVyeSwgbWV0aG9kLCBjb250ZW50LCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHVybCA9IHVybEZyb21Ib3N0VVJJQW5kUXVlcnkoaG9zdCwgdXJpLCBxdWVyeSksXG4gICAgICAgIGFjY2VwdCA9IGhlYWRlcnNbQUNDRVBUX0hFQURFUl0gfHwgbnVsbCxcbiAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdIHx8IG51bGwsXG4gICAgICAgIHhtbEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgaWYgKGNvbnRlbnRUeXBlID09PSBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSkge1xuICAgIGNvbnN0IGpzb24gPSBjb250ZW50LCAgLy8vXG4gICAgICAgICAganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXG4gICAgY29udGVudCA9IGpzb25TdHJpbmc7ICAvLy9cbiAgfVxuXG4gIGlmIChyZXNwb25zZVR5cGUgIT09IG51bGwpIHtcbiAgICBPYmplY3QuYXNzaWduKHhtbEh0dHBSZXF1ZXN0LCB7XG4gICAgICByZXNwb25zZVR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIHhtbEh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHJlYWR5U3RhdGUsIHN0YXR1cywgcmVzcG9uc2UgfSA9IHhtbEh0dHBSZXF1ZXN0LFxuICAgICAgICAgIHN0YXR1c0NvZGUgPSBzdGF0dXM7XG5cbiAgICBpZiAocmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICBsZXQgY29udGVudCA9IHJlc3BvbnNlO1xuXG4gICAgICBpZiAoYWNjZXB0ID09PSBBUFBMSUNBVElPTl9KU09OX0NPTlRFTlRfVFlQRSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBjb250ZW50LCAgLy8vXG4gICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG5cbiAgICAgICAgICBjb250ZW50ID0ganNvbjsgIC8vL1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKGNvbnRlbnQsIHN0YXR1c0NvZGUpO1xuICAgIH1cbiAgfTtcblxuICB4bWxIdHRwUmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsKTtcblxuICBpZiAoYWNjZXB0ICE9PSBudWxsKSB7XG4gICAgeG1sSHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihBQ0NFUFRfSEVBREVSLCBhY2NlcHQpO1xuICB9XG5cbiAgaWYgKGNvbnRlbnRUeXBlICE9PSBudWxsKSB7XG4gICAgeG1sSHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihDT05URU5UX1RZUEVfSEVBREVSLCBjb250ZW50VHlwZSk7XG4gIH1cblxuICAoY29udGVudCAhPT0gbnVsbCkgP1xuICAgIHhtbEh0dHBSZXF1ZXN0LnNlbmQoY29udGVudCkgOlxuICAgICAgeG1sSHR0cFJlcXVlc3Quc2VuZCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCxcbiAgcG9zdCxcbiAgcmVxdWVzdFxufVxuXG5mdW5jdGlvbiB1bmRlcndyaXRlQWNjZXB0SGVhZGVyKGhlYWRlcnMsIGFjY2VwdCkge1xuICBjb25zdCBuYW1lID0gQUNDRVBUX0hFQURFUiwgIC8vL1xuICAgICAgICB2YWx1ZSA9IGFjY2VwdDsgLy8vXG5cbiAgdW5kZXJ3cml0ZShoZWFkZXJzLCBuYW1lLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVyd3JpdGVDb250ZW50VHlwZUhlYWRlcihoZWFkZXJzLCBjb250ZW50VFlwZSkge1xuICBjb25zdCBuYW1lID0gQ09OVEVOVF9UWVBFX0hFQURFUiwgIC8vL1xuICAgICAgICB2YWx1ZSA9IGNvbnRlbnRUWXBlOyAvLy9cblxuICB1bmRlcndyaXRlKGhlYWRlcnMsIG5hbWUsIHZhbHVlKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXZlbHMgfSBmcm9tIFwiLi9sZXZlbHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWV0aG9kcyB9IGZyb20gXCIuL21ldGhvZHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaGVhZGVycyB9IGZyb20gXCIuL2hlYWRlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMga2V5Q29kZXMgfSBmcm9tIFwiLi9rZXlDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBlbmNvZGluZ3MgfSBmcm9tIFwiLi9lbmNvZGluZ3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY2hhcmFjdGVycyB9IGZyb20gXCIuL2NoYXJhY3RlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzQ29kZXMgfSBmcm9tIFwiLi9zdGF0dXNDb2Rlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb250ZW50VHlwZXMgfSBmcm9tIFwiLi9jb250ZW50VHlwZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RhdHVzTWVzc2FnZXMgfSBmcm9tIFwiLi9zdGF0dXNNZXNzYWdlc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhdGhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcGF0aFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBodHRwVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2h0dHBcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYXJyYXlcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3ZlcnNpb25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGFqYXhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvYWpheFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgViA9IFwidlwiO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9BTVBFUlNBTkQgPSBcIiZhbXA7XCI7XG5leHBvcnQgY29uc3QgRVNDQVBFRF9MRVNTX1RIQU4gPSBcIiZsdDtcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0dSRUFURVJfVEhBTiA9IFwiJmd0O1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFU0NBUEVEX0FNUEVSU0FORCwgRVNDQVBFRF9MRVNTX1RIQU4sIEVTQ0FQRURfR1JFQVRFUl9USEFOIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3Qgc2FuaXRpc2VkQ29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgRVNDQVBFRF9BTVBFUlNBTkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIEVTQ0FQRURfTEVTU19USEFOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBFU0NBUEVEX0dSRUFURVJfVEhBTik7XG5cbiAgcmV0dXJuIHNhbml0aXNlZENvbnRlbnQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCB0eXBlVHlwZSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IG5hbWVUeXBlID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgbnVtYmVyVHlwZSA9IFwibnVtYmVyXCI7XG5leHBvcnQgY29uc3QgY29tbWVudFR5cGUgPSBcImNvbW1lbnRcIjtcbmV4cG9ydCBjb25zdCBlbmRPZkxpbmVUeXBlID0gXCJlbmQtb2YtbGluZVwiO1xuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2VUeXBlID0gXCJ3aGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3Qgc3RyaW5nTGl0ZXJhbFR5cGUgPSBcInN0cmluZy1saXRlcmFsXCI7XG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lQ29tbWVudFR5cGUgPSBgJHtlbmRPZkxpbmVUeXBlfSAke2NvbW1lbnRUeXBlfWA7XG5leHBvcnQgY29uc3Qgc2luZ2xlTGluZUNvbW1lbnRUeXBlID0gYHNpbmdsZS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCByZWd1bGFyRXhwcmVzc2lvblR5cGUgPSBcInJlZ3VsYXItZXhwcmVzc2lvblwiO1xuZXhwb3J0IGNvbnN0IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgPSBgZW5kLW9mLW11bHRpLWxpbmUgJHtjb21tZW50VHlwZX1gO1xuZXhwb3J0IGNvbnN0IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZSA9IGBzdGFydC1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcbmV4cG9ydCBjb25zdCBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlID0gYG1pZGRsZS1vZi1tdWx0aS1saW5lICR7Y29tbWVudFR5cGV9YDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICB0eXBlVHlwZSxcbiAgbmFtZVR5cGUsXG4gIG51bWJlclR5cGUsXG4gIGNvbW1lbnRUeXBlLFxuICBlbmRPZkxpbmVUeXBlLFxuICB3aGl0ZXNwYWNlVHlwZSxcbiAgc3RyaW5nTGl0ZXJhbFR5cGUsXG4gIGVuZE9mTGluZUNvbW1lbnRUeXBlLFxuICBzaW5nbGVMaW5lQ29tbWVudFR5cGUsXG4gIHJlZ3VsYXJFeHByZXNzaW9uVHlwZSxcbiAgZW5kT2ZNdWx0aUxpbmVDb21tZW50VHlwZSxcbiAgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlLFxuICBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcywgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBzYW5pdGlzZUNvbnRlbnQgfSBmcm9tIFwiLi91dGlsaXRpZXMvY29udGVudFwiO1xuaW1wb3J0IHsgY29tbWVudFR5cGUsIGVuZE9mTGluZVR5cGUsIHdoaXRlc3BhY2VUeXBlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHN0cmxlbiB9ID0gc3RyaW5nVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNvbnRlbnQsIHNpZ25pZmljYW50KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMuc2lnbmlmaWNhbnQgPSBzaWduaWZpY2FudDtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBcbiAgZ2V0Q29udGVudExlbmd0aChuYWl2ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IG5haXZlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmxlbih0aGlzLmNvbnRlbnQpOyAvLy9cblxuICAgIHJldHVybiBjb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgaXNTaWduaWZpY2FudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudDtcbiAgfVxuICBcbiAgaXNDb21tZW50VG9rZW4oKSB7XG4gICAgY29uc3QgdHlwZUluY2x1ZGVzQ29tbWVudFR5cGUgPSB0aGlzLnR5cGUuaW5jbHVkZXMoY29tbWVudFR5cGUpLFxuICAgICAgICAgIGNvbW1lbnRUb2tlbiA9IHR5cGVJbmNsdWRlc0NvbW1lbnRUeXBlOyAvLy9cblxuICAgIHJldHVybiBjb21tZW50VG9rZW47XG4gIH1cblxuICBpc0VuZE9mTGluZVRva2VuKCkge1xuICAgIGNvbnN0IHR5cGVFbmRPZkxpbmVUeXBlID0gKHRoaXMudHlwZS5pbmNsdWRlcyhlbmRPZkxpbmVUeXBlKSksXG4gICAgICAgICAgZW5kT2ZMaW5lVG9rZW4gPSB0eXBlRW5kT2ZMaW5lVHlwZTsgLy8vXG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lVG9rZW47XG4gIH1cblxuICBpc1doaXRlc3BhY2VUb2tlbigpIHtcbiAgICBjb25zdCB0eXBlV2hpdGVzcGFjZVR5cGUgPSAodGhpcy50eXBlID09PSB3aGl0ZXNwYWNlVHlwZSksXG4gICAgICAgICAgd2hpdGVzcGFjZVRva2VuID0gdHlwZVdoaXRlc3BhY2VUeXBlOyAvLy9cblxuICAgIHJldHVybiB3aGl0ZXNwYWNlVG9rZW47XG4gIH1cblxuICBtYXRjaCh0b2tlbikge1xuICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICBpZiAodG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0b2tlbi5nZXRUeXBlKCksXG4gICAgICAgICAgICBjb250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgc2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgICAgIG1hdGNoZXMgPSAoKHRoaXMudHlwZSA9PT0gdHlwZSkgJiYgKHRoaXMuY29udGVudCA9PT0gY29udGVudCkgJiYgKHRoaXMuc2lnbmlmaWNhbnQgPT09IHNpZ25pZmljYW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBhc0hUTUwoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy50eXBlLCAvLy9cbiAgICAgICAgICBzYW5pdGlzZWRDb250ZW50ID0gc2FuaXRpc2VDb250ZW50KHRoaXMuY29udGVudCksXG4gICAgICAgICAgaHRtbCA9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPiR7c2FuaXRpc2VkQ29udGVudH08L3NwYW4+YDtcblxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgICAgICBzaWduaWZpY2FudCA9IHRoaXMuc2lnbmlmaWNhbnQsXG4gICAgICAgICAgdG9rZW4gPSBuZXcgQ2xhc3ModHlwZSwgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdG9rZW4gPSBudWxsO1xuXG4gICAgY29uc3QgeyByZWd1bGFyRXhwcmVzc2lvbiB9ID0gQ2xhc3MsXG4gICAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2gocmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoZXM7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE1hdGNoID0gZmlyc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgLy8vXG5cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBDbGFzcztcblxuICAgICAgICAgIHRva2VuID0gbmV3IENsYXNzKHR5cGUsIGNvbnRlbnQsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBDbGFzcyxcbiAgICAgICAgICB0b2tlbiA9IG5ldyBDbGFzcyh0eXBlLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgcmV0dXJuIG5ldyBDbGFzcyh0eXBlLCBjb250ZW50LCBzaWduaWZpY2FudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL3Rva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChDbGFzcywgY29udGVudCwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHR5cGUgPSBjb250ZW50OyAvLy9cblxuICAgICAgY29udGVudCA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSB0cnVlLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudEFuZFR5cGUoQ2xhc3MsIGNvbnRlbnQsIHR5cGUsIHNpZ25pZmljYW50LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW47XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBTaWduaWZpY2FudFRva2VuIGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IFYgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCByZWd1bGFyRXhwcmVzc2lvbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWd1bGFyRXhwcmVzc2lvbiA9IHJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG4gIFxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbiAgXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG5cbiAgbWF0Y2goY29udGVudCkge1xuICAgIGxldCBzaWduaWZpY2FudFRva2VuID0gbnVsbDtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKHRoaXMucmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hdGNoZXM7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE1hdGNoID0gZmlyc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgY29udGVudCA9IGZpcnN0TWF0Y2g7IC8vL1xuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDsgLy8vXG5cbiAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IFNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnRBbmRUeXBlKGNvbnRlbnQsIHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuICBcbiAgc3RhdGljIGZyb21Ub2tlbihUb2tlbikge1xuICAgIGNvbnN0IHsgdHlwZSwgcmVndWxhckV4cHJlc3Npb24gfSA9IFRva2VuLFxuICAgICAgICAgIHJ1bGUgPSBuZXcgUnVsZSh0eXBlLCByZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRW50cnkoZW50cnkpIHtcbiAgICBjb25zdCBlbnRyeUtleXMgPSBPYmplY3Qua2V5cyhlbnRyeSksXG4gICAgICAgICAgZmlyc3RFbnRyeUtleSA9IGZpcnN0KGVudHJ5S2V5cyksXG4gICAgICAgICAgdHlwZSA9IGZpcnN0RW50cnlLZXksIC8vL1xuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiA9IGVudHJ5W3R5cGVdLFxuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb25Gcm9tUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksXG4gICAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcbiAgICAgICAgXG4gICAgcmV0dXJuIHJ1bGU7IFxuICB9XG5cbiAgc3RhdGljIGZyb21UeXBlQW5kUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybikge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uID0gcmVndWxhckV4cHJlc3Npb25Gcm9tUmVndWxhckV4cHJlc3Npb25QYXR0ZXJuKHJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybiksXG4gICAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHR5cGUsIHJlZ3VsYXJFeHByZXNzaW9uKTtcblxuICAgIHJldHVybiBydWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ3VsYXJFeHByZXNzaW9uRnJvbVJlZ3VsYXJFeHByZXNzaW9uUGF0dGVybihyZWd1bGFyRXhwcmVzc2lvblBhdHRlcm4pIHtcbiAgY29uc3QgZmxhZ3MgPSBWLCAgLy8vXG4gICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAocmVndWxhckV4cHJlc3Npb25QYXR0ZXJuLCBmbGFncyksXG4gICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uID0gcmVnRXhwOyAvLy9cblxuICByZXR1cm4gcmVndWxhckV4cHJlc3Npb247XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnQgY29uc3QgcGx1cyA9IFwiK1wiO1xyXG5leHBvcnQgY29uc3Qgb3BhcXVlID0gXCIuXCI7XHJcbmV4cG9ydCBjb25zdCBlcHNpbG9uID0gJ1x1MDNCNSc7XHJcbmV4cG9ydCBjb25zdCB3aWxkY2FyZCA9IFwiLlwiO1xyXG5leHBvcnQgY29uc3QgYXN0ZXJpc2sgPSBcIipcIjtcclxuZXhwb3J0IGNvbnN0IGVsbGlwc2lzID0gXCIuLi5cIjtcclxuZXhwb3J0IGNvbnN0IHNlcGFyYXRvciA9IFwiOjo9XCI7XHJcbmV4cG9ydCBjb25zdCBzZW1pT3BhcXVlID0gXCIuLlwiO1xyXG5leHBvcnQgY29uc3QgdGVybWluYXRvciA9IFwiO1wiO1xyXG5leHBvcnQgY29uc3QgdmVydGljYWxCYXIgPSBcInxcIjtcclxuZXhwb3J0IGNvbnN0IG9wZW5CcmFja2V0ID0gXCIoXCI7XHJcbmV4cG9ydCBjb25zdCBjbG9zZUJyYWNrZXQgPSBcIilcIjtcclxuZXhwb3J0IGNvbnN0IHF1ZXN0aW9uTWFyayA9IFwiP1wiO1xyXG5leHBvcnQgY29uc3QgZW5kT2ZMaW5lID0gXCI8RU5EX09GX0xJTkU+XCI7XHJcbmV4cG9ydCBjb25zdCBub1doaXRlc3BhY2UgPSBcIjxOT19XSElURVNQQUNFPlwiO1xyXG5leHBvcnQgY29uc3Qgc3RhcnRPZkNvbnRlbnQgPSBcIjxTVEFSVF9PRl9DT05URU5UPlwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHBsdXMsXHJcbiAgb3BhcXVlLFxyXG4gIGVwc2lsb24sXHJcbiAgd2lsZGNhcmQsXHJcbiAgYXN0ZXJpc2ssXHJcbiAgZWxsaXBzaXMsXHJcbiAgc2VwYXJhdG9yLFxyXG4gIHNlbWlPcGFxdWUsXHJcbiAgdGVybWluYXRvcixcclxuICB2ZXJ0aWNhbEJhcixcclxuICBvcGVuQnJhY2tldCxcclxuICBjbG9zZUJyYWNrZXQsXHJcbiAgcXVlc3Rpb25NYXJrLFxyXG4gIGVuZE9mTGluZSxcclxuICBub1doaXRlc3BhY2UsXHJcbiAgc3RhcnRPZkNvbnRlbnRcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNBc0VudHJpZXMocnVsZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHJ1bGVzLm1hcCgocnVsZSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gcnVsZUFzRW50cnkocnVsZSk7XG5cbiAgICByZXR1cm4gZW50cnk7XG4gIH0pO1xuXG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJ1bGVzQXNFbnRyaWVzXG59O1xuXG5mdW5jdGlvbiBydWxlQXNFbnRyeShydWxlKSB7XG4gIGNvbnN0IHR5cGUgPSBydWxlLmdldFR5cGUoKSxcbiAgICAgICAgcmVndWxhckV4cHJlc3Npb24gPSBydWxlLmdldFJlZ3VsYXJFeHByZXNzaW9uKCksXG4gICAgICAgIHsgc291cmNlIH0gPSByZWd1bGFyRXhwcmVzc2lvbixcbiAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgW3R5cGVdOiBzb3VyY2VcbiAgICAgICAgfTtcblxuICByZXR1cm4gZW50cnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi9ydWxlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0Zyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgY29uc3QgcnVsZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICBjb25zdCBydWxlID0gUnVsZS5mcm9tRW50cnkoZW50cnkpO1xuXG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0pO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcykge1xuICBjb25zdCBJbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcyksXG4gICAgICAgIE5vdEluQ29tbWVudENsYXNzZXMgPSBOb3RJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSxcbiAgICAgICAgbGV4ZXIgPSBuZXcgQ2xhc3MocnVsZXMsIEluQ29tbWVudENsYXNzZXMsIE5vdEluQ29tbWVudENsYXNzZXMpO1xuXG4gIHJldHVybiBsZXhlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0Zyb21FbnRyaWVzLFxuICBsZXhlckZyb21SdWxlc1xufTtcblxuZnVuY3Rpb24gSW5Db21tZW50Q2xhc3Nlc0Zyb21DbGFzcyhDbGFzcykge1xuICBjb25zdCB7IEVuZE9mTGluZUNvbW1lbnRUb2tlbiwgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gPSBDbGFzcztcblxuICBjb25zdCBJbkNvbW1lbnRDbGFzc2VzID0gW1xuICAgIEVuZE9mTGluZUNvbW1lbnRUb2tlbixcbiAgICBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcbiAgICBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlblxuICBdO1xuXG4gIHJldHVybiBJbkNvbW1lbnRDbGFzc2VzO1xufVxuXG5mdW5jdGlvbiBOb3RJbkNvbW1lbnRDbGFzc2VzRnJvbUNsYXNzKENsYXNzKSB7XG4gIGNvbnN0IHsgRW5kT2ZMaW5lVG9rZW4sXG4gICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxuICAgICAgICAgIFNpbmdsZUxpbmVDb21tZW50VG9rZW4sXG4gICAgICAgICAgUmVndWxhckV4cHJlc3Npb25Ub2tlbixcbiAgICAgICAgICBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxuICAgICAgICAgIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSA9IENsYXNzO1xuXG4gIGNvbnN0IE5vdEluQ29tbWVudENsYXNzZXMgPSBbXG4gICAgRW5kT2ZMaW5lVG9rZW4sXG4gICAgV2hpdGVzcGFjZVRva2VuLFxuICAgIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXG4gICAgU2luZ2xlTGluZUNvbW1lbnRUb2tlbixcbiAgICBSZWd1bGFyRXhwcmVzc2lvblRva2VuLFxuICAgIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW5cbiAgXTtcblxuICByZXR1cm4gTm90SW5Db21tZW50Q2xhc3Nlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OlxcXFx8fFxcXFwofFxcXFwpfFxcXFw/fFxcXFwqfFxcXFwrfFxcXFwuXFxcXC5cXFxcLnxcXFxcLlxcXFwufFxcXFwufDo6PXw7fFx1MDNCNXw8U1RBUlRfT0ZfQ09OVEVOVD58PE5PX1dISVRFU1BBQ0U+fDxFTkRfT0ZfTElORT4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibnVtYmVyXCI6IFwiXig/OjB8WzEtOV1bMC05XSopXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIl5bXFxcXHd+XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ0eXBlXCI6IFwiXlxcXFxbW15cXFxcXV0rXFxcXF1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5Db21tZW50RnJvbVRva2VuQW5kSW5Db21tZW50KHRva2VuLCBpbkNvbW1lbnQpIHtcbiAgY29uc3QgdG9rZW5Db21tZW50VG9rZW4gPSB0b2tlbi5pc0NvbW1lbnRUb2tlbigpO1xuXG4gIGlmICh0b2tlbkNvbW1lbnRUb2tlbikge1xuICAgIGNvbnN0IGNvbW1lbnRUb2tlbiA9IHRva2VuLCAvLy9cbiAgICAgICAgICBjb21tZW50VG9rZW5JbkNvbW1lbnRQcmVzZXJ2aW5nID0gY29tbWVudFRva2VuLmlzSW5Db21tZW50UHJlc2VydmluZygpO1xuXG4gICAgaW5Db21tZW50ID0gY29tbWVudFRva2VuSW5Db21tZW50UHJlc2VydmluZzsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGluQ29tbWVudDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgaW5Db21tZW50RnJvbVRva2VuQW5kSW5Db21tZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy90b2tlblwiO1xyXG5pbXBvcnQgeyBydWxlc0Zyb21FbnRyaWVzLCBsZXhlckZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvbGV4ZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbW1vbkxleGVyIHtcclxuICBjb25zdHJ1Y3RvcihydWxlcywgSW5Db21tZW50Q2xhc3NlcywgTm90SW5Db21tZW50Q2xhc3Nlcykge1xyXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG4gICAgdGhpcy5JbkNvbW1lbnRDbGFzc2VzID0gSW5Db21tZW50Q2xhc3NlcztcclxuICAgIHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcyA9IE5vdEluQ29tbWVudENsYXNzZXM7XHJcbiAgfVxyXG4gIFxyXG4gIGdldFJ1bGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucnVsZXM7XHJcbiAgfVxyXG5cclxuICBnZXRJbkNvbW1lbnRDbGFzc2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuSW5Db21tZW50Q2xhc3NlcztcclxuICB9XHJcblxyXG4gIGdldE5vdEluQ29tbWVudENsYXNzZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5Ob3RJbkNvbW1lbnRDbGFzc2VzO1xyXG4gIH1cclxuXHJcbiAgdG9rZW5pc2UoY29udGVudCwgaW5Db21tZW50ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xyXG5cclxuICAgIHdoaWxlIChjb250ZW50ICE9PSBFTVBUWV9TVFJJTkcpIHtcclxuICAgICAgbGV0IHRva2VuID0gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IENsYXNzZXMgPSBpbkNvbW1lbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkluQ29tbWVudENsYXNzZXMgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTm90SW5Db21tZW50Q2xhc3NlcztcclxuXHJcbiAgICAgIENsYXNzZXMuc29tZSgoQ2xhc3MpID0+IHtcclxuICAgICAgICBpZiAoQ2xhc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgIHRva2VuID0gQ2xhc3MubWF0Y2goY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHRva2VuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcclxuICAgICAgICBsZXQgc2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMucnVsZXMuc29tZSgocnVsZSkgPT4ge1xyXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IHJ1bGUubWF0Y2goY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdG9rZW4gPSBzaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjb250ZW50ICcke2NvbnRlbnR9JyBjYW5ub3QgYmUgdG9rZW5pc2VkLmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICBpbkNvbW1lbnQgPSBpbkNvbW1lbnRGcm9tVG9rZW5BbmRJbkNvbW1lbnQodG9rZW4sIGluQ29tbWVudCk7XHJcblxyXG4gICAgICBjb25zdCBuYWl2ZSA9IHRydWUsXHJcbiAgICAgICAgICAgIHRva2VuQ29udGVudExlbmd0aCA9IHRva2VuLmdldENvbnRlbnRMZW5ndGgobmFpdmUpLFxyXG4gICAgICAgICAgICBzdGFydCA9IHRva2VuQ29udGVudExlbmd0aDsgLy8vXHJcblxyXG4gICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b2tlbnM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MpIHtcclxuICAgIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXHJcbiAgICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyksXHJcbiAgICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XHJcblxyXG4gICAgcmV0dXJuIGxleGVyO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcclxuICAgIGNvbnN0IGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcclxuXHJcbiAgICByZXR1cm4gbGV4ZXI7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoQ2xhc3MsIGVudHJpZXMpIHtcclxuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tRW50cmllcyhlbnRyaWVzKSxcclxuICAgICAgICAgIGxleGVyID0gbGV4ZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcclxuXHJcbiAgICByZXR1cm4gbGV4ZXI7XHJcbiAgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRva2VuIGZyb20gXCIuLi90b2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25TaWduaWZpY2FudFRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudCA9IGZhbHNlLFxuICAgICAgICAgIG5vblNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQpO1xuXG4gICAgcmV0dXJuIG5vblNpZ25pZmljYW50VG9rZW47XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudCA9IGZhbHNlLFxuICAgICAgICAgIG5vblNpZ25pZmljYW50VG9rZW4gPSBUb2tlbi5mcm9tQ29udGVudChDbGFzcywgY29udGVudCwgc2lnbmlmaWNhbnQpO1xuXG4gICAgcmV0dXJuIG5vblNpZ25pZmljYW50VG9rZW47XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnQgPSBmYWxzZSxcbiAgICAgICAgICBub25TaWduaWZpY2FudFRva2VuID0gVG9rZW4uZnJvbUNvbnRlbnRBbmRUeXBlKENsYXNzLCBjb250ZW50LCB0eXBlLCBzaWduaWZpY2FudCk7XG5cbiAgICByZXR1cm4gbm9uU2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgd2hpdGVzcGFjZVR5cGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2hpdGVzcGFjZVRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIHN0YXRpYyB0eXBlID0gd2hpdGVzcGFjZVR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL15bXFx0XFx2IF0rLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChXaGl0ZXNwYWNlVG9rZW4sIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoV2hpdGVzcGFjZVRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgcmVndWxhckV4cHJlc3Npb25UeXBlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gZXh0ZW5kcyBTaWduaWZpY2FudFRva2VuIHtcbiAgc3RhdGljIHR5cGUgPSByZWd1bGFyRXhwcmVzc2lvblR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL15cXC8oPzpcXFxcW15cXHNdfFteXFwvXFxyXFxuXFxmXSkqXFwvLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChSZWd1bGFyRXhwcmVzc2lvblRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVUeXBlIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgYXNIVE1MKCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBodG1sID0gY29udGVudDsgLy8vXG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lVHlwZTtcblxuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXig/OlxcclxcbnxcXHJ8XFxufFxcZikvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBOb25TaWduaWZpY2FudFRva2VuLm1hdGNoKEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3RyaW5nVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgc3RyaW5nTGl0ZXJhbFR5cGUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuY29uc3QgeyBzdWJzdHJpbmcgfSA9IHN0cmluZ1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nTGl0ZXJhbFRva2VuIGV4dGVuZHMgU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGdldFN0cmluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksXG4gICAgICAgICAgY29udGVudExlbmd0aCA9IHRoaXMuZ2V0Q29udGVudExlbmd0aCgpLFxuICAgICAgICAgIHN0YXJ0ID0gMSxcbiAgICAgICAgICBlbmQgPSBjb250ZW50TGVuZ3RoIC0gMSxcbiAgICAgICAgICBzdHJpbmcgPSBzdWJzdHJpbmcoY29udGVudCwgc3RhcnQsIGVuZCk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBzdHJpbmdMaXRlcmFsVHlwZTtcblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIFNpZ25pZmljYW50VG9rZW4ubWF0Y2goQ2xhc3MsIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFRva2VuIGZyb20gXCIuLi8uLi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiBleHRlbmRzIFN0cmluZ0xpdGVyYWxUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eXCIoPzpcXFxcW15cXHNdfFteXCJcXFxcXFxyXFxuXSkqXCIvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTdHJpbmdMaXRlcmFsVG9rZW4ubWF0Y2goRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTdHJpbmdMaXRlcmFsVG9rZW4uZnJvbUNvbnRlbnQoRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5pbXBvcnQgQ29tbW9uTGV4ZXIgZnJvbSBcIi4uL2NvbW1vbi9sZXhlclwiO1xyXG5pbXBvcnQgV2hpdGVzcGFjZVRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCI7XHJcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblRva2VuIGZyb20gXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCTkZMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICB0b2tlbnNGcm9tQk5GKGJuZikge1xyXG4gICAgY29uc3QgY29udGVudCA9IGJuZiwgIC8vL1xyXG4gICAgICAgICAgdG9rZW5zID0gc3VwZXIudG9rZW5pc2UoY29udGVudCk7XHJcblxyXG4gICAgcmV0dXJuIHRva2VucztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoQk5GTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhCTkZMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhCTkZMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwiZGlnaXRcIjogXCJeXFxcXGQrXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYnJhY2tldFwiOiBcIl4oPzpcXFxcKHxcXFxcKSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJvcGVyYXRvclwiOiBcIl4oPzpcXFxcK3wtfFxcXFwqfFxcXFwvKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc11cIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0cmluZ0xpdGVyYWxUb2tlbiBmcm9tIFwiLi4vLi4vc2lnbmlmaWNhbnQvc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZXh0ZW5kcyBTdHJpbmdMaXRlcmFsVG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXicoPzpcXFxcW15cXHNdfFteJ1xcXFxcXHJcXG5dKSonLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU3RyaW5nTGl0ZXJhbFRva2VuLm1hdGNoKFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RyaW5nTGl0ZXJhbFRva2VuLmZyb21Db250ZW50KFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IHNpbmdsZUxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICBjb25zdCBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gZmFsc2U7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gc2luZ2xlTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTaW5nbGVMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eI1teXFxyXFxuXFxmXSovO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTaW5nbGVMaW5lQ29tbWVudFRva2VuLm1hdGNoKFB5dGhvblN0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2luZ2xlTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiBleHRlbmRzIE5vblNpZ25pZmljYW50VG9rZW4ge1xuICBpc0luQ29tbWVudFByZXNlcnZpbmcoKSB7XG4gICAgY29uc3QgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lQ29tbWVudFR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5mcm9tQ29udGVudChFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50XCI7XG5cbmltcG9ydCB7IGVuZE9mTXVsdGlMaW5lQ29tbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgIGNvbnN0IGluQ29tbWVudFByZXNlcnZpbmcgPSBmYWxzZTtcblxuICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBlbmRPZk11bHRpTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14jIyMvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5tYXRjaChQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgc3RhcnRPZk11bHRpTGluZUNvbW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBOb25TaWduaWZpY2FudFRva2VuIHtcbiAgaXNJbkNvbW1lbnRQcmVzZXJ2aW5nKCkge1xuICAgIGNvbnN0IGluQ29tbWVudFByZXNlcnZpbmcgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGluQ29tbWVudFByZXNlcnZpbmc7XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IHN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VHlwZTtcblxuICBzdGF0aWMgbWF0Y2goQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4ubWF0Y2goQ2xhc3MsIGNvbnRlbnQpOyB9XG5cbiAgc3RhdGljIGZyb21Db250ZW50KENsYXNzLCBjb250ZW50KSB7IHJldHVybiBOb25TaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KENsYXNzLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZXh0ZW5kcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14jIyMvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25TaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi8uLi90b2tlbi9ub25TaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTm9uU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGlzSW5Db21tZW50UHJlc2VydmluZygpIHtcbiAgICBjb25zdCBpbkNvbW1lbnRQcmVzZXJ2aW5nID0gdHJ1ZTtcblxuICAgIHJldHVybiBpbkNvbW1lbnRQcmVzZXJ2aW5nO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBtaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUeXBlO1xuXG4gIHN0YXRpYyBtYXRjaChDbGFzcywgY29udGVudCkgeyByZXR1cm4gTm9uU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChDbGFzcywgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpIHsgcmV0dXJuIE5vblNpZ25pZmljYW50VG9rZW4uZnJvbUNvbnRlbnQoQ2xhc3MsIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvbWlkZGxlT2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIHtcbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpbXlxcclxcblxcZl0rPyg/PSMjIyl8W15cXHJcXG5cXGZdKykvO1xuXG4gIHN0YXRpYyBtYXRjaChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5tYXRjaChQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5pbXBvcnQgQ29tbW9uTGV4ZXIgZnJvbSBcIi4uL2NvbW1vbi9sZXhlclwiO1xyXG5pbXBvcnQgV2hpdGVzcGFjZVRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC93aGl0ZXNwYWNlXCI7XHJcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblRva2VuIGZyb20gXCIuLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvc2luZ2x5UXVvdGVkXCI7XHJcbmltcG9ydCBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gZnJvbSBcIi4uL3Rva2VuL3NpZ25pZmljYW50L3N0cmluZ0xpdGVyYWwvZG91Ymx5UXVvdGVkXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZS9weXRob25TdHlsZVwiO1xyXG5pbXBvcnQgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gZnJvbSBcIi4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvZW5kT2ZMaW5lXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZi9weXRob25TdHlsZVwiO1xyXG5pbXBvcnQgUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL3B5dGhvblN0eWxlXCI7XHJcbmltcG9ydCBQeXRob25TdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGZyb20gXCIuLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9taWRkbGVPZi9weXRob25TdHlsZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IFJlZ3VsYXJFeHByZXNzaW9uVG9rZW47XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKEJhc2ljTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhCYXNpY0xleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEJhc2ljTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlbiBmcm9tIFwiLi4vLi4vdG9rZW4vc2lnbmlmaWNhbnRcIjtcblxuaW1wb3J0IHsgZW5kT2ZMaW5lVHlwZSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuIGV4dGVuZHMgU2lnbmlmaWNhbnRUb2tlbiB7XG4gIGFzSFRNTCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KCksXG4gICAgICAgICAgaHRtbCA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IGVuZE9mTGluZVR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBTaWduaWZpY2FudFRva2VuLmZyb21Db250ZW50KEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4sIGNvbnRlbnQpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTaWduaWZpY2FudFRva2VuIGZyb20gXCIuLi8uLi8uLi90b2tlbi9zaWduaWZpY2FudFwiO1xuXG5pbXBvcnQgeyBlbmRPZkxpbmVDb21tZW50VHlwZSB9IGZyb20gXCIuLi8uLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiBleHRlbmRzIFNpZ25pZmljYW50VG9rZW4ge1xuICBpc0luQ29tbWVudFByZXNlcnZpbmcoKSB7XG4gICAgY29uc3QgaW5Db21tZW50UHJlc2VydmluZyA9IHRydWU7XG5cbiAgICByZXR1cm4gaW5Db21tZW50UHJlc2VydmluZztcbiAgfVxuXG4gIHN0YXRpYyB0eXBlID0gZW5kT2ZMaW5lQ29tbWVudFR5cGU7XG5cbiAgc3RhdGljIHJlZ3VsYXJFeHByZXNzaW9uID0gL14oPzpcXHJcXG58XFxyfFxcbnxcXGYpLztcblxuICBzdGF0aWMgbWF0Y2goY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5tYXRjaChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2lnbmlmaWNhbnRUb2tlbi5mcm9tQ29udGVudChFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFNpbmdsZUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvc2luZ2xlTGluZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiB7XG4gIHN0YXRpYyByZWd1bGFyRXhwcmVzc2lvbiA9IC9eXFwvXFwvW15cXHJcXG5cXGZdKi87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIFNpbmdsZUxpbmVDb21tZW50VG9rZW4ubWF0Y2goQ1N0eWxlU2luZ2xlTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU2luZ2xlTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcKlxcLy87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2ZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiBleHRlbmRzIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcL1xcKi87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ubWF0Y2goQ1N0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkgeyByZXR1cm4gU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuIGV4dGVuZHMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4ge1xuICBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSAvXig/OlteXFxyXFxuXFxmXSs/KD89XFwqXFwvKXxbXlxcclxcblxcZl0rKS87XG5cbiAgc3RhdGljIG1hdGNoKGNvbnRlbnQpIHsgcmV0dXJuIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLm1hdGNoKENTdHlsZU1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuLCBjb250ZW50KTsgfVxuXG4gIHN0YXRpYyBmcm9tQ29udGVudChjb250ZW50KSB7IHJldHVybiBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbi5mcm9tQ29udGVudChDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiwgY29udGVudCk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSdWxlIH0gZnJvbSBcIi4vcnVsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0eXBlcyB9IGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIi4vc3BlY2lhbFN5bWJvbHNcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBydWxlc1V0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9ydWxlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBsZXhlclV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJORkxleGVyIH0gZnJvbSBcIi4vYm5mL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2ljTGV4ZXIgfSBmcm9tIFwiLi9iYXNpYy9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25MZXhlciB9IGZyb20gXCIuL2NvbW1vbi9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL3NpZ25pZmljYW50L2VuZE9mTGluZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvZW5kT2ZMaW5lXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vc2lnbmlmaWNhbnQvY29tbWVudC9lbmRPZkxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZMaW5lQ29tbWVudE5vblNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L2VuZE9mTGluZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFdoaXRlc3BhY2VUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L3doaXRlc3BhY2VcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL3NpbmdseVF1b3RlZFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gfSBmcm9tIFwiLi90b2tlbi9zaWduaWZpY2FudC9zdHJpbmdMaXRlcmFsL2RvdWJseVF1b3RlZFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9lbmRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvc3RhcnRPZlwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuIH0gZnJvbSBcIi4vdG9rZW4vbm9uU2lnbmlmaWNhbnQvY29tbWVudC9tdWx0aUxpbmUvZW5kT2YvY1N0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENTdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L211bHRpTGluZS9zdGFydE9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL2NTdHlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwiLi90b2tlbi9ub25TaWduaWZpY2FudC9jb21tZW50L3NpbmdsZUxpbmUvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL2VuZE9mL3B5dGhvblN0eWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL3N0YXJ0T2YvcHl0aG9uU3R5bGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCIuL3Rva2VuL25vblNpZ25pZmljYW50L2NvbW1lbnQvbXVsdGlMaW5lL21pZGRsZU9mL3B5dGhvblN0eWxlXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwibWVkaWFcIjogXCJeQG1lZGlhXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwia2V5ZnJhbWVzXCI6IFwiXkBrZXlmcmFtZXNcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJjb2xvdXJcIjogXCJeIyg/OlswLTlhLWZBLUZdezZ9fFswLTlhLWZBLUZdezN9KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImltcG9ydGFudFwiOiBcIl4haW1wb3J0YW50XCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicGVyY2VudGFnZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspJVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImZyZXF1ZW5jeVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86aHp8a2h6KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImZyYWN0aW9uXCI6IFwiXlsxLTldWzAtOV0qP2ZyXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibGVuZ3RoXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKykoPzpweHxjbXxtbXxpbnxwdHxwYylcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJhbmdsZVwiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspKD86ZGVnfHJhZHxncmFkKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInRpbWVcIjogXCJeKD86WzAtOV0rfFswLTldKlxcXFwuWzAtOV0rKSg/OnN8bXMpXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicmVtc1wiOiBcIl4oPzpbMC05XSt8WzAtOV0qXFxcXC5bMC05XSspcmVtXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiZW1zXCI6IFwiXig/OlswLTldK3xbMC05XSpcXFxcLlswLTldKyllbVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl5bMC05XSt8WzAtOV0qXFxcXC5bMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXjt8Ojp8OnxcXFxcLnwsfFxcXFx8PXx+PXw9fD58XFxcXHt8XFxcXH18XFxcXCh8XFxcXCl8XFxcXFt8XFxcXF1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJpZGVudGlmaWVyXCI6IFwiXltfYS16QS1aMC05XFxcXC1dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcImxvZ2ljYWwtb3BlcmF0b3JcIjogXCJeKD86YW5kfG5vdCkkXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwicGx1cy1vci1taW51c1wiOiBcIl5bXFxcXCtcXFxcLV1cIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsIFdoaXRlc3BhY2VUb2tlbiwgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbiwgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDsgLy8vXHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7IC8vL1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsOyAvLy9cclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW47XHJcblxyXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKENTU0xleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoQ1NTTGV4ZXIsIHJ1bGVzKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoQ1NTTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICAgIGRvY3VtZW50ICAgICAgICAgICAgICAgICA6Oj0gICggcnVsZSB8IGVycm9yICkrIDtcblxuICAgICAgcnVsZSAgICAgICAgICAgICAgICAgICAgIDo6PSAgbmFtZSBvcGFjaXR5TW9kaWZpZXI/IFwiOjo9XCIgZGVmaW5pdGlvbnMgXCI7XCIgO1xuXG4gICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBkZWZpbml0aW9ucyAgICAgICAgICAgICAgOjo9ICBkZWZpbml0aW9uICggXCJ8XCIgZGVmaW5pdGlvbiApKiA7XG5cbiAgICAgIGRlZmluaXRpb24gICAgICAgICAgICAgICA6Oj0gIHBhcnQrIHByZWNlZGVuY2U/IDtcbiBcbiAgICAgIHBhcnQgICAgICAgICAgICAgICAgICAgICA6Oj0gIG5vblRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtaW5hbFBhcnQgcXVhbnRpZmllcipcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBub25UZXJtaW5hbFBhcnQgICAgICAgICAgOjo9ICBjaG9pY2VPZlBhcnRzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNlcXVlbmNlT2ZQYXJ0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBydWxlTmFtZSBjYWxsQWhlYWRNb2RpZmllcj9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICB0ZXJtaW5hbFBhcnQgICAgICAgICAgICAgOjo9ICBzaWduaWZpY2FudFRva2VuVHlwZVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJlZ3VsYXJFeHByZXNzaW9uXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdHJpbmdMaXRlcmFsXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgZW5kT2ZMaW5lXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgd2lsZGNhcmRcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlcHNpbG9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vV2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGFydE9mQ29udGVudFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgIHNlcXVlbmNlT2ZQYXJ0cyAgICAgICAgICA6Oj0gIFwiKFwiIHBhcnQgcGFydCsgXCIpXCIgO1xuXG4gICAgICBjaG9pY2VPZlBhcnRzICAgICAgICAgICAgOjo9ICBcIihcIiBwYXJ0Q2hvaWNlICggXCJ8XCIgcGFydENob2ljZSApKyBcIilcIiA7XG5cbiAgICAgIHBhcnRDaG9pY2UgICAgICAgICAgICAgICA6Oj0gIHBhcnQgcHJlY2VkZW5jZT8gO1xuXG4gICAgICBydWxlTmFtZSAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBzaWduaWZpY2FudFRva2VuVHlwZSAgICAgOjo9ICBbdHlwZV0gO1xuXG4gICAgICByZWd1bGFyRXhwcmVzc2lvbiAgICAgICAgOjo9ICBbcmVndWxhci1leHByZXNzaW9uXSA7XG5cbiAgICAgIHN0cmluZ0xpdGVyYWwgICAgICAgICAgICA6Oj0gIFtzdHJpbmctbGl0ZXJhbF0gO1xuXG4gICAgICBwcmVjZWRlbmNlICAgICAgICAgICAgICAgOjo9ICBcIihcIiBbbnVtYmVyXT8gXCIpXCIgO1xuICAgICAgXG4gICAgICBlbmRPZkxpbmUgICAgICAgICAgICAgICAgOjo9ICBcIjxFTkRfT0ZfTElORT5cIiA7XG4gICAgICBcbiAgICAgIHdpbGRjYXJkICAgICAgICAgICAgICAgICA6Oj0gIFwiLlwiIDtcblxuICAgICAgZXBzaWxvbiAgICAgICAgICAgICAgICAgIDo6PSAgXCJcdTAzQjVcIiA7XG5cbiAgICAgIG5vV2hpdGVzcGFjZSAgICAgICAgICAgICA6Oj0gIFwiPE5PX1dISVRFU1BBQ0U+XCIgOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICBzdGFydE9mQ29udGVudCAgICAgICAgICAgOjorICBcIjxTVEFSVF9PRl9DT05URU5UPlwiOyBcbiAgICAgIFxuICAgICAgcXVhbnRpZmllciAgICAgICAgICAgICAgIDo6PSAgb3B0aW9uYWxRdWFudGlmaWVyXG4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvbmVPck1vcmVRdWFudGlmaWVyXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgemVyb09yTW9yZVF1YW50aWZpZXJcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgIG9wYWNpdHlNb2RpZmllciAgICAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPiggXCIuXCIgfCBcIi4uXCIgKTtcbiAgICAgIFxuICAgICAgY2FsbEFoZWFkTW9kaWZpZXIgICAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIuLi5cIiA7XG5cbiAgICAgIG9wdGlvbmFsUXVhbnRpZmllciAgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiP1wiIDtcblxuICAgICAgb25lT3JNb3JlUXVhbnRpZmllciAgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIrXCIgO1xuXG4gICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllciAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIipcIiA7XG5cbiAgICAgIGVycm9yLiAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRURfQkFDS1NMQVNIID1cIlxcXFxcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0RPVUJMRV9RVU9URSA9IFwiXFxcIlwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFkZGluZ0Zyb21QYWRkaW5nTGVuZ3RoKHBhZGRpbmdMZW5ndGgpIHtcbiAgbGV0IHBhZGRpbmcgPSBFTVBUWV9TVFJJTkc7XG5cbiAgZm9yIChsZXQgcG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IHBhZGRpbmdMZW5ndGg7IHBvc2l0aW9uKyspIHtcbiAgICBwYWRkaW5nICs9IFNQQUNFX0NIQVJBQ1RFUjtcbiAgfVxuXG4gIHJldHVybiBwYWRkaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcbmltcG9ydCB7IHBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aCB9IGZyb20gXCIuL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuY29uc3QgeyBjbGVhciB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IG9wYXF1ZTogb3BhcXVlU3BlY2lhbFN5bWJvbCwgc2VtaU9wYXF1ZTogc2VtaU9wYXF1ZVNwZWNpYWxTeW1ib2wgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZ2V0RGVmaW5pdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbnM7XG4gIH1cblxuICBzZXROYW1lKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgfVxuXG4gIHNldERlZmluaXRpb25zKGRlZmluaXRpb25zKSB7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICB9XG5cbiAgaXNPcGFxdWUoKSB7XG4gICAgY29uc3Qgb3BhcXVlID0gKHRoaXMub3BhY2l0eSA9PT0gb3BhcXVlU3BlY2lhbFN5bWJvbCk7XG5cbiAgICByZXR1cm4gb3BhcXVlO1xuICB9XG5cbiAgaXNTZW1pT3BhcXVlKCkge1xuICAgIGNvbnN0IHNlbWlPcGFxdWUgPSAodGhpcy5vcGFjaXR5ID09PSBzZW1pT3BhcXVlU3BlY2lhbFN5bWJvbCk7XG5cbiAgICByZXR1cm4gc2VtaU9wYXF1ZTtcbiAgfVxuXG4gIGlzVHJhbnNwYXJlbnQoKSB7XG4gICAgY29uc3Qgc2VtaU9wYXF1ZSA9ICh0aGlzLm9wYWNpdHkgPT09IG51bGwpO1xuXG4gICAgcmV0dXJuIHNlbWlPcGFxdWU7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRoaXMubmFtZSwgLy8vXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IFtdLFxuICAgICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHRoaXMuTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lLCBzdGF0ZSksXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSksXG4gICAgICAgICAgc2F2ZWRQcmVjZWRlbmNlID0gc3RhdGUuZ2V0U2F2ZWRQcmVjZWRlbmNlKCk7XG5cbiAgICBsZXQgbm9kZSA9IG5vblRlcm1pbmFsTm9kZTsgLy8vXG5cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuXG4gICAgcGFyc2VkID0gdGhpcy5kZWZpbml0aW9ucy5zb21lKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICBjbGVhcihjaGlsZE5vZGVzKTtcblxuICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IGRlZmluaXRpb24uZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgICBzdGF0ZS5zZXRQcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuXG4gICAgICBjYWxsYmFjayA9ICgpID0+IHsgIC8vL1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5nZXRQcmVjZWRlbmNlKCk7XG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG5cbiAgICAgICAgcGFyc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgbm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmV3cml0dGVuTm9uVGVybWluYWxOb2RlID0gbm9uVGVybWluYWxOb2RlLnJld3JpdGUoc3RhdGUpO1xuXG4gICAgICAgIGlmIChyZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcblxuICAgICAgICAgICAgbm9kZSA9IHJld3JpdHRlbk5vblRlcm1pbmFsTm9kZTsgLy8vXG5cbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIGNvbnN0IGVtcHR5ID0gbm9kZS5pc0VtcHR5KCk7XG5cbiAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICBjb25zdCB1bnByZWNlZGVudGVkID0gbm9kZS5pc1VucHJlY2VkZW50ZWQoKTtcblxuICAgICAgICAgIGlmICh1bnByZWNlZGVudGVkKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgaWYgKGNhbGxBaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSk7XG5cbiAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuXG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgbm9kZS5yZXNldENoaWxkTm9kZXNQYXJlbnROb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfTtcblxuICAgICAgcGFyc2VkID0gZGVmaW5pdGlvbi5wYXJzZShjaGlsZE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgIHN0YXRlLnJlc2V0UHJlY2VkZW5jZShzYXZlZFByZWNlZGVuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIG5vZGVzLnBvcCgpO1xuICAgIH1cblxuICAgIGlmIChjYWxsQWhlYWQgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLnJlc2V0UHJlY2VkZW5jZShzYXZlZFByZWNlZGVuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5Ob25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUpOyB9XG5cbiAgYXNTdHJpbmcobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBtdWx0aUxpbmUgPSB0cnVlKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbnNMZW5ndGggPSB0aGlzLmRlZmluaXRpb25zLmxlbmd0aDtcblxuICAgIG11bHRpTGluZSA9IG11bHRpTGluZSAmJiAoZGVmaW5pdGlvbnNMZW5ndGggPiAxKTsgIC8vL1xuXG4gICAgY29uc3QgbWF4aW11bVBhZGRpbmcgPSBwYWRkaW5nRnJvbVBhZGRpbmdMZW5ndGgobWF4aW11bVJ1bGVOYW1lTGVuZ3RoKSxcbiAgICAgICAgICBkZWZpbml0aW9uc1N0cmluZyA9IHRoaXMuZGVmaW5pdGlvbnMucmVkdWNlKChkZWZpbml0aW9uc1N0cmluZywgZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKGRlZmluaXRpb25zU3RyaW5nID09PSBFTVBUWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbnNTdHJpbmcgPSBkZWZpbml0aW9uU3RyaW5nOyAvLy9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZmluaXRpb25zU3RyaW5nID0gbXVsdGlMaW5lID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZGVmaW5pdGlvbnNTdHJpbmd9XG5cbiR7bWF4aW11bVBhZGRpbmd9ICAgfCAke2RlZmluaXRpb25TdHJpbmd9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZGVmaW5pdGlvbnNTdHJpbmd9IHwgJHtkZWZpbml0aW9uU3RyaW5nfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uc1N0cmluZztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5uYW1lLCAvLy9cbiAgICAgICAgICBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aCxcbiAgICAgICAgICBvcGFjaXR5U3RyaW5nID0gKHRoaXMub3BhY2l0eSA9PT0gbnVsbCk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSwgLy8vXG4gICAgICAgICAgb3BhY2l0eVN0cmluZ0xlbmd0aCA9IG9wYWNpdHlTdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmdMZW5ndGggPSBtYXhpbXVtUnVsZU5hbWVMZW5ndGggLSBydWxlTmFtZUxlbmd0aCAtIG9wYWNpdHlTdHJpbmdMZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IHBhZGRpbmdGcm9tUGFkZGluZ0xlbmd0aChwYWRkaW5nTGVuZ3RoKTtcblxuICAgIGNvbnN0IHNlbWljb2xvblN0cmluZyA9IG11bHRpTGluZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcblxuJHttYXhpbXVtUGFkZGluZ30gICA7YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgO1wiLFxuICAgICAgICAgIHN0cmluZyA9IGBcblxuJHt0aGlzLm5hbWV9JHtvcGFjaXR5U3RyaW5nfSR7cGFkZGluZ30gOjo9ICR7ZGVmaW5pdGlvbnNTdHJpbmd9JHtzZW1pY29sb25TdHJpbmd9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWVPcGFjaXR5QW5kRGVmaW5pdGlvbnMoQ2xhc3MsIG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKSB7XG4gICAgaWYgKGRlZmluaXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZmluaXRpb25zID0gb3BhY2l0eTsgIC8vL1xuXG4gICAgICBvcGFjaXR5ID0gbmFtZTsgLy8vXG5cbiAgICAgIG5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gUnVsZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcnVsZSA9IG5ldyBDbGFzcyhuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBwdXNoLCBmaXJzdCwgZm9yd2FyZHNTb21lLCBiYWNrd2FyZHNTb21lIH0gPSBhcnJheVV0aWxpdGllcztcblxuZnVuY3Rpb24gZ2V0TXVsdGlwbGljaXR5KCkge1xuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgbXVsdGlwbGljaXR5ID0gY2hpbGROb2Rlc0xlbmd0aDsgIC8vL1xuXG4gIHJldHVybiBtdWx0aXBsaWNpdHk7XG59XG5cbmZ1bmN0aW9uIG1hcENoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcChjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gc29tZUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLnNvbWUoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maW5kKGNhbGxiYWNrKTsgfVxuXG5mdW5jdGlvbiBldmVyeUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLmV2ZXJ5KGNhbGxiYWNrKTsgfVxuXG5mdW5jdGlvbiBmaWx0ZXJDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5maWx0ZXIoY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIHJlZHVjZUNoaWxkTm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXMucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZE5vZGUoY2FsbGJhY2spIHsgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGZvcndhcmRzU29tZUNoaWxkTm9kZShjYWxsYmFjaykgeyByZXR1cm4gZm9yd2FyZHNTb21lKHRoaXMuY2hpbGROb2RlcywgY2FsbGJhY2spOyB9XG5cbmZ1bmN0aW9uIGJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoY2FsbGJhY2spIHsgcmV0dXJuIGJhY2t3YXJkc1NvbWUodGhpcy5jaGlsZE5vZGVzLCBjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gaW5kZXhPZkNoaWxkTm9kZShjaGlsZE5vZGUpIHsgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkTm9kZSk7IH1cblxuZnVuY3Rpb24gc2V0Q2hpbGROb2Rlc1BhcmVudE5vZGUoY2hpbGROb2Rlcykge1xuICBpZiAoY2hpbGROb2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2hpbGROb2RlcyA9IFtcbiAgICAgIC4uLnRoaXMuY2hpbGROb2Rlc1xuICAgIF07XG4gIH1cblxuICBjb25zdCBwYXJlbnROb2RlID0gdGhpcztcblxuICBjaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNoaWxkTm9kZS5zZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZShjaGlsZE5vZGVzKSB7XG4gIGlmIChjaGlsZE5vZGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZE5vZGVzID0gW1xuICAgICAgLi4udGhpcy5jaGlsZE5vZGVzXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgY2hpbGROb2RlLnNldFBhcmVudE5vZGUocGFyZW50Tm9kZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZE5vZGUoYWRkZWRDaGlsZE5vZGUsIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgYWRkZWRDaGlsZE5vZGVzID0gW1xuICAgIGFkZGVkQ2hpbGROb2RlXG4gIF07XG5cbiAgdGhpcy5hZGRDaGlsZE5vZGVzKGFkZGVkQ2hpbGROb2Rlcywgc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkTm9kZXMoYWRkZWRDaGlsZE5vZGVzLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IGRlbGV0ZUNvdW50ID0gMDtcblxuICB0aGlzLnNwbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIGFkZGVkQ2hpbGROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkTm9kZShyZW1vdmVkQ2hpbGROb2RlKSB7XG4gIGxldCByZW1vdmVkQ2hpbGROb2RlcztcblxuICByZW1vdmVkQ2hpbGROb2RlcyA9IFtcbiAgICByZW1vdmVkQ2hpbGROb2RlXG4gIF07XG5cbiAgcmVtb3ZlZENoaWxkTm9kZXMgPSB0aGlzLnJlbW92ZUNoaWxkTm9kZXMocmVtb3ZlZENoaWxkTm9kZXMpO1xuXG4gIHJldHVybiByZW1vdmVkQ2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGROb2RlcyhyZW1vdmVkQ2hpbGROb2Rlcykge1xuICBpZiAocmVtb3ZlZENoaWxkTm9kZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlbW92ZWRDaGlsZE5vZGVzID0gW1xuICAgICAgLi4udGhpcy5jaGlsZE5vZGVzXG4gICAgXTtcbiAgfVxuXG4gIGNvbnN0IHJlbW92ZWRDaGlsZE5vZGVzTGVuZ3RoID0gcmVtb3ZlZENoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGlmIChyZW1vdmVkQ2hpbGROb2Rlc0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdFJlcGxhY2VkQ2hpbGROb2RlID0gZmlyc3QocmVtb3ZlZENoaWxkTm9kZXMpLFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihmaXJzdFJlcGxhY2VkQ2hpbGROb2RlKSwgLy8vXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSByZW1vdmVkQ2hpbGROb2Rlc0xlbmd0aCwgLy8vXG4gICAgICAgICAgYWRkZWRDaGlsZE5vZGVzID0gW107XG5cbiAgICByZW1vdmVkQ2hpbGROb2RlcyA9IHRoaXMuc3BsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBkZWxldGVDb3VudCwgYWRkZWRDaGlsZE5vZGVzKTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkQ2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkTm9kZShyZXBsYWNlZENoaWxkTm9kZSwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKSB7XG4gIGNvbnN0IHJlcGxhY2VkQ2hpbGROb2RlcyA9IFtcbiAgICByZXBsYWNlZENoaWxkTm9kZVxuICBdO1xuXG4gIHRoaXMucmVwbGFjZUNoaWxkTm9kZXMocmVwbGFjZWRDaGlsZE5vZGVzLCByZXBsYWNlbWVudENoaWxkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGROb2RlcyhyZXBsYWNlZENoaWxkTm9kZXMsIHJlcGxhY2VtZW50Q2hpbGROb2Rlcykge1xuICBjb25zdCByZXBsYWNlZENoaWxkTm9kZXNMZW5ndGggPSByZXBsYWNlZENoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICBmaXJzdFJlcGxhY2VkQ2hpbGROb2RlID0gZmlyc3QocmVwbGFjZWRDaGlsZE5vZGVzKSxcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGZpcnN0UmVwbGFjZWRDaGlsZE5vZGUpLCAvLy9cbiAgICAgICAgZGVsZXRlQ291bnQgPSByZXBsYWNlZENoaWxkTm9kZXNMZW5ndGg7IC8vL1xuXG4gIHRoaXMuc3BsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBkZWxldGVDb3VudCwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGROb2RlKGFwcGVuZGVkQ2hpbGROb2RlKSB7XG4gIGNvbnN0IGFwcGVuZGVkQ2hpbGROb2RlcyA9IFtcbiAgICBhcHBlbmRlZENoaWxkTm9kZVxuICBdO1xuXG4gIHRoaXMuYXBwZW5kQ2hpbGROb2RlcyhhcHBlbmRlZENoaWxkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZE5vZGVzKGFwcGVuZGVkQ2hpbGROb2Rlcykge1xuICBjb25zdCBhZGRlZENoaWxkTm9kZXMgPSBhcHBlbmRlZENoaWxkTm9kZXMsIC8vL1xuICAgICAgICBtdWx0aXBsaWNpdHkgPSB0aGlzLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICBzdGFydEluZGV4ID0gbXVsdGlwbGljaXR5OyAgLy8vXG5cbiAgdGhpcy5hZGRDaGlsZE5vZGVzKGFkZGVkQ2hpbGROb2Rlcywgc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRDaGlsZE5vZGUocHJlcGVuZGVkQ2hpbGROb2RlKSB7XG4gIGNvbnN0IHByZXBlbmRlZENoaWxkTm9kZXMgPSBbXG4gICAgcHJlcGVuZGVkQ2hpbGROb2RlXG4gIF07XG5cbiAgdGhpcy5wcmVwZW5kQ2hpbGROb2RlcyhwcmVwZW5kZWRDaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZENoaWxkTm9kZXMocHJlcGVuZGVkQ2hpbGROb2Rlcykge1xuICBjb25zdCBhZGRlZENoaWxkTm9kZXMgPSBwcmVwZW5kZWRDaGlsZE5vZGVzLCAgLy8vXG4gICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuXG4gIHRoaXMuYWRkQ2hpbGROb2RlcyhhZGRlZENoaWxkTm9kZXMsIHN0YXJ0SW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzcGxpY2VDaGlsZE5vZGVzKHN0YXJ0SW5kZXgsIGRlbGV0ZUNvdW50LCBhZGRlZENoaWxkTm9kZXMgPSBbXSkge1xuICBjb25zdCByZW1vdmVkQ2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2Rlcy5zcGxpY2Uoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIC4uLmFkZGVkQ2hpbGROb2Rlcyk7XG5cbiAgdGhpcy5yZXNldENoaWxkTm9kZXNQYXJlbnROb2RlKHJlbW92ZWRDaGlsZE5vZGVzKTtcblxuICB0aGlzLnNldENoaWxkTm9kZXNQYXJlbnROb2RlKGFkZGVkQ2hpbGROb2Rlcyk7XG5cbiAgcmV0dXJuIHJlbW92ZWRDaGlsZE5vZGVzO1xufVxuXG5mdW5jdGlvbiBzbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZW5kSW5kZXggPSBJbmZpbml0eSkge1xuICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcblxuICByZXR1cm4gY2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JOb2RlcygpIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IFtdO1xuXG4gIGxldCBhbmNlc3Rvck5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vL1xuXG4gIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICBhbmNlc3Rvck5vZGVzLnB1c2goYW5jZXN0b3JOb2RlKTtcblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIGFuY2VzdG9yTm9kZXM7XG59XG5cbmZ1bmN0aW9uIG1hcEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgcmV0dXJuIGFuY2VzdG9yTm9kZXMubWFwKGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gc29tZUFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgbGV0IGluZGV4ID0gMCxcbiAgICAgIGFuY2VzdG9yTm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8vXG5cbiAgd2hpbGUgKGFuY2VzdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7IC8vL1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yTm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBhbmNlc3Rvck5vZGUgPSBwYXJlbnROb2RlOyAgLy8vXG5cbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgaW5kZXggPSAwLFxuICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3JOb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIGFuY2VzdG9yTm9kZSA9IHVuZGVmaW5lZDtcblxuICByZXR1cm4gYW5jZXN0b3JOb2RlO1xufVxuXG5mdW5jdGlvbiBldmVyeUFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBsZXQgaW5kZXggPSAwLFxuICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gISFjYWxsYmFjayhhbmNlc3Rvck5vZGUsIGluZGV4KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGFuY2VzdG9yTm9kZSA9IHBhcmVudE5vZGU7ICAvLy9cblxuICAgIGluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gIHJldHVybiBhbmNlc3Rvck5vZGVzLmZpbHRlcihjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUFuY2VzdG9yTm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGFuY2VzdG9yTm9kZXMgPSB0aGlzLmdldEFuY2VzdG9yTm9kZXMoKTtcblxuICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gIGFuY2VzdG9yTm9kZXMuZm9yRWFjaChjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldERlc2NlbmRhbnROb2RlcyhkZXNjZW5kYW50Tm9kZXMgPSBbXSkge1xuICBwdXNoKGRlc2NlbmRhbnROb2RlcywgdGhpcy5jaGlsZE5vZGVzKTtcblxuICB0aGlzLmZvckVhY2hDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNoaWxkTm9kZS5nZXREZXNjZW5kYW50Tm9kZXMoZGVzY2VuZGFudE5vZGVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcztcbn1cblxuZnVuY3Rpb24gbWFwRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgY29uc3QgZGVzY2VuZGFudE5vZGVzID0gdGhpcy5nZXREZXNjZW5kYW50Tm9kZXMoKTtcblxuICByZXR1cm4gZGVzY2VuZGFudE5vZGVzLm1hcChjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHNvbWVEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNoaWxkTm9kZXNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgIGRlc2NlbmRhbnROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soZGVzY2VuZGFudE5vZGUpO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hpbGROb2RlLnNvbWVEZXNjZW5kYW50Tm9kZShjYWxsYmFjayk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgbGV0IGRlc2NlbmRhbnROb2RlID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjaGlsZE5vZGVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpbmRleF07XG5cbiAgICBkZXNjZW5kYW50Tm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICByZXN1bHQgPSBjYWxsYmFjayhkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXNjZW5kYW50Tm9kZSA9IGNoaWxkTm9kZS5maW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXNjZW5kYW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXZlcnlEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcblxuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2hpbGROb2Rlc0xlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgcmVzdWx0ID0gISFjYWxsYmFjayhkZXNjZW5kYW50Tm9kZSk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hpbGROb2RlLmV2ZXJ5RGVzY2VuZGFudE5vZGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckRlc2NlbmRhbnROb2RlKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGRlc2NlbmRhbnROb2RlcyA9IHRoaXMuZ2V0RGVzY2VuZGFudE5vZGVzKCk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEZXNjZW5kYW50Tm9kZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGRlc2NlbmRhbnROb2RlcyA9IHRoaXMuZ2V0RGVzY2VuZGFudE5vZGVzKCk7XG5cbiAgcmV0dXJuIGRlc2NlbmRhbnROb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hEZXNjZW5kYW50Tm9kZShjYWxsYmFjaykge1xuICBjb25zdCBkZXNjZW5kYW50Tm9kZXMgPSB0aGlzLmdldERlc2NlbmRhbnROb2RlcygpO1xuXG4gIGRlc2NlbmRhbnROb2Rlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbn1cblxuY29uc3Qgbm9kZU1peGlucyA9IHtcbiAgZ2V0TXVsdGlwbGljaXR5LFxuICBtYXBDaGlsZE5vZGUsXG4gIHNvbWVDaGlsZE5vZGUsXG4gIGZpbmRDaGlsZE5vZGUsXG4gIGV2ZXJ5Q2hpbGROb2RlLFxuICBmaWx0ZXJDaGlsZE5vZGUsXG4gIHJlZHVjZUNoaWxkTm9kZSxcbiAgZm9yRWFjaENoaWxkTm9kZSxcbiAgZm9yd2FyZHNTb21lQ2hpbGROb2RlLFxuICBiYWNrd2FyZHNTb21lQ2hpbGROb2RlLFxuICBpbmRleE9mQ2hpbGROb2RlLFxuICBzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSxcbiAgcmVzZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSxcbiAgYWRkQ2hpbGROb2RlLFxuICBhZGRDaGlsZE5vZGVzLFxuICByZW1vdmVDaGlsZE5vZGUsXG4gIHJlbW92ZUNoaWxkTm9kZXMsXG4gIHJlcGxhY2VDaGlsZE5vZGUsXG4gIHJlcGxhY2VDaGlsZE5vZGVzLFxuICBhcHBlbmRDaGlsZE5vZGUsXG4gIGFwcGVuZENoaWxkTm9kZXMsXG4gIHByZXBlbmRDaGlsZE5vZGUsXG4gIHByZXBlbmRDaGlsZE5vZGVzLFxuICBzcGxpY2VDaGlsZE5vZGVzLFxuICBzbGljZUNoaWxkTm9kZXMsXG4gIGdldEFuY2VzdG9yTm9kZXMsXG4gIG1hcEFuY2VzdG9yTm9kZSxcbiAgc29tZUFuY2VzdG9yTm9kZSxcbiAgZmluZEFuY2VzdG9yTm9kZSxcbiAgZXZlcnlBbmNlc3Rvck5vZGUsXG4gIGZpbHRlckFuY2VzdG9yTm9kZSxcbiAgcmVkdWNlQW5jZXN0b3JOb2RlLFxuICBmb3JFYWNoQW5jZXN0b3JOb2RlLFxuICBnZXREZXNjZW5kYW50Tm9kZXMsXG4gIG1hcERlc2NlbmRhbnROb2RlLFxuICBzb21lRGVzY2VuZGFudE5vZGUsXG4gIGZpbmREZXNjZW5kYW50Tm9kZSxcbiAgZXZlcnlEZXNjZW5kYW50Tm9kZSxcbiAgZmlsdGVyRGVzY2VuZGFudE5vZGUsXG4gIHJlZHVjZURlc2NlbmRhbnROb2RlLFxuICBmb3JFYWNoRGVzY2VuZGFudE5vZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMsIGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBsYXN0IH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgTkVXX0xJTkVfQ0hBUkFDVEVSLCBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnNlVHJlZSB7XG4gIGNvbnN0cnVjdG9yKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKCksICAvLy9cbiAgICAgICAgICBwYXJzZVRyZWUgPSBuZXcgUGFyc2VUcmVlKGxpbmVzKTtcblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBnZXRXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGg7XG5cbiAgICBsZXQgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aDtcblxuICAgIGlmIChsaW5lc0xlbmd0aCA9PT0gMCkge1xuICAgICAgd2lkdGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0TGluZSA9IGxhc3QodGhpcy5saW5lcyksXG4gICAgICAgICAgICBsYXN0TGluZUxlbmd0aCA9IGxhc3RMaW5lLmxlbmd0aDtcblxuICAgICAgd2lkdGggPSBsYXN0TGluZUxlbmd0aDsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0RGVwdGgoKSB7XG4gICAgY29uc3QgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aCxcbiAgICAgICAgICBkZXB0aCA9IGxpbmVzTGVuZ3RoOyAgLy8vXG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBmb3JFYWNoTGluZShjYWxsYmFjaykge1xuICAgIHRoaXMubGluZXMuZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cblxuICBhcHBlbmRUb1RvcChwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUpID0+IHtcbiAgICAgIHRoaXMubGluZXMudW5zaGlmdChsaW5lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZFRvTGVmdChwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLmxpbmVzW2luZGV4XSA9IGxpbmUgKyB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZFRvUmlnaHQocGFyc2VUcmVlKSB7XG4gICAgcGFyc2VUcmVlLmZvckVhY2hMaW5lKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIGxpbmU7XG4gICAgfSk7XG4gIH1cblxuICBhcHBlbmRUb0JvdHRvbShwYXJzZVRyZWUpIHtcbiAgICBwYXJzZVRyZWUuZm9yRWFjaExpbmUoKGxpbmUpID0+IHtcbiAgICAgIHRoaXMubGluZXMucHVzaChsaW5lKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZFRvcE1hcmdpbih0b3BNYXJnaW5EZXB0aCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIHRvcE1hcmdpbldpZHRoID0gd2lkdGgsICAvLy9cbiAgICAgICAgICB0b3BNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgodG9wTWFyZ2luV2lkdGgpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRvcE1hcmdpbkRlcHRoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzLnVuc2hpZnQodG9wTWFyZ2luU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBhZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCkge1xuICAgIGNvbnN0IGxlZnRNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgobGVmdE1hcmdpbldpZHRoKSxcbiAgICAgICAgICBsaW5lc0xlbmd0aCA9IHRoaXMubGluZXMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpbmVzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzW2luZGV4XSA9IGxlZnRNYXJnaW5TdHJpbmcgKyB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICB9XG4gIH1cblxuICBhZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKSB7XG4gICAgY29uc3QgcmlnaHRNYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgocmlnaHRNYXJnaW5XaWR0aCksXG4gICAgICAgICAgbGluZXNMZW5ndGggPSB0aGlzLmxpbmVzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsaW5lc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGhpcy5saW5lc1tpbmRleF0gPSB0aGlzLmxpbmVzW2luZGV4XSArIHJpZ2h0TWFyZ2luU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGFkZEJvdHRvbU1hcmdpbihib3R0b21NYXJnaW5EZXB0aCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIGJvdHRvbU1hcmdpbldpZHRoID0gd2lkdGgsICAvLy9cbiAgICAgICAgICBib3R0b21NYXJnaW5TdHJpbmcgPSBtYXJnaW5TdHJpbmdGcm9tTWFyZ2luV2lkdGgoYm90dG9tTWFyZ2luV2lkdGgpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGJvdHRvbU1hcmdpbkRlcHRoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmxpbmVzLnB1c2goYm90dG9tTWFyZ2luU3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgXG4gIHBvcExpbmUoKSB7IHJldHVybiB0aGlzLmxpbmVzLnBvcCgpOyB9XG4gIFxuICBzaGlmdExpbmUoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNoaWZ0KCk7IH1cbiAgXG4gIHB1c2hMaW5lKGxpbmUpIHsgdGhpcy5saW5lcy5wdXNoKGxpbmUpOyB9XG4gIFxuICB1bnNoaWZ0TGluZShsaW5lKSB7IHRoaXMubGluZXMudW5zaGlmdChsaW5lKTsgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMubGluZXMucmVkdWNlKChzdHJpbmcsIGxpbmUpID0+IHtcbiAgICAgIHN0cmluZyArPSBsaW5lICsgTkVXX0xJTkVfQ0hBUkFDVEVSO1xuXG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmdpblN0cmluZ0Zyb21NYXJnaW5XaWR0aChtYXJnaW5XaWR0aCwgc3BhY2VDaGFyYWN0ZXIpIHtcbiAgc3BhY2VDaGFyYWN0ZXIgPSBzcGFjZUNoYXJhY3RlciB8fCBTUEFDRV9DSEFSQUNURVI7XG5cbiAgbGV0IG1hcmdpblN0cmluZyA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWFyZ2luV2lkdGg7IGluZGV4KyspIHtcbiAgICBtYXJnaW5TdHJpbmcgKz0gc3BhY2VDaGFyYWN0ZXI7XG4gIH1cblxuICByZXR1cm4gbWFyZ2luU3RyaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUGFyc2VUcmVlIGZyb20gXCIuLi9wYXJzZVRyZWVcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IEJBUl9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGV4dGVuZHMgUGFyc2VUcmVlIHtcbiAgY29uc3RydWN0b3IobGluZXMsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICBzdXBlcihsaW5lcyk7XG4gICAgXG4gICAgdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgfVxuICBcbiAgZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICB9XG5cbiAgYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpIHtcbiAgICBzdXBlci5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG5cbiAgICB0aGlzLnZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gbGVmdE1hcmdpbldpZHRoOyAvLy9cbiAgfVxuXG4gIHN0YXRpYyBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBCQVJfQ0hBUkFDVEVSLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSAwLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oVmVydGljYWxCcmFuY2hQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbiksXG4gICAgICAgICAgbGVmdE1hcmdpbldpZHRoID0gTWF0aC5mbG9vcih3aWR0aC8yKSxcbiAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGggLSAxO1xuXG4gICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuXG4gICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICB9XG5cbiAgc3RhdGljIGZyb21EZXB0aEFuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oQ2xhc3MsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGluZXMgPSBsaW5lc0Zyb21EZXB0aChkZXB0aCksXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBuZXcgQ2xhc3MobGluZXMsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlO1xuICB9XG5cbiAgc3RhdGljIGZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENsYXNzLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pIHtcbiAgICBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gc3RyaW5nOyAgLy8vXG5cbiAgICAgIHN0cmluZyA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJzZVRyZWU7ICAvLy9cbiAgICB9XG4gICAgXG4gICAgY29uc3QgbGluZSA9IHN0cmluZywgLy8vXG4gICAgICAgICAgbGluZXMgPSBbXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgXSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IG5ldyBDbGFzcyhsaW5lcywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gdmVydGljYWxCcmFuY2hQYXJzZVRyZWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluZXNGcm9tRGVwdGgoZGVwdGgpIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcblxuICBsZXQgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IGRlcHRoKSB7XG4gICAgbGluZXNbaW5kZXgrK10gPSBFTVBUWV9TVFJJTkc7XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2Vucyh0b2tlbkluZGV4LCB0b2tlbnMpIHtcbiAgbGV0IGxpbmVJbmRleCA9IG51bGw7XG5cbiAgaWYgKHRva2VuSW5kZXggIT09IG51bGwpIHtcbiAgICBsaW5lSW5kZXggPSAwO1xuXG4gICAgY29uc3Qgc3RhcnQgPSAwLFxuICAgICAgICAgIGVuZCA9IHRva2VuSW5kZXg7XG5cbiAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgY29uc3QgdG9rZW5FbmRPZkxpbmVUb2tlbiA9IHRva2VuLmlzRW5kT2ZMaW5lVG9rZW4oKTtcblxuICAgICAgaWYgKHRva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgbGluZUluZGV4Kys7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGluZUluZGV4O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdG9rZW5zXCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZVBhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21Ob25UZXJtaW5hbE5vZGVBbmRUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIG9wYWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgZmlyc3RMaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyhmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgdG9rZW5zKSxcbiAgICAgICAgICBsYXN0TGluZUluZGV4ID0gbGluZUluZGV4RnJvbVRva2VuSW5kZXhBbmRUb2tlbnMobGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCwgdG9rZW5zKTtcblxuICAgIGxldCBsaW5lSW5kZXhlcztcblxuICAgIGlmIChmaXJzdExpbmVJbmRleCA9PT0gbGFzdExpbmVJbmRleCkge1xuICAgICAgY29uc3QgbGluZUluZGV4ID0gZmlyc3RMaW5lSW5kZXg7IC8vL1xuXG4gICAgICBpZiAobGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIGxpbmVJbmRleGVzID0gRU1QVFlfU1RSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZUluZGV4ZXMgPSBgIFske2xpbmVJbmRleH1dYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vL1xuICAgICAgfSBlbHNlIGlmIChmaXJzdExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7bGFzdExpbmVJbmRleH1dYDtcbiAgICAgIH0gZWxzZSBpZiAobGFzdExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7Zmlyc3RMaW5lSW5kZXh9XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lSW5kZXhlcyA9IGAgWyR7Zmlyc3RMaW5lSW5kZXh9LSR7bGFzdExpbmVJbmRleH1dYFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdHJpbmcgPSBgJHtydWxlTmFtZX1gO1xuXG4gICAgaWYgKG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgIHN0cmluZyA9IGAke3N0cmluZ30ke29wYWNpdHl9YDtcbiAgICB9XG5cbiAgICBzdHJpbmcgPSBgJHtzdHJpbmd9JHtsaW5lSW5kZXhlc31gO1xuXG4gICAgbGV0IHByZWNlZGVuY2UgPSBub25UZXJtaW5hbE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgaWYgKHByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmVjZWRlbmNlID09PSBJbmZpbml0eSkge1xuICAgICAgICBwcmVjZWRlbmNlID0gU1BBQ0VfQ0hBUkFDVEVSO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBgJHtzdHJpbmd9ICgke3ByZWNlZGVuY2V9KWA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oUnVsZU5hbWVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICBydWxlTmFtZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJzZVRyZWU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFBhcnNlVHJlZSBmcm9tIFwiLi4vcGFyc2VUcmVlXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBEQVNIX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSBleHRlbmRzIFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tV2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdGcm9tQ2hhcmFjdGVyc1dpZHRoKHdpZHRoLCBEQVNIX0NIQVJBQ1RFUiksXG4gICAgICAgICAgbGluZSA9IHN0cmluZywgLy8vXG4gICAgICAgICAgbGluZXMgPSBbXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgXSxcbiAgICAgICAgICBob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlID0gbmV3IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUobGluZXMpO1xuXG4gICAgcmV0dXJuIGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nRnJvbUNoYXJhY3RlcnNXaWR0aChjaGFyYWN0ZXJzV2lkdGgsIGNoYXJhY3Rlcikge1xuICBsZXQgc3RyaW5nID0gRU1QVFlfU1RSSU5HO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjaGFyYWN0ZXJzV2lkdGg7IGluZGV4KyspIHtcbiAgICBzdHJpbmcgKz0gY2hhcmFjdGVyO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuaW1wb3J0IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUgZnJvbSBcIi4vaG9yaXpvbnRhbEJyYW5jaFwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hpbGROb2Rlc1BhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21DaGlsZE5vZGVzQW5kVG9rZW5zKGNoaWxkTm9kZXMsIHRva2Vucykge1xuICAgIGxldCBjaGlsZE5vZGVzUGFyc2VUcmVlID0gbnVsbDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChjaGlsZE5vZGVzTGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlcyA9IGNoaWxkTm9kZXMucmVkdWNlKChjaGlsZE5vZGVQYXJzZVRyZWVzLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlID0gY2hpbGROb2RlLmFzUGFyc2VUcmVlKHRva2Vucyk7XG5cbiAgICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlcy5wdXNoKGNoaWxkTm9kZVBhcnNlVHJlZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVBhcnNlVHJlZXM7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID0gY2hpbGROb2RlUGFyc2VUcmVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlID0gZmlyc3QoY2hpbGROb2RlUGFyc2VUcmVlcyk7XG5cbiAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlOyAgLy8vXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uLFxuICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSAwLFxuICAgICAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoID0gMCxcbiAgICAgICAgICAgIGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCA9IDA7XG5cbiAgICAgICAgY2hpbGROb2RlUGFyc2VUcmVlcy5mb3JFYWNoKChjaGlsZE5vZGVQYXJzZVRyZWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlUGFyc2VUcmVlV2lkdGggPSBjaGlsZE5vZGVQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZVBhcnNlVHJlZSxcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGZpcnN0Q2hpbGROb2RlUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gZmlyc3RDaGlsZE5vZGVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gY2hpbGROb2RlUGFyc2VUcmVlc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUgPSBjaGlsZE5vZGVQYXJzZVRyZWUsXG4gICAgICAgICAgICAgICAgICBsYXN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGxhc3RDaGlsZE5vZGVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArPSBsYXN0Q2hpbGROb2RlUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCBjaGlsZE5vZGVQYXJzZVRyZWVzTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbGFzdFZlcnRpY2FsQnJhbmNoUG9zaXRpb24gKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG4gICAgICAgICAgICBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArPSAxO1xuXG4gICAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzV2lkdGggKz0gY2hpbGROb2RlUGFyc2VUcmVlV2lkdGg7XG5cbiAgICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGggPSBNYXRoLm1heChjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGgsIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYXN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiAtIGZpcnN0VmVydGljYWxCcmFuY2hQb3NpdGlvbiArIDEsXG4gICAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZSA9IEhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgICAgbGVmdE1hcmdpbldpZHRoID0gZmlyc3RWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uLFxuICAgICAgICAgICAgICByaWdodE1hcmdpbldpZHRoID0gY2hpbGROb2RlUGFyc2VUcmVlc1dpZHRoIC0gd2lkdGggLSBsZWZ0TWFyZ2luV2lkdGg7XG5cbiAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5hZGRSaWdodE1hcmdpbihyaWdodE1hcmdpbldpZHRoKTtcbiAgICAgICAgaG9yaXpvbnRhbEJyYW5jaFBhcnNlVHJlZS5hZGRMZWZ0TWFyZ2luKGxlZnRNYXJnaW5XaWR0aCk7XG4gICAgICAgIGhvcml6b250YWxCcmFuY2hQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG5cbiAgICAgICAgY29uc3QgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICAgICAgZGVwdGggPSBjaGlsZE5vZGVQYXJzZVRyZWVzRGVwdGg7IC8vL1xuXG4gICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tRGVwdGhBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKENoaWxkTm9kZXNQYXJzZVRyZWUsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgICAgICBjaGlsZE5vZGVQYXJzZVRyZWVzLmZvckVhY2goKGNoaWxkTm9kZVBhcnNlVHJlZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVQYXJzZVRyZWVEZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZS5nZXREZXB0aCgpLFxuICAgICAgICAgICAgICAgIGNsb25lZENoaWxkTm9kZVBhcnNlVHJlZSA9IGNoaWxkTm9kZVBhcnNlVHJlZS5jbG9uZSgpO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgY2hpbGROb2RlUGFyc2VUcmVlc0xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TWFyZ2luV2lkdGggPSAxO1xuXG4gICAgICAgICAgICBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoIDwgY2hpbGROb2RlUGFyc2VUcmVlc0RlcHRoKSB7XG4gICAgICAgICAgICBjb25zdCBib3R0b21NYXJnaW5EZXB0aCA9IGNoaWxkTm9kZVBhcnNlVHJlZXNEZXB0aCAtIGNoaWxkTm9kZVBhcnNlVHJlZURlcHRoO1xuXG4gICAgICAgICAgICBjbG9uZWRDaGlsZE5vZGVQYXJzZVRyZWUuYWRkQm90dG9tTWFyZ2luKGJvdHRvbU1hcmdpbkRlcHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQoY2xvbmVkQ2hpbGROb2RlUGFyc2VUcmVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZS5hcHBlbmRUb1RvcChob3Jpem9udGFsQnJhbmNoUGFyc2VUcmVlKTtcblxuICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGROb2Rlc1BhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZU5hbWVQYXJzZVRyZWUgZnJvbSBcIi4vcnVsZU5hbWVcIjtcbmltcG9ydCBDaGlsZE5vZGVzUGFyc2VUcmVlIGZyb20gXCIuL2NoaWxkTm9kZXNcIjtcbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm9uVGVybWluYWxOb2RlQW5kVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gICAgbGV0IG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZTtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlID0gUnVsZU5hbWVQYXJzZVRyZWUuZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2VucyksXG4gICAgICAgICAgY2hpbGROb2Rlc1BhcnNlVHJlZSA9IENoaWxkTm9kZXNQYXJzZVRyZWUuZnJvbUNoaWxkTm9kZXNBbmRUb2tlbnMoY2hpbGROb2RlcywgdG9rZW5zKTtcblxuICAgIGlmIChjaGlsZE5vZGVzUGFyc2VUcmVlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnNlVHJlZURlcHRoID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0RGVwdGgoKSxcbiAgICAgICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHJ1bGVOYW1lUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24sIC8vL1xuICAgICAgICAgICAgZGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZURlcHRoOyAvLy9cblxuICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbURlcHRoQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUsIGRlcHRoLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgICAgbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvUmlnaHQocnVsZU5hbWVQYXJzZVRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpO1xuXG4gICAgICBjb25zdCBjaGlsZE5vZGVzUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlID0gcnVsZU5hbWVQYXJzZVRyZWVWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uIC0gY2hpbGROb2Rlc1BhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb247XG5cbiAgICAgIGxldCBsZWZ0TWFyZ2luV2lkdGg7XG5cbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAvLy9cbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSAtdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuXG4gICAgICAgIHJ1bGVOYW1lUGFyc2VUcmVlLmFkZExlZnRNYXJnaW4obGVmdE1hcmdpbldpZHRoKTtcbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlID4gMCkge1xuICAgICAgICBsZWZ0TWFyZ2luV2lkdGggPSArdmVydGljYWxCcmFuY2hQb3NpdGlvbnNEaWZmZXJlbmNlO1xuXG4gICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWUuYWRkTGVmdE1hcmdpbihsZWZ0TWFyZ2luV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBydWxlTmFtZVBhcnNlVHJlZVdpZHRoID0gcnVsZU5hbWVQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXNQYXJzZVRyZWVXaWR0aCA9IGNoaWxkTm9kZXNQYXJzZVRyZWUuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHdpZHRoc0RpZmZlcmVuY2UgPSBydWxlTmFtZVBhcnNlVHJlZVdpZHRoIC0gY2hpbGROb2Rlc1BhcnNlVHJlZVdpZHRoO1xuXG4gICAgICBsZXQgcmlnaHRNYXJnaW5XaWR0aDtcblxuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIC8vL1xuICAgICAgfSBlbHNlIGlmICh3aWR0aHNEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICByaWdodE1hcmdpbldpZHRoID0gLXdpZHRoc0RpZmZlcmVuY2U7XG5cbiAgICAgICAgcnVsZU5hbWVQYXJzZVRyZWUuYWRkUmlnaHRNYXJnaW4ocmlnaHRNYXJnaW5XaWR0aCk7XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoc0RpZmZlcmVuY2UgPiAwKSB7XG4gICAgICAgIHJpZ2h0TWFyZ2luV2lkdGggPSArd2lkdGhzRGlmZmVyZW5jZTtcblxuICAgICAgICBjaGlsZE5vZGVzUGFyc2VUcmVlLmFkZFJpZ2h0TWFyZ2luKHJpZ2h0TWFyZ2luV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBydWxlTmFtZVBhcnNlVHJlZVZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSBydWxlTmFtZVBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGggPSBydWxlTmFtZVBhcnNlVHJlZS5nZXREZXB0aCgpLFxuICAgICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHJ1bGVOYW1lUGFyc2VUcmVlVmVydGljYWxCcmFuY2hQb3NpdGlvbiwgLy8vXG4gICAgICAgICAgICBkZXB0aCA9IHJ1bGVOYW1lUGFyc2VUcmVlRGVwdGg7IC8vL1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tRGVwdGhBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgZGVwdGgsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9SaWdodChydWxlTmFtZVBhcnNlVHJlZSk7XG5cbiAgICAgIG5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb0JvdHRvbShjaGlsZE5vZGVzUGFyc2VUcmVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBub2RlTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvbm9kZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vcGFyc2VUcmVlL25vblRlcm1pbmFsTm9kZVwiO1xuXG5jb25zdCB7IGZpcnN0LCBtYXRjaCB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IG9wYXF1ZTogb3BhcXVlU3BlY2lhbFN5bWJvbCAsIHNlbWlPcGFxdWU6IHNlbWlPcGFxdWVTcGVjaWFsU3ltYm9sIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uVGVybWluYWxOb2RlIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWUsIHBhcmVudE5vZGUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzO1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFJ1bGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lO1xuICB9XG5cbiAgZ2V0UGFyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICB9XG5cbiAgZ2V0Q2hpbGROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZ2V0UHJlY2VkZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVjZWRlbmNlO1xuICB9XG5cbiAgc2V0UnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cblxuICBzZXRQYXJlbnROb2RlKHBhcmVudE5vZGUpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuICB9XG5cbiAgc2V0Q2hpbGROb2RlcyhjaGlsZE5vZGVzKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IDAsXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSBJbmZpbml0eSxcbiAgICAgICAgICBhZGRlZENoaWxkTm9kZXMgPSBjaGlsZE5vZGVzOyAgLy8vXG5cbiAgICB0aGlzLnNwbGljZUNoaWxkTm9kZXMoc3RhcnRJbmRleCwgZGVsZXRlQ291bnQsIGFkZGVkQ2hpbGROb2Rlcyk7XG4gIH1cblxuICBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICB9XG5cbiAgc2V0UHJlY2VkZW5jZShwcmVjZWRlbmNlKSB7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGlzT3BhcXVlKCkge1xuICAgIGNvbnN0IG9wYXF1ZSA9ICh0aGlzLm9wYWNpdHkgPT09IG9wYXF1ZVNwZWNpYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIG9wYXF1ZTtcbiAgfVxuXG4gIGlzU2VtaU9wYXF1ZSgpIHtcbiAgICBjb25zdCBzZW1pT3BhcXVlID0gKHRoaXMub3BhY2l0eSA9PT0gc2VtaU9wYXF1ZVNwZWNpYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIHNlbWlPcGFxdWU7XG4gIH1cblxuICBpc1RyYW5zcGFyZW50KCkge1xuICAgIGNvbnN0IHNlbWlPcGFxdWUgPSAodGhpcy5vcGFjaXR5ID09PSBudWxsKTtcblxuICAgIHJldHVybiBzZW1pT3BhcXVlO1xuICB9XG5cbiAgaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdHJ1ZTtcblxuICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBnZXREZXNjZW5kYW50Tm9kZXMoZGVzY2VuZGFudE5vZGVzKSB7XG4gICAgcmV0dXJuIGRlc2NlbmRhbnROb2RlcztcbiAgfVxuXG4gIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2Vucykge1xuICAgIGxldCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleDtcblxuICAgIHRoaXMuZm9yd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKTtcblxuICAgICAgaWYgKGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpIHtcbiAgICBsZXQgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleDtcblxuICAgIHRoaXMuYmFja3dhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gICAgICBpZiAobGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0U2lnbmlmaWNhbnRUb2tlbnMoc2lnbmlmaWNhbnRUb2tlbnMgPSBbXSkge1xuICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNoaWxkTm9kZS5nZXRTaWduaWZpY2FudFRva2VucyhzaWduaWZpY2FudFRva2Vucyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlbnM7XG4gIH1cblxuICBnZXRNdWx0aXBsaWNpdHkoKSB7XG4gICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgbXVsdGlwbGljaXR5ID0gY2hpbGROb2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgcmV0dXJuIG11bHRpcGxpY2l0eTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgY29uc3QgbXVsdGlwbGljaXR5ID0gdGhpcy5nZXRNdWx0aXBsaWNpdHkoKSxcbiAgICAgICAgICBlbXB0eSA9IChtdWx0aXBsaWNpdHkgPT09IDApO1xuXG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgaXNTaW5ndWxhcigpIHtcbiAgICBjb25zdCBtdWx0aXBsaWNpdHkgPSB0aGlzLmdldE11bHRpcGxpY2l0eSgpLFxuICAgICAgICAgIHNpbmd1bGFyID0gKG11bHRpcGxpY2l0eSA9PT0gMSk7XG5cbiAgICByZXR1cm4gc2luZ3VsYXI7XG4gIH1cblxuICBpc0xvd2VyUHJlY2VkZW5jZShydWxlTmFtZSwgcHJlY2VkZW5jZSkge1xuICAgIGxldCBsb3dlclByZWNlZGVuY2U7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjZWRlbmNlID09PSBudWxsKSB7XG4gICAgICBsb3dlclByZWNlZGVuY2UgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGROb2RlID0gZmlyc3QodGhpcy5jaGlsZE5vZGVzKTtcblxuICAgICAgbG93ZXJQcmVjZWRlbmNlID0gZmlyc3RDaGlsZE5vZGUuaXNMb3dlclByZWNlZGVuY2UocnVsZU5hbWUsIHByZWNlZGVuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3dlclByZWNlZGVuY2UgPSAoKHRoaXMucnVsZU5hbWUgPT09IHJ1bGVOYW1lKSAmJiAodGhpcy5wcmVjZWRlbmNlIDwgcHJlY2VkZW5jZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsb3dlclByZWNlZGVuY2U7XG4gIH1cblxuICBpc1VucHJlY2VkZW50ZWQoKSB7XG4gICAgbGV0IHVucHJlY2VkZW50ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnByZWNlZGVuY2UgIT09IG51bGwpIHtcbiAgICAgIHVucHJlY2VkZW50ZWQgPSB0aGlzLmNoaWxkTm9kZXMuc29tZSgoY2hpbGROb2RlKSA9PiB7ICAvLy9cbiAgICAgICAgY29uc3QgY2hpbGROb2RlTG93ZXJQcmVjZWRlbmNlID0gY2hpbGROb2RlLmlzTG93ZXJQcmVjZWRlbmNlKHRoaXMucnVsZU5hbWUsIHRoaXMucHJlY2VkZW5jZSk7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5wcmVjZWRlbnRlZDtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHRoaXMsICAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBOb25UZXJtaW5hbE5vZGVQYXJzZVRyZWUuZnJvbU5vblRlcm1pbmFsTm9kZUFuZFRva2Vucyhub25UZXJtaW5hbE5vZGUsIHRva2VucyksXG4gICAgICAgICAgcGFyc2VUcmVlID0gbm9uVGVybWluYWxOb2RlUGFyc2VUcmVlOyAgLy8vXG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgbWF0Y2gobm9kZSwgZGVwdGggPSBJbmZpbml0eSwgZXhhY3RseSA9IGZhbHNlKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgICBpZiAodGhpcy5ydWxlTmFtZSA9PT0gbm9uVGVybWluYWxOb2RlUnVsZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlT3BhY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRPcGFjaXR5KCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3BhY2l0eSA9PT0gbm9uVGVybWluYWxOb2RlT3BhY2l0eSkge1xuICAgICAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSB0aGlzLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICAgICAgICBub25UZXJtaW5hbE5vZGVQcmVjZWRlbmNlID0gbm9uVGVybWluYWxOb2RlLmdldFByZWNlZGVuY2UoKTtcblxuICAgICAgICAgIGlmIChwcmVjZWRlbmNlID09PSBub25UZXJtaW5hbE5vZGVQcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBkZXB0aC0tO1xuXG4gICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKTtcblxuICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2godGhpcy5jaGlsZE5vZGVzLCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzLCAoY2hpbGROb2RlLCBub25UZXJtaW5hbE5vZGVDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVNYXRjaGVzTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlID0gY2hpbGROb2RlLm1hdGNoKG5vblRlcm1pbmFsTm9kZUNoaWxkTm9kZSwgZGVwdGgsIGV4YWN0bHkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZU1hdGNoZXNOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICByZXdyaXRlKHN0YXRlKSB7XG4gICAgY29uc3QgcmV3cml0dGVuTm9uVGVybWluYWxOb2RlID0gbnVsbDtcblxuICAgIHJldHVybiByZXdyaXR0ZW5Ob25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZm9yRWFjaENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjaGlsZE5vZGUuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5ydWxlTmFtZSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gY2xvbmVDaGlsZE5vZGVzKHRoaXMuY2hpbGROb2RlcyksXG4gICAgICAgICAgb3BhY2l0eSA9IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gdGhpcy5wcmVjZWRlbmNlLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhydWxlTmFtZSwgcGFyZW50Tm9kZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBpZiAocHJlY2VkZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmVjZWRlbmNlID0gb3BhY2l0eTsgLy8vXG5cbiAgICAgIG9wYWNpdHkgPSBjaGlsZE5vZGVzOyAvLy9cblxuICAgICAgY2hpbGROb2RlcyA9IHJ1bGVOYW1lOyAgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IE5vblRlcm1pbmFsTm9kZTsgIC8vL1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IG5ldyBDbGFzcyhydWxlTmFtZSwgcGFyZW50Tm9kZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZS5zZXRDaGlsZE5vZGVzUGFyZW50Tm9kZSgpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKE5vblRlcm1pbmFsTm9kZS5wcm90b3R5cGUsIG5vZGVNaXhpbnMpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkTm9kZXMoY2hpbGROb2Rlcykge1xuICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5tYXAoKGNoaWxkTm9kZSkgPT4geyAgLy8vXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNsb25lKCk7ICAvLy9cblxuICAgIHJldHVybiBjaGlsZE5vZGU7XG4gIH0pO1xuXG4gIHJldHVybiBjaGlsZE5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQWhlYWQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY2FsbEFoZWFkID0gY2FsbEFoZWFkO1xuICB9XG4gIFxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBpc0NhbGxBaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsQWhlYWQ7XG4gIH1cblxuICBpc05vblRlcm1pbmFsUGFydCgpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbFBhcnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IGZhbHNlO1xuICAgIFxuICAgIHJldHVybiB0ZXJtaW5hbFBhcnQ7XG4gIH1cblxuICBpc1J1bGVOYW1lUGFydCgpIHtcbiAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBmYWxzZTtcblxuICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFJ1bGVOYW1lUGFydFR5cGUgPSBcInJ1bGVOYW1lUGFydFwiO1xuZXhwb3J0IGNvbnN0IE9wdGlvbmFsUGFydFBhcnRUeXBlID0gXCJvcHRpb25hbFBhcnRcIjtcbmV4cG9ydCBjb25zdCBDaG9pY2VPZlBhcnRzUGFydFR5cGUgPSBcImNob2ljZU9mUGFydHNcIjtcbmV4cG9ydCBjb25zdCBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlID0gXCJvbmVPck1vcmVQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlID0gXCJ6ZXJvT3JNb3JlUGFydHNcIjtcbmV4cG9ydCBjb25zdCBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSA9IFwic2VxdWVuY2VPZlBhcnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBPcHRpb25hbFBhcnRQYXJ0VHlwZSB9IGZyb20gXCIuLi8uLi9wYXJ0VHlwZXNcIjtcblxuXG5jb25zdCB7IHF1ZXN0aW9uTWFyayB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbmFsUGFydFBhcnQgZXh0ZW5kcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQWhlYWQsIHBhcnQpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuXG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgfVxuXG4gIGdldFBhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydDtcbiAgfVxuXG4gIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgcGFyc2VkID0gcGFyc2VPcHRpb25hbFBhcnQodGhpcy5wYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm9kZXNMZW5ndGg7ICAvLy9cblxuICAgICAgbm9kZXMuc3BsaWNlKHN0YXJ0KTtcblxuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgICAgc3RyaW5nID0gYCR7cGFydFN0cmluZ30ke3F1ZXN0aW9uTWFya31gO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydChwYXJ0KSB7XG4gICAgY29uc3QgdHlwZSA9IE9wdGlvbmFsUGFydFBhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIG9wdGlvbmFsUGFydFBhcnQgPSBuZXcgT3B0aW9uYWxQYXJ0UGFydCh0eXBlLCBjYWxsQWhlYWQsIHBhcnQpO1xuXG4gICAgcmV0dXJuIG9wdGlvbmFsUGFydFBhcnQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlT3B0aW9uYWxQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIGlmIChjYWxsQWhlYWQgPT09IG51bGwpIHtcbiAgICBwYXJzZWQgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cblxuXG5cblxuICAgIHBhcnNlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG5cblxuXG5cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIH0gZnJvbSBcIi4uLy4uL3BhcnRUeXBlc1wiO1xuXG5cbmNvbnN0IHsgYXN0ZXJpc2sgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaZXJvT3JNb3JlUGFydHNQYXJ0IGV4dGVuZHMgTm9uVGVybWluYWxQYXJ0IHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KSB7XG4gICAgc3VwZXIodHlwZSwgY2FsbEFoZWFkKTtcblxuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gIH1cblxuICBnZXRQYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHBhcnNlZCA9IHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydCh0aGlzLnBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuXG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRTdHJpbmcgPSB0aGlzLnBhcnQuYXNTdHJpbmcoKSxcbiAgICAgICAgICBzdHJpbmcgPSBgJHtwYXJ0U3RyaW5nfSR7YXN0ZXJpc2t9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnQocGFydCkge1xuICAgIGNvbnN0IHR5cGUgPSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gbmV3IFplcm9Pck1vcmVQYXJ0c1BhcnQodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KTtcblxuICAgIHJldHVybiB6ZXJvT3JNb3JlUGFydHNQYXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVplcm9Pck1vcmVQYXJ0c1BhcnQocGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgaWYgKGNhbGxBaGVhZCA9PT0gbnVsbCkge1xuICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgcGFyc2VkID0gcGFyc2VaZXJvT3JNb3JlUGFydHNQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IE9uZU9yTW9yZVBhcnRzUGFydFR5cGUgfSBmcm9tIFwiLi4vLi4vcGFydFR5cGVzXCI7XG5pbXBvcnQgeyBwYXJzZVplcm9Pck1vcmVQYXJ0c1BhcnQgfSBmcm9tIFwiLi96ZXJvT3JNb3JlUGFydHNcIjtcblxuY29uc3QgeyBwbHVzIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT25lT3JNb3JlUGFydHNQYXJ0IGV4dGVuZHMgTm9uVGVybWluYWxQYXJ0IHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2FsbEFoZWFkLCBwYXJ0KSB7XG4gICAgc3VwZXIodHlwZSwgY2FsbEFoZWFkKTtcblxuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gIH1cblxuICBnZXRQYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIHBhcnNlZCA9IHBhcnNlT25lT3JNb3JlUGFydHNQYXJ0KHRoaXMucGFydCwgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICAgIG5vZGVzLnNwbGljZShzdGFydCk7XG5cbiAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3QgcGFydFN0cmluZyA9IHRoaXMucGFydC5hc1N0cmluZygpLFxuICAgICAgICAgIHN0cmluZyA9IGAke3BhcnRTdHJpbmd9JHtwbHVzfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXJ0KHBhcnQpIHtcbiAgICBjb25zdCB0eXBlID0gT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICBvbmVPck1vcmVQYXJ0c1BhcnQgPSBuZXcgT25lT3JNb3JlUGFydHNQYXJ0KHR5cGUsIGNhbGxBaGVhZCwgcGFydCk7XG5cbiAgICByZXR1cm4gb25lT3JNb3JlUGFydHNQYXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9uZU9yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBpZiAoY2FsbEFoZWFkID09PSBudWxsKSB7XG4gICAgcGFyc2VkID0gcGFydC5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcGFyc2VaZXJvT3JNb3JlUGFydHNQYXJ0KHBhcnQsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG4gICAgfVxuXG5cbiAgfSBlbHNlIHtcblxuXG5cbiAgICAgIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgKCkgPT4ge1xuICAgICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlWmVyb09yTW9yZVBhcnRzUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9KTtcblxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE5BTUVfUlVMRV9OQU1FID0gXCJuYW1lXCI7XG5leHBvcnQgY29uc3QgUEFSVF9SVUxFX05BTUUgPSBcInBhcnRcIjtcbmV4cG9ydCBjb25zdCBSVUxFX1JVTEVfTkFNRSA9IFwicnVsZVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SX1JVTEVfTkFNRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBFUFNJTE9OX1JVTEVfTkFNRSA9IFwiZXBzaWxvblwiO1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1JVTEVfTkFNRSA9IFwiZG9jdW1lbnRcIjtcbmV4cG9ydCBjb25zdCBXSUxEQ0FSRF9SVUxFX05BTUUgPSBcIndpbGRjYXJkXCI7XG5leHBvcnQgY29uc3QgUlVMRV9OQU1FX1JVTEVfTkFNRSA9IFwicnVsZU5hbWVcIjtcbmV4cG9ydCBjb25zdCBERUZJTklUSU9OX1JVTEVfTkFNRSA9IFwiZGVmaW5pdGlvblwiO1xuZXhwb3J0IGNvbnN0IFBSRUNFREVOQ0VfUlVMRV9OQU1FID0gXCJwcmVjZWRlbmNlXCI7XG5leHBvcnQgY29uc3QgUVVBTlRJRklFUl9SVUxFX05BTUUgPSBcInF1YW50aWZpZXJcIjtcbmV4cG9ydCBjb25zdCBFTkRfT0ZfTElORV9SVUxFX05BTUUgPSBcImVuZE9mTGluZVwiO1xuZXhwb3J0IGNvbnN0IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSA9IFwicGFydENob2ljZVwiO1xuZXhwb3J0IGNvbnN0IERFRklOSVRJT05TX1JVTEVfTkFNRSA9IFwiZGVmaW5pdGlvbnNcIjtcbmV4cG9ydCBjb25zdCBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSA9IFwidGVybWluYWxQYXJ0XCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FID0gXCJzdHJpbmdMaXRlcmFsXCI7XG5leHBvcnQgY29uc3QgQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRSA9IFwiY2hvaWNlT2ZQYXJ0c1wiO1xuZXhwb3J0IGNvbnN0IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FID0gXCJvcGFjaXR5TW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUgPSBcIm5vblRlcm1pbmFsUGFydFwiO1xuZXhwb3J0IGNvbnN0IFNFUVVFTkNFX09GX1BBUlRTX1JVTEVfTkFNRSA9IFwic2VxdWVuY2VPZlBhcnRzXCI7XG5leHBvcnQgY29uc3QgTk9fV0hJVEVTUEFDRV9QQVJUX1JVTEVfTkFNRSA9IFwibm9XaGl0ZXNwYWNlXCI7XG5leHBvcnQgY29uc3QgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSA9IFwicmVndWxhckV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSA9IFwiY2FsbEFoZWFkTW9kaWZpZXJcIjtcbmV4cG9ydCBjb25zdCBPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwib3B0aW9uYWxRdWFudGlmaWVyXCI7XG5leHBvcnQgY29uc3QgU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRSA9IFwic3RhcnRPZkNvbnRlbnRcIjtcbmV4cG9ydCBjb25zdCBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRSA9IFwic2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcbmV4cG9ydCBjb25zdCBPTkVfT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwib25lT3JNb3JlUXVhbnRpZmllclwiO1xuZXhwb3J0IGNvbnN0IFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSA9IFwiemVyb09yTW9yZVF1YW50aWZpZXJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IFJVTEVfTkFNRV9SVUxFX05BTUUsIFFVQU5USUZJRVJfUlVMRV9OQU1FLCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDaG9pY2VOb2RlKG5vZGUpIHtcbiAgbGV0IG5vZGVOb0Nob2ljZU5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgbm9kZU5vQ2hvaWNlTm9kZSA9ICh0ZXJtaW5hbE5vZGVDb250ZW50ID09PSBcInxcIik7XG4gIH1cblxuICByZXR1cm4gbm9kZU5vQ2hvaWNlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVJ1bGVOYW1lTm9kZShub2RlKSB7XG4gIGxldCBub2RlUnVsZU5hbWVOb2RlID0gZmFsc2U7XG5cbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgbm9kZU5vblRlcm1pbmFsTm9kZSA9ICFub2RlVGVybWluYWxOb2RlO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgIG5vZGVSdWxlTmFtZU5vZGUgPSAobm9uVGVybWluYWxOb2RlUnVsZU5hbWUgPT09IFJVTEVfTkFNRV9SVUxFX05BTUUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVSdWxlTmFtZU5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVRdWFudGlmaWVyTm9kZShub2RlKSB7XG4gIGxldCBub2RlUXVhbnRpZmllck5vZGUgPSBmYWxzZTtcblxuICBjb25zdCBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgLy8vXG4gICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZVF1YW50aWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gUVVBTlRJRklFUl9SVUxFX05BTUUpO1xuXG4gICAgbm9kZVF1YW50aWZpZXJOb2RlID0gcnVsZU5hbWVRdWFudGlmaWVyUnVsZU5hbWU7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlUXVhbnRpZmllck5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVDYWxsQWhlYWRNb2RpZmllck5vZGUobm9kZSkge1xuICBsZXQgbm9kZUNhbGxBaGVhZE1vZGlmaWVyTm9kZSA9IGZhbHNlO1xuXG4gIGNvbnN0IG5vZGVOb25UZXJtaW5hbE5vZGUgPSBub2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lQ2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUUpO1xuXG4gICAgbm9kZUNhbGxBaGVhZE1vZGlmaWVyTm9kZSA9IHJ1bGVOYW1lQ2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZTsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG5vZGVDYWxsQWhlYWRNb2RpZmllck5vZGU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lRnJvbVF1YW50aWZpZXJOb2RlKHF1YW50aWZpZXJOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcXVhbnRpZmllck5vZGU7IC8vL1xuXG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpO1xuXG4gIG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgY29uc3QgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBPbmVPck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIjtcbmltcG9ydCBaZXJvT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiO1xuXG5pbXBvcnQgeyBpc05vZGVRdWFudGlmaWVyTm9kZSwgcnVsZU5hbWVGcm9tUXVhbnRpZmllck5vZGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2JuZlwiO1xuaW1wb3J0IHsgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgbGFzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBub2RlcyA9IGNoaWxkTm9kZXMuc2xpY2UoKSxcbiAgICAgICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5mdW5jdGlvbiBwYXJ0RnJvbU5vZGVzKG5vZGVzKSB7XG4gIGxldCBwYXJ0O1xuXG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGlmIChub2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKSxcbiAgICAgICAgICBjYWxsQWhlYWQgPSBmYWxzZTtcblxuICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3ROb2RlUXVhbnRpZmllck5vZGUgPSBpc0xhc3ROb2RlUXVhbnRpZmllck5vZGUobm9kZXMpO1xuXG4gICAgaWYgKGxhc3ROb2RlUXVhbnRpZmllck5vZGUpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5wb3AoKSxcbiAgICAgICAgICAgIHF1YW50aWZpZXJOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG5cbiAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZU5hbWVGcm9tUXVhbnRpZmllck5vZGUocXVhbnRpZmllck5vZGUpLFxuICAgICAgICAgICAgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gY29sbGVjdGlvbk9mUGFydHNQYXJ0RnJvbVBhcnRBbmRSdWxlTmFtZShwYXJ0LCBydWxlTmFtZSk7XG5cbiAgICAgIHBhcnQgPSBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7IC8vL1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5zaGlmdCgpO1xuXG4gICAgICBwYXJ0ID0gcGFydEZyb21Ob2Rlcyhub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnQ7XG59XG5cbmZ1bmN0aW9uIGlzTGFzdE5vZGVRdWFudGlmaWVyTm9kZShub2Rlcykge1xuICBjb25zdCBsYXN0Tm9kZSA9IGxhc3Qobm9kZXMpLFxuICAgICAgICBsYXN0Tm9kZVF1YW50aWZpZXJOb2RlID0gaXNOb2RlUXVhbnRpZmllck5vZGUobGFzdE5vZGUpO1xuXG4gIHJldHVybiBsYXN0Tm9kZVF1YW50aWZpZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnRGcm9tUGFydEFuZFJ1bGVOYW1lKHBhcnQsIHJ1bGVOYW1lKSB7XG4gIGxldCBjb2xsZWN0aW9uT2ZQYXJ0c1BhcnQ7XG5cbiAgc3dpdGNoIChydWxlTmFtZSkge1xuICAgIGNhc2UgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUgOlxuICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQocGFydCk7XG5cbiAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IG9wdGlvbmFsUGFydFBhcnQ7IC8vL1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FIDpcbiAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IE9uZU9yTW9yZVBhcnRzUGFydC5mcm9tUGFydChwYXJ0KTtcblxuICAgICAgY29sbGVjdGlvbk9mUGFydHNQYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0OyAvLy9cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgOlxuICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocGFydCk7XG5cbiAgICAgIGNvbGxlY3Rpb25PZlBhcnRzUGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQ7ICAvLy9cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb25PZlBhcnRzUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hbWVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgZmlyc3RDaGlsZE5vZGUgPSBmaXJzdChjaGlsZE5vZGVzKSxcbiAgICAgICAgICB0ZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIG5hbWUgPSB0ZXJtaW5hbE5vZGVDb250ZW50OyAvLy9cbiAgICBcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGNoaWxkTm9kZXMuc29tZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lID0gKG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBydWxlTmFtZSk7XG5cbiAgICAgIGlmIChub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpIHtcbiAgY29uc3Qgbm9kZXMgPSBjaGlsZE5vZGVzLmZpbHRlcigoY2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgIG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lID0gKG5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBydWxlTmFtZSk7XG5cbiAgICAgIGlmIChub25UZXJtaW5hbE5vZGVSdWxlTmFtZVJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBPUEFDSVRZX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZExhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlUnVsZShSdWxlKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpLFxuICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IHRoaXMuZ2VuZXJhdGVEZWZpbml0aW9ucygpLFxuICAgICAgICAgIHJ1bGUgPSBSdWxlLmZyb21OYW1lT3BhY2l0eUFuZERlZmluaXRpb25zKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBydWxlO1xuICB9XG5cbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBsZXQgb3BhY2l0eSA9IG51bGw7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgaWYgKG9wYWNpdHlNb2RpZmllckJORk5vZGUgIT09IG51bGwpIHtcbiAgICAgIG9wYWNpdHkgPSBvcGFjaXR5TW9kaWZpZXJCTkZOb2RlLmdldE9wYWNpdHkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BhY2l0eTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgbmFtZUJORk5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIG5hbWUgPSBuYW1lQk5GTm9kZS5nZXROYW1lKCk7XG4gICAgXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgXG4gIGdlbmVyYXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHNlY29uZExhc3RDaGlsZE5vZGUgPSBzZWNvbmRMYXN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIGRlZmluaXRpb25zQk5GTm9kZSA9IHNlY29uZExhc3RDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnNCTkZOb2RlLmdlbmVyYXRlRGVmaW5pdGlvbnMoKTtcbiAgICBcbiAgICByZXR1cm4gZGVmaW5pdGlvbnM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJ1bGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEVycm9yQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsUGFydCB7XG4gIGlzQ2FsbEFoZWFkKCkge1xuICAgIGNvbnN0IGNhbGxBaGVhZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGNhbGxBaGVhZDtcbiAgfVxuXG4gIGlzTm9uVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzVGVybWluYWxQYXJ0KCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIHRlcm1pbmFsUGFydDtcbiAgfVxuXG4gIGlzTm9XaGl0ZXNwYWNlUGFydCgpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VQYXJ0ID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgfVxuXG4gIGlzU3RhcnRPZkNvbnRlbnRQYXJ0KCkge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50UGFydDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUgZnJvbSBcIi4vdmVydGljYWxCcmFuY2hcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgbGluZUluZGV4RnJvbVRva2VuSW5kZXhBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rva2Vuc1wiO1xuXG5jb25zdCB7IE5FV19MSU5FX0NIQVJBQ1RFUiwgQ0FSUklBR0VfUkVUVVJOX0NIQVJBQ1RFUiB9ID0gY2hhcmFjdGVycztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxOb2RlUGFyc2VUcmVlIGV4dGVuZHMgVmVydGljYWxCcmFuY2hQYXJzZVRyZWUge1xuICBzdGF0aWMgZnJvbVRlcm1pbmFsTm9kZUFuZFRva2Vucyh0ZXJtaW5hbE5vZGUsIHRva2Vucykge1xuICAgIGxldCBjb250ZW50O1xuXG4gICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9bXFxyXFxuXS9nLCAobWF0Y2gpID0+IHtcbiAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgY2FzZSBDQVJSSUFHRV9SRVRVUk5fQ0hBUkFDVEVSOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG5cbiAgICAgICAgY2FzZSBORVdfTElORV9DSEFSQUNURVI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGUgPSB0ZXJtaW5hbE5vZGUuZ2V0VHlwZSgpLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRlcm1pbmFsTm9kZS5nZXRTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tVG9rZW5JbmRleEFuZFRva2VucyhzaWduaWZpY2FudFRva2VuSW5kZXgsIHRva2Vucyk7XG5cbiAgICBsZXQgbGluZUluZGV4ZXM7XG5cbiAgICBpZiAobGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICBsaW5lSW5kZXhlcyA9IEVNUFRZX1NUUklORztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZUluZGV4ZXMgPSBgIFske2xpbmVJbmRleH1dYDtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpbmcgPSBgXCIke2NvbnRlbnR9XCJbJHt0eXBlfV0ke2xpbmVJbmRleGVzfWAsXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKFRlcm1pbmFsTm9kZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlUGFyc2VUcmVlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXJtaW5hbE5vZGVQYXJzZVRyZWUgZnJvbSBcIi4uL3BhcnNlVHJlZS90ZXJtaW5hbE5vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxOb2RlIHtcbiAgY29uc3RydWN0b3IocGFyZW50Tm9kZSwgc2lnbmlmaWNhbnRUb2tlbikge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgdGhpcy5zaWduaWZpY2FudFRva2VuID0gc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIGdldFBhcmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGdldFNpZ25pZmljYW50VG9rZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmlmaWNhbnRUb2tlbjtcbiAgfVxuXG4gIHNldFBhcmVudE5vZGUocGFyZW50Tm9kZSkge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cblxuICBzZXRTaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pIHtcbiAgICB0aGlzLnNpZ25pZmljYW50VG9rZW4gPSBzaWduaWZpY2FudFRva2VuO1xuICB9XG5cbiAgaXNTdGFydE9mQ29udGVudE5vZGUoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnROb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnROb2RlO1xuICB9XG5cbiAgaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGUgPSBmYWxzZTtcblxuICAgIHJldHVybiBub1doaXRlc3BhY2VOb2RlO1xuICB9XG5cbiAgaXNFcHNpbG9uTm9kZSgpIHtcbiAgICBjb25zdCBlcHNpbG9uTm9kZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlO1xuICB9XG5cbiAgaXNUZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gdHJ1ZTtcbiAgICBcbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgaXNOb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxOb2RlO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHsgcmV0dXJuIHRoaXMuc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7IH1cblxuICBnZXRDb250ZW50KCkgeyByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuLmdldENvbnRlbnQoKTsgfVxuXG4gIGdldFByZWNlZGVuY2UoKSAge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsO1xuXG4gICAgcmV0dXJuIHByZWNlZGVuY2U7XG4gIH1cblxuICBpc0xvd2VyUHJlY2VkZW5jZShwYXJlbnRSdWxlTmFtZSwgcGFyZW50UHJlY2VkZW5jZSkge1xuICAgIGNvbnN0IGxvd2VyUHJlY2VkZW5jZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGxvd2VyUHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2Vucykge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5JbmRleCA9IHRoaXMuZ2V0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgICAgZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSBzaWduaWZpY2FudFRva2VuSW5kZXg7IC8vL1xuXG4gICAgcmV0dXJuIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4O1xuICB9XG5cbiAgZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuSW5kZXggPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpLFxuICAgICAgICAgIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSBzaWduaWZpY2FudFRva2VuSW5kZXg7IC8vL1xuXG4gICAgcmV0dXJuIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXg7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSB7XG4gICAgbGV0IHNpZ25pZmljYW50VG9rZW5JbmRleCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICBzaWduaWZpY2FudFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZih0aGlzLnNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuSW5kZXg7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VucyhzaWduaWZpY2FudFRva2VucyA9IFtdKSB7XG4gICAgaWYgKHRoaXMuc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgc2lnbmlmaWNhbnRUb2tlbnMucHVzaCh0aGlzLnNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VucztcbiAgfVxuXG4gIGdldEFuY2VzdG9yTm9kZXMoKSB7XG4gICAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IFtdO1xuXG4gICAgbGV0IGFuY2VzdG9yTm9kZSA9IHRoaXMucGFyZW50Tm9kZTsgLy8vXG5cbiAgICB3aGlsZSAoYW5jZXN0b3JOb2RlICE9PSBudWxsKSB7XG4gICAgICBhbmNlc3Rvck5vZGVzLnB1c2goYW5jZXN0b3JOb2RlKTtcblxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2VzdG9yTm9kZS5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgIGFuY2VzdG9yTm9kZSA9IHBhcmVudE5vZGU7ICAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2RlcztcbiAgfVxuXG4gIG1hcEFuY2VzdG9yTm9kZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGFuY2VzdG9yTm9kZXMgPSB0aGlzLmdldEFuY2VzdG9yTm9kZXMoKTtcblxuICAgIHJldHVybiBhbmNlc3Rvck5vZGVzLm1hcChjYWxsYmFjayk7XG4gIH1cblxuICBzb21lQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgbGV0IGluZGV4ID0gMCxcbiAgICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICAgIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9ICEhY2FsbGJhY2soYW5jZXN0b3JOb2RlLCBpbmRleCk7IC8vL1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaW5kQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IGluZGV4ID0gMCxcbiAgICAgICAgYW5jZXN0b3JOb2RlID0gdGhpcy5wYXJlbnROb2RlOyAvLy9cblxuICAgIHdoaWxlIChhbmNlc3Rvck5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKGFuY2VzdG9yTm9kZSwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBhbmNlc3Rvck5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNlc3Rvck5vZGUuZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICBhbmNlc3Rvck5vZGUgPSBwYXJlbnROb2RlOyAgLy8vXG5cbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JOb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGFuY2VzdG9yTm9kZTtcbiAgfVxuXG4gIGV2ZXJ5QW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICBsZXQgaW5kZXggPSAwLFxuICAgICAgICBhbmNlc3Rvck5vZGUgPSB0aGlzLnBhcmVudE5vZGU7IC8vL1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yTm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gISFjYWxsYmFjayhhbmNlc3Rvck5vZGUsIGluZGV4KTsgLy8vXG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jZXN0b3JOb2RlLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgYW5jZXN0b3JOb2RlID0gcGFyZW50Tm9kZTsgIC8vL1xuXG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaWx0ZXJBbmNlc3Rvck5vZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5maWx0ZXIoY2FsbGJhY2spO1xuICB9XG5cbiAgcmVkdWNlQW5jZXN0b3JOb2RlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICBjb25zdCBhbmNlc3Rvck5vZGVzID0gdGhpcy5nZXRBbmNlc3Rvck5vZGVzKCk7XG5cbiAgICByZXR1cm4gYW5jZXN0b3JOb2Rlcy5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBmb3JFYWNoQW5jZXN0b3JOb2RlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYW5jZXN0b3JOb2RlcyA9IHRoaXMuZ2V0QW5jZXN0b3JOb2RlcygpO1xuXG4gICAgYW5jZXN0b3JOb2Rlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGdldERlc2NlbmRhbnROb2RlcyhkZXNjZW5kYW50Tm9kZXMgPSBbXSkge1xuICAgIHJldHVybiBkZXNjZW5kYW50Tm9kZXM7XG4gIH1cblxuICBzb21lRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmaW5kRGVzY2VuZGFudE5vZGUoY2FsbGJhY2spIHtcbiAgICBsZXQgZGVzY2VuZGFudE5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVzY2VuZGFudE5vZGU7XG4gIH1cblxuICBldmVyeURlc2NlbmRhbnROb2RlKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgY29uc3QgdGVybWluYWxOb2RlID0gdGhpcywgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFRlcm1pbmFsTm9kZVBhcnNlVHJlZS5mcm9tVGVybWluYWxOb2RlQW5kVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBtYXRjaChub2RlLCBkZXB0aCA9IEluZmluaXR5LCBleGFjdGx5ID0gZmFsc2UpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICBzaWduaWZpY2FudFRva2VuID0gdGVybWluYWxOb2RlLmdldFNpZ25pZmljYW50VG9rZW4oKTtcblxuICAgICAgbWF0Y2hlcyA9IGV4YWN0bHkgP1xuICAgICAgICAgICAgICAgICAgKHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9PT0gc2lnbmlmaWNhbnRUb2tlbikgOlxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduaWZpY2FudFRva2VuLm1hdGNoKHNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgY2xvbmUoLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHBhcmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSB0aGlzLnNpZ25pZmljYW50VG9rZW4sXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMuc2lnbmlmaWNhbnRUb2tlbiA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGlmIChDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBDbGFzcyA9IFRlcm1pbmFsTm9kZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG51bGwsXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlbiA9IG51bGwsXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21TaWduaWZpY2FudFRva2VuKENsYXNzLCBzaWduaWZpY2FudFRva2VuLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduaWZpY2FudFRva2VuID0gQ2xhc3M7IC8vL1xuXG4gICAgICBDbGFzcyA9IFRlcm1pbmFsTm9kZTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG51bGwsXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gbmV3IENsYXNzKHBhcmVudE5vZGUsIHNpZ25pZmljYW50VG9rZW4sIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgXG4gICAgcmV0dXJuIHRlcm1pbmFsTm9kZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuLi9wYXJzZVRyZWUvdmVydGljYWxCcmFuY2hcIjtcblxuY29uc3QgeyBlcHNpbG9uIH0gPSBzcGVjaWFsU3ltYm9scztcblxuY2xhc3MgRXBzaWxvbk5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBlcHNpbG9uLCAvLy9cbiAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGggPSBzdHJpbmdMZW5ndGgsIC8vL1xuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVdpZHRoKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlV2lkdGgpLFxuICAgICAgICAgIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24gPSB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5nZXRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKCksXG4gICAgICAgICAgdGVybWluYWxOb2RlUGFyc2VUcmVlID0gVmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZnJvbVN0cmluZ0FuZFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oRXBzaWxvbk5vZGVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9Ub3AodmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuXG4gICAgY29uc3QgZXBzaWxvbk5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlUGFyc2VUcmVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXBzaWxvbk5vZGVQYXJzZVRyZWU7IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vdGVybWluYWxcIjtcbmltcG9ydCBFcHNpbG9uTm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vLi4vcGFyc2VUcmVlL2Vwc2lsb25Ob2RlXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25Ob2RlIGV4dGVuZHMgVGVybWluYWxOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBjb25zdCB0eXBlID0gbnVsbDsgIC8vL1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBlcHNpbG9uOyAgLy8vXG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlzRXBzaWxvbk5vZGUoKSB7XG4gICAgY29uc3QgZXBzaWxvbk5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGVwc2lsb25Ob2RlO1xuICB9XG5cbiAgYXNQYXJzZVRyZWUodG9rZW5zKSB7XG4gICAgY29uc3QgZXBzaWxvbk5vZGVQYXJzZVRyZWUgPSBFcHNpbG9uTm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IGVwc2lsb25Ob2RlUGFyc2VUcmVlOyAgLy8vXG5cbiAgICByZXR1cm4gcGFyc2VUcmVlO1xuICB9XG5cbiAgbWF0Y2gobm9kZSwgZGVwdGgpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICB0ZXJtaW5hbE5vZGVFcHNpbG9uTm9kZSA9IHRlcm1pbmFsTm9kZS5pc0Vwc2lsb25Ob2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVFcHNpbG9uTm9kZSkge1xuICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIFRlcm1pbmFsTm9kZS5mcm9tTm90aGluZyhFcHNpbG9uTm9kZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBFcHNpbG9uQk5GTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9lcHNpbG9uXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25QYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgZXBzaWxvbkJORk5vZGUgPSBFcHNpbG9uQk5GTm9kZS5mcm9tTm90aGluZygpO1xuXG4gICAgcGFyc2VkID0gKGVwc2lsb25CTkZOb2RlICE9PSBudWxsKTtcblxuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIG5vZGVzLnB1c2goZXBzaWxvbkJORk5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGVwc2lsb247IC8vL1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlcHNpbG9uUGFydCA9IG5ldyBFcHNpbG9uUGFydCgpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25QYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFcHNpbG9uUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbC9lcHNpbG9uXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25CTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGVwc2lsb25QYXJ0ID0gRXBzaWxvblBhcnQuZnJvbU5vdGhpbmcoKTtcblxuICAgIHJldHVybiBlcHNpbG9uUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXBzaWxvbkJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb21cIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgUlVMRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVSdWxlcyhSdWxlKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSVUxFX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcnVsZUJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICBydWxlcyA9IHJ1bGVCTkZOb2Rlcy5tYXAoKHJ1bGVCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZUJORk5vZGUuZ2VuZXJhdGVSdWxlKFJ1bGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKERvY3VtZW50Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IFJ1bGVOYW1lUGFydFR5cGUgfSBmcm9tIFwiLi4vLi4vcGFydFR5cGVzXCI7XG5cbmNvbnN0IHsgZWxsaXBzaXMgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZVBhcnQgZXh0ZW5kcyBOb25UZXJtaW5hbFBhcnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYWxsQUFoZWFkLCBydWxlTmFtZSkge1xuICAgIHN1cGVyKHR5cGUsIGNhbGxBQWhlYWQpO1xuXG4gICAgdGhpcy5ydWxlTmFtZSA9IHJ1bGVOYW1lO1xuICB9XG4gIFxuICBnZXRSdWxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlTmFtZTtcbiAgfVxuXG4gIGlzUnVsZU5hbWVQYXJ0KCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IHRydWU7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG5cbiAgZmluZFJ1bGUoc3RhdGUpIHtcbiAgICBjb25zdCBydWxlTWFwID0gc3RhdGUuZ2V0UnVsZU1hcCgpLFxuICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3RoaXMucnVsZU5hbWVdIHx8IG51bGw7ICAvLy9cblxuICAgIHJldHVybiBydWxlO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmZpbmRSdWxlKHN0YXRlKTtcblxuICAgIHBhcnNlZCA9IChydWxlICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICBydWxlLnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkgOlxuICAgICAgICAgICAgICAgICBmYWxzZTtcblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBjYWxsQUFoZWFkID0gdGhpcy5pc0NhbGxBaGVhZCgpLFxuICAgICAgICAgIGNhbGxBQWhlYWRTdHJpbmcgPSBjYWxsQUFoZWFkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbGlwc2lzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRU1QVFlfU1RSSU5HLFxuICAgICAgICAgIHN0cmluZyA9IGAke3RoaXMucnVsZU5hbWV9JHtjYWxsQUFoZWFkU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZShydWxlTmFtZSkge1xuICAgIGNvbnN0IHR5cGUgPSBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBQWhlYWQgPSBmYWxzZSxcbiAgICAgICAgICBydWxlTmFtZVBhcnQgPSBuZXcgUnVsZU5hbWVQYXJ0KHR5cGUsIGNhbGxBQWhlYWQsIHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBydWxlTmFtZVBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUNhbGxBaGVhZEFuZFJ1bGVOYW1lKGNhbGxBQWhlYWQsIHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IFJ1bGVOYW1lUGFydFR5cGUsXG4gICAgICAgICAgcnVsZU5hbWVQYXJ0ID0gbmV3IFJ1bGVOYW1lUGFydCh0eXBlLCBjYWxsQUFoZWFkLCBydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZUJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVDb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBydWxlTmFtZSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQsIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tQ2FsbEFoZWFkQW5kUnVsZU5hbWUoY2FsbEFoZWFkLCBydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSdWxlTmFtZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiO1xuXG5jb25zdCB7IHdpbGRjYXJkIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lsZGNhcmRQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGxldCB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuXHRcdFx0XHRcdHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgdGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlLmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHdpbGRjYXJkOyAgLy8vXG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHdpbGRjYXJkUGFydCA9IG5ldyBXaWxkY2FyZFBhcnQoKTtcblxuICAgIHJldHVybiB3aWxkY2FyZFBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFdpbGRjYXJkUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbC93aWxkY2FyZFwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWxkY2FyZEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgd2lsZGNhcmRQYXJ0ID0gV2lsZGNhcmRQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gd2lsZGNhcmRQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShXaWxkY2FyZEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuL3ZlcnRpY2FsQnJhbmNoXCI7XG5cbmNvbnN0IHsgZW5kT2ZMaW5lIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSBleHRlbmRzIFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGVuZE9mTGluZSwgLy8vXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKEVuZE9mTGluZU5vZGVQYXJzZVRyZWUsIHN0cmluZywgdmVydGljYWxCcmFuY2hQb3NpdGlvbik7XG5cbiAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUuYXBwZW5kVG9Ub3AodmVydGljYWxCcmFuY2hQYXJzZVRyZWUpO1xuXG4gICAgY29uc3QgZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZSA9IHRlcm1pbmFsTm9kZVBhcnNlVHJlZTsgLy8vXG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi90ZXJtaW5hbFwiO1xuaW1wb3J0IEVuZE9mTGluZU5vZGVQYXJzZVRyZWUgZnJvbSBcIi4uLy4uL3BhcnNlVHJlZS9lbmRPZkxpbmVOb2RlXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lTm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XG4gIGdldENvbnRlbnQoZmFpdGhmdWwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmYWl0aGZ1bCA/XG4gICAgICAgICAgICAgICAgICAgICAgc3VwZXIuZ2V0Q29udGVudCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORzsgLy8vXG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IGVuZE9mTGluZU5vZGVQYXJzZVRyZWUgPSBFbmRPZkxpbmVOb2RlUGFyc2VUcmVlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFyc2VUcmVlID0gZW5kT2ZMaW5lTm9kZVBhcnNlVHJlZTsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKSB7IHJldHVybiBUZXJtaW5hbE5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oRW5kT2ZMaW5lTm9kZSwgc2lnbmlmaWNhbnRUb2tlbik7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBFbmRPZkxpbmVOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1pbmFsL2VuZE9mTGluZVwiO1xuXG5jb25zdCB7IGVuZE9mTGluZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZE9mTGluZVBhcnQgZXh0ZW5kcyBUZXJtaW5hbFBhcnQge1xuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IGVuZE9mTGluZU5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlbkVuZE9mTGluZVRva2VuID0gc2lnbmlmaWNhbnRUb2tlbi5pc0VuZE9mTGluZVRva2VuKCk7XG5cbiAgICAgIGlmIChzaWduaWZpY2FudFRva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgZW5kT2ZMaW5lTm9kZSA9IEVuZE9mTGluZU5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKGVuZE9mTGluZU5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaChlbmRPZkxpbmVOb2RlKTtcblxuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBpZiAoY2FsbEFoZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VkID0gY2FsbEFoZWFkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBlbmRPZkxpbmU7IC8vL1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlbmRPZkxpbmVQYXJ0ID0gbmV3IEVuZE9mTGluZVBhcnQoKTtcblxuICAgIHJldHVybiBlbmRPZkxpbmVQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFbmRPZkxpbmVQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL2VuZE9mTGluZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmRPZkxpbmVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGVuZE9mTGluZVBhcnQgPSBFbmRPZkxpbmVQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRW5kT2ZMaW5lQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgU1BBQ0VfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0Q2hvaWNlIHtcbiAgY29uc3RydWN0b3IocGFydCwgcHJlY2VkZW5jZSkge1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFBhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydDtcbiAgfVxuXG4gIGdldFByZWNlZGVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZTtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmc7XG5cbiAgICBjb25zdCBwYXJ0U3RyaW5nID0gdGhpcy5wYXJ0LmFzU3RyaW5nKCk7XG5cbiAgICBzdHJpbmcgPSBwYXJ0U3RyaW5nOyAgLy8vXG5cbiAgICBpZiAodGhpcy5wcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQQUNFX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZTtcblxuICAgICAgc3RyaW5nID0gYCR7c3RyaW5nfSAoJHtwcmVjZWRlbmNlfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnQocGFydCkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHBhcnRDaG9pY2UgPSBuZXcgUGFydENob2ljZShwYXJ0LCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJ0Q2hvaWNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXJ0QW5kUHJlY2VkZW5jZShwYXJ0LCBwcmVjZWRlbmNlKSB7XG4gICAgY29uc3QgcGFydENob2ljZSA9IG5ldyBQYXJ0Q2hvaWNlKHBhcnQsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHBhcnRDaG9pY2U7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFBhcnRDaG9pY2UgZnJvbSBcIi4uLy4uL3BhcnRDaG9pY2VcIjtcbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydENob2ljZUJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnRDaG9pY2UoY2FsbEFoZWFkKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgcnVsZU5hbWUgPSBQQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHBhcnRCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBQUkVDRURFTkNFX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHByZWNlZGVuY2VCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgY2FsbEFoZWFkID0gZmFsc2U7ICAvLy9cblxuICAgIGNvbnN0IHBhcnQgPSBwYXJ0Qk5GTm9kZS5nZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gKHByZWNlZGVuY2VCTkZOb2RlID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VCTkZOb2RlLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICBkZWZpbml0aW9uID0gUGFydENob2ljZS5mcm9tUGFydEFuZFByZWNlZGVuY2UocGFydCwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUGFydENob2ljZUJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZWNlZGVuY2VCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0UHJlY2VkZW5jZSgpIHtcbiAgICBsZXQgcHJlY2VkZW5jZSA9IEluZmluaXR5O1xuXG4gICAgY29uc3QgbXVsdGlwbGljaXR5ID0gdGhpcy5nZXRNdWx0aXBsaWNpdHkoKTtcblxuICAgIGlmIChtdWx0aXBsaWNpdHkgPT09IDMpIHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICAgIHNlY29uZENoaWxkTm9kZSA9IHNlY29uZChjaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHByZWNlZGVuY2UgPSBOdW1iZXIoY29udGVudCk7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBwcmVjZWRlbmNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcmVjZWRlbmNlQk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhbnRpZmllckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFF1YW50aWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBjb25zdCBpbmRleCA9IDAsXG4gICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgIHBhcnRcbiAgICAgICAgXTtcblxuICBwYXJzZWQgPSBwYXJzZVBhcnRPZlBhcnRzKGluZGV4LCBwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJ0cyhwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gIGxldCBwYXJzZWQ7XG5cbiAgY29uc3QgaW5kZXggPSAwO1xuXG4gIHBhcnNlZCA9IHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgbGV0IHBhcnNlZDtcblxuICBjb25zdCBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICBpZiAoaW5kZXggPT09IHBhcnRzTGVuZ3RoKSB7XG4gICAgcGFyc2VkID0gKGNhbGxiYWNrICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICBjYWxsYmFjaygpIDpcbiAgICAgICAgICAgICAgICAgdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHNbaW5kZXhdLFxuICAgICAgICAgIHBhcnRDYWxsQWhlYWQgPSAoY2FsbEFoZWFkID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pc0NhbGxBaGVhZCgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWU7XG5cbiAgICBpbmRleCsrO1xuXG4gICAgcGFyc2VkID0gcGFydENhbGxBaGVhZCA/XG4gICAgICAgICAgICAgICBwYXJzZVBhcnRXaXRoQ2FsbEFoZWFkKHBhcnQsIGluZGV4LCBwYXJ0cywgbm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSA6XG4gICAgICAgICAgICAgICAgIHBhcnNlUGFydFdpdGhvdXRDYWxsQWhlYWQocGFydCwgaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0V2l0aENhbGxBaGVhZChwYXJ0LCBpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGNhbGxBaGVhZCA9ICgpID0+IHsgLy8vXG4gICAgbGV0IHBhcnNlZDtcblxuICAgIHBhcnNlZCA9IHBhcnNlUGFydE9mUGFydHMoaW5kZXgsIHBhcnRzLCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfTtcblxuICBwYXJzZWQgPSBwYXJ0LnBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgaWYgKCFwYXJzZWQpIHtcbiAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJ0V2l0aG91dENhbGxBaGVhZChwYXJ0LCBpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICBsZXQgcGFyc2VkO1xuXG4gIHBhcnNlZCA9IHBhcnQucGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKTtcblxuICBpZiAocGFyc2VkKSB7XG4gICAgcGFyc2VkID0gcGFyc2VQYXJ0T2ZQYXJ0cyhpbmRleCwgcGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBjaGFyYWN0ZXJzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBwYXJzZVBhcnRzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlXCI7XG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBTUEFDRV9DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJ0cywgcHJlY2VkZW5jZSkge1xuICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICB9XG5cbiAgZ2V0UGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cblxuICBnZXRQcmVjZWRlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLnByZWNlZGVuY2U7XG4gIH1cblxuICBwYXJzZShjaGlsZE5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBjb25zdCBub2RlcyA9IGNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgIHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCk7XG5cbiAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUuYmFja3RyYWNrKHNhdmVkSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBsZXQgc3RyaW5nO1xuXG4gICAgY29uc3QgcGFydHNTdHJpbmcgPSB0aGlzLnBhcnRzLnJlZHVjZSgocGFydHNTdHJpbmcsIHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRTdHJpbmcgPSBwYXJ0LmFzU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0c1N0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgIHBhcnRzU3RyaW5nID0gcGFydFN0cmluZzsgLy8vXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJ0c1N0cmluZyA9IGAke3BhcnRzU3RyaW5nfSAke3BhcnRTdHJpbmd9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzU3RyaW5nO1xuICAgICAgICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICBzdHJpbmcgPSBwYXJ0c1N0cmluZzsgLy8vXG5cbiAgICBpZiAodGhpcy5wcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVjZWRlbmNlID0gKHRoaXMucHJlY2VkZW5jZSA9PT0gSW5maW5pdHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNQQUNFX0NIQVJBQ1RFUiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZTtcblxuICAgICAgc3RyaW5nID0gYCR7c3RyaW5nfSAoJHtwcmVjZWRlbmNlfSlgO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnRzKENsYXNzLCBwYXJ0cykge1xuICAgIGlmIChwYXJ0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cyA9IENsYXNzOyAgLy8vXG5cbiAgICAgIENsYXNzID0gRGVmaW5pdGlvbjsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IG5ldyBDbGFzcyhwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydHNBbmRQcmVjZWRlbmNlKENsYXNzLCBwYXJ0cywgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBwYXJ0czsgLy8vXG5cbiAgICAgIHBhcnRzID0gQ2xhc3M7ICAvLy9cblxuICAgICAgQ2xhc3MgPSBEZWZpbml0aW9uOyAvLy9cbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gbmV3IENsYXNzKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lLCBub2Rlc0Zyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL25vZGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZURlZmluaXRpb24oKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXG4gICAgcnVsZU5hbWUgPSBQQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHBhcnRCTkZOb2RlcyA9IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZUJORk5vZGUgPSBub2RlRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSksXG4gICAgICAgICAgY2FsbEFoZWFkID0gZmFsc2UsICAvLy9cbiAgICAgICAgICBwYXJ0cyA9IHBhcnRCTkZOb2Rlcy5tYXAoKHBhcnRCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydEJORk5vZGUuZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCk7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IChwcmVjZWRlbmNlQk5GTm9kZSA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlQk5GTm9kZS5nZXRQcmVjZWRlbmNlKCksXG4gICAgICAgICAgZGVmaW5pdGlvbiA9IERlZmluaXRpb24uZnJvbVBhcnRzQW5kUHJlY2VkZW5jZShwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGVmaW5pdGlvbkJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IERFRklOSVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25zQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlRGVmaW5pdGlvbnMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBERUZJTklUSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgZGVmaW5pdGlvbkJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IGRlZmluaXRpb25CTkZOb2Rlcy5tYXAoKGRlZmluaXRpb25CTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmaW5pdGlvbkJORk5vZGUuZ2VuZXJhdGVEZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBkZWZpbml0aW9ucztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGVmaW5pdGlvbnNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsUGFydEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgbm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgcGFydCA9IG5vZGUuZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCk7XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVGVybWluYWxQYXJ0Qk5GTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWxcIjtcblxuaW1wb3J0IHsgcGFyc2VQYXJ0IH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wYXJzZVwiO1xuaW1wb3J0IHsgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlIH0gZnJvbSBcIi4uLy4uL3BhcnRUeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzUGFydCBleHRlbmRzIE5vblRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNhbGxBaGVhZCwgcGFydENob2ljZXMpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuICAgIFxuICAgIHRoaXMucGFydENob2ljZXMgPSBwYXJ0Q2hvaWNlcztcbiAgfVxuICBcbiAgZ2V0UGFydENob2ljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydENob2ljZXM7XG4gIH1cblxuICBnZXRQYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFydENob2ljZXMubWFwKChwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydENob2ljZS5nZXRQYXJ0KCk7XG5cbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGNvbnN0IHNhdmVkUHJlY2VkZW5jZSA9IHN0YXRlLmdldFNhdmVkUHJlY2VkZW5jZSgpO1xuXG4gICAgcGFyc2VkID0gdGhpcy5wYXJ0Q2hvaWNlcy5zb21lKChwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICBsZXQgcGFyc2VkO1xuXG4gICAgICBjb25zdCBwYXJ0ID0gcGFydENob2ljZS5nZXRQYXJ0KCksXG4gICAgICAgICAgICBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHBhcnRDaG9pY2UuZ2V0UHJlY2VkZW5jZSgpLFxuICAgICAgICAgICAgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChwcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLnNldFByZWNlZGVuY2UocHJlY2VkZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrID0gKGNhbGxBaGVhZCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgIHBhcnNlZCA9IHBhcnNlUGFydChwYXJ0LCBub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5vZGVzTGVuZ3RoOyAgLy8vXG5cbiAgICAgICAgbm9kZXMuc3BsaWNlKHN0YXJ0KTtcblxuICAgICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgc3RhdGUucmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRDaG9pY2VzU3RyaW5nID0gdGhpcy5wYXJ0Q2hvaWNlcy5yZWR1Y2UoKHBhcnRDaG9pY2VzU3RyaW5nLCBwYXJ0Q2hvaWNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q2hvaWNlU3RyaW5nID0gcGFydENob2ljZS5hc1N0cmluZygpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHBhcnRDaG9pY2VzU3RyaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnRDaG9pY2VzU3RyaW5nID0gcGFydENob2ljZVN0cmluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnRDaG9pY2VzU3RyaW5nID0gYCR7cGFydENob2ljZXNTdHJpbmd9IHwgJHtwYXJ0Q2hvaWNlU3RyaW5nfWA7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcGFydENob2ljZXNTdHJpbmc7XG4gICAgICAgICAgfSwgbnVsbCksXG4gICAgICAgICAgc3RyaW5nID0gYCggJHtwYXJ0Q2hvaWNlc1N0cmluZ30gKWA7XG4gICAgXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGFydENob2ljZXMocGFydENob2ljZXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIGNob2ljZU9mUGFydHNQYXJ0ID0gbmV3IENob2ljZU9mUGFydHNQYXJ0KHR5cGUsIGNhbGxBaGVhZCwgcGFydENob2ljZXMpO1xuXG4gICAgcmV0dXJuIGNob2ljZU9mUGFydHNQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBDaG9pY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9jaG9pY2VPZlBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdlbmVyYXRlUGFydChjYWxsQWhlYWQpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgcGFydENob2ljZUJORk5vZGVzID0gbm9kZXNGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lKGNoaWxkTm9kZXMsIHJ1bGVOYW1lKTtcblxuICAgIGNhbGxBaGVhZCA9IGZhbHNlOyAgLy8vXG5cbiAgICBjb25zdCBwYXJ0Q2hvaWNlcyA9IHBhcnRDaG9pY2VCTkZOb2Rlcy5tYXAoKHBhcnRDaG9pY2VCTkZOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0Q2hvaWNlID0gcGFydENob2ljZUJORk5vZGUuZ2VuZXJhdGVQYXJ0Q2hvaWNlKGNhbGxBaGVhZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q2hvaWNlO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNob2ljZU9mUGFydHNQYXJ0ID0gQ2hvaWNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRDaG9pY2VzKHBhcnRDaG9pY2VzKSxcbiAgICAgICAgICBwYXJ0ID0gY2hvaWNlT2ZQYXJ0c1BhcnQ7IC8vL1xuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENob2ljZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IHRlcm1pbmFsTm9kZSA9IG51bGw7XG4gICAgXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBuZXh0U2lnbmlmaWNhbnRUb2tlbiA9IHN0YXRlLmdldE5leHRTaWduaWZpY2FudFRva2VuKCksXG5cdFx0XHRcdFx0c2lnbmlmaWNhbnRUb2tlbiA9IG5leHRTaWduaWZpY2FudFRva2VuOyAvLy9cblxuICAgIGlmIChzaWduaWZpY2FudFRva2VuICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlLmZyb21TaWduaWZpY2FudFRva2VuKHNpZ25pZmljYW50VG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBcbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC5yZXBsYWNlKC9cXFxcLywgXCJcXFxcXFxcXFwiKSxcbiAgICAgICAgICBzdHJpbmcgPSBgXCIke2NvbnRlbnR9XCJgO1xuICAgIFxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWxQYXJ0ID0gbmV3IFN0cmluZ0xpdGVyYWxQYXJ0KGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBFU0NBUEVEX0JBQ0tTTEFTSCwgRVNDQVBFRF9ET1VCTEVfUVVPVEUgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmluZ0xpdGVyYWxCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmVndWxhckV4cHJlc3Npb24gPSAvXlwiKCg/OlxcXFwufFteXCJcXFxcXSkqKVwiJC87XG5cbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxQYXJ0O1xuICB9XG5cbiAgZ2V0Q29udGVudCgpIHtcbiAgICBsZXQgY29udGVudDtcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZUNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbiksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBjb250ZW50ID0gc2Vjb25kTWF0Y2g7ICAvLy9cblxuICAgIGNvbnRlbnQgPSBzYW5pdGlzZUNvbnRlbnQoY29udGVudCk7XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU3RyaW5nTGl0ZXJhbEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGlzZUNvbnRlbnQoY29udGVudCkge1xuICBjb250ZW50ID0gY29udGVudFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgRVNDQVBFRF9CQUNLU0xBU0gpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgRVNDQVBFRF9ET1VCTEVfUVVPVEUpO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVGcm9tQ2hpbGROb2Rlc0FuZFJ1bGVOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKTtcblxuICAgIGlmICghY2FsbEFoZWFkKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlID0gbm9kZUZyb21DaGlsZE5vZGVzQW5kUnVsZU5hbWUoY2hpbGROb2RlcywgcnVsZU5hbWUpO1xuXG4gICAgICBjYWxsQWhlYWQgPSAoY2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIG5vZGUgPSBmaXJzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgIHBhcnQgPSBub2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKE5vblRlcm1pbmFsUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IHBhcnNlUGFydHMgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3BhcnNlXCI7XG5pbXBvcnQgeyBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSB9IGZyb20gXCIuLi8uLi9wYXJ0VHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VxdWVuY2VPZlBhcnRzUGFydCBleHRlbmRzIE5vblRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNhbGxBaGVhZCwgcGFydHMpIHtcbiAgICBzdXBlcih0eXBlLCBjYWxsQWhlYWQpO1xuXG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICB9XG5cbiAgZ2V0UGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGNhbGxiYWNrID0gKGNhbGxBaGVhZCA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICgpID0+IHsgIC8vL1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICBwYXJzZWQgPSBwYXJzZVBhcnRzKHRoaXMucGFydHMsIG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub2Rlc0xlbmd0aDsgIC8vL1xuXG4gICAgICBub2Rlcy5zcGxpY2Uoc3RhcnQpO1xuXG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHBhcnRzU3RyaW5nID0gdGhpcy5wYXJ0cy5yZWR1Y2UoKHBhcnRzU3RyaW5nLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0U3RyaW5nID0gcGFydC5hc1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAocGFydHNTdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFydHNTdHJpbmcgPSBwYXJ0U3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFydHNTdHJpbmcgPSBgJHtwYXJ0c1N0cmluZ30gJHtwYXJ0U3RyaW5nfWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0c1N0cmluZztcbiAgICAgICAgICB9LCBudWxsKSxcbiAgICAgICAgICBzdHJpbmcgPSBgKCAke3BhcnRzU3RyaW5nfSApYDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgY29uc3QgdHlwZSA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICAgIGNhbGxBaGVhZCA9IGZhbHNlLFxuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBuZXcgU2VxdWVuY2VPZlBhcnRzUGFydCh0eXBlLCBjYWxsQWhlYWQsIHBhcnRzKTtcblxuICAgIHJldHVybiBzZXF1ZW5jZU9mUGFydHNQYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBTZXF1ZW5jZU9mUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBQQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZU9mUGFydHNCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICAgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHBhcnRCTkZOb2RlcyA9IG5vZGVzRnJvbUNoaWxkTm9kZXNBbmRSdWxlTmFtZShjaGlsZE5vZGVzLCBydWxlTmFtZSk7XG5cbiAgICBjYWxsQWhlYWQgPSBmYWxzZTsgIC8vL1xuXG4gICAgY29uc3QgcGFydHMgPSBwYXJ0Qk5GTm9kZXMubWFwKChwYXJ0Qk5GTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRCTkZOb2RlLmdlbmVyYXRlUGFydChjYWxsQWhlYWQpO1xuXG4gICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gU2VxdWVuY2VPZlBhcnRzUGFydC5mcm9tUGFydHMocGFydHMpLFxuICAgICAgICAgIHBhcnQgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0OyAvLy9cblxuICAgIHJldHVybiBwYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTZXF1ZW5jZU9mUGFydHNCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcblxuY29uc3QgeyBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0T3BhY2l0eSgpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5nZXRDaGlsZE5vZGVzKCksXG4gICAgICAgICAgc2Vjb25kQ2hpbGROb2RlID0gc2Vjb25kKGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgb3BhY2l0eSA9IHRlcm1pbmFsTm9kZUNvbnRlbnQ7ICAvLy9cblxuICAgIHJldHVybiBvcGFjaXR5O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPcGFjaXR5TW9kaWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSBmcm9tIFwiLi92ZXJ0aWNhbEJyYW5jaFwiO1xuXG5jb25zdCB7IG5vV2hpdGVzcGFjZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBub1doaXRlc3BhY2UsIC8vL1xuICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWVXaWR0aCA9IHN0cmluZ0xlbmd0aCwgLy8vXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tV2lkdGgodmVydGljYWxCcmFuY2hQYXJzZVRyZWVXaWR0aCksXG4gICAgICAgICAgdmVydGljYWxCcmFuY2hQb3NpdGlvbiA9IHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmdldFZlcnRpY2FsQnJhbmNoUG9zaXRpb24oKSxcbiAgICAgICAgICB0ZXJtaW5hbE5vZGVQYXJzZVRyZWUgPSBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZS5mcm9tU3RyaW5nQW5kVmVydGljYWxCcmFuY2hQb3NpdGlvbihOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlLCBzdHJpbmcsIHZlcnRpY2FsQnJhbmNoUG9zaXRpb24pO1xuXG4gICAgdGVybWluYWxOb2RlUGFyc2VUcmVlLmFwcGVuZFRvVG9wKHZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlKTtcblxuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vdGVybWluYWxcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlIGZyb20gXCIuLi8uLi9wYXJzZVRyZWUvbm9XaGl0ZXNwYWNlTm9kZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZU5vZGUgZXh0ZW5kcyBUZXJtaW5hbE5vZGUge1xuICBnZXRUeXBlKCkge1xuICAgIGNvbnN0IHR5cGUgPSBudWxsOyAgLy8vXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgY29uc3QgY29udGVudCA9IEVNUFRZX1NUUklORztcblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaXNOb1doaXRlc3BhY2VOb2RlKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZU5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZU5vZGU7XG4gIH1cblxuICBhc1BhcnNlVHJlZSh0b2tlbnMpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VOb2RlUGFyc2VUcmVlID0gTm9XaGl0ZXNwYWNlTm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IG5vV2hpdGVzcGFjZU5vZGVQYXJzZVRyZWU7ICAvLy9cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBtYXRjaChub2RlLCBkZXB0aCkge1xuICAgIGxldCBtYXRjaGVzID0gZmFsc2U7XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGUsICAvLy9cbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZU5vV2hpdGVzcGFjZU5vZGUgPSB0ZXJtaW5hbE5vZGUuaXNOb1doaXRlc3BhY2VOb2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVOb1doaXRlc3BhY2VOb2RlKSB7XG4gICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gVGVybWluYWxOb2RlLmZyb21Ob3RoaW5nKE5vV2hpdGVzcGFjZU5vZGUpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcblxuY29uc3QgeyBub1doaXRlc3BhY2UgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb1doaXRlc3BhY2VQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgaXNOb1doaXRlc3BhY2VQYXJ0KCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IG5vV2hpdGVzcGFjZU5vZGUgPSBudWxsO1xuXG4gICAgY29uc3Qgc2F2ZWRJbmRleCA9IHN0YXRlLmdldFNhdmVkSW5kZXgoKSxcbiAgICAgICAgICBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBzdGF0ZS5pc05leHRUb2tlbldoaXRlc3BhY2VUb2tlbigpO1xuXG4gICAgaWYgKCFuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4pIHtcbiAgICAgIG5vV2hpdGVzcGFjZU5vZGUgPSBOb1doaXRlc3BhY2VOb2RlLmZyb21Ob3RoaW5nKCk7XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKG5vV2hpdGVzcGFjZU5vZGUgIT09IG51bGwpXG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBub2Rlcy5wdXNoKG5vV2hpdGVzcGFjZU5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IG5vV2hpdGVzcGFjZTsgLy8vXG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSBuZXcgTm9XaGl0ZXNwYWNlUGFydCgpO1xuXG4gICAgcmV0dXJuIG5vV2hpdGVzcGFjZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnRCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IG5vV2hpdGVzcGFjZVBhcnQgPSBOb1doaXRlc3BhY2VQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbGxBaGVhZE1vZGlmaWVyQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBUZXJtaW5hbFBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWxcIjtcbmltcG9ydCBUZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvdGVybWluYWxcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMucmVndWxhckV4cHJlc3Npb24gPSByZWd1bGFyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ3VsYXJFeHByZXNzaW9uO1xuICB9XG5cbiAgcGFyc2Uobm9kZXMsIHN0YXRlLCBjYWxsYmFjaywgY2FsbEFoZWFkKSB7XG4gICAgbGV0IHBhcnNlZDtcblxuICAgIGxldCB0ZXJtaW5hbE5vZGUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IHNhdmVkSW5kZXggPSBzdGF0ZS5nZXRTYXZlZEluZGV4KCksXG4gICAgICAgICAgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBzdGF0ZS5nZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpLFxuXHRcdFx0XHRcdHNpZ25pZmljYW50VG9rZW4gPSBuZXh0U2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgICBpZiAoc2lnbmlmaWNhbnRUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHNpZ25pZmljYW50VG9rZW4uZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBmaXJzdChtYXRjaGVzKTtcblxuICAgICAgICBpZiAoZmlyc3RNYXRjaCA9PT0gY29udGVudCkge1xuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IFRlcm1pbmFsTm9kZS5mcm9tU2lnbmlmaWNhbnRUb2tlbihzaWduaWZpY2FudFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9ICh0ZXJtaW5hbE5vZGUgIT09IG51bGwpO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaCh0ZXJtaW5hbE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nID0gdGhpcy5yZWd1bGFyRXhwcmVzc2lvbi50b1N0cmluZygpLFxuXHRcdCAgICAgIHN0cmluZyA9IHJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nOyAvLy9cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlZ3VsYXJFeHByZXNzaW9uKHJlZ3VsYXJFeHByZXNzaW9uKSB7XG4gICAgY29uc3QgcmVndWxhckV4cHJlc3Npb25QYXJ0ID0gbmV3IFJlZ3VsYXJFeHByZXNzaW9uUGFydChyZWd1bGFyRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25QYXJ0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgUmVndWxhckV4cHJlc3Npb25QYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3JlZ3VsYXJFeHByZXNzaW9uXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ3VsYXJFeHByZXNzaW9uQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJlZ3VsYXJFeHByZXNzaW9uID0gL15cXC8oKD86XFxcXC58W15cXC9dKSopXFwvJC87XG5cbiAgZ2VuZXJhdGVQYXJ0KGNhbGxBaGVhZCkge1xuICAgIGNvbnN0IHJlZ3VsYXJFeHByZXNzaW9uID0gdGhpcy5nZXRSZWd1bGFyRXhwcmVzc2lvbigpLFxuICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUGFydCA9IFJlZ3VsYXJFeHByZXNzaW9uUGFydC5mcm9tUmVndWxhckV4cHJlc3Npb24ocmVndWxhckV4cHJlc3Npb24pO1xuXG4gICAgcmV0dXJuIHJlZ3VsYXJFeHByZXNzaW9uUGFydDtcbiAgfVxuXG4gIGdldFJlZ3VsYXJFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdENoaWxkTm9kZSA9IGZpcnN0KGNoaWxkTm9kZXMpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZUNvbnRlbnQubWF0Y2godGhpcy5yZWd1bGFyRXhwcmVzc2lvbiksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyksXG4gICAgICAgICAgcGF0dGVybiA9IHNlY29uZE1hdGNoLCAvLy9cbiAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocGF0dGVybik7ICAvLy9cblxuICAgIHJldHVybiByZWd1bGFyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlIGZyb20gXCIuL3ZlcnRpY2FsQnJhbmNoXCI7XG5cbmNvbnN0IHsgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFydE9mQ29udGVudE5vZGVQYXJzZVRyZWUgZXh0ZW5kcyBWZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBzdGFydE9mQ29udGVudCwgLy8vXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoID0gc3RyaW5nTGVuZ3RoLCAvLy9cbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21XaWR0aCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZVdpZHRoKSxcbiAgICAgICAgICB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uID0gdmVydGljYWxCcmFuY2hQYXJzZVRyZWUuZ2V0VmVydGljYWxCcmFuY2hQb3NpdGlvbigpLFxuICAgICAgICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZSA9IFZlcnRpY2FsQnJhbmNoUGFyc2VUcmVlLmZyb21TdHJpbmdBbmRWZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSwgc3RyaW5nLCB2ZXJ0aWNhbEJyYW5jaFBvc2l0aW9uKTtcblxuICAgIHRlcm1pbmFsTm9kZVBhcnNlVHJlZS5hcHBlbmRUb1RvcCh2ZXJ0aWNhbEJyYW5jaFBhcnNlVHJlZSk7XG5cbiAgICBjb25zdCBzdGFydE9mQ29udGVudE5vZGVQYXJzZVRyZWUgPSB0ZXJtaW5hbE5vZGVQYXJzZVRyZWU7IC8vL1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi90ZXJtaW5hbFwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSBmcm9tIFwiLi4vLi4vcGFyc2VUcmVlL3N0YXJ0T2ZDb250ZW50Tm9kZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50Tm9kZSBleHRlbmRzIFRlcm1pbmFsTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgY29uc3QgdHlwZSA9IG51bGw7ICAvLy9cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0Q29udGVudCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpc1N0YXJ0T2ZDb250ZW50Tm9kZSgpIHtcbiAgICBjb25zdCBzdGFydE9mQ29udGVudE5vZGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50Tm9kZTtcbiAgfVxuXG4gIGFzUGFyc2VUcmVlKHRva2Vucykge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZSA9IFN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnNlVHJlZSA9IHN0YXJ0T2ZDb250ZW50Tm9kZVBhcnNlVHJlZTsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlVHJlZTtcbiAgfVxuXG4gIG1hdGNoKG5vZGUsIGRlcHRoKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgICAgdGVybWluYWxOb2RlU3RhcnRPZkNvbnRlbnROb2RlID0gdGVybWluYWxOb2RlLmlzU3RhcnRPZkNvbnRlbnROb2RlKCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVTdGFydE9mQ29udGVudE5vZGUpIHtcbiAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBUZXJtaW5hbE5vZGUuZnJvbU5vdGhpbmcoU3RhcnRPZkNvbnRlbnROb2RlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFRlcm1pbmFsUGFydCBmcm9tIFwiLi4vLi4vcGFydC90ZXJtaW5hbFwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50Tm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtaW5hbC9zdGFydE9mQ29udGVudFwiO1xuXG5jb25zdCB7IHN0YXJ0T2ZDb250ZW50IH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhcnRPZkNvbnRlbnRQYXJ0IGV4dGVuZHMgVGVybWluYWxQYXJ0IHtcbiAgaXNTdGFydE9mQ29udGVudFBhcnQoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gdHJ1ZTtcblxuICAgIHJldHVybiBzdGFydE9mQ29udGVudFBhcnQ7XG4gIH1cblxuICBwYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpIHtcbiAgICBsZXQgcGFyc2VkO1xuXG4gICAgbGV0IHN0YXJ0T2ZDb250ZW50Tm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIGF0U3RhcnRPZkNvbnRlbnQgPSBzdGF0ZS5pc0F0U3RhcnRPZkNvbnRlbnQoKTtcblxuICAgIGlmIChhdFN0YXJ0T2ZDb250ZW50KSB7XG4gICAgICBzdGFydE9mQ29udGVudE5vZGUgPSBTdGFydE9mQ29udGVudE5vZGUuZnJvbU5vdGhpbmcoKTtcbiAgICB9XG5cbiAgICBwYXJzZWQgPSAoc3RhcnRPZkNvbnRlbnROb2RlICE9PSBudWxsKVxuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgbm9kZXMucHVzaChzdGFydE9mQ29udGVudE5vZGUpO1xuXG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGlmIChjYWxsQWhlYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZWQgPSBjYWxsQWhlYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2soc2F2ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IHN0YXJ0T2ZDb250ZW50OyAvLy9cblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gbmV3IFN0YXJ0T2ZDb250ZW50UGFydCgpO1xuXG4gICAgcmV0dXJuIHN0YXJ0T2ZDb250ZW50UGFydDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5pbXBvcnQgU3RhcnRPZkNvbnRlbnRQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsL3N0YXJ0T2ZDb250ZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50UGFydEJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgc3RhcnRPZkNvbnRlbnRQYXJ0ID0gU3RhcnRPZkNvbnRlbnRQYXJ0LmZyb21Ob3RoaW5nKCk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0O1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTdGFydE9mQ29udGVudFBhcnRCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPbmVPck1vcmVRdWFudGlmaWVyQk5GTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoT25lT3JNb3JlUXVhbnRpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGVybWluYWxQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L3Rlcm1pbmFsXCI7XG5pbXBvcnQgVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBleHRlbmRzIFRlcm1pbmFsUGFydCB7XG4gIGNvbnN0cnVjdG9yKHNpZ25pZmljYW50VG9rZW5UeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlblR5cGU7XG4gIH1cblxuICBnZXRTaWduaWZpY2FudFRva2VuVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZTtcbiAgfVxuXG4gIHBhcnNlKG5vZGVzLCBzdGF0ZSwgY2FsbGJhY2ssIGNhbGxBaGVhZCkge1xuICAgIGxldCBwYXJzZWQ7XG5cbiAgICBsZXQgdGVybWluYWxOb2RlID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBzYXZlZEluZGV4ID0gc3RhdGUuZ2V0U2F2ZWRJbmRleCgpLFxuICAgICAgICAgIG5leHRTaWduaWZpY2FudFRva2VuID0gc3RhdGUuZ2V0TmV4dFNpZ25pZmljYW50VG9rZW4oKSxcblx0XHRcdFx0XHRzaWduaWZpY2FudFRva2VuID0gbmV4dFNpZ25pZmljYW50VG9rZW47IC8vL1xuXG4gICAgaWYgKHNpZ25pZmljYW50VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gc2lnbmlmaWNhbnRUb2tlbi5nZXRUeXBlKCk7XG5cbiAgICAgIGlmIChzaWduaWZpY2FudFRva2VuVHlwZSA9PT0gdGhpcy5zaWduaWZpY2FudFRva2VuVHlwZSkge1xuICAgICAgICB0ZXJtaW5hbE5vZGUgPSBUZXJtaW5hbE5vZGUuZnJvbVNpZ25pZmljYW50VG9rZW4oc2lnbmlmaWNhbnRUb2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2VkID0gKHRlcm1pbmFsTm9kZSAhPT0gbnVsbCk7XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBub2Rlcy5wdXNoKHRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgaWYgKGNhbGxBaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlZCA9IGNhbGxBaGVhZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHN0YXRlLmJhY2t0cmFjayhzYXZlZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgYXNTdHJpbmcoKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gYFske3RoaXMuc2lnbmlmaWNhbnRUb2tlblR5cGV9XWA7XG4gICAgXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBuZXcgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KHNpZ25pZmljYW50VG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBOb25UZXJtaW5hbE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvbm9uVGVybWluYWxcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuY29uc3QgeyBmaXJzdCwgc2Vjb25kIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgcmVndWxhckV4cHJlc3Npb24gPSAvXlxcWyhbXlxcXV0rKV0kLztcblxuICBnZW5lcmF0ZVBhcnQoY2FsbEFoZWFkKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0aGlzLmdldFNpZ25pZmljYW50VG9rZW5UeXBlKCksXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0O1xuICB9XG5cbiAgZ2V0U2lnbmlmaWNhbnRUb2tlblR5cGUoKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIGZpcnN0Q2hpbGROb2RlID0gZmlyc3QoY2hpbGROb2RlcyksXG4gICAgICAgICAgdGVybWluYWxOb2RlID0gZmlyc3RDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVDb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICBtYXRjaGVzID0gdGVybWluYWxOb2RlQ29udGVudC5tYXRjaCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uKSxcbiAgICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKSxcbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZSA9IHNlY29uZE1hdGNoOyAvLy9cblxuICAgIHJldHVybiBzaWduaWZpY2FudFRva2VuVHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGU7XG5cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlIGZyb20gXCIuLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFplcm9yT3JNb3JlUXVhbnRpZmllckJORk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFplcm9yT3JNb3JlUXVhbnRpZmllckJORk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFydEJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvcGFydFwiO1xuaW1wb3J0IE5hbWVCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL25hbWVcIjtcbmltcG9ydCBSdWxlQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ydWxlXCI7XG5pbXBvcnQgRXJyb3JCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL2Vycm9yXCI7XG5pbXBvcnQgRXBzaWxvbkJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZXBzaWxvblwiO1xuaW1wb3J0IERvY3VtZW50Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9kb2N1bWVudFwiO1xuaW1wb3J0IFJ1bGVOYW1lQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ydWxlTmFtZVwiO1xuaW1wb3J0IFdpbGRjYXJkQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi93aWxkY2FyZFwiO1xuaW1wb3J0IEVuZE9mTGluZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgUGFydENob2ljZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvcGFydENob2ljZVwiO1xuaW1wb3J0IFByZWNlZGVuY2VCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3ByZWNlZGVuY2VcIjtcbmltcG9ydCBRdWFudGlmaWVyQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9xdWFudGlmaWVyXCI7XG5pbXBvcnQgRGVmaW5pdGlvbkJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvZGVmaW5pdGlvblwiO1xuaW1wb3J0IERlZmluaXRpb25zQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9kZWZpbml0aW9uc1wiO1xuaW1wb3J0IFRlcm1pbmFsUGFydEJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvdGVybWluYWxQYXJ0XCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0JORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCBCb25UZXJtaW5hbFBhcnRCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL25vblRlcm1pbmFsUGFydFwiO1xuaW1wb3J0IFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvc2VxdWVuY2VPZlBhcnRzXCI7XG5pbXBvcnQgT3BhY2l0eU1vZGlmaWVyQk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9vcGFjaXR5TW9kaWZpZXJcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VQYXJ0Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5pbXBvcnQgQ2FsbEFoZWFkTW9kaWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL2NhbGxBaGVhZE1vZGlmaWVyXCI7XG5pbXBvcnQgUmVndWxhckV4cHJlc3Npb25CTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL3JlZ3VsYXJFeHByZXNzaW9uXCI7XG5pbXBvcnQgU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GTm9kZSBmcm9tIFwiLi9ub2RlL2JuZi9zdGFydE9mQ29udGVudFBhcnRcIjtcbmltcG9ydCBPcHRpb25hbFF1YW50aWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL29wdGlvbmFsUXVhbnRpZmllclwiO1xuaW1wb3J0IE9uZU9yTW9yZVF1YW50aWZpZXJCTkZOb2RlIGZyb20gXCIuL25vZGUvYm5mL29uZU9uZU9yTW9yZVF1YW50aWZpZXJcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZUJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcbmltcG9ydCBaZXJvT3JNb3JlUXVhbnRpZmllckJORk5vZGUgZnJvbSBcIi4vbm9kZS9ibmYvemVyb09uZU9yTW9yZVF1YW50aWZpZXJcIjtcblxuaW1wb3J0IHsgTkFNRV9SVUxFX05BTUUsXG4gICAgICAgICBQQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFJVTEVfUlVMRV9OQU1FLFxuICAgICAgICAgRVJST1JfUlVMRV9OQU1FLFxuICAgICAgICAgRVBTSUxPTl9SVUxFX05BTUUsXG4gICAgICAgICBET0NVTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBXSUxEQ0FSRF9SVUxFX05BTUUsXG4gICAgICAgICBSVUxFX05BTUVfUlVMRV9OQU1FLFxuICAgICAgICAgREVGSU5JVElPTl9SVUxFX05BTUUsXG4gICAgICAgICBQUkVDRURFTkNFX1JVTEVfTkFNRSxcbiAgICAgICAgIFFVQU5USUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgRU5EX09GX0xJTkVfUlVMRV9OQU1FLFxuICAgICAgICAgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgREVGSU5JVElPTlNfUlVMRV9OQU1FLFxuICAgICAgICAgVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBTVFJJTkdfTElURVJBTF9SVUxFX05BTUUsXG4gICAgICAgICBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FLFxuICAgICAgICAgT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUUsXG4gICAgICAgICBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUsXG4gICAgICAgICBOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FLFxuICAgICAgICAgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FLFxuICAgICAgICAgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsXG4gICAgICAgICBTVEFSVF9PRl9DT05URU5UX1BBUlRfUlVMRV9OQU1FLFxuICAgICAgICAgU0lHTklGSUNBTlRfVE9LRU5fVFlQRV9SVUxFX05BTUUsXG4gICAgICAgICBPTkVfT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSxcbiAgICAgICAgIFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuXG5jb25zdCBOb25UZXJtaW5hbE5vZGVNYXAgPSB7XG4gIFtOQU1FX1JVTEVfTkFNRV06IE5hbWVCTkZOb2RlLFxuICBbUEFSVF9SVUxFX05BTUVdOiBQYXJ0Qk5GTm9kZSxcbiAgW1JVTEVfUlVMRV9OQU1FXTogUnVsZUJORk5vZGUsXG4gIFtFUlJPUl9SVUxFX05BTUVdOiBFcnJvckJORk5vZGUsXG4gIFtFUFNJTE9OX1JVTEVfTkFNRV06IEVwc2lsb25CTkZOb2RlLFxuICBbRE9DVU1FTlRfUlVMRV9OQU1FXTogRG9jdW1lbnRCTkZOb2RlLFxuICBbV0lMRENBUkRfUlVMRV9OQU1FXTogV2lsZGNhcmRCTkZOb2RlLFxuICBbUlVMRV9OQU1FX1JVTEVfTkFNRV06IFJ1bGVOYW1lQk5GTm9kZSxcbiAgW0RFRklOSVRJT05fUlVMRV9OQU1FXTogRGVmaW5pdGlvbkJORk5vZGUsXG4gIFtQUkVDRURFTkNFX1JVTEVfTkFNRV06IFByZWNlZGVuY2VCTkZOb2RlLFxuICBbUVVBTlRJRklFUl9SVUxFX05BTUVdOiBRdWFudGlmaWVyQk5GTm9kZSxcbiAgW0VORF9PRl9MSU5FX1JVTEVfTkFNRV06IEVuZE9mTGluZUJORk5vZGUsXG4gIFtQQVJUX0NIT0lDRV9SVUxFX05BTUVdOiBQYXJ0Q2hvaWNlQk5GTm9kZSxcbiAgW0RFRklOSVRJT05TX1JVTEVfTkFNRV06IERlZmluaXRpb25zQk5GTm9kZSxcbiAgW1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FXTogVGVybWluYWxQYXJ0Qk5GTm9kZSxcbiAgW1NUUklOR19MSVRFUkFMX1JVTEVfTkFNRV06IFN0cmluZ0xpdGVyYWxCTkZOb2RlLFxuICBbQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRV06IENob2ljZU9mUGFydHNCTkZOb2RlLFxuICBbT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUVdOiBPcGFjaXR5TW9kaWZpZXJCTkZOb2RlLFxuICBbTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FXTogQm9uVGVybWluYWxQYXJ0Qk5GTm9kZSxcbiAgW1NFUVVFTkNFX09GX1BBUlRTX1JVTEVfTkFNRV06IFNlcXVlbmNlT2ZQYXJ0c0JORk5vZGUsXG4gIFtOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FXTogTm9XaGl0ZXNwYWNlUGFydEJORk5vZGUsXG4gIFtSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FXTogUmVndWxhckV4cHJlc3Npb25CTkZOb2RlLFxuICBbQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUVdOiBDYWxsQWhlYWRNb2RpZmllckJORk5vZGUsXG4gIFtPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRV06IE9wdGlvbmFsUXVhbnRpZmllckJORk5vZGUsXG4gIFtTVEFSVF9PRl9DT05URU5UX1BBUlRfUlVMRV9OQU1FXTogU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GTm9kZSxcbiAgW1NJR05JRklDQU5UX1RPS0VOX1RZUEVfUlVMRV9OQU1FXTogU2lnbmlmaWNhbnRUb2tlblR5cGVCTkZOb2RlLFxuICBbT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUVdOiBPbmVPck1vcmVRdWFudGlmaWVyQk5GTm9kZSxcbiAgW1pFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRV06IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GTm9kZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9uVGVybWluYWxOb2RlTWFwOyIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcihpbmRleCwgdG9rZW5zLCBydWxlTWFwLCBwcmVjZWRlbmNlLCBzdGFydE9mQ29udGVudCwgTm9uVGVybWluYWxOb2RlTWFwLCBkZWZhdWx0Tm9uVGVybWluYWxOb2RlKSB7XG5cdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIHRoaXMucnVsZU1hcCA9IHJ1bGVNYXA7XG4gICAgdGhpcy5wcmVjZWRlbmNlID0gcHJlY2VkZW5jZTtcbiAgICB0aGlzLnN0YXJ0T2ZDb250ZW50ID0gc3RhcnRPZkNvbnRlbnQ7XG4gICAgdGhpcy5Ob25UZXJtaW5hbE5vZGVNYXAgPSBOb25UZXJtaW5hbE5vZGVNYXA7XG4gICAgdGhpcy5kZWZhdWx0Tm9uVGVybWluYWxOb2RlID0gZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4O1xuICB9XG5cbiAgZ2V0VG9rZW5zKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfVxuXG4gIGdldFJ1bGVNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU1hcDtcbiAgfVxuXG4gIGdldFByZWNlZGVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZTtcbiAgfVxuXG4gIGdldFN0YXJ0T2ZDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZDb250ZW50O1xuICB9XG5cbiAgZ2V0Tm9uVGVybWluYWxOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLk5vblRlcm1pbmFsTm9kZU1hcDtcbiAgfVxuXG4gIGdldERlZmF1bHROb25UZXJtaW5hbE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHNldEluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG5cbiAgc2V0VG9rZW5zKHRva2Vucykge1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgc2V0UnVsZU1hcChydWxlTWFwKSB7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIHNldFByZWNlZGVuY2UocHJlY2VkZW5jZSkge1xuICAgIHRoaXMucHJlY2VkZW5jZSA9IHByZWNlZGVuY2U7XG4gIH1cblxuICBzZXRTdGFydE9mQ29udGVudChzdGFydE9mQ29udGVudCkge1xuICAgIHRoaXMuc3RhcnRPZkNvbnRlbnQgPSBzdGFydE9mQ29udGVudDtcbiAgfVxuXG4gIGdldFNhdmVkUHJlY2VkZW5jZSgpIHtcbiAgICBjb25zdCBzYXZlZFByZWNlZGVuY2UgPSB0aGlzLnByZWNlZGVuY2U7XG5cbiAgICByZXR1cm4gc2F2ZWRQcmVjZWRlbmNlO1xuICB9XG5cbiAgZ2V0U2F2ZWRJbmRleCgpIHtcbiAgICBjb25zdCBzYXZlZEluZGV4ID0gdGhpcy5pbmRleDsgLy8vXG4gIFxuICAgIHJldHVybiBzYXZlZEluZGV4O1xuICB9XG5cbiAgZ2V0TmV4dFRva2VuKCkge1xuICAgIGxldCBuZXh0VG9rZW4gPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgICAgIG5leHRUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXgrK107XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRUb2tlbjtcbiAgfVxuXG4gIGlzQXRTdGFydE9mQ29udGVudCgpIHtcbiAgICBjb25zdCBhdFN0YXJ0T2ZDb250ZW50ID0gdGhpcy5zdGFydE9mQ29udGVudCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pbmRleCA9PT0gMCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuXG4gICAgcmV0dXJuIGF0U3RhcnRPZkNvbnRlbnQ7XG4gIH1cblxuICBnZXROZXh0U2lnbmlmaWNhbnRUb2tlbigpIHtcblx0XHRsZXQgbmV4dFNpZ25pZmljYW50VG9rZW4gPSBudWxsO1xuXG4gIFx0Y29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgXHRcdGNvbnN0IHRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5pbmRleCsrXSxcblx0XHRcdFx0XHRcdHRva2VuU2lnbmlmaWNhbnQgPSB0b2tlbi5pc1NpZ25pZmljYW50KCk7XG5cbiAgXHRcdGlmICh0b2tlblNpZ25pZmljYW50KSB7XG4gIFx0XHQgIGNvbnN0IHNpZ25pZmljYW50VG9rZW4gPSB0b2tlbjsgLy8vXG5cblx0XHRcdFx0bmV4dFNpZ25pZmljYW50VG9rZW4gPSBzaWduaWZpY2FudFRva2VuO1x0Ly8vXG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG4gIFx0fVxuXG5cdFx0cmV0dXJuIG5leHRTaWduaWZpY2FudFRva2VuO1xuICB9XG5cbiAgaXNOZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4oKSB7XG4gICAgbGV0IG5leHRUb2tlbldoaXRlc3BhY2VUb2tlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPCB0b2tlbnNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMudG9rZW5zW3RoaXMuaW5kZXhdO1xuXG4gICAgICBuZXh0VG9rZW5XaGl0ZXNwYWNlVG9rZW4gPSBuZXh0VG9rZW4uaXNXaGl0ZXNwYWNlVG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRva2VuV2hpdGVzcGFjZVRva2VuO1xuICB9XG5cblx0YmFja3RyYWNrKHNhdmVkSW5kZXgpIHtcblx0XHR0aGlzLmluZGV4ID0gc2F2ZWRJbmRleDsgIC8vL1xuXHR9XG5cbiAgcmVzZXRQcmVjZWRlbmNlKHNhdmVkUHJlY2VkZW5jZSkge1xuICAgIHRoaXMucHJlY2VkZW5jZSA9IHNhdmVkUHJlY2VkZW5jZTsgIC8vL1xuICB9XG5cbiAgTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gT2JqZWN0Lmhhc093bih0aGlzLk5vblRlcm1pbmFsTm9kZU1hcCwgcnVsZU5hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTm9uVGVybWluYWxOb2RlTWFwW3J1bGVOYW1lXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdE5vblRlcm1pbmFsTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRva2Vuc1J1bGVNYXBTdGFydE9mQ29udGVudE5vblRlcm1pbmFsTm9kZU1hcEFuZERlZmF1bHROb25UZXJtaW5hbE5vZGUodG9rZW5zLCBydWxlTWFwLCBzdGFydE9mQ29udGVudCwgTm9uVGVybWluYWxOb2RlTWFwLCBkZWZhdWx0Tm9uVGVybWluYWxOb2RlKSB7XG4gICAgY29uc3QgaW5kZXggPSAwLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuXHRcdFx0XHRcdHN0YXRlID0gbmV3IFN0YXRlKGluZGV4LCB0b2tlbnMsIHJ1bGVNYXAsIHByZWNlZGVuY2UsIHN0YXJ0T2ZDb250ZW50LCBOb25UZXJtaW5hbE5vZGVNYXAsIGRlZmF1bHROb25UZXJtaW5hbE5vZGUpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uL3N0YXRlXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5mdW5jdGlvbiBwYXJzZSh0b2tlbnMsIHJ1bGUgPSB0aGlzLnN0YXJ0UnVsZSwgc3RhcnRPZkNvbnRlbnQgPSB0cnVlKSB7XG4gIGxldCBub2RlID0gbnVsbDtcblxuICBjb25zdCBub2RlcyA9IFtdLFxuICAgICAgICB7IE5vblRlcm1pbmFsTm9kZU1hcCwgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgc3RhdGUgPSBTdGF0ZS5mcm9tVG9rZW5zUnVsZU1hcFN0YXJ0T2ZDb250ZW50Tm9uVGVybWluYWxOb2RlTWFwQW5kRGVmYXVsdE5vblRlcm1pbmFsTm9kZSh0b2tlbnMsIHRoaXMucnVsZU1hcCwgc3RhcnRPZkNvbnRlbnQsIE5vblRlcm1pbmFsTm9kZU1hcCwgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSksXG4gICAgICAgIGNhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY2FsbEFoZWFkID0gbnVsbCxcbiAgICAgICAgcGFyc2VkID0gcnVsZS5wYXJzZShub2Rlcywgc3RhdGUsIGNhbGxiYWNrLCBjYWxsQWhlYWQpO1xuXG4gIGlmIChwYXJzZWQpIHtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBmaXJzdChub2Rlcyk7XG5cbiAgICBub2RlID0gZmlyc3ROb2RlOyAvLy9cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5jb25zdCBwYXJzZXJNaXhpbnMgPSB7XG4gIHBhcnNlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZXJNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5jb25zdCB7IG5hbWVUeXBlIH0gPSB0eXBlcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmFtZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gbmFtZVR5cGUsICAvLy9cbiAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0ID0gU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0LmZyb21TaWduaWZpY2FudFRva2VuVHlwZShzaWduaWZpY2FudFRva2VuVHlwZSksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBuYW1lU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBuYW1lRGVmaW5pdGlvbiA9IG5ldyBOYW1lRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gbmFtZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9uYW1lXCI7XG5cbmltcG9ydCB7IE5BTUVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZURlZmluaXRpb24gPSBOYW1lRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBOQU1FX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG5hbWVSdWxlID0gbmV3IE5hbWVCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBuYW1lUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFFVQU5USUZJRVJfUlVMRV9OQU1FLCBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUVVBTlRJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBxdWFudGlmaWVyUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFRFUk1JTkFMX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgdGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocXVhbnRpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICB0ZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IG5ldyBUZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gdGVybWluYWxQYXJ0UnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBaZXJvT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi8uLi9wYXJ0L25vblRlcm1pbmFsL3plcm9Pck1vcmVQYXJ0c1wiO1xuXG5pbXBvcnQgeyBRVUFOVElGSUVSX1JVTEVfTkFNRSwgTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgcnVsZU5hbWUgPSBRVUFOVElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHF1YW50aWZpZXJSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gTk9OX1RFUk1JTkFMX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZVBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocXVhbnRpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVOYW1lUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IG5ldyBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG4gICAgXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcGFydFJ1bGUvdGVybWluYWxcIjtcbmltcG9ydCBOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9wYXJ0UnVsZS9ub25UZXJtaW5hbFwiO1xuXG5pbXBvcnQgeyBQQVJUX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBQQVJUX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uID0gVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiA9IE5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBub25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBwYXJ0UnVsZSA9IG5ldyBQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcGFydFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmltcG9ydCB7IE5BTUVfUlVMRV9OQU1FLCBERUZJTklUSU9OU19SVUxFX05BTUUsIE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHNlcGFyYXRvciwgdGVybWluYXRvciB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBjb25zdCBzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCA9IHNlcGFyYXRvciwgLy8vXG4gICAgICAgICAgdGVybWluYXRvclN0cmluZ0xpdGVyYWxDb250ZW50ID0gdGVybWluYXRvcjsgLy8vXG5cbiAgICBydWxlTmFtZSA9IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgb3BhY2l0eU1vZGlmaWVyUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IE5BTUVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgbmFtZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsT3BhY2l0eVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KG9wYWNpdHlNb2RpZmllclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChzZXBhcmF0b3JTdHJpbmdMaXRlcmFsQ29udGVudCk7XG5cbiAgICBydWxlTmFtZSA9IERFRklOSVRJT05TX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IGRlZmluaXRpb25zUnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgdGVybWluYXRvclN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQodGVybWluYXRvclN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbE9wYWNpdHlSdWxlTmFtZVBhcnRQYXJ0LFxuICAgICAgICAgICAgc2VwYXJhdG9yU3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICAgICAgICBkZWZpbml0aW9uc1J1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIHRlcm1pbmF0b3JTdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgcnVsZURlZmluaXRpb24gPSBuZXcgUnVsZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHJ1bGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcnVsZVwiO1xuXG5pbXBvcnQgeyBSVUxFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHJ1bGVEZWZpbml0aW9uID0gUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gUlVMRV9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlUnVsZSA9IG5ldyBSdWxlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZVJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBXaWxkY2FyZFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCB3aWxkY2FyZFBhcnQgPSBXaWxkY2FyZFBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHdpbGRjYXJkUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgZXJyb3JEZWZpbml0aW9uID0gbmV3IEVycm9yRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZXJyb3JEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IEVycm9yRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9lcnJvclwiO1xuXG5pbXBvcnQgeyBFUlJPUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgb3BhcXVlIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBlcnJvckRlZmluaXRpb24gPSBFcnJvckRlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gRVJST1JfUlVMRV9OQU1FLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gb3BhcXVlLCAvLy9cbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVycm9yRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXJyb3JSdWxlID0gbmV3IEVycm9yQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZXJyb3JSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbUNvbnRlbnQoY29udGVudCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbERlZmluaXRpb24gPSBuZXcgU3RyaW5nTGl0ZXJhbERlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWxEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3N0cmluZ0xpdGVyYWxcIjtcblxuaW1wb3J0IHsgRVBTSUxPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZXBzaWxvbiB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVwc2lsb25CTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZXBzaWxvbiwgLy8vXG4gICAgICAgICAgZXBzaWxvblN0cmluZ0xpdGVyYWxEZWZpbml0aW9uID0gU3RyaW5nTGl0ZXJhbERlZmluaXRpb24uZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgbmFtZSA9IEVQU0lMT05fUlVMRV9OQU1FLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGVwc2lsb25TdHJpbmdMaXRlcmFsRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXBzaWxvblJ1bGUgPSBuZXcgRXBzaWxvbkJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGVwc2lsb25SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUGFydENob2ljZSBmcm9tIFwiLi4vcGFydENob2ljZVwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IENob2ljZU9mUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL2Nob2ljZU9mUGFydHNcIjtcbmltcG9ydCBPbmVPck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb25lT3JNb3JlUGFydHNcIjtcblxuaW1wb3J0IHsgUlVMRV9SVUxFX05BTUUsIEVSUk9SX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBydWxlTmFtZSA9IFJVTEVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcnVsZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBFUlJPUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBlcnJvclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHJ1bGVSdWxlTmFtZVBhcnRDaG9pY2UgPSBQYXJ0Q2hvaWNlLmZyb21QYXJ0KHJ1bGVSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIGVycm9yUnVsZU5hbWVQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChlcnJvclJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydENob2ljZXMgPSBbXG4gICAgICAgICAgICBydWxlUnVsZU5hbWVQYXJ0Q2hvaWNlLFxuICAgICAgICAgICAgZXJyb3JSdWxlTmFtZVBhcnRDaG9pY2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZU9mUnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzUGFydCA9IENob2ljZU9mUGFydHNQYXJ0LmZyb21QYXJ0Q2hvaWNlcyhwYXJ0Q2hvaWNlcyksXG4gICAgICAgICAgb25lT3JNb3JlQ2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0c1BhcnQgPSBPbmVPck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQoY2hvaWNlT2ZSdWxlUnVsZU5hbWVBbmRFcnJvclJ1bGVOYW1lUGFydHNQYXJ0KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9uZU9yTW9yZUNob2ljZU9mUnVsZVJ1bGVOYW1lQW5kRXJyb3JSdWxlTmFtZVBhcnRzUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkb2N1bWVudERlZmluaXRpb24gPSBuZXcgRG9jdW1lbnREZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkb2N1bWVudERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEb2N1bWVudERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZG9jdW1lbnRcIjtcblxuaW1wb3J0IHsgRE9DVU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGRvY3VtZW50RGVmaW5pdGlvbiA9IERvY3VtZW50RGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBET0NVTUVOVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGRvY3VtZW50RGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgZG9jdW1lbnRSdWxlID0gbmV3IERvY3VtZW50Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZG9jdW1lbnRSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgTmFtZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vbmFtZVwiO1xuXG5pbXBvcnQgeyBSVUxFX05BTUVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTmFtZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWVEZWZpbml0aW9uID0gTmFtZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBuYW1lID0gUlVMRV9OQU1FX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgbmFtZURlZmluaXRpb24gIC8vL1xuICAgICAgICAgIF0sXG4gICAgICAgICAgcnVsZU5hbWVSdWxlID0gbmV3IFJ1bGVOYW1lQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3N0cmluZ0xpdGVyYWxcIjtcblxuaW1wb3J0IHsgV0lMRENBUkRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHdpbGRjYXJkIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lsZGNhcmRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gd2lsZGNhcmQsIC8vL1xuICAgICAgICAgIHdpbGRjYXJkU3RyaW5nTGl0ZXJhbERlZmluaXRpb24gPSBTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbi5mcm9tQ29udGVudChjb250ZW50KSxcbiAgICAgICAgICBuYW1lID0gV0lMRENBUkRfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICB3aWxkY2FyZFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICB3aWxkY2FyZFJ1bGUgPSBuZXcgV2lsZGNhcmRCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiB3aWxkY2FyZFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc3RyaW5nTGl0ZXJhbFwiO1xuXG5pbXBvcnQgeyBFTkRfT0ZfTElORV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZW5kT2ZMaW5lIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5kT2ZMaW5lQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgY29udGVudCA9IGVuZE9mTGluZSxcbiAgICAgICAgICBlbmRPZkxpbmVTdHJpbmdMaXRlcmFsRGVmaW5pdGlvbiA9IFN0cmluZ0xpdGVyYWxEZWZpbml0aW9uLmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIG5hbWUgPSBFTkRfT0ZfTElORV9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZW5kT2ZMaW5lU3RyaW5nTGl0ZXJhbERlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGVuZE9mTGluZVJ1bGUgPSBuZXcgRW5kT2ZMaW5lQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZW5kT2ZMaW5lUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydENob2ljZURlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KHByZWNlZGVuY2VSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uID0gbmV3IFBhcnRDaG9pY2VEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJ0Q2hvaWNlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFBhcnRDaG9pY2VEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3BhcnRDaG9pY2VcIjtcblxuaW1wb3J0IHsgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0Q2hvaWNlQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IFBBUlRfQ0hPSUNFX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uID0gUGFydENob2ljZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHBhcnRDaG9pY2VEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZpbml0aW9uUnVsZSA9IG5ldyBQYXJ0Q2hvaWNlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvblJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgICBjb25zdCBydWxlTmFtZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lRGVmaW5pdGlvbiA9IG5ldyBSdWxlTmFtZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHJ1bGVOYW1lRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFJ1bGVOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ydWxlTmFtZVwiO1xuXG5pbXBvcnQgeyBRVUFOVElGSUVSX1JVTEVfTkFNRSwgT1BUSU9OQUxfUVVBTlRJRklFUl9SVUxFX05BTUUsIE9ORV9PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCBaRVJPX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG4gICAgY29uc3QgbmFtZSA9IFFVQU5USUZJRVJfUlVMRV9OQU1FOyAgLy8vXG5cbiAgICBydWxlTmFtZSA9IE9QVElPTkFMX1FVQU5USUZJRVJfUlVMRV9OQU1FXG5cbiAgICBjb25zdCBvcHRpb25hbFF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFpFUk9fT1JfTU9SRV9RVUFOVElGSUVSX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHplcm9Pck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBvcHRpb25hbFF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHF1YW50aWZpZXJSdWxlID0gbmV3IFF1YW50aWZpZXJCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBxdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9ydWxlTmFtZVwiO1xuaW1wb3J0IE9wdGlvbmFsUGFydFBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvb3B0aW9uYWxQYXJ0XCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FLCBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbkRlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIHJ1bGVOYW1lID0gUEFSVF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBwYXJ0UnVsZU5hbWVQYXJ0ID0gUnVsZU5hbWVQYXJ0LmZyb21SdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICBydWxlTmFtZSA9IFBSRUNFREVOQ0VfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9uZU9yTW9yZVJ1bGVOYW1lUGFydHNQYXJ0ID0gT25lT3JNb3JlUGFydHNQYXJ0LmZyb21QYXJ0KHBhcnRSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIG9wdGlvbmFsUHJlY2VkZW5jZVJ1bGVOYW1lUGFydFBhcnQgPSBPcHRpb25hbFBhcnRQYXJ0LmZyb21QYXJ0KHByZWNlZGVuY2VSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgb25lT3JNb3JlUnVsZU5hbWVQYXJ0c1BhcnQsXG4gICAgICAgICAgICBvcHRpb25hbFByZWNlZGVuY2VSdWxlTmFtZVBhcnRQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9uRGVmaW5pdGlvbiA9IG5ldyBEZWZpbml0aW9uRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gZGVmaW5pdGlvbkRlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEZWZpbml0aW9uRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9kZWZpbml0aW9uXCI7XG5cbmltcG9ydCB7IERFRklOSVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IERFRklOSVRJT05fUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgZGVmaW5pdGlvbkRlZmluaXRpb24gPSBEZWZpbml0aW9uRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvbkRlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlZmluaXRpb25SdWxlID0gbmV3IERlZmluaXRpb25CTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB0eXBlcywgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9vcHRpb25hbFBhcnRcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmNvbnN0IHsgbnVtYmVyVHlwZSB9ID0gdHlwZXMsXG4gICAgICB7IG9wZW5CcmFja2V0LCBjbG9zZUJyYWNrZXQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVjZWRlbmNlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBudW1iZXJUeXBlLCAgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQpLFxuICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbENvbnRlbnQpLFxuICAgICAgICAgIG51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydCA9IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydC5mcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpLFxuICAgICAgICAgIG9wdGlvbmFsTnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQobnVtYmVyU2lnbmlmaWNhbnRUb2tlblR5cGVQYXJ0KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbE51bWJlclNpZ25pZmljYW50VG9rZW5UeXBlUGFydFBhcnQsXG4gICAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgcHJlY2VkZW5jZURlZmluaXRpb24gPSBuZXcgUHJlY2VkZW5jZURlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHByZWNlZGVuY2VEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUHJlY2VkZW5jZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcHJlY2VkZW5jZVwiO1xuXG5pbXBvcnQgeyBQUkVDRURFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlY2VkZW5jZUJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBQUkVDRURFTkNFX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHByZWNlZGVuY2VEZWZpbml0aW9uID0gUHJlY2VkZW5jZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHByZWNlZGVuY2VEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlUnVsZSA9IG5ldyBQcmVjZWRlbmNlQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcHJlY2VkZW5jZVJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUnVsZU5hbWVQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvemVyb09yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIjtcblxuaW1wb3J0IHsgREVGSU5JVElPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgdmVydGljYWxCYXIgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uc0RlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBwYXJ0cztcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lID0gREVGSU5JVElPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZGVmaW5pdGlvblJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KTtcblxuICAgIHBhcnRzID0gW1xuICAgICAgdmVydGljYWxCYXJTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgIGRlZmluaXRpb25SdWxlTmFtZVBhcnRcbiAgICBdO1xuXG4gICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IFNlcXVlbmNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRzKHBhcnRzKSxcbiAgICAgICAgICB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IFplcm9Pck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQoc2VxdWVuY2VPZlBhcnRzUGFydCk7XG5cbiAgICBwYXJ0cyA9IFtcbiAgICAgIGRlZmluaXRpb25SdWxlTmFtZVBhcnQsXG4gICAgICB6ZXJvT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydFxuICAgIF07XG5cbiAgICBjb25zdCBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9uc0RlZmluaXRpb24gPSBuZXcgRGVmaW5pdGlvbnNEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uc0RlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBEZWZpbml0aW9uc0RlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZGVmaW5pdGlvbnNcIjtcblxuaW1wb3J0IHsgREVGSU5JVElPTlNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uc0JORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGRlZmluaXRpb25zRGVmaW5pdGlvbiA9IERlZmluaXRpb25zRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG5hbWUgPSBERUZJTklUSU9OU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgZGVmaW5pdGlvbnNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZWZpbml0aW9uc1J1bGUgPSBuZXcgRGVmaW5pdGlvbnNCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBkZWZpbml0aW9uc1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBSdWxlTmFtZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcnVsZU5hbWVcIjtcblxuaW1wb3J0IHsgRVBTSUxPTl9SVUxFX05BTUUsXG4gICAgICAgICBXSUxEQ0FSRF9SVUxFX05BTUUsXG4gICAgICAgICBFTkRfT0ZfTElORV9SVUxFX05BTUUsXG4gICAgICAgICBURVJNSU5BTF9QQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFNUUklOR19MSVRFUkFMX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUsXG4gICAgICAgICBSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FLFxuICAgICAgICAgU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRSxcbiAgICAgICAgIFNJR05JRklDQU5UX1RPS0VOX1RZUEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtaW5hbFBhcnRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBsZXQgcnVsZU5hbWU7XG5cbiAgICBjb25zdCBuYW1lID0gVEVSTUlOQUxfUEFSVF9SVUxFX05BTUU7XG5cbiAgICBydWxlTmFtZSA9IEVQU0lMT05fUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgZXBzaWxvblJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBXSUxEQ0FSRF9SVUxFX05BTUU7XG5cbiAgICBjb25zdCB3aWxkY2FyZFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBFTkRfT0ZfTElORV9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBlbmRPZkxpbmVSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgc3RyaW5nTGl0ZXJhbFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBOT19XSElURVNQQUNFX1BBUlRfUlVMRV9OQU1FO1xuXG4gICAgY29uc3Qgbm9XaGl0ZXNwYWNlUGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBSRUdVTEFSX0VYUFJFU1NJT05fUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcmVndWxhckV4cHJlc3Npb25SdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gU1RBUlRfT0ZfQ09OVEVOVF9QQVJUX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydFJ1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRTtcblxuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZU5hbWVEZWZpbml0aW9uID0gUnVsZU5hbWVEZWZpbml0aW9uLmZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZVJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGVuZE9mTGluZVJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHdpbGRjYXJkUnVsZU5hbWVEZWZpbml0aW9uLFxuICAgICAgICAgICAgZXBzaWxvblJ1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnRSdWxlTmFtZURlZmluaXRpb24sXG4gICAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRSdWxlTmFtZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHRlcm1pbmFsUGFydFJ1bGUgPSBuZXcgVGVybWluYWxQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gdGVybWluYWxQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi4vcGFydC9ub25UZXJtaW5hbC9zZXF1ZW5jZU9mUGFydHNcIjtcblxuaW1wb3J0IHsgUEFSVF9DSE9JQ0VfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHZlcnRpY2FsQmFyLCBvcGVuQnJhY2tldCwgY2xvc2VCcmFja2V0IH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBwYXJ0cztcblxuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSVF9DSE9JQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbENvbnRlbnQgPSB2ZXJ0aWNhbEJhciwgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgcGFydENob2ljZVJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudCh2ZXJ0aWNhbEJhclN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQob3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCksXG4gICAgICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCk7XG5cbiAgICBwYXJ0cyA9IFtcbiAgICAgIHZlcnRpY2FsQmFyU3RyaW5nTGl0ZXJhbFBhcnQsXG4gICAgICBwYXJ0Q2hvaWNlUnVsZU5hbWVQYXJ0XG4gICAgXTtcblxuICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBTZXF1ZW5jZU9mUGFydHNQYXJ0LmZyb21QYXJ0cyhwYXJ0cyksXG4gICAgICAgICAgb25lT3JNb3JlU2VxdWVuY2VPZlBhcnRzUGFydCA9IE9uZU9yTW9yZVBhcnRzUGFydC5mcm9tUGFydChzZXF1ZW5jZU9mUGFydHNQYXJ0KTtcblxuICAgIHBhcnRzID0gW1xuICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCxcbiAgICAgIHBhcnRDaG9pY2VSdWxlTmFtZVBhcnQsXG4gICAgICBvbmVPck1vcmVTZXF1ZW5jZU9mUGFydHNQYXJ0LFxuICAgICAgY2xvc2VCcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnRcbiAgICBdO1xuXG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgY2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gPSBuZXcgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIGNob2ljZU9mUGFydHNEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vY2hvaWNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaG9pY2VPZlBhcnRzQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZSA9IENIT0lDRV9PRl9QQVJUU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIGNob2ljZU9mUGFydHNEZWZpbml0aW9uID0gQ2hvaWNlT2ZQYXJ0c0RlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNob2ljZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjaG9pY2VPZlBhcnRzUnVsZSA9IG5ldyBDaG9pY2VPZlBhcnRzQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gY2hvaWNlT2ZQYXJ0c1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tU2lnbmlmaWNhbnRUb2tlblR5cGUoc2lnbmlmaWNhbnRUb2tlblR5cGUpIHtcbiAgICBjb25zdCBzaWduaWZpY2FudFRva2VuVHlwZVBhcnQgPSBTaWduaWZpY2FudFRva2VuVHlwZVBhcnQuZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uID0gbmV3IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gc2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5pbXBvcnQgeyBTVFJJTkdfTElURVJBTF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgc3RyaW5nTGl0ZXJhbFR5cGUgfSA9IHR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdMaXRlcmFsQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSBzdHJpbmdMaXRlcmFsVHlwZSwgIC8vL1xuICAgICAgICAgIHN0cmluZ0xpdGVyYWxTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gU1RSSU5HX0xJVEVSQUxfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzdHJpbmdMaXRlcmFsU2lnbmlmaWNhbnRUb2tlblR5cGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUnVsZSA9IG5ldyBTdHJpbmdMaXRlcmFsQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uLy4uLy4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uLy4uLy4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBPcHRpb25hbFBhcnRQYXJ0IGZyb20gXCIuLi8uLi8uLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuXG5pbXBvcnQgeyBSVUxFX05BTUVfUlVMRV9OQU1FLCBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IHJ1bGVOYW1lO1xuXG4gICAgcnVsZU5hbWUgPSBSVUxFX05BTUVfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgcnVsZU5hbWVSdWxlTmFtZVBhcnQgPSBSdWxlTmFtZVBhcnQuZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJ1bGVOYW1lID0gQ0FMTF9BSEVBRF9NT0RJRklFUl9SVUxFX05BTUU7XG5cbiAgICBjb25zdCBjYWxsQWhlYWRNb2RpZmllclJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wdGlvbmFsQ2FsbEFoZWFkUnVsZU5hbWVQYXJ0UGFydCA9IE9wdGlvbmFsUGFydFBhcnQuZnJvbVBhcnQoY2FsbEFoZWFkTW9kaWZpZXJSdWxlTmFtZVBhcnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVBhcnQsXG4gICAgICAgICAgICBvcHRpb25hbENhbGxBaGVhZFJ1bGVOYW1lUGFydFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gPSBuZXcgUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gcnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFJ1bGVOYW1lRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ydWxlTmFtZVwiO1xuaW1wb3J0IFJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcGFydFJ1bGUvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcblxuaW1wb3J0IHsgQ0hPSUNFX09GX1BBUlRTX1JVTEVfTkFNRSwgU0VRVUVOQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FLCBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vblRlcm1pbmFsUGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGxldCBydWxlTmFtZTtcblxuICAgIGNvbnN0IG5hbWUgPSBOT05fVEVSTUlOQUxfUEFSVF9SVUxFX05BTUU7IC8vL1xuXG4gICAgcnVsZU5hbWUgPSBDSE9JQ0VfT0ZfUEFSVFNfUlVMRV9OQU1FO1xuXG4gICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbiA9IFJ1bGVOYW1lRGVmaW5pdGlvbi5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcnVsZU5hbWUgPSBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUU7XG5cbiAgICBjb25zdCBzZXF1ZW5jZU9mUGFydHNSdWxlTmFtZURlZmluaXRpb24gPSBSdWxlTmFtZURlZmluaXRpb24uZnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICBydWxlTmFtZU5vblRlcm1pbmFsUGFydFJ1bGVEZWZpbml0aW9uID0gUnVsZU5hbWVOb25UZXJtaW5hbFBhcnRSdWxlRGVmaW5pdGlvbi5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c1J1bGVOYW1lRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJ1bGVOYW1lTm9uVGVybWluYWxQYXJ0UnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG5vblRlcm1pbmFsUGFydFJ1bGUgPSBuZXcgTm9uVGVybWluYWxQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gbm9uVGVybWluYWxQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBSdWxlTmFtZVBhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvcnVsZU5hbWVcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgT25lT3JNb3JlUGFydHNQYXJ0IGZyb20gXCIuLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5cbmltcG9ydCB7IFBBUlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IG9wZW5CcmFja2V0LCBjbG9zZUJyYWNrZXQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUlRfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgb3BlbkJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IG9wZW5CcmFja2V0LCAvLy9cbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsQ29udGVudCA9IGNsb3NlQnJhY2tldCwgLy8vXG4gICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG9wZW5CcmFja2V0U3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBjbG9zZUJyYWNrZXRTdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxDb250ZW50KSxcbiAgICAgICAgICBvbmVPck1vcmVQYXJ0UnVsZU5hbWVQYXJ0c1BhcnQgPSBPbmVPck1vcmVQYXJ0c1BhcnQuZnJvbVBhcnQocGFydFJ1bGVOYW1lUGFydCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBvcGVuQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0LFxuICAgICAgICAgICAgcGFydFJ1bGVOYW1lUGFydCxcbiAgICAgICAgICAgIG9uZU9yTW9yZVBhcnRSdWxlTmFtZVBhcnRzUGFydCxcbiAgICAgICAgICAgIGNsb3NlQnJhY2tldFN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24ocGFydHMsIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuXG5pbXBvcnQgeyBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBTRVFVRU5DRV9PRl9QQVJUU19SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c0RlZmluaXRpb24gPSBTZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNSdWxlID0gbmV3IFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNlcXVlbmNlT2ZQYXJ0c1J1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUGFydENob2ljZSBmcm9tIFwiLi4vcGFydENob2ljZVwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvbm9XaGl0ZXNwYWNlXCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c1BhcnQgZnJvbSBcIi4uL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuLi9wYXJ0L3Rlcm1pbmFsL3N0cmluZ0xpdGVyYWxcIjtcblxuY29uc3QgeyBvcGFxdWUsIHNlbWlPcGFxdWUgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgbGV0IGNvbnRlbnQ7XG5cbiAgICBjb250ZW50ID0gb3BhcXVlOyAvLy9cblxuICAgIGNvbnN0IG9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCk7XG5cbiAgICBjb250ZW50ID0gc2VtaU9wYXF1ZTsgLy8vXG5cbiAgICBjb25zdCBzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KTtcblxuICAgIGNvbnN0IG9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChvcGFxdWVTdHJpbmdMaXRlcmFsUGFydCksXG4gICAgICAgICAgc2VtaU9wYXF1ZVN0cmluZ0xpdGVyYWxQYXJ0Q2hvaWNlID0gUGFydENob2ljZS5mcm9tUGFydChzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnQpLFxuICAgICAgICAgIHBhcnRDaG9pY2VzID0gW1xuICAgICAgICAgICAgb3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnRDaG9pY2UsXG4gICAgICAgICAgICBzZW1pT3BhcXVlU3RyaW5nTGl0ZXJhbFBhcnRDaG9pY2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGNob2ljZU9mT3BhcXVlU3RyaW5nTGl0ZXJhbEFuZFNlbWlPcGFxdWVTdHJpbmdMaXRlcmFsUGFydHNQYXJ0ID0gQ2hvaWNlT2ZQYXJ0c1BhcnQuZnJvbVBhcnRDaG9pY2VzKHBhcnRDaG9pY2VzKSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0ID0gTm9XaGl0ZXNwYWNlUGFydC5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCxcbiAgICAgICAgICAgIGNob2ljZU9mT3BhcXVlU3RyaW5nTGl0ZXJhbEFuZFNlbWlPcGFxdWVTdHJpbmdMaXRlcmFsUGFydHNQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IG5ldyBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gb3BhY2l0eU1vZGlmaWVyUnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBPcGFjaXR5TW9kaWZpZXJSdWxlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9vcGFjaXR5TW9kaWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IE9QQUNJVFlfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcGFjaXR5TW9kaWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gT1BBQ0lUWV9NT0RJRklFUl9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIG9wYWNpdHlNb2RpZmllclJ1bGVEZWZpbml0aW9uID0gT3BhY2l0eU1vZGlmaWVyUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG9wYWNpdHlNb2RpZmllclJ1bGVEZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvcGFjaXR5TW9kaWZpZXJSdWxlID0gbmV3IE9wYWNpdHlNb2RpZmllckJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIG9wYWNpdHlNb2RpZmllclJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgU3RyaW5nTGl0ZXJhbFBhcnQgZnJvbSBcIi4uL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuXG5jb25zdCB7IG5vV2hpdGVzcGFjZSB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gbm9XaGl0ZXNwYWNlLCAgLy8vXG4gICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnQgPSBTdHJpbmdMaXRlcmFsUGFydC5mcm9tQ29udGVudChjb250ZW50KSxcbiAgICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiA9IG5ldyBOb1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydERlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBOb1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5cbmltcG9ydCB7IE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBub1doaXRlc3BhY2VQYXJ0RGVmaW5pdGlvbiA9IE5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgbmFtZSA9IE5PX1dISVRFU1BBQ0VfUEFSVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIG5vV2hpdGVzcGFjZVBhcnREZWZpbml0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0UnVsZSA9IG5ldyBOb1doaXRlc3BhY2VQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gbm9XaGl0ZXNwYWNlUGFydFJ1bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmNvbnN0IHsgZWxsaXBzaXMgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsQWhlYWRNb2RpZmllclJ1bGVEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZWxsaXBzaXMsICAvLy9cbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0ID0gTm9XaGl0ZXNwYWNlUGFydC5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0ID0gU3RyaW5nTGl0ZXJhbFBhcnQuZnJvbUNvbnRlbnQoY29udGVudCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0LFxuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gPSBuZXcgQ2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gY2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IENhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vY2FsbEFoZWFkTW9kaWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IENBTExfQUhFQURfTU9ESUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWxsQWhlYWRNb2RpZmllckJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBDQUxMX0FIRUFEX01PRElGSUVSX1JVTEVfTkFNRSwgLy8vXG4gICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJSdWxlRGVmaW5pdGlvbiA9IENhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb24uZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNhbGxBaGVhZE1vZGlmaWVyUnVsZSA9IG5ldyBDYWxsQWhlYWRNb2RpZmllckJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGNhbGxBaGVhZE1vZGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc2lnbmlmaWNhbnRUb2tlblR5cGVcIjtcblxuaW1wb3J0IHsgUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyByZWd1bGFyRXhwcmVzc2lvblR5cGUgfSA9IHR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWd1bGFyRXhwcmVzc2lvbkJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlID0gcmVndWxhckV4cHJlc3Npb25UeXBlLCAgLy8vXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25TaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gUkVHVUxBUl9FWFBSRVNTSU9OX1JVTEVfTkFNRSwgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICByZWd1bGFyRXhwcmVzc2lvblNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25SdWxlID0gbmV3IFJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcmVndWxhckV4cHJlc3Npb25SdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWZpbml0aW9uIGZyb20gXCIuLi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgTm9XaGl0ZXNwYWNlUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9ub1doaXRlc3BhY2VcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXJSdWxlRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVNwZWNpYWxTeW1ib2woc3BlY2lhbFN5bWJvbCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzcGVjaWFsU3ltYm9sLCAgLy8vXG4gICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCA9IE5vV2hpdGVzcGFjZVBhcnQuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydCxcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxQYXJ0XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgICBxdWFudGlmaWVyUnVsZURlZmluaXRpb24gPSBuZXcgUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBxdWFudGlmaWVyUnVsZURlZmluaXRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgc3BlY2lhbFN5bWJvbHMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBSdWxlIGZyb20gXCIuLi8uLi9ydWxlXCI7XG5pbXBvcnQgUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uIGZyb20gXCIuLi8uLi9kZWZpbml0aW9uL3F1YW50aWZpZXJSdWxlXCI7XG5cbmltcG9ydCB7IE9QVElPTkFMX1FVQU5USUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IHF1ZXN0aW9uTWFyayB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbmFsUXVhbnRpZmllckJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG5hbWUgPSBPUFRJT05BTF9RVUFOVElGSUVSX1JVTEVfTkFNRSwgIC8vL1xuICAgICAgICAgIHNwZWNpYWxTeW1ib2wgPSBxdWVzdGlvbk1hcmssIC8vL1xuICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uLmZyb21TcGVjaWFsU3ltYm9sKHNwZWNpYWxTeW1ib2wpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG9wdGlvbmFsUXVhbnRpZmllclJ1bGUgPSBuZXcgT3B0aW9uYWxRdWFudGlmaWVyQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gb3B0aW9uYWxRdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IERlZmluaXRpb24gZnJvbSBcIi4uL2RlZmluaXRpb25cIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsUGFydCBmcm9tIFwiLi4vcGFydC90ZXJtaW5hbC9zdHJpbmdMaXRlcmFsXCI7XG5cbmNvbnN0IHsgc3RhcnRPZkNvbnRlbnQgfSA9IHNwZWNpYWxTeW1ib2xzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFydE9mQ29udGVudFBhcnREZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBjb250ZW50ID0gc3RhcnRPZkNvbnRlbnQsICAvLy9cbiAgICAgICAgICBzdHJpbmdMaXRlcmFsUGFydCA9IFN0cmluZ0xpdGVyYWxQYXJ0LmZyb21Db250ZW50KGNvbnRlbnQpLFxuICAgICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgc3RyaW5nTGl0ZXJhbFBhcnRcbiAgICAgICAgICBdLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBudWxsLFxuICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gPSBuZXcgU3RhcnRPZkNvbnRlbnRQYXJ0RGVmaW5pdGlvbihwYXJ0cywgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0RGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vc3RhcnRPZkNvbnRlbnRQYXJ0XCI7XG5cbmltcG9ydCB7IFNUQVJUX09GX0NPTlRFTlRfUEFSVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXJ0T2ZDb250ZW50UGFydEJORlJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb24gPSBTdGFydE9mQ29udGVudFBhcnREZWZpbml0aW9uLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgbmFtZSA9IFNUQVJUX09GX0NPTlRFTlRfUEFSVF9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydERlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXJ0T2ZDb250ZW50UGFydFJ1bGUgPSBuZXcgU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gc3RhcnRPZkNvbnRlbnRQYXJ0UnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIjtcblxuaW1wb3J0IHsgT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgcGx1cyB9ID0gc3BlY2lhbFN5bWJvbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gT05FX09SX01PUkVfUVVBTlRJRklFUl9SVUxFX05BTUUsIC8vL1xuICAgICAgICAgIHNwZWNpYWxTeW1ib2wgPSBwbHVzLCAvLy9cbiAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb24gPSBRdWFudGlmaWVyUnVsZURlZmluaXRpb24uZnJvbVNwZWNpYWxTeW1ib2woc3BlY2lhbFN5bWJvbCksXG4gICAgICAgICAgb3BhY2l0eSA9IG51bGwsXG4gICAgICAgICAgZGVmaW5pdGlvbnMgPSBbXG4gICAgICAgICAgICBvbmVPck1vcmVRdWFudGlmaWVyUnVsZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IE9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlKG5hbWUsIG9wYWNpdHksIGRlZmluaXRpb25zKTtcblxuICAgIHJldHVybiBvbmVPck1vcmVRdWFudGlmaWVyUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IFJ1bGUgZnJvbSBcIi4uLy4uL3J1bGVcIjtcbmltcG9ydCBRdWFudGlmaWVyUnVsZURlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcXVhbnRpZmllclJ1bGVcIjtcblxuaW1wb3J0IHsgWkVST19PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IGFzdGVyaXNrIH0gPSBzcGVjaWFsU3ltYm9scztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWmVyb09yTW9yZVF1YW50aWZpZXJCTkZSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBuYW1lID0gWkVST19PUl9NT1JFX1FVQU5USUZJRVJfUlVMRV9OQU1FLCAgLy8vXG4gICAgICAgICAgc3BlY2lhbFN5bWJvbCA9IGFzdGVyaXNrLCAvLy9cbiAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uID0gUXVhbnRpZmllclJ1bGVEZWZpbml0aW9uLmZyb21TcGVjaWFsU3ltYm9sKHNwZWNpYWxTeW1ib2wpLFxuICAgICAgICAgIG9wYWNpdHkgPSBudWxsLFxuICAgICAgICAgIGRlZmluaXRpb25zID0gW1xuICAgICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlRGVmaW5pdGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgemVyb09yTW9yZVF1YW50aWZpZXJSdWxlID0gbmV3IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gemVyb09yTW9yZVF1YW50aWZpZXJSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vLi4vcnVsZVwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlRGVmaW5pdGlvbiBmcm9tIFwiLi4vLi4vZGVmaW5pdGlvbi9zaWduaWZpY2FudFRva2VuVHlwZVwiO1xuXG5pbXBvcnQgeyBTSUdOSUZJQ0FOVF9UT0tFTl9UWVBFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgeyB0eXBlVHlwZSB9ID0gdHlwZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpZ25pZmljYW50VG9rZW5UeXBlQk5GUnVsZSBleHRlbmRzIFJ1bGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3Qgc2lnbmlmaWNhbnRUb2tlblR5cGUgPSB0eXBlVHlwZSwgIC8vL1xuICAgICAgICAgIHR5cGVTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24gPSBTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb24uZnJvbVNpZ25pZmljYW50VG9rZW5UeXBlKHNpZ25pZmljYW50VG9rZW5UeXBlKSxcbiAgICAgICAgICBuYW1lID0gU0lHTklGSUNBTlRfVE9LRU5fVFlQRV9SVUxFX05BTUUsICAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gbnVsbCxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtcbiAgICAgICAgICAgIHR5cGVTaWduaWZpY2FudFRva2VuVHlwZURlZmluaXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZSA9IG5ldyBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNpZ25pZmljYW50VG9rZW5UeXBlUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCwgcHJ1bmUgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0FzU3RyaW5nKHJ1bGVzLCBtdWx0aUxpbmUpIHtcbiAgY29uc3QgbWF4aW11bVJ1bGVOYW1lTGVuZ3RoID0gcnVsZXMucmVkdWNlKChtYXhpbXVtUnVsZU5hbWVMZW5ndGgsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpO1xuXG4gICAgICAgIGxldCBydWxlTmFtZUxlbmd0aCA9IHJ1bGVOYW1lLmxlbmd0aDtcblxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG9wYWNpdHlMZW5ndGggPSBvcGFjaXR5Lmxlbmd0aDtcblxuICAgICAgICAgIHJ1bGVOYW1lTGVuZ3RoICs9IG9wYWNpdHlMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBtYXhpbXVtUnVsZU5hbWVMZW5ndGggPSBNYXRoLm1heChtYXhpbXVtUnVsZU5hbWVMZW5ndGgsIHJ1bGVOYW1lTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gbWF4aW11bVJ1bGVOYW1lTGVuZ3RoO1xuICAgICAgfSwgMCksXG4gICAgICBydWxlc1N0cmluZyA9IHJ1bGVzLnJlZHVjZSgocnVsZXNTdHJpbmcsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcnVsZVN0cmluZyA9IHJ1bGUuYXNTdHJpbmcobWF4aW11bVJ1bGVOYW1lTGVuZ3RoLCBtdWx0aUxpbmUpO1xuXG4gICAgICAgIHJ1bGVzU3RyaW5nICs9IHJ1bGVTdHJpbmc7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzU3RyaW5nO1xuICAgICAgfSwgRU1QVFlfU1RSSU5HKS5yZXBsYWNlKC9eXFxuXFxuLywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcnVsZXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSB7XG4gIGNvbnN0IHJ1bGVNYXAgPSB7fTtcblxuICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKTtcblxuICAgIHJ1bGVNYXBbcnVsZU5hbWVdID0gcnVsZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVNYXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpIHtcbiAgY29uc3QgZmlyc3RSdWxlID0gZmlyc3QocnVsZXMpLFxuICAgICAgICBzdGFydFJ1bGUgPSBmaXJzdFJ1bGU7ICAvLy9cblxuICByZXR1cm4gc3RhcnRSdWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcChzdGFydFJ1bGUsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZXMgPSBPYmplY3QudmFsdWVzKHJ1bGVNYXApLFxuICAgICAgICBzdGFydFJ1bGVOYW1lID0gc3RhcnRSdWxlLmdldE5hbWUoKTtcblxuICBzdGFydFJ1bGUgPSBwcnVuZShydWxlcywgKHJ1bGUpID0+IHsgIC8vL1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBpZiAocnVsZU5hbWUgIT09IHN0YXJ0UnVsZU5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZXMudW5zaGlmdChzdGFydFJ1bGUpO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUocnVsZXMsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgbGV0IHN0YXJ0UnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHtcbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgaWYgKHJ1bGVOYW1lID09PSBzdGFydFJ1bGVOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIHx8IG51bGw7IC8vL1xuXG4gIGlmIChzdGFydFJ1bGUgPT09IG51bGwpIHtcbiAgICBzdGFydFJ1bGUgPSBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0UnVsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0FzU3RyaW5nLFxuICBydWxlTWFwRnJvbVJ1bGVzLFxuICBzdGFydFJ1bGVGcm9tUnVsZXMsXG4gIHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAsXG4gIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5pbXBvcnQgUnVsZSBmcm9tIFwiLi4vcnVsZVwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZU1hcCBmcm9tIFwiLi4vbm9uVGVybWluYWxOb2RlTWFwXCI7XG5pbXBvcnQgcGFyc2VyTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvcGFyc2VyXCI7XG5pbXBvcnQgTmFtZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL25hbWVcIjtcbmltcG9ydCBQYXJ0Qk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcGFydFwiO1xuaW1wb3J0IFJ1bGVCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9ydWxlXCI7XG5pbXBvcnQgRXJyb3JCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9lcnJvclwiO1xuaW1wb3J0IEVwc2lsb25CTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9lcHNpbG9uXCI7XG5pbXBvcnQgRG9jdW1lbnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9kb2N1bWVudFwiO1xuaW1wb3J0IFJ1bGVOYW1lQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcnVsZU5hbWVcIjtcbmltcG9ydCBXaWxkY2FyZEJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3dpbGRjYXJkXCI7XG5pbXBvcnQgRW5kT2ZMaW5lQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgUGFydENob2ljZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3BhcnRDaG9pY2VcIjtcbmltcG9ydCBRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcXVhbnRpZmllclwiO1xuaW1wb3J0IERlZmluaXRpb25CTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9kZWZpbml0aW9uXCI7XG5pbXBvcnQgUHJlY2VkZW50c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3ByZWNlZGVuY2VcIjtcbmltcG9ydCBEZWZpbml0aW9uc0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL2RlZmluaXRpb25zXCI7XG5pbXBvcnQgVGVybWluYWxQYXJ0Qk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvdGVybWluYWxQYXJ0XCI7XG5pbXBvcnQgQ2hvaWNlT2ZQYXJ0c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL2Nob2ljZU9mUGFydHNcIjtcbmltcG9ydCBTdHJpbmdMaXRlcmFsQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IE5vblRlcm1pbmFsUGFydEJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL25vblRlcm1pbmFsUGFydFwiO1xuaW1wb3J0IFNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuaW1wb3J0IE9wYWNpdHlNb2RpZmllckJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL29wYWNpdHlNb2RpZmllclwiO1xuaW1wb3J0IE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9ub1doaXRlc3BhY2VQYXJ0XCI7XG5pbXBvcnQgQ2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9jYWxsQWhlYWRNb2RpZmllclwiO1xuaW1wb3J0IFJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvcmVndWxhckV4cHJlc3Npb25cIjtcbmltcG9ydCBPcHRpb25hbFF1YW50aWZpZXJCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9vcHRpb25hbFF1YW50aWZpZXJcIjtcbmltcG9ydCBTdGFydE9mQ29udGVudFBhcnRCTkZSdWxlIGZyb20gXCIuLi9ydWxlL2JuZi9zdGFydE9mQ29udGVudFBhcnRcIjtcbmltcG9ydCBPbmVPck1vcmVRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvb25lT3JNb3JlUXVhbnRpZmllclwiO1xuaW1wb3J0IFplcm9Pck1vcmVRdWFudGlmaWVyQk5GUnVsZSBmcm9tIFwiLi4vcnVsZS9ibmYvemVyb09yTW9yZVF1YW50aWZpZXJcIjtcbmltcG9ydCBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUgZnJvbSBcIi4uL3J1bGUvYm5mL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmltcG9ydCB7IHJ1bGVNYXBGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQk5GUGFyc2VyIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIGdldFN0YXJ0UnVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gIH1cblxuICBnZXRSdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gIH1cblxuXHRydWxlc0Zyb21Ub2tlbnModG9rZW5zKSB7XG5cdCAgbGV0IHJ1bGVzO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2UodG9rZW5zKTtcblxuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIG5vZGUuYCk7XG4gICAgfVxuXG4gICAgcnVsZXMgPSBub2RlLmdlbmVyYXRlUnVsZXMoUnVsZSk7XG5cbiAgICBjb25zdCBydWxlc0xlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcblxuICAgIGlmIChydWxlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBhcmUgbm8gcnVsZXMuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgc3RhdGljIE5vblRlcm1pbmFsTm9kZU1hcCA9IE5vblRlcm1pbmFsTm9kZU1hcDtcblxuICBzdGF0aWMgZGVmYXVsdE5vblRlcm1pbmFsTm9kZSA9IG51bGw7XG5cbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbmFtZUJORlJ1bGUgPSBOYW1lQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHBhcnRCTkZSdWxlID0gUGFydEJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBydWxlQk5GUnVsZSA9IFJ1bGVCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgZXJyb3JCTkZSdWxlID0gRXJyb3JCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgZXBzaWxvbkJORlJ1bGUgPSBFcHNpbG9uQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGRvY3VtZW50Qk5GUnVsZSA9IERvY3VtZW50Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHJ1bGVOYW1lQk5GUnVsZSA9IFJ1bGVOYW1lQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHdpbGRjYXJkQk5GUnVsZSA9IFdpbGRjYXJkQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGVuZE9mTGluZUJORlJ1bGUgPSBFbmRPZkxpbmVCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFydENob2ljZUJORlJ1bGUgPSBQYXJ0Q2hvaWNlQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHF1YW50aWZpZXJCTkZSdWxlID0gUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBkZWZpbml0aW9uQk5GUnVsZSA9IERlZmluaXRpb25CTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcHJlY2VkZW50c0JORlJ1bGUgPSBQcmVjZWRlbnRzQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIGRlZmluaXRpb25zQk5GUnVsZSA9IERlZmluaXRpb25zQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHRlcm1pbmFsUGFydEJORlJ1bGUgPSBUZXJtaW5hbFBhcnRCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgY2hvaWNlT2ZQYXJ0c0JORlJ1bGUgPSBDaG9pY2VPZlBhcnRzQk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHN0cmluZ0xpdGVyYWxCTkZSdWxlID0gU3RyaW5nTGl0ZXJhbEJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub25UZXJtaW5hbFBhcnRCTkZSdWxlID0gTm9uVGVybWluYWxQYXJ0Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIHNlcXVlbmNlT2ZQYXJ0c0JORlJ1bGUgPSBTZXF1ZW5jZU9mUGFydHNCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3BhY2l0eU1vZGlmaWVyQk5GUnVsZSA9IE9wYWNpdHlNb2RpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBub1doaXRlc3BhY2VQYXJ0Qk5GUnVsZSA9IE5vV2hpdGVzcGFjZVBhcnRCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcmVndWxhckV4cHJlc3Npb25CTkZSdWxlID0gUmVndWxhckV4cHJlc3Npb25CTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgY2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlID0gQ2FsbEFoZWFkTW9kaWZpZXJCTkZSdWxlLmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgb3B0aW9uYWxRdWFudGlmaWVyQk5GUnVsZSA9IE9wdGlvbmFsUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRCTkZSdWxlID0gU3RhcnRPZkNvbnRlbnRQYXJ0Qk5GUnVsZS5mcm9tTm90aGluZygpLFxuICAgICAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXJCTkZSdWxlID0gT25lT3JNb3JlUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUgPSBaZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUgPSBTaWduaWZpY2FudFRva2VuVHlwZUJORlJ1bGUuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBydWxlcyA9IFtcbiAgICAgICAgICAgIGRvY3VtZW50Qk5GUnVsZSxcbiAgICAgICAgICAgIHJ1bGVCTkZSdWxlLFxuICAgICAgICAgICAgbmFtZUJORlJ1bGUsXG4gICAgICAgICAgICBkZWZpbml0aW9uc0JORlJ1bGUsXG4gICAgICAgICAgICBkZWZpbml0aW9uQk5GUnVsZSxcbiAgICAgICAgICAgIHBhcnRCTkZSdWxlLFxuICAgICAgICAgICAgbm9uVGVybWluYWxQYXJ0Qk5GUnVsZSxcbiAgICAgICAgICAgIHRlcm1pbmFsUGFydEJORlJ1bGUsXG4gICAgICAgICAgICBzdGFydE9mQ29udGVudFBhcnRCTkZSdWxlLFxuICAgICAgICAgICAgbm9XaGl0ZXNwYWNlUGFydEJORlJ1bGUsXG4gICAgICAgICAgICBzZXF1ZW5jZU9mUGFydHNCTkZSdWxlLFxuICAgICAgICAgICAgY2hvaWNlT2ZQYXJ0c0JORlJ1bGUsXG4gICAgICAgICAgICBwYXJ0Q2hvaWNlQk5GUnVsZSxcbiAgICAgICAgICAgIHJ1bGVOYW1lQk5GUnVsZSxcbiAgICAgICAgICAgIHNpZ25pZmljYW50VG9rZW5UeXBlQk5GUnVsZSxcbiAgICAgICAgICAgIHJlZ3VsYXJFeHByZXNzaW9uQk5GUnVsZSxcbiAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxCTkZSdWxlLFxuICAgICAgICAgICAgcHJlY2VkZW50c0JORlJ1bGUsXG4gICAgICAgICAgICBlbmRPZkxpbmVCTkZSdWxlLFxuICAgICAgICAgICAgd2lsZGNhcmRCTkZSdWxlLFxuICAgICAgICAgICAgZXBzaWxvbkJORlJ1bGUsXG4gICAgICAgICAgICBxdWFudGlmaWVyQk5GUnVsZSxcbiAgICAgICAgICAgIG9wYWNpdHlNb2RpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBjYWxsQWhlYWRNb2RpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBvcHRpb25hbFF1YW50aWZpZXJCTkZSdWxlLFxuICAgICAgICAgICAgb25lT3JNb3JlUXVhbnRpZmllckJORlJ1bGUsXG4gICAgICAgICAgICB6ZXJvT3JNb3JlUXVhbnRpZmllckJORlJ1bGUsXG4gICAgICAgICAgICBlcnJvckJORlJ1bGVcbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXJ0UnVsZSA9IHN0YXJ0UnVsZUZyb21SdWxlcyhydWxlcyksXG4gICAgICAgICAgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICAgIGJuZlBhcnNlciA9IG5ldyBCTkZQYXJzZXIoc3RhcnRSdWxlLCBydWxlTWFwKTtcbiAgICBcbiAgICByZXR1cm4gYm5mUGFyc2VyO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oQk5GUGFyc2VyLnByb3RvdHlwZSwgcGFyc2VyTWl4aW5zKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYFxuXG4gICAgZXhwcmVzc2lvbnMgIDo6PSAgZXhwcmVzc2lvbisgO1xuXG4gICAgZXhwcmVzc2lvbiAgIDo6PSAgdGVybS4uLiBcIi5cIiA7XG4gICAgXG4gICAgdGVybSAgICAgICAgIDo6PSAgdGVybV8gdGVybX4qIDtcbiAgICBcbiAgICBvcGVyYXRvciAgICAgOjo9ICBcIitcIlxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFwiLVwiXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgXCIqXCJcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gICAgXG4gICAgbnVtYmVyICAgICAgIDo6PSAgL1xcXFxkKy8gO1xuICAgIFxuICAgIHRlcm1fICAgICAgICA6Oj0gIFwiKFwiIHRlcm0gXCIpXCJcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBudW1iZXJcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gICAgXG4gICAgdGVybX50ZXJtICAgIDo6PSAgb3BlcmF0b3IgdGVybSA7XG4gICAgXG4gICAgdGVybX4gICAgICAgIDo6PSAgdGVybX50ZXJtIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBCTkZMZXhlciB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IEJORlBhcnNlciBmcm9tIFwiLi4vYm5mL3BhcnNlclwiO1xuXG5pbXBvcnQgeyBydWxlTWFwRnJvbVJ1bGVzLCBzdGFydFJ1bGVGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVzXCI7XG5cbmNvbnN0IGJuZkxleGVyID0gQk5GTGV4ZXIuZnJvbU5vdGhpbmcoKSxcbiAgICAgIGJuZlBhcnNlciA9IEJORlBhcnNlci5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGcm9tQk5GKGJuZikge1xuICBjb25zdCB0b2tlbnMgPSBibmZMZXhlci50b2tlbnNGcm9tQk5GKGJuZiksXG4gICAgICAgIHJ1bGVzID0gYm5mUGFyc2VyLnJ1bGVzRnJvbVRva2Vucyh0b2tlbnMpO1xuXG4gIHJldHVybiBydWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcbiAgY29uc3Qgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzKHJ1bGVzKSxcbiAgICAgICAgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBwYXJzZXIgPSBuZXcgQ2xhc3Moc3RhcnRSdWxlLCBydWxlTWFwKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpIHtcbiAgY29uc3Qgc3RhcnRSdWxlID0gc3RhcnRSdWxlRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShydWxlcywgc3RhcnRSdWxlTmFtZSksXG4gICAgICAgIHJ1bGVNYXAgPSBydWxlTWFwRnJvbVJ1bGVzKHJ1bGVzKSxcbiAgICAgICAgcGFyc2VyID0gbmV3IENsYXNzKHN0YXJ0UnVsZSwgcnVsZU1hcCk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBydWxlc0Zyb21CTkYsXG4gIHBhcnNlckZyb21SdWxlcyxcbiAgcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHBhcnNlck1peGlucyBmcm9tIFwiLi4vbWl4aW5zL3BhcnNlclwiO1xuaW1wb3J0IE5vblRlcm1pbmFsTm9kZSBmcm9tIFwiLi8uLi9ub2RlL25vblRlcm1pbmFsXCI7XG5cbmltcG9ydCB7IHJ1bGVzRnJvbUJORiwgcGFyc2VyRnJvbVJ1bGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJzZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tbW9uUGFyc2VyIHtcbiAgY29uc3RydWN0b3Ioc3RhcnRSdWxlLCBydWxlTWFwKSB7XG4gICAgdGhpcy5zdGFydFJ1bGUgPSBzdGFydFJ1bGU7XG4gICAgdGhpcy5ydWxlTWFwID0gcnVsZU1hcDtcbiAgfVxuXG4gIGdldFN0YXJ0UnVsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFJ1bGU7XG4gIH1cblxuICBnZXRSdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVNYXA7XG4gIH1cblxuICBzdGF0aWMgTm9uVGVybWluYWxOb2RlTWFwID0ge307XG5cbiAgc3RhdGljIGRlZmF1bHROb25UZXJtaW5hbE5vZGUgPSBOb25UZXJtaW5hbE5vZGU7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKENsYXNzKSB7XG4gICAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZiksXG4gICAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgc3RhdGljIGZyb21CTkYoQ2xhc3MsIGJuZikge1xuICAgIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZiksXG4gICAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhDbGFzcywgcnVsZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICAgIHJldHVybiBwYXJzZXI7XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihDb21tb25QYXJzZXIucHJvdG90eXBlLCBwYXJzZXJNaXhpbnMpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuaW1wb3J0IENvbW1vblBhcnNlciBmcm9tIFwiLi4vY29tbW9uL3BhcnNlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEJhc2ljUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoQmFzaWNQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKEJhc2ljUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVwc2lsb25QYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvZXBzaWxvblwiO1xuaW1wb3J0IFJ1bGVOYW1lUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL3J1bGVOYW1lXCI7XG5pbXBvcnQgV2lsZGNhcmRQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvd2lsZGNhcmRcIjtcbmltcG9ydCBFbmRPZkxpbmVQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvZW5kT2ZMaW5lXCI7XG5pbXBvcnQgT3B0aW9uYWxQYXJ0UGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL29wdGlvbmFsUGFydFwiO1xuaW1wb3J0IFN0cmluZ0xpdGVyYWxQYXJ0IGZyb20gXCIuL3BhcnQvdGVybWluYWwvc3RyaW5nTGl0ZXJhbFwiO1xuaW1wb3J0IENob2ljZU9mUGFydHNQYXJ0IGZyb20gXCIuL3BhcnQvbm9uVGVybWluYWwvY2hvaWNlT2ZQYXJ0c1wiO1xuaW1wb3J0IE9uZU9yTW9yZVBhcnRzUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL29uZU9yTW9yZVBhcnRzXCI7XG5pbXBvcnQgU2VxdWVuY2VPZlBhcnRzUGFydCBmcm9tIFwiLi9wYXJ0L25vblRlcm1pbmFsL3NlcXVlbmNlT2ZQYXJ0c1wiO1xuaW1wb3J0IFplcm9Pck1vcmVQYXJ0c1BhcnQgZnJvbSBcIi4vcGFydC9ub25UZXJtaW5hbC96ZXJvT3JNb3JlUGFydHNcIjtcbmltcG9ydCBSZWd1bGFyRXhwcmVzc2lvblBhcnQgZnJvbSBcIi4vcGFydC90ZXJtaW5hbC9yZWd1bGFyRXhwcmVzc2lvblwiO1xuaW1wb3J0IFNpZ25pZmljYW50VG9rZW5UeXBlUGFydCBmcm9tIFwiLi9wYXJ0L3Rlcm1pbmFsL3NpZ25pZmljYW50VG9rZW5UeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRXBzaWxvblBhcnQsXG4gIFJ1bGVOYW1lUGFydCxcbiAgV2lsZGNhcmRQYXJ0LFxuICBFbmRPZkxpbmVQYXJ0LFxuICBPcHRpb25hbFBhcnRQYXJ0LFxuICBDaG9pY2VPZlBhcnRzUGFydCxcbiAgU3RyaW5nTGl0ZXJhbFBhcnQsXG4gIE9uZU9yTW9yZVBhcnRzUGFydCxcbiAgU2VxdWVuY2VPZlBhcnRzUGFydCxcbiAgWmVyb09yTW9yZVBhcnRzUGFydCxcbiAgUmVndWxhckV4cHJlc3Npb25QYXJ0LFxuICBTaWduaWZpY2FudFRva2VuVHlwZVBhcnRcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQk5GUGFyc2VyIH0gZnJvbSBcIi4vYm5mL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNpY1BhcnNlciB9IGZyb20gXCIuL2Jhc2ljL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21tb25QYXJzZXIgfSBmcm9tIFwiLi9jb21tb24vcGFyc2VyXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9kZU1peGlucyB9IGZyb20gXCIuL21peGlucy9ub2RlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgcnVsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvcnVsZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2VyVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bGUgfSBmcm9tIFwiLi9ydWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRzIH0gZnJvbSBcIi4vcGFydHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFydFR5cGVzIH0gZnJvbSBcIi4vcGFydFR5cGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBhcnRDaG9pY2UgfSBmcm9tIFwiLi9wYXJ0Q2hvaWNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlZmluaXRpb24gfSBmcm9tIFwiLi9kZWZpbml0aW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVwc2lsb25Ob2RlIH0gZnJvbSBcIi4vbm9kZS90ZXJtaW5hbC9lcHNpbG9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL25vZGUvdGVybWluYWxcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIi4vbm9kZS9ub25UZXJtaW5hbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBzdHlsZXNoZWV0ICAgICAgICAgICAgICAgICA6Oj0gKCBtZWRpYSB8IHJ1bGVTZXQgfCBrZXlmcmFtZXMgfCBkZWNsYXJhdGlvbiB8IGVycm9yICkrIDtcblxuXG4gICAgbWVkaWEgICAgICAgICAgICAgICAgICAgICAgOjo9IFwiQG1lZGlhXCIgbWVkaWFRdWVyaWVzIFwie1wiICggcnVsZVNldCB8IGRlY2xhcmF0aW9uICkqIFwifVwiIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgcnVsZVNldCAgICAgICAgICAgICAgICAgICAgOjo9ICBzZWxlY3RvcnMgXCJ7XCIgZGVjbGFyYXRpb24qIFwifVwiIDtcbiAgICBcbiAgICBcbiAgICBrZXlmcmFtZXMgICAgICAgICAgICAgICAgICA6Oj0gXCJAa2V5ZnJhbWVzXCIgW2lkZW50aWZpZXJdIFwie1wiIGtleWZyYW1lKyBcIn1cIiA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlY2xhcmF0aW9uICAgICAgICAgICAgICAgIDo6PSAgcHJvcGVydHlOYW1lIFwiOlwiIHByb3BlcnR5VmFsdWVzIGltcG9ydGFudD8gXCI7XCIgO1xuXG5cbiAgICBlcnJvci4gICAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5cbiAgICBwcm9wZXJ0eVZhbHVlcyAgICAgICAgICAgICA6Oj0gIHByb3BlcnR5VmFsdWUgKCBcIixcIiBwcm9wZXJ0eVZhbHVlICkqIDtcblxuXG4gICAgbWVkaWFRdWVyaWVzICAgICAgICAgICAgICAgOjo9ICBtZWRpYVF1ZXJ5ICggKCBcIixcIiB8IFwib3JcIiApIG1lZGlhUXVlcnkgKSogO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgc2VsZWN0b3JzICAgICAgICAgICAgICAgICAgOjo9ICBzZWxlY3RvciAoIFwiLFwiIHNlbGVjdG9yICkqIDtcblxuXG4gICAga2V5ZnJhbWUgICAgICAgICAgICAgICAgICAgOjo9ICBbcGVyY2VudGFnZV0gXCJ7XCIgZGVjbGFyYXRpb24rIFwifVwiIDtcbiAgICBcbiAgICBcbiAgICBtZWRpYVF1ZXJ5ICAgICAgICAgICAgICAgICA6Oj0gICggXCJub3RcIj8gbWVkaWFUeXBlIFwiYW5kXCIgKT8gbWVkaWFGZWF0dXJlcyBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFwibm90XCI/IG1lZGlhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIG1lZGlhVHlwZSAgICAgICAgICAgICAgICAgIDo6PSAgXCJhbGxcIiB8IFwicHJpbnRcIiB8IFwic2NyZWVuXCIgfCBcInNwZWVjaFwiIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIG1lZGlhRmVhdHVyZXMgICAgICAgICAgICAgIDo6PSAgKCBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFGZWF0dXJlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCIoXCIgXCJub3RcIiBtZWRpYUZlYXR1cmUgXCIpXCIgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFuZFwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRmVhdHVyZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCIoXCIgXCJub3RcIiBtZWRpYUZlYXR1cmUgXCIpXCIgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBtZWRpYUZlYXR1cmUgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIFtpZGVudGlmaWVyXSAoIFwiOlwiIHByb3BlcnR5VmFsdWUgKT8gXCIpXCIgO1xuXG5cbiAgICBwcm9wZXJ0eVZhbHVlICAgICAgICAgICAgICA6Oj0gIHRlcm0gKCBcIixcIj8gdGVybSApKiA7XG5cblxuICAgIHByb3BlcnR5TmFtZSAgICAgICAgICAgICAgIDo6PSAgW2lkZW50aWZpZXJdIDtcblxuXG4gICAgaW1wb3J0YW50ICAgICAgICAgICAgICAgICAgOjo9ICBcIiFpbXBvcnRhbnRcIiA7XG5cblxuICAgIHNlbGVjdG9yICAgICAgICAgICAgICAgICAgIDo6PSAgKCBjbGFzcyB8IHBzZXVkb0NsYXNzIHwgcHNldWRvRWxlbWVudCB8IGF0dHJpYnV0ZSApKyA7XG5cblxuICAgIGNsYXNzICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCIuXCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBzZXVkb0NsYXNzICAgICAgICAgICAgICAgIDo6PSAgXCI6XCI8Tk9fV0hJVEVTUEFDRT5baWRlbnRpZmllcl0gcGFyZW50aGVzaXNlZFNlbGVjdG9yPyA7XG5cblxuICAgIHBzZXVkb0VsZW1lbnQgICAgICAgICAgICAgIDo6PSAgXCI6OlwiPE5PX1dISVRFU1BBQ0U+W2lkZW50aWZpZXJdIHBhcmVudGhlc2lzZWRTZWxlY3Rvcj8gO1xuXG5cbiAgICBwYXJlbnRoZXNpc2VkU2VsZWN0b3IgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiKFwiIHNlbGVjdG9yIDxOT19XSElURVNQQUNFPlwiKVwiIDtcblxuXG4gICAgYXR0cmlidXRlICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCI9XCIgfCBcIn49XCIgfCBcInw9XCIgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW2lkZW50aWZpZXJdIHwgW3N0cmluZy1saXRlcmFsXSApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG4gICAgdGVybSAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBbcGx1cy1vci1taW51c10/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFtwZXJjZW50YWdlXSB8IFtmcmVxdWVuY3ldIHwgW2ZyYWN0aW9uXSB8IFtsZW5ndGhdIHwgW2FuZ2xlXSB8IFtyZW1zXSB8IFtlbXNdIHwgW3RpbWVdIHwgW251bWJlcl0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0cmluZy1saXRlcmFsXStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZGVudGlmaWVyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbG91cl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuICAgIHVyaSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCJ1cmxcIjxOT19XSElURVNQQUNFPlwiKFwiIFtzdHJpbmctbGl0ZXJhbF0gXCIpXCIgO1xuXG5cbiAgICBmdW5jdGlvbiAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXTxOT19XSElURVNQQUNFPlwiKFwiIHByb3BlcnR5VmFsdWUgXCIpXCIgO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTU1BhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKENTU1BhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKENTU1BhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoQ1NTUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IEVSUk9SX1JVTEVfTkFNRSA9IFwiZXJyb3JcIjtcbmV4cG9ydCBjb25zdCBJTkRFWF9SVUxFX05BTUUgPSBcImluZGV4XCI7XG5leHBvcnQgY29uc3QgVU5JUVVFX1JVTEVfTkFNRSA9IFwidW5pcXVlXCI7XG5leHBvcnQgY29uc3QgU1BSRUFEX1JVTEVfTkFNRSA9IFwic3ByZWFkXCI7XG5leHBvcnQgY29uc3QgRU5EX0lOREVYX1JVTEVfTkFNRSA9IFwiZW5kSW5kZXhcIjtcbmV4cG9ydCBjb25zdCBSVUxFX05BTUVfUlVMRV9OQU1FID0gXCJydWxlTmFtZVwiO1xuZXhwb3J0IGNvbnN0IFRPS0VOX1RZUEVfUlVMRV9OQU1FID0gXCJ0b2tlblR5cGVcIjtcbmV4cG9ydCBjb25zdCBTVEFSVF9JTkRFWF9SVUxFX05BTUUgPSBcInN0YXJ0SW5kZXhcIjtcbmV4cG9ydCBjb25zdCBTVUJfRVhQUkVTU0lPTl9SVUxFX05BTUUgPSBcInN1YkV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBJTkZJTklURV9ERVNDRU5UX1JVTEVfTkFNRSA9IFwiaW5maW5pdGVEZXNjZW50XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVSUk9SX1JVTEVfTkFNRSxcbiAgICAgICAgIElOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFVOSVFVRV9SVUxFX05BTUUsXG4gICAgICAgICBTUFJFQURfUlVMRV9OQU1FLFxuICAgICAgICAgRU5EX0lOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFJVTEVfTkFNRV9SVUxFX05BTUUsXG4gICAgICAgICBUT0tFTl9UWVBFX1JVTEVfTkFNRSxcbiAgICAgICAgIFNUQVJUX0lOREVYX1JVTEVfTkFNRSxcbiAgICAgICAgIFNVQl9FWFBSRVNTSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIElORklOSVRFX0RFU0NFTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhGcm9tSW5kZXhOb2RlKGluZGV4Tm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbmRleE5vZGUsIC8vL1xuICAgICAgICBpbmRleCA9IGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChmaXJzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgICAgICAgaW5kZXggPSBOdW1iZXIoY29udGVudCk7XG5cbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVOYW1lc0Zyb21QYXRoTm9kZShwYXRoTm9kZSkge1xuICBjb25zdCBzZWxlY3Rvck5vZGVzID0gc2VsZWN0b3JOb2Rlc0Zyb21QYXRoTm9kZShwYXRoTm9kZSksXG4gICAgICAgIHJ1bGVOYW1lTm9kZXMgPSBzZWxlY3Rvck5vZGVzLnJlZHVjZSgocnVsZU5hbWVOb2Rlcywgc2VsZWN0b3JOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2VsZWN0b3JOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICBydWxlTmFtZU5vZGUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBydWxlTmFtZU5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWVSdWxlTmFtZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBSVUxFX05BTUVfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVOYW1lUnVsZU5hbWVSdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZU5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZU5hbWVOb2RlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJ1bGVOYW1lTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVsZU5hbWVOb2Rlcy5wdXNoKHJ1bGVOYW1lTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lTm9kZXM7XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgcnVsZU5hbWVzID0gcnVsZU5hbWVOb2Rlcy5tYXAoKHJ1bGVOYW1lTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHJ1bGVOYW1lTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gY29udGVudDsgLy8vXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBydWxlTmFtZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuVHlwZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0b3JOb2RlcyA9IHNlbGVjdG9yTm9kZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICB0b2tlblR5cGVOb2RlcyA9IHNlbGVjdG9yTm9kZXMucmVkdWNlKCh0b2tlblR5cGVOb2Rlcywgc2VsZWN0b3JOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2VsZWN0b3JOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICB0b2tlblR5cGVOb2RlID0gZnJvbUZpcnN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGZpcnN0Q2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgdG9rZW5UeXBlTm9kZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGZpcnN0Q2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlTmFtZVRva2VuVHlwZVJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBUT0tFTl9UWVBFX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChydWxlTmFtZVRva2VuVHlwZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZU5vZGUgPSBub25UZXJtaW5hbE5vZGU7IC8vL1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5UeXBlTm9kZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0b2tlblR5cGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlblR5cGVOb2Rlcy5wdXNoKHRva2VuVHlwZU5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b2tlblR5cGVOb2RlcztcbiAgICAgICAgfSwgW10pLFxuICAgICAgICB0b2tlblR5cGVzID0gdG9rZW5UeXBlTm9kZXMubWFwKCh0b2tlblR5cGVOb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdG9rZW5UeXBlTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgIHRva2VuVHlwZSA9IGZyb21UaGlyZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsICh0aGlyZENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gdGhpcmRDaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlID0gY29udGVudDsgIC8vL1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHRva2VuVHlwZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHRva2VuVHlwZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rvck5vZGVzRnJvbVBhdGhOb2RlKHBhdGhOb2RlKSB7XG4gIGxldCBub25UZXJtaW5hbE5vZGU7XG5cbiAgbm9uVGVybWluYWxOb2RlID0gcGF0aE5vZGU7IC8vL1xuXG4gIGNvbnN0IHNlbGVjdG9yc05vZGUgPSBmcm9tTGFzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChsYXN0Q2hpbGROb2RlKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3JzTm9kZSA9IGxhc3RDaGlsZE5vZGU7ICAvLy9cblxuICAgIHJldHVybiBzZWxlY3RvcnNOb2RlO1xuICB9KTtcblxuICBub25UZXJtaW5hbE5vZGUgPSBzZWxlY3RvcnNOb2RlOyAgLy8vXG5cbiAgY29uc3Qgc2VsZWN0b3JOb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5maWx0ZXJDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2VsZWN0b3JOb2Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZmluaXRlRGVzY2VudEZyb21QYXRoTm9kZShwYXRoTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBwYXRoTm9kZSwgLy8vXG4gICAgICAgIGluZmluaXRlRGVzY2VudCA9IGZyb21TZWNvbmRDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoc2Vjb25kQ2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZUluZmluaXRlRGVzY2VudFJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBJTkZJTklURV9ERVNDRU5UX1JVTEVfTkFNRSksXG4gICAgICAgICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gcnVsZU5hbWVJbmZpbml0ZURlc2NlbnRSdWxlTmFtZTsgIC8vL1xuXG4gICAgICAgICAgcmV0dXJuIGluZmluaXRlRGVzY2VudDtcbiAgICAgICAgfSkgfHwgZmFsc2U7XG5cbiAgcmV0dXJuIGluZmluaXRlRGVzY2VudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ByZWFkTm9kZSxcbiAgICAgICAgdW5pcXVlID0gZnJvbUZpcnN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGZpcnN0Q2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgbGV0IHVuaXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgaWYgKGZpcnN0Q2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBmaXJzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgcnVsZU5hbWVVbmlxdWVSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gVU5JUVVFX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGlmIChydWxlTmFtZVVuaXF1ZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHVuaXF1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuaXF1ZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHVuaXF1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4RnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSkge1xuICBsZXQgaW5kZXggPSBudWxsO1xuXG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNwcmVhZE5vZGUsIC8vL1xuICAgICAgICBpbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZUluZGV4UnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IElOREVYX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGlmIChydWxlTmFtZUluZGV4UnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChpbmRleE5vZGUgIT09IG51bGwpIHtcbiAgICBpbmRleCA9IGluZGV4RnJvbUluZGV4Tm9kZShpbmRleE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kSW5kZXhGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKSB7XG4gIGxldCBlbmRJbmRleCA9IEluZmluaXR5O1xuXG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNwcmVhZE5vZGUsIC8vL1xuICAgICAgICBlbmRJbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZUVuZEluZGV4UnVsZU5hbWUgPSAocnVsZU5hbWUgPT09IEVORF9JTkRFWF9SVUxFX05BTUUpO1xuXG4gICAgICAgICAgICBpZiAocnVsZU5hbWVFbmRJbmRleFJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoZW5kSW5kZXhOb2RlICE9PSBudWxsKSB7XG4gICAgZW5kSW5kZXggPSBpbmRleEZyb21JbmRleE5vZGUoZW5kSW5kZXhOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBlbmRJbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0SW5kZXhGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKSB7XG4gIGxldCBzdGFydEluZGV4ID0gMDtcblxuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBzcHJlYWROb2RlLCAvLy9cbiAgICAgICAgc3RhcnRJbmRleE5vZGUgPSBub25UZXJtaW5hbE5vZGUuZmluZENoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsICAvLy9cbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICBydWxlTmFtZVN0YXJ0SW5kZXhSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1RBUlRfSU5ERVhfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVOYW1lU3RhcnRJbmRleFJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoc3RhcnRJbmRleE5vZGUgIT09IG51bGwpIHtcbiAgICBzdGFydEluZGV4ID0gaW5kZXhGcm9tSW5kZXhOb2RlKHN0YXJ0SW5kZXhOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGFydEluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBwYXRoTm9kZSA9IGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChmaXJzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGhOb2RlID0gZmlyc3RDaGlsZE5vZGU7ICAvLy9cblxuICAgICAgICAgIHJldHVybiBwYXRoTm9kZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHBhdGhOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkTm9kZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIHNwcmVhZE5vZGUgPSBmcm9tU2Vjb25kQ2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKHNlY29uZENoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGxldCBzcHJlYWROb2RlID0gbnVsbDtcblxuICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHNlY29uZENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgcnVsZU5hbWVTcHJlYWRSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1BSRUFEX1JVTEVfTkFNRSk7XG5cbiAgICAgICAgICBpZiAocnVsZU5hbWVTcHJlYWRSdWxlTmFtZSkge1xuICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNlY29uZENoaWxkTm9kZTsgIC8vL1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzcHJlYWROb2RlO1xuICAgICAgICB9KSB8fCBudWxsO1xuXG4gIHJldHVybiBzcHJlYWROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JOb2Rlc0Zyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSkge1xuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIGVycm9yTm9kZXMgPSBub25UZXJtaW5hbE5vZGUucmVkdWNlQ2hpbGROb2RlKChlcnJvck5vZGVzLCBjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lRXJyb3JSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gRVJST1JfUlVMRV9OQU1FKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVOYW1lRXJyb3JSdWxlTmFtZSkge1xuICAgICAgICAgICAgICBjb25zdCBlcnJvck5vZGUgPSBub25UZXJtaW5hbE5vZGU7ICAvLy9cblxuICAgICAgICAgICAgICBlcnJvck5vZGVzLnB1c2goZXJyb3JOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXJyb3JOb2RlcztcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBlcnJvck5vZGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbk5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgbGV0IHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBleHByZXNzaW9uTm9kZSwgLy8vXG4gICAgICAgIG11bHRpcGxpY2l0eSA9IG5vblRlcm1pbmFsTm9kZS5nZXRNdWx0aXBsaWNpdHkoKTtcblxuICBpZiAobXVsdGlwbGljaXR5ID4gMSkge1xuICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gZnJvbUxhc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAobGFzdENoaWxkTm9kZSkgPT4ge1xuICAgICAgbGV0IHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbGFzdENoaWxkTm9kZSwgIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJ1bGVOYW1lU3ViRXhwcmVzc2lvblJ1bGVOYW1lID0gKHJ1bGVOYW1lID09PSBTVUJfRVhQUkVTU0lPTl9SVUxFX05BTUUpO1xuXG4gICAgICBpZiAocnVsZU5hbWVTdWJFeHByZXNzaW9uUnVsZU5hbWUpIHtcbiAgICAgICAgc3ViRXhwcmVzc2lvbk5vZGUgPSBsYXN0Q2hpbGROb2RlOyAgLy8vXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJFeHByZXNzaW9uTm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdWJFeHByZXNzaW9uTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhOb2RlRnJvbVN1YkV4cHJlc3Npb25Ob2RlKHN1YkV4cHJlc3Npb25Ob2RlKSB7XG4gIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlLCAvLy9cbiAgICAgICAgcGF0aE5vZGUgPSBmcm9tRmlyc3RDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCAoZmlyc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwYXRoTm9kZSA9IGZpcnN0Q2hpbGROb2RlOyAgLy8vXG5cbiAgICAgICAgICByZXR1cm4gcGF0aE5vZGU7XG4gICAgICAgIH0pXG5cbiAgcmV0dXJuIHBhdGhOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZShzdWJFeHByZXNzaW9uTm9kZSkge1xuICBsZXQgc3ByZWFkTm9kZSA9IG51bGw7XG5cbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ViRXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCk7XG5cbiAgaWYgKG11bHRpcGxpY2l0eSA+IDEpIHtcbiAgICBzcHJlYWROb2RlID0gZnJvbVNlY29uZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIChzZWNvbmRDaGlsZE5vZGUpID0+IHtcbiAgICAgIGxldCBzcHJlYWROb2RlID0gbnVsbDtcblxuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgcnVsZU5hbWVTcHJlYWRSdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1BSRUFEX1JVTEVfTkFNRSk7XG5cbiAgICAgIGlmIChydWxlTmFtZVNwcmVhZFJ1bGVOYW1lKSB7XG4gICAgICAgIHNwcmVhZE5vZGUgPSBzZWNvbmRDaGlsZE5vZGU7ICAvLy9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwcmVhZE5vZGU7XG4gICAgfSkgfHwgbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzcHJlYWROb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViRXhwcmVzc2lvbk5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gc3ViRXhwcmVzc2lvbk5vZGU7IC8vL1xuXG4gIHN1YkV4cHJlc3Npb25Ob2RlID0gbnVsbDtcblxuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCk7XG5cbiAgaWYgKG11bHRpcGxpY2l0eSA+IDEpIHtcbiAgICBzdWJFeHByZXNzaW9uTm9kZSA9IGZyb21MYXN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgKGxhc3RDaGlsZE5vZGUpID0+IHtcbiAgICAgIGxldCBzdWJFeHByZXNzaW9uTm9kZSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9lID0gbGFzdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9lLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBydWxlTmFtZVN1YkV4cHJlc3Npb25SdWxlTmFtZSA9IChydWxlTmFtZSA9PT0gU1VCX0VYUFJFU1NJT05fUlVMRV9OQU1FKTtcblxuICAgICAgaWYgKHJ1bGVOYW1lU3ViRXhwcmVzc2lvblJ1bGVOYW1lKSB7XG4gICAgICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gbGFzdENoaWxkTm9kZTsgIC8vL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ViRXhwcmVzc2lvbk5vZGU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3ViRXhwcmVzc2lvbk5vZGU7XG59XG5cbmZ1bmN0aW9uIGZyb21GaXJzdENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3QgZmlyc3RJbmRleCA9IDA7XG5cbiAgbm9uVGVybWluYWxOb2RlLmZvcndhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gZmlyc3RJbmRleCkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayhmaXJzdENoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZnJvbVNlY29uZENoaWxkTm9kZShub25UZXJtaW5hbE5vZGUsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQ7XG5cbiAgY29uc3Qgc2Vjb25kSW5kZXggPSAxO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5mb3J3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IHNlY29uZEluZGV4KSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkTm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGZpcnN0Q2hpbGROb2RlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmcm9tVGhpcmRDaGlsZE5vZGUobm9uVGVybWluYWxOb2RlLCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0O1xuXG4gIGNvbnN0IHRoaXJkSW5kZXggPSAyO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5mb3J3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXJkSW5kZXgpIHtcbiAgICAgIGNvbnN0IHRoaXJkQ2hpbGROb2RlID0gY2hpbGROb2RlOyAvLy9cblxuICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodGhpcmRDaGlsZE5vZGUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZyb21MYXN0Q2hpbGROb2RlKG5vblRlcm1pbmFsTm9kZSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdDtcblxuICBjb25zdCBtdWx0aXBsaWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0TXVsdGlwbGljaXR5KCksXG4gICAgICAgIGxhc3RJbmRleCA9IG11bHRpcGxpY2l0eSAtIDE7XG5cbiAgbm9uVGVybWluYWxOb2RlLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgY29uc3QgdGhpcmRDaGlsZE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh0aGlyZENoaWxkTm9kZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbVBhdGhOb2RlLCB0b2tlblR5cGVzRnJvbVBhdGhOb2RlLCBpbmZpbml0ZURlc2NlbnRGcm9tUGF0aE5vZGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIHtcbiAgY29uc3RydWN0b3IocnVsZU5hbWVzLCB0b2tlblR5cGVzLCBpbmZpbml0ZURlc2NlbnQpIHtcbiAgICB0aGlzLnJ1bGVOYW1lcyA9IHJ1bGVOYW1lcztcbiAgICB0aGlzLnRva2VuVHlwZXMgPSB0b2tlblR5cGVzO1xuICAgIHRoaXMuaW5maW5pdGVEZXNjZW50ID0gaW5maW5pdGVEZXNjZW50O1xuICB9XG5cbiAgZ2V0UnVsZU5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVOYW1lcztcbiAgfVxuXG4gIGdldFRva2VuVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5UeXBlcztcbiAgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXRlRGVzY2VudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGF0aE5vZGUocGF0aE5vZGUpIHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgIHRva2VuVHlwZXMgPSB0b2tlblR5cGVzRnJvbVBhdGhOb2RlKHBhdGhOb2RlKSxcbiAgICAgICAgICBpbmZpbml0ZURlc2NlbnQgPSBpbmZpbml0ZURlc2NlbnRGcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChydWxlTmFtZXMsIHRva2VuVHlwZXMsIGluZmluaXRlRGVzY2VudCk7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuZXhwb3J0IGNvbnN0IHsgY2xlYXIsIHB1c2gsIGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBmb3VydGgsIGZpZnRoLCBsYXN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oYXJyYXksIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgLy8vXG5cbiAgICBzdGFydEluZGV4ID0gbGVuZ3RoICsgc3RhcnRJbmRleDsgLy8vXG5cbiAgICBlbmRJbmRleCA9IGxlbmd0aCArIGVuZEluZGV4OyAvLy9cbiAgfVxuXG4gIGlmIChlbmRJbmRleCAhPT0gSW5maW5pdHkpIHtcbiAgICBjb25zdCBzdGFydCA9IGVuZEluZGV4ICsgMTtcblxuICAgIGFycmF5LnNwbGljZShzdGFydCk7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IDAsXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gc3RhcnRJbmRleDsgLy8vXG5cbiAgYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgLi4uZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IGFycmF5LmluY2x1ZGVzKGVsZW1lbnQpKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hhcmFjdGVycyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgY2xlYXIsIHRyaW0sIHNlY29uZCwgdGhpcmQsIGZvdXJ0aCB9IGZyb20gXCIuL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgaW5kZXhGcm9tU3ByZWFkTm9kZSxcbiAgICAgICAgIHVuaXF1ZUZyb21TcHJlYWROb2RlLFxuICAgICAgICAgZW5kSW5kZXhGcm9tU3ByZWFkTm9kZSxcbiAgICAgICAgIHN0YXJ0SW5kZXhGcm9tU3ByZWFkTm9kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IHsgRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVIgfSA9IGNoYXJhY3RlcnM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcmVhZCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpIHtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICB0aGlzLnVuaXF1ZSA9IHVuaXF1ZTtcbiAgfVxuXG4gIGFkanVzdE5vZGVzKG5vZGVzKSB7XG4gICAgaWYgKHRoaXMudW5pcXVlKSB7XG4gICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVzTGVuZ3RoID4gMSkge1xuICAgICAgICBjbGVhcihub2Rlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaW0obm9kZXMsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5lbmRJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgIGVuZEluZGV4ID0gSW5maW5pdHksXG4gICAgICAgICAgdW5pcXVlID0gZmFsc2UsXG4gICAgICAgICAgc3ByZWFkID0gbmV3IFNwcmVhZChzdGFydEluZGV4LCBlbmRJbmRleCwgdW5pcXVlKTtcblxuICAgIHJldHVybiBzcHJlYWQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSkge1xuICAgIGxldCBzdGFydEluZGV4ID0gMCxcbiAgICAgICAgZW5kSW5kZXggPSBJbmZpbml0eSxcbiAgICAgICAgdW5pcXVlID0gZmFsc2U7XG5cbiAgICBpZiAoc3ByZWFkTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kZXggPSBpbmRleEZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4OyAvLy9cblxuICAgICAgICBlbmRJbmRleCA9IGluZGV4OyAvLy9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4RnJvbVNwcmVhZE5vZGUoc3ByZWFkTm9kZSk7XG5cbiAgICAgICAgZW5kSW5kZXggPSBlbmRJbmRleEZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuICAgICAgfVxuXG4gICAgICB1bmlxdWUgPSB1bmlxdWVGcm9tU3ByZWFkTm9kZShzcHJlYWROb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcHJlYWQgPSBuZXcgU3ByZWFkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpO1xuXG4gICAgcmV0dXJuIHNwcmVhZDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3ByZWFkRXhwcmVzc2lvbihzcHJlYWRFeHByZXNzaW9uKSB7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLFxuICAgICAgICBlbmRJbmRleCA9IEluZmluaXR5LFxuICAgICAgICB1bmlxdWUgPSBmYWxzZTtcblxuICAgIGlmIChzcHJlYWRFeHByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoc3ByZWFkRXhwcmVzc2lvbiA9PT0gRVhDTEFNQVRJT05fTUFSS19DSEFSQUNURVIpIHtcbiAgICAgICAgdW5pcXVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9IC9cXFsoLT9cXGQrKT8oXFwuXFwuXFwuKT8oLT9cXGQrKT9dLyxcbiAgICAgICAgICAgICAgbWF0Y2hlcyA9IHNwcmVhZEV4cHJlc3Npb24ubWF0Y2gocmVnRXhwKSxcbiAgICAgICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcykgfHwgbnVsbCxcbiAgICAgICAgICAgICAgdGhpcmRNYXRjaCA9IHRoaXJkKG1hdGNoZXMpIHx8IG51bGwsXG4gICAgICAgICAgICAgIGZvdXJ0aE1hdGNoID0gZm91cnRoKG1hdGNoZXMpIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKHNlY29uZE1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHBhcnNlSW50KHNlY29uZE1hdGNoKTtcblxuICAgICAgICAgIGlmICh0aGlyZE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IHN0YXJ0SW5kZXg7ICAvLy9cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91cnRoTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICBlbmRJbmRleCA9IHBhcnNlSW50KGZvdXJ0aE1hdGNoKTtcblxuICAgICAgICAgIGlmICh0aGlyZE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gZW5kSW5kZXg7ICAvLy9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcHJlYWQgPSBuZXcgU3ByZWFkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB1bmlxdWUpO1xuXG4gICAgcmV0dXJuIHNwcmVhZDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGF0aCBmcm9tIFwiLi9wYXRoXCI7XG5pbXBvcnQgU3ByZWFkIGZyb20gXCIuL3NwcmVhZFwiO1xuXG5pbXBvcnQgeyBwYXRoTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZSwgc3ByZWFkTm9kZUZyb21TdWJFeHByZXNzaW9uTm9kZSwgc3ViRXhwcmVzc2lvbk5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbm9kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGF0aCwgc3ByZWFkLCBzdWJFeHByZXNzaW9uKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnNwcmVhZCA9IHNwcmVhZDtcbiAgICB0aGlzLnN1YkV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9XG5cbiAgZ2V0U3ByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnNwcmVhZDtcbiAgfVxuXG4gIGdldFN1YkV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFJ1bGVOYW1lcygpIHsgcmV0dXJuIHRoaXMucGF0aC5nZXRSdWxlTmFtZXMoKTsgfVxuXG4gIGdldFRva2VuVHlwZXMoKSB7IHJldHVybiB0aGlzLnBhdGguZ2V0VG9rZW5UeXBlcygpOyB9XG5cbiAgaXNJbmZpbml0ZURlc2NlbnQoKSB7IHJldHVybiB0aGlzLnBhdGguaXNJbmZpbml0ZURlc2NlbnQoKTsgfVxuXG4gIHN0YXRpYyBmcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpIHtcbiAgICBsZXQgc3ViRXhwcmVzc2lvbiA9IG51bGw7XG5cbiAgICBpZiAoc3ViRXhwcmVzc2lvbk5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhdGhOb2RlID0gcGF0aE5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlRnJvbVN1YkV4cHJlc3Npb25Ob2RlKHN1YkV4cHJlc3Npb25Ob2RlKTsgIC8vL1xuXG4gICAgICBjb25zdCBwYXRoID0gUGF0aC5mcm9tUGF0aE5vZGUocGF0aE5vZGUpLFxuICAgICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbi5mcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICBzdWJFeHByZXNzaW9uID0gbmV3IFN1YkV4cHJlc3Npb24ocGF0aCwgc3ByZWFkLCBzdWJFeHByZXNzaW9uKTsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YkV4cHJlc3Npb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OkB8IXxcXFxcKnxcXFxcfHxcXFxcL3xcXFxcW3xcXFxcXXxcXFxcLlxcXFwuXFxcXC4pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIl5bYS16QS1aXFxcXC1dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBcIl5bMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXi5cIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHByZXNzaW9uTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuOyAvLy9cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoRXhwcmVzc2lvbkxleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoRXhwcmVzc2lvbkxleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEV4cHJlc3Npb25MZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgIGV4cHJlc3Npb24gICAgICAgOjo9ICBwYXRoIHNwcmVhZD8gc3ViRXhwcmVzc2lvbj8gICBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgfCAgZXJyb3IrIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgIDtcbiAgXG4gICAgcGF0aCAgICAgICAgICAgICA6Oj0gIFwiL1wiIGluZmluaXRlRGVzY2VudD8gc2VsZWN0b3JzIDtcbiAgICBcbiAgICBzdWJFeHByZXNzaW9uICAgIDo6PSAgcGF0aCBzcHJlYWQ/IHN1YkV4cHJlc3Npb24/O1xuXG4gICAgaW5maW5pdGVEZXNjZW50ICA6Oj0gIFwiL1wiIDtcbiAgICBcbiAgICBzZWxlY3RvcnMgICAgICAgIDo6PSAgc2VsZWN0b3IgKCBcInxcIiBzZWxlY3RvciApKiA7XG5cbiAgICBzcHJlYWQgICAgICAgICAgIDo6PSAgdW5pcXVlXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgIHwgIFwiW1wiIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzdGFydEluZGV4IFwiLi4uXCIgZW5kSW5kZXggKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggc3RhcnRJbmRleCBcIi4uLlwiICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFwiLi4uXCIgZW5kSW5kZXggKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICApICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiIDtcblxuICAgIHNlbGVjdG9yICAgICAgICAgOjo9ICBydWxlTmFtZSB8IHRva2VuVHlwZSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHJ1bGVOYW1lICAgICAgICAgOjo9ICBbbmFtZV0gfCBcIipcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHRva2VuVHlwZSAgICAgICAgOjo9ICBcIkBcIjxOT19XSElURVNQQUNFPiggW25hbWVdIHwgXCIqXCIgKSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHN0YXJ0SW5kZXggICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGVuZEluZGV4ICAgICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGluZGV4ICAgICAgICAgICAgOjo9ICBbbnVtYmVyXSA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHVuaXF1ZSAgICAgICAgICAgOjo9ICBcIiFcIiA7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuXG5cbiAgICBlcnJvci4gICAgICAgICAgIDo6PSAgLiA7XG4gICAgXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhFeHByZXNzaW9uUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoRXhwcmVzc2lvblBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoRXhwcmVzc2lvblBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQYXRoIGZyb20gXCIuL3BhdGhcIjtcbmltcG9ydCBTcHJlYWQgZnJvbSBcIi4vc3ByZWFkXCI7XG5pbXBvcnQgU3ViRXhwcmVzc2lvbiBmcm9tIFwiLi9zdWJFeHByZXNzaW9uXCI7XG5pbXBvcnQgRXhwcmVzc2lvbkxleGVyIGZyb20gXCIuL2V4cHJlc3Npb24vbGV4ZXJcIjtcbmltcG9ydCBFeHByZXNzaW9uUGFyc2VyIGZyb20gXCIuL2V4cHJlc3Npb24vcGFyc2VyXCI7XG5cbmltcG9ydCB7IHBhdGhOb2RlRnJvbUV4cHJlc3Npb25Ob2RlLFxuICAgICAgICAgc3ByZWFkTm9kZUZyb21FeHByZXNzaW9uTm9kZSxcbiAgICAgICAgIGVycm9yTm9kZXNGcm9tRXhwcmVzc2lvbk5vZGUsXG4gICAgICAgICBzdWJFeHByZXNzaW9uTm9kZUZyb21FeHByZXNzaW9uTm9kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5cbmNvbnN0IGV4cHJlc3Npb25MZXhlciA9IEV4cHJlc3Npb25MZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgZXhwcmVzc2lvblBhcnNlciA9IEV4cHJlc3Npb25QYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIHNwcmVhZCwgc3ViRXhwcmVzc2lvbikge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJFeHByZXNzaW9uID0gc3ViRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGdldFNwcmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcHJlYWQ7XG4gIH1cblxuICBnZXRTdWJFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN1YkV4cHJlc3Npb247XG4gIH1cblxuICBnZXRSdWxlTmFtZXMoKSB7IHJldHVybiB0aGlzLnBhdGguZ2V0UnVsZU5hbWVzKCk7IH1cblxuICBnZXRUb2tlblR5cGVzKCkgeyByZXR1cm4gdGhpcy5wYXRoLmdldFRva2VuVHlwZXMoKTsgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkgeyByZXR1cm4gdGhpcy5wYXRoLmlzSW5maW5pdGVEZXNjZW50KCk7IH1cblxuICBzdGF0aWMgZnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSB7XG4gICAgY29uc3QgcGF0aE5vZGUgPSBwYXRoTm9kZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHN1YkV4cHJlc3Npb25Ob2RlID0gc3ViRXhwcmVzc2lvbk5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgIHBhdGggPSBQYXRoLmZyb21QYXRoTm9kZShwYXRoTm9kZSksXG4gICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpLFxuICAgICAgICAgIHN1YkV4cHJlc3Npb24gPSBTdWJFeHByZXNzaW9uLmZyb21TdWJFeHByZXNzaW9uTm9kZShzdWJFeHByZXNzaW9uTm9kZSksXG4gICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKHBhdGgsIHNwcmVhZCwgc3ViRXhwcmVzc2lvbik7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKSB7XG4gICAgbGV0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gICAgY29uc3QgbGV4ZXIgPSBleHByZXNzaW9uTGV4ZXIsICAvLy9cbiAgICAgICAgICBwYXJzZXIgPSBleHByZXNzaW9uUGFyc2VyLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IGV4cHJlc3Npb25TdHJpbmcsIC8vL1xuICAgICAgICAgIHRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICAgIG5vZGUgPSBwYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgZXJyb3JOb2RlcyA9IGVycm9yTm9kZXNGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgZXJyb3JOb2Rlc0xlbmd0aCA9IGVycm9yTm9kZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZXJyb3JOb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBwYXRoTm9kZSA9IHBhdGhOb2RlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICAgICAgc3ByZWFkTm9kZSA9IHNwcmVhZE5vZGVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpLFxuICAgICAgICAgICAgICBzdWJFeHByZXNzaW9uTm9kZSA9IHN1YkV4cHJlc3Npb25Ob2RlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICAgICAgcGF0aCA9IFBhdGguZnJvbVBhdGhOb2RlKHBhdGhOb2RlKSxcbiAgICAgICAgICAgICAgc3ByZWFkID0gU3ByZWFkLmZyb21TcHJlYWROb2RlKHNwcmVhZE5vZGUpLFxuICAgICAgICAgICAgICBzdWJFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbi5mcm9tU3ViRXhwcmVzc2lvbk5vZGUoc3ViRXhwcmVzc2lvbk5vZGUpO1xuXG4gICAgICAgIGV4cHJlc3Npb24gPSBuZXcgRXhwcmVzc2lvbihwYXRoLCBzcHJlYWQsIHN1YkV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuL2V4cHJlc3Npb25cIjtcblxuaW1wb3J0IHsgcHVzaCwgY2xlYXIsIGluY2x1ZGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmNvbnN0IHsgV0lMRENBUkRfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKHNwcmVhZCwgc3ViUXVlcnksIHJ1bGVOYW1lcywgdG9rZW5UeXBlcywgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKSB7XG4gICAgdGhpcy5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgdGhpcy5zdWJRdWVyeSA9IHN1YlF1ZXJ5O1xuICAgIHRoaXMucnVsZU5hbWVzID0gcnVsZU5hbWVzO1xuICAgIHRoaXMudG9rZW5UeXBlcyA9IHRva2VuVHlwZXM7XG4gICAgdGhpcy5tYXhpbXVtRGVwdGggPSBtYXhpbXVtRGVwdGg7XG4gICAgdGhpcy5pbmZpbml0ZURlc2NlbnQgPSBpbmZpbml0ZURlc2NlbnQ7XG4gICAgdGhpcy5pbnRlcm1lZGlhdGVOb2RlcyA9IGludGVybWVkaWF0ZU5vZGVzO1xuICB9XG5cbiAgZ2V0U3ByZWFkKCkge1xuICAgIHJldHVybiB0aGlzLnNwcmVhO1xuICB9XG5cbiAgZ2V0U3ViUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViUXVlcnk7XG4gIH1cblxuICBnZXRSdWxlTmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZU5hbWVzO1xuICB9XG5cbiAgZ2V0VG9rZW5UeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlblR5cGVzO1xuICB9XG5cbiAgZ2V0TWF4aW11bURlcHRoKCkge1xuICAgIHJldHVybiB0aGlzLm1heGltdW1EZXB0aDtcbiAgfVxuXG4gIGlzSW5maW5pdGVEZXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXRlRGVzY2VudDtcbiAgfVxuXG4gIGdldEludGVybWVkaWF0ZU5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybWVkaWF0ZU5vZGVzO1xuICB9XG5cbiAgZXhlY3V0ZShub2RlLCBkZXB0aCA9IDAsIG1heGltdW1EZXB0aCA9IHRoaXMubWF4aW11bURlcHRoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuZmluZChub2RlLCBkZXB0aCwgbWF4aW11bURlcHRoKTtcblxuICAgIHRoaXMuYXBwbHkobm9kZXMsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXIodGhpcy5pbnRlcm1lZGlhdGVOb2Rlcyk7XG4gIH1cblxuICBmaW5kKG5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBtYXhpbXVtRGVwdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIG5vZGVOb25UZXJtaW5hbE5vZGUgPSAhbm9kZVRlcm1pbmFsTm9kZTtcblxuICAgIGxldCBmb3VuZDtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICB0eXBlcyA9IHRoaXMudG9rZW5UeXBlcywgIC8vL1xuICAgICAgICAgICAgdHlwZSA9IHRlcm1pbmFsTm9kZS5nZXRUeXBlKCk7XG5cbiAgICAgIGZvdW5kID0gaW5jbHVkZXModHlwZXMsIHR5cGUsIFdJTERDQVJEX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTtcblxuICAgICAgZm91bmQgPSBpbmNsdWRlcyh0aGlzLnJ1bGVOYW1lcywgcnVsZU5hbWUsIFdJTERDQVJEX0NIQVJBQ1RFUik7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGVOb2RlID0gbm9kZTsgLy8vXG5cbiAgICAgIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMucHVzaChpbnRlcm1lZGlhdGVOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmZpbml0ZURlc2NlbnQpIHtcbiAgICAgIGlmIChub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgLy8vXG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlLmZvckVhY2hDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCkge1xuICAgIHRoaXMuc3ByZWFkLmFkanVzdE5vZGVzKHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgaWYgKHRoaXMuc3ViUXVlcnkgPT09IG51bGwpIHtcbiAgICAgIHB1c2gobm9kZXMsIHRoaXMuaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVybWVkaWF0ZU5vZGVzLmZvckVhY2goKGludGVybWVkaWF0ZU5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSA9IGludGVybWVkaWF0ZU5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgIGRlcHRoKys7XG5cbiAgICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBpbnRlcm1lZGlhdGVOb2RlOyAvLy9cblxuICAgICAgICAgIHRoaXMuc3ViUXVlcnkuY2xlYXIoKTtcblxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZS5mb3JFYWNoQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViUXVlcnkuZmluZChjaGlsZE5vZGUsIGRlcHRoLCBtYXhpbXVtRGVwdGgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5zdWJRdWVyeS5hcHBseShub2RlcywgZGVwdGgsIG1heGltdW1EZXB0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tRXhwcmVzc2lvbihleHByZXNzaW9uLCBtYXhpbXVtRGVwdGggPSBJbmZpbml0eSkge1xuICAgIGNvbnN0IHNwcmVhZCA9IGV4cHJlc3Npb24uZ2V0U3ByZWFkKCksXG4gICAgICAgICAgc3ViUXVlcnkgPSBzdWJRdWVyeUZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pLFxuICAgICAgICAgIHJ1bGVOYW1lcyA9IGV4cHJlc3Npb24uZ2V0UnVsZU5hbWVzKCksXG4gICAgICAgICAgdG9rZW5UeXBlcyA9IGV4cHJlc3Npb24uZ2V0VG9rZW5UeXBlcygpLFxuICAgICAgICAgIGluZmluaXRlRGVzY2VudCA9IGV4cHJlc3Npb24uaXNJbmZpbml0ZURlc2NlbnQoKSxcbiAgICAgICAgICBpbnRlcm1lZGlhdGVOb2RlcyA9IFtdLFxuICAgICAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHNwcmVhZCwgc3ViUXVlcnksIHJ1bGVOYW1lcywgdG9rZW5UeXBlcywgbWF4aW11bURlcHRoLCBpbmZpbml0ZURlc2NlbnQsIGludGVybWVkaWF0ZU5vZGVzKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3ViRXhwcmVzc2lvbihzdWJFeHByZXNzaW9uKSB7XG4gICAgY29uc3Qgc3ByZWFkID0gc3ViRXhwcmVzc2lvbi5nZXRTcHJlYWQoKSxcbiAgICAgICAgICBzdWJRdWVyeSA9IHN1YlF1ZXJ5RnJvbVN1YkV4cHJlc3Npb24oc3ViRXhwcmVzc2lvbiksXG4gICAgICAgICAgcnVsZU5hbWVzID0gc3ViRXhwcmVzc2lvbi5nZXRSdWxlTmFtZXMoKSxcbiAgICAgICAgICB0b2tlblR5cGVzID0gc3ViRXhwcmVzc2lvbi5nZXRUb2tlblR5cGVzKCksXG4gICAgICAgICAgbWF4aW11bURlcHRoID0gSW5maW5pdHksXG4gICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gc3ViRXhwcmVzc2lvbi5pc0luZmluaXRlRGVzY2VudCgpLFxuICAgICAgICAgIGludGVybWVkaWF0ZU5vZGVzID0gW10sXG4gICAgICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoc3ByZWFkLCBzdWJRdWVyeSwgcnVsZU5hbWVzLCB0b2tlblR5cGVzLCBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpO1xuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgc3RhdGljIGZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcsIG1heGltdW1EZXB0aCA9IEluZmluaXR5KSB7XG4gICAgbGV0IHF1ZXJ5ID0gbnVsbDtcblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBFeHByZXNzaW9uLmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gICAgaWYgKGV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHNwcmVhZCA9IGV4cHJlc3Npb24uZ2V0U3ByZWFkKCksXG4gICAgICAgICAgICBzdWJRdWVyeSA9IHN1YlF1ZXJ5RnJvbUV4cHJlc3Npb24oZXhwcmVzc2lvbiksXG4gICAgICAgICAgICBydWxlTmFtZXMgPSBleHByZXNzaW9uLmdldFJ1bGVOYW1lcygpLFxuICAgICAgICAgICAgdG9rZW5UeXBlcyA9IGV4cHJlc3Npb24uZ2V0VG9rZW5UeXBlcygpLFxuICAgICAgICAgICAgaW5maW5pdGVEZXNjZW50ID0gZXhwcmVzc2lvbi5pc0luZmluaXRlRGVzY2VudCgpLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlTm9kZXMgPSBbXTtcblxuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoc3ByZWFkLCBzdWJRdWVyeSwgcnVsZU5hbWVzLCB0b2tlblR5cGVzLCBtYXhpbXVtRGVwdGgsIGluZmluaXRlRGVzY2VudCwgaW50ZXJtZWRpYXRlTm9kZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJRdWVyeUZyb21FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgbGV0IHN1YlF1ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBzdWJFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5nZXRTdWJFeHByZXNzaW9uKCk7XG5cbiAgaWYgKHN1YkV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21TdWJFeHByZXNzaW9uKHN1YkV4cHJlc3Npb24pO1xuXG4gICAgc3ViUXVlcnkgPSBxdWVyeTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3ViUXVlcnk7XG59XG5cbmZ1bmN0aW9uIHN1YlF1ZXJ5RnJvbVN1YkV4cHJlc3Npb24oc3ViRXhwcmVzc2lvbikge1xuICBsZXQgc3ViUXVlcnkgPSBudWxsO1xuXG4gIHN1YkV4cHJlc3Npb24gPSBzdWJFeHByZXNzaW9uLmdldFN1YkV4cHJlc3Npb24oKTsgLy8vXG5cbiAgaWYgKHN1YkV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21TdWJFeHByZXNzaW9uKHN1YkV4cHJlc3Npb24pO1xuXG4gICAgc3ViUXVlcnkgPSBxdWVyeTsgLy8vXG4gIH1cblxuICByZXR1cm4gc3ViUXVlcnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBRdWVyeSBmcm9tIFwiLi4vcXVlcnlcIjtcbmltcG9ydCBFeHByZXNzaW9uIGZyb20gXCIuLi9leHByZXNzaW9uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeUJ5RXhwcmVzc2lvblN0cmluZyhub2RlLCBleHByZXNzaW9uU3RyaW5nLCBtYXhpbXVtRGVwdGgpIHtcbiAgbGV0IG5vZGVzID0gbnVsbDtcblxuICBjb25zdCBleHByZXNzaW9uID0gRXhwcmVzc2lvbi5mcm9tRXhwcmVzc2lvblN0cmluZyhleHByZXNzaW9uU3RyaW5nKTtcblxuICBpZiAoZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbWF4aW11bURlcHRoKTtcblxuICAgIG5vZGVzID0gcXVlcnkuZXhlY3V0ZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBxdWVyeUJ5RXhwcmVzc2lvblN0cmluZ1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBRdWVyeSB9IGZyb20gXCIuL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cHJlc3Npb24gfSBmcm9tIFwiLi9leHByZXNzaW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHF1ZXJ5VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4cHJlc3Npb25MZXhlciB9IGZyb20gXCIuL2V4cHJlc3Npb24vbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXhwcmVzc2lvblBhcnNlciB9IGZyb20gXCIuL2V4cHJlc3Npb24vcGFyc2VyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBIRUFEID0gXCJoZWFkXCI7XG5leHBvcnQgY29uc3QgU1RZTEUgPSBcInN0eWxlXCI7XG5leHBvcnQgY29uc3QgQ0hBUkFDVEVSUyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuZXhwb3J0IGNvbnN0IFRXT19TUEFDRVMgPSBcIiAgXCI7XG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FX0xFTkdUSCA9IDY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMocXVlcnksIG5vZGUsIHRva2Vucykge1xuICBsZXQgY29udGVudCA9IG51bGw7XG5cbiAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICBpZiAobm9kZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3Qobm9kZXMpO1xuXG4gICAgbm9kZSA9IGZpcnN0Tm9kZTsgLy8vXG5cbiAgICBjb250ZW50ID0gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gY29udGVudEZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICBjb25zdCBmaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0Rmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgodG9rZW5zKSxcbiAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gIGxldCBjb250ZW50ID0gRU1QVFlfU1RSSU5HO1xuXG4gIGZvciAobGV0IGluZGV4ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXg7IGluZGV4IDw9IGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXg7IGluZGV4KyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpbmRleF0sXG4gICAgICAgICAgdG9rZW5Db250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpO1xuXG4gICAgY29udGVudCArPSB0b2tlbkNvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gY29udGVudDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HLCBUV09fU1BBQ0VTIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcblxuY29uc3QgaW1wb3J0YW50UXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi8qL2ltcG9ydGFudFwiKSxcbiAgICAgIHByb3BlcnR5TmFtZVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9wcm9wZXJ0eU5hbWVcIiksXG4gICAgICBwcm9wZXJ0eVZhbHVlc1F1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9wcm9wZXJ0eVZhbHVlc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eVZhbHVlcywgcHJvcGVydHlOYW1lLCBpbXBvcnRhbnQpIHtcbiAgICB0aGlzLnByb3BlcnR5VmFsdWVzID0gcHJvcGVydHlWYWx1ZXM7XG4gICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgdGhpcy5pbXBvcnRhbnQgPSBpbXBvcnRhbnQ7XG4gIH1cblxuICBnZXRQcm9wZXJ0eVZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eVZhbHVlcztcbiAgfVxuXG4gIGdldFByb3BlcnR5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eU5hbWU7XG4gIH1cblxuICBnZXRJbXBvcnRhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wb3J0YW50O1xuICB9XG5cbiAgbWF0Y2hQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9ICh0aGlzLnByb3BlcnR5TmFtZSA9PT0gcHJvcGVydHlOYW1lKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgbWF0Y2hEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGRlY2xhcmF0aW9uLmdldFByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLm1hdGNoUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSk7IC8vL1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBtYXRjaERlY2xhcmF0aW9ucyhkZWNsYXJhdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gZGVjbGFyYXRpb25zLnNvbWVEZWNsYXJhdGlvbigoZGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm1hdGNoRGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50ICsgVFdPX1NQQUNFUztcblxuICAgIGNvbnN0IGNzcyA9IGAke2luZGVudH0ke3RoaXMucHJvcGVydHlOYW1lfTogJHt0aGlzLnByb3BlcnR5VmFsdWVzfSR7dGhpcy5pbXBvcnRhbnR9O1xcbmA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHByb3BlcnR5VmFsdWVzQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKHByb3BlcnR5VmFsdWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcHJvcGVydHlOYW1lQ29udGVudCA9IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zKHByb3BlcnR5TmFtZVF1ZXJ5LCBub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGltcG9ydGFudENvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhpbXBvcnRhbnRRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBwcm9wZXJ0eVZhbHVlcyA9IHByb3BlcnR5VmFsdWVzQ29udGVudCwgLy8vXG4gICAgICAgICAgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lQ29udGVudCwgLy8vXG4gICAgICAgICAgaW1wb3J0YW50ID0gKGltcG9ydGFudENvbnRlbnQgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEVNUFRZX1NUUklORyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgYCAke2ltcG9ydGFudENvbnRlbnR9YCxcbiAgICAgICAgICBkZWNsYXJhdGlvbiA9IG5ldyBEZWNsYXJhdGlvbihwcm9wZXJ0eVZhbHVlcywgcHJvcGVydHlOYW1lLCBpbXBvcnRhbnQpO1xuXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmb3J3YXJkc0ZvckVhY2gsIGJhY2t3YXJkc0ZvckVhY2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5jb25zdCBkZWNsYXJhdGlvblF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9kZWNsYXJhdGlvblwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVjbGFyYXRpb25zIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBzb21lRGVjbGFyYXRpb24oY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICBmb3J3YXJkc0ZvckVhY2hEZWNsYXJhdGlvbihjYWxsYmFjaykgeyBmb3J3YXJkc0ZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2spOyB9XG5cbiAgYmFja3dhcmRzRm9yRWFjaERlY2xhcmF0aW9uKGNhbGxiYWNrKSB7IGJhY2t3YXJkc0ZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2spOyB9XG5cbiAgdW5zaGlmdChkZWNsYXJhdGlvbnMpIHtcbiAgICBkZWNsYXJhdGlvbnMuYmFja3dhcmRzRm9yRWFjaERlY2xhcmF0aW9uKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGRlY2xhcmF0aW9uLm1hdGNoRGVjbGFyYXRpb25zKHRoaXMpOyAvLy9cblxuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChkZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uc0NTUyA9IHRoaXMuYXJyYXkucmVkdWNlKChkZWNsYXJhdGlvbnNDU1MsIGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbkNTUyA9IGRlY2xhcmF0aW9uLmFzQ1NTKGluZGVudCk7XG5cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyArPSBkZWNsYXJhdGlvbkNTUztcblxuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uc0NTUztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIGNzcyA9IChjbGFzc05hbWUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uc0NTUyA6ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ge1xuJHtkZWNsYXJhdGlvbnNDU1N9JHtpbmRlbnR9fVxuXG5gO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGVzID0gZGVjbGFyYXRpb25RdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGFycmF5ID0gZGVjbGFyYXRpb25Ob2Rlcy5tYXAoKGRlY2xhcmF0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGRlY2xhcmF0aW9uTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkZWNsYXJhdGlvbnMgPSBuZXcgRGVjbGFyYXRpb25zKGFycmF5KTtcblxuICAgIHJldHVybiBkZWNsYXJhdGlvbnM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9ucyBmcm9tIFwiLi9kZWNsYXJhdGlvbnNcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcblxuY29uc3Qgc2VsZWN0b3JzUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi8vc2VsZWN0b3JzXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2V0IHtcbiAgY29uc3RydWN0b3Ioc2VsZWN0b3JzLCBkZWNsYXJhdGlvbnMpIHtcbiAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RvcnM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zO1xuICB9XG5cbiAgdW5zaGlmdChydWxlU2V0KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gcnVsZVNldC5nZXREZWNsYXJhdGlvbnMoKTtcblxuICAgIHRoaXMuZGVjbGFyYXRpb25zLnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgfVxuXG4gIGZpbmRNYXRjaGluZ1J1bGVTZXQocnVsZVNldHMpIHtcbiAgICBjb25zdCBtYXRjaGluZ1J1bGVTZXQgPSBydWxlU2V0cy5maW5kKChydWxlU2V0KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSBydWxlU2V0LmdldFNlbGVjdG9ycygpLFxuICAgICAgICAgICAgc2VsZWN0b3JzTWF0Y2ggPSAoc2VsZWN0b3JzID09PSB0aGlzLnNlbGVjdG9ycyksXG4gICAgICAgICAgICBydWxlU2V0c01hdGNoID0gc2VsZWN0b3JzTWF0Y2g7IC8vL1xuXG4gICAgICBpZiAocnVsZVNldHNNYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBtYXRjaGluZ1J1bGVTZXQ7XG4gIH1cblxuICBhc0NTUyhjbGFzc05hbWUsIGluZGVudCkge1xuICAgIGxldCBjc3MgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhudWxsLCBpbmRlbnQpO1xuXG4gICAgaWYgKGRlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICAgY3NzID0gYCR7aW5kZW50fS4ke2NsYXNzTmFtZX0ke3RoaXMuc2VsZWN0b3JzfSB7XG4ke2RlY2xhcmF0aW9uc0NTU30ke2luZGVudH19XG5cbmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWxlY3RvcnNGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHJ1bGVTZXQgPSBuZXcgUnVsZVNldChzZWxlY3RvcnMsIGRlY2xhcmF0aW9ucyk7XG5cbiAgICByZXR1cm4gcnVsZVNldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RvcnNGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3Qgc2VsZWN0b3JzTm9kZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhzZWxlY3RvcnNRdWVyeSwgbm9kZSwgdG9rZW5zKSxcbiAgICAgICAgc2VsZWN0b3JzID0gYCR7c2VsZWN0b3JzTm9kZUNvbnRlbnR9YDtcblxuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1xdWVyeVwiO1xuXG5pbXBvcnQgUnVsZVNldCBmcm9tIFwiLi9ydWxlU2V0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgcnVsZVNldFF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9ydWxlU2V0XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2V0cyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChydWxlU2V0cykge1xuICAgIHJ1bGVTZXRzLmZvckVhY2goKHJ1bGVTZXQpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nUnVsZVNldCA9IHJ1bGVTZXQuZmluZE1hdGNoaW5nUnVsZVNldCh0aGlzLmFycmF5KTsgLy8vXG5cbiAgICAgIChtYXRjaGluZ1J1bGVTZXQgPT09IG51bGwpID9cbiAgICAgICAgdGhpcy5hcnJheS51bnNoaWZ0KHJ1bGVTZXQpIDpcbiAgICAgICAgICBtYXRjaGluZ1J1bGVTZXQudW5zaGlmdChydWxlU2V0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spO1xuICB9XG5cbiAgYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpIHtcbiAgICBjb25zdCBjc3MgPSB0aGlzLmFycmF5LnJlZHVjZSgoY3NzLCBydWxlU2V0KSA9PiB7XG4gICAgICBjb25zdCBydWxlU2V0Q1NTID0gcnVsZVNldC5hc0NTUyhjbGFzc05hbWUsIGluZGVudCk7XG5cbiAgICAgIGNzcyArPSBydWxlU2V0Q1NTO1xuXG4gICAgICByZXR1cm4gY3NzO1xuICAgIH0sIEVNUFRZX1NUUklORyk7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IHJ1bGVTZXROb2RlcyA9IHJ1bGVTZXRRdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGFycmF5ID0gcnVsZVNldE5vZGVzLm1hcCgocnVsZVNldE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBydWxlU2V0Tm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICBydWxlU2V0ID0gUnVsZVNldC5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcnVsZVNldDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBydWxlU2V0cyA9IG5ldyBSdWxlU2V0cyhhcnJheSk7XG5cbiAgICByZXR1cm4gcnVsZVNldHM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcbiAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1tcXG5cXHJdJC9nLCBFTVBUWV9TVFJJTkcpOyAgLy8vXG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3J1bGVTZXRzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyB0cmltIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcbmltcG9ydCB7IFRXT19TUEFDRVMsIEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IHF1ZXJpZXNRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiL21lZGlhL21lZGlhUXVlcmllc1wiKTsgLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhIHtcbiAgY29uc3RydWN0b3IoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgcXVlcmllcykge1xuICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgICB0aGlzLnF1ZXJpZXMgPSBxdWVyaWVzO1xuICB9XG5cbiAgZ2V0RGVjbGFyYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9ucztcbiAgfVxuXG4gIGdldFJ1bGVTZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVTZXRzO1xuICB9XG5cbiAgZ2V0UXVlcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyaWVzO1xuICB9XG5cbiAgYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpIHtcbiAgICBpbmRlbnQgPSBpbmRlbnQgKyBUV09fU1BBQ0VTO1xuXG4gICAgbGV0IGNzcyA9IEVNUFRZX1NUUklORztcblxuICAgIGNvbnN0IHJ1bGVTZXRzQ1NTID0gdGhpcy5ydWxlU2V0cy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgZGVjbGFyYXRpb25zQ1NTID0gdGhpcy5kZWNsYXJhdGlvbnMuYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpO1xuXG4gICAgbGV0IHJ1bGVTZXRzRGVjbGFyYXRpb25zQ1NTID0gYCR7ZGVjbGFyYXRpb25zQ1NTfSR7cnVsZVNldHNDU1N9YDtcblxuICAgIGlmIChydWxlU2V0c0RlY2xhcmF0aW9uc0NTUyAhPT0gRU1QVFlfU1RSSU5HKSB7XG4gICAgICBydWxlU2V0c0RlY2xhcmF0aW9uc0NTUyA9IHRyaW0ocnVsZVNldHNEZWNsYXJhdGlvbnNDU1MpO1xuXG4gICAgICBjc3MgPSBgQG1lZGlhICR7dGhpcy5xdWVyaWVzfSB7XG4ke3J1bGVTZXRzRGVjbGFyYXRpb25zQ1NTfX1cblxuYDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHJ1bGVTZXRzID0gUnVsZVNldHMuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSxcbiAgICAgICAgICBxdWVyaWVzID0gcXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgbWVkaWEgPSBuZXcgTWVkaWEoZGVjbGFyYXRpb25zLCBydWxlU2V0cywgcXVlcmllcyk7XG5cbiAgICByZXR1cm4gbWVkaWE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcmllc0Zyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICBjb25zdCBxdWVyaWVzTm9kZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhxdWVyaWVzUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgIHF1ZXJpZXMgPSBgJHtxdWVyaWVzTm9kZUNvbnRlbnR9YDtcblxuICByZXR1cm4gcXVlcmllcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuaW1wb3J0IE1lZGlhIGZyb20gXCIuL21lZGlhXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgbWVkaWFRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiL3N0eWxlc2hlZXQvbWVkaWFcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChtZWRpYXMpIHtcbiAgICBtZWRpYXMuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgIHRoaXMuYXJyYXkudW5zaGlmdChtZWRpYSk7XG4gICAgfSk7XG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgY29uc3QgY3NzID0gdGhpcy5hcnJheS5yZWR1Y2UoKGNzcywgbWVkaWEpID0+IHtcbiAgICAgIGNvbnN0IG1lZGlhQ1NTID0gbWVkaWEuYXNDU1MoY2xhc3NOYW1lLCBpbmRlbnQpO1xuXG4gICAgICBjc3MgKz0gbWVkaWFDU1M7XG5cbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgbWVkaWFOb2RlcyA9IG1lZGlhUXVlcnkuZXhlY3V0ZShub2RlKSxcbiAgICAgICAgICBhcnJheSA9IG1lZGlhTm9kZXMubWFwKChtZWRpYU5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBtZWRpYU5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgbWVkaWEgPSBNZWRpYS5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWVkaWE7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWVkaWFzID0gbmV3IE1lZGlhcyhhcnJheSk7XG5cbiAgICByZXR1cm4gbWVkaWFzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuL2RlY2xhcmF0aW9uXCI7XG5cbmltcG9ydCB7IGNvbnRlbnRGcm9tUXVlcnlOb2RlQW5kVG9rZW5zIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5cbmNvbnN0IHBlcmNlbnRhZ2VRdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKFwiLyovQHBlcmNlbnRhZ2VcIiksXG4gICAgICBkZWNsYXJhdGlvblF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIvKi9kZWNsYXJhdGlvblwiKTtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleWZyYW1lIHtcbiAgY29uc3RydWN0b3IocGVyY2VudGFnZSwgZGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLnBlcmNlbnRhZ2UgPSBwZXJjZW50YWdlO1xuICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcbiAgfVxuXG4gIGdldFBlcmNlbnRhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyY2VudGFnZTtcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25DU1MgPSB0aGlzLmRlY2xhcmF0aW9uLmFzQ1NTKGluZGVudCksXG4gICAgICAgICAgY3NzID0gYCR7aW5kZW50fSR7dGhpcy5wZXJjZW50YWdlfSB7IFxuJHtkZWNsYXJhdGlvbkNTU30ke2luZGVudH19XFxuYDtcblxuICAgIHJldHVybiBjc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gICAgY29uc3QgcGVyY2VudGFnZUNvbnRlbnQgPSBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyhwZXJjZW50YWdlUXVlcnksIG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcGVyY2VudGFnZSA9IHBlcmNlbnRhZ2VDb250ZW50LCAvLy9cbiAgICAgICAgICBkZWNsYXJhdGlvbk5vZGVzID0gZGVjbGFyYXRpb25RdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIGZpcnN0RGVjbGFyYXRpb25Ob2RlID0gZmlyc3QoZGVjbGFyYXRpb25Ob2RlcyksXG4gICAgICAgICAgZGVjbGFyYXRpb25Ob2RlID0gZmlyc3REZWNsYXJhdGlvbk5vZGU7IC8vL1xuXG4gICAgbm9kZSA9IGRlY2xhcmF0aW9uTm9kZTsgLy8vXG5cbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAga2V5ZnJhbWUgPSBuZXcgS2V5ZnJhbWUocGVyY2VudGFnZSwgZGVjbGFyYXRpb24pO1xuXG4gICAgcmV0dXJuIGtleWZyYW1lO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmltcG9ydCBLZXlmcmFtZSBmcm9tIFwiLi9rZXlmcmFtZVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcsIFRXT19TUEFDRVMgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjb250ZW50RnJvbVF1ZXJ5Tm9kZUFuZFRva2VucyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY29udGVudFwiO1xuXG5jb25zdCBrZXlmcmFtZVF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIva2V5ZnJhbWVzL2tleWZyYW1lXCIpLFxuICAgICAgaWRlbnRpZmllclF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoXCIva2V5ZnJhbWVzL0BpZGVudGlmaWVyXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlmcmFtZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSwgaWRlbnRpZmllcikge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICB9XG5cbiAgZ2V0SWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyO1xuICB9XG5cbiAgYXNDU1MoaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50ICsgVFdPX1NQQUNFUztcblxuICAgIGNvbnN0IGtleWZyYW1lc0NTUyA9IHRoaXMuYXJyYXkucmVkdWNlKChrZXlmcmFtZXNDU1MsIGtleWZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZUNTUyA9IGtleWZyYW1lLmFzQ1NTKGluZGVudCk7XG5cbiAgICAgICAgICAgIGtleWZyYW1lc0NTUyArPSBrZXlmcmFtZUNTUztcblxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lc0NTUztcbiAgICAgICAgICB9LCBFTVBUWV9TVFJJTkcpLFxuICAgICAgICAgIGNzcyA9IGBAa2V5ZnJhbWVzICR7dGhpcy5pZGVudGlmaWVyfSB7XG4ke2tleWZyYW1lc0NTU319XG5cbmA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGtleWZyYW1lTm9kZXMgPSBrZXlmcmFtZVF1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBrZXlmcmFtZU5vZGVzLm1hcCgoa2V5ZnJhbWVOb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0ga2V5ZnJhbWVOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lID0gS2V5ZnJhbWUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGlkZW50aWZpZXJDb250ZW50ID0gY29udGVudEZyb21RdWVyeU5vZGVBbmRUb2tlbnMoaWRlbnRpZmllclF1ZXJ5LCBub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyQ29udGVudCwgLy8vXG4gICAgICAgICAga2V5ZnJhbWVzID0gbmV3IEtleWZyYW1lcyhhcnJheSwgaWRlbnRpZmllcik7XG5cbiAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmltcG9ydCBLZXlmcmFtZXMgZnJvbSBcIi4va2V5ZnJhbWVzXCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3Qga2V5ZnJhbWVzUXVlcnkgPSBRdWVyeS5mcm9tRXhwcmVzc2lvblN0cmluZyhcIi9zdHlsZXNoZWV0L2tleWZyYW1lc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5ZnJhbWVzcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgdW5zaGlmdChrZXlmcmFtZXNzKSB7XG4gICAgLy8vXG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSB7XG4gICAgY29uc3QgY3NzID0gdGhpcy5hcnJheS5yZWR1Y2UoKGNzcywga2V5ZnJhbWVzKSA9PiB7XG4gICAgICBjb25zdCBrZXlmcmFtZXNDU1MgPSBrZXlmcmFtZXMuYXNDU1MoaW5kZW50KTtcblxuICAgICAgY3NzICs9IGtleWZyYW1lc0NTUztcblxuICAgICAgcmV0dXJuIGNzcztcbiAgICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gICAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgICBjb25zdCBrZXlmcmFtZXNOb2RlcyA9IGtleWZyYW1lc1F1ZXJ5LmV4ZWN1dGUobm9kZSksXG4gICAgICAgICAgYXJyYXkgPSBrZXlmcmFtZXNOb2Rlcy5tYXAoKGtleWZyYW1lc05vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBrZXlmcmFtZXNOb2RlLCAvLy9cbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcyA9IEtleWZyYW1lcy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBuZXcgS2V5ZnJhbWVzcyhhcnJheSk7XG5cbiAgICByZXR1cm4ga2V5ZnJhbWVzcztcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWVkaWFzIGZyb20gXCIuL3N0eWxlL21lZGlhc1wiO1xuaW1wb3J0IFJ1bGVTZXRzIGZyb20gXCIuL3N0eWxlL3J1bGVTZXRzXCI7XG5pbXBvcnQgS2V5ZnJhbWVzcyBmcm9tIFwiLi9zdHlsZS9rZXlmcmFtZXNzXCI7XG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gXCIuL3N0eWxlL2RlY2xhcmF0aW9uc1wiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3R5bGUge1xuICBjb25zdHJ1Y3RvcihkZWNsYXJhdGlvbnMsIGtleWZyYW1lc3MsIHJ1bGVTZXRzLCBtZWRpYXMpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgICB0aGlzLmtleWZyYW1lc3MgPSBrZXlmcmFtZXNzO1xuICAgIHRoaXMucnVsZVNldHMgPSBydWxlU2V0cztcbiAgICB0aGlzLm1lZGlhcyA9IG1lZGlhcztcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnM7XG4gIH1cblxuICBnZXRLZXlmcmFtZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmtleWZyYW1lc3M7XG4gIH1cblxuICBnZXRSdWxlU2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlU2V0cztcbiAgfVxuXG4gIGdldE1lZGlhcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZWRpYXM7XG4gIH1cblxuICBleHRlbmRzKHN1cGVyU3R5bGUpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBzdXBlclN0eWxlLmdldERlY2xhcmF0aW9ucygpLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBzdXBlclN0eWxlLmdldEtleWZyYW1lc3MoKSxcbiAgICAgICAgICBydWxlU2V0cyA9IHN1cGVyU3R5bGUuZ2V0UnVsZVNldHMoKSxcbiAgICAgICAgICBtZWRpYXMgPSBzdXBlclN0eWxlLmdldE1lZGlhcygpO1xuXG4gICAgdGhpcy51bnNoaWZ0KGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcyk7XG4gIH1cblxuICB1bnNoaWZ0KGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcykge1xuICAgIHRoaXMuZGVjbGFyYXRpb25zLnVuc2hpZnQoZGVjbGFyYXRpb25zKTtcbiAgICB0aGlzLmtleWZyYW1lc3MudW5zaGlmdChrZXlmcmFtZXNzKTtcbiAgICB0aGlzLnJ1bGVTZXRzLnVuc2hpZnQocnVsZVNldHMpO1xuICAgIHRoaXMubWVkaWFzLnVuc2hpZnQobWVkaWFzKTtcbiAgfVxuXG4gIGFzQ1NTKGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IGluZGVudCA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBkZWNsYXJhdGlvbnNDU1MgPSB0aGlzLmRlY2xhcmF0aW9ucy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAga2V5ZnJhbWVzc0NTUyA9IHRoaXMua2V5ZnJhbWVzcy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgcnVsZVNldHNDU1MgPSB0aGlzLnJ1bGVTZXRzLmFzQ1NTKGNsYXNzTmFtZSwgaW5kZW50KSxcbiAgICAgICAgICBtZWRpYXNDU1MgPSB0aGlzLm1lZGlhcy5hc0NTUyhjbGFzc05hbWUsIGluZGVudCksXG4gICAgICAgICAgY3NzID0gYCR7ZGVjbGFyYXRpb25zQ1NTfSR7a2V5ZnJhbWVzc0NTU30ke3J1bGVTZXRzQ1NTfSR7bWVkaWFzQ1NTfWA7XG5cbiAgICByZXR1cm4gY3NzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2Vucykge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IERlY2xhcmF0aW9ucy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIGtleWZyYW1lc3MgPSBLZXlmcmFtZXNzLmZyb21Ob2RlQW5kVG9rZW5zKG5vZGUsIHRva2VucyksXG4gICAgICAgICAgcnVsZVNldHMgPSBSdWxlU2V0cy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIG1lZGlhcyA9IE1lZGlhcy5mcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0b2tlbnMpLFxuICAgICAgICAgIHN0eWxlID0gbmV3IFN0eWxlKGRlY2xhcmF0aW9ucywga2V5ZnJhbWVzcywgcnVsZVNldHMsIG1lZGlhcyk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFN0eWxlIGZyb20gXCIuLi9zdHlsZVwiO1xuaW1wb3J0IENTU0xleGVyIGZyb20gXCIuLi9jc3MvbGV4ZXJcIjtcbmltcG9ydCBDU1NQYXJzZXIgZnJvbSBcIi4uL2Nzcy9wYXJzZXJcIjtcblxuaW1wb3J0IHsgSEVBRCwgU1RZTEUsIEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgY3NzTGV4ZXIgPSBDU1NMZXhlci5mcm9tTm90aGluZygpLFxuICAgICAgY3NzUGFyc2VyID0gQ1NTUGFyc2VyLmZyb21Ob3RoaW5nKCk7XG5cbmlmICghZ2xvYmFsVGhpcy5zdHlsZU1hcCkge1xuICBnbG9iYWxUaGlzLnN0eWxlTWFwID0ge307XG59XG5cbmNvbnN0IHsgc3R5bGVNYXAgfSA9IGdsb2JhbFRoaXM7XG5cbmZ1bmN0aW9uIHJlbmRlclN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IGhlYWRET01FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihIRUFEKSxcbiAgICAgICAgc3R5bGVET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChTVFlMRSksXG4gICAgICAgIGlubmVySFRNTCA9IGAgICAgICAgIFxuJHtzdHlsZX1cbmA7XG5cbiAgT2JqZWN0LmFzc2lnbihzdHlsZURPTUVsZW1lbnQsIHtcbiAgICBpbm5lckhUTUxcbiAgfSk7XG5cbiAgaGVhZERPTUVsZW1lbnQuYXBwZW5kQ2hpbGQoc3R5bGVET01FbGVtZW50KTtcblxuICByZXR1cm4gc3R5bGVET01FbGVtZW50O1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdHlsZXMoKSB7XG4gIGNvbnN0IHN0eWxlc0NTUyA9IHJldHJpZXZlU3R5bGVzQ1NTKCksXG4gICAgICAgIHN0eWxlID0gc3R5bGVzQ1NTOyAgLy8vXG5cbiAgcmVuZGVyU3R5bGUoc3R5bGUpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSwgc3VwZXJTdHlsZSA9IG51bGwpIHtcbiAgY29uc3Qgc3RyaW5ncyA9IGFyZ3Muc2hpZnQoKSxcdC8vL1xuICAgICAgICBjb250ZW50ID0gc3RyaW5ncy5yZWR1Y2UoKGNvbnRlbnQsIHN0cmluZywgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XSB8fCBudWxsO1xuXG4gICAgICAgICAgY29udGVudCA9IChhcmcgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICBgJHtjb250ZW50fSR7c3RyaW5nfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7Y29udGVudH0ke3N0cmluZ30ke2FyZ31gO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0sIEVNUFRZX1NUUklORyksXG4gICAgICAgIHRva2VucyA9IGNzc0xleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3NzUGFyc2VyLnBhcnNlKHRva2VucyksXG4gICAgICAgIHN0eWxlID0gU3R5bGUuZnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKTtcblxuICBpZiAoc3VwZXJTdHlsZSAhPT0gbnVsbCkge1xuICAgIHN0eWxlLmV4dGVuZHMoc3VwZXJTdHlsZSk7XG4gIH1cblxuICBzdHlsZU1hcFtjbGFzc05hbWVdID0gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlU3R5bGUoY2xhc3NOYW1lKSB7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVNYXBbY2xhc3NOYW1lXSB8fCBudWxsO1xuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzLFxuICBnZW5lcmF0ZVN0eWxlLFxuICByZXRyaWV2ZVN0eWxlXG59O1xuXG5mdW5jdGlvbiByZXRyaWV2ZVN0eWxlc0NTUygpIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlTWFwKSxcbiAgICAgICAgc3R5bGVzQ1NTID0gY2xhc3NOYW1lcy5yZWR1Y2UoKHN0eWxlc0NTUywgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSksXG4gICAgICAgICAgICAgICAgc3R5bGVDU1MgPSBzdHlsZS5hc0NTUyhjbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3R5bGVzQ1NTICs9IHN0eWxlQ1NTO1xuXG4gICAgICAgICAgcmV0dXJuIHN0eWxlc0NTUztcbiAgICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gc3R5bGVzQ1NTO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDSEFSQUNURVJTLCBFTVBUWV9TVFJJTkcsIENMQVNTX05BTUVfTEVOR1RIIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5jb25zdCBsZW5ndGggPSBDTEFTU19OQU1FX0xFTkdUSCxcbiAgICAgIGNoYXJhY3RlcnMgPSBDSEFSQUNURVJTLFxuICAgICAgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuXG5jb25zdCBjbGFzc05hbWVzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNsYXNzTmFtZSgpIHtcbiAgbGV0IGNsYXNzTmFtZSA9IEVNUFRZX1NUUklORztcblxuICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgbGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXJzW2luZGV4XTtcblxuICAgIGNsYXNzTmFtZSArPSBjaGFyYWN0ZXI7XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUgPSBjbGFzc05hbWVzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG5cbiAgaWYgKCFjbGFzc05hbWVzSW5jbHVkZXNDbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlQ2xhc3NOYW1lKGVsZW1lbnQpIHtcbiAgY29uc3QgeyBjbGFzc05hbWUgfSA9IGVsZW1lbnQucmVhY3RGdW5jdGlvbiB8fCBlbGVtZW50LnJlYWN0Q29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2VuZXJhdGVDbGFzc05hbWUsXG4gIHJldHJpZXZlQ2xhc3NOYW1lXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHRhZ05hbWVzIH0gZnJvbSBcIi4vdGFnTmFtZXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTTGV4ZXIgfSBmcm9tIFwiLi9jc3MvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ1NTUGFyc2VyIH0gZnJvbSBcIi4vY3NzL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHlsZXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3R5bGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNsYXNzTmFtZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc05hbWVcIjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGFzcyhhcmd1bWVudCkgeyByZXR1cm4gaXNTdWJjbGFzc09mKGFyZ3VtZW50LCBFbGVtZW50KTsgfSAgLy8vXG5cbmZ1bmN0aW9uIGlzU3ViY2xhc3NPZihhcmd1bWVudCwgQ2xhc3MpIHtcbiAgY29uc3Qgc3ViY2xhc3NPZiA9IChhcmd1bWVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBDbGFzcyk7XG5cbiAgcmV0dXJuIHN1YmNsYXNzT2Y7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDTEFTU19OQU1FID0gXCJjbGFzc05hbWVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUmVhY3QgfSBmcm9tIFwiZWFzeVwiO1xuaW1wb3J0IHsgdGFnTmFtZXMsIHN0eWxlc1V0aWxpdGllcywgY2xhc3NOYW1lVXRpbGl0aWVzIH0gZnJvbSBcIndpdGgtc3R5bGVcIjtcblxuaW1wb3J0IHsgaXNDbGFzcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jbGFzc1wiO1xuaW1wb3J0IHsgQ0xBU1NfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCB7IGdlbmVyYXRlQ2xhc3NOYW1lIH0gPSBjbGFzc05hbWVVdGlsaXRpZXMsXG4gICAgICB7IHJlbmRlclN0eWxlLCByZW5kZXJTdHlsZXMsIGdlbmVyYXRlU3R5bGUsIHJldHJpZXZlU3R5bGUgfSA9IHN0eWxlc1V0aWxpdGllcztcblxuZnVuY3Rpb24gd2l0aFN0eWxlKENsYXNzT3JGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYXJncyA9IFsgLi4uYXJndW1lbnRzIF07ICAvLy9cblxuICAgIGxldCB7IGNsYXNzTmFtZSA9IG51bGwgfSA9IENsYXNzT3JGdW5jdGlvbjtcblxuICAgIGNvbnN0IHN1cGVyU3R5bGUgPSByZXRyaWV2ZVN0eWxlKGNsYXNzTmFtZSk7XG5cbiAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuXG4gICAgZ2VuZXJhdGVTdHlsZShhcmdzLCBjbGFzc05hbWUsIHN1cGVyU3R5bGUpO1xuXG4gICAgY29uc3QgQ2xhc3NPckZ1bmN0aW9uQ2xhc3MgPSBpc0NsYXNzKENsYXNzT3JGdW5jdGlvbik7XG5cbiAgICBpZiAoQ2xhc3NPckZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgIGNvbnN0IENsYXNzID0gQ2xhc3NPckZ1bmN0aW9uOyAgLy8vXG5cbiAgICAgIENsYXNzT3JGdW5jdGlvbiA9IGNsYXNzIGV4dGVuZHMgQ2xhc3Mge1xuICAgICAgICBzdGF0aWMgZnJvbUNsYXNzKF9DbGFzcywgcHJvcGVydGllcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgICAgcmV0dXJuIENsYXNzLmZyb21DbGFzcyhfQ2xhc3MsIHByb3BlcnRpZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgRnVuY3Rpb24gPSBDbGFzc09yRnVuY3Rpb247IC8vL1xuXG4gICAgICBDbGFzc09yRnVuY3Rpb24gPSAocHJvcGVydGllcykgPT4ge1xuICAgICAgICBwcm9wZXJ0aWVzID0gYXBwZW5kQ2xhc3NOYW1lVG9Qcm9wZXJ0aWVzKGNsYXNzTmFtZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKHByb3BlcnRpZXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKENsYXNzT3JGdW5jdGlvbiwge1xuICAgICAgY2xhc3NOYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ2xhc3NPckZ1bmN0aW9uO1xuICB9O1xufVxuXG5PYmplY3QuYXNzaWduKHdpdGhTdHlsZSwge1xuICByZW5kZXJTdHlsZSxcbiAgcmVuZGVyU3R5bGVzXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlO1xuXG50YWdOYW1lcy5mb3JFYWNoKCh0YWdOYW1lKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aXRoU3R5bGUsIHRhZ05hbWUsIHtcbiAgICBnZXQ6ICgpID0+IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYXJncyA9IFsuLi5hcmd1bWVudHNdLCAgLy8vXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZSgpO1xuXG4gICAgICBnZW5lcmF0ZVN0eWxlKGFyZ3MsIGNsYXNzTmFtZSk7XG5cbiAgICAgIGNvbnN0IEZ1bmN0aW9uID0gKHByb3BlcnRpZXMpID0+IHtcbiAgICAgICAgcHJvcGVydGllcyA9IGFwcGVuZENsYXNzTmFtZVRvUHJvcGVydGllcyhjbGFzc05hbWUsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIHByb3BlcnRpZXMpO1xuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmFzc2lnbihGdW5jdGlvbiwge1xuICAgICAgICBjbGFzc05hbWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gRnVuY3Rpb247XG4gICAgfVxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBhcHBlbmRDbGFzc05hbWVUb1Byb3BlcnRpZXMoY2xhc3NOYW1lLCBwcm9wZXJ0aWVzKSB7XG4gIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KENMQVNTX05BTUUpID8gcHJvcGVydGllcyA6IHsgLi4ucHJvcGVydGllcywgY2xhc3NOYW1lIH07IC8vL1xuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCIuL3dpdGhTdHlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDVVJTT1IgPSBcImN1cnNvclwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgQVVUT19DVVJTT1IgPSBcImF1dG9cIjtcbmV4cG9ydCBjb25zdCBQT0lOVEVSX0NVUlNPUiA9IFwicG9pbnRlclwiO1xuZXhwb3J0IGNvbnN0IENPTF9SRVNJWkVfQ1VSU09SID0gXCJjb2wtcmVzaXplXCI7XG5leHBvcnQgY29uc3QgUk9XX1JFU0laRV9DVVJTT1IgPSBcInJvdy1yZXNpemVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQm9keSB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCB7IENVUlNPUiB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQVVUT19DVVJTT1IsIFBPSU5URVJfQ1VSU09SLCBDT0xfUkVTSVpFX0NVUlNPUiwgUk9XX1JFU0laRV9DVVJTT1IgfSBmcm9tIFwiLi9jdXJzb3JzXCI7XG5cbmNvbnN0IGJvZHkgPSBuZXcgQm9keSgpO1xuXG5sZXQgcHJldmlvdXNDdXJzb3I7ICAvLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9DdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IEFVVE9fQ1VSU09SO1xuXG4gIHVwZGF0ZUN1cnNvcihjdXJzb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDdXJzb3IoKSB7XG4gIHNldEN1cnNvcihwcmV2aW91c0N1cnNvcik7IC8vL1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRlckN1cnNvcigpIHtcbiAgY29uc3QgY3Vyc29yID0gUE9JTlRFUl9DVVJTT1I7XG5cbiAgdXBkYXRlQ3Vyc29yKGN1cnNvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3dSZXNpemVDdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IFJPV19SRVNJWkVfQ1VSU09SO1xuXG4gIHVwZGF0ZUN1cnNvcihjdXJzb3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sdW1uUmVzaXplQ3Vyc29yKCkge1xuICBjb25zdCBjdXJzb3IgPSBDT0xfUkVTSVpFX0NVUlNPUjtcblxuICB1cGRhdGVDdXJzb3IoY3Vyc29yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhdXRvQ3Vyc29yLFxuICByZXNldEN1cnNvcixcbiAgcG9pbnRlckN1cnNvcixcbiAgcm93UmVzaXplQ3Vyc29yLFxuICBjb2x1bW5SZXNpemVDdXJzb3Jcbn1cblxuZnVuY3Rpb24gc2V0Q3Vyc29yKGN1cnNvcikge1xuICBjb25zdCBjc3MgPSB7XG4gICAgY3Vyc29yXG4gIH07XG5cbiAgYm9keS5jc3MoY3NzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKGN1cnNvcikge1xuICBjb25zdCBjdXJyZW50Q3Vyc29yID0gZ2V0Q3VycmVudEN1cnNvcigpO1xuXG4gIGlmIChjdXJyZW50Q3Vyc29yICE9PSBjdXJzb3IpIHtcbiAgICBwcmV2aW91c0N1cnNvciA9IGN1cnJlbnRDdXJzb3I7IC8vL1xuXG4gICAgc2V0Q3Vyc29yKGN1cnNvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEN1cnNvcigpIHtcbiAgY29uc3QgY3VycmVudEN1cnNvciA9IGJvZHkuY3NzKENVUlNPUikgfHwgQVVUT19DVVJTT1I7XG5cbiAgcmV0dXJuIGN1cnJlbnRDdXJzb3I7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBSb3dEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwicm93XCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFJvd0RpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgUm93c0RpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJyb3dzXCJcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFJvd3NEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZ3JvdzogMTtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmNsYXNzIENvbHVtbkRpdiBleHRlbmRzIEVsZW1lbnQge1xuICBzdGF0aWMgdGFnTmFtZSA9IFwiZGl2XCI7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb2x1bW5cIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoQ29sdW1uRGl2KWBcblxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWdyb3c6IDE7XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBDb2x1bW5zRGl2IGV4dGVuZHMgRWxlbWVudCB7XG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImNvbHVtbnNcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoQ29sdW1uc0RpdilgXG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1ncm93OiAxO1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfRFJBR0dJTkdfREVMQVkgPSAxNzU7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50KGRyYWdFbGVtZW50LCBkcm9wRWxlbWVudCkge1xuICBjb25zdCByZWZlcmVuY2UgPSBkcm9wRWxlbWVudC5nZXRSZWZlcmVuY2UoKSxcbiAgICAgICAgcmVmZXJlbmNlcyA9IGRyYWdFbGVtZW50LmdldFJlZmVyZW5jZXMoKSxcbiAgICAgICAgcmVmZXJlbmNlc0luY2x1ZGVzUmVmZXJlbmNlID0gcmVmZXJlbmNlcy5pbmNsdWRlcyhyZWZlcmVuY2UpLFxuICAgICAgICBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9ICFyZWZlcmVuY2VzSW5jbHVkZXNSZWZlcmVuY2U7XG5cbiAgcmV0dXJuIGRyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50O1xufSIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdXNlVG9wRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IHsgcGFnZVkgfSA9IGV2ZW50LFxuICAgICAgICBtb3VzZVRvcCA9IHBhZ2VZOyAvLy9cblxuICByZXR1cm4gbW91c2VUb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VzZUxlZnRGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgeyBwYWdlWCB9ID0gZXZlbnQsXG4gICAgICAgIG1vdXNlTGVmdCA9IHBhZ2VYOyAgLy8vXG5cbiAgcmV0dXJuIG1vdXNlTGVmdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcImRyYWdcIjtcbmV4cG9ydCBjb25zdCBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFID0gXCJkcm9wXCI7XG5leHBvcnQgY29uc3QgRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcImRyYWctb3V0XCI7XG5leHBvcnQgY29uc3QgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFID0gXCJkcmFnLW92ZXJcIjtcbmV4cG9ydCBjb25zdCBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcInN0b3AtZHJhZ1wiO1xuZXhwb3J0IGNvbnN0IFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgPSBcInN0YXJ0LWRyYWdcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBEUkFHX09VVF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFLFxuICBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gIFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGtleUNvZGVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiIDtcbmltcG9ydCB7IHdpbmRvdywgbW91c2VCdXR0b25zIH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IHsgU1RBUlRfRFJBR0dJTkdfREVMQVkgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9yZWZlcmVuY2VcIjtcbmltcG9ydCB7IG1vdXNlVG9wRnJvbUV2ZW50LCBtb3VzZUxlZnRGcm9tRXZlbnQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2V2ZW50XCI7XG5pbXBvcnQgeyBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLCBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsIFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUgfSBmcm9tIFwiLi4vY3VzdG9tRXZlbnRUeXBlc1wiO1xuXG5jb25zdCB7IEVTQ0FQRV9LRVlfQ09ERSB9ID0ga2V5Q29kZXMsXG4gICAgICB7IExFRlRfTU9VU0VfQlVUVE9OIH0gPSBtb3VzZUJ1dHRvbnM7XG5cbmZ1bmN0aW9uIGdldERyYWdFbGVtZW50KCkge1xuICBjb25zdCB7IGRyYWdFbGVtZW50IH0gPSBnbG9iYWxUaGlzO1xuXG4gIHJldHVybiBkcmFnRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gc2V0RHJhZ0VsZW1lbnQoZHJhZ0VsZW1lbnQpIHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gICAgZHJhZ0VsZW1lbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0RHJhZ0VsZW1lbnQoKSB7XG4gIGNvbnN0IGRyYWdFbGVtZW50ID0gbnVsbDtcblxuICBzZXREcmFnRWxlbWVudChkcmFnRWxlbWVudCk7XG59XG5cbk9iamVjdC5hc3NpZ24oZ2xvYmFsVGhpcywge1xuICBnZXREcmFnRWxlbWVudCxcbiAgc2V0RHJhZ0VsZW1lbnQsXG4gIHJlc2V0RHJhZ0VsZW1lbnRcbn0pO1xuXG5yZXNldERyYWdFbGVtZW50KCk7XG5cbmZ1bmN0aW9uIGVuYWJsZURyYWcoKSB7XG4gIGNvbnN0IHRpbWVvdXQgPSBudWxsLFxuICAgICAgICB0b3BPZmZzZXQgPSBudWxsLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gbnVsbCxcbiAgICAgICAgZHJhZ0VuYWJsZWQgPSB0cnVlLFxuICAgICAgICBzdGFydE1vdXNlVG9wID0gbnVsbCxcbiAgICAgICAgc3RhcnRNb3VzZUxlZnQgPSBudWxsO1xuXG4gIHRoaXMub25Nb3VzZURvd24obW91c2VEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgdGltZW91dCxcbiAgICB0b3BPZmZzZXQsXG4gICAgbGVmdE9mZnNldCxcbiAgICBkcmFnRW5hYmxlZCxcbiAgICBzdGFydE1vdXNlVG9wLFxuICAgIHN0YXJ0TW91c2VMZWZ0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlRHJhZygpIHtcbiAgY29uc3QgZHJhZ0VuYWJsZWQgPSBmYWxzZTtcblxuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBkcmFnRW5hYmxlZFxuICB9KTtcblxuICB0aGlzLm9mZk1vdXNlRG93bihtb3VzZURvd25IYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25DdXN0b21EcmFnKGRyYWdDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnKGRyYWdDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub2ZmQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb25DdXN0b21TdG9wRHJhZyhzdG9wRHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RPUF9EUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gc3RvcERyYWdDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZkN1c3RvbVN0b3BEcmFnKHN0b3BEcmFnQ3VzdG9tSGFuZGxlciwgZWxlbWVudCkge1xuICBjb25zdCBjdXN0b21FdmVudFR5cGUgPSBTVE9QX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBzdG9wRHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9uQ3VzdG9tU3RhcnREcmFnKHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RBUlRfRFJBR19DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9uQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnRUeXBlLCBjdXN0b21IYW5kbGVyLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gb2ZmQ3VzdG9tU3RhcnREcmFnKHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gU1RBUlRfRFJBR19DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGlzRHJhZ0VuYWJsZWQoKSB7XG4gIGNvbnN0IHsgZHJhZ0VuYWJsZWQgPSBmYWxzZSB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBkcmFnRW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZygpIHtcbiAgY29uc3QgZHJhZ2dpbmcgPSB0aGlzLmhhc0NsYXNzKFwiZHJhZ2dpbmdcIik7XG5cbiAgcmV0dXJuIGRyYWdnaW5nO1xufVxuXG5mdW5jdGlvbiBzdGFydERyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgYm91bmRzVG9wID0gYm91bmRzLmdldFRvcCgpLFxuICAgICAgICBib3VuZHNMZWZ0ID0gYm91bmRzLmdldExlZnQoKSxcbiAgICAgICAgYm91bmRzUmlnaHQgPSBib3VuZHMuZ2V0UmlnaHQoKSxcbiAgICAgICAgYm91bmRzQm90dG9tID0gYm91bmRzLmdldEJvdHRvbSgpLFxuICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kc1JpZ2h0IC0gYm91bmRzTGVmdCxcbiAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzQm90dG9tIC0gYm91bmRzVG9wLFxuICAgICAgICB0b3BPZmZzZXQgPSBNYXRoLmZsb29yKGJvdW5kc0hlaWdodCAvIDIpLFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gTWF0aC5mbG9vcihib3VuZHNXaWR0aCAvIDIpLFxuICAgICAgICBkcmFnRWxlbWVudCA9IHRoaXMsIC8vL1xuICAgICAgICBzdGFydE1vdXNlVG9wID0gbW91c2VUb3AsIC8vL1xuICAgICAgICBzdGFydE1vdXNlTGVmdCA9IG1vdXNlTGVmdCwgLy8vXG4gICAgICAgIGN1c3RvbUV2ZW50VHlwZSA9IFNUQVJUX0RSQUdfQ1VTVE9NX0VWRU5UX1RZUEU7XG5cbiAgd2luZG93Lm9uS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9uTW91c2VNb3ZlKG1vdXNlTW92ZUhhbmRsZXIsIHRoaXMpO1xuXG4gIHRoaXMuYWRkQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICBzZXREcmFnRWxlbWVudChkcmFnRWxlbWVudCk7XG5cbiAgdGhpcy5zZXRUb3BPZmZzZXQodG9wT2Zmc2V0KTtcblxuICB0aGlzLnNldExlZnRPZmZzZXQobGVmdE9mZnNldCk7XG5cbiAgdGhpcy5zZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApO1xuXG4gIHRoaXMuc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpO1xuXG4gIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQpO1xuXG4gIHRoaXMuZHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BEcmFnKGV2ZW50LCBlbGVtZW50LCBhYm9ydGVkKSB7XG4gIGNvbnN0IGRyb3BFbGVtZW50ID0gZ2V0RHJvcEVsZW1lbnQoKSxcbiAgICAgICAgY3VzdG9tRXZlbnRUeXBlID0gU1RPUF9EUkFHX0NVU1RPTV9FVkVOVF9UWVBFO1xuXG4gIHRoaXMucmVtb3ZlQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcblxuICB3aW5kb3cub2ZmS2V5RG93bihrZXlEb3duSGFuZGxlciwgdGhpcyk7XG5cbiAgd2luZG93Lm9mZk1vdXNlTW92ZShtb3VzZU1vdmVIYW5kbGVyLCB0aGlzKTtcblxuICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzQXN5bmMoY3VzdG9tRXZlbnRUeXBlLCBldmVudCwgZWxlbWVudCwgZHJvcEVsZW1lbnQsIGFib3J0ZWQsICgpID0+IHtcbiAgICAgIHJlc2V0RHJhZ0VsZW1lbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChkcm9wRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxldCBkcmFnRWxlbWVudCA9IHRoaXM7IC8vL1xuXG4gICAgY29uc3QgZHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQgPSBjaGVja0RyYWdFbGVtZW50SWdub3Jlc0Ryb3BFbGVtZW50KGRyYWdFbGVtZW50LCBkcm9wRWxlbWVudCk7XG5cbiAgICBpZiAoZHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQpIHtcbiAgICAgIGRyYWdFbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkcm9wRWxlbWVudC5kcm9wKGV2ZW50LCBlbGVtZW50LCBkcmFnRWxlbWVudCwgYWJvcnRlZCwgZG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpIHtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LmdldFNjcm9sbFRvcCgpLFxuICAgICAgICBzY3JvbGxMZWZ0ID0gd2luZG93LmdldFNjcm9sbExlZnQoKSxcbiAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICBzdGFydE1vdXNlVG9wID0gdGhpcy5nZXRTdGFydE1vdXNlVG9wKCksXG4gICAgICAgIHN0YXJ0TW91c2VMZWZ0ID0gdGhpcy5nZXRTdGFydE1vdXNlTGVmdCgpLFxuICAgICAgICBjdXN0b21FdmVudFR5cGUgPSBEUkFHX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICByZWxhdGl2ZU1vdXNlVG9wID0gbW91c2VUb3AgLSBzdGFydE1vdXNlVG9wLFxuICAgICAgICByZWxhdGl2ZU1vdXNlTGVmdCA9IG1vdXNlTGVmdCAtIHN0YXJ0TW91c2VMZWZ0O1xuXG4gIGxldCB0b3AgPSBzdGFydE1vdXNlVG9wICsgcmVsYXRpdmVNb3VzZVRvcCAtIHRvcE9mZnNldCAtIHNjcm9sbFRvcCxcbiAgICAgIGxlZnQgPSBzdGFydE1vdXNlTGVmdCArIHJlbGF0aXZlTW91c2VMZWZ0IC0gbGVmdE9mZnNldCAtIHNjcm9sbExlZnQ7XG5cbiAgdG9wID0gYCR7dG9wfXB4YDsgLy8vXG4gIGxlZnQgPSBgJHtsZWZ0fXB4YDsgLy8vXG5cbiAgY29uc3QgY3NzID0ge1xuICAgIHRvcCxcbiAgICBsZWZ0XG4gIH07XG5cbiAgdGhpcy5jc3MoY3NzKTtcblxuICB0aGlzLmNhbGxDdXN0b21IYW5kbGVycyhjdXN0b21FdmVudFR5cGUsIGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2FpdGluZ1RvRHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCkge1xuICBsZXQgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ID09PSBudWxsKSB7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcblxuICAgICAgdGhpcy5zdGFydERyYWcoZXZlbnQsIGVsZW1lbnQsIG1vdXNlVG9wLCBtb3VzZUxlZnQpO1xuICAgIH0sIFNUQVJUX0RSQUdHSU5HX0RFTEFZKTtcblxuICAgIHRoaXMudXBkYXRlVGltZW91dCh0aW1lb3V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV2FpdGluZ1RvRHJhZygpIHtcbiAgY29uc3QgdGltZW91dCA9IHRoaXMuZ2V0VGltZW91dCgpO1xuXG4gIGlmICh0aW1lb3V0ICE9PSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0KCkge1xuICBjb25zdCB7IHRpbWVvdXQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICByZXR1cm4gdGltZW91dDtcbn1cblxuZnVuY3Rpb24gcmVzZXRUaW1lb3V0KCkge1xuICBjb25zdCB0aW1lb3V0ID0gbnVsbDtcblxuICB0aGlzLnVwZGF0ZVRpbWVvdXQodGltZW91dCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVvdXQodGltZW91dCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0aW1lb3V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BPZmZzZXQoKSB7XG4gIGNvbnN0IHsgdG9wT2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIHRvcE9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCgpIHtcbiAgY29uc3QgeyBsZWZ0T2Zmc2V0IH0gPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgcmV0dXJuIGxlZnRPZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0TW91c2VUb3AoKSB7XG4gIGNvbnN0IHsgc3RhcnRNb3VzZVRvcCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlVG9wO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydE1vdXNlTGVmdCgpIHtcbiAgY29uc3QgeyBzdGFydE1vdXNlTGVmdCB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gIHJldHVybiBzdGFydE1vdXNlTGVmdDtcbn1cblxuZnVuY3Rpb24gc2V0VG9wT2Zmc2V0KHRvcE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICB0b3BPZmZzZXRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldExlZnRPZmZzZXQobGVmdE9mZnNldCkge1xuICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICBsZWZ0T2Zmc2V0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRTdGFydE1vdXNlVG9wKHN0YXJ0TW91c2VUb3ApIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZVRvcFxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0U3RhcnRNb3VzZUxlZnQoc3RhcnRNb3VzZUxlZnQpIHtcbiAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgc3RhcnRNb3VzZUxlZnRcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW5hYmxlRHJhZyxcbiAgZGlzYWJsZURyYWcsXG4gIG9uQ3VzdG9tRHJhZyxcbiAgb2ZmQ3VzdG9tRHJhZyxcbiAgb25DdXN0b21TdG9wRHJhZyxcbiAgb2ZmQ3VzdG9tU3RvcERyYWcsXG4gIG9uQ3VzdG9tU3RhcnREcmFnLFxuICBvZmZDdXN0b21TdGFydERyYWcsXG4gIGlzRHJhZ0VuYWJsZWQsXG4gIGlzRHJhZ2dpbmcsXG4gIHN0YXJ0RHJhZyxcbiAgc3RvcERyYWcsXG4gIGRyYWcsXG4gIHN0YXJ0V2FpdGluZ1RvRHJhZyxcbiAgc3RvcFdhaXRpbmdUb0RyYWcsXG4gIGdldFRpbWVvdXQsXG4gIHJlc2V0VGltZW91dCxcbiAgdXBkYXRlVGltZW91dCxcbiAgZ2V0VG9wT2Zmc2V0LFxuICBnZXRMZWZ0T2Zmc2V0LFxuICBnZXRTdGFydE1vdXNlVG9wLFxuICBnZXRTdGFydE1vdXNlTGVmdCxcbiAgc2V0VG9wT2Zmc2V0LFxuICBzZXRMZWZ0T2Zmc2V0LFxuICBzZXRTdGFydE1vdXNlVG9wLFxuICBzZXRTdGFydE1vdXNlTGVmdFxufTtcblxuZnVuY3Rpb24ga2V5RG93bkhhbmRsZXIoZXZlbnQsIGVsZW1lbnQpIHtcbiAgY29uc3QgeyBrZXlDb2RlIH0gPSBldmVudCxcbiAgICAgICAgZXNjYXBlS2V5ID0gKGtleUNvZGUgPT09IEVTQ0FQRV9LRVlfQ09ERSksXG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuXG4gIGlmIChlc2NhcGVLZXkpIHtcbiAgICB0aGlzLnN0b3BEcmFnKGV2ZW50LCBlbGVtZW50LCBhYm9ydGVkKTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNlVXBIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCksXG4gICAgICAgIGFib3J0ZWQgPSBmYWxzZTtcblxuICBkcmFnZ2luZyA/XG4gICAgdGhpcy5zdG9wRHJhZyhldmVudCwgZWxlbWVudCwgYWJvcnRlZCkgOlxuICAgICAgdGhpcy5zdG9wV2FpdGluZ1RvRHJhZygpO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gIHdpbmRvdy5vZmZCbHVyKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTsgIC8vL1xuXG4gIHdpbmRvdy5vZmZNb3VzZVVwKG1vdXNlVXBIYW5kbGVyLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gbW91c2VEb3duSGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCB7IGJ1dHRvbiB9ID0gZXZlbnQ7XG5cbiAgaWYgKGJ1dHRvbiA9PT0gTEVGVF9NT1VTRV9CVVRUT04pIHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZygpO1xuXG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgY29uc3QgbW91c2VUb3AgPSBtb3VzZVRvcEZyb21FdmVudChldmVudCksXG4gICAgICAgICAgICBtb3VzZUxlZnQgPSBtb3VzZUxlZnRGcm9tRXZlbnQoZXZlbnQpO1xuXG4gICAgICB0aGlzLnN0YXJ0V2FpdGluZ1RvRHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gICAgfVxuICB9XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgd2luZG93Lm9uQmx1cihtb3VzZVVwSGFuZGxlciwgdGhpcyk7IC8vL1xuXG4gIHdpbmRvdy5vbk1vdXNlVXAobW91c2VVcEhhbmRsZXIsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBtb3VzZU1vdmVIYW5kbGVyKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nKCk7XG5cbiAgaWYgKGRyYWdnaW5nKSB7XG4gICAgY29uc3QgbW91c2VUb3AgPSBtb3VzZVRvcEZyb21FdmVudChldmVudCksXG4gICAgICAgICAgbW91c2VMZWZ0ID0gbW91c2VMZWZ0RnJvbUV2ZW50KGV2ZW50KTtcblxuICAgIHRoaXMuZHJhZyhldmVudCwgZWxlbWVudCwgbW91c2VUb3AsIG1vdXNlTGVmdCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgY2hlY2tEcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVmZXJlbmNlXCI7XG5pbXBvcnQgeyBEUk9QX0NVU1RPTV9FVkVOVF9UWVBFLCBEUkFHX09VVF9DVVNUT01fRVZFTlRfVFlQRSwgRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFIH0gZnJvbSBcIi4uL2N1c3RvbUV2ZW50VHlwZXNcIjtcblxuZnVuY3Rpb24gZ2V0RHJvcEVsZW1lbnQoKSB7XG4gIGNvbnN0IHsgZHJvcEVsZW1lbnQgfSA9IGdsb2JhbFRoaXM7XG5cbiAgcmV0dXJuIGRyb3BFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBzZXREcm9wRWxlbWVudChkcm9wRWxlbWVudCkge1xuICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgICBkcm9wRWxlbWVudFxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXREcm9wRWxlbWVudCgpIHtcbiAgY29uc3QgZHJvcEVsZW1lbnQgPSBudWxsO1xuXG4gIHNldERyb3BFbGVtZW50KGRyb3BFbGVtZW50KTtcbn1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gIGdldERyb3BFbGVtZW50LFxuICBzZXREcm9wRWxlbWVudCxcbiAgcmVzZXREcm9wRWxlbWVudFxufSk7XG5cbnJlc2V0RHJvcEVsZW1lbnQoKTtcblxuZnVuY3Rpb24gZHJvcChldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQsIGFib3J0ZWQsIGRvbmUpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRTtcblxuICB0aGlzLmNhbGxDdXN0b21IYW5kbGVyc0FzeW5jKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50LCBhYm9ydGVkLCBkb25lKTtcbn1cblxuZnVuY3Rpb24gZHJhZ091dChldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEU7XG5cbiAgdGhpcy5jYWxsQ3VzdG9tSGFuZGxlcnMoY3VzdG9tRXZlbnRUeXBlLCBldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBkcmFnT3ZlcihldmVudCwgZWxlbWVudCwgZHJhZ0VsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFO1xuXG4gIHRoaXMuY2FsbEN1c3RvbUhhbmRsZXJzKGN1c3RvbUV2ZW50VHlwZSwgZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRHJvcCgpIHtcbiAgdGhpcy5vbk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gIHRoaXMub25Nb3VzZU92ZXIobW91c2VPdmVySGFuZGxlciwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVEcm9wKCkge1xuICB0aGlzLm9mZk1vdXNlT3V0KG1vdXNlT3V0SGFuZGxlciwgdGhpcyk7XG4gIHRoaXMub2ZmTW91c2VPdmVyKG1vdXNlT3ZlckhhbmRsZXIsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkN1c3RvbURyb3AoZHJvcEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyb3BDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vbkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9mZkN1c3RvbURyb3AoZHJvcEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJPUF9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyb3BDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvbkN1c3RvbURyYWdPdXQoZHJhZ091dEN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVVRfQ1VTVE9NX0VWRU5UX1RZUEUsXG4gICAgICAgIGN1c3RvbUhhbmRsZXIgPSBkcmFnT3V0Q3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnT3V0KGRyYWdPdXRDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfT1VUX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gZHJhZ091dEN1c3RvbUhhbmRsZXI7ICAvLy9cblxuICB0aGlzLm9mZkN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50VHlwZSwgY3VzdG9tSGFuZGxlciwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIG9uQ3VzdG9tRHJhZ092ZXIoZHJhZ092ZXJDdXN0b21IYW5kbGVyLCBlbGVtZW50KSB7XG4gIGNvbnN0IGN1c3RvbUV2ZW50VHlwZSA9IERSQUdfT1ZFUl9DVVNUT01fRVZFTlRfVFlQRSxcbiAgICAgICAgY3VzdG9tSGFuZGxlciA9IGRyYWdPdmVyQ3VzdG9tSGFuZGxlcjsgIC8vL1xuXG4gIHRoaXMub25DdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBvZmZDdXN0b21EcmFnT3ZlcihkcmFnT3ZlckN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpIHtcbiAgY29uc3QgY3VzdG9tRXZlbnRUeXBlID0gRFJBR19PVkVSX0NVU1RPTV9FVkVOVF9UWVBFLFxuICAgICAgICBjdXN0b21IYW5kbGVyID0gZHJhZ092ZXJDdXN0b21IYW5kbGVyOyAgLy8vXG5cbiAgdGhpcy5vZmZDdXN0b21FdmVudChjdXN0b21FdmVudFR5cGUsIGN1c3RvbUhhbmRsZXIsIGVsZW1lbnQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyb3AsXG4gIGRyYWdPdXQsXG4gIGRyYWdPdmVyLFxuICBlbmFibGVEcm9wLFxuICBkaXNhYmxlRHJvcCxcbiAgb25DdXN0b21Ecm9wLFxuICBvZmZDdXN0b21Ecm9wLFxuICBvbkN1c3RvbURyYWdPdXQsXG4gIG9mZkN1c3RvbURyYWdPdXQsXG4gIG9uQ3VzdG9tRHJhZ092ZXIsXG4gIG9mZkN1c3RvbURyYWdPdmVyXG59XG5cbmZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnRWxlbWVudCA9IGdldERyYWdFbGVtZW50KCk7XG5cbiAgaWYgKGRyYWdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcmVzZXREcm9wRWxlbWVudCgpO1xuXG4gICAgdGhpcy5kcmFnT3V0KGV2ZW50LCBlbGVtZW50LCBkcmFnRWxlbWVudCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlcihldmVudCwgZWxlbWVudCkge1xuICBjb25zdCBkcmFnRWxlbWVudCA9IGdldERyYWdFbGVtZW50KCk7XG5cbiAgaWYgKGRyYWdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgZHJvcEVsZW1lbnQgPSB0aGlzLCAvLy9cbiAgICAgICAgICBkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCA9IGNoZWNrRHJhZ0VsZW1lbnRJZ25vcmVzRHJvcEVsZW1lbnQoZHJhZ0VsZW1lbnQsIGRyb3BFbGVtZW50KTtcblxuICAgIGlmIChkcmFnRWxlbWVudElnbm9yZXNEcm9wRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldERyb3BFbGVtZW50KGRyb3BFbGVtZW50KTtcblxuICAgIHRoaXMuZHJhZ092ZXIoZXZlbnQsIGVsZW1lbnQsIGRyYWdFbGVtZW50KTtcbiAgfVxuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBkcmFnTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZHJhZ1wiO1xuXG5jbGFzcyBEcmFnRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRSZWZlcmVuY2VzKCkge1xuICAgIGNvbnN0IHsgcmVmZXJlbmNlcyA9IFtdIH0gPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgfVxuXG4gIGRpZE1vdW50KCkge1xuICAgIHRoaXMuZW5hYmxlRHJhZygpO1xuICB9XG5cbiAgd2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlRHJhZygpO1xuICB9XG5cbiAgc3RhdGljIGlnbm9yZWRQcm9wZXJ0aWVzID0gW1xuICAgIFwicmVmZXJlbmNlc1wiXG4gIF07XG59XG5cbk9iamVjdC5hc3NpZ24oRHJhZ0VsZW1lbnQucHJvdG90eXBlLCBkcmFnTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKERyYWdFbGVtZW50KWBcblxuICAuZHJhZ2dpbmcge1xuICAgIHotaW5kZXg6IDE7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5cbmltcG9ydCBkcm9wTWl4aW5zIGZyb20gXCIuLi9taXhpbnMvZHJvcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBnZXRSZWZlcmVuY2UoKSB7XG4gICAgY29uc3QgeyByZWZlcmVuY2UgPSBudWxsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlO1xuICB9XG5cbiAgZGlkTW91bnQoKSB7XG4gICAgdGhpcy5lbmFibGVEcm9wKCk7XG4gIH1cblxuICB3aWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGVEcm9wKCk7XG4gIH1cblxuICBzdGF0aWMgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgXCJyZWZlcmVuY2VcIlxuICBdO1xufVxuXG5PYmplY3QuYXNzaWduKERyb3BFbGVtZW50LnByb3RvdHlwZSwgZHJvcE1peGlucyk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgZHJhZ01peGlucyB9IGZyb20gXCIuL21peGlucy9kcmFnXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGRyb3BNaXhpbnMgfSBmcm9tIFwiLi9taXhpbnMvZHJvcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcmFnRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnQvZHJhZ1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEcm9wRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnQvZHJvcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjdXN0b21FdmVudFR5cGVzIH0gZnJvbSBcIi4vY3VzdG9tRXZlbnRUeXBlc1wiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcblxuY2xhc3MgU2l6ZWFibGVEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RhdGljIHRhZ05hbWUgPSBcImRpdlwiO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwic2l6ZWFibGVcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoU2l6ZWFibGVEaXYpYFxuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJlYXN5XCI7XG5pbXBvcnQgeyBkcmFnTWl4aW5zIH0gZnJvbSBcImVhc3ktZHJhZy1hbmQtZHJvcFwiO1xuXG5pbXBvcnQgU2l6ZWFibGVEaXYgZnJvbSBcIi4uL2Rpdi9zaXplYWJsZVwiO1xuXG5pbXBvcnQgeyByZXNldEN1cnNvciB9IGZyb20gXCIuLi9jdXJzb3JcIjtcblxuY2xhc3MgU3BsaXR0ZXJEaXYgZXh0ZW5kcyBFbGVtZW50IHtcbiAgc3RvcERyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCBkcm9wRWxlbWVudCwgYWJvcnRlZCwgZG9uZSkgPT4ge1xuICAgIHJlc2V0Q3Vyc29yKCk7XG5cbiAgICBkb25lKCk7XG4gIH1cblxuICBtb3VzZU91dEhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICByZXNldEN1cnNvcigpO1xuICB9XG5cbiAgZ2V0U2l6ZWFibGVEaXYoKSB7XG4gICAgbGV0IHNpemVhYmxlRGl2O1xuXG4gICAgY29uc3QgbmV4dFNpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXROZXh0U2libGluZ0VsZW1lbnQoKSxcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50ID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmdFbGVtZW50KCksXG4gICAgICAgICAgbmV4dFNpYmxpbmdFbGVtZW50U2l6ZWFibGVEaXYgPSAobmV4dFNpYmxpbmdFbGVtZW50IGluc3RhbmNlb2YgU2l6ZWFibGVEaXYpLFxuICAgICAgICAgIHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdiA9IChwcmV2aW91c1NpYmxpbmdFbGVtZW50IGluc3RhbmNlb2YgU2l6ZWFibGVEaXYpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nRWxlbWVudFNpemVhYmxlRGl2KSB7XG4gICAgICBzaXplYWJsZURpdiA9IG5leHRTaWJsaW5nRWxlbWVudDsgLy8vXG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgc2l6ZWFibGVEaXYgPSBwcmV2aW91c1NpYmxpbmdFbGVtZW50OyAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZWFibGVEaXY7XG4gIH1cblxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgbGV0IGRpcmVjdGlvbjtcblxuICAgIGNvbnN0IG5leHRTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdFbGVtZW50KCksXG4gICAgICAgICAgcHJldmlvdXNTaWJsaW5nRWxlbWVudCA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nRWxlbWVudCgpLFxuICAgICAgICAgIG5leHRTaWJsaW5nRWxlbWVudFNpemVhYmxlRGl2ID0gKG5leHRTaWJsaW5nRWxlbWVudCBpbnN0YW5jZW9mIFNpemVhYmxlRGl2KSxcbiAgICAgICAgICBwcmV2aW91c1NpYmxpbmdFbGVtZW50U2l6ZWFibGVEaXYgPSAocHJldmlvdXNTaWJsaW5nRWxlbWVudCBpbnN0YW5jZW9mIFNpemVhYmxlRGl2KTtcblxuICAgIGlmIChuZXh0U2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgZGlyZWN0aW9uID0gKzE7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU2libGluZ0VsZW1lbnRTaXplYWJsZURpdikge1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIGdldFJlZmVyZW5jZXMoKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICBlbmFibGUoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKTtcblxuICAgIGlmICghZHJhZ0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuZW5hYmxlRHJhZygpO1xuXG4gICAgICB0aGlzLm9uQ3VzdG9tRHJhZyh0aGlzLmRyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vbkN1c3RvbVN0b3BEcmFnKHRoaXMuc3RvcERyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vbkN1c3RvbVN0YXJ0RHJhZyh0aGlzLnN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKTtcblxuICAgIGlmIChkcmFnRW5hYmxlZCkge1xuICAgICAgdGhpcy5vZmZDdXN0b21TdGFydERyYWcodGhpcy5zdGFydERyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5vZmZDdXN0b21TdG9wRHJhZyh0aGlzLnN0b3BEcmFnQ3VzdG9tSGFuZGxlcik7XG5cbiAgICAgIHRoaXMub2ZmQ3VzdG9tRHJhZyh0aGlzLmRyYWdDdXN0b21IYW5kbGVyKTtcblxuICAgICAgdGhpcy5kaXNhYmxlRHJhZygpO1xuICAgIH1cbiAgfVxuXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgY29uc3QgZHJhZ0VuYWJsZWQgPSB0aGlzLmlzRHJhZ0VuYWJsZWQoKSxcbiAgICAgICAgICBkaXNhYmxlZCA9ICFkcmFnRW5hYmxlZDtcblxuICAgIHJldHVybiBkaXNhYmxlZDtcbiAgfVxuXG4gIGRpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQgPSBmYWxzZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uTW91c2VPdmVyKHRoaXMubW91c2VPdmVySGFuZGxlcik7XG5cbiAgICB0aGlzLm9uTW91c2VPdXQodGhpcy5tb3VzZU91dEhhbmRsZXIpO1xuICB9XG5cbiAgd2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKTtcblxuICAgIHRoaXMub2ZmTW91c2VPdXQodGhpcy5tb3VzZU91dEhhbmRsZXIpO1xuXG4gICAgdGhpcy5vZmZNb3VzZU92ZXIodGhpcy5tb3VzZU92ZXJIYW5kbGVyKTtcblxuICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxpc2UoKSB7XG4gICAgdGhpcy5zZXRJbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgaWdub3JlZFByb3BlcnRpZXMgPSBbXG4gICAgXCJkaXNhYmxlZFwiXG4gIF07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJzcGxpdHRlclwiXG4gIH07XG59XG5cbk9iamVjdC5hc3NpZ24oU3BsaXR0ZXJEaXYucHJvdG90eXBlLCBkcmFnTWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlKFNwbGl0dGVyRGl2KWBcblxuICBmbGV4LXNocmluazogMDtcblxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IFNwbGl0dGVyIGZyb20gXCIuLi9zcGxpdHRlclwiO1xuXG5pbXBvcnQgeyBjb2x1bW5SZXNpemVDdXJzb3IgfSBmcm9tIFwiLi4vLi4vY3Vyc29yXCI7XG5cbmNsYXNzIFZlcnRpY2FsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gc2l6ZWFibGVEaXYuZ2V0V2lkdGgoKSxcbiAgICAgICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSBzaXplYWJsZURpdldpZHRoOyAgLy8vXG5cbiAgICB0aGlzLnNldFByZXZpb3VzU2l6ZWFibGVEaXZXaWR0aChwcmV2aW91c1NpemVhYmxlRGl2V2lkdGgpO1xuXG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIGRyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdldpZHRoID0gdGhpcy5nZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSxcbiAgICAgICAgICBzaXplYWJsZURpdldpZHRoID0gcHJldmlvdXNTaXplYWJsZURpdldpZHRoIC0gZGlyZWN0aW9uICogcmVsYXRpdmVNb3VzZUxlZnQsXG4gICAgICAgICAgd2lkdGggPSBzaXplYWJsZURpdldpZHRoOyAvLy9cblxuICAgIHNpemVhYmxlRGl2LnNldFdpZHRoKHdpZHRoKTtcbiAgfVxuXG4gIG1vdXNlT3ZlckhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICB0aGlzLnNldEN1cnNvcigpO1xuICB9XG5cbiAgc2V0Q3Vyc29yKCkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5pc0Rpc2FibGVkKCk7XG5cbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICBjb2x1bW5SZXNpemVDdXJzb3IoKTtcbiAgICB9XG4gIH1cblxuICBnZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgoKSB7XG4gICAgY29uc3QgeyBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIHJldHVybiBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGg7XG4gIH1cblxuICBzZXRQcmV2aW91c1NpemVhYmxlRGl2V2lkdGgocHJldmlvdXNTaXplYWJsZURpdldpZHRoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGhcbiAgICB9KTtcbiAgfVxuXG4gIHNldEluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGggPSBudWxsO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2V2lkdGhcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwidmVydGljYWxcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVmVydGljYWxTcGxpdHRlcilgXG5cbiAgd2lkdGg6IDFyZW07XG5cbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB3aXRoU3R5bGUgZnJvbSBcImVhc3ktd2l0aC1zdHlsZVwiOyAgLy8vXG5cbmltcG9ydCBTcGxpdHRlciBmcm9tIFwiLi4vc3BsaXR0ZXJcIjtcblxuaW1wb3J0IHsgcm93UmVzaXplQ3Vyc29yIH0gZnJvbSBcIi4uLy4uL2N1cnNvclwiO1xuXG5jbGFzcyBIb3Jpem9udGFsU3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gIHN0YXJ0RHJhZ0N1c3RvbUhhbmRsZXIgPSAoZXZlbnQsIGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzaXplYWJsZURpdiA9IHRoaXMuZ2V0U2l6ZWFibGVEaXYoKSxcbiAgICAgICAgICBzaXplYWJsZURpdkhlaWdodCA9IHNpemVhYmxlRGl2LmdldEhlaWdodCgpLFxuICAgICAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgPSBzaXplYWJsZURpdkhlaWdodDsgIC8vL1xuXG4gICAgdGhpcy5zZXRQcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQpO1xuXG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIGRyYWdDdXN0b21IYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50LCByZWxhdGl2ZU1vdXNlVG9wLCByZWxhdGl2ZU1vdXNlTGVmdCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgICAgc2l6ZWFibGVEaXYgPSB0aGlzLmdldFNpemVhYmxlRGl2KCksXG4gICAgICAgICAgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IHRoaXMuZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpLFxuICAgICAgICAgIHNpemVhYmxlRGl2SGVpZ2h0ID0gcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCAtIGRpcmVjdGlvbiAqIHJlbGF0aXZlTW91c2VUb3AsXG4gICAgICAgICAgaGVpZ2h0ID0gc2l6ZWFibGVEaXZIZWlnaHQ7IC8vL1xuXG4gICAgc2l6ZWFibGVEaXYuc2V0SGVpZ2h0KGhlaWdodCk7XG4gIH1cblxuICBtb3VzZU92ZXJIYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50KSA9PiB7XG4gICAgdGhpcy5zZXRDdXJzb3IoKTtcbiAgfVxuXG4gIHNldEN1cnNvcigpIHtcbiAgICBjb25zdCBkaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpO1xuXG4gICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgcm93UmVzaXplQ3Vyc29yKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodCgpIHtcbiAgICBjb25zdCB7IHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHQgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIHJldHVybiBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0O1xuICB9XG5cbiAgc2V0UHJldmlvdXNTaXplYWJsZURpdkhlaWdodChwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0KSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICBwcmV2aW91c1NpemVhYmxlRGl2SGVpZ2h0XG4gICAgfSk7XG4gIH1cblxuICBzZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgY29uc3QgcHJldmlvdXNTaXplYWJsZURpdkhlaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHByZXZpb3VzU2l6ZWFibGVEaXZIZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwiaG9yaXpvbnRhbFwiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShIb3Jpem9udGFsU3BsaXR0ZXIpYFxuXG4gIGhlaWdodDogMXJlbTtcblxuYDtcbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3Vyc29yIH0gZnJvbSBcIi4vY3Vyc29yXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm93RGl2IH0gZnJvbSBcIi4vZGl2L3Jvd1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb3dzRGl2IH0gZnJvbSBcIi4vZGl2L3Jvd3NcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sdW1uRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2x1bW5zRGl2IH0gZnJvbSBcIi4vZGl2L2NvbHVtbnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2l6ZWFibGVEaXYgfSBmcm9tIFwiLi9kaXYvc2l6ZWFibGVcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmVydGljYWxTcGxpdHRlckRpdiB9IGZyb20gXCIuL2Rpdi9zcGxpdHRlci92ZXJ0aWNhbFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIb3Jpem9udGFsU3BsaXR0ZXJEaXYgfSBmcm9tIFwiLi9kaXYvc3BsaXR0ZXIvaG9yaXpvbnRhbFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBsZXZlbHMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmV4cG9ydCBjb25zdCB7IFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwgfSA9IGxldmVscztcblxuZXhwb3J0IGNvbnN0IExFVkVMUyA9IFtcbiAgVFJBQ0VfTEVWRUwsXG4gIERFQlVHX0xFVkVMLFxuICBJTkZPX0xFVkVMLFxuICBXQVJOSU5HX0xFVkVMLFxuICBFUlJPUl9MRVZFTFxuXTtcblxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUklORyA9IFwiXCI7XG5leHBvcnQgY29uc3QgU0lOR0xFX1NQQUNFID0gXCIgXCI7XG5leHBvcnQgY29uc3QgRE9VQkxFX1NQQUNFID0gXCIgIFwiO1xuZXhwb3J0IGNvbnN0IEJSRUFLX01FU1NBR0UgPSBcIjo6IEJSRUFLIDo6XCI7XG5leHBvcnQgY29uc3QgTEVWRUxfTUFYSU1VTV9MRU5HVEggPSA3O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBMRVZFTFMsIFNJTkdMRV9TUEFDRSwgRU1QVFlfU1RSSU5HLCBMRVZFTF9NQVhJTVVNX0xFTkdUSCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5jb25zdCBbIFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwgXSA9IExFVkVMUztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZXMsIGxvZ0xldmVsLCBmb2xsb3cpIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgIHRoaXMuZm9sbG93ID0gZm9sbG93O1xuICB9XG5cbiAgZ2V0TWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXM7XG4gIH1cblxuICBnZXRMb2dMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dMZXZlbDtcbiAgfVxuXG4gIGdldEZvbGxvdygpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xsb3c7XG4gIH1cblxuICB0cmFjZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBUUkFDRV9MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gREVCVUdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGluZm8obWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gSU5GT19MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd2FybmluZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBXQVJOSU5HX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZShsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBlcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBFUlJPUl9MRVZFTDtcblxuICAgIHRoaXMud3JpdGUobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd3JpdGUobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoID0gbnVsbCwgbGluZUluZGV4ID0gbnVsbCkge1xuICAgIGNvbnN0IGxldmVsSW5kZXggPSBMRVZFTFMuaW5kZXhPZihsZXZlbCksXG4gICAgICAgICAgbG9nTGV2ZWxJbmRleCA9IExFVkVMUy5pbmRleE9mKHRoaXMubG9nTGV2ZWwpO1xuXG4gICAgaWYgKGxldmVsSW5kZXggPCBsb2dMZXZlbEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpOyAgLy8vXG5cbiAgICB0aGlzLmZvbGxvdyA/XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKSA6XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IG51bGwsXG4gICAgICAgICAgbG9nTGV2ZWwgPSBUUkFDRV9MRVZFTCxcbiAgICAgICAgICBmb2xsb3cgPSB0cnVlLFxuICAgICAgICAgIGxvZyA9IG5ldyBMb2cobWVzc2FnZXMsIGxvZ0xldmVsLCBmb2xsb3cpO1xuXG4gICAgcmV0dXJuIGxvZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRm9sbG93QW5kTG9nTGV2ZWwoZm9sbG93LCBsb2dMZXZlbCkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gZm9sbG93ID9cbiAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgbG9nID0gbmV3IExvZyhtZXNzYWdlcywgbG9nTGV2ZWwsIGZvbGxvdyk7XG5cbiAgICByZXR1cm4gbG9nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpIHtcbiAgbGV0IGZvcm1hdHRlZE1lc3NhZ2UgPSBFTVBUWV9TVFJJTkc7XG5cbiAgY29uc3QgbGVmdFBhZGRlZExldmVsID0gbGVmdFBhZExldmVsKGxldmVsKSxcbiAgICAgICAgdXBwZXJDYXNlTGVmdFBhZGRlZExldmVsID0gbGVmdFBhZGRlZExldmVsLnRvVXBwZXJDYXNlKCk7XG5cbiAgZm9ybWF0dGVkTWVzc2FnZSArPSBgJHt1cHBlckNhc2VMZWZ0UGFkZGVkTGV2ZWx9OiBgO1xuXG4gIGlmIChmaWxlUGF0aCAhPT0gbnVsbCkge1xuICAgIGZvcm1hdHRlZE1lc3NhZ2UgKz0gYCR7ZmlsZVBhdGh9IGA7XG4gIH1cblxuICBpZiAobGluZUluZGV4ICE9PSBudWxsKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgWyR7bGluZUluZGV4fV0gYDtcbiAgfVxuXG4gIGlmICgoZmlsZVBhdGggIT09IG51bGwpIHx8IChsaW5lSW5kZXggIT09IG51bGwpKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSArPSBgLSBgO1xuICB9XG5cbiAgZm9ybWF0dGVkTWVzc2FnZSArPSBtZXNzYWdlO1xuXG4gIG1lc3NhZ2UgPSBmb3JtYXR0ZWRNZXNzYWdlOyAvLy9cblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZExldmVsKGxldmVsKSB7XG4gIGNvbnN0IG1heGltdW1MZW5ndGggPSBMRVZFTF9NQVhJTVVNX0xFTkdUSCxcbiAgICAgICAgbGVmdFBhZGRlZExldmVsID0gbGVmdFBhZChsZXZlbCwgbWF4aW11bUxlbmd0aCk7XG5cbiAgcmV0dXJuIGxlZnRQYWRkZWRMZXZlbDtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZChzdHJpbmcsIG1heGltdW1MZW5ndGgpIHtcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgbGVuZ3RoID0gbWF4aW11bUxlbmd0aCAtIHN0cmluZ0xlbmd0aCxcbiAgICAgICAgaW5kZW50ID0gU0lOR0xFX1NQQUNFLnJlcGVhdChsZW5ndGgpLFxuICAgICAgICBsZWZ0UGFkZGVkU3RyaW5nID0gYCR7aW5kZW50fSR7c3RyaW5nfWA7XG5cbiAgcmV0dXJuIGxlZnRQYWRkZWRTdHJpbmc7XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgfVxuXG4gIGdldFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gIH1cblxuICBnZXROb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAgc2V0U3RyaW5nKHN0cmluZykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICB9XG5cbiAgc2V0Tm9kZShub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIGFzeW5jIGJyZWFrKGNvbnRleHQpIHtcbiAgICBhd2FpdCBjb250ZXh0LmJyZWFrKHRoaXMubm9kZSk7XG4gIH1cblxuICBtYXRjaE5vZGUobm9kZSkgeyByZXR1cm4gdGhpcy5ub2RlLm1hdGNoKG5vZGUpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERPVUJMRV9TUEFDRSwgVFJBQ0VfTEVWRUwsIERFQlVHX0xFVkVMLCBJTkZPX0xFVkVMLCBFUlJPUl9MRVZFTCwgV0FSTklOR19MRVZFTCB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICBnZXREZXB0aCgpIHtcbiAgICBsZXQgZGVwdGggPSB0aGlzLmNvbnRleHQuZ2V0RGVwdGgoKTtcblxuICAgIGRlcHRoKys7XG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBnZXRSZWxlYXNlQ29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRSZWxlYXNlQ29udGV4dCgpOyB9XG5cbiAgbm9kZXNBc1N0cmluZyhub2RlKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZXNBc1N0cmluZyhub2RlKTsgfVxuXG4gIG5vZGVBc1N0cmluZyhub2RlKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpOyB9XG5cbiAgdHJhY2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gVFJBQ0VfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgZGVidWcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gREVCVUdfTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgaW5mbyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBJTkZPX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHdhcm5pbmcobWVzc2FnZSkge1xuICAgIGNvbnN0IGxldmVsID0gV0FSTklOR19MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBlcnJvcihtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBFUlJPUl9MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICB3cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZGVwdGggPSB0aGlzLmdldERlcHRoKCksXG4gICAgICAgICAgaW5kZW50ID0gRE9VQkxFX1NQQUNFLnJlcGVhdChkZXB0aCk7XG5cbiAgICBtZXNzYWdlID0gYCR7aW5kZW50fSR7bWVzc2FnZX1gOyAgLy8vXG5cbiAgICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHRoaXMuZ2V0UmVsZWFzZUNvbnRleHQoKTtcblxuICAgIHJlbGVhc2VDb250ZXh0LndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsobm9kZSkgeyBhd2FpdCB0aGlzLmNvbnRleHQuYnJlYWsobm9kZSk7IH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoQ2xhc3MsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBjb250ZXh0ID0gcmVtYWluaW5nQXJndW1lbnRzLnBvcCgpO1xuXG4gICAgY29udGV4dCA9IG5ldyBDbGFzcyhjb250ZXh0LCAuLi5yZW1haW5pbmdBcmd1bWVudHMpOyAgLy8vXG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZUluZGV4RnJvbU5vZGVBbmRUb2tlbnMobm9kZSwgdG9rZW5zKSB7XG4gIGxldCBsaW5lSW5kZXggPSAwO1xuXG4gIGNvbnN0IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9kZS5nZXRGaXJzdFNpZ25pZmljYW50VG9rZW5JbmRleCh0b2tlbnMpO1xuXG4gIHRva2Vucy5zb21lKCh0b2tlbiwgdG9rZW5JbmRleCkgPT4ge1xuICAgIGNvbnN0IHRva2VuRW5kT2ZMaW5lVG9rZW4gPSB0b2tlbi5pc0VuZE9mTGluZVRva2VuKCk7XG5cbiAgICBpZiAodG9rZW5FbmRPZkxpbmVUb2tlbikge1xuICAgICAgbGluZUluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuSW5kZXggPT09IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBsaW5lSW5kZXg7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVBc1N0cmluZyhub2RlLCB0b2tlbnMpIHtcbiAgbGV0IHN0cmluZztcblxuICB0b2tlbnMgPSBub2RlQXNUb2tlbnMobm9kZSwgdG9rZW5zKTsgIC8vL1xuXG4gIHN0cmluZyA9IHRva2Vuc0FzU3RyaW5nKHRva2Vucyk7XG5cbiAgc3RyaW5nID0gdHJpbVN0cmluZyhzdHJpbmcpOyAgLy8vXG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzQXNTdHJpbmcobm9kZXMsIHRva2Vucykge1xuICBjb25zdCBzdHJpbmcgPSBub2Rlcy5yZWR1Y2UoKHN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IG5vZGVTdHJpbmcgPSBub2RlQXNTdHJpbmcobm9kZSwgdG9rZW5zKTtcblxuICAgIHN0cmluZyA9IChzdHJpbmcgPT09IG51bGwpID9cbiAgICAgIG5vZGVTdHJpbmcgOlxuICAgICAgYCR7c3RyaW5nfSwgJHtub2RlU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBudWxsKTtcblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5vZGVBc1N0cmluZyxcbiAgbm9kZXNBc1N0cmluZyxcbn07XG5cbmZ1bmN0aW9uIHRyaW1TdHJpbmcoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXHMrJC8sIEVNUFRZX1NUUklORyk7ICAvLy9cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b2tlbnNBc1N0cmluZyh0b2tlbnMpIHtcbiAgY29uc3Qgc3RyaW5nID0gdG9rZW5zLnJlZHVjZSgoc3RyaW5nLCB0b2tlbikgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0b2tlbi5nZXRDb250ZW50KCk7XG5cbiAgICBzdHJpbmcgPSBgJHtzdHJpbmd9JHtjb250ZW50fWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIG5vZGVBc1Rva2Vucyhub2RlLCB0b2tlbnMpIHtcbiAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgIHRva2VucyA9IHRlcm1pbmFsTm9kZUFzVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlOyAvLy9cblxuICAgIHRva2VucyA9IG5vblRlcm1pbmFsTm9kZUFzVG9rZW5zKG5vblRlcm1pbmFsTm9kZSwgdG9rZW5zKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmZ1bmN0aW9uIHRlcm1pbmFsTm9kZUFzVG9rZW5zKHRlcm1pbmFsTm9kZSwgdG9rZW5zKSB7XG4gIGNvbnN0IHNpZ25pZmljYW50VG9rZW4gPSB0ZXJtaW5hbE5vZGUuZ2V0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICB0b2tlbiA9IHNpZ25pZmljYW50VG9rZW47IC8vL1xuXG4gIHRva2VucyA9IFsgIC8vL1xuICAgIHRva2VuXG4gIF07XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gbm9uVGVybWluYWxOb2RlQXNUb2tlbnMobm9uVGVybWluYWxOb2RlLCB0b2tlbnMpIHtcbiAgY29uc3QgbGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCA9IG5vblRlcm1pbmFsTm9kZS5nZXRMYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4KHRva2VucyksXG4gICAgICAgIHN0YXJ0ID0gZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgsIC8vL1xuICAgICAgICBlbmQgPSBsYXN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ICsgMTtcblxuICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICByZXR1cm4gdG9rZW5zO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQ29udGV4dCBmcm9tICcuLi9jb250ZXh0JztcblxuaW1wb3J0IHsgbGluZUluZGV4RnJvbU5vZGVBbmRUb2tlbnMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2xpbmVJbmRleFwiO1xuaW1wb3J0IHsgbm9kZUFzU3RyaW5nLCBub2Rlc0FzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ub2RlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVDb250ZXh0IGV4dGVuZHMgQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcblxuICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9XG5cbiAgZ2V0RmlsZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZVBhdGg7XG4gIH1cblxuICBnZXRUb2tlbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICB9XG5cbiAgZ2V0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgZ2V0TGV4ZXIoKSB7XG4gICAgY29uc3QgbGV4ZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIGxleGVyO1xuICB9XG5cbiAgZ2V0UGFyc2VyKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IG51bGw7XG5cbiAgICByZXR1cm4gcGFyc2VyO1xuICB9XG5cbiAgZ2V0VHlwZVByZWZpeCgpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgdHlwZVByZWZpeCA9IGNvbnRleHQuZ2V0VHlwZVByZWZpeCgpO1xuXG4gICAgcmV0dXJuIHR5cGVQcmVmaXg7XG4gIH1cblxuICBtYXRjaEZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgZmlsZVBhdGhNYXRjaGVzID0gKHRoaXMuZmlsZVBhdGggPT09IGZpbGVQYXRoKTtcblxuICAgIHJldHVybiBmaWxlUGF0aE1hdGNoZXM7XG4gIH1cblxuICBmaW5kRmlsZSgpIHtcbiAgICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHRoaXMuZ2V0UmVsZWFzZUNvbnRleHQoKSxcbiAgICAgICAgICBmaWxlID0gcmVsZWFzZUNvbnRleHQuZmluZEZpbGUodGhpcy5maWxlUGF0aCk7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIG5vZGVBc1N0cmluZyhub2RlKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gbm9kZUFzU3RyaW5nKG5vZGUsIHRoaXMudG9rZW5zKTtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBub2Rlc0FzU3RyaW5nKG5vZGVzKSB7XG4gICAgY29uc3Qgc3RyaW5nID0gbm9kZXNBc1N0cmluZyhub2RlcywgdGhpcy50b2tlbnMpO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHByZXBhcmUoKSB7XG4gICAgaWYgKHRoaXMudG9rZW5zICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZmluZEZpbGUoKSxcbiAgICAgICAgICBsZXhlciA9IHRoaXMuZ2V0TGV4ZXIoKSxcbiAgICAgICAgICBwYXJzZXIgPSB0aGlzLmdldFBhcnNlcigpLFxuICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKTtcblxuICAgIHRoaXMudG9rZW5zID0gbGV4ZXIudG9rZW5pc2UoY29udGVudCk7XG5cbiAgICB0aGlzLm5vZGUgPSBwYXJzZXIucGFyc2UodGhpcy50b2tlbnMpO1xuICB9XG5cbiAgaW5pdGlhbGlzZShqc29uKSB7XG4gICAgY29uc3QgeyBjb250ZW50IH0gPSBqc29uLFxuICAgICAgICAgIGxleGVyID0gdGhpcy5nZXRMZXhlcigpLFxuICAgICAgICAgIHBhcnNlciA9IHRoaXMuZ2V0UGFyc2VyKCk7XG5cbiAgICB0aGlzLnRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpO1xuXG4gICAgdGhpcy5ub2RlID0gcGFyc2VyLnBhcnNlKHRoaXMudG9rZW5zKTtcblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuYWRkUHJvY2VkdXJlcygpO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsobm9kZSkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBsaW5lSW5kZXggPSBsaW5lSW5kZXhGcm9tTm9kZUFuZFRva2Vucyhub2RlLCB0aGlzLnRva2VucyksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLmdldFJlbGVhc2VDb250ZXh0KCk7XG5cbiAgICBhd2FpdCByZWxlYXNlQ29udGV4dC5icmVhayhmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSgpIHtcbiAgICBsZXQgdmVyaWZpZXMgPSBmYWxzZTtcblxuICAgIHRoaXMucHJlcGFyZSgpO1xuXG4gICAgaWYgKHRoaXMubm9kZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy53YXJuaW5nKGBVbmFibGUgdG8gdmVyaWZ5IHRoZSAnJHt0aGlzLmZpbGVQYXRofScgZmlsZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBwYXJzZWQuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoYFZlcmlmeWluZyB0aGUgJyR7dGhpcy5maWxlUGF0aH0nIGZpbGUuLi5gKTtcblxuICAgICAgY29uc3QgZmlsZVZlcmlmaWVzID0gYXdhaXQgdGhpcy52ZXJpZnlGaWxlKCk7XG5cbiAgICAgIGlmIChmaWxlVmVyaWZpZXMpIHtcbiAgICAgICAgdmVyaWZpZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2ZXJpZmllcyA/XG4gICAgICAgIHRoaXMuY29tcGxldGUoKSA6XG4gICAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICBpZiAodmVyaWZpZXMpIHtcbiAgICAgICAgdGhpcy5pbmZvKGAuLi52ZXJpZmllZCB0aGUgJyR7dGhpcy5maWxlUGF0aH0nIGZpbGUuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcmlmaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21GaWxlKENsYXNzLCBmaWxlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgIHRva2VucyA9IG51bGwsXG4gICAgICAgICAgbm9kZSA9IG51bGwsXG4gICAgICAgICAgY29udGV4dCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKSwgLy8vXG4gICAgICAgICAgZmlsZUNvbnRleHQgPSBuZXcgQ2xhc3MoY29udGV4dCwgZmlsZVBhdGgsIHRva2Vucywgbm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHJldHVybiBmaWxlQ29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihDbGFzcywganNvbiwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgeyBmaWxlUGF0aCB9ID0ganNvbixcbiAgICAgICAgICB0b2tlbnMgPSBudWxsLFxuICAgICAgICAgIG5vZGUgPSBudWxsLFxuICAgICAgICAgIGNvbnRleHQgPSByZW1haW5pbmdBcmd1bWVudHMucG9wKCksIC8vL1xuICAgICAgICAgIGZpbGVDb250ZXh0ID0gbmV3IENsYXNzKGNvbnRleHQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gZmlsZUNvbnRleHQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jU29tZShhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2luZGV4XTtcblxuICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4LCBhcnJheSk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgsIGFycmF5KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNSZWR1Y2UoYXJyYXksIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlOyAvLy9cblxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICB2YWx1ZSA9IGF3YWl0IGNhbGxiYWNrKHZhbHVlLCBlbGVtZW50LCBpbmRleCwgYXJyYXkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNGb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG5cbiAgICBhd2FpdCBjYWxsYmFjayhlbGVtZW50LCBpbmRleCwgYXJyYXkpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1Jlc29sdmUoYXJyYXlBLCBhcnJheUIsIGNhbGxiYWNrKSB7XG4gIGxldCByZXNvbHZlZDtcblxuICBhcnJheUEgPSBbICAvLy9cbiAgICAuLi5hcnJheUFcbiAgXTtcblxuICBmb3IgKDs7KSB7XG4gICAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aDtcblxuICAgIGlmIChhcnJheUFMZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgYXdhaXQgYXN5bmNGb3JFYWNoKGFycmF5QSwgYXN5bmMgKGVsZW1lbnRBLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFzc2VkID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudEEsIGluZGV4LCBhcnJheUEpO1xuXG4gICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRCID0gZWxlbWVudEE7ICAvLy9cblxuICAgICAgICBhcnJheUIucHVzaChlbGVtZW50Qik7XG5cbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZmlsdGVyKGFycmF5QSwgKGVsZW1lbnRBKSA9PiB7XG4gICAgICBjb25zdCBhcnJheUJJbmNsdWRlc0VsZW1lbnRBID0gYXJyYXlCLmluY2x1ZGVzKGVsZW1lbnRBKTtcblxuICAgICAgaWYgKCFhcnJheUJJbmNsdWRlc0VsZW1lbnRBKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgYXJyYXlBTGVuZ3RoID0gYXJyYXlBLmxlbmd0aDtcblxuICByZXNvbHZlZCA9IChhcnJheUFMZW5ndGggPT09IDApO1xuXG4gIHJldHVybiByZXNvbHZlZDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jRm9yd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIHBhc3NlZCA9IGF3YWl0IGNhbGxiYWNrKGVsZW1lbnQsIGluZGV4LCBhcnJheSk7XG5cbiAgICBpZiAoIXBhc3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNCYWNrd2FyZHNFdmVyeShhcnJheSwgY2FsbGJhY2spIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAobGV0IGluZGV4ID0gbGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgcGFzc2VkID0gYXdhaXQgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgsIGFycmF5KTtcblxuICAgIGlmICghcGFzc2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXN5bmNTb21lLFxuICBhc3luY0V2ZXJ5LFxuICBhc3luY1JlZHVjZSxcbiAgYXN5bmNGb3JFYWNoLFxuICBhc3luY1Jlc29sdmUsXG4gIGFzeW5jRm9yd2FyZHNFdmVyeSxcbiAgYXN5bmNCYWNrd2FyZHNFdmVyeVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IGFzeW5jUmVzb2x2ZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXN5bmNocm9ub3VzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIGZpbHRlciwgY29tcHJlc3MgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RmlsZUNvbnRleHRzKGZpbGVDb250ZXh0cywgdmVyaWZpZWRGaWxlQ29udGV4dHMpIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCBhc3luY1Jlc29sdmUoZmlsZUNvbnRleHRzLCB2ZXJpZmllZEZpbGVDb250ZXh0cywgYXN5bmMgKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZUNvbnRleHRWZXJpZmllcyA9IGF3YWl0IGZpbGVDb250ZXh0LnZlcmlmeSgpO1xuXG4gICAgICAgICAgaWYgKGZpbGVDb250ZXh0VmVyaWZpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGZpbGVDb250ZXh0c1ZlcmlmeSA9IHJlc29sdmVkOyAgLy8vXG5cbiAgcmV0dXJuIGZpbGVDb250ZXh0c1ZlcmlmeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVQcmVmaXhlcyh0eXBlUHJlZml4ZXMsIHJlbGVhc2VDb250ZXh0KSB7XG4gIGxldCB0eXBlUHJlZml4ZXNWZXJpZnkgPSB0cnVlO1xuXG4gIGNvbnN0IHR5cGVQcmVmaXhlc0xlbmd0aCA9IHR5cGVQcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgIGNvbXByZXNzZWRUeXBlUHJlZml4ZXMgPSBbICAvLy9cbiAgICAgICAgICAuLi50eXBlUHJlZml4ZXMsXG4gICAgICAgIF07XG5cbiAgY29tcHJlc3MoY29tcHJlc3NlZFR5cGVQcmVmaXhlcywgKHR5cGVQcmVmaXhBLCB0eXBlUHJlZml4QikgPT4ge1xuICAgIGNvbnN0IHR5cGVQcmVmaXhBTmFtZSA9IHR5cGVQcmVmaXhBLmdldE5hbWUoKSxcbiAgICAgICAgICB0eXBlUHJlZml4Qk5hbWUgPSB0eXBlUHJlZml4Qi5nZXROYW1lKCk7XG5cbiAgICBpZiAodHlwZVByZWZpeEFOYW1lICE9PSB0eXBlUHJlZml4Qk5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgY29tcHJlc3NUeXBlUHJlZml4ZXNMZW5ndGggPSBjb21wcmVzc2VkVHlwZVByZWZpeGVzLmxlbmd0aDtcblxuICBpZiAodHlwZVByZWZpeGVzTGVuZ3RoID4gY29tcHJlc3NUeXBlUHJlZml4ZXNMZW5ndGgpIHtcbiAgICBmaWx0ZXIoY29tcHJlc3NlZFR5cGVQcmVmaXhlcywgKHR5cGVQcmVmaXgpID0+IHtcbiAgICAgIGNvbnN0IHR5cGVQcmVmaXhlc0luY2x1ZGVzVHlwZVByZWZpeCA9IHR5cGVQcmVmaXhlcy5pbmNsdWRlcyh0eXBlUHJlZml4KTtcblxuICAgICAgaWYgKCF0eXBlUHJlZml4ZXNJbmNsdWRlc1R5cGVQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaXJzdFR5cGVQcmVmaXggPSBmaXJzdCh0eXBlUHJlZml4ZXMpLFxuICAgICAgICAgIHR5cGVQcmVmaXggPSBmaXJzdFR5cGVQcmVmaXgsIC8vL1xuICAgICAgICAgIHR5cGVQcmVmaXhTdHJpbmcgPSB0eXBlUHJlZml4LmdldFN0cmluZygpO1xuXG4gICAgcmVsZWFzZUNvbnRleHQuaW5mbyhgVGhlICcke3R5cGVQcmVmaXhTdHJpbmd9JyB0eXBlIHByZWZpeCBpcyBkdXBsaWNhdGVkLmApXG5cbiAgICB0eXBlUHJlZml4ZXNWZXJpZnkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlUHJlZml4ZXNWZXJpZnk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NVU1RPTV9HUkFNTUFSX05BTUUgPSBcIkRlZmF1bHRcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRFUk1fUlVMRV9OQU1FID0gXCJ0ZXJtXCI7XG5leHBvcnQgY29uc3QgU1RBVEVNRU5UX1JVTEVfTkFNRSA9IFwic3RhdGVtZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVEVSTV9SVUxFX05BTUUsXG4gIFNUQVRFTUVOVF9SVUxFX05BTUVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBUWVBFX1ZPQ0FCVUxBUllfTkFNRSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IFNZTUJPTF9WT0NBQlVMQVJZX05BTUUgPSBcInN5bWJvbFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFRZUEVfVk9DQUJVTEFSWV9OQU1FLFxuICBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbmV4cG9ydCBjb25zdCBWRVJUSUNBTF9CQVIgPSBcInxcIjtcbmV4cG9ydCBjb25zdCBWRVJUSUNBTF9TUEFDRSA9IGBcblxuYFxuZXhwb3J0IGNvbnN0IFVOQVNTSUdORURfVFlQRSA9IFwidW5hc3NpZ25lZFwiO1xuZXhwb3J0IGNvbnN0IFNUVUZGX1JVTEVfTkFNRSA9IFwic3R1ZmZcIjtcbmV4cG9ydCBjb25zdCBCQVNFX1RZUEVfU1lNQk9MID0gXCI8PlwiO1xuZXhwb3J0IGNvbnN0IE5PTlNFTlNFX1JVTEVfTkFNRSA9IFwibm9uc2Vuc2VcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBERUZBVUxUX0NVU1RPTV9HUkFNTUFSX05BTUUgfSBmcm9tIFwiLi9ncmFtbWFyTmFtZXNcIjtcbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FLCBTVEFURU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBUWVBFX1ZPQ0FCVUxBUllfTkFNRSwgU1lNQk9MX1ZPQ0FCVUxBUllfTkFNRSB9IGZyb20gXCIuL3ZvY2FidWxhcnlOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21HcmFtbWFyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50ZXJtQk5GID0gdGVybUJORjtcbiAgICB0aGlzLnN0YXRlbWVudEJORiA9IHN0YXRlbWVudEJORjtcbiAgICB0aGlzLnR5cGVWb2NhYnVsYXJ5ID0gdHlwZVZvY2FidWxhcnk7XG4gICAgdGhpcy5zeW1ib2xWb2NhYnVsYXJ5ID0gc3ltYm9sVm9jYWJ1bGFyeTtcbiAgfVxuICBcbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0VGVybUJORigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtQk5GO1xuICB9XG5cbiAgZ2V0U3RhdGVtZW50Qk5GKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlbWVudEJORjtcbiAgfVxuXG4gIGdldFR5cGVWb2NhYnVsYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVWb2NhYnVsYXJ5O1xuICB9XG5cbiAgZ2V0U3ltYm9sVm9jYWJ1bGFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW1ib2xWb2NhYnVsYXJ5O1xuICB9XG5cbiAgZ2V0Qk5GKHJ1bGVOYW1lKSB7XG4gICAgbGV0IGJuZjtcblxuICAgIHN3aXRjaCAocnVsZU5hbWUpIHtcbiAgICAgIGNhc2UgVEVSTV9SVUxFX05BTUU6IGJuZiA9IHRoaXMudGVybUJORjsgYnJlYWs7XG4gICAgICBjYXNlIFNUQVRFTUVOVF9SVUxFX05BTUU6IGJuZiA9IHRoaXMuc3RhdGVtZW50Qk5GOyBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gYm5mO1xuICB9XG5cbiAgZ2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSkge1xuICAgIGxldCB2b2NhYnVsYXJ5O1xuXG4gICAgc3dpdGNoICh2b2NhYnVsYXJ5TmFtZSkge1xuICAgICAgY2FzZSBUWVBFX1ZPQ0FCVUxBUllfTkFNRTogdm9jYWJ1bGFyeSA9IHRoaXMudHlwZVZvY2FidWxhcnk7IGJyZWFrO1xuICAgICAgY2FzZSBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FOiB2b2NhYnVsYXJ5ID0gdGhpcy5zeW1ib2xWb2NhYnVsYXJ5OyBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdm9jYWJ1bGFyeTtcbiAgfVxuXG4gIGdldFZvY2FidWxhcmllcygpIHtcbiAgICBjb25zdCB2b2NhYnVsYXJpZXMgPSBbXG4gICAgICB0aGlzLnR5cGVWb2NhYnVsYXJ5LFxuICAgICAgdGhpcy5zeW1ib2xWb2NhYnVsYXJ5XG4gICAgXTtcblxuICAgIHJldHVybiB2b2NhYnVsYXJpZXM7XG4gIH1cblxuICBpc0RlZmF1bHRDdXN0b21HcmFtbWFyKCkge1xuICAgIGNvbnN0IGRlZmF1bHRDdXN0b21HcmFtbWFyID0gKHRoaXMubmFtZSA9PT0gREVGQVVMVF9DVVNUT01fR1JBTU1BUl9OQU1FKTtcblxuICAgIHJldHVybiBkZWZhdWx0Q3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBzZXRCTkYocnVsZU5hbWUsIGJuZikge1xuICAgIHN3aXRjaCAocnVsZU5hbWUpIHtcbiAgICAgIGNhc2UgVEVSTV9SVUxFX05BTUU6XG4gICAgICAgIHRoaXMudGVybUJORiA9IGJuZjtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTVEFURU1FTlRfUlVMRV9OQU1FOlxuICAgICAgICB0aGlzLnN0YXRlbWVudEJORiA9IGJuZjtcblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lLCB2b2NhYnVsYXJ5KSB7XG4gICAgc3dpdGNoICh2b2NhYnVsYXJ5TmFtZSkge1xuICAgICAgY2FzZSBUWVBFX1ZPQ0FCVUxBUllfTkFNRTpcbiAgICAgICAgdGhpcy50eXBlVm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1lNQk9MX1ZPQ0FCVUxBUllfTkFNRTpcbiAgICAgICAgdGhpcy5zeW1ib2xWb2NhYnVsYXJ5ID0gdm9jYWJ1bGFyeTtcblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXNldEJORihydWxlTmFtZSkge1xuICAgIGNvbnN0IGJuZiA9IEVNUFRZX1NUUklORztcblxuICAgIHRoaXMuc2V0Qk5GKHJ1bGVOYW1lLCBibmYpO1xuICB9XG5cbiAgcmVzZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlOYW1lKSB7XG4gICAgY29uc3Qgdm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORztcblxuICAgIHRoaXMuc2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSwgdm9jYWJ1bGFyeSk7XG4gIH1cblxuICB1cGRhdGUocnVsZU5hbWUsIGJuZiwgdm9jYWJ1bGFyeU5hbWUsIHZvY2FidWxhcnkpIHtcbiAgICB0aGlzLnNldEJORihydWxlTmFtZSwgYm5mKTtcblxuICAgIHRoaXMuc2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSwgdm9jYWJ1bGFyeSk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgICB0ZXJtQk5GID0gdGhpcy50ZXJtQk5GLFxuICAgICAgICAgIHN0YXRlbWVudEJORiA9IHRoaXMuc3RhdGVtZW50Qk5GLFxuICAgICAgICAgIHR5cGVWb2NhYnVsYXJ5ID0gdGhpcy50eXBlVm9jYWJ1bGFyeSxcbiAgICAgICAgICBzeW1ib2xWb2NhYnVsYXJ5ID0gdGhpcy5zeW1ib2xWb2NhYnVsYXJ5LFxuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVybUJORixcbiAgICAgICAgICAgIHN0YXRlbWVudEJORixcbiAgICAgICAgICAgIHR5cGVWb2NhYnVsYXJ5LFxuICAgICAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeVxuICAgICAgICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IHsgbmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSB9ID0ganNvbixcbiAgICAgICAgICBjdXN0b21HcmFtbWFyID0gbmV3IEN1c3RvbUdyYW1tYXIobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSk7XG5cbiAgICByZXR1cm4gY3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgY29uc3QgdGVybUJORiA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBzdGF0ZW1lbnRCTkYgPSBFTVBUWV9TVFJJTkcsXG4gICAgICAgICAgdHlwZVZvY2FidWxhcnkgPSBFTVBUWV9TVFJJTkcsXG4gICAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORyxcbiAgICAgICAgICBjdXN0b21HcmFtbWFyID0gbmV3IEN1c3RvbUdyYW1tYXIobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSk7XG5cbiAgICByZXR1cm4gY3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZVRlcm1CTkZTdGF0ZW1lbnRCTkZUeXBlVm9jYWJ1bGFyeUFuZFN5bWJvbFZvY2FidWxhcnkobmFtZSwgdGVybUJORiwgc3RhdGVtZW50Qk5GLCB0eXBlVm9jYWJ1bGFyeSwgc3ltYm9sVm9jYWJ1bGFyeSkge1xuICAgIGNvbnN0IGN1c3RvbUdyYW1tYXIgPSBuZXcgQ3VzdG9tR3JhbW1hcihuYW1lLCB0ZXJtQk5GLCBzdGF0ZW1lbnRCTkYsIHR5cGVWb2NhYnVsYXJ5LCBzeW1ib2xWb2NhYnVsYXJ5KTtcblxuICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBDdXN0b21HcmFtbWFyIGZyb20gXCIuLi9jdXN0b21HcmFtbWFyXCI7XG5cbmltcG9ydCB7IERFRkFVTFRfQ1VTVE9NX0dSQU1NQVJfTkFNRSB9IGZyb20gXCIuLi9ncmFtbWFyTmFtZXNcIjtcblxuZXhwb3J0IGNvbnN0IHRlcm1CTkYgPSBgdGVybSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgXCIoXCIgYXJndW1lbnQgXCIpXCJcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdmFyaWFibGUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtgO1xuXG5leHBvcnQgY29uc3Qgc3RhdGVtZW50Qk5GID0gYHN0YXRlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIG1ldGFBcmd1bWVudCBcIilcIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlcXVhbGl0eVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBqdWRnZW1lbnRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdHlwZUFzc2VydGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBkZWZpbmVkQXNzZXJ0aW9uICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgY29udGFpbmVkQXNzZXJ0aW9uICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgc2F0aXNmaWVzQXNzZXJ0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHN1YnByb29mQXNzZXJ0aW9uICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHByb3BlcnR5QXNzZXJ0aW9uICBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbWV0YXZhcmlhYmxlICggZnJhbWVTdWJzdGl0dXRpb24gfCB0ZXJtU3Vic3RpdHV0aW9uICk/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuZXF1YWxpdHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSBcIj1cIiB0ZXJtIDtcblxudHlwZUFzc2VydGlvbiAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSBcIjpcIiB0eXBlIDtcblxuZGVmaW5lZEFzc2VydGlvbiAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBmcmFtZSB8IHRlcm0gKSBcImlzXCIgKCBcImRlZmluZWRcIiB8IFwidW5kZWZpbmVkXCIgKTtcblxuY29udGFpbmVkQXNzZXJ0aW9uICAgICAgICAgICAgICAgICAgIDo6PSAgKCBmcmFtZSB8IHRlcm0gKSBcImlzXCIgKCBcInByZXNlbnRcIiB8IFwibWlzc2luZ1wiICkgXCJpblwiIHN0YXRlbWVudCA7XG5cbnNhdGlzZmllc0Fzc2VydGlvbiAgICAgICAgICAgICAgICAgICA6Oj0gIHNpZ25hdHVyZSBcInNhdGlzZmllc1wiIG1ldGF2YXJpYWJsZSA7ICBcblxuc3VicHJvb2ZBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgc3RhdGVtZW50ICggXCIsXCIgc3RhdGVtZW50ICkqIFwiXVwiIFwiLi4uXCIgc3RhdGVtZW50IDtcblxucHJvcGVydHlBc3NlcnRpb24gICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSBcImlzXCIgKCBcImFcIiB8IFwiYW5cIiApIHByb3BlcnR5UmVsYXRpb24gO1xuXG5wcm9wZXJ0eVJlbGF0aW9uICAgICAgICAgICAgICAgICAgICAgOjo9ICBwcm9wZXJ0eSBcIm9mXCIgdGVybSA7XG5cbmp1ZGdlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGZyYW1lIFwifFwiPE5PX1dISVRFU1BBQ0U+XCItXCIgYXNzdW1wdGlvbiA7XG5cbmZyYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiICggKCBhc3N1bXB0aW9uICggXCIsXCIgYXNzdW1wdGlvbiApKiApIHwgbWV0YXZhcmlhYmxlICkgXCJdXCIgO1xuIFxuYXNzdW1wdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXZhcmlhYmxlIFwiOjpcIiBzdGF0ZW1lbnQgO1xuXG50ZXJtU3Vic3RpdHV0aW9uICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIiB0ZXJtIFwiZm9yXCIgdGVybSBcIl1cIjtcblxuZnJhbWVTdWJzdGl0dXRpb24gICAgICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgZnJhbWUgXCJmb3JcIiBmcmFtZSBcIl1cIjtcblxuc3RhdGVtZW50U3Vic3RpdHV0aW9uICAgICAgICAgICAgICAgIDo6PSAgXCJbXCIgc3RhdGVtZW50IFwiZm9yXCIgc3RhdGVtZW50IFwiXVwiO1xuXG5yZWZlcmVuY2VTdWJzdGl0dXRpb24gICAgICAgICAgICAgICAgOjo9ICBcIltcIiByZWZlcmVuY2UgXCJmb3JcIiByZWZlcmVuY2UgXCJdXCI7YDtcblxuZXhwb3J0IGNvbnN0IHR5cGVWb2NhYnVsYXJ5ID0gXCJcIjtcblxuZXhwb3J0IGNvbnN0IHN5bWJvbFZvY2FidWxhcnkgPSBcIlwiO1xuXG5jb25zdCBuYW1lID0gREVGQVVMVF9DVVNUT01fR1JBTU1BUl9OQU1FLFxuICAgICAganNvbiA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdGVybUJORixcbiAgICAgICAgc3RhdGVtZW50Qk5GLFxuICAgICAgICB0eXBlVm9jYWJ1bGFyeSxcbiAgICAgICAgc3ltYm9sVm9jYWJ1bGFyeVxuICAgICAgfTtcblxuY29uc3QgZGVmYXVsdEN1c3RvbUdyYW1tYXIgPSBDdXN0b21HcmFtbWFyLmZyb21KU09OKGpzb24pO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0Q3VzdG9tR3JhbW1hcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGFtcGxlTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhFeGFtcGxlTGV4ZXIsIGVudHJpZXMpOyB9XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jbGFzcyBBIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShBLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgQiBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQiwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIEMgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEMsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBEIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShELCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgRSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIEYgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEYsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jbGFzcyBTIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cblxuY2xhc3MgVCBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVCwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG5cbmNsYXNzIFYgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFYsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuXG5jb25zdCBOb25UZXJtaW5hbE5vZGVNYXAgPSB7XG4gIEEsXG4gIEIsXG4gIEMsXG4gIEQsXG4gIEUsXG4gIEYsXG4gIFMsXG4gIFQsXG4gIFZcbn1cblxuZXhwb3J0IGRlZmF1bHQgTm9uVGVybWluYWxOb2RlTWFwO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgTm9uVGVybWluYWxOb2RlTWFwIGZyb20gXCIuL25vblRlcm1pbmFsTm9kZU1hcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGFtcGxlUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIE5vblRlcm1pbmFsTm9kZU1hcCA9IE5vblRlcm1pbmFsTm9kZU1hcDtcbn0iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGNoYXJhY3RlcnMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgQ09NTUFfQ0hBUkFDVEVSIH0gPSBjaGFyYWN0ZXJzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDeWNsZSB7XG4gIGNvbnN0cnVjdG9yKGVkZ2VzKSB7XG4gICAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB9XG5cbiAgZ2V0RWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXM7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5lZGdlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG5cbiAgZ2V0RWRnZShpbmRleCkge1xuICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmVkZ2VzW2luZGV4XTtcblxuICAgIHJldHVybiBlZGdlO1xuICB9XG5cbiAgZ2V0VmVydGV4ZXMoKSB7XG4gICAgY29uc3QgdmVydGV4ZXMgPSB0aGlzLm1hcEVkZ2UoKGVkZ2UpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IGVkZ2UuZ2V0U291cmNlVmVydGV4KCksXG4gICAgICAgICAgICB2ZXJ0ZXggPSBzb3VyY2VWZXJ0ZXg7ICAvLy9cblxuICAgICAgcmV0dXJuIHZlcnRleDtcbiAgICB9KTtcblxuICAgIHJldHVybiB2ZXJ0ZXhlcztcbiAgfVxuXG4gIG1hcEVkZ2UoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuZWRnZXMubWFwKGNhbGxiYWNrKTsgfVxuXG4gIGV2ZXJ5RWRnZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5lZGdlcy5ldmVyeShjYWxsYmFjayk7IH1cblxuICBmb3JFYWNoRWRnZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5lZGdlcy5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGlzRXF1YWxUbyhjeWNsZSkge1xuICAgIGxldCBlcXVhbFRvID0gZmFsc2U7XG5cbiAgICBjb25zdCBjeWNsZUEgPSB0aGlzLCAgLy8vXG4gICAgICAgICAgY3ljbGVCID0gY3ljbGUsICAvLy9cbiAgICAgICAgICBjeWNsZUFMZW5ndGggPSBjeWNsZUEuZ2V0TGVuZ3RoKCksXG4gICAgICAgICAgY3ljbGVCTGVuZ3RoID0gY3ljbGVCLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKGN5Y2xlQUxlbmd0aCA9PT0gY3ljbGVCTGVuZ3RoKSB7XG4gICAgICBlcXVhbFRvID0gY3ljbGVBLmV2ZXJ5RWRnZSgoZWRnZUEsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGVkZ2VCID0gY3ljbGVCLmdldEVkZ2UoaW5kZXgpLFxuICAgICAgICAgICAgICBtYXRjaGVzID0gZWRnZUEubWF0Y2goZWRnZUIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBlcXVhbFRvO1xuICB9XG5cbiAgcGVybXV0ZWQoKSB7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLmVkZ2VzLnNsaWNlKCksIC8vL1xuICAgICAgICAgIGVkZ2UgPSBlZGdlcy5wb3AoKTtcblxuICAgIGVkZ2VzLnVuc2hpZnQoZWRnZSk7XG5cbiAgICBjb25zdCBjeWNsZSA9IG5ldyBDeWNsZShlZGdlcyk7XG5cbiAgICByZXR1cm4gY3ljbGU7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICBjb25zdCB2ZXJ0ZXhlcyA9IHRoaXMuZ2V0VmVydGV4ZXMoKSxcbiAgICAgICAgICBzdHJpbmcgPSB2ZXJ0ZXhlcy5qb2luKENPTU1BX0NIQVJBQ1RFUik7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgc3RhdGljIGZyb21FZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtcbiAgICAgICAgICAgIGVkZ2VcbiAgICAgICAgICBdLFxuICAgICAgICAgIGN5Y2xlID0gbmV3IEN5Y2xlKGVkZ2VzKTtcblxuICAgIHJldHVybiBjeWNsZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRWRnZXMoZWRnZXMpIHtcbiAgICBjb25zdCBjeWNsZSA9IG5ldyBDeWNsZShlZGdlcyk7XG5cbiAgICByZXR1cm4gY3ljbGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBDeWNsZSBmcm9tIFwiLi9jeWNsZVwiO1xuXG5jb25zdCB7IGxhc3QsIGZpbmQsIGNvbXByZXNzIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0ZWRHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKGVkZ2VzLCBzdGFydFZlcnRleCkge1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgICB0aGlzLnN0YXJ0VmVydGV4ID0gc3RhcnRWZXJ0ZXg7XG4gIH1cblxuICBnZXRFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcztcbiAgfVxuXG4gIGdldFN0YXJ0VmVydGV4KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0VmVydGV4O1xuICB9XG5cbiAgYWRkRWRnZShlZGdlKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGVkZ2VzTWF0Y2hFZGdlKHRoaXMuZWRnZXMsIGVkZ2UpO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aGlzLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuICB9XG5cbiAgYWRkRWRnZXMoZWRnZXMpIHtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICB0aGlzLmFkZEVkZ2UoZWRnZSk7XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZWRnZXMuaW5kZXhPZihlZGdlKSxcbiAgICAgICAgICBzdGFydCA9IGluZGV4LCAgLy8vXG4gICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgdGhpcy5lZGdlcy5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KTtcbiAgfVxuXG4gIGRlcHRoRmlyc3RTZWFyY2godmVydGV4LCB2ZXJ0ZXhlcywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcmV2aW91c1ZlcnRleGVzID0gdmVydGV4ZXMsICAvLy9cbiAgICAgICAgICBzdWNjZXNzb3JWZXJ0ZXhlcyA9IHRoaXMuZmluZFN1Y2Nlc3NvclZlcnRleGVzKHZlcnRleCk7XG5cbiAgICBzdWNjZXNzb3JWZXJ0ZXhlcy5mb3JFYWNoKChzdWNjZXNzb3JWZXJ0ZXgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVmVydGV4ZXNJbmNsdWRlc1N1Y2Nlc3NvclZlcnRleCA9IHByZXZpb3VzVmVydGV4ZXMuaW5jbHVkZXMoc3VjY2Vzc29yVmVydGV4KSxcbiAgICAgICAgICAgIHZlcnRleGVzID0gW1xuICAgICAgICAgICAgICAuLi5wcmV2aW91c1ZlcnRleGVzLFxuICAgICAgICAgICAgICBzdWNjZXNzb3JWZXJ0ZXhcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB2ZXJ0ZXggPSBzdWNjZXNzb3JWZXJ0ZXg7ICAvLy9cblxuICAgICAgaWYgKHByZXZpb3VzVmVydGV4ZXNJbmNsdWRlc1N1Y2Nlc3NvclZlcnRleCkge1xuICAgICAgICBjYWxsYmFjayh2ZXJ0ZXhlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlcHRoRmlyc3RTZWFyY2godmVydGV4LCB2ZXJ0ZXhlcywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZmluZEN5Y2xlcygpIHtcbiAgICBjb25zdCB0cml2aWFsQ3ljbGVzID0gdGhpcy5maW5kVHJpdmlhbEN5Y2xlcygpLFxuICAgICAgICAgIG5vblRyaXZpYWxDeWNsZXMgPSB0aGlzLmZpbmROb25Ucml2aWFsQ3ljbGVzKCksXG4gICAgICAgICAgY3ljbGVzID0gW1xuICAgICAgICAgICAgLi4udHJpdmlhbEN5Y2xlcyxcbiAgICAgICAgICAgIC4uLm5vblRyaXZpYWxDeWNsZXNcbiAgICAgICAgICBdO1xuXG4gICAgY29tcHJlc3MoY3ljbGVzLCAoY3ljbGVBLCBjeWNsZUIpID0+IHtcbiAgICAgIGNvbnN0IGN5Y2xlc0NvaW5jaWRlbnQgPSBhcmVDeWNsZXNDb2luY2lkZW50KGN5Y2xlQSwgY3ljbGVCKTtcblxuICAgICAgaWYgKCFjeWNsZXNDb2luY2lkZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGN5Y2xlcztcbiAgfVxuXG4gIGZpbmRUcml2aWFsQ3ljbGVzKCkge1xuICAgIGNvbnN0IHRyaXZpYWxseUN5Y2xpY0VkZ2VzID0gdGhpcy5maW5kVHJpdmlhbGx5Q3ljbGljRWRnZXMoKSxcbiAgICAgICAgICB0cml2aWFsQ3ljbGVzID0gdHJpdmlhbGx5Q3ljbGljRWRnZXMubWFwKCh0cml2aWFsbHlDeWNsaWNFZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGdlID0gdHJpdmlhbGx5Q3ljbGljRWRnZSwgIC8vL1xuICAgICAgICAgICAgICAgICAgY3ljbGUgPSBDeWNsZS5mcm9tRWRnZShlZGdlKSxcbiAgICAgICAgICAgICAgICAgIHRyaXZpYWxDeWNsZSA9IGN5Y2xlOyAvLy9cblxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxDeWNsZTtcbiAgICAgICAgICB9KTtcblxuICAgIHJldHVybiB0cml2aWFsQ3ljbGVzO1xuICB9XG5cbiAgZmluZE5vblRyaXZpYWxDeWNsZXMoKSB7XG4gICAgY29uc3Qgbm9uVHJpdmlhbEN5Y2xlcyA9IFtdLFxuICAgICAgICAgIGRpcmVjdGVkR3JhcGggPSB0aGlzLCAvLy9cbiAgICAgICAgICB2ZXJ0ZXggPSB0aGlzLnN0YXJ0VmVydGV4LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhlcyA9IFtcbiAgICAgICAgICAgIHZlcnRleFxuICAgICAgICAgIF07XG5cbiAgICB0aGlzLmRlcHRoRmlyc3RTZWFyY2godmVydGV4LCB2ZXJ0ZXhlcywgKHZlcnRleGVzKSA9PiB7XG4gICAgICBjb25zdCBub25Ucml2aWFsQ3ljbGUgPSBub25Ucml2aWFsQ3ljbGVGcm9tVmVydGV4ZXModmVydGV4ZXMsIGRpcmVjdGVkR3JhcGgpO1xuXG4gICAgICBub25Ucml2aWFsQ3ljbGVzLnB1c2gobm9uVHJpdmlhbEN5Y2xlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBub25Ucml2aWFsQ3ljbGVzO1xuICB9XG5cbiAgZmluZFN1Y2Nlc3NvckVkZ2VzKHZlcnRleCkge1xuICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IHZlcnRleCwgIC8vL1xuICAgICAgICAgIGVkZ2VzID0gdGhpcy5maW5kRWRnZXNCeVNvdXJjZVZlcnRleChzb3VyY2VWZXJ0ZXgpLFxuICAgICAgICAgIHN1Y2Nlc3NvckVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRWZXJ0ZXggPSBlZGdlLmdldFRhcmdldFZlcnRleCgpO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0VmVydGV4ICE9PSBzb3VyY2VWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gc3VjY2Vzc29yRWRnZXM7XG4gIH1cblxuICBmaW5kU3VjY2Vzc29yVmVydGV4ZXModmVydGV4KSB7XG4gICAgY29uc3Qgc3VjY2Vzc29yRWRnZXMgPSB0aGlzLmZpbmRTdWNjZXNzb3JFZGdlcyh2ZXJ0ZXgpLFxuICAgICAgICAgIHN1Y2Nlc3NvclZlcnRleGVzID0gc3VjY2Vzc29yRWRnZXMubWFwKChzdWNjZXNzb3JFZGdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzb3JFZGdlVGFyZ2V0VmVydGV4ID0gc3VjY2Vzc29yRWRnZS5nZXRUYXJnZXRWZXJ0ZXgoKSxcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NvclZlcnRleCA9IHN1Y2Nlc3NvckVkZ2VUYXJnZXRWZXJ0ZXg7ICAvLy9cblxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3NvclZlcnRleDtcbiAgICAgICAgICB9KTtcblxuICAgIHJldHVybiBzdWNjZXNzb3JWZXJ0ZXhlcztcbiAgfVxuXG4gIGZpbmRFZGdlc0J5U291cmNlVmVydGV4KHNvdXJjZVZlcnRleCkge1xuICAgIGNvbnN0IGVkZ2VzID0gZmluZCh0aGlzLmVkZ2VzLCAoZWRnZSkgPT4geyAvLy9cbiAgICAgIGNvbnN0IGVkZ2VNYXRjaGVzU291cmNlVmVydGV4ID0gZWRnZS5tYXRjaFNvdXJjZVZlcnRleChzb3VyY2VWZXJ0ZXgpO1xuXG4gICAgICBpZiAoZWRnZU1hdGNoZXNTb3VyY2VWZXJ0ZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWRnZXM7XG4gIH1cblxuICBmaW5kVHJpdmlhbGx5Q3ljbGljRWRnZXMoKSB7XG4gICAgY29uc3QgdHJpdmlhbGx5Q3ljbGljRWRnZXMgPSBmaW5kKHRoaXMuZWRnZXMsIChlZGdlKSA9PiB7XG4gICAgICBjb25zdCBlZGdlVHJpdmlhbGx5Q3ljbGljID0gZWRnZS5pc1RyaXZpYWxseUN5Y2xpYygpO1xuXG4gICAgICBpZiAoZWRnZVRyaXZpYWxseUN5Y2xpYykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cml2aWFsbHlDeWNsaWNFZGdlcztcbiAgfVxuXG4gIGZpbmRFZGdlQnlTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgoc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBlZGdlID0gdGhpcy5lZGdlcy5maW5kKChlZGdlKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZWRnZS5tYXRjaFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCk7XG5cbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRWRnZXNBbmRTdGFydFZlcnRleChlZGdlcywgc3RhcnRWZXJ0ZXgpIHtcbiAgICBjb25zdCBkaXJlY3RlZEdyYXBoID0gbmV3IERpcmVjdGVkR3JhcGgoZWRnZXMsIHN0YXJ0VmVydGV4KTtcblxuICAgIHJldHVybiBkaXJlY3RlZEdyYXBoO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGdlc01hdGNoRWRnZShlZGdlcywgZWRnZSkge1xuICBjb25zdCBlZGdlQSA9IGVkZ2UsIC8vL1xuICAgICAgICBtYXRjaGVzID0gZWRnZXMuc29tZSgoZWRnZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVkZ2VCID0gZWRnZSwgLy8vXG4gICAgICAgICAgICAgICAgZWRnZUFNYXRjaGVzRWRnZUIgPSBlZGdlQS5tYXRjaChlZGdlQik7XG5cbiAgICAgICAgICBpZiAoZWRnZUFNYXRjaGVzRWRnZUIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmZ1bmN0aW9uIG5vblRyaXZpYWxDeWNsZUZyb21WZXJ0ZXhlcyh2ZXJ0ZXhlcywgZGlyZWN0ZWRHcmFwaCkge1xuICBjb25zdCBsYXN0VmVydGV4ID0gbGFzdCh2ZXJ0ZXhlcyksXG4gICAgICAgIGluZGV4ID0gdmVydGV4ZXMuaW5kZXhPZihsYXN0VmVydGV4KSxcbiAgICAgICAgc3RhcnQgPSBpbmRleDsgIC8vL1xuXG4gIHZlcnRleGVzID0gdmVydGV4ZXMuc2xpY2Uoc3RhcnQpOyAvLy9cblxuICB2ZXJ0ZXhlcy5wb3AoKTtcblxuICBjb25zdCBsZW5ndGggPSB2ZXJ0ZXhlcy5sZW5ndGgsXG4gICAgICAgIGVkZ2VzID0gdmVydGV4ZXMubWFwKCh2ZXJ0ZXgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBsZW5ndGgsXG4gICAgICAgICAgICAgICAgbmV4dFZlcnRleCA9IHZlcnRleGVzW25leHRJbmRleF0sXG4gICAgICAgICAgICAgICAgc291cmNlVmVydGV4ID0gdmVydGV4LCAgLy8vXG4gICAgICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gbmV4dFZlcnRleCwgLy8vXG4gICAgICAgICAgICAgICAgZWRnZSA9IGRpcmVjdGVkR3JhcGguZmluZEVkZ2VCeVNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCk7XG5cbiAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgfSksXG4gICAgICAgIGN5Y2xlID0gQ3ljbGUuZnJvbUVkZ2VzKGVkZ2VzKTtcblxuICByZXR1cm4gY3ljbGU7XG59XG5cbmZ1bmN0aW9uIHNvbWVDeWNsZVBlcm11dGF0aW9uKGN5Y2xlLCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG5cbiAgY29uc3QgbGVuZ3RoID0gY3ljbGUuZ2V0TGVuZ3RoKCk7XG5cbiAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIHJlc3VsdCA9IGNhbGxiYWNrKGN5Y2xlKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGN5Y2xlID0gY3ljbGUucGVybXV0ZWQoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFyZUN5Y2xlc0NvaW5jaWRlbnQoY3ljbGVBLCBjeWNsZUIpIHtcbiAgbGV0IGN5Y2xlc0NvaW5jaWRlbnQgPSBmYWxzZTtcblxuICBjb25zdCBjeWNsZUFMZW5ndGggPSBjeWNsZUEuZ2V0TGVuZ3RoKCksXG4gICAgICAgIGN5Y2xlQkxlbmd0aCA9IGN5Y2xlQi5nZXRMZW5ndGgoKTtcblxuICBpZiAoY3ljbGVBTGVuZ3RoID09PSBjeWNsZUJMZW5ndGgpIHtcbiAgICBjeWNsZXNDb2luY2lkZW50ID0gc29tZUN5Y2xlUGVybXV0YXRpb24oY3ljbGVBLCAoY3ljbGVBKSA9PiB7XG4gICAgICBjb25zdCBjeWNsZUFFcXVhbFRvID0gY3ljbGVBLmlzRXF1YWxUbyhjeWNsZUIpO1xuXG4gICAgICBpZiAoY3ljbGVBRXF1YWxUbykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjeWNsZXNDb2luY2lkZW50O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVkdWNlZE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfU1RSSU5HID0gXCJcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IGAke3J1bGVOYW1lfV9gO1xuXG4gIHJldHVybiByZWR1Y2VkUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZUZyb21SZWR1Y2VkUnVsZU5hbWUocmVkdWNlZFJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lLnJlcGxhY2UoL18kL2csIEVNUFRZX1NUUklORyk7XG5cbiAgcmV0dXJuIHJ1bGVOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGAke3J1bGVOYW1lfX5gO1xuXG4gIHJldHVybiBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZUZyb21JbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSkge1xuICBjb25zdCBydWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLnJlcGxhY2UoL34uKyQvZywgRU1QVFlfU1RSSU5HKTtcblxuICByZXR1cm4gcnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVGcm9tSW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUoaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUpIHtcbiAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUucmVwbGFjZSgvXltefl0rfi9nLCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gYCR7cnVsZU5hbWV9fiR7bGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lfWA7XG5cbiAgcmV0dXJuIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBwdXNoLCBjb21wcmVzcyB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21SdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3ljbGVJcnJlZHVjaWJsZShjeWNsZSwgcnVsZU1hcCkge1xuICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpLFxuICAgICAgICByZWR1Y2VkUnVsZXMgPSBydWxlTmFtZXMucmVkdWNlKChyZWR1Y2VkUnVsZXMsIHJ1bGVOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICAgICAgICByZWR1Y2VkUnVsZSA9IHJ1bGVNYXBbcmVkdWNlZFJ1bGVOYW1lXSB8fCBudWxsO1xuXG4gICAgICAgICAgaWYgKHJlZHVjZWRSdWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZWR1Y2VkUnVsZXMucHVzaChyZWR1Y2VkUnVsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlZHVjZWRSdWxlcztcbiAgICAgICAgfSwgW10pLFxuICAgICAgICByZWR1Y2VkUnVsZXNMZW5ndGggPSByZWR1Y2VkUnVsZXMubGVuZ3RoLFxuICAgICAgICBjeWNsZUlycmVkdWNpYmxlID0gKHJlZHVjZWRSdWxlc0xlbmd0aCA9PT0gMCk7IC8vL1xuXG4gIHJldHVybiBjeWNsZUlycmVkdWNpYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlLCBydWxlTmFtZXMgPSBbXSkge1xuICBjb25zdCBjeWNsZVZlcnRleGVzID0gY3ljbGUuZ2V0VmVydGV4ZXMoKSxcbiAgICAgICAgY3ljbGVSdWxlTmFtZXMgPSBjeWNsZVZlcnRleGVzOyAvLy9cblxuICBwdXNoKHJ1bGVOYW1lcywgY3ljbGVSdWxlTmFtZXMpO1xuXG4gIHJldHVybiBydWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydWxlTmFtZXNGcm9tQ3ljbGVzKGN5Y2xlcywgcnVsZU5hbWVzID0gW10pIHtcbiAgY3ljbGVzLmZvckVhY2goKGN5Y2xlKSA9PiB7XG4gICAgcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlLCBydWxlTmFtZXMpO1xuICB9KTtcblxuICBjb21wcmVzcyhydWxlTmFtZXMsIChydWxlTmFtZUEsIHJ1bGVOYW1lQikgPT4ge1xuICAgIGlmIChydWxlTmFtZUEgIT09IHJ1bGVOYW1lQikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcnVsZU5hbWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVsZUN5Y2xlc0Zyb21SdWxlTmFtZUFuZEN5Y2xlcyhydWxlTmFtZSwgY3ljbGVzKSB7XG4gIGNvbnN0IHJ1bGVDeWNsZXMgPSBjeWNsZXMucmVkdWNlKChydWxlQ3ljbGVzLCBjeWNsZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSksXG4gICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZVJ1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgIGlmIChydWxlTmFtZXNJbmNsdWRlUnVsZU5hbWUpIHtcbiAgICAgIGNvbnN0IHJ1bGVDeWNsZSA9IGN5Y2xlOyAgLy8vXG5cbiAgICAgIHJ1bGVDeWNsZXMucHVzaChydWxlQ3ljbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlQ3ljbGVzO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHJ1bGVDeWNsZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBzcGVjaWFsU3ltYm9scyB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuY29uc3QgeyBlcHNpbG9uLCBub1doaXRlc3BhY2UsIHN0YXJ0T2ZDb250ZW50IH0gPSBzcGVjaWFsU3ltYm9scyxcbiAgICAgIHsgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgICAgICAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gICAgICAgIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gICAgICAgIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bGVOb25Db25zdW1pbmcocnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzID0gW10pIHtcbiAgbGV0IHJ1bGVOb25Db25zdW1pbmcgPSBmYWxzZTtcblxuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICBpZiAoIXJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICBydWxlTmFtZXMgPSBbIC8vL1xuICAgICAgLi4ucnVsZU5hbWVzLFxuICAgICAgcnVsZU5hbWVcbiAgICBdO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCksXG4gICAgICAgICAgZGVmaW5pdGlvbnNOb25Db25zdW1pbmcgPSBhcmVEZWZpbml0aW9uc05vbkNvbnN1bWluZyhkZWZpbml0aW9ucywgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIHJ1bGVOb25Db25zdW1pbmcgPSBkZWZpbml0aW9uc05vbkNvbnN1bWluZzsgLy8vXG4gIH1cblxuICByZXR1cm4gcnVsZU5vbkNvbnN1bWluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFydE5vbkNvbnN1bWluZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMgPSBbXSkge1xuICBsZXQgcGFydE5vbkNvbnN1bWluZztcblxuICBjb25zdCBwYXJUZXJtaW5hbFBhcnQgPSBwYXJ0LmlzVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhclRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmcgPSBpc1Rlcm1pbmFsUGFydE5vbkNvbnN1bWluZyh0ZXJtaW5hbFBhcnQpO1xuXG4gICAgcGFydE5vbkNvbnN1bWluZyA9IHRlcm1pbmFsUGFydE5vbkNvbnN1bWluZzsgLy8vXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICBub25UZXJtaW5hbFBhcnROb25Db25zdW1pbmcgPSBpc05vblRlcm1pbmFsUGFydE5vbkNvbnN1bWluZyhub25UZXJtaW5hbE5QYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgcGFydE5vbkNvbnN1bWluZyA9IG5vblRlcm1pbmFsUGFydE5vbkNvbnN1bWluZzsgLy8vXG4gIH1cblxuICByZXR1cm4gcGFydE5vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gYXJlRGVmaW5pdGlvbnNOb25Db25zdW1pbmcoZGVmaW5pdGlvbnMsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBkZWZpbml0aW9uc05vbkNvbnN1bWluZyA9IGRlZmluaXRpb25zLnNvbWUoKGRlZmluaXRpb24pID0+IHtcbiAgICBjb25zdCBkZWZpbml0aW9uTm9uQ29uc3VtaW5nID0gaXNEZWZpbml0aW9uTm9uQ29uc3VtaW5nKGRlZmluaXRpb24sIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbk5vbkNvbnN1bWluZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvbnNOb25Db25zdW1pbmc7XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5pdGlvbk5vbkNvbnN1bWluZyhkZWZpbml0aW9uLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIHBhcnRzTm9uQ29uc3VtaW5nID0gYXJlUGFydHNOb25Db25zdW1pbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcyksXG4gICAgICAgIGRlZmluaXRpb25Ob25Db25zdW1pbmcgPSBwYXJ0c05vbkNvbnN1bWluZzsgLy8vXG5cbiAgcmV0dXJuIGRlZmluaXRpb25Ob25Db25zdW1pbmc7XG59XG5cbmZ1bmN0aW9uIGFyZVBhcnRzTm9uQ29uc3VtaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHNOb25Db25zdW1pbmcgPSBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgIGNvbnN0IHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIGlmIChwYXJ0Tm9uQ29uc3VtaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJ0c05vbkNvbnN1bWluZztcbn1cblxuZnVuY3Rpb24gaXNUZXJtaW5hbFBhcnROb25Db25zdW1pbmcodGVybWluYWxQYXJ0KSB7XG4gIGxldCB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmc7XG5cbiAgY29uc3QgdGVybWluYWxQYXJ0U3RyaW5nID0gdGVybWluYWxQYXJ0LmFzU3RyaW5nKCk7XG5cbiAgc3dpdGNoICh0ZXJtaW5hbFBhcnRTdHJpbmcpIHtcbiAgICBjYXNlIGVwc2lsb246XG4gICAgY2FzZSBub1doaXRlc3BhY2U6XG4gICAgY2FzZSBzdGFydE9mQ29udGVudDoge1xuICAgICAgdGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nID0gdHJ1ZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgdGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nID0gZmFsc2U7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXJtaW5hbFBhcnROb25Db25zdW1pbmc7XG59XG5cbmZ1bmN0aW9uIGlzTm9uVGVybWluYWxQYXJ0Tm9uQ29uc3VtaW5nKG5vblRlcm1pbmFsUGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGxldCBwYXJ0Tm9uQ29uc3VtaW5nID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSdWxlTmFtZVBhcnRUeXBlOiB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVQYXJ0LmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0gfHwgbnVsbDtcblxuICAgICAgaWYgKHJ1bGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcnVsZU5vbkNvbnN1bWluZyA9IGlzUnVsZU5vbkNvbnN1bWluZyhydWxlLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICAgIHBhcnROb25Db25zdW1pbmcgPSBydWxlTm9uQ29uc3VtaW5nOyAgLy8vXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgT3B0aW9uYWxQYXJ0UGFydFR5cGU6IHtcbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSB0cnVlO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIE9uZU9yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgcGFydE5vbkNvbnN1bWluZyA9IHRydWU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgcGFydHMgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c05vbkNvbnN1bWluZyA9IGFyZVBhcnRzTm9uQ29uc3VtaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICBwYXJ0Tm9uQ29uc3VtaW5nID0gcGFydHNOb25Db25zdW1pbmc7IC8vL1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIENob2ljZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgcGFydHMgPSBjaG9pY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpLFxuICAgICAgICAgICAgcGFydHNOb25Db25zdW1pbmcgPSBwYXJ0cy5zb21lKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnROb25Db25zdW1pbmcgPSBpc1BhcnROb25Db25zdW1pbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgICAgICAgICByZXR1cm4gcGFydE5vbkNvbnN1bWluZztcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIHBhcnROb25Db25zdW1pbmcgPSBwYXJ0c05vbkNvbnN1bWluZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uQ29uc3VtaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJ0VHlwZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IGlzUGFydE5vbkNvbnN1bWluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvbm9uQ29uc3VtaW5nXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUoZGVmaW5pdGlvbiwgcnVsZU1hcCkge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgcGFydHNMZWZ0UmVjdXJzaXZlID0gYXJlUGFydHNMZWZ0UmVjdXJzaXZlKHBhcnRzLCBydWxlTWFwKSxcbiAgICAgICAgZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUgPSBwYXJ0c0xlZnRSZWN1cnNpdmU7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uTGVmdFJlY3Vyc2l2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZShydWxlLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCk7XG5cbiAgZGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IFtdKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydHMocGFydHMsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gIHJldHVybiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzO1xufVxuXG5mdW5jdGlvbiBhcmVQYXJ0c0xlZnRSZWN1cnNpdmUocGFydHMsIHJ1bGVNYXApIHtcbiAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydHMocGFydHMsIHJ1bGVNYXApLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5sZW5ndGgsXG4gICAgICAgIHBhcnRzTGVmdFJlY3Vyc2l2ZSA9IChsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzTGVuZ3RoID4gMCk7XG5cbiAgcmV0dXJuIHBhcnRzTGVmdFJlY3Vyc2l2ZTtcbn1cblxuZnVuY3Rpb24gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydE5vblRlcm1pbmFsUGFydCA9IHBhcnQuaXNOb25UZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgIHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVQYXJ0LmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJ1bGVOYW1lOyAvLy9cblxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMucHVzaChsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgT3B0aW9uYWxQYXJ0UGFydFR5cGU6IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0UGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnQgPSBvcHRpb25hbFBhcnRQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvbmVPck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHplcm9Pck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gemVyb09yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydHMgPSBzZXF1ZW5jZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgICAgICAgcGFydCA9IGZpcnN0UGFydDsgLy8vXG5cbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIENob2ljZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBjaG9pY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gY2hvaWNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKTtcblxuICAgICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0KSA9PiB7XG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJ1bGVNYXAsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnRzKHBhcnRzLCBydWxlTWFwLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgcGFydHMuZXZlcnkoKHBhcnQpID0+IHtcbiAgICBjb25zdCBwYXJ0Tm9uQ29uc3VtaW5nID0gaXNQYXJ0Tm9uQ29uc3VtaW5nKHBhcnQsIHJ1bGVNYXApO1xuXG4gICAgaWYgKCFwYXJ0Tm9uQ29uc3VtaW5nKSB7XG4gICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcnVsZU1hcCwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2Uge1xuICBjb25zdHJ1Y3RvcihsYWJlbCxzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLnNvdXJjZVZlcnRleCA9IHNvdXJjZVZlcnRleDtcbiAgICB0aGlzLnRhcmdldFZlcnRleCA9IHRhcmdldFZlcnRleDtcbiAgfVxuXG4gIGdldExhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICB9XG5cbiAgZ2V0U291cmNlVmVydGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZVZlcnRleDtcbiAgfVxuXG4gIGdldFRhcmdldFZlcnRleCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRWZXJ0ZXg7XG4gIH1cblxuICBpc1RyaXZpYWxseUN5Y2xpYygpIHtcbiAgICBjb25zdCB0cml2aWFsbHlDeWNsaWMgPSAodGhpcy5zb3VyY2VWZXJ0ZXggPT09IHRoaXMudGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiB0cml2aWFsbHlDeWNsaWM7XG4gIH1cblxuICBtYXRjaChlZGdlKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsKCksXG4gICAgICAgICAgc291cmNlVmVydGV4ID0gZWRnZS5nZXRTb3VyY2VWZXJ0ZXgoKSxcbiAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSBlZGdlLmdldFRhcmdldFZlcnRleCgpLFxuICAgICAgICAgIG1hdGNoZXMgPSB0aGlzLm1hdGNoTGFiZWxTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgbWF0Y2hTb3VyY2VWZXJ0ZXgoc291cmNlVmVydGV4KSB7XG4gICAgY29uc3QgbWF0Y2hlc1NvdXJjZVZlcnRleCA9ICh0aGlzLnNvdXJjZVZlcnRleCA9PT0gc291cmNlVmVydGV4KTtcblxuICAgIHJldHVybiBtYXRjaGVzU291cmNlVmVydGV4O1xuICB9XG5cbiAgbWF0Y2hUYXJnZXRWZXJ0ZXgodGFyZ2V0VmVydGV4KSB7XG4gICAgY29uc3QgbWF0Y2hlc1RhcmdldFZlcnRleCA9ICh0aGlzLnRhcmdldFZlcnRleCA9PT0gdGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiBtYXRjaGVzVGFyZ2V0VmVydGV4O1xuICB9XG5cbiAgbWF0Y2hTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgoc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gKCh0aGlzLnNvdXJjZVZlcnRleCA9PT0gc291cmNlVmVydGV4KSAmJiAodGhpcy50YXJnZXRWZXJ0ZXggPT09IHRhcmdldFZlcnRleCkpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBtYXRjaExhYmVsU291cmNlVmVydGV4QW5kVGFyZ2V0VmVydGV4KGxhYmVsLCBzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoKHRoaXMubGFiZWwgPT09IGxhYmVsKSAmJiAodGhpcy5zb3VyY2VWZXJ0ZXggPT09IHNvdXJjZVZlcnRleCkgJiYgKHRoaXMudGFyZ2V0VmVydGV4ID09PSB0YXJnZXRWZXJ0ZXgpKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21MYWJlbFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpIHtcbiAgICBjb25zdCBlZGdlID0gbmV3IEVkZ2UobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICAgIHJldHVybiBlZGdlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNvbnN0IHsgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgICAgICAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gICAgICAgIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgU2VxdWVuY2VPZlBhcnRzUGFydFR5cGUsXG4gICAgICAgIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZShydWxlLCByZWN1cnNpdmVSdWxlTmFtZXMgPSBbXSkge1xuICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICBkZWZpbml0aW9ucy5mb3JFYWNoKChkZWZpbml0aW9uKSA9PiB7XG4gICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlY3Vyc2l2ZVJ1bGVOYW1lcztcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCk7XG5cbiAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnRzKHBhcnRzLCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuXG4gIHJldHVybiByZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0cyhwYXJ0cywgcmVjdXJzaXZlUnVsZU5hbWVzID0gW10pIHtcbiAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG4gIH0pO1xuXG4gIHJldHVybiByZWN1cnNpdmVSdWxlTmFtZXM7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcykge1xuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgdHlwZSA9IG5vblRlcm1pbmFsUGFydC5nZXRUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUnVsZU5hbWVQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJlY3Vyc2l2ZVJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKCFyZWN1cnNpdmVSdWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgY29uc3QgcmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXMucHVzaChyZWN1cnNpdmVSdWxlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvbmVPck1vcmVQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsICAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9uZU9yTW9yZVBhcnRzUGFydC5nZXRQYXJ0KCk7XG5cbiAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IHplcm9Pck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpOyAgLy8vXG5cbiAgICAgICAgcmVjdXJzaXZlUnVsZU5hbWVzRnJvbVBhcnQocGFydCwgcmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU9mUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICAgIHBhcnRzID0gc2VxdWVuY2VPZlBhcnRzUGFydC5nZXRQYXJ0cygpO1xuXG4gICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgICByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUGFydChwYXJ0LCByZWN1cnNpdmVSdWxlTmFtZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBDaG9pY2VPZlBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgY2hvaWNlT2ZQYXJ0c1BhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgICBwYXJ0cyA9IGNob2ljZU9mUGFydHNQYXJ0LmdldFBhcnRzKCk7XG5cbiAgICAgICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21QYXJ0KHBhcnQsIHJlY3Vyc2l2ZVJ1bGVOYW1lcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBSRUNVUlNJVkVfTEFCRUwgPSBcInJlY3Vyc2l2ZVwiO1xuZXhwb3J0IGNvbnN0IExFRlRfUkVDVVJTSVZFX0xBQkVMID0gXCJsZWZ0LXJlY3Vyc2l2ZVwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRWRnZSBmcm9tIFwiLi4vZWRnZVwiO1xuXG5pbXBvcnQgeyBlZGdlc01hdGNoRWRnZSB9IGZyb20gXCIuLi9kaXJlY3RlZEdyYXBoXCI7XG5pbXBvcnQgeyByZWN1cnNpdmVSdWxlTmFtZXNGcm9tUnVsZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcmVjdXJzaXZlXCI7XG5pbXBvcnQgeyBSRUNVUlNJVkVfTEFCRUwsIExFRlRfUkVDVVJTSVZFX0xBQkVMIH0gZnJvbSBcIi4uL2xhYmVsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZWRnZXNGcm9tUnVsZU5hbWVzKHJ1bGVOYW1lcykge1xuICBjb25zdCBsZW5ndGggPSBydWxlTmFtZXMubGVuZ3RoLFxuICAgICAgICBlZGdlcyA9IHJ1bGVOYW1lcy5tYXAoKHJ1bGVOYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IChpbmRleCArIDEpICUgbGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5leHRSdWxlTmFtZSA9IHJ1bGVOYW1lc1tuZXh0SW5kZXhdLFxuICAgICAgICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IG5leHRSdWxlTmFtZSwgLy8vXG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2VGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZXNGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHJ1bGUgPSBzdGFydFJ1bGUsIC8vL1xuICAgICAgICBlZGdlcyA9IFtdLFxuICAgICAgICB2ZXJ0ZXhlcyA9IFtdO1xuXG4gIGVkZ2VzRnJvbVJ1bGUocnVsZSwgZWRnZXMsIHZlcnRleGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICBjb25zdCBsYWJlbCA9IExFRlRfUkVDVVJTSVZFX0xBQkVMLFxuICAgICAgICBzb3VyY2VWZXJ0ZXggPSBydWxlTmFtZSwgIC8vL1xuICAgICAgICB0YXJnZXRWZXJ0ZXggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIC8vL1xuICAgICAgICBlZGdlID0gRWRnZS5mcm9tTGFiZWxTb3VyY2VWZXJ0ZXhBbmRUYXJnZXRWZXJ0ZXgobGFiZWwsIHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KTtcblxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gZWRnZXNGcm9tUnVsZShydWxlLCBlZGdlcywgdmVydGV4ZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICB2ZXJ0ZXggPSBydWxlTmFtZSwgIC8vL1xuICAgICAgICB2ZXJ0ZXhlc0luY2x1ZGVzVmVydGV4ID0gdmVydGV4ZXMuaW5jbHVkZXModmVydGV4KTtcblxuICBpZiAodmVydGV4ZXNJbmNsdWRlc1ZlcnRleCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZlcnRleGVzID0gW1xuICAgIC4uLnZlcnRleGVzLFxuICAgIHZlcnRleFxuICBdO1xuXG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc01hcFtydWxlTmFtZV0sXG4gICAgICAgIHJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IHJlY3Vyc2l2ZVJ1bGVOYW1lc0Zyb21SdWxlKHJ1bGUpLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzID0gcnVsZU5hbWVzOyAvLy9cblxuICByZWN1cnNpdmVSdWxlTmFtZXMuZm9yRWFjaCgocmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSZWN1cnNpdmVSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMuaW5jbHVkZXMocmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IHJlY3Vyc2l2ZVJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgbGFiZWwgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzSW5jbHVkZXNSZWN1cnNpdmVSdWxlTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIExFRlRfUkVDVVJTSVZFX0xBQkVMIDpcbiAgICAgICAgICAgICAgICAgICAgICBSRUNVUlNJVkVfTEFCRUwsXG4gICAgICAgICAgc291cmNlVmVydGV4ID0gcnVsZU5hbWUsICAvLy9cbiAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIC8vL1xuICAgICAgICAgIGVkZ2UgPSBFZGdlLmZyb21MYWJlbFNvdXJjZVZlcnRleEFuZFRhcmdldFZlcnRleChsYWJlbCwgc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpLFxuICAgICAgICAgIG1hdGNoZXMgPSBlZGdlc01hdGNoRWRnZShlZGdlcywgZWRnZSk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjdXJzaXZlUnVsZSA9IHJ1bGVNYXBbcmVjdXJzaXZlUnVsZU5hbWVdIHx8IG51bGw7XG5cbiAgICBpZiAocmVjdXJzaXZlUnVsZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcnVsZSA9IHJlY3Vyc2l2ZVJ1bGU7IC8vL1xuXG4gICAgICBlZGdlc0Zyb21SdWxlKHJ1bGUsIGVkZ2VzLCB2ZXJ0ZXhlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcbiAgICB9XG4gIH0pO1xufVxuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFJ1bGUgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgUmVkdWNlZE5vZGUgZnJvbSBcIi4uL25vZGUvcmVkdWNlZFwiO1xuXG5pbXBvcnQgeyBlZGdlc01hdGNoRWRnZSB9IGZyb20gXCIuLi9kaXJlY3RlZEdyYXBoXCI7XG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5pbXBvcnQgeyByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5pbXBvcnQgeyBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24gfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2xlZnRSZWN1cnNpdmVcIjtcbmltcG9ydCB7IGVkZ2VzRnJvbVJ1bGVOYW1lcywgZWRnZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvZGlyZWN0ZWRHcmFwaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VkUnVsZSBleHRlbmRzIFJ1bGUge1xuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gUmVkdWNlZE5vZGU7XG5cbiAgICByZXR1cm4gTm9uVGVybWluYWxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICBsZXQgcmVkdWNlZFJ1bGUgPSBudWxsLFxuICAgICAgICBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgIGRlZmluaXRpb25zID0gZGVmaW5pdGlvbnMuZmlsdGVyKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uTGVmdFJlZHVjaWJsZSA9IGlzRGVmaW5pdGlvblJlZHVjaWJsZShkZWZpbml0aW9uLCBydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwKTtcblxuICAgICAgaWYgKGRlZmluaXRpb25MZWZ0UmVkdWNpYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnNMZW5ndGggPSBkZWZpbml0aW9ucy5sZW5ndGg7XG5cbiAgICBpZiAoZGVmaW5pdGlvbnNMZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICAgIG5hbWUgPSByZWR1Y2VkUnVsZU5hbWUsIC8vL1xuICAgICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpO1xuXG4gICAgICByZWR1Y2VkUnVsZSA9IG5ldyBSZWR1Y2VkUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHVjZWRSdWxlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5pdGlvblJlZHVjaWJsZShkZWZpbml0aW9uLCBydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwKSB7XG4gIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbURlZmluaXRpb24oZGVmaW5pdGlvbiwgcnVsZU1hcCksXG4gICAgICAgIGRlZmluaXRpb25SZWR1Y2libGUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzLmV2ZXJ5KChsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBjeWNsZXNJbmNsdWRlUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBjeWNsZXMuc29tZSgoY3ljbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN5Y2xlSW5jbHVkZXNSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGRvZXNDeWNsZUluY2x1ZGVSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShjeWNsZSwgcnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChjeWNsZUluY2x1ZGVzUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWN5Y2xlc0luY2x1ZGVSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvblJlZHVjaWJsZTtcbn1cblxuZnVuY3Rpb24gZG9lc0N5Y2xlSW5jbHVkZVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKGN5Y2xlLCBydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZShjeWNsZSksXG4gICAgICAgIGVkZ2UgPSBlZGdlRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICBlZGdlcyA9IGVkZ2VzRnJvbVJ1bGVOYW1lcyhydWxlTmFtZXMpLFxuICAgICAgICBtYXRjaGVzID0gZWRnZXNNYXRjaEVkZ2UoZWRnZXMsIGVkZ2UpLFxuICAgICAgICBjeWNsZUluY2x1ZGVzUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBtYXRjaGVzOyAgLy8vXG5cbiAgcmV0dXJuIGN5Y2xlSW5jbHVkZXNSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFJlZHVjZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVkdWNlZFwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZWRSdWxlcyhjeWNsZXMsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlcyhjeWNsZXMpO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgICByZWR1Y2VkUnVsZSA9IFJlZHVjZWRSdWxlLmZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCk7XG5cbiAgICBpZiAocmVkdWNlZFJ1bGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IHJlZHVjZWRSdWxlLmdldE5hbWUoKTtcblxuICAgICAgcnVsZU1hcFtyZWR1Y2VkUnVsZU5hbWVdID0gcmVkdWNlZFJ1bGU7XG4gICAgfVxuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZChub25UZXJtaW5hbE5vZGUpIHtcbiAgbGV0IG5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQ7XG5cbiAgY29uc3QgY2hpbGROb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gbm9uVGVybWluYWxOb2RlLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgICAgY2hpbGROb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gaXNOb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkKGNoaWxkTm9uVGVybWluYWxOb2RlKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIGlmIChjaGlsZE5vblRlcm1pbmFsTm9kZVVucHJlY2VkZW50ZWQpIHtcbiAgICBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gbm9uVGVybWluYWxOb2RlLmdldFByZWNlZGVuY2UoKTtcblxuICAgIGlmIChwcmVjZWRlbmNlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpO1xuXG4gICAgICBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkID0gbm9uVGVybWluYWxOb2RlLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4geyAgLy8vXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSA9IGNoaWxkTm9kZS5pc0xvd2VyUHJlY2VkZW5jZShydWxlTmFtZSwgcHJlY2VkZW5jZSk7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZUxvd2VyUHJlY2VkZW5jZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IHsgcmV3cml0ZURpcmVjdGx5UmVwZWF0ZWROb2RlcyB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcmV3cml0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RseVJlcGVhdGVkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJld3JpdGUoc3RhdGUpIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSB0aGlzLmNsb25lKCk7XG5cbiAgICByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuXG4gICAgcmV0dXJuIG5vblRlcm1pbmFsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRGlyZWN0bHlSZXBlYXRlZE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFcHNpbG9uTm9kZSwgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaXJlY3RseVJlcGVhdGVkTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGlzTnVsbGFyeSgpIHtcbiAgICBsZXQgbnVsbGFyeSA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc2luZ3VsYXIgPSB0aGlzLmlzU2luZ3VsYXIoKTtcblxuICAgIGlmIChzaW5ndWxhcikge1xuICAgICAgbnVsbGFyeSA9IHRoaXMuZXZlcnlDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgRXBzaWxvbk5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxhcnk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEluZGlyZWN0bHlSZXBlYXRlZE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFJlZHVjZWROb2RlIGZyb20gXCIuLi9ub2RlL3JlZHVjZWRcIjtcbmltcG9ydCBEaXJlY3RseVJlcGVhdGVkTm9kZSBmcm9tIFwiLi4vbm9kZS9yZXBlYXRlZC9kaXJlY3RseVwiO1xuaW1wb3J0IEluZGlyZWN0bHlSZXBlYXRlZE5vZGUgZnJvbSBcIi4uL25vZGUvcmVwZWF0ZWQvaW5kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZUZyb21SZWR1Y2VkUnVsZU5hbWUsIHJ1bGVOYW1lRnJvbUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVGcm9tSW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmNvbnN0IHsgcHVzaCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlUmVkdWNlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpIHtcbiAgbGV0IHJlZHVjZWRDaGlsZE5vZGU7XG5cbiAgY29uc3QgZmlyc3RDaGlsZE5vZGVSZWR1Y2VkTm9kZSA9IG5vblRlcm1pbmFsTm9kZS5zb21lQ2hpbGROb2RlKChjaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBpZiAoY2hpbGROb2RlIGluc3RhbmNlb2YgUmVkdWNlZE5vZGUpIHtcbiAgICAgICAgcmVkdWNlZENoaWxkTm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGlmICghZmlyc3RDaGlsZE5vZGVSZWR1Y2VkTm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub25UZXJtaW5hbE5vZGUsIC8vL1xuICAgICAgICByZXBsYWNlZENoaWxkTm9kZSA9IHJlZHVjZWRDaGlsZE5vZGUsIC8vL1xuICAgICAgICByZXBsYWNlZENoaWxkTm9kZU9wYWNpdHkgPSByZXBsYWNlZENoaWxkTm9kZS5nZXRPcGFjaXR5KCksXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlUnVsZU5hbWUgPSByZXBsYWNlZENoaWxkTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICByZXBsYWNlZENoaWxkTm9kZVByZWNlZGVuY2UgPSByZXBsYWNlZENoaWxkTm9kZS5nZXRQcmVjZWRlbmNlKCksXG4gICAgICAgIHJlcGxhY2VkQ2hpbGROb2RlQ2hpbGROb2RlcyA9IHJlcGxhY2VkQ2hpbGROb2RlLnJlbW92ZUNoaWxkTm9kZXMoKSxcbiAgICAgICAgcGFyZW50Tm9kZVJ1bGVOYW1lID0gcGFyZW50Tm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICByZWR1Y2VkUnVsZU5hbWUgPSByZXBsYWNlZENoaWxkTm9kZVJ1bGVOYW1lLCAgLy8vXG4gICAgICAgIHBhcmVudFJ1bGVOYW1lID0gcGFyZW50Tm9kZVJ1bGVOYW1lLCAgLy8vXG4gICAgICAgIHByZWNlZGVuY2UgPSByZXBsYWNlZENoaWxkTm9kZVByZWNlZGVuY2UsIC8vL1xuICAgICAgICBvcGFjaXR5ID0gcmVwbGFjZWRDaGlsZE5vZGVPcGFjaXR5LCAvLy9cbiAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZUZyb21SZWR1Y2VkUnVsZU5hbWUocmVkdWNlZFJ1bGVOYW1lKTtcblxuICBsZXQgcmVwbGFjZW1lbnRDaGlsZE5vZGVzO1xuXG4gIGlmIChydWxlTmFtZSA9PT0gcGFyZW50UnVsZU5hbWUpIHtcbiAgICByZXBsYWNlbWVudENoaWxkTm9kZXMgPSByZXBsYWNlZENoaWxkTm9kZUNoaWxkTm9kZXM7ICAvLy9cblxuICAgIHBhcmVudE5vZGUuc2V0UHJlY2VkZW5jZShwcmVjZWRlbmNlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gcmVwbGFjZWRDaGlsZE5vZGVDaGlsZE5vZGVzLCAvLy9cbiAgICAgICAgICBOb25UZXJtaW5hbE5vZGUgPSBzdGF0ZS5Ob25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpLFxuICAgICAgICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlID0gbm9uVGVybWluYWxOb2RlOyAvLy9cblxuICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlcyA9IFtcbiAgICAgIHJlcGxhY2VtZW50Q2hpbGROb2RlXG4gICAgXTtcbiAgfVxuXG4gIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkTm9kZShyZXBsYWNlZENoaWxkTm9kZSwgcmVwbGFjZW1lbnRDaGlsZE5vZGVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJld3JpdGVEaXJlY3RseVJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBzdGF0ZSkge1xuICBsZXQgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQ7XG5cbiAgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSByZXBsYWNlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgd2hpbGUgKGRpcmVjdGx5UmVwZWF0ZWROb2Rlc1JlcGxhY2VkKSB7XG4gICAgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSByZXBsYWNlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJld3JpdGVJbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUsIHN0YXRlKSB7XG4gIGxldCBwYXJlbnROb2RlID0gbm9uVGVybWluYWxOb2RlOyAvLy9cblxuICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlcyA9IGZpbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpO1xuXG4gIGluZGlyZWN0bHlSZXBlYXRlZE5vZGVzLmZvckVhY2goKGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpID0+IHtcbiAgICBjb25zdCBsZWZ0UmVjdXJzaXZlTm9kZSA9IGxlZnRSZWN1cnNpdmVOb2RlRnJvbVBhcmVudE5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUsIHN0YXRlKSxcbiAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0Zyb21MZWZ0UmVjdXJzaXZlTm9kZU5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKGxlZnRSZWN1cnNpdmVOb2RlLCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlKTtcblxuICAgIGFkanVzdFBhcmVudE5vZGVQcmVjZWRlbmNlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUpO1xuXG4gICAgcGFyZW50Tm9kZS5zZXRDaGlsZE5vZGVzKGNoaWxkTm9kZXMpO1xuXG4gICAgcGFyZW50Tm9kZSA9IGxlZnRSZWN1cnNpdmVOb2RlOyAvLy9cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgUmVwZWF0ZWROb2RlKSB7XG4gIGxldCByZXBlYXRlZE5vZGVzO1xuXG4gIGxldCBlbmRJbmRleCA9IC0xO1xuXG4gIG5vblRlcm1pbmFsTm9kZS5iYWNrd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlUmVwZWF0ZWROb2RlID0gKGNoaWxkTm9kZSBpbnN0YW5jZW9mIFJlcGVhdGVkTm9kZSk7XG5cbiAgICBpZiAoY2hpbGROb2RlUmVwZWF0ZWROb2RlKSB7XG4gICAgICBlbmRJbmRleCA9IGluZGV4ICsgMTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZW5kSW5kZXggPT09IC0xKSB7XG4gICAgcmVwZWF0ZWROb2RlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIGxldCBzdGFydEluZGV4O1xuXG4gICAgbm9uVGVybWluYWxOb2RlLmJhY2t3YXJkc1NvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZVJlcGVhdGVkTm9kZSA9IChjaGlsZE5vZGUgaW5zdGFuY2VvZiBSZXBlYXRlZE5vZGUpO1xuXG4gICAgICBpZiAoIWNoaWxkTm9kZVJlcGVhdGVkTm9kZSkge1xuICAgICAgICBpZiAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDsgLy8vXG4gICAgfSk7XG5cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLnNsaWNlQ2hpbGROb2RlcyhzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cbiAgICByZXBlYXRlZE5vZGVzID0gY2hpbGROb2RlczsgLy8vXG4gIH1cblxuICByZXR1cm4gcmVwZWF0ZWROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbnRDaGlsZE5vZGVzKHBhcmVudE5vZGUpIHtcbiAgY29uc3QgbXVsdGlwbGljaXR5ID0gcGFyZW50Tm9kZS5nZXRNdWx0aXBsaWNpdHkoKSxcbiAgICAgICAgZGVsZXRlQ291bnQgPSBtdWx0aXBsaWNpdHkgLSAxLFxuICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgIHJlbW92ZWRGcm9udENoaWxkTm9kZXMgPSBwYXJlbnROb2RlLnNwbGljZUNoaWxkTm9kZXMoc3RhcnQsIGRlbGV0ZUNvdW50KTtcblxuICByZXR1cm4gcmVtb3ZlZEZyb250Q2hpbGROb2Rlcztcbn1cblxuZnVuY3Rpb24gZmluZERpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpIHtcbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZE5vZGVzID0gZmluZFJlcGVhdGVkTm9kZXMobm9uVGVybWluYWxOb2RlLCBEaXJlY3RseVJlcGVhdGVkTm9kZSk7XG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWROb2Rlcztcbn1cblxuZnVuY3Rpb24gZmluZEluZGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSkge1xuICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlcyA9IGZpbmRSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgSW5kaXJlY3RseVJlcGVhdGVkTm9kZSk7XG5cbiAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZXMucmV2ZXJzZSgpO1xuXG4gIHJldHVybiBpbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZURpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpIHtcbiAgbGV0IGRpcmVjdGx5UmVwZWF0ZWROb2Rlc1JlcGxhY2VkID0gZmFsc2U7XG5cbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZE5vZGVzID0gZmluZERpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkTm9kZXNMZW5ndGggPSBkaXJlY3RseVJlcGVhdGVkTm9kZXMubGVuZ3RoO1xuXG4gIGlmIChkaXJlY3RseVJlcGVhdGVkTm9kZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vblRlcm1pbmFsTm9kZSwgLy8vXG4gICAgICAgICAgcmVwbGFjZWRDaGlsZE5vZGVzID0gZGlyZWN0bHlSZXBlYXRlZE5vZGVzLCAvLy9cbiAgICAgICAgICByZXBsYWNlbWVudENoaWxkTm9kZXMgPSBbXTsgLy8vXG5cbiAgICBkaXJlY3RseVJlcGVhdGVkTm9kZXMuZm9yRWFjaCgoZGlyZWN0bHlSZXBlYXRlZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWROb2Rlc0NoaWxkTm9kZXMgPSBkaXJlY3RseVJlcGVhdGVkTm9kZS5yZW1vdmVDaGlsZE5vZGVzKCk7XG5cbiAgICAgIHB1c2gocmVwbGFjZW1lbnRDaGlsZE5vZGVzLCBkaXJlY3RseVJlcGVhdGVkTm9kZXNDaGlsZE5vZGVzKTtcbiAgICB9KTtcblxuICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkTm9kZXMocmVwbGFjZWRDaGlsZE5vZGVzLCByZXBsYWNlbWVudENoaWxkTm9kZXMpO1xuXG4gICAgZGlyZWN0bHlSZXBlYXRlZE5vZGVzUmVwbGFjZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWROb2Rlc1JlcGxhY2VkO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RQYXJlbnROb2RlUHJlY2VkZW5jZShwYXJlbnROb2RlLCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgcGFyZW50Tm9kZU5vZGVSdWxlTmFtZSA9IHBhcmVudE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZUZyb21JbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSk7XG5cbiAgaWYgKHBhcmVudE5vZGVOb2RlUnVsZU5hbWUgPT09IHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgcGFyZW50Tm9kZS5zZXRQcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZnRSZWN1cnNpdmVOb2RlRnJvbVBhcmVudE5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKHBhcmVudE5vZGUsIGluZGlyZWN0bHlSZXBlYXRlZE5vZGUsIHN0YXRlKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZE5vZGVSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZU9wYWNpdHkgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlLmdldE9wYWNpdHkoKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlUnVsZU5hbWUsICAvLy9cbiAgICAgICAgcmVtb3ZlZEZyb250Q2hpbGROb2RlcyA9IHJlbW92ZUZyb250Q2hpbGROb2RlcyhwYXJlbnROb2RlKSxcbiAgICAgICAgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lRnJvbUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSxcbiAgICAgICAgcnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIC8vL1xuICAgICAgICBjaGlsZE5vZGVzID0gcmVtb3ZlZEZyb250Q2hpbGROb2RlcywgIC8vL1xuICAgICAgICBvcGFjaXR5ID0gaW5kaXJlY3RseVJlcGVhdGVkTm9kZU9wYWNpdHksICAvLy9cbiAgICAgICAgcHJlY2VkZW5jZSA9IG51bGwsXG4gICAgICAgIE5vblRlcm1pbmFsTm9kZSA9IHN0YXRlLk5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSksXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpLFxuICAgICAgICBsZWZ0UmVjdXJzaXZlTm9kZSA9IG5vblRlcm1pbmFsTm9kZTsgIC8vL1xuXG4gIHJldHVybiBsZWZ0UmVjdXJzaXZlTm9kZTtcbn1cblxuZnVuY3Rpb24gY2hpbGROb2Rlc0Zyb21MZWZ0UmVjdXJzaXZlTm9kZU5vZGVBbmRJbmRpcmVjdGx5UmVwZWF0ZWROb2RlKGxlZnRSZWN1cnNpdmVOb2RlLCBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlKSB7XG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBbXG4gICAgICAgICAgbGVmdFJlY3Vyc2l2ZU5vZGVcbiAgICAgICAgXSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkTm9kZU51bGxhcnkgPSBpbmRpcmVjdGx5UmVwZWF0ZWROb2RlLmlzTnVsbGFyeSgpO1xuXG4gIGlmICghaW5kaXJlY3RseVJlcGVhdGVkTm9kZU51bGxhcnkpIHtcbiAgICBjb25zdCByZW1vdmVkQ2hpbGROb2RlcyA9IGluZGlyZWN0bHlSZXBlYXRlZE5vZGUucmVtb3ZlQ2hpbGROb2RlcygpO1xuXG4gICAgcHVzaChjaGlsZE5vZGVzLCByZW1vdmVkQ2hpbGROb2Rlcyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGROb2Rlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IHsgaXNOb25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wcmVjZWRlbmNlXCI7XG5pbXBvcnQgeyByZXdyaXRlUmVkdWNlZE5vZGVzLCByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzLCByZXdyaXRlSW5kaXJlY3RseVJlcGVhdGVkTm9kZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Jld3JpdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHJld3JpdGUoc3RhdGUpIHtcbiAgICBsZXQgbm9uVGVybWluYWxOb2RlO1xuXG4gICAgY29uc3QgcnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgTm9uVGVybWluYWxOb2RlID0gc3RhdGUuTm9uVGVybWluYWxOb2RlRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIG5vblRlcm1pbmFsTm9kZSA9IHRoaXMuY2xvbmUoKTtcblxuICAgIGNvbnN0IG9wYWNpdHkgPSBub25UZXJtaW5hbE5vZGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIHByZWNlZGVuY2UgPSBub25UZXJtaW5hbE5vZGUuZ2V0UHJlY2VkZW5jZSgpO1xuXG4gICAgbm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXdyaXRlRGlyZWN0bHlSZXBlYXRlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IHJld3JpdGVJbmRpcmVjdGx5UmVwZWF0ZWROb2Rlcyhub25UZXJtaW5hbE5vZGUsIHN0YXRlKTtcblxuICAgIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IHBhcmVudE5vZGU7IC8vL1xuXG4gICAgICByZXdyaXRlUmVkdWNlZE5vZGVzKG5vblRlcm1pbmFsTm9kZSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBpc1VucHJlY2VkZW50ZWQoKSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gdGhpcywgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZCA9IGlzTm9uVGVybWluYWxOb2RlVW5wcmVjZWRlbnRlZChub25UZXJtaW5hbE5vZGUpLFxuICAgICAgICAgIHVucHJlY2VkZW50ZWQgPSBub25UZXJtaW5hbE5vZGVVbnByZWNlZGVudGVkOyAvLy9cblxuICAgIHJldHVybiB1bnByZWNlZGVudGVkO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShSZXdyaXR0ZW5Ob2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBlcm11dGVSdWxlTmFtZXMocnVsZU5hbWVzLCBydWxlTmFtZSkge1xuICBsZXQgc3RhcnQsXG4gICAgICAgIGVuZDtcblxuICBjb25zdCBpbmRleCA9IHJ1bGVOYW1lcy5pbmRleE9mKHJ1bGVOYW1lKTtcblxuICBzdGFydCA9IDA7XG5cbiAgZW5kID0gaW5kZXg7ICAvLy9cblxuICBjb25zdCBsZWFkaW5nUnVsZU5hbWVzID0gcnVsZU5hbWVzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIHN0YXJ0ID0gaW5kZXg7ICAvLy9cblxuICBjb25zdCB0cmFpbGluZ1J1bGVOYW1lcyA9IHJ1bGVOYW1lcy5zbGljZShzdGFydCksXG4gICAgICAgIHBlcm11dGVkUnVsZU5hbWVzID0gW1xuICAgICAgICAgIC4uLnRyYWlsaW5nUnVsZU5hbWVzLFxuICAgICAgICAgIC4uLmxlYWRpbmdSdWxlTmFtZXNcbiAgICAgICAgXTtcblxuICByZXR1cm4gcGVybXV0ZWRSdWxlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWVzLCBjYWxsYmFjaykge1xuICBjb25zdCBydWxlTmFtZXNMZW5ndGggPSBydWxlTmFtZXMubGVuZ3RoLFxuICAgICAgICBsYXN0SW5kZXggPSBydWxlTmFtZXNMZW5ndGggLSAxO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBuZXh0SW5kZXggPSAoaW5kZXggPT09IGxhc3RJbmRleCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZXNbbmV4dEluZGV4XTtcblxuICAgIGNhbGxiYWNrKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUsIGluZGV4KTtcbiAgfSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFBhcnRzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuY29uc3QgeyBSdWxlTmFtZVBhcnQsIFplcm9Pck1vcmVQYXJ0c1BhcnQgfSA9IFBhcnRzO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gIGNvbnN0IHJ1bGVOYW1lUGFydCA9IFJ1bGVOYW1lUGFydC5mcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gIHJldHVybiBydWxlTmFtZVBhcnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvT3JNb3JlUGFydHNQYXJ0RnJvbVBhcnQocGFydCkge1xuICBjb25zdCB6ZXJvT3JNb3JlUGFydHNQYXJ0ID0gWmVyb09yTW9yZVBhcnRzUGFydC5mcm9tUGFydChwYXJ0KTtcblxuICByZXR1cm4gemVyb09yTW9yZVBhcnRzUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IHBlcm11dGVSdWxlTmFtZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jeWNsZVwiO1xuaW1wb3J0IHsgcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJ0XCI7XG5pbXBvcnQgeyByZWR1Y2VkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmNvbnN0IHsgbGFzdCwgbWF0Y2gsIGNvbXByZXNzIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGFyZVBhdGhzRXF1YWwocGF0aEEsIHBhdGhCKSB7XG4gIGNvbnN0IHJ1bGVOYW1lc0EgPSBwYXRoQSwgLy8vXG4gICAgICAgIHJ1bGVOYW1lc0IgPSBwYXRoQiwgLy8vXG4gICAgICAgIHJ1bGVOYW1lc01hdGNoID0gbWF0Y2gocnVsZU5hbWVzQSwgcnVsZU5hbWVzQiwgKHJ1bGVOYW1lQSwgcnVsZU5hbWVCKSA9PiB7XG4gICAgICAgICAgaWYgKHJ1bGVOYW1lQSA9PT0gcnVsZU5hbWVCKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwYXRoc0VxdWFsID0gcnVsZU5hbWVzTWF0Y2g7ICAvLy9cblxuICByZXR1cm4gcGF0aHNFcXVhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZlcmVuY2VGcm9tUGF0aHMocGF0aEEsIHBhdGhCLCBydWxlTmFtZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGxldCBkaWZmZXJlbmNlO1xuXG4gIGNvbnN0IHBhdGhBTGVuZ3RoID0gcGF0aEEubGVuZ3RoLFxuICAgICAgICBwYXRoQkxlbmd0aCA9IHBhdGhCLmxlbmd0aDtcblxuICBpZiAoZmFsc2UpIHtcbiAgICAvLy9cbiAgfSBlbHNlIGlmICgocGF0aEFMZW5ndGggPT09IDEpKSB7XG4gICAgZGlmZmVyZW5jZSA9IC0xO1xuICB9IGVsc2UgaWYgKChwYXRoQkxlbmd0aCA9PT0gMSkpIHtcbiAgICBkaWZmZXJlbmNlID0gKzE7XG4gIH0gZWxzZSBpZiAoKHBhdGhBTGVuZ3RoID09PSAwKSAmJiAocGF0aEJMZW5ndGggPT09IDApKSB7XG4gICAgZGlmZmVyZW5jZSA9IDA7XG4gIH0gZWxzZSBpZiAoKHBhdGhBTGVuZ3RoID09PSAwKSkge1xuICAgIGRpZmZlcmVuY2UgPSArMTtcbiAgfSBlbHNlIGlmICgocGF0aEJMZW5ndGggPT09IDApKSB7XG4gICAgZGlmZmVyZW5jZSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJ1bGVOYW1lc0EgPSBwYXRoQS5zbGljZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lc0IgPSBwYXRoQi5zbGljZSgpLFxuICAgICAgICAgIHJ1bGVOYW1lQSA9IHJ1bGVOYW1lc0Euc2hpZnQoKSxcbiAgICAgICAgICBydWxlTmFtZUIgPSBydWxlTmFtZXNCLnNoaWZ0KCk7XG5cbiAgICBpZiAocnVsZU5hbWVBID09PSBydWxlTmFtZUIpIHtcbiAgICAgIHBhdGhBID0gcnVsZU5hbWVzQTsgLy8vXG5cbiAgICAgIHBhdGhCID0gcnVsZU5hbWVzQjsgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gcnVsZU5hbWVBOyAvLy9cblxuICAgICAgZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VGcm9tUGF0aHMocGF0aEEsIHBhdGhCLCBydWxlTmFtZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgICAgIGluZGV4QSA9IHJ1bGVOYW1lcy5pbmRleE9mKHJ1bGVOYW1lQSksXG4gICAgICAgICAgICBpbmRleEIgPSBydWxlTmFtZXMuaW5kZXhPZihydWxlTmFtZUIpO1xuXG4gICAgICBkaWZmZXJlbmNlID0gKGluZGV4QSAtIGluZGV4Qik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpZmZlcmVuY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VkUnVsZU5hbWVGcm9tUGF0aChwYXRoKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHBhdGgsIC8vL1xuICAgICAgICBsYXN0UnVsZU5hbWUgPSBsYXN0KHJ1bGVOYW1lcyksXG4gICAgICAgIHJ1bGVOYW1lID0gbGFzdFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICByZXR1cm4gcmVkdWNlZFJ1bGVOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aHNGcm9tUnVsZU5hbWVBbmRDeWNsZXMocnVsZU5hbWUsIGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IHBhdGhzID0gY3ljbGVzLnJlZHVjZSgocGF0aHMsIGN5Y2xlKSA9PiB7XG4gICAgY29uc3QgcnVsZU5hbWVzID0gcnVsZU5hbWVzRnJvbUN5Y2xlKGN5Y2xlKSxcbiAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICBjb25zdCBwZXJtdXRlZFJ1bGVOYW1lcyA9IHBlcm11dGVSdWxlTmFtZXMocnVsZU5hbWVzLCBydWxlTmFtZSksXG4gICAgICAgICAgICBwYXRoID0gcGVybXV0ZWRSdWxlTmFtZXM7IC8vL1xuXG4gICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSwgW10pO1xuXG4gIGxldCBsZW5ndGg7XG5cbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IDEpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKCk7ICAvLy9cblxuICAgICAgcGF0aC5wb3AoKTtcblxuICAgICAgcGF0aHMucHVzaChwYXRoKTtcblxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICBjb21wcmVzcyhwYXRocywgKHBhdGhBLCBwYXRoQikgPT4ge1xuICAgIGNvbnN0IHBhdGhzRXF1YWwgPSBhcmVQYXRoc0VxdWFsKHBhdGhBLCBwYXRoQik7XG5cbiAgICBpZiAoIXBhdGhzRXF1YWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcnVsZU5hbWUgPSBudWxsO1xuXG4gIHBhdGhzLnNvcnQoKHBhdGhBLCBwYXRoQikgPT4ge1xuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlRnJvbVBhdGhzKHBhdGhBLCBwYXRoQiwgcnVsZU5hbWUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCk7XG5cbiAgICByZXR1cm4gZGlmZmVyZW5jZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlZFJ1bGVOYW1lUGFydEZyb21QYXRoKHBhdGgpIHtcbiAgY29uc3QgcmVkdWNlZFJ1bGVOYW1lID0gcmVkdWNlZFJ1bGVOYW1lRnJvbVBhdGgocGF0aCksXG4gICAgICAgIHJlZHVjZWRSdWxlTmFtZVBhcnQgPSBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUocmVkdWNlZFJ1bGVOYW1lKTtcblxuICByZXR1cm4gcmVkdWNlZFJ1bGVOYW1lUGFydDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRGVmaW5pdGlvbiB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IHJlZHVjZWRSdWxlTmFtZUZyb21QYXRoLCByZWR1Y2VkUnVsZU5hbWVQYXJ0RnJvbVBhdGggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhdGhcIjtcbmltcG9ydCB7IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZSwgemVyb09yTW9yZVBhcnRzUGFydEZyb21QYXJ0IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJ0XCI7XG5pbXBvcnQgeyBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUsIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ydWxlTmFtZVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuRGVmaW5pdGlvbiBleHRlbmRzIERlZmluaXRpb24ge1xuICBzdGF0aWMgZnJvbVBhdGgocGF0aCwgcnVsZU1hcCkge1xuICAgIGxldCByZXdyaXR0ZW5EZWZpbml0aW9uID0gbnVsbDtcblxuICAgIGNvbnN0IHJlZHVjZWRSdWxlTmFtZSA9IHJlZHVjZWRSdWxlTmFtZUZyb21QYXRoKHBhdGgpLFxuICAgICAgICAgIHJlZHVjZWRSdWxlID0gcnVsZU1hcFtyZWR1Y2VkUnVsZU5hbWVdIHx8IG51bGw7XG5cbiAgICBpZiAocmVkdWNlZFJ1bGUgIT09IG51bGwpIHtcbiAgICAgIHJld3JpdHRlbkRlZmluaXRpb24gPSByZXdyaXR0ZW5EZWZpbml0aW9uRnJvbVBhdGgocGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJld3JpdHRlbkRlZmluaXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBhdGgocGF0aCkge1xuICBjb25zdCByZXZlcnNlZFBhdGggPSBwYXRoLnNsaWNlKCk7XG5cbiAgcmV2ZXJzZWRQYXRoLnJldmVyc2UoKTtcblxuICByZXR1cm4gcmV2ZXJzZWRQYXRoO1xufVxuXG5mdW5jdGlvbiByZXdyaXR0ZW5EZWZpbml0aW9uRnJvbVBhdGgocGF0aCkge1xuICBjb25zdCByZWR1Y2VkUnVsZU5hbWVQYXJ0ID0gcmVkdWNlZFJ1bGVOYW1lUGFydEZyb21QYXRoKHBhdGgpLFxuICAgICAgICByZXZlcnNlZFBhdGggPSByZXZlcnNlUGF0aChwYXRoKSxcbiAgICAgICAgcnVsZU5hbWVzID0gcmV2ZXJzZWRQYXRoLCAvLy9cbiAgICAgICAgcnVsZU5hbWVzTGVuZ3RoID0gcnVsZU5hbWVzLmxlbmd0aCxcbiAgICAgICAgbGFzdEluZGV4ID0gcnVsZU5hbWVzTGVuZ3RoIC0gMSxcbiAgICAgICAgcGFydHMgPSBbXTsgLy8vXG5cbiAgcGFydHMucHVzaChyZWR1Y2VkUnVsZU5hbWVQYXJ0KTtcblxuICBmb3JFYWNoUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWVzLCAocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgICBwYXJ0cy5wdXNoKGRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcblxuICAgICAgY29uc3QgdGVtcG9yYXJ5UnVsZU5hbWUgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWU7IC8vL1xuXG4gICAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICAgIHJ1bGVOYW1lID0gdGVtcG9yYXJ5UnVsZU5hbWU7ICAvLy9cblxuICAgICAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUGFydCA9IGluZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgIHBhcnRzLnB1c2goaW5kaXJlY3RseVJlcGVhdGVkUGFydCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAocnVsZU5hbWVzTGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZmlyc3RSdWxlTmFtZSA9IGZpcnN0KHJ1bGVOYW1lcyksXG4gICAgICAgICAgcnVsZU5hbWUgPSBmaXJzdFJ1bGVOYW1lLFxuICAgICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcGFydHMucHVzaChkaXJlY3RseVJlcGVhdGVkUGFydCk7XG4gIH1cblxuICBjb25zdCBwcmVjZWRlbmNlID0gbnVsbCxcbiAgICAgICAgcmV3cml0dGVuRGVmaW5pdGlvbiA9IG5ldyBSZXdyaXR0ZW5EZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICByZXR1cm4gcmV3cml0dGVuRGVmaW5pdGlvbjtcbn1cblxuZnVuY3Rpb24gZGlyZWN0bHlSZXBlYXRlZFBhcnRGcm9tUnVsZU5hbWUocnVsZU5hbWUpIHtcbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCA9IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZShkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUpLFxuICAgICAgICB6ZXJvT3JNb3JlRGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydHNQYXJ0ID0gemVyb09yTW9yZVBhcnRzUGFydEZyb21QYXJ0KGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnQpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkUGFydCA9IHplcm9Pck1vcmVEaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0c1BhcnQ7IC8vL1xuXG4gIHJldHVybiBkaXJlY3RseVJlcGVhdGVkUGFydDtcbn1cblxuZnVuY3Rpb24gaW5kaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSB7XG4gIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSksXG4gICAgICAgIGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCA9IHJ1bGVOYW1lUGFydEZyb21SdWxlTmFtZShpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSksXG4gICAgICAgIGluZGlyZWN0bHlSZXBlYXRlZFBhcnQgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnQ7ICAvLy9cblxuICByZXR1cm4gaW5kaXJlY3RseVJlcGVhdGVkUGFydDtcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSdWxlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IFJld3JpdHRlbk5vZGUgZnJvbSBcIi4uL25vZGUvcmV3cml0dGVuXCI7XG5pbXBvcnQgUmV3cml0dGVuRGVmaW5pdGlvbiBmcm9tIFwiLi4vZGVmaW5pdGlvbi9yZXdyaXR0ZW5cIjtcblxuaW1wb3J0IHsgcGF0aHNGcm9tUnVsZU5hbWVBbmRDeWNsZXMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3BhdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV3cml0dGVuUnVsZSBleHRlbmRzIFJ1bGUge1xuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gUmV3cml0dGVuTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApIHtcbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IFtdLFxuICAgICAgICAgIHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgcGF0aHMgPSBwYXRoc0Zyb21SdWxlTmFtZUFuZEN5Y2xlcyhydWxlTmFtZSwgY3ljbGVzLCBydWxlTWFwLCBydWxlTmFtZXNNYXApO1xuXG4gICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgY29uc3QgcmV3cml0dGVuRGVmaW5pdGlvbiA9IFJld3JpdHRlbkRlZmluaXRpb24uZnJvbVBhdGgocGF0aCwgcnVsZU1hcCk7XG5cbiAgICAgIGlmIChyZXdyaXR0ZW5EZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSByZXdyaXR0ZW5EZWZpbml0aW9uOyAvLy9cblxuICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbmFtZSA9IHJ1bGVOYW1lLCAgLy8vXG4gICAgICAgICAgb3BhY2l0eSA9IHJ1bGUuZ2V0T3BhY2l0eSgpLFxuICAgICAgICAgIHJld3JpdHRlblJ1bGUgPSBuZXcgUmV3cml0dGVuUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyk7XG5cbiAgICByZXR1cm4gcmV3cml0dGVuUnVsZTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBEZWZpbml0aW9uIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IHJ1bGVOYW1lc0Zyb21DeWNsZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvY3ljbGVcIjtcbmltcG9ydCB7IHBlcm11dGVSdWxlTmFtZXMsIGZvckVhY2hSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBydWxlTmFtZVBhcnRGcm9tUnVsZU5hbWUsIHplcm9Pck1vcmVQYXJ0c1BhcnRGcm9tUGFydCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcGFydFwiO1xuaW1wb3J0IHsgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lLCBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21SdWxlQW5kQ3ljbGUocnVsZSwgY3ljbGUpIHtcbiAgICBsZXQgZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gPSBudWxsO1xuXG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpLFxuICAgICAgICAgIHJ1bGVOYW1lSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICBpZiAocnVsZU5hbWVJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICBjb25zdCBwZXJtdXRlZFJ1bGVOYW1lcyA9IHBlcm11dGVSdWxlTmFtZXMocnVsZU5hbWVzLCBydWxlTmFtZSksXG4gICAgICAgICAgICBwYXRoID0gcGVybXV0ZWRSdWxlTmFtZXMsIC8vL1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0c0Zyb21QYXRoKHBhdGgpLFxuICAgICAgICAgICAgcHJlY2VkZW5jZSA9IG51bGw7XG5cbiAgICAgIGRpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uID0gbmV3IERpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uKHBhcnRzLCBwcmVjZWRlbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVybXV0ZVBhdGgocGF0aCkge1xuICBjb25zdCBwZXJtdXRlZFBhdGggPSBwYXRoLnNsaWNlKCk7ICAvLy9cblxuICBwZXJtdXRlZFBhdGgucmV2ZXJzZSgpO1xuXG4gIGNvbnN0IHJ1bGVOYW1lID0gcGVybXV0ZWRQYXRoLnBvcCgpO1xuXG4gIHBlcm11dGVkUGF0aC51bnNoaWZ0KHJ1bGVOYW1lKTtcblxuICByZXR1cm4gcGVybXV0ZWRQYXRoO1xufVxuXG5mdW5jdGlvbiBwYXJ0c0Zyb21QYXRoKHBhdGgpIHtcbiAgY29uc3QgcGVybXV0ZWRQYXRoID0gcGVybXV0ZVBhdGgocGF0aCksXG4gICAgICAgIHJ1bGVOYW1lcyA9IHBlcm11dGVkUGF0aCwgLy8vXG4gICAgICAgIHBhcnRzID0gW107XG5cbiAgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lcywgKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCB0ZW1wb3JhcnlSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZTsgLy8vXG5cbiAgICBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICBydWxlTmFtZSA9IHRlbXBvcmFyeVJ1bGVOYW1lOyAgLy8vXG5cbiAgICBjb25zdCBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gaW5kaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZUFuZExlZnRSZXVjcnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSxcbiAgICAgICAgICBkaXJlY3RseVJlcGVhdGVkUGFydCA9IGRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHBhcnRzLnB1c2goaW5kaXJlY3RseVJlcGVhdGVkUGFydCk7XG5cbiAgICBwYXJ0cy5wdXNoKGRpcmVjdGx5UmVwZWF0ZWRQYXJ0KTtcbiAgfSk7XG5cbiAgcGFydHMucG9wKCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RseVJlcGVhdGVkUGFydEZyb21SdWxlTmFtZShydWxlTmFtZSkge1xuICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUocnVsZU5hbWUpLFxuICAgICAgICBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSksXG4gICAgICAgIHplcm9Pck1vcmVEaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0c1BhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0RnJvbVBhcnQoZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydCksXG4gICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0ID0gemVyb09yTW9yZURpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZVBhcnRzUGFydDsgLy8vXG5cbiAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWRQYXJ0O1xufVxuXG5mdW5jdGlvbiBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0RnJvbVJ1bGVOYW1lQW5kTGVmdFJldWNyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpIHtcbiAgY29uc3QgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZShydWxlTmFtZSwgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVQYXJ0ID0gcnVsZU5hbWVQYXJ0RnJvbVJ1bGVOYW1lKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lKSxcbiAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUGFydCA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lUGFydDsgIC8vL1xuXG4gIHJldHVybiBpbmRpcmVjdGx5UmVwZWF0ZWRQYXJ0O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSdWxlIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWROb2RlIGZyb20gXCIuLi8uLi9ub2RlL3JlcGVhdGVkL2RpcmVjdGx5XCI7XG5pbXBvcnQgRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vcmVwZWF0ZWQvZGlyZWN0bHlcIlxuXG5pbXBvcnQgeyBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdGx5UmVwZWF0ZWRSdWxlIGV4dGVuZHMgUnVsZSB7XG4gIE5vblRlcm1pbmFsTm9kZUZyb21SdWxlTmFtZShydWxlTmFtZSwgc3RhdGUpIHtcbiAgICBjb25zdCBOb25UZXJtaW5hbE5vZGUgPSBEaXJlY3RseVJlcGVhdGVkTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRDeWNsZXMocnVsZSwgY3ljbGVzKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBydWxlLmdldE5hbWUoKSxcbiAgICAgICAgICBkZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgY3ljbGVzLm1hcCgoY3ljbGUpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGx5UmVwZWF0ZWREZWZpbml0aW9uID0gRGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb24uZnJvbVJ1bGVBbmRDeWNsZShydWxlLCBjeWNsZSk7XG5cbiAgICAgIGlmIChkaXJlY3RseVJlcGVhdGVkRGVmaW5pdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGlyZWN0bHlSZXBlYXRlZERlZmluaXRpb247ICAvLy9cblxuICAgICAgICBkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICBuYW1lID0gZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lLCAvLy9cbiAgICAgICAgICBvcGFjaXR5ID0gcnVsZS5nZXRPcGFjaXR5KCksXG4gICAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBuZXcgRGlyZWN0bHlSZXBlYXRlZFJ1bGUobmFtZSwgb3BhY2l0eSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgcmV0dXJuIGRpcmVjdGx5UmVwZWF0ZWRSdWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUmV3cml0dGVuUnVsZSBmcm9tIFwiLi9ydWxlL3Jld3JpdHRlblwiO1xuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHlcIjtcblxuaW1wb3J0IHsgaXNSdWxlTm9uQ29uc3VtaW5nIH0gZnJvbSBcIi4vdXRpbGl0aWVzL25vbkNvbnN1bWluZ1wiO1xuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jeWNsZVwiO1xuaW1wb3J0IHsgaXNDeWNsZUlycmVkdWNpYmxlLCBydWxlQ3ljbGVzRnJvbVJ1bGVOYW1lQW5kQ3ljbGVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2N5Y2xlXCI7XG5cbmNvbnN0IHsgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmV3cml0ZUxlZnRSZWN1cnNpdmVSdWxlcyhjeWNsZXMsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGVzKGN5Y2xlcyk7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgbGV0IHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXTtcblxuICAgIGNvbnN0IHJld3JpdHRlblJ1bGUgPSBSZXdyaXR0ZW5SdWxlLmZyb21SdWxlQW5kQ3ljbGVzKHJ1bGUsIGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcblxuICAgIHJ1bGUgPSByZXdyaXR0ZW5SdWxlOyAvLy9cblxuICAgIHJ1bGVNYXBbcnVsZU5hbWVdID0gcnVsZTtcbiAgfSk7XG5cbiAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVzID0gcnVsZXNGcm9tUnVsZShEaXJlY3RseVJlcGVhdGVkUnVsZSwgcnVsZU1hcCk7XG5cbiAgZGlyZWN0bHlSZXBlYXRlZFJ1bGVzLmZvckVhY2goKGRpcmVjdGx5UmVwZWF0ZWRSdWxlKSA9PiB7XG4gICAgY29uc3QgZGlyZWN0bHlSZXBlYXRlZFJ1bGVOb25Db25zdW1pbmcgPSBpc1J1bGVOb25Db25zdW1pbmcoZGlyZWN0bHlSZXBlYXRlZFJ1bGUsIHJ1bGVNYXApO1xuXG4gICAgaWYgKGRpcmVjdGx5UmVwZWF0ZWRSdWxlTm9uQ29uc3VtaW5nKSB7XG4gICAgICBjb25zdCBkaXJlY3RseVJlcGVhdGVkUnVsZU5hbWUgPSBkaXJlY3RseVJlcGVhdGVkUnVsZS5nZXROYW1lKCk7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRpcmVjdGx5IHJlcGVhdGVkICcke2RpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZX0nIHJ1bGUgaXMgbm9uLWNvbnN1bWluZy5gKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGVDeWNsZXMgPSBydWxlQ3ljbGVzRnJvbVJ1bGVOYW1lQW5kQ3ljbGVzKHJ1bGVOYW1lLCBjeWNsZXMpLFxuICAgICAgICAgIHJ1bGVDeWNsZXNJcnJlZHVjaWJsZSA9IHJ1bGVDeWNsZXMuZXZlcnkoKHJ1bGVDeWNsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVsZUN5Y2xlSXJyZWR1Y2libGUgPSBpc0N5Y2xlSXJyZWR1Y2libGUocnVsZUN5Y2xlLCBydWxlTWFwKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGVDeWNsZUlycmVkdWNpYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgaWYgKHJ1bGVDeWNsZXNJcnJlZHVjaWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25lIG9mIHRoZSBjeWNsZXMgaW5jbHVkaW5nIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUgaGF2ZSBhIHJlZHVjZWQgcnVsZS5gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBydWxlc0Zyb21SdWxlKFJ1bGUsIHJ1bGVNYXApIHtcbiAgY29uc3QgcnVsZXMgPSBPYmplY3QudmFsdWVzKHJ1bGVNYXApOyAvLy9cblxuICBmaWx0ZXIocnVsZXMsIChydWxlKSA9PiB7XG4gICAgY29uc3QgcnVsZVJ1bGUgPSAocnVsZSBpbnN0YW5jZW9mIFJ1bGUpO1xuXG4gICAgaWYgKHJ1bGVSdWxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBydWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IERpcmVjdGx5UmVwZWF0ZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVwZWF0ZWQvZGlyZWN0bHlcIjtcblxuaW1wb3J0IHsgcnVsZU5hbWVzRnJvbUN5Y2xlcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jeWNsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKSB7XG4gIGNvbnN0IHJ1bGVOYW1lcyA9IHJ1bGVOYW1lc0Zyb21DeWNsZXMoY3ljbGVzKTtcblxuICBydWxlTmFtZXMuZm9yRWFjaCgocnVsZU5hbWUpID0+IHtcbiAgICBjb25zdCBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgICAgZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBEaXJlY3RseVJlcGVhdGVkUnVsZS5mcm9tUnVsZUFuZEN5Y2xlcyhydWxlLCBjeWNsZXMsIHJ1bGVNYXApLFxuICAgICAgICAgIGRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGRpcmVjdGx5UmVwZWF0ZWRSdWxlLmdldE5hbWUoKTtcblxuICAgIHJ1bGVNYXBbZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lXSA9IGRpcmVjdGx5UmVwZWF0ZWRSdWxlO1xuICB9KTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUGFydHMsIERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IEVwc2lsb25QYXJ0IH0gPSBQYXJ0cztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXBzaWxvbkRlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgc3RhdGljIGZyb21QcmVjZWRlbmNlKHByZWNlZGVuY2UpIHtcbiAgICBjb25zdCBlcHNpbG9uUGFydCA9IEVwc2lsb25QYXJ0LmZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBlcHNpbG9uUGFydFxuICAgICAgICAgIF0sXG4gICAgICAgICAgZXBzaWxvbkRlZmluaXRpb24gPSBFcHNpbG9uRGVmaW5pdGlvbi5mcm9tUGFydHNBbmRQcmVjZWRlbmNlKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBlcHNpbG9uRGVmaW5pdGlvbjtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVQYXJ0c0VxdWFsKHBhcnRzKSB7XG4gIGNvbnN0IGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgZmlyc3RQYXJ0U3RyaW5nID0gZmlyc3RQYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgIHBhcnRzRXF1YWwgPSBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcnRTdHJpbmcgPSBwYXJ0LmFzU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcGFydFN0cmluZ0ZpcnN0UGFydFN0cmluZyA9IChwYXJ0U3RyaW5nID09PSBmaXJzdFBhcnRTdHJpbmcpO1xuXG4gICAgICAgICAgaWYgKHBhcnRTdHJpbmdGaXJzdFBhcnRTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHBhcnRzRXF1YWw7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRUeXBlcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmNvbnN0IHsgUnVsZU5hbWVQYXJ0VHlwZSxcbiAgICAgICAgT3B0aW9uYWxQYXJ0UGFydFR5cGUsXG4gICAgICAgIENob2ljZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgT25lT3JNb3JlUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUsXG4gICAgICAgIFNlcXVlbmNlT2ZQYXJ0c1BhcnRUeXBlIH0gPSBwYXJ0VHlwZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bGVOb25Qcm9kdWNpbmcocnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzID0gW10pIHtcbiAgbGV0IHJ1bGVOb25Qcm9kdWNpbmcgPSBmYWxzZTtcblxuICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICBpZiAoIXJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICBydWxlTmFtZXMgPSBbIC8vL1xuICAgICAgLi4ucnVsZU5hbWVzLFxuICAgICAgcnVsZU5hbWVcbiAgICBdO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSBydWxlLmdldERlZmluaXRpb25zKCksXG4gICAgICAgICAgZGVmaW5pdGlvbnNOb25Qcm9kdWNpbmcgPSBhcmVEZWZpbml0aW9uc05vblByb2R1Y2luZyhkZWZpbml0aW9ucywgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIHJ1bGVOb25Qcm9kdWNpbmcgPSBkZWZpbml0aW9uc05vblByb2R1Y2luZzsgLy8vXG4gIH1cblxuICByZXR1cm4gcnVsZU5vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gYXJlRGVmaW5pdGlvbnNOb25Qcm9kdWNpbmcoZGVmaW5pdGlvbnMsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBjb25zdCBkZWZpbml0aW9uc05vblByb2R1Y2luZyA9IGRlZmluaXRpb25zLmV2ZXJ5KChkZWZpbml0aW9uKSA9PiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk5vblByb2R1Y2luZyA9IGlzRGVmaW5pdGlvbk5vblByb2R1Y2luZyhkZWZpbml0aW9uLCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgaWYgKGRlZmluaXRpb25Ob25Qcm9kdWNpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlZmluaXRpb25zTm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluaXRpb25Ob25Qcm9kdWNpbmcoZGVmaW5pdGlvbiwgcnVsZU1hcCwgcnVsZU5hbWVzKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBwYXJ0c05vblByb2R1Y2luZyA9IGFyZVBhcnRzTm9uUHJvZHVjaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpLFxuICAgICAgICBkZWZpbml0aW9uTm9uUHJvZHVjaW5nID0gcGFydHNOb25Qcm9kdWNpbmc7XG5cbiAgcmV0dXJuIGRlZmluaXRpb25Ob25Qcm9kdWNpbmc7XG59XG5cbmZ1bmN0aW9uIGFyZVBhcnRzTm9uUHJvZHVjaW5nKHBhcnRzLCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgY29uc3QgcGFydHNOb25Qcm9kdWNpbmcgPSBwYXJ0cy5ldmVyeSgocGFydCkgPT4ge1xuICAgIGNvbnN0IHBhcnROb25Qcm9kdWNpbmcgPSBpc1BhcnROb25Qcm9kdWNpbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgIGlmIChwYXJ0Tm9uUHJvZHVjaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJ0c05vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gaXNQYXJ0Tm9uUHJvZHVjaW5nKHBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcykge1xuICBsZXQgcGFydE5vblByb2R1Y2luZztcblxuICBjb25zdCBwYXJUZXJtaW5hbFBhcnQgPSBwYXJ0LmlzVGVybWluYWxQYXJ0KCk7XG5cbiAgaWYgKHBhclRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IHRlcm1pbmFsUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICB0ZXJtaW5hbFBhcnRVc2VsZXNzID0gaXNUZXJtaW5hbFBhcnROb25Qcm9kdWNpbmcodGVybWluYWxQYXJ0KTtcblxuICAgIHBhcnROb25Qcm9kdWNpbmcgPSB0ZXJtaW5hbFBhcnRVc2VsZXNzOyAvLy9cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub25UZXJtaW5hbE5QYXJ0ID0gcGFydCwgIC8vL1xuICAgICAgICAgIG5vblRlcm1pbmFsUGFydE5vblByb2R1Y2luZyA9IGlzTm9uVGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nKG5vblRlcm1pbmFsTlBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gbm9uVGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nOyAvLy9cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uUHJvZHVjaW5nO1xufVxuXG5mdW5jdGlvbiBpc1Rlcm1pbmFsUGFydE5vblByb2R1Y2luZyh0ZXJtaW5hbFBhcnQpIHtcbiAgY29uc3QgdGVybWluYWxQYXJ0Tm9uUHJvZHVjaW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRlcm1pbmFsUGFydE5vblByb2R1Y2luZztcbn1cblxuZnVuY3Rpb24gaXNOb25UZXJtaW5hbFBhcnROb25Qcm9kdWNpbmcobm9uVGVybWluYWxQYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpIHtcbiAgbGV0IHBhcnROb25Qcm9kdWNpbmcgPSBmYWxzZTtcblxuICBjb25zdCB0eXBlID0gbm9uVGVybWluYWxQYXJ0LmdldFR5cGUoKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgIGNvbnN0IHJ1bGVOYW1lUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBydWxlTmFtZVBhcnQuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSB8fCBudWxsO1xuXG4gICAgICBpZiAocnVsZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBydWxlTm9uUHJvZHVjaW5nID0gaXNSdWxlTm9uUHJvZHVjaW5nKHJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgICAgcGFydE5vblByb2R1Y2luZyA9IHJ1bGVOb25Qcm9kdWNpbmc7ICAvLy9cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgcGFydE5vblByb2R1Y2luZyA9IHRydWU7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgT25lT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3Qgb25lT3JNb3JlUGFydHNQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAgLy8vXG4gICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgcGFydE5vblByb2R1Y2luZyA9IGlzUGFydE5vblByb2R1Y2luZyhwYXJ0LCBydWxlTWFwLCBydWxlTmFtZXMpO1xuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlIFplcm9Pck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBwYXJ0Tm9uUHJvZHVjaW5nID0gdHJ1ZTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZToge1xuICAgICAgY29uc3Qgc2VxdWVuY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IHNlcXVlbmNlT2ZQYXJ0c1BhcnQuZ2V0UGFydHMoKSxcbiAgICAgICAgICAgIHBhcnRzTm9uUHJvZHVjaW5nID0gYXJlUGFydHNOb25Qcm9kdWNpbmcocGFydHMsIHJ1bGVNYXAsIHJ1bGVOYW1lcyk7XG5cbiAgICAgIHBhcnROb25Qcm9kdWNpbmcgPSBwYXJ0c05vblByb2R1Y2luZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICBjb25zdCBjaG9pY2VPZlBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICBwYXJ0cyA9IGNob2ljZU9mUGFydHNQYXJ0LmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c05vblByb2R1Y2luZyA9IHBhcnRzLmV2ZXJ5KChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnROb25Qcm9kdWNpbmcgPSBpc1BhcnROb25Qcm9kdWNpbmcocGFydCwgcnVsZU1hcCwgcnVsZU5hbWVzKTtcblxuICAgICAgICAgICAgICByZXR1cm4gcGFydE5vblByb2R1Y2luZztcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIHBhcnROb25Qcm9kdWNpbmcgPSBwYXJ0c05vblByb2R1Y2luZzsgLy8vXG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0Tm9uUHJvZHVjaW5nO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJ0VHlwZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzLFxuICAgICAgeyBSdWxlTmFtZVBhcnRUeXBlLFxuICAgICAgICBPcHRpb25hbFBhcnRQYXJ0VHlwZSxcbiAgICAgICAgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLFxuICAgICAgICBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZSxcbiAgICAgICAgWmVyb09yTW9yZVBhcnRzUGFydFR5cGUgfSA9IHBhcnRUeXBlcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkNvbXBsZXgoZGVmaW5pdGlvbikge1xuICBjb25zdCBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKSxcbiAgICAgICAgZmlyc3RQYXJ0ID0gZmlyc3QocGFydHMpLFxuICAgICAgICBmaXJzdFBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChmaXJzdFBhcnQpLFxuICAgICAgICBkZWZpbml0aW9uQ29tcGxleCA9IGZpcnN0UGFydENvbXBsZXg7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uQ29tcGxleDtcbn1cblxuZnVuY3Rpb24gaXNQYXJ0Q29tcGxleChwYXJ0KSB7XG4gIGxldCBwYXJ0Q29tcGxleCA9IHRydWU7XG5cbiAgY29uc3QgcGFydE5vblRlcm1pbmFsUGFydCA9IHBhcnQuaXNOb25UZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgIHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJ1bGVOYW1lUGFydFR5cGU6IHtcbiAgICAgICAgcGFydENvbXBsZXggPSBmYWxzZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPcHRpb25hbFBhcnRQYXJ0VHlwZToge1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LCAvLy9cbiAgICAgICAgICAgICAgcGFydCA9IG9wdGlvbmFsUGFydFBhcnQuZ2V0UGFydCgpO1xuXG4gICAgICAgIHBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChwYXJ0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIGNvbnN0IG9uZU9yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgIC8vL1xuICAgICAgICAgICAgICBwYXJ0ID0gb25lT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTtcblxuICAgICAgICBwYXJ0Q29tcGxleCA9IGlzUGFydENvbXBsZXgocGFydCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgWmVyb09yTW9yZVBhcnRzUGFydFR5cGU6IHtcbiAgICAgICAgY29uc3QgemVyb09yTW9yZVBhcnRzUGFydCA9IG5vblRlcm1pbmFsUGFydCwgLy8vXG4gICAgICAgICAgICAgIHBhcnQgPSB6ZXJvT3JNb3JlUGFydHNQYXJ0LmdldFBhcnQoKTsgIC8vL1xuXG4gICAgICAgIHBhcnRDb21wbGV4ID0gaXNQYXJ0Q29tcGxleChwYXJ0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBTZXF1ZW5jZU9mUGFydHNQYXJ0VHlwZTpcbiAgICAgIGNhc2UgQ2hvaWNlT2ZQYXJ0c1BhcnRUeXBlOiB7XG4gICAgICAgIHBhcnRDb21wbGV4ID0gdHJ1ZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydENvbXBsZXg7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHtpc1BhcnROb25Db25zdW1pbmd9IGZyb20gXCIuL25vbkNvbnN1bWluZ1wiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbk9jY2x1ZGVkKGRlZmluaXRpb24sIHJ1bGVNYXAsIHJ1bGVOYW1lcyA9IFtdKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIGZpcnN0UGFydE5vbkNvbnN1bWluZyA9IGlzUGFydE5vbkNvbnN1bWluZyhmaXJzdFBhcnQsIHJ1bGVNYXAsIHJ1bGVOYW1lcyksXG4gICAgICAgIGRlZmluaXRpb25PY2NsdWRlZCA9IGZpcnN0UGFydE5vbkNvbnN1bWluZzsgIC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uT2NjbHVkZWQ7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5pdGlvbkNhbGxBaGVhZChkZWZpbml0aW9uKSB7XG4gIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIGZpcnN0UGFydENhbGxBaGVhZCA9IGlzUGFydENhbGxBaGVhZChmaXJzdFBhcnQpLFxuICAgICAgICBkZWZpbml0aW9uQ2FsbEFoZWFkID0gZmlyc3RQYXJ0Q2FsbEFoZWFkOyAvLy9cblxuICByZXR1cm4gZGVmaW5pdGlvbkNhbGxBaGVhZDtcbn1cblxuZnVuY3Rpb24gaXNQYXJ0Q2FsbEFoZWFkKHBhcnQpIHtcbiAgbGV0IHBhcnRDYWxsQWhlYWQgPSBmYWxzZTtcblxuICBjb25zdCBwYXJ0Tm9uVGVybWluYWxQYXJ0ID0gcGFydC5pc05vblRlcm1pbmFsUGFydCgpO1xuXG4gIGlmIChwYXJ0Tm9uVGVybWluYWxQYXJ0KSB7XG4gICAgY29uc3Qgbm9uVGVybWluYWxQYXJ0ID0gcGFydCwgLy8vXG4gICAgICAgICAgbm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0ID0gbm9uVGVybWluYWxQYXJ0LmlzUnVsZU5hbWVQYXJ0KCk7XG5cbiAgICBpZiAobm9uVGVybWluYWxQYXJ0UnVsZU5hbWVQYXJ0KSB7XG4gICAgICBjb25zdCBydWxlTmFtZVBhcnQgPSBub25UZXJtaW5hbFBhcnQsIC8vL1xuICAgICAgICAgICAgY2FsbEFoZWFkID0gcnVsZU5hbWVQYXJ0LmlzQ2FsbEFoZWFkKCk7XG5cbiAgICAgIHBhcnRDYWxsQWhlYWQgPSBjYWxsQWhlYWQ7ICAvLy9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydENhbGxBaGVhZDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFydFR5cGVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5jb25zdCB7IE9wdGlvbmFsUGFydFBhcnRUeXBlLCBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlLCBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZSB9ID0gcGFydFR5cGVzO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFydFF1YWxpZmllZChwYXJ0KSB7XG4gIGxldCBwYXJ0UXVhbGlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgcGFydE5vblRlcm1pbmFsUGFydCA9IHBhcnQuaXNOb25UZXJtaW5hbFBhcnQoKTtcblxuICBpZiAocGFydE5vblRlcm1pbmFsUGFydCkge1xuICAgIGNvbnN0IG5vblRlcm1pbmFsUGFydCA9IHBhcnQsIC8vL1xuICAgICAgICAgIHR5cGUgPSBub25UZXJtaW5hbFBhcnQuZ2V0VHlwZSgpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIE9wdGlvbmFsUGFydFBhcnRUeXBlOlxuICAgICAgY2FzZSBPbmVPck1vcmVQYXJ0c1BhcnRUeXBlOlxuICAgICAgY2FzZSBaZXJvT3JNb3JlUGFydHNQYXJ0VHlwZToge1xuICAgICAgICBwYXJ0UXVhbGlmaWVkID0gdHJ1ZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydFF1YWxpZmllZDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbml0aW9uUXVhbGlmaWVkKGRlZmluaXRpb24pIHtcbiAgY29uc3QgcGFydHMgPSBkZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKSxcbiAgICAgICAgZmlyc3RQYXJ0UXVhbGlmaWVkID0gaXNQYXJ0UXVhbGlmaWVkKGZpcnN0UGFydCksXG4gICAgICAgIGRlZmluaXRpb25RdWFsaWZpZWQgPSBmaXJzdFBhcnRRdWFsaWZpZWQ7IC8vL1xuXG4gIHJldHVybiBkZWZpbml0aW9uUXVhbGlmaWVkO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IFJ1bGUsIERlZmluaXRpb24gfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgRXBzaWxvbkRlZmluaXRpb24gZnJvbSBcIi4uLy4uL2RlZmluaXRpb24vZXBzaWxvblwiO1xuaW1wb3J0IEluZGlyZWN0bHlSZXBlYXRlZE5vZGUgZnJvbSBcIi4uLy4uL25vZGUvcmVwZWF0ZWQvaW5kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBhcmVQYXJ0c0VxdWFsIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9wYXJ0c1wiO1xuaW1wb3J0IHsgaXNSdWxlTm9uUHJvZHVjaW5nIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9ub25Qcm9kdWNpbmdcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvbkNvbXBsZXggfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2NvbXBsZXhcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvbk9jY2x1ZGVkIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9vY2NsdWRlZFwiO1xuaW1wb3J0IHsgaXNEZWZpbml0aW9uQ2FsbEFoZWFkIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9jYWxsQWhlYWRcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvblF1YWxpZmllZCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcXVhbGlmaWVkXCI7XG5pbXBvcnQgeyBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZUZyb21SdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcnVsZU5hbWVcIjtcbmltcG9ydCB7IGlzRGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbiB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZVwiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaXJlY3RseVJlcGVhdGVkUnVsZSBleHRlbmRzIFJ1bGUge1xuICBOb25UZXJtaW5hbE5vZGVGcm9tUnVsZU5hbWUocnVsZU5hbWUsIHN0YXRlKSB7XG4gICAgY29uc3QgTm9uVGVybWluYWxOb2RlID0gSW5kaXJlY3RseVJlcGVhdGVkTm9kZTtcblxuICAgIHJldHVybiBOb25UZXJtaW5hbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVBbmRMZWZ0UmVjdXJzaXZlUnVsZShydWxlLCBsZWZ0UmVjdXJzaXZlUnVsZSwgcnVsZU1hcCkge1xuICAgIGxldCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSA9IGxlZnRSZWN1cnNpdmVSdWxlLmdldE5hbWUoKTtcblxuICAgIGxldCBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucy5maWx0ZXIoKGRlZmluaXRpb24pID0+IHsgIC8vL1xuICAgICAgY29uc3QgZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUgPSBpc0RlZmluaXRpb25MZWZ0UmVjdXJzaXZlKGRlZmluaXRpb24sIHJ1bGVNYXApO1xuXG4gICAgICBpZiAoZGVmaW5pdGlvbkxlZnRSZWN1cnNpdmUpIHtcbiAgICAgICAgY29uc3QgbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lcyA9IGxlZnRSZWN1cnNpdmVSdWxlTmFtZXNGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uLCBydWxlTWFwKSxcbiAgICAgICAgICAgICAgZmlyc3RMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPSBmaXJzdChsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzKTtcblxuICAgICAgICBpZiAoZmlyc3RMZWZ0UmVjdXJzaXZlUnVsZU5hbWUgPT09IGxlZnRSZWN1cnNpdmVSdWxlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gcnVsZS5nZXROYW1lKCksXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25Db21wbGV4ID0gaXNEZWZpbml0aW9uQ29tcGxleChkZWZpbml0aW9uKTtcblxuICAgICAgICAgIGlmIChkZWZpbml0aW9uQ29tcGxleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGxlZnQgcmVjdXJzaXZlLWRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyBjb21wbGV4LmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25PY2NsdWRlZCA9IGlzRGVmaW5pdGlvbk9jY2x1ZGVkKGRlZmluaXRpb24sIHJ1bGVNYXApO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25PY2NsdWRlZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvblN0cmluZyA9IGRlZmluaXRpb24uYXNTdHJpbmcoKTtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7ZGVmaW5pdGlvblN0cmluZ30nIGxlZnQgcmVjdXJzaXZlIGRlZmluaXRpb24gb2YgdGhlICcke3J1bGVOYW1lfScgcnVsZSBpcyBvY2NsdWRlZC5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkZWZpbml0aW9uQ2FsbEFoZWFkID0gaXNEZWZpbml0aW9uQ2FsbEFoZWFkKGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25DYWxsQWhlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpcnN0IHBhcnQgb2YgdGhlICcke2RlZmluaXRpb25TdHJpbmd9JyBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIG9mIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUgaXMgbG9vay1haGVhZC5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkZWZpbml0aW9uUXVhbGlmaWVkID0gaXNEZWZpbml0aW9uUXVhbGlmaWVkKGRlZmluaXRpb24pO1xuXG4gICAgICAgICAgaWYgKGRlZmluaXRpb25RdWFsaWZpZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZpcnN0IHBhcnQgb2YgdGhlICcke2RlZmluaXRpb25TdHJpbmd9JyBsZWZ0IHJlY3Vyc2l2ZSBkZWZpbml0aW9uIG9mIHRoZSAnJHtydWxlTmFtZX0nIHJ1bGUgaXMgcXVhbGlmaWVkLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaXJzdFBhcnRzRXF1YWwgPSBhcmVGaXJzdFBhcnRzRXF1YWwobGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zKTtcblxuICAgIGlmICghZmlyc3RQYXJ0c0VxdWFsKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaXJzdCBwYXJ0cyBvZiB0aGUgJyR7bGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lfScgbGVmdCByZWN1cnNpdmUgZGVmaW5pdGlvbnMgaW4gdGhlICcke3J1bGVOYW1lfScgcnVsZSBhcmUgbm90IGVxdWFsLmApO1xuICAgIH1cblxuICAgIGxldCBwcmVjZWRlbmNlID0gbnVsbDtcblxuICAgIGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucy5maWx0ZXIoKGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFBhcnRzKCksXG4gICAgICAgICAgICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICAgICAgaWYgKHBhcnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHByZWNlZGVuY2UgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRQcmVjZWRlbmNlKCk7XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBydWxlTmFtZSA9IHJ1bGUuZ2V0TmFtZSgpLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlT3BhY2l0eSA9IGxlZnRSZWN1cnNpdmVSdWxlLmdldE9wYWNpdHkoKSxcbiAgICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpLFxuICAgICAgICAgIG5hbWUgPSBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZSwgIC8vL1xuICAgICAgICAgIG9wYWNpdHkgPSBsZWZ0UmVjdXJzaXZlUnVsZU9wYWNpdHk7IC8vL1xuXG4gICAgZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9uc0Zyb21MZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMobGVmdFJlY3Vyc2l2ZURlZmluaXRpb25zKTtcblxuICAgIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPSBuZXcgSW5kaXJlY3RseVJlcGVhdGVkUnVsZShuYW1lLCBvcGFjaXR5LCBkZWZpbml0aW9ucyksXG4gICAgICAgICAgaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5vblByb2R1Y2luZyA9IGlzUnVsZU5vblByb2R1Y2luZyhpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlLCBydWxlTWFwKTtcblxuICAgIGlmIChpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTm9uUHJvZHVjaW5nKSB7XG4gICAgICBjb25zdCBlcHNpbG9uRGVmaW5pdGlvbiA9IEVwc2lsb25EZWZpbml0aW9uLmZyb21QcmVjZWRlbmNlKHByZWNlZGVuY2UpO1xuXG4gICAgICBkZWZpbml0aW9ucy5wdXNoKGVwc2lsb25EZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaXJlY3RseVJlcGVhdGVkUnVsZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcmVGaXJzdFBhcnRzRXF1YWwoZGVmaW5pdGlvbnMpIHtcbiAgY29uc3QgZmlyc3RQYXJ0cyA9IGRlZmluaXRpb25zLm1hcCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5nZXRQYXJ0cygpLFxuICAgICAgICAgICAgICAgIGZpcnN0UGFydCA9IGZpcnN0KHBhcnRzKTtcblxuICAgICAgICAgIHJldHVybiBmaXJzdFBhcnQ7XG4gICAgICAgIH0pLFxuICAgICAgICBmaXJzdFBhcnRzRXF1YWwgPSBhcmVQYXJ0c0VxdWFsKGZpcnN0UGFydHMpO1xuXG4gIHJldHVybiBmaXJzdFBhcnRzRXF1YWw7XG59XG5cbmZ1bmN0aW9uIGRlZmluaXRpb25zRnJvbUxlZnRSZWN1cnNpdmVEZWZpbml0aW9ucyhsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMpIHtcbiAgY29uc3QgZGVmaW5pdGlvbnMgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbnMubWFwKChsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbikgPT4geyAvLy9cbiAgICAgICAgICBsZXQgcGFydHMgPSBsZWZ0UmVjdXJzaXZlRGVmaW5pdGlvbi5nZXRQYXJ0cygpO1xuXG4gICAgICAgICAgcGFydHMgPSBbIC8vL1xuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgICBdXG5cbiAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgY29uc3QgcHJlY2VkZW5jZSA9IGxlZnRSZWN1cnNpdmVEZWZpbml0aW9uLmdldFByZWNlZGVuY2UoKSxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gRGVmaW5pdGlvbi5mcm9tUGFydHNBbmRQcmVjZWRlbmNlKHBhcnRzLCBwcmVjZWRlbmNlKTtcblxuICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gZGVmaW5pdGlvbnM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBJbmRpcmVjdGx5UmVwZWF0ZWRSdWxlIGZyb20gXCIuL3J1bGUvcmVwZWF0ZWQvaW5kaXJlY3RseVwiO1xuXG5pbXBvcnQgeyBydWxlTmFtZXNGcm9tQ3ljbGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvY3ljbGVcIjtcbmltcG9ydCB7IGZvckVhY2hSdWxlTmFtZUFuZExlZnRSZWN1cnNpdmVSdWxlTmFtZSB9IGZyb20gXCIuL3V0aWxpdGllcy9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lRnJvbVJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3J1bGVOYW1lXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUluZGlyZWN0bHlSZXBlYXRlZFJ1bGVzKGN5Y2xlcywgcnVsZU1hcCkge1xuICBjeWNsZXMuZm9yRWFjaCgoY3ljbGUpID0+IHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBydWxlTmFtZXNGcm9tQ3ljbGUoY3ljbGUpO1xuXG4gICAgZm9yRWFjaFJ1bGVOYW1lQW5kTGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lKHJ1bGVOYW1lcywgKHJ1bGVOYW1lLCBsZWZ0UmVjdXJzaXZlUnVsZU5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lID0gaW5kaXJlY3RseVJlcGVhdGVkUnVsZU5hbWVGcm9tUnVsZU5hbWVBbmRMZWZ0UmVjdXJzaXZlUnVsZU5hbWUocnVsZU5hbWUsIGxlZnRSZWN1cnNpdmVSdWxlTmFtZSk7XG5cbiAgICAgIGxldCBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlID0gcnVsZU1hcFtpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlTmFtZV0gfHwgbnVsbDtcblxuICAgICAgaWYgKGluZGlyZWN0bHlSZXBlYXRlZFJ1bGUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICAgICAgICBsZWZ0UmVjdXJzaXZlUnVsZSA9IHJ1bGVNYXBbbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lXTtcblxuICAgICAgICBpbmRpcmVjdGx5UmVwZWF0ZWRSdWxlID0gSW5kaXJlY3RseVJlcGVhdGVkUnVsZS5mcm9tUnVsZUFuZExlZnRSZWN1cnNpdmVSdWxlKHJ1bGUsIGxlZnRSZWN1cnNpdmVSdWxlLCBydWxlTWFwKTtcblxuICAgICAgICBydWxlTWFwW2luZGlyZWN0bHlSZXBlYXRlZFJ1bGVOYW1lXSA9IGluZGlyZWN0bHlSZXBlYXRlZFJ1bGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IHJ1bGVzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IERpcmVjdGVkR3JhcGggZnJvbSBcIi4vZGlyZWN0ZWRHcmFwaFwiO1xuaW1wb3J0IGNyZWF0ZVJlZHVjZWRSdWxlcyBmcm9tIFwiLi9jcmVhdGVSZWR1Y2VkUnVsZXNcIjtcbmltcG9ydCByZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzIGZyb20gXCIuL3Jld3JpdGVMZWZ0UmVjdXJzaXZlUnVsZXNcIjtcbmltcG9ydCBjcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXMgZnJvbSBcIi4vY3JlYXRlRGlyZWN0bHlSZXBlYXRlZFJ1bGVzXCI7XG5pbXBvcnQgY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXMgZnJvbSBcIi4vY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXNcIjtcblxuaW1wb3J0IHsgZWRnZXNGcm9tU3RhcnRSdWxlIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2RpcmVjdGVkR3JhcGhcIjtcbmltcG9ydCB7IExFRlRfUkVDVVJTSVZFX0xBQkVMIH0gZnJvbSBcIi4vbGFiZWxzXCI7XG5pbXBvcnQgeyBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVJ1bGUgfSBmcm9tIFwiLi91dGlsaXRpZXMvbGVmdFJlY3Vyc2l2ZVwiO1xuXG5jb25zdCB7IGZpbHRlciB9ID0gYXJyYXlVdGlsaXRpZXMsXG4gICAgICB7IHJ1bGVNYXBGcm9tUnVsZXMsIHN0YXJ0UnVsZUZyb21SdWxlcywgcnVsZXNGcm9tU3RhcnRSdWxlQW5kUnVsZU1hcCB9ID0gcnVsZXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpIHtcbiAgY29uc3QgcnVsZU1hcCA9IHJ1bGVNYXBGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBzdGFydFJ1bGUgPSBzdGFydFJ1bGVGcm9tUnVsZXMocnVsZXMpLFxuICAgICAgICBydWxlTmFtZXNNYXAgPSBydWxlTmFtZXNNYXBGcm9tTm90aGluZyhydWxlTWFwKSxcbiAgICAgICAgY3ljbGVzID0gY3ljbGVzRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCk7XG5cbiAgY3JlYXRlUmVkdWNlZFJ1bGVzKGN5Y2xlcywgcnVsZU1hcCk7XG5cbiAgY3JlYXRlSW5kaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKTtcblxuICBjcmVhdGVEaXJlY3RseVJlcGVhdGVkUnVsZXMoY3ljbGVzLCBydWxlTWFwKTtcblxuICByZXdyaXRlTGVmdFJlY3Vyc2l2ZVJ1bGVzKGN5Y2xlcywgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKTtcblxuICBydWxlcyA9IHJ1bGVzRnJvbVN0YXJ0UnVsZUFuZFJ1bGVNYXAoc3RhcnRSdWxlLCBydWxlTWFwKTsgLy8vXG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RlZEdyYXBoRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCkge1xuICBjb25zdCBzdGFydFJ1bGVOYW1lID0gc3RhcnRSdWxlLmdldE5hbWUoKSxcbiAgICAgICAgZWRnZXMgPSBlZGdlc0Zyb21TdGFydFJ1bGUoc3RhcnRSdWxlLCBydWxlTWFwLCBydWxlTmFtZXNNYXApLFxuICAgICAgICBzdGFydFZlcnRleCA9IHN0YXJ0UnVsZU5hbWUsICAvLy9cbiAgICAgICAgZGlyZWN0ZWRHcmFwaCA9IERpcmVjdGVkR3JhcGguZnJvbUVkZ2VzQW5kU3RhcnRWZXJ0ZXgoZWRnZXMsIHN0YXJ0VmVydGV4KTtcblxuICByZXR1cm4gZGlyZWN0ZWRHcmFwaDtcbn1cblxuZnVuY3Rpb24gcnVsZU5hbWVzTWFwRnJvbU5vdGhpbmcocnVsZU1hcCkge1xuICBjb25zdCBydWxlTmFtZXNNYXAgPSB7fSxcbiAgICAgICAgcnVsZU5hbWVzID0gT2JqZWN0LmtleXMocnVsZU1hcCk7XG5cbiAgcnVsZU5hbWVzLmZvckVhY2goKHJ1bGVOYW1lKSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICAgIGxlZnRSZWN1cnNpdmVSdWxlTmFtZXMgPSBsZWZ0UmVjdXJzaXZlUnVsZU5hbWVzRnJvbVJ1bGUocnVsZSwgcnVsZU1hcCksXG4gICAgICAgICAgcnVsZU5hbWVzID0gbGVmdFJlY3Vyc2l2ZVJ1bGVOYW1lczsgLy8vXG5cbiAgICBydWxlTmFtZXNNYXBbcnVsZU5hbWVdID0gcnVsZU5hbWVzO1xuICB9KTtcblxuICByZXR1cm4gcnVsZU5hbWVzTWFwO1xufVxuXG5mdW5jdGlvbiBpc0N5Y2xlTGVmdFJlY3Vyc2l2ZShjeWNsZSkge1xuICBjb25zdCBjeWNsZUxlZnRSZWN1cnNpdmUgPSBjeWNsZS5ldmVyeUVkZ2UoKGVkZ2UpID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IGVkZ2UuZ2V0TGFiZWwoKSxcbiAgICAgICAgICBsYWJlbExlZnRSZWN1cnNpdmVMYWJlbCA9IChsYWJlbCA9PT0gTEVGVF9SRUNVUlNJVkVfTEFCRUwpLFxuICAgICAgICAgIGVkZ2VMZWZ0UmVjdXJzaXZlID0gbGFiZWxMZWZ0UmVjdXJzaXZlTGFiZWw7ICAvLy9cblxuICAgIGlmIChlZGdlTGVmdFJlY3Vyc2l2ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY3ljbGVMZWZ0UmVjdXJzaXZlO1xufVxuXG5mdW5jdGlvbiBjeWNsZXNGcm9tU3RhcnRSdWxlKHN0YXJ0UnVsZSwgcnVsZU1hcCwgcnVsZU5hbWVzTWFwKSB7XG4gIGNvbnN0IGRpcmVjdGVkR3JhcGggPSBkaXJlY3RlZEdyYXBoRnJvbVN0YXJ0UnVsZShzdGFydFJ1bGUsIHJ1bGVNYXAsIHJ1bGVOYW1lc01hcCksXG4gICAgICAgIGN5Y2xlcyA9IGRpcmVjdGVkR3JhcGguZmluZEN5Y2xlcygpO1xuXG4gIGZpbHRlcihjeWNsZXMsIChjeWNsZSkgPT4ge1xuICAgIGNvbnN0IGN5Y2xlTGVmdFJlY3Vyc2l2ZSA9IGlzQ3ljbGVMZWZ0UmVjdXJzaXZlKGN5Y2xlKTtcblxuICAgIGlmIChjeWNsZUxlZnRSZWN1cnNpdmUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGN5Y2xlcztcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIEV4YW1wbGVMZXhlciB9IGZyb20gXCIuL2V4YW1wbGUvbGV4ZXIvZXhhbXBsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeGFtcGxlUGFyc2VyIH0gZnJvbSBcIi4vZXhhbXBsZS9wYXJzZXIvZXhhbXBsZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24gfSBmcm9tIFwiLi9lbGltaW5hdGVMZWZ0UmVjdXJzaW9uXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIm9jY2FtLXF1ZXJ5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlUXVlcnkoZXhwcmVzc2lvblN0cmluZykge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgbm9kZSA9IG5vZGVzLnNoaWZ0KCkgfHwgbnVsbDsgLy8vXG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnkoZXhwcmVzc2lvblN0cmluZykge1xuICBjb25zdCBxdWVyeSA9IFF1ZXJ5LmZyb21FeHByZXNzaW9uU3RyaW5nKGV4cHJlc3Npb25TdHJpbmcpO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBxdWVyeS5leGVjdXRlKG5vZGUpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgZW50cmllcyA9IFtcclxuICB7XHJcbiAgICBcInNwZWNpYWxcIjogXCJeKD86XFxcXCRcXFxcJHxcXFxcJHxcXFxcXFxcXFxcXFwofFxcXFxcXFxcXFxcXCl8XFxcXFxcXFxcXFxcW3xcXFxcXFxcXFxcXFxdKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeKD86Lis/KD89XFxcXCRcXFxcJHxcXFxcJHxcXFxcXFxcXFxcXFwofFxcXFxcXFxcXFxcXCl8XFxcXFxcXFxcXFxcW3xcXFxcXFxcXFxcXFxdKXwuKylcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcblxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb21tb25MZXhlciwgV2hpdGVzcGFjZVRva2VuLCBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVYTGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XHJcbiAgc3RhdGljIGVudHJpZXMgPSBlbnRyaWVzO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVOb25TaWduaWZpY2FudFRva2VuO1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhUZVhMZXhlcik7IH1cclxuXHJcbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKFRlWExleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKFRlWExleGVyLCBlbnRyaWVzKTsgfVxyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/Oix8OnxcXFxce3xcXFxcfXxcXFxcW3xcXFxcXSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJudW1iZXJcIjogXCJeLT9bMS05XVswLTldKihcXFxcLlswLTldKyk/XCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYm9vbGVhblwiOiBcIl4oPzp0cnVlfGZhbHNlKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bGxcIjogXCJeKD86bnVsbClcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsXHJcbiAgICAgICAgIFdoaXRlc3BhY2VUb2tlbixcclxuICAgICAgICAgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbixcclxuICAgICAgICAgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xyXG5cclxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNPTkxleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xyXG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXHJcblxyXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2xlTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIEVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoSlNPTkxleGVyKTsgfVxyXG5cclxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tUnVsZXMoSlNPTkxleGVyLCBydWxlcyk7IH1cclxuXHJcbiAgc3RhdGljIGZyb21FbnRyaWVzKGVudHJpZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21FbnRyaWVzKEpTT05MZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBMQVRJTiA9IFwiW1xcXFxwe1NjcmlwdD1MYXRpbn1dXCIsXHJcbiAgICAgIERFQ0lNQUwgPSBcIlswLTldXCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwidHlwZVwiOiBcIl4oPzpOb2Rlc3xOb2RlfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbilcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJxdWVyeVwiOiBcIl4oPzpub2RlUXVlcnl8bm9kZXNRdWVyeSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJwcmltYXJ5LWtleXdvcmRcIjogXCJecmV0dXJuXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwic2Vjb25kYXJ5LWtleXdvcmRcIjogXCJeKD86aWZ8ZWxzZXxyZWR1Y2V8ZXZlcnl8c29tZXxhcylcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJudWxsXCI6IFwiXm51bGxcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJib29sZWFuXCI6IFwiXig/OnRydWV8ZmFsc2UpXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwiYnJhY2tldFwiOiBcIl4oPzpcXFxce3xcXFxcfSlcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJzcGVjaWFsXCI6IFwiXig/OiE9fD09fCF8PXwsfDt8X3wmJnxcXFxcfFxcXFx8fFxcXFwofFxcXFwpfFxcXFxbfFxcXFxdKVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogYF4ke0xBVElOfSske0RFQ0lNQUx9KmAsXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm51bWJlclwiOiBgXiR7REVDSU1BTH0rYFxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29tbW9uTGV4ZXIsXHJcbiAgICAgICAgIFdoaXRlc3BhY2VUb2tlbixcclxuICAgICAgICAgRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbixcclxuICAgICAgICAgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuLFxyXG4gICAgICAgICBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVTaW5nbGVMaW5lQ29tbWVudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZUVuZE9mTXVsdGlMaW5lQ29tbWVudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXJ0bGVMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBFbmRPZkxpbmVDb21tZW50Tm9uU2lnbmlmaWNhbnRUb2tlbjtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoRnVydGxlTGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhGdXJ0bGVMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhGdXJ0bGVMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBHUkVFSyA9IFwiW1xcXFxwe1NjcmlwdD1HcmVla31dXCIsXHJcbiAgICAgIExBVElOID0gXCJbXFxcXHB7U2NyaXB0PUxhdGlufV1cIixcclxuICAgICAgREVDSU1BTCA9IFwiWzAtOV1cIixcclxuICAgICAgTEFUSU5fTE9XRVJfQ0FTRSA9IFwiW1xcXFxwe1NjcmlwdD1MYXRpbn0mJlxcXFxwe0xvd2VyY2FzZX1dXCIsXHJcbiAgICAgIExBVElOX1VQUEVSX0NBU0UgPSBcIltcXFxccHtTY3JpcHQ9TGF0aW59JiZcXFxccHtVcHBlcmNhc2V9XVwiLFxyXG4gICAgICBNQVRIRU1BVElDQUxfU0FOU19TRVJJRl9CT0xEID0gXCJbXFxcXHV7MUQ1RDR9LVxcXFx1ezFENjA3fV1cIixcclxuICAgICAgTUFUSEVNQVRJQ0FMX0lUQUxJQ19VUFBFUl9DQVNFID0gXCJbXFxcXHV7MUQ0MzR9LVxcXFx1ezFENDREfV1cIixcclxuICAgICAgTUFUSEVNQVRJQ0FMX1NDUklQVF9VUFBFUl9DQVNFID0gXCJbXFxcXHV7MUQ0OUN9XFxcXHV7MjEyQ31cXFxcdXsxRDQ5RX1cXFxcdXsxRDQ5Rn1cXFxcdXsyMTMwfVxcXFx1ezIxMzF9XFxcXHV7MUQ0QTJ9XFxcXHV7MjEwQn1cXFxcdXsyMTEwfVxcXFx1ezFENEE1fVxcXFx1ezFENEE2fVxcXFx1ezIxMTJ9XFxcXHV7MjEzM31cXFxcdXsxRDRBOX0tXFxcXHV7MUQ0QUN9XFxcXHV7MjExQn1cXFxcdXsxRDRBRX0tXFxcXHV7MUQ0QjV9XVwiLFxyXG4gICAgICBNQVRIRU1BVElDQUxfRlJBS1RVUl9VUFBFUl9DQVNFID0gXCJbXFxcXHV7MUQ1MDR9XFxcXHV7MUQ1MDV9XFxcXHV7MjEyRH1cXFxcdXsxRDUwN30tXFxcXHV7MUQ1MEF9XFxcXHV7MjEwQ31cXFxcdXsyMTExfVxcXFx1ezFENTBEfS1cXFxcdXsxRDUxNH1cXFxcdXsyMTFDfVxcXFx1ezFENTE2fS1cXFxcdXsxRDUxQ31cXFxcdXsyMTI4fV1cIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJwcmltYXJ5LWtleXdvcmRcIjogXCJeKD86UnVsZXxBeGlvbXxUaGVvcmVtfExlbW1hfENvbmplY3R1cmV8TWV0YUxlbW1hfE1ldGF0aGVvcmVtfFByZW1pc2VzfFByZW1pc2V8Q29uY2x1c2lvbnxQcm9vZnxUaGVyZWZvcmV8U3VwcG9zZXxIZW5jZXxUaGVufFByb3Zpc2lvbmFsfFR5cGV8VHlwZVByZWZpeHxQcm9wZXJ0aWVzfFByb3BlcnR5fFZhcmlhYmxlfENvbnN0cnVjdG9yfENvbWJpbmF0b3J8TWV0YXZhcmlhYmxlfEdpdmVuKVxcXFxiXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwic2Vjb25kYXJ5LWtleXdvcmRcIjogXCJeKD86aXN8aW58YW58YXxvZnxieXxmcm9tfGJlY2F1c2V8Zm9yfHNhdGlzZmllc3xwcm92aXNpb25hbGx5fGRlZmluZWR8dW5kZWZpbmVkfG1pc3Npbmd8cHJlc2VudClcXFxcYlwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm1ldGEtdHlwZVwiOiBcIl4oPzpTdGF0ZW1lbnR8UmVmZXJlbmNlfEZyYW1lKVxcXFxiXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBgXig/OiR7TEFUSU5fVVBQRVJfQ0FTRX0ke0xBVElOfSoke0RFQ0lNQUx9Knwke0xBVElOX0xPV0VSX0NBU0V9JHtMQVRJTn0rJHtERUNJTUFMfSopYCxcclxuICB9LFxyXG4gIHtcclxuICAgIFwiaWRlbnRpZmllclwiOiBgXig/OiR7TEFUSU5fTE9XRVJfQ0FTRX0ke0RFQ0lNQUx9Knwke0dSRUVLfSt8JHtNQVRIRU1BVElDQUxfU0FOU19TRVJJRl9CT0xEfSt8JHtNQVRIRU1BVElDQUxfSVRBTElDX1VQUEVSX0NBU0V9K3wke01BVEhFTUFUSUNBTF9TQ1JJUFRfVVBQRVJfQ0FTRX0rfCR7TUFUSEVNQVRJQ0FMX0ZSQUtUVVJfVVBQRVJfQ0FTRX0rKWBcclxuICB9LFxyXG4gIHtcclxuICAgIFwicHJpbWl0aXZlXCI6IFwiXig/OlxcXFx8fFxcXFwuXFxcXC5cXFxcLnxcXFxcKHxcXFxcKXxcXFxcW3xcXFxcXXxcXFxcK3wtfCx8PHw+KVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInNwZWNpYWxcIjogXCJeKD86QHw6Onw6fD0pXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXFxcXChcXFxcKVxcXFxbXFxcXF06LF0rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pbXBvcnQgeyBDb21tb25MZXhlcixcclxuICAgICAgICAgV2hpdGVzcGFjZVRva2VuLFxyXG4gICAgICAgICBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4sXHJcbiAgICAgICAgIEVuZE9mTGluZUNvbW1lbnRTaWduaWZpY2FudFRva2VuLFxyXG4gICAgICAgICBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4sXHJcbiAgICAgICAgIFB5dGhvblN0eWxlU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbixcclxuICAgICAgICAgUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcclxuXHJcbmltcG9ydCBlbnRyaWVzIGZyb20gXCIuL2VudHJpZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbWluYWxMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW47IC8vL1xyXG5cclxuICBzdGF0aWMgV2hpdGVzcGFjZVRva2VuID0gV2hpdGVzcGFjZVRva2VuO1xyXG5cclxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVDb21tZW50VG9rZW4gPSBFbmRPZkxpbmVDb21tZW50U2lnbmlmaWNhbnRUb2tlbjtcclxuXHJcbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVNpbmdsZUxpbmVDb21tZW50VG9rZW47XHJcblxyXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IFB5dGhvblN0eWxlRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBQeXRob25TdHlsZVN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW47ICAvLy9cclxuXHJcbiAgc3RhdGljIE1pZGRsZU9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gUHl0aG9uU3R5bGVNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbjsgIC8vL1xyXG5cclxuICBzdGF0aWMgU2luZ2x5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwiYWxwaGEtbnVtZXJpY1wiOiBcIl5bYS16QS1aMC05XStcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJwdW5jdHVhdGlvblwiOiBcIl5bQCxcXFxcLlxcXCInYF0rXCJcclxuICB9LFxyXG4gIHtcclxuICAgIFwidW5hc3NpZ25lZFwiOiBcIl5bXlxcXFxzXStcIlxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGVudHJpZXM7XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW4gfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XHJcblxyXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFpblRleHRMZXhlciBleHRlbmRzIENvbW1vbkxleGVyIHtcclxuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XHJcblxyXG4gIHN0YXRpYyBFbmRPZkxpbmVUb2tlbiA9IEVuZE9mTGluZVNpZ25pZmljYW50VG9rZW47ICAvLy5cclxuXHJcbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcclxuXHJcbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbGVMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIFJlZ3VsYXJFeHByZXNzaW9uVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgU3RhcnRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XHJcblxyXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xyXG5cclxuICBzdGF0aWMgRG91Ymx5UXVvdGVkU3RyaW5nTGl0ZXJhbFRva2VuID0gbnVsbDtcclxuXHJcbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbU5vdGhpbmcoUGxhaW5UZXh0TGV4ZXIpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhQbGFpblRleHRMZXhlciwgcnVsZXMpOyB9XHJcblxyXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhQbGFpblRleHRMZXhlciwgZW50cmllcyk7IH1cclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBlbnRyaWVzID0gW1xyXG4gIHtcclxuICAgIFwic3BlY2lhbFwiOiBcIl4oPzpcXFxcfHxcXFxcKHxcXFxcKXxcXFxcP3xcXFxcKnxcXFxcK3w6Oj18O3w8Tk9fV0hJVEVTUEFDRT58PEVORF9PRl9MSU5FPilcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJudW1iZXJcIjogXCJeKD86MHxbMS05XVswLTldKilcIlxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiXltcXFxcd35dK1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInR5cGVcIjogXCJeXFxcXFtbXlxcXFxdXStcXFxcXVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBcInVuYXNzaWduZWRcIjogXCJeW15cXFxcc10rXCJcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzO1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vbkxleGVyLCBXaGl0ZXNwYWNlVG9rZW4sIEVuZE9mTGluZU5vblNpZ25pZmljYW50VG9rZW4sIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcblxuaW1wb3J0IGVudHJpZXMgZnJvbSBcIi4vZW50cmllc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21HcmFtbWFyQk5GbkxleGVyIGV4dGVuZHMgQ29tbW9uTGV4ZXIge1xuICBzdGF0aWMgZW50cmllcyA9IGVudHJpZXM7XG5cbiAgc3RhdGljIEVuZE9mTGluZVRva2VuID0gRW5kT2ZMaW5lTm9uU2lnbmlmaWNhbnRUb2tlbjsgLy8vXG5cbiAgc3RhdGljIFdoaXRlc3BhY2VUb2tlbiA9IFdoaXRlc3BhY2VUb2tlbjtcblxuICBzdGF0aWMgRW5kT2ZMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgUmVndWxhckV4cHJlc3Npb25Ub2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBFbmRPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFN0YXJ0T2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBNaWRkbGVPZk11bHRpTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbiA9IERvdWJseVF1b3RlZFN0cmluZ0xpdGVyYWxUb2tlbjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tTm90aGluZyhDdXN0b21HcmFtbWFyQk5GbkxleGVyKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21SdWxlcyhDdXN0b21HcmFtbWFyQk5GbkxleGVyLCBydWxlcyk7IH1cblxuICBzdGF0aWMgZnJvbUVudHJpZXMoZW50cmllcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbUVudHJpZXMoQ3VzdG9tR3JhbW1hckJORm5MZXhlciwgZW50cmllcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IGVudHJpZXMgPSBbXHJcbiAge1xyXG4gICAgXCJ1bmFzc2lnbmVkXCI6IFwiXlteXFxcXHNdK1wiXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZW50cmllcztcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25MZXhlciwgV2hpdGVzcGFjZVRva2VuLCBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgZW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIgZXh0ZW5kcyBDb21tb25MZXhlciB7XG4gIHN0YXRpYyBlbnRyaWVzID0gZW50cmllcztcblxuICBzdGF0aWMgRW5kT2ZMaW5lVG9rZW4gPSBFbmRPZkxpbmVTaWduaWZpY2FudFRva2VuO1xuXG4gIHN0YXRpYyBXaGl0ZXNwYWNlVG9rZW4gPSBXaGl0ZXNwYWNlVG9rZW47XG5cbiAgc3RhdGljIEVuZE9mTGluZUNvbW1lbnRUb2tlbiA9IG51bGw7XG5cbiAgc3RhdGljIFNpbmdsZUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBSZWd1bGFyRXhwcmVzc2lvblRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgRW5kT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBTdGFydE9mTXVsdGlMaW5lQ29tbWVudFRva2VuID0gbnVsbDtcblxuICBzdGF0aWMgTWlkZGxlT2ZNdWx0aUxpbmVDb21tZW50VG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBTaW5nbHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBEb3VibHlRdW90ZWRTdHJpbmdMaXRlcmFsVG9rZW4gPSBudWxsO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uTGV4ZXIuZnJvbVJ1bGVzKEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIsIHJ1bGVzKTsgfVxuXG4gIHN0YXRpYyBmcm9tRW50cmllcyhlbnRyaWVzKSB7IHJldHVybiBDb21tb25MZXhlci5mcm9tRW50cmllcyhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLCBlbnRyaWVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgICggZGVsaW1pdGVkVGVYIHwgcGxhaW5NYXJrdXAgKSsgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIGRlbGltaXRlZFRlWCAgICAgICAgICAgICAgICAgICAgOjo9ICAgZG9sbGFyRGVsaW1pdGVyIGlubGluZVRlWCBkb2xsYXJEZWxpbWl0ZXIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBkb3VibGVEb2xsYXJEZWxpbWl0ZXIgZGlzcGxheVRlWCBkb3VibGVEb2xsYXJEZWxpbWl0ZXIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBvcGVuaW5nQnJhY2tldERlbGltaXRlciBpbmxpbmVUZVggY2xvc2luZ0JyYWNrZXREZWxpbWl0ZXIgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBvcGVuaW5nU3F1YXJlQnJhY2tldERlbGltaXRlciBkaXNwbGF5VGVYIGNsb3NpbmdTcXVhcmVCcmFja2V0RGVsaW1pdGVyIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgIFxuXG4gICAgXG4gICAgaW5saW5lVGVYICAgICAgICAgICAgICAgICAgICAgICA6Oj0gICBbdW5hc3NpZ25lZF0qIDtcblxuICAgIGRpc3BsYXlUZVggICAgICAgICAgICAgICAgICAgICAgOjo9ICAgW3VuYXNzaWduZWRdKiA7XG5cblxuXG4gICAgZG9sbGFyRGVsaW1pdGVyICAgICAgICAgICAgICAgICA6Oj0gICBcIiRcIiA7XG4gXG4gICAgZG91YmxlRG9sbGFyRGVsaW1pdGVyICAgICAgICAgICA6Oj0gICBcIiQkXCIgO1xuICAgIFxuXG4gICAgXG4gICAgb3BlbmluZ0JyYWNrZXREZWxpbWl0ZXIgICAgICAgICA6Oj0gICBcIlxcXFwoXCIgO1xuXG4gICAgY2xvc2luZ0JyYWNrZXREZWxpbWl0ZXIgICAgICAgICA6Oj0gICBcIlxcXFwpXCIgO1xuXG4gICAgb3BlbmluZ1NxdWFyZUJyYWNrZXREZWxpbWl0ZXIgICA6Oj0gICBcIlxcXFxbXCIgO1xuICAgIFxuICAgIGNsb3NpbmdTcXVhcmVCcmFja2V0RGVsaW1pdGVyICAgOjo9ICAgXCJcXFxcXVwiIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICBwbGFpbk1hcmt1cCAgICAgICAgICAgICAgICAgICAgIDo6PSAgIC4gO1xuXG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVYUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoVGVYUGFyc2VyKTsgfVxuXG4gIHN0YXRpYyBmcm9tQk5GKGJuZikgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21CTkYoVGVYUGFyc2VyLCBibmYpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21SdWxlcyhUZVhQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgOjo9ICBqc29uIGVycm9yKiBcbiAgICBcbiAgICAgICAgICAgICAgICAgICB8ICBlcnJvcisgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gIFxuICBcbiAgXG4gICAganNvbiAgICAgICAgIDo6PSAgYXJyYXkgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgb2JqZWN0IFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFtzdHJpbmctbGl0ZXJhbF0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgfCAgW2Jvb2xlYW5dIFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFtudW1iZXJdIFxuICAgIFxuICAgICAgICAgICAgICAgICAgIHwgIFtudWxsXSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICA7XG4gIFxuICBcbiAgXG4gICAgYXJyYXkuLiAgICAgIDo6PSAgXCJbXCIgKCBlbGVtZW50ICggXCIsXCIgZWxlbWVudCApKiApPyBub25zZW5zZT8gXCJdXCIgO1xuICBcbiAgXG4gICAgIFxuICAgIG9iamVjdC4uICAgICA6Oj0gIFwie1wiICggcHJvcGVydHkgKCBcIixcIiBwcm9wZXJ0eSApKiApPyBub25zZW5zZT8gXCJ9XCIgO1xuICBcbiAgXG4gICAgXG4gICAgcHJvcGVydHkgICAgIDo6PSAgW3N0cmluZy1saXRlcmFsXSBcIjpcIiBqc29uIDtcbiAgXG4gICAgXG5cbiAgICBlbGVtZW50ICAgICAgOjo9ICBqc29uIDtcbiAgXG4gICAgXG5cbiAgICBub25zZW5zZS4gICAgOjo9ICAoIFwiOlwiIHwgXCIsXCIgfCBbc3RyaW5nLWxpdGVyYWxdIHwgW251bWJlcl0gfCBbYm9vbGVhbl0gfCBbbnVsbF0gfCBbdW5hc3NpZ25lZF0gKSsgO1xuICAgIFxuXG5cbiAgICBlcnJvci4gICAgICAgOjo9ICAuIDtcbiAgICBcbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGJuZjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgQ29tbW9uUGFyc2VyIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcblxuaW1wb3J0IGJuZiBmcm9tIFwiLi9ibmZcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNPTlBhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEpTT05QYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihKU09OUGFyc2VyLCBibmYpOyB9XG5cbiAgc3RhdGljIGZyb21SdWxlcyhydWxlcykgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21SdWxlcyhKU09OUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYFxuXG4gICAgZG9jdW1lbnQgICAgICAgICAgICAgICAgOjo9ICAoIHByb2NlZHVyZURlY2xhcmF0aW9uIHwgZXJyb3IgKSsgO1xuICAgIFxuICAgIFxuICAgIFxuICAgIHByb2NlZHVyZURlY2xhcmF0aW9uICAgIDo6PSAgW3R5cGVdIGxhYmVsPE5PX1dISVRFU1BBQ0U+XCIoXCIgcGFyYW1ldGVycz8gXCIpXCIgcmV0dXJuQmxvY2sgO1xuICAgIFxuICAgIGFub255bW91c1Byb2NlZHVyZSAgICAgIDo6PSAgW3R5cGVdIFwiKFwiIHBhcmFtZXRlcnM/IFwiKVwiIHJldHVybkJsb2NrIDtcbiAgICBcbiAgICByZXR1cm5TdGF0ZW1lbnQgICAgICAgICA6Oj0gIFwicmV0dXJuXCIgdGVybSBcIjtcIiA7IFxuICAgIFxuICAgIFxuICAgIFxuICAgIHN0ZXAgICAgICAgICAgICAgICAgICAgIDo6PSAgYXJyYXlBc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9iamVjdEFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgdmFyaWFibGVBc3NpZ25tZW50c1xuICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgIFxuICAgICAgXG4gICAgICBcbiAgICBcbiAgICBhcnJheUFzc2lnbm1lbnQgICAgICAgICA6Oj0gIFwiW1wiIHBhcmFtZXRlcnMgXCJdXCIgXCI9XCIgdmFyaWFibGUgXCI7XCIgO1xuICAgIFxuICAgIG9iamVjdEFzc2lnbm1lbnQgICAgICAgIDo6PSAgXCJ7XCIgbmFtZWRQYXJhbWV0ZXJzIFwifVwiIFwiPVwiIHZhcmlhYmxlIFwiO1wiIDtcbiAgICBcbiAgICB2YXJpYWJsZUFzc2lnbm1lbnRzICAgICA6Oj0gIFt0eXBlXSB2YXJpYWJsZUFzc2lnbm1lbnQgKCBcIixcIiB2YXJpYWJsZUFzc2lnbm1lbnQgKSogXCI7XCIgO1xuICAgIFxuICAgIHZhcmlhYmxlQXNzaWdubWVudCAgICAgIDo6PSAgdmFyaWFibGUgXCI9XCIgZXhwcmVzc2lvbiA7XG4gICAgXG5cblxuICAgIG5hbWVkUGFyYW1ldGVycyAgICAgICAgIDo6PSAgbmFtZWRQYXJhbWV0ZXIgKCBcIixcIiBuYW1lZFBhcmFtZXRlciApKiA7XG4gICAgXG4gICAgcGFyYW1ldGVycyAgICAgICAgICAgICAgOjo9ICBwYXJhbWV0ZXIgKCBcIixcIiBwYXJhbWV0ZXIgKSogO1xuICAgIFxuICAgIHRlcm1zICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSAoIFwiLFwiIHRlcm0gKSogO1xuICAgIFxuXG5cbiAgICBuYW1lZFBhcmFtZXRlciAgICAgICAgICA6Oj0gIFt0eXBlXSBbbmFtZV0gKCBcImFzXCIgW25hbWVdICk/IDsgICBcbiAgICBcbiAgICBwYXJhbWV0ZXIgICAgICAgICAgICAgICA6Oj0gIFt0eXBlXSBbbmFtZV1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFwiX1wiIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBcbiAgICBwcm9jZWR1cmVDYWxsICAgICAgICAgICA6Oj0gIHJlZmVyZW5jZTxOT19XSElURVNQQUNFPlwiKFwiIHRlcm1zPyBcIilcIiA7XG4gICAgXG4gICAgcmV0dXJuQmxvY2suLiAgICAgICAgICAgOjo9ICBcIntcIiAoIHN0ZXAgfCBub25zZW5zZSApKiByZXR1cm5TdGF0ZW1lbnQgXCJ9XCIgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIG5vZGVzUXVlcnkgICAgICAgICAgICAgIDo6PSAgXCJub2Rlc1F1ZXJ5XCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBbc3RyaW5nLWxpdGVyYWxdIFwiKVwiIDtcbiAgICBcbiAgICBub2RlUXVlcnkgICAgICAgICAgICAgICA6Oj0gIFwibm9kZVF1ZXJ5XCI8Tk9fV0hJVEVTUEFDRT5cIihcIiB2YXJpYWJsZSBcIixcIiBbc3RyaW5nLWxpdGVyYWxdIFwiKVwiIDtcbiAgICBcbiAgICB0ZXJuYXJ5ICAgICAgICAgICAgICAgICA6Oj0gIFwiaWZcIiBcIihcIiB0ZXJtIFwiKVwiIGV4cHJlc3Npb24gXCJlbHNlXCIgZXhwcmVzc2lvbiA7XG4gICAgXG4gICAgcmVkdWNlICAgICAgICAgICAgICAgICAgOjo9ICBcInJlZHVjZVwiPE5PX1dISVRFU1BBQ0U+XCIoXCIgdmFyaWFibGUgXCIsXCIgYW5vbnltb3VzUHJvY2VkdXJlIFwiLFwiIGV4cHJlc3Npb24gXCIpXCIgO1xuICAgIFxuICAgIGV2ZXJ5ICAgICAgICAgICAgICAgICAgIDo6PSAgXCJldmVyeVwiPE5PX1dISVRFU1BBQ0U+XCIoXCIgdmFyaWFibGUgXCIsXCIgYW5vbnltb3VzUHJvY2VkdXJlIFwiKVwiIDtcbiAgICBcbiAgICBzb21lICAgICAgICAgICAgICAgICAgICA6Oj0gIFwic29tZVwiPE5PX1dISVRFU1BBQ0U+XCIoXCIgdmFyaWFibGUgXCIsXCIgYW5vbnltb3VzUHJvY2VkdXJlIFwiKVwiIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICBjb21wYXJpc29uVGVybSAgICAgICAgICA6Oj0gIHRlcm0gKCBcIj09XCIgfCBcIiE9XCIgKSB0ZXJtIDsgXG4gICAgXG4gICAgYnJhY2tldGVkVGVybSAgICAgICAgICAgOjo9ICBcIihcIiB0ZXJtIFwiKVwiIDsgXG4gICAgXG4gICAgbmVnYXRlZFRlcm0gICAgICAgICAgICAgOjo9ICBcIiFcIjxOT19XSElURVNQQUNFPnRlcm0gOyBcbiAgICBcbiAgICBsb2dpY2FsVGVybSAgICAgICAgICAgICA6Oj0gIHRlcm0gKCBcInx8XCIgfCBcIiYmXCIgKSB0ZXJtIDsgXG5cblxuICAgIFxuICAgIGV4cHJlc3Npb24gICAgICAgICAgICAgIDo6PSAgcHJvY2VkdXJlQ2FsbFxuICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJldHVybkJsb2NrXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub2Rlc1F1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vZGVRdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJuYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJlZHVjZVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgZXZlcnlcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICBcbiAgICBcbiAgICBcbiAgICB0ZXJtICAgICAgICAgICAgICAgICAgICA6Oj0gIGNvbXBhcmlzb25UZXJtIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgYnJhY2tldGVkVGVybSBcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIGxvZ2ljYWxUZXJtIFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbmVnYXRlZFRlcm0gXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBwcmltaXRpdmUgXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB2YXJpYWJsZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICBcbiAgICBwcmltaXRpdmUgICAgICAgICAgICAgICA6Oj0gIFtzdHJpbmctbGl0ZXJhbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW2Jvb2xlYW5dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtudW1iZXJdIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuXG4gICAgcmVmZXJlbmNlLiAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuICAgIFxuICAgIHZhcmlhYmxlICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcbiAgICBcbiAgICBsYWJlbC4gICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSA7XG4gICAgXG4gICAgXG4gICAgXG4gICAgbm9uc2Vuc2UuICAgICAgICAgICAgICAgOjo9ICBbc2Vjb25kYXJ5LWtleXdvcmRdIHwgW3R5cGVdIHwgW251bGxdIHwgW2Jvb2xlYW5dIHwgW3N0cmluZy1saXRlcmFsXSB8IFtxdWVyeV0gfCBbc3BlY2lhbF0gfCBbbmFtZV0gfCBbbnVtYmVyXSB8IFt1bmFzc2lnbmVkXSA7XG5cblxuICAgIFxuICAgIGVycm9yLiAgICAgICAgICAgICAgICAgIDo6PSAgLiA7XG4gICAgXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZVBhcnNlciBleHRlbmRzIENvbW1vblBhcnNlciB7XG4gIHN0YXRpYyBibmYgPSBibmY7XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkgeyByZXR1cm4gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKEZ1cnRsZVBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKEZ1cnRsZVBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoRnVydGxlUGFyc2VyLCBydWxlcyk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYm5mID0gYGRvY3VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gICggdmFyaWFibGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY29tYmluYXRvckRlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtZXRhdmFyaWFibGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHlwZVByZWZpeERlY2xhcmF0aW9uICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNpbXBsZVR5cGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY29tcGxleFR5cGVEZWNsYXJhdGlvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBydWxlIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGF4aW9tIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlbW1hIFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRoZW9yZW0gXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY29uamVjdHVyZSBcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBtZXRhTGVtbWEgXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbWV0YXRoZW9yZW0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHNlY3Rpb24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdmVydGljYWxTcGFjZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlcnJvciApKyA7XG5cblxuXG5zZWN0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkdpdmVuXCIgPEVORF9PRl9MSU5FPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoeXBvdGhlc2lzK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggYXhpb20gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbGVtbWEgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdGhlb3JlbSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjb25qZWN0dXJlICkgOyBcblxuXG5cbnZlcnRpY2FsU3BhY2UgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIDxFTkRfT0ZfTElORT4rIDtcblxuXG5cbmVycm9yLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIC4gO1xuXG5cblxudmFyaWFibGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICAgIDo6PSAgXCJWYXJpYWJsZVwiIHZhcmlhYmxlICggXCI6XCIgdHlwZSBcInByb3Zpc2lvbmFsbHlcIj8gKT8gPEVORF9PRl9MSU5FPiA7XG4gXG5jb21iaW5hdG9yRGVjbGFyYXRpb24gICAgICAgICAgICAgICAgOjo9ICBcIkNvbWJpbmF0b3JcIiBjb21iaW5hdG9yLi4uIDxFTkRfT0ZfTElORT4gO1xuIFxuY29uc3RydWN0b3JEZWNsYXJhdGlvbiAgICAgICAgICAgICAgIDo6PSAgXCJDb25zdHJ1Y3RvclwiIGNvbnN0cnVjdG9yLi4uICggXCI6XCIgdHlwZSBcInByb3Zpc2lvbmFsbHlcIj8gKT8gPEVORF9PRl9MSU5FPiA7XG4gXG5tZXRhdmFyaWFibGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgOjo9ICBcIk1ldGF2YXJpYWJsZVwiIG1ldGF2YXJpYWJsZS4uLiBcIjpcIiBtZXRhVHlwZSA8RU5EX09GX0xJTkU+IDtcbiBcbnR5cGVQcmVmaXhEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICA6Oj0gIFwiVHlwZVByZWZpeFwiIHR5cGVQcmVmaXggPEVORF9PRl9MSU5FPiA7XG5cbnNpbXBsZVR5cGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgICA6Oj0gIFwiUHJvdmlzaW9uYWxcIj8gXCJUeXBlXCIgdHlwZSAoIFwiOlwiIHR5cGVzICk/IDxFTkRfT0ZfTElORT4gO1xuIFxuY29tcGxleFR5cGVEZWNsYXJhdGlvbiAgICAgICAgICAgICAgIDo6PSAgXCJQcm92aXNpb25hbFwiPyBcIlR5cGVcIiA8RU5EX09GX0xJTkU+IFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlICggXCI6XCIgdHlwZXMgKT8gPEVORF9PRl9MSU5FPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBcIlByb3BlcnRpZXNcIiA8RU5EX09GX0xJTkU+IHByb3BlcnR5RGVjbGFyYXRpb24gcHJvcGVydHlEZWNsYXJhdGlvbisgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCJQcm9wZXJ0eVwiIDxFTkRfT0ZfTElORT4gcHJvcGVydHlEZWNsYXJhdGlvbiApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICBcblxuICBcbnJ1bGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHJ1bGVIZWFkZXIgcnVsZUJvZHkgOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbm1ldGFMZW1tYSAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIG1ldGFMZW1tYUhlYWRlciBtZXRhTGVtbWFCb2R5IDtcblxubWV0YXRoZW9yZW0gICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXRoZW9yZW1IZWFkZXIgbWV0YXRoZW9yZW1Cb2R5IDtcblxuYXhpb20gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgYXhpb21IZWFkZXIgYXhpb21Cb2R5IDtcblxubGVtbWEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbGVtbWFIZWFkZXIgbGVtbWFCb2R5IDtcblxudGhlb3JlbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGhlb3JlbUhlYWRlciB0aGVvcmVtQm9keSA7XG5cbmNvbmplY3R1cmUgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGNvbmplY3R1cmVIZWFkZXIgY29uamVjdHVyZUJvZHkgO1xuXG5cblxucnVsZUhlYWRlciAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIlJ1bGVcIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gOyBcblxubWV0YUxlbW1hSGVhZGVyICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIk1ldGFMZW1tYVwiIHBhcmVudGhlc2lzZWRMYWJlbC4uLiA8RU5EX09GX0xJTkU+IHwgXCJNZXRhTGVtbWFcIiA8RU5EX09GX0xJTkU+IDtcblxubWV0YXRoZW9yZW1IZWFkZXIgICAgICAgICAgICAgICAgICAgOjo9ICBcIk1ldGF0aGVvcmVtXCIgcGFyZW50aGVzaXNlZExhYmVsLi4uIDxFTkRfT0ZfTElORT4gOyBcblxuYXhpb21IZWFkZXIgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkF4aW9tXCIgc2lnbmF0dXJlPyBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gOyBcblxubGVtbWFIZWFkZXIgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkxlbW1hXCIgcGFyZW50aGVzaXNlZExhYmVscy4uLiA8RU5EX09GX0xJTkU+IHwgXCJMZW1tYVwiIDxFTkRfT0ZfTElORT4gOyBcblxudGhlb3JlbUhlYWRlciAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIlRoZW9yZW1cIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gOyBcblxuY29uamVjdHVyZUhlYWRlciAgICAgICAgICAgICAgICAgICAgOjo9ICBcIkNvbmplY3R1cmVcIiBwYXJlbnRoZXNpc2VkTGFiZWxzLi4uIDxFTkRfT0ZfTElORT4gO1xuXG5cblxucnVsZUJvZHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFwiUHJlbWlzZXNcIiA8RU5EX09GX0xJTkU+IHByZW1pc2UgcHJlbWlzZSsgKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXCJQcmVtaXNlXCIgPEVORF9PRl9MSU5FPiBwcmVtaXNlICkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29uY2x1c2lvblwiIDxFTkRfT0ZfTElORT4gY29uY2x1c2lvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mPyA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxubWV0YUxlbW1hQm9keSAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uKyBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mIDtcblxubWV0YXRoZW9yZW1Cb2R5ICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uKyBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2YgO1xuXG5heGlvbUJvZHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3VwcG9zZVwiIDxFTkRfT0ZfTElORT4gc3VwcG9zaXRpb24rXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uIDtcblxubGVtbWFCb2R5ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uK1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZiA7XG5cbnRoZW9yZW1Cb2R5ICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTdXBwb3NlXCIgPEVORF9PRl9MSU5FPiBzdXBwb3NpdGlvbitcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb29mIDtcblxuY29uamVjdHVyZUJvZHkgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uK1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlblwiIDxFTkRfT0ZfTElORT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvb2Y/IDtcblxuXG5cbnByb29mICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiUHJvb2ZcIiA8RU5EX09GX0xJTkU+IGRlcml2YXRpb24gO1xuXG5zdWJwcm9vZiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIlN1cHBvc2VcIiA8RU5EX09GX0xJTkU+IHN1cHBvc2l0aW9uKyBzdWJEZXJpdmF0aW9uIDtcblxuZGVyaXZhdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHN0ZXAgfCBzdWJwcm9vZiApKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmVmb3JlXCIgPEVORF9PRl9MSU5FPiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5zdWJEZXJpdmF0aW9uICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJIZW5jZVwiIDxFTkRfT0ZfTElORT5cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzdGVwIHwgc3VicHJvb2YgKSsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKT8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZW5cIiA8RU5EX09GX0xJTkU+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG5cblxucHJvcGVydHlEZWNsYXJhdGlvbi4gICAgICAgICAgICAgICAgIDo6PSAgcHJvcGVydHkgKCBcIjpcIiB0eXBlICk/IDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub25zZW5zZS4uLiA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5cbmNvbWJpbmF0b3IgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHN0YXRlbWVudCA7XG5cbmNvbnN0cnVjdG9yICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIHRlcm0gOyBcblxuIFxuXG5wcmVtaXNlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBwcm9jZWR1cmVDYWxsIDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5zdXBwb3NpdGlvbi4gICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBwcm9jZWR1cmVDYWxsIDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5jb25jbHVzaW9uLiAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5kZWR1Y3Rpb24uICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5oeXBvdGhlc2lzLiAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBzdGF0ZW1lbnQuLi4gPEVORF9PRl9MSU5FPiAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG5vbnNlbnNlLi4uIDxFTkRfT0ZfTElORT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG5cblxuc3RlcC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgc3RhdGVtZW50Li4uIHF1YWxpZmljYXRpb24/IDxFTkRfT0ZfTElORT4gIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub25zZW5zZS4uLiBxdWFsaWZpY2F0aW9uPyA8RU5EX09GX0xJTkU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxuXG5cbnF1YWxpZmljYXRpb24gICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiYmVjYXVzZVwiIHNhdGlzZmllc0Fzc2VydGlvblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAoIFwiYnlcIiB8IFwiZnJvbVwiICkgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgXG5cblxuXG5wYXJlbnRoZXNpc2VkTGFiZWxzICAgICAgICAgICAgICAgICAgOjo9ICBcIihcIiBsYWJlbHMgXCIpXCIgOyBcblxucGFyZW50aGVzaXNlZExhYmVsICAgICAgICAgICAgICAgICAgIDo6PSAgXCIoXCIgbGFiZWwgXCIpXCIgOyBcblxuXG5cbnByb2NlZHVyZUNhbGwgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiQFwiPE5PX1dISVRFU1BBQ0U+cHJvY2VkdXJlUmVmZXJlbmNlPE5PX1dISVRFU1BBQ0U+XCIoXCIgcGFyYW1ldGVyICggXCIsXCIgcGFyYW1ldGVyICkqIFwiKVwiIDtcblxuXG5cbnNpZ25hdHVyZSAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFwiW1wiIHRlcm0gKCBcIixcIiB0ZXJtICkqIFwiXVwiIDtcblxuXG5cbmFyZ3VtZW50cyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGFyZ3VtZW50ICggXCIsXCIgYXJndW1lbnQgKSogO1xuXG5sYWJlbHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBsYWJlbCAoIFwiLFwiIGxhYmVsICkqIDtcblxudHlwZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdHlwZSAoIFwiLFwiIHR5cGUgKSogO1xuXG5cblxuYXJndW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgdGVybSAoICkgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHR5cGUgKCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcblxubWV0YUFyZ3VtZW50ICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgc3RhdGVtZW50ICggKSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbWV0YVR5cGUgKCApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cbmZyYW1lQXJndW1lbnQgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGZyYW1lICggKSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgbWV0YVR5cGUgKCApIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxucHJvY2VkdXJlUmVmZXJlbmNlLiAgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcblxucmVmZXJlbmNlLiAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXZhcmlhYmxlIDtcblxubGFiZWwuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgbWV0YXZhcmlhYmxlIDtcblxuXG5cbmVxdWl2YWxlbmNlcyAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIGVxdWl2YWxlbmNlICggXCIsXCIgZXF1aXZhbGVuY2UgKSogO1xuXG5lcXVpdmFsZW5jZSAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBcIltcIiB0ZXJtICggXCIsXCIgdGVybSApKyBcIl1cIiA7XG5cblxuXG5tZXRhdmFyaWFibGUuICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gKCA8Tk9fV0hJVEVTUEFDRT5cIihcIiAoIHRlcm0gfCB0eXBlIHwgc3R1ZmYgKSBcIilcIiApPyA7XG5cbnBhcmFtZXRlci4gICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtuYW1lXSB8IFtpZGVudGlmaWVyXSA7XG5cbnZhcmlhYmxlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFtpZGVudGlmaWVyXSA7XG5cbm1ldGFUeXBlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFttZXRhLXR5cGVdIDtcblxucHJvcGVydHkuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdKyA7XG5cbnR5cGVQcmVmaXguICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFt0eXBlXSA7XG5cbnR5cGUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Oj0gIFt0eXBlXSAoIDxOT19XSElURVNQQUNFPlt0eXBlXSApPyBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgXCI8XCI8Tk9fV0hJVEVTUEFDRT5cIj5cIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG5cblxuXG5zdHVmZi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjo9ICAoIFtzdHJpbmctbGl0ZXJhbF0gfCBbc3ltYm9sXSB8IFt0eXBlXSB8IFtuYW1lXSB8IFtpZGVudGlmaWVyXSB8IFtwcmltaXRpdmVdIHwgW3VuYXNzaWduZWRdICkrIDtcblxubm9uc2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDo6PSAgKCBbc2Vjb25kYXJ5LWtleXdvcmRdIHwgW21ldGEtdHlwZV0gfCBbc3BlY2lhbF0gfCBbc3ltYm9sXSB8IFt0eXBlXSB8IFtuYW1lXSB8IFtpZGVudGlmaWVyXSB8IFtwcmltaXRpdmVdIHwgW3VuYXNzaWduZWRdICkrIDtgO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbWluYWxQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICA6Oj0gICggYmxvY2sgfCB2ZXJ0aWNhbFNwYWNlICkrIDtcblxuICAgIGJsb2NrICAgICAgICAgIDo6PSAgZW5kZWRMaW5lKiBsYXN0TGluZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICB8ICBlbmRlZExpbmUrXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgbGFzdExpbmUgICAgICAgOjo9ICAoIFthbHBoYS1udW1lcmljXSB8IFtwdW5jdHVhdGlvbl0gfCBbdW5hc3NpZ25lZF0gKSsgO1xuXG4gICAgZW5kZWRMaW5lICAgICAgOjo9ICAoIFthbHBoYS1udW1lcmljXSB8IFtwdW5jdHVhdGlvbl0gfCBbdW5hc3NpZ25lZF0gKSsgPEVORF9PRl9MSU5FPiA7XG5cbiAgICB2ZXJ0aWNhbFNwYWNlICA6Oj0gIDxFTkRfT0ZfTElORT4rIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFpblRleHRQYXJzZXIgZXh0ZW5kcyBDb21tb25QYXJzZXIge1xuICBzdGF0aWMgYm5mID0gYm5mO1xuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tTm90aGluZyhQbGFpblRleHRQYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihQbGFpblRleHRQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKFBsYWluVGV4dFBhcnNlciwgcnVsZXMpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJuZiA9IGBcblxuICAgICAgZG9jdW1lbnQgICAgICAgICAgICAgICAgIDo6PSAgKCBydWxlIHwgZXJyb3IgKSsgO1xuXG4gICAgICBydWxlICAgICAgICAgICAgICAgICAgICAgOjo9ICBuYW1lIFwiOjo9XCIgZGVmaW5pdGlvbnMgXCI7XCIgO1xuXG4gICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgOjo9ICBbbmFtZV0gO1xuXG4gICAgICBkZWZpbml0aW9ucyAgICAgICAgICAgICAgOjo9ICBkZWZpbml0aW9uICggXCJ8XCIgZGVmaW5pdGlvbiApKiA7XG5cbiAgICAgIGRlZmluaXRpb24gICAgICAgICAgICAgICA6Oj0gIHBhcnQrIHByZWNlZGVuY2U/IDtcbiBcbiAgICAgIHBhcnQgICAgICAgICAgICAgICAgICAgICA6Oj0gIG5vblRlcm1pbmFsUGFydCBxdWFudGlmaWVyKlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB0ZXJtaW5hbFBhcnQgcXVhbnRpZmllcipcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBub25UZXJtaW5hbFBhcnQgICAgICAgICAgOjo9ICBjaG9pY2VPZlBhcnRzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHNlcXVlbmNlT2ZQYXJ0c1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBydWxlTmFtZSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICB0ZXJtaW5hbFBhcnQgICAgICAgICAgICAgOjo9ICBzaWduaWZpY2FudFRva2VuVHlwZVxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHN0cmluZ0xpdGVyYWxcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBlbmRPZkxpbmVcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBub1doaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICBzZXF1ZW5jZU9mUGFydHMgICAgICAgICAgOjo9ICBcIihcIiBwYXJ0IHBhcnQrIFwiKVwiIDtcblxuICAgICAgY2hvaWNlT2ZQYXJ0cyAgICAgICAgICAgIDo6PSAgXCIoXCIgcGFydENob2ljZSAoIFwifFwiIHBhcnRDaG9pY2UgKSsgXCIpXCIgO1xuXG4gICAgICBwYXJ0Q2hvaWNlICAgICAgICAgICAgICAgOjo9ICBwYXJ0IHByZWNlZGVuY2U/IDtcblxuICAgICAgcnVsZU5hbWUgICAgICAgICAgICAgICAgIDo6PSAgW25hbWVdIDtcblxuICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGUgICAgIDo6PSAgW3R5cGVdIDtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCAgICAgICAgICAgIDo6PSAgW3N0cmluZy1saXRlcmFsXSA7XG5cbiAgICAgIHByZWNlZGVuY2UgICAgICAgICAgICAgICA6Oj0gIFwiKFwiIFtudW1iZXJdPyBcIilcIiA7XG4gICAgICBcbiAgICAgIGVuZE9mTGluZSAgICAgICAgICAgICAgICA6Oj0gIFwiPEVORF9PRl9MSU5FPlwiIDtcbiAgICAgIFxuICAgICAgbm9XaGl0ZXNwYWNlICAgICAgICAgICAgIDo6PSAgXCI8Tk9fV0hJVEVTUEFDRT5cIiA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgIHF1YW50aWZpZXIgICAgICAgICAgICAgICA6Oj0gIG9wdGlvbmFsUXVhbnRpZmllclxuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb25lT3JNb3JlUXVhbnRpZmllclxuICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHplcm9Pck1vcmVRdWFudGlmaWVyXG4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICBvcHRpb25hbFF1YW50aWZpZXIgICAgICAgOjo9ICA8Tk9fV0hJVEVTUEFDRT5cIj9cIiA7XG5cbiAgICAgIG9uZU9yTW9yZVF1YW50aWZpZXIgICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlwiK1wiIDtcblxuICAgICAgemVyb09yTW9yZVF1YW50aWZpZXIgICAgIDo6PSAgPE5PX1dISVRFU1BBQ0U+XCIqXCIgO1xuXG4gICAgICBlcnJvci4gICAgICAgICAgICAgICAgICAgOjo9ICAuIDtcblxuYDtcblxuZXhwb3J0IGRlZmF1bHQgYm5mO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25QYXJzZXIgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgYm5mIGZyb20gXCIuL2JuZlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21HcmFtbWFyQk5GUGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoQ3VzdG9tR3JhbW1hckJORlBhcnNlcik7IH1cblxuICBzdGF0aWMgZnJvbUJORihibmYpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tQk5GKEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIsIGJuZik7IH1cblxuICBzdGF0aWMgZnJvbVJ1bGVzKHJ1bGVzKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbVJ1bGVzKEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBibmYgPSBgXG5cbiAgICBkb2N1bWVudCAgICAgICA6Oj0gICggZXhwcmVzc2lvbiB8IHZlcnRpY2FsU3BhY2UgfCBlcnJvciApKyA7XG5cbiAgICBleHByZXNzaW9uICAgICA6Oj0gIDxOT19XSElURVNQQUNFPlt1bmFzc2lnbmVkXTxOT19XSElURVNQQUNFPjxFTkRfT0ZfTElORT4gO1xuXG4gICAgdmVydGljYWxTcGFjZSAgOjo9ICA8RU5EX09GX0xJTkU+KyA7XG4gICBcbiAgICBlcnJvci4gICAgICAgICA6Oj0gIC4gO1xuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBibmY7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5cbmltcG9ydCBibmYgZnJvbSBcIi4vYm5mXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIGV4dGVuZHMgQ29tbW9uUGFyc2VyIHtcbiAgc3RhdGljIGJuZiA9IGJuZjtcblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbU5vdGhpbmcoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIpOyB9XG5cbiAgc3RhdGljIGZyb21CTkYoYm5mKSB7IHJldHVybiBDb21tb25QYXJzZXIuZnJvbUJORihDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciwgYm5mKTsgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZXMocnVsZXMpIHsgcmV0dXJuIENvbW1vblBhcnNlci5mcm9tUnVsZXMoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIsIHJ1bGVzKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlWExleGVyIH0gZnJvbSBcIi4vdGVYL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEpTT05MZXhlciB9IGZyb20gXCIuL2pzb24vbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlTGV4ZXIgfSBmcm9tIFwiLi9mdXJ0bGUvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9taW5hbExleGVyIH0gZnJvbSBcIi4vbm9taW5hbC9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQbGFpblRleHRMZXhlciB9IGZyb20gXCIuL3BsYWluVGV4dC9sZXhlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDdXN0b21HcmFtbWFyQk5GTGV4ZXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyQk5GL2xleGVyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyVm9jYWJ1bGFyeS9sZXhlclwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRlWFBhcnNlciB9IGZyb20gXCIuL3RlWC9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSlNPTlBhcnNlciB9IGZyb20gXCIuL2pzb24vcGFyc2VyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZ1cnRsZVBhcnNlciB9IGZyb20gXCIuL2Z1cnRsZS9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTm9taW5hbFBhcnNlciB9IGZyb20gXCIuL25vbWluYWwvcGFyc2VyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYWluVGV4dFBhcnNlciB9IGZyb20gXCIuL3BsYWluVGV4dC9wYXJzZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ3VzdG9tR3JhbW1hckJORlBhcnNlciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXJCTkYvcGFyc2VyXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIH0gZnJvbSBcIi4vY3VzdG9tR3JhbW1hclZvY2FidWxhcnkvcGFyc2VyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEN1c3RvbUdyYW1tYXJCTkZMZXhlciwgQ3VzdG9tR3JhbW1hckJORlBhcnNlciB9IGZyb20gXCJvY2NhbS1ncmFtbWFyc1wiO1xuaW1wb3J0IHsgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciwgQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgfSBmcm9tIFwib2NjYW0tZ3JhbW1hcnNcIjtcblxuZXhwb3J0IGNvbnN0IGN1c3RvbUdyYW1tYXJCTkZMZXhlciA9IEN1c3RvbUdyYW1tYXJCTkZMZXhlci5mcm9tTm90aGluZygpO1xuXG5leHBvcnQgY29uc3QgY3VzdG9tR3JhbW1hckJORlBhcnNlciA9IEN1c3RvbUdyYW1tYXJCTkZQYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuZXhwb3J0IGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIgPSBDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeVBhcnNlciA9IEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyLmZyb21Ob3RoaW5nKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBub2Rlc1F1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlMZXhlciwgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2dyYW1tYXJcIlxuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNvbnN0IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8vZXhwcmVzc2lvblwiKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cHJlc3Npb25zRnJvbVZvY2FidWxhcnkodm9jYWJ1bGFyeSwgZXhwcmVzc2lvbnMpIHtcbiAgY29uc3QgY29udGVudCA9IHZvY2FidWxhcnksIC8vL1xuICAgICAgICB0b2tlbnMgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGV4cHJlc3Npb25Ob2RlcyA9IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5KG5vZGUpO1xuXG4gIGV4cHJlc3Npb25Ob2Rlcy5mb3JFYWNoKChleHByZXNzaW9uTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICBleHByZXNzaW9uID0gZXNjYXBlKGNvbnRlbnQpO1xuXG4gICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUpIHtcbiAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gZXhwcmVzc2lvbk5vZGUsIC8vL1xuICAgICAgICBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSxcbiAgICAgICAgc2Vjb25kQ2hpbGROb2RlID0gc2Vjb25kKGNoaWxkTm9kZXMpLFxuICAgICAgICB1bmFzc2lnbmVkVGVybWluYWxOb2RlID0gc2Vjb25kQ2hpbGROb2RlLCAgLy8vXG4gICAgICAgIGNvbnRlbnQgPSB1bmFzc2lnbmVkVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59IiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBDb21tb25MZXhlciB9IGZyb20gXCJvY2NhbS1sZXhlcnNcIjtcbmltcG9ydCB7IENvbW1vblBhcnNlciB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBOb21pbmFsTGV4ZXIsIE5vbWluYWxQYXJzZXIgfSBmcm9tIFwib2NjYW0tZ3JhbW1hcnNcIjtcblxuZXhwb3J0IGNvbnN0IG5vbWluYWxMZXhlciA9IENvbW1vbkxleGVyLmZyb21Ob3RoaW5nKE5vbWluYWxMZXhlcik7XG5cbmV4cG9ydCBjb25zdCBub21pbmFsUGFyc2VyID0gQ29tbW9uUGFyc2VyLmZyb21Ob3RoaW5nKE5vbWluYWxQYXJzZXIpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgbm9taW5hbFBhcnNlciB9IGZyb20gXCIuL3V0aWxpdGllcy9ub21pbmFsXCI7XG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSwgU1RBVEVNRU5UX1JVTEVfTkFNRSB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgU1RVRkZfUlVMRV9OQU1FLCBOT05TRU5TRV9SVUxFX05BTUUgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNvbnN0IHJ1bGVNYXAgPSBub21pbmFsUGFyc2VyLmdldFJ1bGVNYXAoKSxcbiAgICAgIHN0dWZmUnVsZSA9IHJ1bGVNYXBbU1RVRkZfUlVMRV9OQU1FXSxcbiAgICAgIG5vbnNlbnNlUnVsZSA9IHJ1bGVNYXBbTk9OU0VOU0VfUlVMRV9OQU1FXSxcbiAgICAgIHN0dWZmVHlwZXMgPSB0eXBlc0Zyb21SdWxlKHN0dWZmUnVsZSksXG4gICAgICBub25zZW5zZVR5cGVzID0gdHlwZXNGcm9tUnVsZShub25zZW5zZVJ1bGUpLFxuICAgICAgdGVybVR5cGVzID0gc3R1ZmZUeXBlcywgLy8vXG4gICAgICBzdGF0ZW1lbnRUeXBlcyA9IG5vbnNlbnNlVHlwZXMsXG4gICAgICB0eXBlc01hcCA9IHtcbiAgICAgICAgW1RFUk1fUlVMRV9OQU1FXTogdGVybVR5cGVzLFxuICAgICAgICBbU1RBVEVNRU5UX1JVTEVfTkFNRV06IHN0YXRlbWVudFR5cGVzXG4gICAgICB9O1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlc01hcDtcblxuZnVuY3Rpb24gdHlwZXNGcm9tUnVsZShydWxlKSB7XG4gIGxldCBwYXJ0cztcblxuICBjb25zdCBkZWZpbml0aW9ucyA9IHJ1bGUuZ2V0RGVmaW5pdGlvbnMoKSxcbiAgICAgICAgZmlyc3RERGVmaW5pdGlvbiA9IGZpcnN0KGRlZmluaXRpb25zKSxcbiAgICAgICAgZGVmaW5pdGlvbiA9IGZpcnN0RERlZmluaXRpb247ICAvLy9cblxuICBwYXJ0cyA9IGRlZmluaXRpb24uZ2V0UGFydHMoKTtcblxuICBjb25zdCBmaXJzdFBhcnQgPSBmaXJzdChwYXJ0cyksXG4gICAgICAgIG9uZU9yTW9yZVBhcnRzUGFydCA9IGZpcnN0UGFydCwgLy8vXG4gICAgICAgIHBhcnQgPSBvbmVPck1vcmVQYXJ0c1BhcnQuZ2V0UGFydCgpLFxuICAgICAgICBjaG9pY2VPclBhcnRzUGFydCA9IHBhcnQ7IC8vL1xuXG4gIHBhcnRzID0gY2hvaWNlT3JQYXJ0c1BhcnQuZ2V0UGFydHMoKTtcblxuICBjb25zdCB0eXBlcyA9IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgIGNvbnN0IHNpZ25pZmljYW50VG9rZW5UeXBlUGFydCA9IHBhcnQsICAvLy9cbiAgICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZSA9IHNpZ25pZmljYW50VG9rZW5UeXBlUGFydC5nZXRTaWduaWZpY2FudFRva2VuVHlwZSgpLFxuICAgICAgICAgIHR5cGUgPSBzaWduaWZpY2FudFRva2VuVHlwZTsgIC8vL1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiB0eXBlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB0eXBlc01hcCBmcm9tIFwiLi4vdHlwZXNNYXBcIjtcblxuaW1wb3J0IHsgbm9taW5hbExleGVyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ub21pbmFsXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBVTkFTU0lHTkVEX1RZUEUsIEJBU0VfVFlQRV9TWU1CT0wgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBjdXN0b21HcmFtbWFyQk5GTGV4ZXIsIGN1c3RvbUdyYW1tYXJCTkZQYXJzZXIsIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5TGV4ZXIsIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5UGFyc2VyIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9ncmFtbWFyXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNvbnN0IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8vZXhwcmVzc2lvblwiKSxcbiAgICAgIHJ1bGVOYW1lVGVybWluYWxOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvZG9jdW1lbnQvcnVsZS9uYW1lL0AqIVwiKSxcbiAgICAgIHVuYXNzaWduZWRUZXJtaW5hbE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9leHByZXNzaW9uL0B1bmFzc2lnbmVkXCIpLFxuICAgICAgc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXNRdWVyeSA9IG5vZGVzUXVlcnkoXCIvL3N0cmluZ0xpdGVyYWwvQCohXCIpLFxuICAgICAgc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5KFwiLy9zaWduaWZpY2FudFRva2VuVHlwZS9AKiFcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJORihibmYsIHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBibmYsXG4gICAgICAgIHRva2VucyA9IGN1c3RvbUdyYW1tYXJCTkZMZXhlci50b2tlbmlzZShjb250ZW50KSxcbiAgICAgICAgbm9kZSA9IGN1c3RvbUdyYW1tYXJCTkZQYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJ1bGVOYW1lVGVybWluYWxOb2RlID0gcnVsZU5hbWVUZXJtaW5hbE5vZGVRdWVyeShub2RlKTtcblxuICBpZiAocnVsZU5hbWVUZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBuYW1lID0gbmFtZUZyb21SdWxlTmFtZVRlcm1pbmFsTm9kZShydWxlTmFtZVRlcm1pbmFsTm9kZSk7XG5cbiAgICBpZiAobmFtZSAhPT0gcnVsZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke25hbWV9JyBydWxlIHNob3VsZCBiZSBuYW1lZCAnJHtydWxlTmFtZX0nLmApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHR5cGVzID0gdHlwZXNNYXBbcnVsZU5hbWVdLFxuICAgICAgICBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXMgPSBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXNRdWVyeShub2RlKTtcblxuICBzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZXMuZm9yRWFjaCgoc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZUZyb21TaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZShzaWduaWZpY2FudFRva2VuVHlwZVRlcm1pbmFsTm9kZSksXG4gICAgICAgICAgdHlwZXNJbmNsdWRlVHlwZSA9IHR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuXG4gICAgaWYgKCF0eXBlc0luY2x1ZGVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHt0eXBlfScgdHlwZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlICcke3J1bGVOYW1lfScgcnVsZSdzIHR5cGVzLmApXG4gICAgfVxuICB9KTtcblxuICBjb25zdCBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlcyA9IHN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVzUXVlcnkobm9kZSk7XG5cbiAgc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZXMuZm9yRWFjaCgoc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUoc3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZSk7XG5cbiAgICBpZiAoY29udGVudCA9PT0gQkFTRV9UWVBFX1NZTUJPTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke2NvbnRlbnR9XCIgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBiYXNlIHR5cGUgc3ltYm9sLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VucyA9IG5vbWluYWxMZXhlci50b2tlbmlzZShjb250ZW50KSxcbiAgICAgICAgICB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgaWYgKHRva2Vuc0xlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbmlzaW5nIHRoZSBcIiR7Y29udGVudH1cIiBzdHJpbmcgbGl0ZXJhbCBkb2VzIG5vdCByZXN1bHQgaW4gYSBzaW5nbGUgdG9rZW4uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IGZpcnN0KHRva2VucyksXG4gICAgICAgICAgdG9rZW4gPSBmaXJzdFRva2VuLCAvLy9cbiAgICAgICAgICB0eXBlID0gdG9rZW4uZ2V0VHlwZSgpLFxuICAgICAgICAgIHR5cGVzSW5jbHVkZVR5cGUgPSB0eXBlcy5pbmNsdWRlcyh0eXBlKTtcblxuICAgIGlmICghdHlwZXNJbmNsdWRlVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke2NvbnRlbnR9XCIgc3RyaW5nIGxpdGVyYWwncyB0b2tlbidzICcke3R5cGV9JyB0eXBlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgJyR7cnVsZU5hbWV9JyBydWxlJ3MgdHlwZXMuYClcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWb2NhYnVsYXJ5KHZvY2FidWxhcnkpIHtcbiAgY29uc3QgY29udGVudCA9IHZvY2FidWxhcnksIC8vL1xuICAgICAgICB0b2tlbnMgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUxleGVyLnRva2VuaXNlKGNvbnRlbnQpLFxuICAgICAgICBub2RlID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlQYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGV4cHJlc3Npb25Ob2RlcyA9IGV4cHJlc3Npb25Ob2Rlc1F1ZXJ5KG5vZGUpO1xuXG4gIGV4cHJlc3Npb25Ob2Rlcy5mb3JFYWNoKChleHByZXNzaW9uTm9kZSkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSxcbiAgICAgICAgICB0b2tlbnMgPSBub21pbmFsTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgICAgdG9rZW5zTGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIGlmICh0b2tlbnNMZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuaXNpbmcgdGhlICcke2NvbnRlbnR9JyBjb250ZW50IHJlc3VsdHMgaW4gbW9yZSB0aGFuIG9uZSB0b2tlbi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFRva2VuID0gZmlyc3QodG9rZW5zKSxcbiAgICAgICAgICB0b2tlbiA9IGZpcnN0VG9rZW4sXG4gICAgICAgICAgdHlwZSA9IHRva2VuLmdldFR5cGUoKTtcblxuICAgIGlmICh0eXBlICE9PSBVTkFTU0lHTkVEX1RZUEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke3R5cGV9JyB0eXBlIG9mIHRoZSAnJHtjb250ZW50fScgdG9rZW4gaXMgbm90ICd1bmFzc2lnbmVkJy5gKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGVudCA9PT0gQkFTRV9UWVBFX1NZTUJPTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7Y29udGVudH0nIHRva2VuIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgYmFzZSB0eXBlIHN5bWJvbC5gKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb250ZW50RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlKSB7XG4gIGxldCBjb250ZW50O1xuXG4gIGNvbnN0IHVuYXNzaWduZWRUZXJtaW5hbE5vZGUgPSB1bmFzc2lnbmVkVGVybWluYWxOb2RlUXVlcnkoZXhwcmVzc2lvbk5vZGUpO1xuXG4gIGNvbnRlbnQgPSB1bmFzc2lnbmVkVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICByZXR1cm4gY29udGVudDs7XG59XG5cbmZ1bmN0aW9uIG5hbWVGcm9tUnVsZU5hbWVUZXJtaW5hbE5vZGUocnVsZU5hbWVUZXJtaW5hbE5vZGUpIHtcbiAgbGV0IG5hbWU7XG5cbiAgY29uc3QgY29udGVudCA9IHJ1bGVOYW1lVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICBuYW1lID0gY29udGVudDsgLy8vXG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZShzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlKSB7XG4gIGxldCBjb250ZW50O1xuXG4gIGNvbnRlbnQgPSBzdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaCgvXCIoW15cIl0qKVwiLyksXG4gICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gIGNvbnRlbnQgPSBzZWNvbmRNYXRjaDsgLy8vXG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHR5cGVGcm9tU2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUoc2lnbmlmaWNhbnRUb2tlblR5cGVUZXJtaW5hbE5vZGUpIHtcbiAgbGV0IHR5cGU7XG5cbiAgY29uc3QgY29udGVudCA9IHNpZ25pZmljYW50VG9rZW5UeXBlVGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goL1xcWyhbXlxcXV0qKVxcXS8pLFxuICAgICAgICBzZWNvbmRNYXRjaCA9IHNlY29uZChtYXRjaGVzKTtcblxuICB0eXBlID0gc2Vjb25kTWF0Y2g7IC8vL1xuXG4gIHJldHVybiB0eXBlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcbmltcG9ydCB7IHNwZWNpYWxTeW1ib2xzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuaW1wb3J0IHsgcGFyc2VyVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLXBhcnNlcnNcIjtcbmltcG9ydCB7IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24gfSBmcm9tIFwib2NjYW0tZ3JhbW1hci11dGlsaXRpZXNcIjtcblxuaW1wb3J0IGRlZmF1bHRDdXN0b21HcmFtbWFyIGZyb20gXCIuLi9jdXN0b21HcmFtbWFyL2RlZmF1bHRcIjtcblxuaW1wb3J0IHsgZXhwcmVzc2lvbnNGcm9tVm9jYWJ1bGFyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdm9jYWJ1bGFyeVwiO1xuaW1wb3J0IHsgVkVSVElDQUxfQkFSLCBWRVJUSUNBTF9TUEFDRSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHZhbGlkYXRlQk5GLCB2YWxpZGF0ZVZvY2FidWxhcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ZhbGlkYXRlXCI7XG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSwgU1RBVEVNRU5UX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IFRZUEVfVk9DQUJVTEFSWV9OQU1FLCBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FIH0gZnJvbSBcIi4uL3ZvY2FidWxhcnlOYW1lc1wiO1xuXG5jb25zdCB7IG9wYXF1ZSAgfSA9IHNwZWNpYWxTeW1ib2xzLFxuICAgICAgeyBydWxlc0Zyb21CTkYgfSA9IHBhcnNlclV0aWxpdGllcyxcbiAgICAgIHsgdW5zaGlmdCwgZm9yd2FyZHNGb3JFYWNoLCBiYWNrd2FyZHNGb3JFYWNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tYmluZWRDdXN0b21HcmFtbWFyIHtcbiAgY29uc3RydWN0b3IocnVsZXMsIGVudHJpZXMpIHtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuICBcbiAgZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXM7XG4gIH1cblxuICBnZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXM7XG4gIH1cblxuICBwb3N0UHJvY2VzcyhydWxlcykge1xuICAgIHJ1bGVzID0gWyAvLy9cbiAgICAgIC4uLnJ1bGVzLFxuICAgICAgLi4udGhpcy5ydWxlc1xuICAgIF07XG5cbiAgICBydWxlcyA9IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpOyAgLy8vXG5cbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoaW5jbHVkZURlZmF1bHQgPSB0cnVlKSB7XG4gICAgbGV0IGN1c3RvbUdyYW1tYXJzID0gW107XG5cbiAgICBpZiAoaW5jbHVkZURlZmF1bHQpIHtcbiAgICAgIGN1c3RvbUdyYW1tYXJzID0gWyBkZWZhdWx0Q3VzdG9tR3JhbW1hciwgLi4uY3VzdG9tR3JhbW1hcnMgXTsgLy8vXG4gICAgfVxuXG4gICAgY29uc3QgcnVsZXMgPSBydWxlc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyksXG4gICAgICAgICAgZW50cmllcyA9IGVudHJpZXNGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpLFxuICAgICAgICAgIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IG5ldyBDb21iaW5lZEN1c3RvbUdyYW1tYXIocnVsZXMsIGVudHJpZXMpO1xuXG4gICAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIGluY2x1ZGVEZWZhdWx0ID0gdHJ1ZSkge1xuICAgIGlmIChpbmNsdWRlRGVmYXVsdCkge1xuICAgICAgY3VzdG9tR3JhbW1hcnMgPSBbIGRlZmF1bHRDdXN0b21HcmFtbWFyLCAuLi5jdXN0b21HcmFtbWFycyBdOyAvLy9cbiAgICB9XG5cbiAgICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSxcbiAgICAgICAgICBlbnRyaWVzID0gZW50cmllc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyksXG4gICAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gbmV3IENvbWJpbmVkQ3VzdG9tR3JhbW1hcihydWxlcywgZW50cmllcyk7XG4gICAgXG4gICAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBydWxlc0Zyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycykge1xuICBjb25zdCBydWxlTmFtZXMgPSBbXG4gICAgICAgICAgVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgXSxcbiAgICAgICAgYm5mcyA9IHJ1bGVOYW1lcy5tYXAoKHJ1bGVOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgYm5mID0gYm5mRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzLCBydWxlTmFtZSk7XG5cbiAgICAgICAgICByZXR1cm4gYm5mO1xuICAgICAgICB9KSxcbiAgICAgICAgYm5mID0gYm5mcy5qb2luKFZFUlRJQ0FMX1NQQUNFKSxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICBjb21iaW5lUnVsZXMocnVsZXMpO1xuXG4gIGNvbnN0IG9wYWNpdHkgPSBvcGFxdWU7IC8vL1xuXG4gIHJ1bGVOYW1lcy5mb3JFYWNoKChydWxlTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlcy5maW5kKChydWxlKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gcnVsZS5nZXROYW1lKCk7XG5cbiAgICAgIGlmIChuYW1lID09PSBydWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJ1bGUuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuXG5mdW5jdGlvbiBlbnRyaWVzRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSB7XG4gIGNvbnN0IHZvY2FidWxhcnlOYW1lcyA9IFtcbiAgICAgICAgICBUWVBFX1ZPQ0FCVUxBUllfTkFNRSxcbiAgICAgICAgICBTWU1CT0xfVk9DQUJVTEFSWV9OQU1FXG4gICAgICAgIF0sXG4gICAgICAgIGVudHJpZXMgPSB2b2NhYnVsYXJ5TmFtZXMubWFwKCh2b2NhYnVsYXJ5TmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIHZvY2FidWxhcnlOYW1lKTtcblxuICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIGVudHJpZXM7XG59XG5cbmZ1bmN0aW9uIGVudHJ5RnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzLCB2b2NhYnVsYXJ5TmFtZSkge1xuICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuXG4gIGJhY2t3YXJkc0ZvckVhY2goY3VzdG9tR3JhbW1hcnMsIChjdXN0b21HcmFtbWFyKSA9PiB7XG4gICAgY29uc3Qgdm9jYWJ1bGFyeSA9IGN1c3RvbUdyYW1tYXIuZ2V0Vm9jYWJ1bGFyeSh2b2NhYnVsYXJ5TmFtZSksXG4gICAgICAgICAgY3VzdG9tR3JhbW1hckRlZmF1bHRDdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hci5pc0RlZmF1bHRDdXN0b21HcmFtbWFyKCk7XG5cbiAgICBpZiAoIWN1c3RvbUdyYW1tYXJEZWZhdWx0Q3VzdG9tR3JhbW1hcikge1xuICAgICAgdmFsaWRhdGVWb2NhYnVsYXJ5KHZvY2FidWxhcnkpO1xuICAgIH1cblxuICAgIGV4cHJlc3Npb25zRnJvbVZvY2FidWxhcnkodm9jYWJ1bGFyeSwgZXhwcmVzc2lvbnMpO1xuICB9KTtcblxuICBjb25zdCBwYXR0ZXJuID0gZXhwcmVzc2lvbnMuam9pbihWRVJUSUNBTF9CQVIpLFxuICAgICAgICBlbnRyeU5hbWUgPSB2b2NhYnVsYXJ5TmFtZSwgIC8vL1xuICAgICAgICBlbnRyeVZhbHVlID0gYF4oPzoke3BhdHRlcm59KWAsXG4gICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgIFtlbnRyeU5hbWVdOiBlbnRyeVZhbHVlXG4gICAgICAgIH07XG5cbiAgcmV0dXJuIGVudHJ5O1xufVxuXG5mdW5jdGlvbiBibmZGcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMsIHJ1bGVOYW1lKSB7XG4gIGNvbnN0IGJuZnMgPSBbXTtcblxuICBmb3J3YXJkc0ZvckVhY2goY3VzdG9tR3JhbW1hcnMsIChjdXN0b21HcmFtbWFyKSA9PiB7XG4gICAgY29uc3QgYm5mID0gY3VzdG9tR3JhbW1hci5nZXRCTkYocnVsZU5hbWUpLFxuICAgICAgICAgIGN1c3RvbUdyYW1tYXJEZWZhdWx0Q3VzdG9tR3JhbW1hciA9IGN1c3RvbUdyYW1tYXIuaXNEZWZhdWx0Q3VzdG9tR3JhbW1hcigpO1xuXG4gICAgaWYgKCFjdXN0b21HcmFtbWFyRGVmYXVsdEN1c3RvbUdyYW1tYXIpIHtcbiAgICAgIHZhbGlkYXRlQk5GKGJuZiwgcnVsZU5hbWUpO1xuICAgIH1cblxuICAgIGJuZnMucHVzaChibmYpO1xuICB9KTtcblxuICBjb25zdCBibmYgPSBibmZzLmpvaW4oVkVSVElDQUxfU1BBQ0UpO1xuXG4gIHJldHVybiBibmY7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVSdWxlcyhydWxlcykge1xuICBsZXQgb3V0ZXJJbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBydWxlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKG91dGVySW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb25zdCBvdXRlclJ1bGUgPSBydWxlc1tvdXRlckluZGV4XSxcbiAgICAgICAgICBvdXRlclJ1bGVOYW1lID0gb3V0ZXJSdWxlLmdldE5hbWUoKTtcblxuICAgIGxldCBpbm5lckluZGV4ID0gb3V0ZXJJbmRleCArIDE7XG5cbiAgICB3aGlsZSAoaW5uZXJJbmRleCA8IGxlbmd0aCkge1xuICAgICAgY29uc3QgaW5uZXJSdWxlID0gcnVsZXNbaW5uZXJJbmRleF0sXG4gICAgICAgICAgICBpbm5lclJ1bGVOYW1lID0gaW5uZXJSdWxlLmdldE5hbWUoKTtcblxuICAgICAgaWYgKGlubmVyUnVsZU5hbWUgPT09IG91dGVyUnVsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5uZXJSdWxlRGVmaW5pdGlvbnMgPSBpbm5lclJ1bGUuZ2V0RGVmaW5pdGlvbnMoKSxcbiAgICAgICAgICAgICAgb3V0ZXJSdWxlRGVmaW5pdGlvbnMgPSBvdXRlclJ1bGUuZ2V0RGVmaW5pdGlvbnMoKTtcblxuICAgICAgICB1bnNoaWZ0KG91dGVyUnVsZURlZmluaXRpb25zLCBpbm5lclJ1bGVEZWZpbml0aW9ucyk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBpbm5lckluZGV4LCAvLy9cbiAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPSAxO1xuXG4gICAgICAgIHJ1bGVzLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xuXG4gICAgICAgIGxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVySW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRlckluZGV4Kys7XG5cbiAgICBsZW5ndGggPSBydWxlcy5sZW5ndGg7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbGV4ZXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGV4ZXJzXCI7XG5cbmltcG9ydCBDb21iaW5lZEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXIvY29tYmluZWRcIjtcblxuY29uc3QgeyBsZXhlckZyb21SdWxlcywgcnVsZXNGcm9tRW50cmllcyB9ID0gbGV4ZXJVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXhlckZyb21Ob3RoaW5nKENsYXNzKSB7XG4gIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXG4gICAgICAgIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IENvbWJpbmVkQ3VzdG9tR3JhbW1hci5mcm9tTm90aGluZygpLFxuICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXNBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoZW50cmllcywgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgbGV4ZXIgPSBsZXhlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBsZXhlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxleGVyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcihDbGFzcywgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHsgZW50cmllcyB9ID0gQ2xhc3MsXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGxleGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4ZXJGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihDbGFzcywgZW50cmllcywgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHJ1bGVzID0gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBsZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGxleGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGxleGVyRnJvbU5vdGhpbmcsXG4gIGxleGVyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgbGV4ZXJGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hclxufTtcblxuZnVuY3Rpb24gcnVsZXNGcm9tRW50cmllc0FuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihlbnRyaWVzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hckVudHJpZXMgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXIuZ2V0RW50cmllcygpO1xuXG4gIGVudHJpZXMgPSBbIC8vL1xuICAgIC4uLmN1c3RvbUdyYW1tYXJFbnRyaWVzLFxuICAgIC4uLmVudHJpZXNcbiAgXTtcblxuICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgcmV0dXJuIHJ1bGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBwYXJzZXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5pbXBvcnQgQ29tYmluZWRDdXN0b21HcmFtbWFyIGZyb20gXCIuLi9jdXN0b21HcmFtbWFyL2NvbWJpbmVkXCI7XG5cbmNvbnN0IHsgcnVsZXNGcm9tQk5GLCBwYXJzZXJGcm9tUnVsZXMsIHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUgfSA9IHBhcnNlclV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21Ob3RoaW5nKENsYXNzKSB7XG4gIGNvbnN0IHsgYm5mIH0gPSBDbGFzcyxcbiAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21Ob3RoaW5nKCksXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21TdGFydFJ1bGVOYW1lKENsYXNzLCBzdGFydFJ1bGVOYW1lKSB7XG4gIGNvbnN0IHsgYm5mIH0gPSBDbGFzcyxcbiAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21Ob3RoaW5nKCksXG4gICAgICAgIHJ1bGVzID0gcnVsZXNGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKGJuZiwgY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgICAgcGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgY29uc3QgeyBibmYgfSA9IENsYXNzLFxuICAgICAgICBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tQk5GQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBwYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGcm9tU3RhcnRSdWxlTmFtZUFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihDbGFzcywgc3RhcnRSdWxlTmFtZSwgY29tYmluZWRDdXN0b21HcmFtbWFyKSB7XG4gIGNvbnN0IHsgYm5mIH0gPSBDbGFzcyxcbiAgICAgICAgcnVsZXMgPSBydWxlc0Zyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoYm5mLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpLFxuICAgICAgICBwYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXNBbmRTdGFydFJ1bGVOYW1lKENsYXNzLCBydWxlcywgc3RhcnRSdWxlTmFtZSk7XG5cbiAgcmV0dXJuIHBhcnNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZyb21CTkZTdGFydFJ1bGVOYW1lQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyKENsYXNzLCBibmYsIHN0YXJ0UnVsZU5hbWUsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcikge1xuICBjb25zdCBydWxlcyA9IHJ1bGVzRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcihibmYsIGNvbWJpbmVkQ3VzdG9tR3JhbW1hciksXG4gICAgICAgIHBhcnNlciA9IHBhcnNlckZyb21SdWxlc0FuZFN0YXJ0UnVsZU5hbWUoQ2xhc3MsIHJ1bGVzLCBzdGFydFJ1bGVOYW1lKTtcblxuICByZXR1cm4gcGFyc2VyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHBhcnNlckZyb21Ob3RoaW5nLFxuICBwYXJzZXJGcm9tU3RhcnRSdWxlTmFtZSxcbiAgcGFyc2VyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgcGFyc2VyRnJvbUJORkFuZENvbWJpbmVkQ3VzdG9tR3JhbW1hcixcbiAgcGFyc2VyRnJvbVN0YXJ0UnVsZU5hbWVBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIsXG4gIHBhcnNlckZyb21CTkZTdGFydFJ1bGVOYW1lQW5kQ29tYmluZWRDdXN0b21HcmFtbWFyXG59O1xuXG5mdW5jdGlvbiBydWxlc0Zyb21CTkZBbmRDb21iaW5lZEN1c3RvbUdyYW1tYXIoYm5mLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIpIHtcbiAgbGV0IHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZik7XG5cbiAgcnVsZXMgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXIucG9zdFByb2Nlc3MocnVsZXMpO1xuXG4gIHJldHVybiBydWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXJcIjtcbmltcG9ydCBDb21iaW5lZEN1c3RvbUdyYW1tYXIgZnJvbSBcIi4uL2N1c3RvbUdyYW1tYXIvY29tYmluZWRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21KU09OKGpzb24pIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hcnNKU09OID0ganNvbiwgIC8vL1xuICAgICAgICBjdXN0b21HcmFtbWFycyA9IGN1c3RvbUdyYW1tYXJzSlNPTi5tYXAoKGN1c3RvbUdyYW1tYXJKU09OKSA9PiB7XG4gICAgICAgICAgY29uc3QganNvbiA9IGN1c3RvbUdyYW1tYXJKU09OLCAvLy9cbiAgICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyID0gQ3VzdG9tR3JhbW1hci5mcm9tSlNPTihqc29uKTtcblxuICAgICAgICAgIHJldHVybiBjdXN0b21HcmFtbWFyO1xuICAgICAgICB9KTtcblxuICBjdXN0b21HcmFtbWFycy5yZXZlcnNlKCk7IC8vXG5cbiAgY29uc3QgY29tYmluZWRDdXN0b21HcmFtbWFyID0gQ29tYmluZWRDdXN0b21HcmFtbWFyLmZyb21DdXN0b21HcmFtbWFycyhjdXN0b21HcmFtbWFycyk7XG5cbiAgcmV0dXJuIGNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21Ob3RoaW5nKCkge1xuICBjb25zdCBjdXN0b21HcmFtbWFycyA9IFtdLFxuICAgICAgICBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBDb21iaW5lZEN1c3RvbUdyYW1tYXIuZnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKTtcblxuICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKSB7XG4gIGN1c3RvbUdyYW1tYXJzID0gWyAgLy8vXG4gICAgLi4uY3VzdG9tR3JhbW1hcnNcbiAgXTtcblxuICBjdXN0b21HcmFtbWFycy5yZXZlcnNlKCk7IC8vL1xuXG4gIGNvbnN0IGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IENvbWJpbmVkQ3VzdG9tR3JhbW1hci5mcm9tQ3VzdG9tR3JhbW1hcnMoY3VzdG9tR3JhbW1hcnMpO1xuXG4gIHJldHVybiBjb21iaW5lZEN1c3RvbUdyYW1tYXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUpTT04sXG4gIGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21Ob3RoaW5nLFxuICBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tQ3VzdG9tR3JhbW1hcnNcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IERFRkFVTFRfQ1VTVE9NX0dSQU1NQVJfTkFNRSB9IGZyb20gXCIuL2dyYW1tYXJOYW1lc1wiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIHJ1bGVOYW1lcyB9IGZyb20gXCIuL3J1bGVOYW1lc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2b2NhYnVsYXJ5TmFtZXMgfSBmcm9tIFwiLi92b2NhYnVsYXJ5TmFtZXNcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBDdXN0b21HcmFtbWFyIH0gZnJvbSBcIi4vY3VzdG9tR3JhbW1hclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBkZWZhdWx0Q3VzdG9tR3JhbW1hciB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXIvZGVmYXVsdFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb21iaW5lZEN1c3RvbUdyYW1tYXIgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyL2NvbWJpbmVkXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGV4ZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2xleGVyc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3VzdG9tR3JhbW1hclV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9jdXN0b21HcmFtbWFyXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEN1c3RvbUdyYW1tYXIsIGN1c3RvbUdyYW1tYXJVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tY3VzdG9tLWdyYW1tYXJzXCI7XG5cbmNvbnN0IHsgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUN1c3RvbUdyYW1tYXJzIH0gPSBjdXN0b21HcmFtbWFyVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKSB7XG4gIGNvbnN0IHRlcm1CTkYgPSBlbnRyaWVzLmdldFRlcm1CTkYoKSxcbiAgICAgICAgc3RhdGVtZW50Qk5GID0gZW50cmllcy5nZXRTdGF0ZW1lbnRCTkYoKSxcbiAgICAgICAgdHlwZVZvY2FidWxhcnkgPSBlbnRyaWVzLmdldFR5cGVWb2NhYnVsYXJ5KCksXG4gICAgICAgIHN5bWJvbFZvY2FidWxhcnkgPSBlbnRyaWVzLmdldFN5bWJvbFZvY2FidWxhcnkoKSxcbiAgICAgICAgY3VzdG9tR3JhbW1hciA9IEN1c3RvbUdyYW1tYXIuZnJvbU5hbWVUZXJtQk5GU3RhdGVtZW50Qk5GVHlwZVZvY2FidWxhcnlBbmRTeW1ib2xWb2NhYnVsYXJ5KG5hbWUsIHRlcm1CTkYsIHN0YXRlbWVudEJORiwgdHlwZVZvY2FidWxhcnksIHN5bWJvbFZvY2FidWxhcnkpO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dHMpIHtcbiAgY29uc3QgY3VzdG9tR3JhbW1hcnMgPSByZWxlYXNlQ29udGV4dHMubWFwKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGN1c3RvbUdyYW1tYXIgPSByZWxlYXNlQ29udGV4dC5nZXRDdXN0b21HcmFtbWFyKCk7XG5cbiAgICByZXR1cm4gY3VzdG9tR3JhbW1hcjtcbiAgfSk7XG5cbiAgY29uc3QgY29tYmluZWRDdXN0b21HcmFtbWFyID0gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbUN1c3RvbUdyYW1tYXJzKGN1c3RvbUdyYW1tYXJzKTtcblxuICByZXR1cm4gY29tYmluZWRDdXN0b21HcmFtbWFyO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsZUNvbnRleHRzRnJvbUpTT04oanNvbiwgZmlsZUNvbnRleHRzLCByZWxlYXNlQ29udGV4dCwgRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgpIHtcbiAgY29uc3QgZmlsZUNvbnRleHRzSlNPTiA9IGpzb247ICAvLy9cblxuICBmaWxlQ29udGV4dHNKU09OLmZvckVhY2goKGZpbGVDb250ZXh0SlNPTikgPT4ge1xuICAgIGNvbnN0IHsgZmlsZVBhdGggfSA9IGZpbGVDb250ZXh0SlNPTixcbiAgICAgICAgICBGaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgIGlmIChGaWxlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QganNvbiA9IGZpbGVDb250ZXh0SlNPTiwgLy8vXG4gICAgICAgICAgICBmaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0LmZyb21KU09OKGpzb24sIHJlbGVhc2VDb250ZXh0KTtcblxuICAgICAgZmlsZUNvbnRleHRzLnB1c2goZmlsZUNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlQ29udGV4dHNGcm9tRW50cmllcyhlbnRyaWVzLCBmaWxlQ29udGV4dHMsIHJlbGVhc2VDb250ZXh0LCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCkge1xuICBlbnRyaWVzLmZvckVhY2hGaWxlKChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBGaWxlQ29udGV4dCA9IEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgIGlmIChGaWxlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZmlsZUNvbnRleHQgPSBGaWxlQ29udGV4dC5mcm9tRmlsZShmaWxlLCByZWxlYXNlQ29udGV4dCk7XG5cbiAgICAgIGZpbGVDb250ZXh0cy5wdXNoKGZpbGVDb250ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpbGVDb250ZXh0c0Zyb21KU09OLFxuICBmaWxlQ29udGV4dHNGcm9tRW50cmllc1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IHZlcmlmeVR5cGVQcmVmaXhlcywgdmVyaWZ5RmlsZUNvbnRleHRzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy92ZXJpZnlcIjtcbmltcG9ydCB7IGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21SZWxlYXNlQ29udGV4dHMgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2N1c3RvbUdyYW1tYXJcIjtcbmltcG9ydCB7IGZpbGVDb250ZXh0c0Zyb21KU09OLCBmaWxlQ29udGV4dHNGcm9tRW50cmllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvZmlsZUNvbnRleHRcIjtcbmltcG9ydCB7IFRSQUNFX0xFVkVMLCBERUJVR19MRVZFTCwgSU5GT19MRVZFTCwgV0FSTklOR19MRVZFTCwgRVJST1JfTEVWRUwsIEJSRUFLX01FU1NBR0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgcHVzaCwgdGFpbCwgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxlYXNlQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIsIHZlcmlmaWVzLCBpbml0aWFsaXNlZCwgZmlsZUNvbnRleHRzLCBjb21iaW5lZEN1c3RvbUdyYW1tYXIsIGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMpIHtcbiAgICB0aGlzLmxvZyA9IGxvZztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hcjtcbiAgICB0aGlzLnZlcmlmaWVzID0gdmVyaWZpZXM7XG4gICAgdGhpcy5pbml0aWFsaXNlZCA9IGluaXRpYWxpc2VkO1xuICAgIHRoaXMuZmlsZUNvbnRleHRzID0gZmlsZUNvbnRleHRzO1xuICAgIHRoaXMuY29tYmluZWRDdXN0b21HcmFtbWFyID0gY29tYmluZWRDdXN0b21HcmFtbWFyO1xuICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyA9IGRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHM7XG4gIH1cblxuICBnZXRMb2coKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0SlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5qc29uO1xuICB9XG5cbiAgZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzO1xuICB9XG5cbiAgZ2V0Q2FsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2s7XG4gIH1cblxuICBnZXRDdXN0b21HcmFtbWFyKCkge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbUdyYW1tYXI7XG4gIH1cblxuICBnZXRWZXJpZmllcygpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZmllcztcbiAgfVxuXG4gIGlzSW5pdGlhbGlzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGlzZWQ7XG4gIH1cblxuICBnZXRGaWxlQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZUNvbnRleHRzO1xuICB9XG5cbiAgZ2V0Q29tYmluZWRDdXN0b21HcmFtbWFyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkQ3VzdG9tR3JhbW1hcjtcbiAgfVxuXG4gIGdldERlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cztcbiAgfVxuXG4gIGdldFJlbGVhc2VDb250ZXh0KCkge1xuICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0ID0gdGhpczsgIC8vL1xuXG4gICAgcmV0dXJuIHJlbGVhc2VDb250ZXh0O1xuICB9XG5cbiAgZ2V0RGVwdGgoKSB7XG4gICAgY29uc3QgZGVwdGggPSAwO1xuXG4gICAgcmV0dXJuIGRlcHRoO1xuICB9XG5cbiAgaGFzVmVyaWZpZWQoKSB7XG4gICAgY29uc3QgdmVyaWZpZWQgPSB0aGlzLnZlcmlmaWVzOyAvLy9cblxuICAgIHJldHVybiB2ZXJpZmllZDtcbiAgfVxuXG4gIGlzUmVsZWFzZWQoKSB7XG4gICAgY29uc3QgcmVsZWFzZWQgPSAodGhpcy5qc29uICE9PSBudWxsKTtcblxuICAgIHJldHVybiByZWxlYXNlZDtcbiAgfVxuXG4gIGdldFR5cGVQcmVmaXgoKSB7XG4gICAgbGV0IHR5cGVQcmVmaXggPSBudWxsO1xuXG4gICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgIHR5cGVQcmVmaXhlcyA9IHRoaXMuZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpLFxuICAgICAgICAgIHR5cGVQcmVmaXhlc0xlbmd0aCA9IHR5cGVQcmVmaXhlcy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZVByZWZpeGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBmaXJzdFR5cGVQcmVmaXggPSBmaXJzdCh0eXBlUHJlZml4ZXMpO1xuXG4gICAgICB0eXBlUHJlZml4ID0gZmlyc3RUeXBlUHJlZml4OyAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZVByZWZpeDtcbiAgfVxuXG4gIGdldExhYmVscyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dExhYmVscyA9IGZpbGVDb250ZXh0LmdldExhYmVscyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2gobGFiZWxzLCBmaWxlQ29udGV4dExhYmVscyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRMYWJlbHMgPSByZWxlYXNlQ29udGV4dC5nZXRMYWJlbHMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChsYWJlbHMsIHJlbGVhc2VDb250ZXh0TGFiZWxzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH1cblxuICBnZXRUeXBlcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHR5cGVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0VHlwZXMgPSBmaWxlQ29udGV4dC5nZXRUeXBlcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2godHlwZXMsIGZpbGVDb250ZXh0VHlwZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0VHlwZXMgPSByZWxlYXNlQ29udGV4dC5nZXRUeXBlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKHR5cGVzLCByZWxlYXNlQ29udGV4dFR5cGVzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlcztcbiAgfVxuXG4gIGdldFJ1bGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgcnVsZXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRSdWxlcyA9IGZpbGVDb250ZXh0LmdldFJ1bGVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChydWxlcywgZmlsZUNvbnRleHRSdWxlcyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRSdWxlcyA9IHJlbGVhc2VDb250ZXh0LmdldFJ1bGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2gocnVsZXMsIHJlbGVhc2VDb250ZXh0UnVsZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgZ2V0QXhpb21zKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgYXhpb21zID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0QXhpb21zID0gZmlsZUNvbnRleHQuZ2V0QXhpb21zKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChheGlvbXMsIGZpbGVDb250ZXh0QXhpb21zKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dEF4aW9tcyA9IHJlbGVhc2VDb250ZXh0LmdldEF4aW9tcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKGF4aW9tcywgcmVsZWFzZUNvbnRleHRBeGlvbXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF4aW9tcztcbiAgfVxuXG4gIGdldExlbW1hcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxlbW1hcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dExlbW1hcyA9IGZpbGVDb250ZXh0LmdldExlbW1hcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2gobGVtbWFzLCBmaWxlQ29udGV4dExlbW1hcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGVtbWFzO1xuICB9XG5cbiAgZ2V0VGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCB0aGVvcmVtcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dFRoZW9yZW1zID0gZmlsZUNvbnRleHQuZ2V0VGhlb3JlbXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKHRoZW9yZW1zLCBmaWxlQ29udGV4dFRoZW9yZW1zKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFRoZW9yZW1zID0gcmVsZWFzZUNvbnRleHQuZ2V0VGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaCh0aGVvcmVtcywgcmVsZWFzZUNvbnRleHRUaGVvcmVtcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhlb3JlbXM7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dFByb2NlZHVyZXMgPSBmaWxlQ29udGV4dC5nZXRQcm9jZWR1cmVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChwcm9jZWR1cmVzLCBmaWxlQ29udGV4dFByb2NlZHVyZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0UHJvY2VkdXJlcyA9IHJlbGVhc2VDb250ZXh0LmdldFByb2NlZHVyZXMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChwcm9jZWR1cmVzLCByZWxlYXNlQ29udGV4dFByb2NlZHVyZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2NlZHVyZXM7XG4gIH1cblxuICBnZXRNZXRhTGVtbWFzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YUxlbW1hcyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dE1ldGFMZW1tYXMgPSBmaWxlQ29udGV4dC5nZXRNZXRhTGVtbWFzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChtZXRhTGVtbWFzLCBmaWxlQ29udGV4dE1ldGFMZW1tYXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1ldGFMZW1tYXM7XG4gIH1cblxuICBnZXRDb25qZWN0dXJlcyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbmplY3R1cmVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0Q29uamVjdHVyZXMgPSBmaWxlQ29udGV4dC5nZXRDb25qZWN0dXJlcyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2goY29uamVjdHVyZXMsIGZpbGVDb250ZXh0Q29uamVjdHVyZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0Q29uamVjdHVyZXMgPSByZWxlYXNlQ29udGV4dC5nZXRDb25qZWN0dXJlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKGNvbmplY3R1cmVzLCByZWxlYXNlQ29udGV4dENvbmplY3R1cmVzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb25qZWN0dXJlcztcbiAgfVxuXG4gIGdldENvbWJpbmF0b3JzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgY29tYmluYXRvcnMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRDb21iaW5hdG9ycyA9IGZpbGVDb250ZXh0LmdldENvbWJpbmF0b3JzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaChjb21iaW5hdG9ycywgZmlsZUNvbnRleHRDb21iaW5hdG9ycyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRDb21iaW5hdG9ycyA9IHJlbGVhc2VDb250ZXh0LmdldENvbWJpbmF0b3JzKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2goY29tYmluYXRvcnMsIHJlbGVhc2VDb250ZXh0Q29tYmluYXRvcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmF0b3JzO1xuICB9XG5cbiAgZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVEZXBlbmRlbmNpZXMgPSB0cnVlKSB7XG4gICAgY29uc3QgdHlwZVByZWZpeGVzID0gW107XG5cbiAgICB0aGlzLmZpbGVDb250ZXh0cy5mb3JFYWNoKChmaWxlQ29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZVJlbGVhc2UgPSBmYWxzZSxcbiAgICAgICAgICAgIGZpbGVDb250ZXh0VHlwZVByZWZpeGVzID0gZmlsZUNvbnRleHQuZ2V0VHlwZVByZWZpeGVzKGluY2x1ZGVSZWxlYXNlKTtcblxuICAgICAgcHVzaCh0eXBlUHJlZml4ZXMsIGZpbGVDb250ZXh0VHlwZVByZWZpeGVzKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmNsdWRlRGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMuZm9yRWFjaCgocmVsZWFzZUNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgaW5jbHVkZURlcGVuZGVuY2llcyA9IGZhbHNlLFxuICAgICAgICAgICAgICByZWxlYXNlQ29udGV4dFR5cGVQcmVmaXhlcyA9IHJlbGVhc2VDb250ZXh0LmdldFR5cGVQcmVmaXhlcyhpbmNsdWRlRGVwZW5kZW5jaWVzKTtcblxuICAgICAgICBwdXNoKHR5cGVQcmVmaXhlcywgcmVsZWFzZUNvbnRleHRUeXBlUHJlZml4ZXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVQcmVmaXhlcztcbiAgfVxuXG4gIGdldENvbnN0cnVjdG9ycyhpbmNsdWRlRGVwZW5kZW5jaWVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9ycyA9IFtdO1xuXG4gICAgdGhpcy5maWxlQ29udGV4dHMuZm9yRWFjaCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVSZWxlYXNlID0gZmFsc2UsXG4gICAgICAgICAgICBmaWxlQ29udGV4dENvbnN0cnVjdG9ycyA9IGZpbGVDb250ZXh0LmdldENvbnN0cnVjdG9ycyhpbmNsdWRlUmVsZWFzZSk7XG5cbiAgICAgIHB1c2goY29uc3RydWN0b3JzLCBmaWxlQ29udGV4dENvbnN0cnVjdG9ycyk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5jbHVkZURlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzLmZvckVhY2goKHJlbGVhc2VDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVEZXBlbmRlbmNpZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHRDb25zdHJ1Y3RvcnMgPSByZWxlYXNlQ29udGV4dC5nZXRDb25zdHJ1Y3RvcnMoaW5jbHVkZURlcGVuZGVuY2llcyk7XG5cbiAgICAgICAgcHVzaChjb25zdHJ1Y3RvcnMsIHJlbGVhc2VDb250ZXh0Q29uc3RydWN0b3JzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zdHJ1Y3RvcnM7XG4gIH1cblxuICBnZXRNZXRhdGhlb3JlbXMoaW5jbHVkZURlcGVuZGVuY2llcyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhdGhlb3JlbXMgPSBbXTtcblxuICAgIHRoaXMuZmlsZUNvbnRleHRzLmZvckVhY2goKGZpbGVDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlUmVsZWFzZSA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRNZXRhdGhlb3JlbXMgPSBmaWxlQ29udGV4dC5nZXRNZXRhdGhlb3JlbXMoaW5jbHVkZVJlbGVhc2UpO1xuXG4gICAgICBwdXNoKG1ldGF0aGVvcmVtcywgZmlsZUNvbnRleHRNZXRhdGhlb3JlbXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGluY2x1ZGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cy5mb3JFYWNoKChyZWxlYXNlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBpbmNsdWRlRGVwZW5kZW5jaWVzID0gZmFsc2UsXG4gICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0TWV0YXRoZW9yZW1zID0gcmVsZWFzZUNvbnRleHQuZ2V0TWV0YXRoZW9yZW1zKGluY2x1ZGVEZXBlbmRlbmNpZXMpO1xuXG4gICAgICAgIHB1c2gobWV0YXRoZW9yZW1zLCByZWxlYXNlQ29udGV4dE1ldGF0aGVvcmVtcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YXRoZW9yZW1zO1xuICB9XG5cbiAgZ2V0RGVwZW5kZW5jaWVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldERlcGVuZGVuY2llcygpOyB9XG5cbiAgbWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pIHsgcmV0dXJuIHRoaXMuZW50cmllcy5tYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbik7IH1cblxuICBmaW5kRmlsZShmaWxlUGF0aCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmZpbmRGaWxlKGZpbGVQYXRoKTsgfVxuXG4gIGZpbmRGaWxlQ29udGV4dChmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVDb250ZXh0ID0gdGhpcy5maWxlQ29udGV4dHMuZmluZCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVQYXRoTWF0Y2hlcyA9IGZpbGVDb250ZXh0Lm1hdGNoRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgICBpZiAoZmlsZVBhdGhNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gZmlsZUNvbnRleHQ7XG4gIH1cblxuICB0cmFjZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBUUkFDRV9MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBERUJVR19MRVZFTDtcblxuICAgIHRoaXMud3JpdGVUb0xvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH1cblxuICBpbmZvKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IElORk9fTEVWRUw7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UpO1xuICB9XG5cbiAgd2FybmluZyhtZXNzYWdlKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBXQVJOSU5HX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBsZXZlbCA9IEVSUk9SX0xFVkVMO1xuXG4gICAgdGhpcy53cml0ZVRvTG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHdyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoID0gbnVsbCwgbGluZUluZGV4ID0gbnVsbCkge1xuICAgIHRoaXMubG9nLndyaXRlKGxldmVsLCBtZXNzYWdlLCBmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGluaXRpYWxpc2UocmVsZWFzZUNvbnRleHRzLCBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCkge1xuICAgIGNvbnN0IHJlbGVhc2VkID0gdGhpcy5pc1JlbGVhc2VkKCksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLCAgLy8vXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHRzVGFpbCA9IHRhaWwocmVsZWFzZUNvbnRleHRzKTtcblxuICAgIHRoaXMuZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyA9IHJlbGVhc2VDb250ZXh0c1RhaWw7IC8vL1xuXG4gICAgdGhpcy5jb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tUmVsZWFzZUNvbnRleHRzKHJlbGVhc2VDb250ZXh0cyk7XG5cbiAgICByZWxlYXNlZCA/XG4gICAgICBmaWxlQ29udGV4dHNGcm9tSlNPTih0aGlzLmpzb24sIHRoaXMuZmlsZUNvbnRleHRzLCByZWxlYXNlQ29udGV4dCwgRmlsZUNvbnRleHRGcm9tRmlsZVBhdGgpIDpcbiAgICAgICAgZmlsZUNvbnRleHRzRnJvbUVudHJpZXModGhpcy5lbnRyaWVzLCB0aGlzLmZpbGVDb250ZXh0cywgcmVsZWFzZUNvbnRleHQsIEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKTtcblxuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSB0cnVlO1xuICB9XG5cbiAgYXN5bmMgYnJlYWsoZmlsZVBhdGgsIGxpbmVJbmRleCkge1xuICAgIGNvbnN0IGxldmVsID0gVFJBQ0VfTEVWRUwsXG4gICAgICAgICAgbWVzc2FnZSA9IEJSRUFLX01FU1NBR0U7XG5cbiAgICB0aGlzLndyaXRlVG9Mb2cobGV2ZWwsIG1lc3NhZ2UsIGZpbGVQYXRoLCBsaW5lSW5kZXgpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXM7IC8vL1xuXG4gICAgYXdhaXQgdGhpcy5jYWxsYmFjayhjb250ZXh0LCBmaWxlUGF0aCwgbGluZUluZGV4KTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeSgpIHtcbiAgICBsZXQgdmVyaWZpZXMgPSBmYWxzZTtcblxuICAgIGNvbnN0IHR5cGVQcmVmaXhlcyA9IHRoaXMuZ2V0VHlwZVByZWZpeGVzKCksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHQgPSB0aGlzLCAvLy9cbiAgICAgICAgICB0eXBlUHJlZml4ZXNWZXJpZnkgPSB2ZXJpZnlUeXBlUHJlZml4ZXModHlwZVByZWZpeGVzLCByZWxlYXNlQ29udGV4dCk7XG5cbiAgICBpZiAodHlwZVByZWZpeGVzVmVyaWZ5KSB7XG4gICAgICBjb25zdCB2ZXJpZmllZEZpbGVDb250ZXh0cyA9IFtdLFxuICAgICAgICAgICAgZmlsZUNvbnRleHRzVmVyaWZ5ID0gYXdhaXQgdmVyaWZ5RmlsZUNvbnRleHRzKHRoaXMuZmlsZUNvbnRleHRzLCB2ZXJpZmllZEZpbGVDb250ZXh0cyk7XG5cbiAgICAgIGlmIChmaWxlQ29udGV4dHNWZXJpZnkpIHtcbiAgICAgICAgdmVyaWZpZXMgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMudmVyaWZpZXMgPSB2ZXJpZmllcztcblxuICAgICAgICB0aGlzLmZpbGVDb250ZXh0cyA9IHZlcmlmaWVkRmlsZUNvbnRleHRzOyAvLy9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZpZXM7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgZmlsZUNvbnRleHRzSlNPTiA9IHRoaXMuZmlsZUNvbnRleHRzLm1hcCgoZmlsZUNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVDb250ZXh0SlNPTiA9IGZpbGVDb250ZXh0LnRvSlNPTigpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRleHRKU09OO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGpzb24gPSBmaWxlQ29udGV4dHNKU09OOyAgLy8vXG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTG9nTmFtZUpTT05FbnRyaWVzQ2FsbGJhY2tBbmRDdXN0b21HcmFtbWFyKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIpIHtcbiAgICBjb25zdCB2ZXJpZmllcyA9IGZhbHNlLFxuICAgICAgICAgIGluaXRpYWxpc2VkID0gZmFsc2UsXG4gICAgICAgICAgZmlsZUNvbnRleHRzID0gW10sXG4gICAgICAgICAgY29tYmluZWRDdXN0b21HcmFtbWFyID0gbnVsbCxcbiAgICAgICAgICBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzID0gbnVsbCxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IG5ldyBSZWxlYXNlQ29udGV4dChsb2csIG5hbWUsIGpzb24sIGVudHJpZXMsIGNhbGxiYWNrLCBjdXN0b21HcmFtbWFyLCB2ZXJpZmllcywgaW5pdGlhbGlzZWQsIGZpbGVDb250ZXh0cywgY29tYmluZWRDdXN0b21HcmFtbWFyLCBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzKTtcblxuICAgIHJldHVybiByZWxlYXNlQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIGFzIE5vblRlcm1pbmFsTm9kZUJhc2UgfSBmcm9tIFwib2NjYW0tcGFyc2Vyc1wiO1xuXG5jb25zdCB7IGZpcnN0IH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uVGVybWluYWxOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlQmFzZSB7XG4gIHNvbWVUZXJtaW5hbE5vZGUoY2FsbGJhY2ssIHRva2VuVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnNvbWVDaGlsZE5vZGUoKGNoaWxkTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZVRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHRlcm1pbmFsTm9kZVR5cGUgPSB0ZXJtaW5hbE5vZGUuZ2V0VHlwZSgpO1xuXG4gICAgICAgIGlmICh0ZXJtaW5hbE5vZGVUeXBlID09PSB0b2tlblR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGVybWluYWxOb2RlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldE5vZGVCeVJ1bGVOYW1lKC4uLnJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmRDaGlsZE5vZGUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2hpbGROb2RlTm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLmlzTm9uVGVybWluYWxOb2RlKCk7XG5cbiAgICAgIGlmIChjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldE5vZGVzQnlSdWxlTmFtZSguLi5ydWxlTmFtZXMpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZmlsdGVyQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGdldExhc3ROb2RlQnlSdWxlTmFtZSguLi5ydWxlTmFtZXMpIHtcbiAgICBsZXQgbGFzdE5vZGUgPSBudWxsO1xuXG4gICAgdGhpcy5iYWNrd2FyZHNTb21lQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZE5vZGU7IC8vL1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXN0Tm9kZTtcbiAgfVxuXG4gIGdldEZpcnN0Tm9kZUJ5UnVsZU5hbWUoLi4ucnVsZU5hbWVzKSB7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IG51bGw7XG5cbiAgICB0aGlzLmZvcndhcmRzU29tZUNoaWxkTm9kZSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZE5vZGVOb25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgaWYgKGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSkge1xuICAgICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBjaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgICAgICBydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lID0gcnVsZU5hbWVzLmluY2x1ZGVzKHJ1bGVOYW1lKTtcblxuICAgICAgICBpZiAocnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSkge1xuICAgICAgICAgIGZpcnN0Tm9kZSA9IGNoaWxkTm9kZTsgLy8vXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpcnN0Tm9kZTtcbiAgfVxuXG4gIGdldFNpbmd1bGFyTm9kZUJ5UnVsZU5hbWUoLi4ucnVsZU5hbWVzKSB7XG4gICAgbGV0IHNpbmd1bGFyTm9kZSA9IG51bGw7XG5cbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZmlsdGVyQ2hpbGROb2RlKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZU5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gbm9uVGVybWluYWxOb2RlLmdldFJ1bGVOYW1lKCksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUgPSBydWxlTmFtZXMuaW5jbHVkZXMocnVsZU5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChydWxlTmFtZXNJbmNsdWRlc1J1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGlmIChub2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3Qobm9kZXMpO1xuXG4gICAgICBzaW5ndWxhck5vZGUgPSBmaXJzdE5vZGU7IC8vL1xuICAgIH1cblxuICAgIHJldHVybiBzaW5ndWxhck5vZGU7XG4gIH1cblxuICBnZXREZXNjZW5kYW50Tm9kZXNCeVJ1bGVOYW1lKC4uLnJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5maWx0ZXJEZXNjZW5kYW50Tm9kZSgoZGVzY2VuZGFudE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NlbmRhbnROb2RlTm9uVGVybWluYWxOb2RlID0gZGVzY2VuZGFudE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgICAgaWYgKGRlc2NlbmRhbnROb2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IGRlc2NlbmRhbnROb2RlLCAvLy9cbiAgICAgICAgICAgICAgcnVsZU5hbWUgPSBub25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKSxcbiAgICAgICAgICAgICAgcnVsZU5hbWVzSW5jbHVkZXNSdWxlTmFtZSA9IHJ1bGVOYW1lcy5pbmNsdWRlcyhydWxlTmFtZSk7XG5cbiAgICAgICAgaWYgKHJ1bGVOYW1lc0luY2x1ZGVzUnVsZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZUJhc2UuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICBub2RlID0gbm9kZXMuc2hpZnQoKSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZXNRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbm9kZVF1ZXJ5LFxuICBub2Rlc1F1ZXJ5LFxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgbm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuXG5jb25zdCB7IG1hdGNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGNvbnN0IG5vblRlcm1pbmFsTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiLypcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMobm9kZXMpIHtcbiAgY29uc3QgdGVybWluYWxOb2RlTWFwID0ge307XG5cbiAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvL1xuXG4gICAgICB0ZXJtaW5hbE5vZGVNYXBbaW5kZXhdID0gdGVybWluYWxOb2RlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1pbmFsTm9kZU1hcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbChnZW5lcmFsVGVybWluYWxOb2RlTWFwLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZU1hcCkge1xuICBsZXQgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gZmFsc2U7XG5cbiAgY29uc3QgZ2VuZXJhbEluZGV4ZXMgPSBPYmplY3Qua2V5cyhnZW5lcmFsVGVybWluYWxOb2RlTWFwKSwgLy8vXG4gICAgICAgIHNwZWNpZmljSW5kZXhlcyA9IE9iamVjdC5rZXlzKHNwZWNpZmljVGVybWluYWxOb2RlTWFwKSwgLy8vXG4gICAgICAgIHRlcm1pbmFsTm9kZU1hcEtleXNNYXRjaCA9IG1hdGNoKGdlbmVyYWxJbmRleGVzLCBzcGVjaWZpY0luZGV4ZXMsIChnZW5lcmFsSW5kZXgsIHNwZWNpZmljSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoZ2VuZXJhbEluZGV4ID09PSBzcGVjaWZpY0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIGlmICh0ZXJtaW5hbE5vZGVNYXBLZXlzTWF0Y2gpIHtcbiAgICBjb25zdCBnZW5lcmFsVGVybWluYWxOb2RlcyA9IE9iamVjdC52YWx1ZXMoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCksIC8vL1xuICAgICAgICAgIHNwZWNpZmljVGVybWluYWxOb2RlcyA9IE9iamVjdC52YWx1ZXMoc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXApLCAvLy9cbiAgICAgICAgICB0ZXJtaW5hbE5vZGVNYXBWYWx1ZXNNYXRjaCA9IG1hdGNoKGdlbmVyYWxUZXJtaW5hbE5vZGVzLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZXMsIChnZW5lcmFsVGVybWluYWxOb2RlLCBzcGVjaWZpY1Rlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhbFRlcm1pbmFsTm9kZU1hdGNoZXNTcGVjaWZpY1Rlcm1pbmFsTm9kZSA9IGdlbmVyYWxUZXJtaW5hbE5vZGUubWF0Y2goc3BlY2lmaWNUZXJtaW5hbE5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hdGNoZXNTcGVjaWZpY1Rlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgIHRlcm1pbmFsTm9kZU1hcHNFcXVhbCA9IHRlcm1pbmFsTm9kZU1hcFZhbHVlc01hdGNoOyAvLy9cbiAgfVxuXG4gIHJldHVybiB0ZXJtaW5hbE5vZGVNYXBzRXF1YWw7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LCB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMsIGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaaXBQYXNzIHtcbiAgcnVuKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBzdWNjZXNzO1xuXG4gICAgY29uc3QgdmlzaXRlZCA9IHRoaXMudmlzaXROb2RlKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICBzdWNjZXNzID0gdmlzaXRlZDsgIC8vL1xuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cblxuICBkZXNjZW5kKGdlbmVyYWxDaGlsZE5vZGVzLCBzcGVjaWZpY0NoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBkZXNjZW5kZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGdlbmVyYWxDaGlsZE5vZGVzTGVuZ3RoID0gZ2VuZXJhbENoaWxkTm9kZXMubGVuZ3RoLFxuICAgICAgICAgIHNwZWNpZmljQ2hpbGROb2Rlc0xlbmd0aCA9IHNwZWNpZmljQ2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoZ2VuZXJhbENoaWxkTm9kZXNMZW5ndGggPT09IHNwZWNpZmljQ2hpbGROb2Rlc0xlbmd0aCkge1xuICAgICAgY29uc3Qgc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMoc3BlY2lmaWNDaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIGdlbmVyYWxUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMoZ2VuZXJhbENoaWxkTm9kZXMpLFxuICAgICAgICAgICAgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gYXJlVGVybWluYWxOb2RlTWFwc0VxdWFsKGdlbmVyYWxUZXJtaW5hbE5vZGVNYXAsIHNwZWNpZmljVGVybWluYWxOb2RlTWFwKTtcblxuICAgICAgaWYgKHRlcm1pbmFsTm9kZU1hcHNFcXVhbCkge1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gZ2VuZXJhbENoaWxkTm9kZXMuZXZlcnkoKGdlbmVyYWxDaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3BlY2lmaWNDaGlsZE5vZGUgPSBzcGVjaWZpY0NoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIHNwZWNpZmljTm9kZSA9IHNwZWNpZmljQ2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgICAgICBnZW5lcmFsTm9kZSA9IGdlbmVyYWxDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShnZW5lcmFsTm9kZSwgc3BlY2lmaWNOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgICBkZXNjZW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NlbmRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShnZW5lcmFsTm9kZSwgc3BlY2lmaWNOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgZ2VuZXJhbE5vZGVUZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHNwZWNpZmljTm9kZVRlcm1pbmFsTm9kZSA9IHNwZWNpZmljTm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIGdlbmVyYWxOb2RlTm9uVGVybWluYWxOb2RlID0gZ2VuZXJhbE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgICBzcGVjaWZpY05vZGVOb25UZXJtaW5hbE5vZGUgPSBzcGVjaWZpY05vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmIChnZW5lcmFsTm9kZVRlcm1pbmFsTm9kZSAmJiBzcGVjaWZpY05vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGdlbmVyYWxUZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZSwgIC8vL1xuICAgICAgICAgICAgc3BlY2lmaWNUZXJtaW5hbE5vZGUgPSBzcGVjaWZpY05vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUoZ2VuZXJhbFRlcm1pbmFsTm9kZSwgc3BlY2lmaWNUZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChnZW5lcmFsTm9kZU5vblRlcm1pbmFsTm9kZSAmJiBzcGVjaWZpY05vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGdlbmVyYWxOb25UZXJtaW5hbE5vZGUgPSBnZW5lcmFsTm9kZSwgIC8vL1xuICAgICAgICAgICAgc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUgPSBzcGVjaWZpY05vZGU7IC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShnZW5lcmFsTm9uVGVybWluYWxOb2RlLCBzcGVjaWZpY05vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0VGVybWluYWxOb2RlKGdlbmVyYWxUZXJtaW5hbE5vZGUsIHNwZWNpZmljVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgLy8vXG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICB2aXNpdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUoZ2VuZXJhbE5vblRlcm1pbmFsTm9kZSwgc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBnZW5lcmFsTm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgc3BlY2lmaWNOb2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IChnZW5lcmFsTm9kZSwgc3BlY2lmaWNOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgZ2VuZXJhbE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gZ2VuZXJhbE5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLCAvLy9cbiAgICAgICAgICAgICAgICBzcGVjaWZpY05vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTsgLy8vXG5cbiAgICAgICAgICBpZiAoZ2VuZXJhbE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSBzcGVjaWZpY05vblRlcm1pbmFsTm9kZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmFsTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcyA9IGdlbmVyYWxOb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgc3BlY2lmaWNOb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgZ2VuZXJhbENoaWxkTm9kZXMgPSBnZW5lcmFsTm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgICAgICBzcGVjaWZpY0NoaWxkTm9kZXMgPSBzcGVjaWZpY05vblRlcm1pbmFsTm9kZUNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGdlbmVyYWxDaGlsZE5vZGVzLCBzcGVjaWZpY0NoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChkZXNjZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBtYXBzLnNvbWUoKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBnZW5lcmFsTm9kZVF1ZXJ5LCBzcGVjaWZpY05vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IGdlbmVyYWxOb2RlID0gZ2VuZXJhbE5vZGVRdWVyeShnZW5lcmFsTm9uVGVybWluYWxOb2RlKSwgIC8vL1xuICAgICAgICAgICAgc3BlY2lmaWNOb2RlID0gc3BlY2lmaWNOb2RlUXVlcnkoc3BlY2lmaWNOb25UZXJtaW5hbE5vZGUpOyAgLy8vXG5cbiAgICAgIGlmICgoZ2VuZXJhbE5vZGUgIT09IG51bGwpICYmIChzcGVjaWZpY05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgID0gcnVuKGdlbmVyYWxOb2RlLCBzcGVjaWZpY05vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgdmlzaXRlZCA9IHN1Y2Nlc3M7ICAvLy9cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vblRlcm1pbmFsTm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXNzXCI7XG5pbXBvcnQgeyBhc3luY1NvbWUsIGFzeW5jRXZlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc3luY1Bhc3Mge1xuICBhc3luYyBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gYXdhaXQgdGhpcy52aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGFzeW5jIGRlc2NlbmQoY2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlc2NlbmRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgdmlzaXRlZCA9IGF3YWl0IGFzeW5jRXZlcnkoY2hpbGROb2RlcywgYXN5bmMgKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICB2aXNpdGVkID0gYXdhaXQgdGhpcy52aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodmlzaXRlZCkge1xuICAgICAgZGVzY2VuZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY2VuZGVkO1xuICB9XG5cbiAgYXN5bmMgdmlzaXROb2RlKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkO1xuXG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlOyAgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSBhd2FpdCB0aGlzLnZpc2l0VGVybWluYWxOb2RlKHRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gYXdhaXQgdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICBhc3luYyB2aXNpdFRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGNvbnN0IHZpc2l0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cblxuICBhc3luYyB2aXNpdE5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBub2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IGFzeW5jIChub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IG5vblRlcm1pbmFsTm9kZS5nZXRDaGlsZE5vZGVzKCksIC8vL1xuICAgICAgICAgICAgICAgIGRlc2NlbmRlZCA9IGF3YWl0IHRoaXMuZGVzY2VuZChjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKGRlc2NlbmRlZCkge1xuICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBhd2FpdCBhc3luY1NvbWUobWFwcywgYXN5bmMgKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBub2RlUXVlcnksIHJ1biB9ID0gbWFwO1xuXG4gICAgICBjb25zdCBub2RlID0gbm9kZVF1ZXJ5KG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzczsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Bhc3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlUGFzcyB7XG4gIHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgc3VjY2VzcztcblxuICAgIGNvbnN0IHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgc3VjY2VzcyA9IHZpc2l0ZWQ7ICAvLy9cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG5cbiAgZGVzY2VuZChjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgZGVzY2VuZGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gY2hpbGROb2Rlcy5ldmVyeSgoY2hpbGROb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh2aXNpdGVkKSB7XG4gICAgICBkZXNjZW5kZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjZW5kZWQ7XG4gIH1cblxuICB2aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICBjb25zdCBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKG5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUodGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlOyAgLy8vXG5cbiAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0VGVybWluYWxOb2RlKHRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgY29uc3QgdmlzaXRlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgIGxldCB7IG1hcHMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG5cbiAgICBtYXBzID0gWyAvLy9cbiAgICAgIC4uLm1hcHMsXG4gICAgICB7XG4gICAgICAgIG5vZGVRdWVyeTogbm9uVGVybWluYWxOb2RlUXVlcnksXG4gICAgICAgIHJ1bjogKG5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykgPT4ge1xuICAgICAgICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSwgLy8vXG4gICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICBpZiAoZGVzY2VuZGVkKSB7XG4gICAgICAgICAgICB2aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlzaXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cblxuICAgIG1hcHMuc29tZSgobWFwKSA9PiB7XG4gICAgICBjb25zdCB7IG5vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlUXVlcnkobm9uVGVybWluYWxOb2RlKTtcblxuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHJ1bihub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgIHZpc2l0ZWQgPSBzdWNjZXNzO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbm9uVGVybWluYWxOb2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Bhc3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9yd2FyZFBhc3Mge1xuICBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gdGhpcy52aXNpdE5vZGUobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGRlc2NlbmQoaW5kZXgsIGNoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCBkZXNjZW5kZWRGb3J3YXJkID0gZmFsc2U7XG5cbiAgICBjb25zdCBkZXNjZW5kRm9yd2FyZCA9IHJlbWFpbmluZ0FyZ3VtZW50cy5wb3AoKSwgLy8vXG4gICAgICAgICAgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKGluZGV4ID09PSBjaGlsZE5vZGVzTGVuZ3RoKSB7XG4gICAgICBkZXNjZW5kZWRGb3J3YXJkID0gZGVzY2VuZEZvcndhcmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICAgICAgICBub2RlID0gY2hpbGROb2RlLCAvLy9cbiAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVtYWluaW5nQXJndW1lbnRzLnB1c2goZGVzY2VuZEZvcndhcmQpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGFoZWFkSW5kZXggPSBpbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRlZEZvcndhcmQgPSB0aGlzLmRlc2NlbmQoYWhlYWRJbmRleCwgY2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZGVzY2VuZGVkRm9yd2FyZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICBkZXNjZW5kZWRGb3J3YXJkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY2VuZGVkRm9yd2FyZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShub2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZDtcblxuICAgIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCk7XG5cbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZTsgIC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdFRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXROb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXRUZXJtaW5hbE5vZGUodGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgZGVzY2VuZEZvcndhcmQgPSByZW1haW5pbmdBcmd1bWVudHMucG9wKCksIC8vL1xuICAgICAgICAgIGRlc2NlbmRlZEZvcndhcmQgPSBkZXNjZW5kRm9yd2FyZCgpO1xuXG4gICAgaWYgKGRlc2NlbmRlZEZvcndhcmQpIHtcbiAgICAgIHZpc2l0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlbWFpbmluZ0FyZ3VtZW50cy5wdXNoKGRlc2NlbmRGb3J3YXJkKTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgbGV0IHsgbWFwcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgIG1hcHMgPSBbIC8vL1xuICAgICAgLi4ubWFwcyxcbiAgICAgIHtcbiAgICAgICAgbm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgcnVuOiAobm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSA9PiB7XG4gICAgICAgICAgbGV0IHZpc2l0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gbm9uVGVybWluYWxOb2RlLmdldENoaWxkTm9kZXMoKSwgLy8vXG4gICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGluZGV4LCBjaGlsZE5vZGVzLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKGRlc2NlbmRlZCkge1xuICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBtYXBzLnNvbWUoKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBub2RlUXVlcnksIHJ1biB9ID0gbWFwO1xuXG4gICAgICBjb25zdCBub2RlID0gbm9kZVF1ZXJ5KG5vblRlcm1pbmFsTm9kZSk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBydW4obm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzcztcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LCB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMsIGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbCB9IGZyb20gXCIuLi91dGlsaXRpZXMvcGFzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcXVpdmFsZW5jZVBhc3Mge1xuICBydW4obGVmdE5vZGUsIHJpZ2h0Tm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG5cbiAgICBjb25zdCB2aXNpdGVkID0gdGhpcy52aXNpdE5vZGUobGVmdE5vZGUsIHJpZ2h0Tm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgIHN1Y2Nlc3MgPSB2aXNpdGVkOyAgLy8vXG5cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuXG4gIGRlc2NlbmQobGVmdENoaWxkTm9kZXMsIHJpZ2h0Q2hpbGROb2RlcywgLi4ucmVtYWluaW5nQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlc2NlbmRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgbGVmdENoaWxkTm9kZXNMZW5ndGggPSBsZWZ0Q2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICByaWdodENoaWxkTm9kZXNMZW5ndGggPSByaWdodENoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlZnRDaGlsZE5vZGVzTGVuZ3RoID09PSByaWdodENoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxlZnRUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMobGVmdENoaWxkTm9kZXMpLFxuICAgICAgICAgICAgcmlnaHRUZXJtaW5hbE5vZGVNYXAgPSB0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMocmlnaHRDaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIHRlcm1pbmFsTm9kZU1hcHNFcXVhbCA9IGFyZVRlcm1pbmFsTm9kZU1hcHNFcXVhbChsZWZ0VGVybWluYWxOb2RlTWFwLCByaWdodFRlcm1pbmFsTm9kZU1hcCk7XG5cbiAgICAgIGlmICh0ZXJtaW5hbE5vZGVNYXBzRXF1YWwpIHtcbiAgICAgICAgZGVzY2VuZGVkID0gbGVmdENoaWxkTm9kZXMuZXZlcnkoKGxlZnRDaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmlnaHRDaGlsZE5vZGUgPSByaWdodENoaWxkTm9kZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxlZnROb2RlID0gbGVmdENoaWxkTm9kZSwgLy8vXG4gICAgICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHRDaGlsZE5vZGUsIC8vL1xuICAgICAgICAgICAgICAgIHZpc2l0ZWQgPSB0aGlzLnZpc2l0Tm9kZShsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpO1xuXG4gICAgICAgICAgaWYgKHZpc2l0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NlbmRlZDtcbiAgfVxuXG4gIHZpc2l0Tm9kZShsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHtcbiAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgbGVmdE5vZGVUZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIHJpZ2h0Tm9kZVRlcm1pbmFsTm9kZSA9IHJpZ2h0Tm9kZS5pc1Rlcm1pbmFsTm9kZSgpLFxuICAgICAgICAgIGxlZnROb2RlTm9uVGVybWluYWxOb2RlID0gbGVmdE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKSxcbiAgICAgICAgICByaWdodE5vZGVOb25UZXJtaW5hbE5vZGUgPSByaWdodE5vZGUuaXNOb25UZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8vXG4gICAgfSBlbHNlIGlmIChsZWZ0Tm9kZVRlcm1pbmFsTm9kZSAmJiByaWdodE5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGxlZnRUZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZSwgIC8vL1xuICAgICAgICAgICAgcmlnaHRUZXJtaW5hbE5vZGUgPSByaWdodE5vZGU7ICAvLy9cblxuICAgICAgdmlzaXRlZCA9IHRoaXMudmlzaXRUZXJtaW5hbE5vZGUobGVmdFRlcm1pbmFsTm9kZSwgcmlnaHRUZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChsZWZ0Tm9kZU5vblRlcm1pbmFsTm9kZSAmJiByaWdodE5vZGVOb25UZXJtaW5hbE5vZGUpIHtcbiAgICAgIGNvbnN0IGxlZnROb25UZXJtaW5hbE5vZGUgPSBsZWZ0Tm9kZSwgIC8vL1xuICAgICAgICAgICAgcmlnaHROb25UZXJtaW5hbE5vZGUgPSByaWdodE5vZGU7IC8vL1xuXG4gICAgICB2aXNpdGVkID0gdGhpcy52aXNpdE5vblRlcm1pbmFsTm9kZShsZWZ0Tm9uVGVybWluYWxOb2RlLCByaWdodE5vblRlcm1pbmFsTm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlzaXRlZDtcbiAgfVxuXG4gIHZpc2l0VGVybWluYWxOb2RlKGxlZnRUZXJtaW5hbE5vZGUsIHJpZ2h0VGVybWluYWxOb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpIHsgLy8vXG4gICAgbGV0IHZpc2l0ZWQ7XG5cbiAgICB2aXNpdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB2aXNpdGVkO1xuICB9XG5cbiAgdmlzaXROb25UZXJtaW5hbE5vZGUobGVmdE5vblRlcm1pbmFsTm9kZSwgcmlnaHROb25UZXJtaW5hbE5vZGUsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cykge1xuICAgIGxldCB2aXNpdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgeyBtYXBzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgbWFwcyA9IFsgLy8vXG4gICAgICAuLi5tYXBzLFxuICAgICAge1xuICAgICAgICBsZWZ0Tm9kZVF1ZXJ5OiBub25UZXJtaW5hbE5vZGVRdWVyeSxcbiAgICAgICAgcmlnaHROb2RlUXVlcnk6IG5vblRlcm1pbmFsTm9kZVF1ZXJ5LFxuICAgICAgICBydW46IChsZWZ0Tm9kZSwgcmlnaHROb2RlLCAuLi5yZW1haW5pbmdBcmd1bWVudHMpID0+IHtcbiAgICAgICAgICBsZXQgdmlzaXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgbGVmdE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gbGVmdE5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLCAvLy9cbiAgICAgICAgICAgICAgICByaWdodE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID0gcmlnaHROb25UZXJtaW5hbE5vZGUuZ2V0UnVsZU5hbWUoKTsgLy8vXG5cbiAgICAgICAgICBpZiAobGVmdE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lID09PSByaWdodE5vblRlcm1pbmFsTm9kZVJ1bGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0Tm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcyA9IGxlZnROb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgcmlnaHROb25UZXJtaW5hbE5vZGVDaGlsZE5vZGVzID0gcmlnaHROb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICAgICAgbGVmdENoaWxkTm9kZXMgPSBsZWZ0Tm9uVGVybWluYWxOb2RlQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgICAgICByaWdodENoaWxkTm9kZXMgPSByaWdodE5vblRlcm1pbmFsTm9kZUNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgICAgICAgICAgZGVzY2VuZGVkID0gdGhpcy5kZXNjZW5kKGxlZnRDaGlsZE5vZGVzLCByaWdodENoaWxkTm9kZXMsIC4uLnJlbWFpbmluZ0FyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChkZXNjZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBtYXBzLnNvbWUoKG1hcCkgPT4ge1xuICAgICAgY29uc3QgeyBsZWZ0Tm9kZVF1ZXJ5LCByaWdodE5vZGVRdWVyeSwgcnVuIH0gPSBtYXA7XG5cbiAgICAgIGNvbnN0IGxlZnROb2RlID0gbGVmdE5vZGVRdWVyeShsZWZ0Tm9uVGVybWluYWxOb2RlKSwgIC8vL1xuICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHROb2RlUXVlcnkocmlnaHROb25UZXJtaW5hbE5vZGUpOyAgLy8vXG5cbiAgICAgIGlmICgobGVmdE5vZGUgIT09IG51bGwpICYmIChyaWdodE5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBydW4obGVmdE5vZGUsIHJpZ2h0Tm9kZSwgLi4ucmVtYWluaW5nQXJndW1lbnRzKTtcblxuICAgICAgICB2aXNpdGVkID0gc3VjY2VzczsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZpc2l0ZWQ7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXN5bmNFdmVyeSAgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNFdmVyeURlcGVuZGVuY3koZGVwZW5kZW5jaWVzLCBjYWxsYmFjaykge1xuICBjb25zdCBhcnJheSA9IGRlcGVuZGVuY2llcy5nZXRBcnJheSgpO1xuXG4gIHJldHVybiBhd2FpdCBhc3luY0V2ZXJ5KGFycmF5LCBjYWxsYmFjayk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgeyBhc3luY0V2ZXJ5RGVwZW5kZW5jeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvZGVwZW5kZW5jeVwiO1xuXG5jb25zdCB7IGxhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGlzZVJlbGVhc2VDb250ZXh0KGRlcGVuZGVuY3ksIGNvbnRleHQpIHtcbiAgY29uc3QgeyByZWxlYXNlQ29udGV4dE1hcCB9ID0gY29udGV4dCxcbiAgICAgICAgZGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgcmVsZWFzZU5hbWUgPSBkZXBlbmRlbmN5TmFtZSwgLy8vXG4gICAgICAgIHJlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHRNYXBbcmVsZWFzZU5hbWVdIHx8IG51bGw7XG5cbiAgaWYgKHJlbGVhc2VDb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29uc3QgeyBsb2cgfSA9IGNvbnRleHQ7XG5cbiAgICBsb2cud2FybmluZyhgVW5hYmxlIHRvIGluaXRpYWxpc2UgdGhlICcke2RlcGVuZGVuY3lOYW1lfScgY29udGV4dCBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiBjcmVhdGVkLmApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0SW5pdGlhbGlzZWQgPSByZWxlYXNlQ29udGV4dC5pc0luaXRpYWxpc2VkKCk7XG5cbiAgICBpZiAoIXJlbGVhc2VDb250ZXh0SW5pdGlhbGlzZWQpIHtcbiAgICAgIGluaXRpYWxpc2VEZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzKGRlcGVuZGVuY3ksIHJlbGVhc2VDb250ZXh0LCBjb250ZXh0KTtcblxuICAgICAgY29uc3QgeyBsb2cgfSA9IGNvbnRleHQsXG4gICAgICAgICAgICByZWxlYXNlQ29udGV4dHMgPSByZXRyaWV2ZVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dCwgcmVsZWFzZUNvbnRleHRNYXApO1xuXG4gICAgICBsb2cuaW5mbyhgSW5pdGlhbGlzaW5nIHRoZSAnJHtkZXBlbmRlbmN5TmFtZX0nIGNvbnRleHQuLi5gKTtcblxuICAgICAgY29uc3QgeyBGaWxlQ29udGV4dEZyb21GaWxlUGF0aCB9ID0gY29udGV4dDtcblxuICAgICAgcmVsZWFzZUNvbnRleHQuaW5pdGlhbGlzZShyZWxlYXNlQ29udGV4dHMsIEZpbGVDb250ZXh0RnJvbUZpbGVQYXRoKTtcblxuICAgICAgbG9nLmRlYnVnKGAuLi5pbml0aWFsaXNlZCB0aGUgJyR7ZGVwZW5kZW5jeU5hbWV9JyBjb250ZXh0LmApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmVsZWFzZUNvbnRleHQoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpIHtcbiAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICBjb25zdCB7IHJlbGVhc2VDb250ZXh0TWFwIH0gPSBjb250ZXh0LFxuICAgICAgICBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICByZWxlYXNlTmFtZSA9IGRlcGVuZGVuY3lOYW1lLCAvLy9cbiAgICAgICAgcmVsZWFzZUNvbnRleHQgPSByZWxlYXNlQ29udGV4dE1hcFtyZWxlYXNlTmFtZV0gfHwgbnVsbDtcblxuICBpZiAocmVsZWFzZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICBjb25zdCB7IGxvZyB9ID0gY29udGV4dCxcbiAgICAgICAgICByZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kgPSBjaGVja1JlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeShyZWxlYXNlQ29udGV4dCwgZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5gKTtcblxuICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgbG9nIH0gPSBjb250ZXh0LFxuICAgICAgICAgIGRlcGVuZGVuY3lTdHJpbmcgPSBkZXBlbmRlbmN5LmFzU3RyaW5nKCksXG4gICAgICAgICAgZGVwZW5kZW50TmFtZXNMZW5ndGggPSBkZXBlbmRlbnROYW1lcy5sZW5ndGg7XG5cbiAgICBpZiAoZGVwZW5kZW50TmFtZXNMZW5ndGggPT09IDApIHtcbiAgICAgIGxvZy5pbmZvKGBDcmVhdGluZyB0aGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0Li4uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3REZXBlbmRlbnROYW1lID0gbGFzdChkZXBlbmRlbnROYW1lcyksXG4gICAgICAgICAgICBkZXBlbmRlbnROYW1lID0gbGFzdERlcGVuZGVudE5hbWU7ICAvLy9cblxuICAgICAgbG9nLmluZm8oYENyZWF0aW5nIHRoZSAnJHtyZWxlYXNlTmFtZX0nIGNvbnRleHQgZ2l2ZW4gdGhlICcke2RlcGVuZGVudE5hbWV9JyBkZXBlbmRhbnQncyAnJHtkZXBlbmRlbmN5U3RyaW5nfScgZGVwZW5kZW5jeS4uLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVsZWFzZUNvbnRleHRGcm9tRGVwZW5kZW5jeSB9ID0gY29udGV4dCxcbiAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IGF3YWl0IHJlbGVhc2VDb250ZXh0RnJvbURlcGVuZGVuY3koZGVwZW5kZW5jeSwgY29udGV4dCksXG4gICAgICAgICAgcmVsZWFzZUNvbnRleHRDcmVhdGVkID0gY2hlY2tSZWxlYXNlQ29udGV4dENyZWF0ZWQocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVuY3ksIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlbGVhc2VDb250ZXh0Q3JlYXRlZCkge1xuICAgICAgY29uc3QgcmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5ID0gY2hlY2tSZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVuY3ksIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KTtcblxuICAgICAgaWYgKHJlbGVhc2VNYXRjaGVzRGVwZW5kZW5jeSkge1xuICAgICAgICByZWxlYXNlQ29udGV4dE1hcFtyZWxlYXNlTmFtZV0gPSByZWxlYXNlQ29udGV4dDtcblxuICAgICAgICBzdWNjZXNzID0gYXdhaXQgY3JlYXRlRGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhkZXBlbmRlbmN5LCByZWxlYXNlQ29udGV4dCwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1Y2Nlc3MgP1xuICAgICAgbG9nLmRlYnVnKGAuLi5jcmVhdGVkIHRoZSAnJHtyZWxlYXNlTmFtZX0nIGNvbnRleHQuYCkgOlxuICAgICAgICBsb2cud2FybmluZyhgLi4udW5hYmxlIHRvIGNyZWF0ZSB0aGUgJyR7cmVsZWFzZU5hbWV9JyBjb250ZXh0LmApO1xuICB9XG5cbiAgcmV0dXJuIHN1Y2Nlc3M7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlSZWxlYXNlQ29udGV4dChyZWxlYXNlTmFtZSwgZGVwZW5kZW50TmFtZSwgZGVwZW5kZW50UmVsZWFzZWQsIHJlbGVhc2VDb250ZXh0TWFwKSB7XG4gIGxldCByZWxlYXNlVmVyaWZpZXMgPSBmYWxzZTtcblxuICBjb25zdCByZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0TWFwW3JlbGVhc2VOYW1lXTtcblxuICBpZiAocmVsZWFzZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICBjb25zdCByZWxlYXNlZCA9IHJlbGVhc2VDb250ZXh0LmlzUmVsZWFzZWQoKTtcblxuICAgIGlmIChyZWxlYXNlZCkge1xuICAgICAgcmVsZWFzZVZlcmlmaWVzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlcGVuZGVudFJlbGVhc2VkKSB7XG4gICAgICAgIHJlbGVhc2VDb250ZXh0Lndhcm5pbmcoYFRoZSAnJHtyZWxlYXNlTmFtZX0nIHByb2plY3QgY2Fubm90IGJlIHZlcmlmaWVzIGJlY2F1c2UgaXRzICcke2RlcGVuZGVudE5hbWV9JyBkZXBlbmRlbnQgaXMgYSBwYWNrYWdlLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW50TmFtZSA9IHJlbGVhc2VOYW1lLCAgLy8vXG4gICAgICAgICAgICAgIGRlcGVuZGVudFJlbGVhc2VkID0gcmVsZWFzZWQsIC8vL1xuICAgICAgICAgICAgICBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzVmVyaWZ5ID0gYXdhaXQgdmVyaWZ5RGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dCwgZGVwZW5kZW50TmFtZSwgZGVwZW5kZW50UmVsZWFzZWQsIHJlbGVhc2VDb250ZXh0TWFwKTtcblxuICAgICAgICBpZiAoZGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0c1ZlcmlmeSkge1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0VmVyaWZpZWQgPSByZWxlYXNlQ29udGV4dC5oYXNWZXJpZmllZCgpO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VDb250ZXh0VmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJlbGVhc2VWZXJpZmllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0LmluZm8oYFZlcmlmeWluZyB0aGUgJyR7cmVsZWFzZU5hbWV9JyBwcm9qZWN0Li4uYCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VDb250ZXh0VmVyaWZpZXMgPSBhd2FpdCByZWxlYXNlQ29udGV4dC52ZXJpZnkoKTtcblxuICAgICAgICAgICAgaWYgKHJlbGVhc2VDb250ZXh0VmVyaWZpZXMpIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUNvbnRleHQuaW5mbyhgLi4udmVyaWZpZWQgdGhlICcke3JlbGVhc2VOYW1lfScgcHJvamVjdC5gKTtcblxuICAgICAgICAgICAgICByZWxlYXNlVmVyaWZpZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWxlYXNlVmVyaWZpZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY3JlYXRlUmVsZWFzZUNvbnRleHQsXG4gIHZlcmlmeVJlbGVhc2VDb250ZXh0LFxuICBpbml0aWFsaXNlUmVsZWFzZUNvbnRleHRcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURlcGVuZGVuY3lSZWxlYXNlQ29udGV4dHMoZGVwZW5kZW5jeSwgcmVsZWFzZUNvbnRleHQsIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KSB7XG4gIGxldCBzdWNjZXNzO1xuXG4gIGNvbnN0IGRlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IHJlbGVhc2VDb250ZXh0LmdldERlcGVuZGVuY2llcygpO1xuXG4gIGRlcGVuZGVudE5hbWVzID0gWyAuLi5kZXBlbmRlbnROYW1lcywgZGVwZW5kZW5jeU5hbWUgXTsgIC8vL1xuXG4gIHN1Y2Nlc3MgPSBhd2FpdCBhc3luY0V2ZXJ5RGVwZW5kZW5jeShkZXBlbmRlbmNpZXMsIGFzeW5jIChkZXBlbmRlbmN5KSA9PiB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIGNvbnN0IGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHMgPSBjaGVja0N5Y2xpY0RlcGVuZGVuY3lFeGlzdHMoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjeWNsaWNEZXBlbmRlbmN5RXhpc3RzKSB7XG4gICAgICBzdWNjZXNzID0gYXdhaXQgY3JlYXRlUmVsZWFzZUNvbnRleHQoZGVwZW5kZW5jeSwgZGVwZW5kZW50TmFtZXMsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9KTtcblxuICByZXR1cm4gc3VjY2Vzcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5RGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dCwgZGVwZW5kZW50TmFtZSwgZGVwZW5kZW50UmVsZWFzZWQsIHJlbGVhc2VDb250ZXh0TWFwKSB7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJlbGVhc2VDb250ZXh0LmdldERlcGVuZGVuY2llcygpLFxuICAgICAgICBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzVmVyaWZ5ID0gYXdhaXQgYXN5bmNFdmVyeURlcGVuZGVuY3koZGVwZW5kZW5jaWVzLCBhc3luYyAoZGVwZW5kZW5jeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXBlbmRlbmN5LmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICByZWxlYXNlTmFtZSA9IG5hbWUsIC8vL1xuICAgICAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0VmVyaWZpZXMgPSBhd2FpdCB2ZXJpZnlSZWxlYXNlQ29udGV4dChyZWxlYXNlTmFtZSwgZGVwZW5kZW50TmFtZSwgZGVwZW5kZW50UmVsZWFzZWQsIHJlbGVhc2VDb250ZXh0TWFwKTtcblxuICAgICAgICAgIGlmIChyZWxlYXNlQ29udGV4dFZlcmlmaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBkZXBlbmRlbmN5UmVsZWFzZUNvbnRleHRzVmVyaWZ5O1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZVJlbGVhc2VDb250ZXh0cyhyZWxlYXNlQ29udGV4dCwgcmVsZWFzZUNvbnRleHRNYXApIHtcbiAgY29uc3QgcmVsZWFzZUNvbnRleHRzID0gW10sXG4gICAgICAgIHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0ID0gcmVsZWFzZUNvbnRleHQsICAvLy9cbiAgICAgICAgcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzID0gW1xuICAgICAgICAgIHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0XG4gICAgICAgIF07XG5cbiAgbGV0IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0c0xlbmd0aCA9IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0c0xlbmd0aCA+IDApIHtcbiAgICBjb25zdCByZW1haW5pbmdSZWxlYXNlQ29udGV4dCA9IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0cy5zaGlmdCgpLFxuICAgICAgICAgIHJlbGVhc2VDb250ZXh0ID0gcmVtYWluaW5nUmVsZWFzZUNvbnRleHQ7ICAvLy9cblxuICAgIHJlbGVhc2VDb250ZXh0cy5wdXNoKHJlbGVhc2VDb250ZXh0KTtcblxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJlbGVhc2VDb250ZXh0LmdldERlcGVuZGVuY2llcygpO1xuXG4gICAgZGVwZW5kZW5jaWVzLmZvckVhY2hEZXBlbmRlbmN5KChkZXBlbmRlbmN5KSA9PiB7XG4gICAgICBjb25zdCBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgcmVsZWFzZU5hbWUgPSBkZXBlbmRlbmN5TmFtZSwgLy8vXG4gICAgICAgICAgICByZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0TWFwW3JlbGVhc2VOYW1lXSxcbiAgICAgICAgICAgIHJlbGVhc2VDb250ZXh0c0luY2x1ZGVzUmVsZWFzZUNvbnRleHQgPSByZWxlYXNlQ29udGV4dHMuaW5jbHVkZXMocmVsZWFzZUNvbnRleHQpLFxuICAgICAgICAgICAgcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzSW5jbHVkZXNSZWxlYXNlQ29udGV4dCA9IHJlbWFpbmluZ1JlbGVhc2VDb250ZXh0cy5pbmNsdWRlcyhyZWxlYXNlQ29udGV4dCk7XG5cbiAgICAgIGlmICghcmVsZWFzZUNvbnRleHRzSW5jbHVkZXNSZWxlYXNlQ29udGV4dCAmJiAhcmVtYWluaW5nUmVsZWFzZUNvbnRleHRzSW5jbHVkZXNSZWxlYXNlQ29udGV4dCkge1xuICAgICAgICBjb25zdCByZW1haW5pbmdSZWxlYXNlQ29udGV4dCA9IHJlbGVhc2VDb250ZXh0OyAvLy9cblxuICAgICAgICByZW1haW5pbmdSZWxlYXNlQ29udGV4dHMucHVzaChyZW1haW5pbmdSZWxlYXNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZW1haW5pbmdSZWxlYXNlQ29udGV4dHNMZW5ndGggPSByZW1haW5pbmdSZWxlYXNlQ29udGV4dHMubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VDb250ZXh0cztcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWxlYXNlQ29udGV4dENyZWF0ZWQocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVuY3ksIGNvbnRleHQpIHtcbiAgY29uc3QgcmVsZWFzZUNvbnRleHRDcmVhdGVkID0gKHJlbGVhc2VDb250ZXh0ICE9PSBudWxsKTtcblxuICBpZiAoIXJlbGVhc2VDb250ZXh0Q3JlYXRlZCkge1xuICAgIGNvbnN0IHsgbG9nIH0gPSBjb250ZXh0LFxuICAgICAgICAgIGRlcGVuZGVuY3lOYW1lID0gZGVwZW5kZW5jeS5nZXROYW1lKCksXG4gICAgICAgICAgcmVsZWFzZU5hbWUgPSBkZXBlbmRlbmN5TmFtZTsgLy8vXG5cbiAgICBsb2cud2FybmluZyhgVGhlICcke3JlbGVhc2VOYW1lfScgY29udGV4dCBjb3VsZCBub3QgYmUgY3JlYXRlZC4gUGVyaGFwcyB0aGUgJ21ldGEuanNvbicgZmlsZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuIE9yIHRoZXJlIGNvdWxkIGJlIGEgZGVwZW5kZW5jeSBtaXNtYXRjaC5gKTtcbiAgfVxuXG4gIHJldHVybiByZWxlYXNlQ29udGV4dENyZWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ3ljbGljRGVwZW5kZW5jeUV4aXN0cyhkZXBlbmRlbmN5LCBkZXBlbmRlbnROYW1lcywgY29udGV4dCkge1xuICBjb25zdCBkZXBlbmRlbmN5TmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICBkZXBlbmRlbnROYW1lc0luY2x1ZGVzRGVwZW5kZW5jeU5hbWUgPSBkZXBlbmRlbnROYW1lcy5pbmNsdWRlcyhkZXBlbmRlbmN5TmFtZSksXG4gICAgICAgIGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHMgPSBkZXBlbmRlbnROYW1lc0luY2x1ZGVzRGVwZW5kZW5jeU5hbWU7ICAvLy9cblxuICBpZiAoY3ljbGljRGVwZW5kZW5jeUV4aXN0cykge1xuICAgIGNvbnN0IHsgbG9nIH0gPSBjb250ZXh0LFxuICAgICAgICAgIGZpcnN0RGVwZW5kZW50TmFtZSA9IGZpcnN0KGRlcGVuZGVudE5hbWVzKSxcbiAgICAgICAgICBkZXBlbmRlbmN5TmFtZXMgPSBbICAvLy9cbiAgICAgICAgICAgIC4uLmRlcGVuZGVudE5hbWVzLFxuICAgICAgICAgICAgZmlyc3REZXBlbmRlbnROYW1lXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkZXBlbmRlbmN5TmFtZXNTdHJpbmcgPSBkZXBlbmRlbmN5TmFtZXMuam9pbihgJyAtPiAnYCk7XG5cbiAgICBsb2cud2FybmluZyhgVGhlcmUgaXMgYSBjeWNsaWMgZGVwZW5kZW5jeSwgJyR7ZGVwZW5kZW5jeU5hbWVzU3RyaW5nfScuYCk7XG4gIH1cblxuICByZXR1cm4gY3ljbGljRGVwZW5kZW5jeUV4aXN0cztcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kocmVsZWFzZUNvbnRleHQsIGRlcGVuZGVuY3ksIGRlcGVuZGVudE5hbWVzLCBjb250ZXh0KSB7XG4gIGxldCByZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kgPSB0cnVlO1xuXG4gIGNvbnN0IHNob3J0ZW5lZFZlcnNpb24gPSBkZXBlbmRlbmN5LmdldFNob3J0ZWRWZXJzaW9uKCk7XG5cbiAgaWYgKHNob3J0ZW5lZFZlcnNpb24gIT09IG51bGwpIHtcbiAgICBjb25zdCBlbnRyaWVzTWF0Y2hTaG9ydGVuZWRWZXJzaW9uID0gcmVsZWFzZUNvbnRleHQubWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgaWYgKCFlbnRyaWVzTWF0Y2hTaG9ydGVuZWRWZXJzaW9uKSB7XG4gICAgICBjb25zdCB7IGxvZyB9ID0gY29udGV4dCxcbiAgICAgICAgICAgIHZlcnNpb24gPSByZWxlYXNlQ29udGV4dC5nZXRWZXJzaW9uKCksXG4gICAgICAgICAgICBsYXN0RGVwZW5kZW50TmFtZSA9IGxhc3QoZGVwZW5kZW50TmFtZXMpLFxuICAgICAgICAgICAgZGVwZW5kZW50TmFtZSA9IGxhc3REZXBlbmRlbnROYW1lLCAgLy8vXG4gICAgICAgICAgICB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgZGVwZW5kZW5jeVN0cmluZyA9IGRlcGVuZGVuY3kuYXNTdHJpbmcoKTtcblxuICAgICAgbG9nLndhcm5pbmcoYFRoZSAnJHtkZXBlbmRlbnROYW1lfScgZGVwZW5kZW50IHJlcXVpcmVzIHRoZSAnJHtkZXBlbmRlbmN5U3RyaW5nfScgZGVwZW5kZW5jeSBidXQgYSBjb250ZXh0IHdpdGggdmVyc2lvbiAnJHt2ZXJzaW9uU3RyaW5nfScgd2FzIHByb3ZpZGVkLmApO1xuXG4gICAgICByZWxlYXNlTWF0Y2hlc0RlcGVuZGVuY3kgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZU1hdGNoZXNEZXBlbmRlbmN5O1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXNlRGVwZW5kZW5jeVJlbGVhc2VDb250ZXh0cyhkZXBlbmRlbmN5LCByZWxlYXNlQ29udGV4dCwgY29udGV4dCkge1xuICBjb25zdCBkZXBlbmRlbmNpZXMgPSByZWxlYXNlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoKTtcblxuICBkZXBlbmRlbmNpZXMuZm9yRWFjaERlcGVuZGVuY3koKGRlcGVuZGVuY3kpID0+IHsgIC8vL1xuICAgIGluaXRpYWxpc2VSZWxlYXNlQ29udGV4dChkZXBlbmRlbmN5LCBjb250ZXh0KTtcbiAgfSk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBGSUxFX1RZUEUgPSBcIkZpbGVcIjtcbmV4cG9ydCBjb25zdCBESVJFQ1RPUllfVFlQRSA9IFwiRGlyZWN0b3J5XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IERPVUJMRV9TUEFDRSA9IFwiICBcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0FNUEVSU0FORCA9IFwiJmFtcDtcIjtcbmV4cG9ydCBjb25zdCBFU0NBUEVEX0xFU1NfVEhBTiA9IFwiJmx0O1wiO1xuZXhwb3J0IGNvbnN0IEVTQ0FQRURfR1JFQVRFUl9USEFOID0gXCImZ3Q7XCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IERPVUJMRV9TUEFDRSwgRU1QVFlfU1RSSU5HLCBFU0NBUEVEX0FNUEVSU0FORCwgRVNDQVBFRF9MRVNTX1RIQU4sIEVTQ0FQRURfR1JFQVRFUl9USEFOIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3Qgc2FuaXRpc2VkQ29udGVudCA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgRVNDQVBFRF9BTVBFUlNBTkQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIEVTQ0FQRURfTEVTU19USEFOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBFU0NBUEVEX0dSRUFURVJfVEhBTik7XG5cbiAgcmV0dXJuIHNhbml0aXNlZENvbnRlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmltRG91YmxlUXVvdGVzKGNvbnRlbnQpIHsgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvKF5cInxcIiQpL2csIEVNUFRZX1NUUklORyk7IH0gLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UoY29udGVudCkgeyByZXR1cm4gY29udGVudC5yZXBsYWNlKC9cXHQvZywgRE9VQkxFX1NQQUNFKTsgfSAvLy9cblxuZXhwb3J0IGRlZmF1bHQge1xuICBzYW5pdGlzZUNvbnRlbnQsXG4gIHRyaW1Eb3VibGVRdW90ZXMsXG4gIGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRklMRV9UWVBFIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZSB9IGZyb20gXCIuL3V0aWxpdGllcy9jb250ZW50XCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMucmVsZWFzZWQgPSByZWxlYXNlZDtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGdldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuXG4gIGlzUmVsZWFzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZWQ7XG4gIH1cblxuICBpc0ZpbGUoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRydWU7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIGlzRGlyZWN0b3J5KCkge1xuICAgIGNvbnN0IGRpcmVjdG9yeSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgfVxuXG4gIHNldFBhdGgocGF0aCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cblxuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgc2V0UmVsZWFzZWQocmVsZWFzZWQpIHtcbiAgICB0aGlzLnJlbGVhc2VkID0gcmVsZWFzZWQ7XG4gIH1cblxuICBtYXRjaEZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgZmlsZVBhdGhNYXRjaGVzID0gKHRoaXMucGF0aCA9PT0gZmlsZVBhdGgpO1xuXG4gICAgcmV0dXJuIGZpbGVQYXRoTWF0Y2hlcztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IEZpbGUsXG4gICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICAgIHJlbGVhc2VkID0gdGhpcy5yZWxlYXNlZCxcbiAgICAgICAgICBqc29uID0ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgcmVsZWFzZWRcbiAgICAgICAgICB9O1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgdHlwZSA9IEZJTEVfVFlQRTtcblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGxldCBmaWxlID0gbnVsbDtcblxuICAgIGlmIChqc29uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7IHR5cGUgfSA9IGpzb247XG5cbiAgICAgIGlmICh0eXBlID09PSBGSUxFX1RZUEUpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCB9ID0ganNvbjtcblxuICAgICAgICBjb25zdCB7IHBhdGgsIHJlbGVhc2VkIH0gPSBqc29uO1xuXG4gICAgICAgIGNvbnRlbnQgPSBjb252ZXJ0Q29udGVudFRhYnNUb1doaXRlc3BhY2UoY29udGVudCk7ICAvLy9cblxuICAgICAgICBmaWxlID0gbmV3IEZpbGUocGF0aCwgY29udGVudCwgcmVsZWFzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZG9jdW1lbnQuZ2V0RmlsZVBhdGgoKSxcbiAgICAgICAgICByZWxlYXNlZCA9IGRvY3VtZW50LmlzUmVsZWFzZWQoKSxcbiAgICAgICAgICBwYXRoID0gZmlsZVBhdGg7ICAvLy9cblxuICAgIGxldCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0Q29udGVudCgpO1xuXG4gICAgY29udGVudCA9IGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZShjb250ZW50KTsgIC8vL1xuXG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKTtcblxuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21QYXRoQ29udGVudEFuZFJlbGVhc2VkKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKSB7XG4gICAgY29udGVudCA9IGNvbnZlcnRDb250ZW50VGFic1RvV2hpdGVzcGFjZShjb250ZW50KTsgIC8vL1xuXG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKHBhdGgsIGNvbnRlbnQsIHJlbGVhc2VkKTtcblxuICAgIHJldHVybiBmaWxlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBGaWxlIGZyb20gXCIuL2ZpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZXMge1xuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5O1xuICB9XG5cbiAgZ2V0RmlsZVBhdGhzKCkge1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IHRoaXMubWFwRmlsZSgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKTtcblxuICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbGVQYXRocztcbiAgfVxuXG4gIGFkZEZpbGUoZmlsZSkgeyB0aGlzLmFycmF5LnB1c2goZmlsZSk7IH1cblxuICBtYXBGaWxlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICBzb21lRmlsZShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5zb21lKGNhbGxiYWNrKTsgfVxuXG4gIHJlZHVjZUZpbGUoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkgeyByZXR1cm4gdGhpcy5hcnJheS5yZWR1Y2UoY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSk7IH1cblxuICBmb3JFYWNoRmlsZShjYWxsYmFjaykgeyB0aGlzLmFycmF5LmZvckVhY2goY2FsbGJhY2spOyB9XG5cbiAgZmluZEZpbGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuZmluZChjYWxsYmFjaykgfHwgbnVsbDsgfSAgLy8vXG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGZpbGVzSlNPTiA9IHRoaXMuYXJyYXkubWFwKChmaWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlSlNPTiA9IChmaWxlICE9PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUudG9KU09OKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGZpbGVKU09OO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGpzb24gPSBmaWxlc0pTT047IC8vL1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGZpbGVzSlNPTiA9IGpzb24sIC8vL1xuICAgICAgICAgIGFycmF5ID0gW10sXG4gICAgICAgICAgZmlsZXMgPSBuZXcgRmlsZXMoYXJyYXkpO1xuICAgIFxuICAgIGZpbGVzSlNPTi5mb3JFYWNoKChmaWxlSlNPTikgPT4ge1xuICAgICAgY29uc3QganNvbiA9IGZpbGVKU09OLCAgLy8vXG4gICAgICAgICAgICBmaWxlID0gRmlsZS5mcm9tSlNPTihqc29uKTtcblxuICAgICAgZmlsZXMuYWRkRmlsZShmaWxlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXSxcbiAgICAgICAgICBmaWxlcyA9IG5ldyBGaWxlcyhhcnJheSk7XG5cbiAgICByZXR1cm4gZmlsZXM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSID0gMWUxMjtcbmV4cG9ydCBjb25zdCBNSU5PUl9OVU1CRVJfTVVMVElQTElFUiA9IDFlNjtcbmV4cG9ydCBjb25zdCBQQVRDSF9OVU1CRVJfTVVMVElQTElFUiA9IDFlMDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSLCBNSU5PUl9OVU1CRVJfTVVMVElQTElFUiwgUEFUQ0hfTlVNQkVSX01VTFRJUExJRVIgfSBmcm9tIFwiLi4vbXVsdGlwbGVyc1wiO1xuXG5jb25zdCB7IHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWpvck51bWJlckZyb21OdW1iZXIobnVtYmVyKSB7XG4gIGNvbnN0IG1ham9yTnVtYmVyID0gKG51bWJlciAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihudW1iZXIgLyBNQUpPUl9OVU1CRVJfTVVMVElQTElFUikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAwOyAgLy8vXG5cbiAgcmV0dXJuIG1ham9yTnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlub3JOdW1iZXJGcm9tTnVtYmVyKG51bWJlcikge1xuICBjb25zdCBtaW5vck51bWJlciA9IChudW1iZXIgIT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG51bWJlciAlIE1BSk9SX05VTUJFUl9NVUxUSVBMSUVSKSAvIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDA7ICAvLy9cblxuICByZXR1cm4gbWlub3JOdW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaE51bWJlckZyb21OdW1iZXIobnVtYmVyKSB7XG4gIGNvbnN0IHBhdGNoTnVtYmVyID0gKG51bWJlciAhPT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcigobnVtYmVyICUgTUlOT1JfTlVNQkVSX01VTFRJUExJRVIpIC8gUEFUQ0hfTlVNQkVSX01VTFRJUExJRVIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMDsgIC8vL1xuXG4gIHJldHVybiBwYXRjaE51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ham9yTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgbGV0IG1ham9yTnVtYmVyID0gMDtcblxuICBpZiAoc3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHN0cmluZy5tYXRjaCgvXihcXGQrKS8pLFxuICAgICAgICAgIHNlY29uZE1hdGNoID0gc2Vjb25kKG1hdGNoZXMpO1xuXG4gICAgbWFqb3JOdW1iZXIgPSBOdW1iZXIoc2Vjb25kTWF0Y2gpOyAgLy8vXG4gIH1cblxuICByZXR1cm4gbWFqb3JOdW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5vck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSB7XG4gIGxldCBtaW5vck51bWJlciA9IDA7XG5cbiAgaWYgKHN0cmluZykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHJpbmcubWF0Y2goL15cXGQrXFwuKFxcZCspLyksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBtaW5vck51bWJlciA9IE51bWJlcihzZWNvbmRNYXRjaCk7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBtaW5vck51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgbGV0IHBhdGNoTnVtYmVyID0gMDtcblxuICBpZiAoc3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHN0cmluZy5tYXRjaCgvXlxcZCtcXC5cXGQrXFwuKFxcZCspLyksXG4gICAgICAgICAgc2Vjb25kTWF0Y2ggPSBzZWNvbmQobWF0Y2hlcyk7XG5cbiAgICBwYXRjaE51bWJlciA9IE51bWJlcihzZWNvbmRNYXRjaCk7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBwYXRjaE51bWJlcjtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTUFKT1JfTlVNQkVSX01VTFRJUExJRVIsIE1JTk9SX05VTUJFUl9NVUxUSVBMSUVSLCBQQVRDSF9OVU1CRVJfTVVMVElQTElFUiB9IGZyb20gXCIuL211bHRpcGxlcnNcIjtcbmltcG9ydCB7IG1ham9yTnVtYmVyRnJvbU51bWJlcixcbiAgICAgICAgIG1pbm9yTnVtYmVyRnJvbU51bWJlcixcbiAgICAgICAgIHBhdGNoTnVtYmVyRnJvbU51bWJlcixcbiAgICAgICAgIG1ham9yTnVtYmVyRnJvbVN0cmluZyxcbiAgICAgICAgIG1pbm9yTnVtYmVyRnJvbVN0cmluZyxcbiAgICAgICAgIHBhdGNoTnVtYmVyRnJvbVN0cmluZyB9IGZyb20gXCIuL3V0aWxpdGllcy92ZXJzaW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnNpb24ge1xuICBjb25zdHJ1Y3RvcihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKSB7XG4gICAgdGhpcy5tYWpvck51bWJlciA9IG1ham9yTnVtYmVyO1xuICAgIHRoaXMubWlub3JOdW1iZXIgPSBtaW5vck51bWJlcjtcbiAgICB0aGlzLnBhdGNoTnVtYmVyID0gcGF0Y2hOdW1iZXI7XG4gIH1cblxuICBnZXRNYWpvck51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYWpvck51bWJlcjtcbiAgfVxuXG4gIGdldE1pbm9yTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLm1pbm9yTnVtYmVyO1xuICB9XG5cbiAgZ2V0UGF0Y2hOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0Y2hOdW1iZXI7XG4gIH1cblxuICBidW1wTWFqb3JOdW1iZXIoKSB7XG4gICAgdGhpcy5tYWpvck51bWJlciArPSAxO1xuICB9XG5cbiAgYnVtcE1pbm9yTnVtYmVyKCkge1xuICAgIHRoaXMubWlub3JOdW1iZXIgKz0gMTtcbiAgfVxuXG4gIGJ1bXBQYXRjaE51bWJlcigpIHtcbiAgICB0aGlzLnBhdGNoTnVtYmVyICs9IDE7XG4gIH1cblxuICByZXNldE1ham9yTnVtYmVyKCkge1xuICAgIHRoaXMubWFqb3JOdW1iZXIgPSAwO1xuICB9XG5cbiAgcmVzZXRNaW5vck51bWJlcigpIHtcbiAgICB0aGlzLm1pbm9yTnVtYmVyID0gMDtcbiAgfVxuXG4gIHJlc2V0UGF0Y2hOdW1iZXIoKSB7XG4gICAgdGhpcy5wYXRjaE51bWJlciA9IDA7XG4gIH1cblxuICBtYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbikge1xuICAgIGxldCBtYXRjaGVzU2hvcnRlbmVkVmVyc2lvbiA9IGZhbHNlO1xuXG4gICAgaWYgKHNob3J0ZW5lZFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIG1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWFqb3JOdW1iZXIgPSBzaG9ydGVuZWRWZXJzaW9uLmdldE1ham9yTnVtYmVyKCk7XG5cbiAgICAgIGlmICh0aGlzLm1ham9yTnVtYmVyID09PSBtYWpvck51bWJlcikge1xuICAgICAgICBjb25zdCBtaW5vck51bWJlciA9IHNob3J0ZW5lZFZlcnNpb24uZ2V0TWlub3JOdW1iZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5taW5vck51bWJlciA+PSBtaW5vck51bWJlcikge1xuICAgICAgICAgIG1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzU2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZyA9IGAke3RoaXMubWFqb3JOdW1iZXJ9LiR7dGhpcy5taW5vck51bWJlcn0uJHt0aGlzLnBhdGNoTnVtYmVyfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgdG9WZXJzaW9uTnVtYmVyKCkge1xuICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSB0aGlzLm1ham9yTnVtYmVyICogTUFKT1JfTlVNQkVSX01VTFRJUExJRVIgKyB0aGlzLm1pbm9yTnVtYmVyICogTUlOT1JfTlVNQkVSX01VTFRJUExJRVIgKyB0aGlzLnBhdGNoTnVtYmVyICogUEFUQ0hfTlVNQkVSX01VTFRJUExJRVI7XG5cbiAgICByZXR1cm4gdmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gbWFqb3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSBtaW5vck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSxcbiAgICAgICAgICBwYXRjaE51bWJlciA9IHBhdGNoTnVtYmVyRnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTtcblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gMCxcbiAgICAgICAgICBtaW5vck51bWJlciA9IDAsXG4gICAgICAgICAgcGF0Y2hOdW1iZXIgPSAwLFxuICAgICAgICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTtcblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJzaW9uKHZlcnNpb24pIHtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IHZlcnNpb24uZ2V0TWFqb3JOdW1iZXIoKSxcbiAgICAgICAgICBtaW5vck51bWJlciA9IHZlcnNpb24uZ2V0TWlub3JOdW1iZXIoKSxcbiAgICAgICAgICBwYXRjaE51bWJlciA9IHZlcnNpb24uZ2V0UGF0Y2hOdW1iZXIoKTtcblxuICAgIHZlcnNpb24gPSBuZXcgVmVyc2lvbihtYWpvck51bWJlciwgbWlub3JOdW1iZXIsIHBhdGNoTnVtYmVyKTsgLy8vXG5cbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVyc2lvbk51bWJlcih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgY29uc3QgbnVtYmVyID0gdmVyc2lvbk51bWJlciwgLy8vXG4gICAgICAgICAgbWFqb3JOdW1iZXIgPSBtYWpvck51bWJlckZyb21OdW1iZXIobnVtYmVyKSxcbiAgICAgICAgICBtaW5vck51bWJlciA9IG1pbm9yTnVtYmVyRnJvbU51bWJlcihudW1iZXIpLFxuICAgICAgICAgIHBhdGNoTnVtYmVyID0gcGF0Y2hOdW1iZXJGcm9tTnVtYmVyKG51bWJlciksXG4gICAgICAgICAgdmVyc2lvbiA9IG5ldyBWZXJzaW9uKG1ham9yTnVtYmVyLCBtaW5vck51bWJlciwgcGF0Y2hOdW1iZXIpO1xuXG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRElSRUNUT1JZX1RZUEUgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIGdldFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfVxuXG4gIGlzRmlsZSgpIHtcbiAgICBjb25zdCBmaWxlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIGlzRGlyZWN0b3J5KCkge1xuICAgIGNvbnN0IGRpcmVjdG9yeSA9IHRydWU7XG5cbiAgICByZXR1cm4gZGlyZWN0b3J5O1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gRGlyZWN0b3J5LFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIHR5cGUgPSBESVJFQ1RPUllfVFlQRTtcblxuICBzdGF0aWMgZnJvbVBhdGgocGF0aCkge1xuICAgIGNvbnN0IGRpcmVjdG9yeSA9IG5ldyBEaXJlY3RvcnkocGF0aCk7XG5cbiAgICByZXR1cm4gZGlyZWN0b3J5O1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBsZXQgZGlyZWN0b3J5ID0gbnVsbDtcblxuICAgIGlmIChqc29uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7IHR5cGUgfSA9IGpzb247XG5cbiAgICAgIGlmICh0eXBlID09PSBESVJFQ1RPUllfVFlQRSkge1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGpzb247XG5cbiAgICAgICAgZGlyZWN0b3J5ID0gbmV3IERpcmVjdG9yeShwYXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0b3J5O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhdGhVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgYm90dG9tbW9zdE5hbWVGcm9tUGF0aCB9ID0gcGF0aFV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVOYW1lRnJvbUZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gIGNvbnN0IHBhdGggPSBmaWxlUGF0aCwgIC8vL1xuICAgICAgICBib3R0b21tb3N0TmFtZSA9IGJvdHRvbW1vc3ROYW1lRnJvbVBhdGgocGF0aCksXG4gICAgICAgIGZpbGVOYW1lID0gYm90dG9tbW9zdE5hbWU7ICAvL1xuXG4gIHJldHVybiBmaWxlTmFtZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFJFQURNRV9NRF9GSUxFX05BTUUgPSBcIlJFQURNRS5tZFwiO1xuZXhwb3J0IGNvbnN0IE1FVEFfSlNPTl9GSUxFX05BTUUgPSBcIm1ldGEuanNvblwiO1xuXG5leHBvcnQgY29uc3QgVEVSTV9CTkZfRklMRV9OQU1FID0gXCJ0ZXJtLmJuZlwiO1xuZXhwb3J0IGNvbnN0IFNUQVRFTUVOVF9CTkZfRklMRV9OQU1FID0gXCJzdGF0ZW1lbnQuYm5mXCI7XG5leHBvcnQgY29uc3QgVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSA9IFwidHlwZS52Y2JcIjtcbmV4cG9ydCBjb25zdCBTWU1CT0xfVk9DQUJVTEFSWV9GSUxFX05BTUUgPSBcInN5bWJvbC52Y2JcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBSRUFETUVfTURfRklMRV9OQU1FLFxuICBNRVRBX0pTT05fRklMRV9OQU1FLFxuICBURVJNX0JORl9GSUxFX05BTUUsXG4gIFNUQVRFTUVOVF9CTkZfRklMRV9OQU1FLFxuICBUWVBFX1ZPQ0FCVUxBUllfRklMRV9OQU1FLFxuICBTWU1CT0xfVk9DQUJVTEFSWV9GSUxFX05BTUVcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGZpbGVOYW1lRnJvbUZpbGVQYXRoIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9uYW1lXCI7XG5pbXBvcnQgeyBURVJNX0JORl9GSUxFX05BTUUsIFNUQVRFTUVOVF9CTkZfRklMRV9OQU1FIH0gZnJvbSBcIi4uL2ZpbGVOYW1lc1wiO1xuXG5mdW5jdGlvbiBnZXRCTkYoYm5mRmlsZU5hbWUpIHtcbiAgbGV0IGJuZiA9IEVNUFRZX1NUUklORztcblxuICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZXMgPSB0aGlzLmdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZSA9IGN1c3RvbUdyYW1tYXJCTkZGaWxlcy5maW5kKChjdXN0b21HcmFtbWFyQk5GRmlsZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aCA9IGN1c3RvbUdyYW1tYXJCTkZGaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZU5hbWUgPSBmaWxlTmFtZUZyb21GaWxlUGF0aChjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgpO1xuXG4gICAgICAgICAgaWYgKGN1c3RvbUdyYW1tYXJCTkZGaWxlTmFtZSA9PT0gYm5mRmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoY3VzdG9tR3JhbW1hckJORkZpbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZUNvbnRlbnQgPSBjdXN0b21HcmFtbWFyQk5GRmlsZS5nZXRDb250ZW50KCk7XG5cbiAgICBibmYgPSBjdXN0b21HcmFtbWFyQk5GRmlsZUNvbnRlbnQ7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBibmY7XG59XG5cbmZ1bmN0aW9uIGdldFRlcm1CTkYoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gVEVSTV9CTkZfRklMRV9OQU1FLCAvLy9cbiAgICAgICAgYm5mID0gdGhpcy5nZXRCTkYoZmlsZU5hbWUpLFxuICAgICAgICB0ZXJtQk5GID0gYm5mOyAgLy8vXG5cbiAgcmV0dXJuIHRlcm1CTkY7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlbWVudEJORigpIHtcbiAgY29uc3QgZmlsZU5hbWUgPSBTVEFURU1FTlRfQk5GX0ZJTEVfTkFNRSwgLy8vXG4gICAgICAgIGJuZiA9IHRoaXMuZ2V0Qk5GKGZpbGVOYW1lKSxcbiAgICAgICAgc3RhdGVtZW50Qk5GID0gYm5mOyAgLy8vXG5cbiAgcmV0dXJuIHN0YXRlbWVudEJORjtcbn1cblxuY29uc3QgYm5mTWl4aW5zID0ge1xuICBnZXRCTkYsXG4gIGdldFRlcm1CTkYsXG4gIGdldFN0YXRlbWVudEJORlxufTtcblxuZXhwb3J0IGRlZmF1bHQgYm5mTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgcmVhZG1lRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezF9UkVBRE1FXFxcXC5tZCRcIixcclxuICAgICAgZnVydGxlRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezEsfVteXFxcXC5dK1xcXFwuZnRsJFwiLFxyXG4gICAgICBub21pbmFsRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezEsfVteXFxcXC5dK1xcXFwubm1sJFwiLFxyXG4gICAgICBtYXJrZG93bkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxLH1bXlxcXFwuXStcXFxcLm1kJFwiLFxyXG4gICAgICBtZXRhSlNPTkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfW1ldGFcXFxcLmpzb24kXCIsXHJcbiAgICAgIGluZGV4SlNPTkZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfWluZGV4XFxcXC5qc29uJFwiLFxyXG4gICAgICBtYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezEsfVteXFxcXC5dK1xcXFwubWRzJFwiLFxyXG4gICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGhQYXR0ZXJuID0gXCJeKD86W15cXFxcL10rXFxcXC8pezF9KHRlcm18c3RhdGVtZW50KVxcXFwuYm5mJFwiLFxyXG4gICAgICBkZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoUGF0dGVybiA9IFwiXlteXFxcXC9dK1xcXFwvZGVmYXVsdFxcXFwubWRzJFwiLFxyXG4gICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUGF0dGVybiA9IFwiXig/OlteXFxcXC9dK1xcXFwvKXsxfSh0eXBlfHN5bWJvbClcXFxcLnZjYiRcIixcclxuICAgICAgcmVsZWFzZUZpbGVQYXRoUGF0dGVybiA9IGAke3JlYWRtZUZpbGVQYXRoUGF0dGVybn18JHtmdXJ0bGVGaWxlUGF0aFBhdHRlcm59fCR7bm9taW5hbEZpbGVQYXRoUGF0dGVybn18JHttZXRhSlNPTkZpbGVQYXRoUGF0dGVybn18JHtjdXN0b21HcmFtbWFyQk5GRmlsZVBhdGhQYXR0ZXJufXwke2N1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGhQYXR0ZXJufWAsXHJcbiAgICAgIHJlY29nbmlzZWRGaWxlUGF0aFBhdHRlcm4gPSBgJHtyZWxlYXNlRmlsZVBhdGhQYXR0ZXJufXwke2luZGV4SlNPTkZpbGVQYXRoUGF0dGVybn18JHttYXJrZG93bkZpbGVQYXRoUGF0dGVybn18JHttYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJufWA7XHJcblxyXG5jb25zdCByZWFkbWVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChyZWFkbWVGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBmdXJ0bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChmdXJ0bGVGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICByZWxlYXNlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocmVsZWFzZUZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG5vbWluYWxGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChub21pbmFsRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgbWFya2Rvd25GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChtYXJrZG93bkZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG1ldGFKU09ORmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAobWV0YUpTT05GaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBpbmRleEpTT05GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChpbmRleEpTT05GaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICByZWNvZ25pc2VkRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocmVjb2duaXNlZEZpbGVQYXRoUGF0dGVybiksXHJcbiAgICAgIG1hcmtkb3duU3R5bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChtYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aFBhdHRlcm4pLFxyXG4gICAgICBkZWZhdWx0TWFya2Rvd25TdHlsZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKGRlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGhQYXR0ZXJuKSxcclxuICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uID0gbmV3IFJlZ0V4cChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUGF0dGVybik7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aFJlYWRtZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiByZWFkbWVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aEZ1cnRsZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBmdXJ0bGVGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aFJlbGVhc2VGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gcmVsZWFzZUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTm9taW5hbEZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBub21pbmFsRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhNYXJrZG93bkZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBtYXJrZG93bkZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gbWV0YUpTT05GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aEluZGV4SlNPTkZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBpbmRleEpTT05GaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aFJlY29nbmlzZWRGaWxlUGF0aChmaWxlUGF0aCkgeyByZXR1cm4gcmVjb2duaXNlZEZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVQYXRoTWFya2Rvd25TdHlsZUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBtYXJrZG93blN0eWxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIGN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aFJlZ3VsYXJFeHByZXNzaW9uLnRlc3QoZmlsZVBhdGgpOyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlUGF0aERlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGgoZmlsZVBhdGgpIHsgcmV0dXJuIGRlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGhSZWd1bGFyRXhwcmVzc2lvbi50ZXN0KGZpbGVQYXRoKTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoKGZpbGVQYXRoKSB7IHJldHVybiBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVQYXRoUmVndWxhckV4cHJlc3Npb24udGVzdChmaWxlUGF0aCk7IH1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBpc0ZpbGVQYXRoUmVhZG1lRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aEZ1cnRsZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aE5vbWluYWxGaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoTWFya2Rvd25GaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoSW5kZXhKU09ORmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aFJlY29nbmlzZWRGaWxlUGF0aCxcclxuICBpc0ZpbGVQYXRoTWFya2Rvd25TdHlsZUZpbGVQYXRoLFxyXG4gIGlzRmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aERlZmF1bHRNYXJrZG93blN0eWxlRmlsZVBhdGgsXHJcbiAgaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGhcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBpc0ZpbGVQYXRoUmVhZG1lRmlsZVBhdGgsXG4gICAgICAgICBpc0ZpbGVQYXRoRnVydGxlRmlsZVBhdGgsXG4gICAgICAgICBpc0ZpbGVQYXRoTm9taW5hbEZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aE1ldGFKU09ORmlsZVBhdGgsXG4gICAgICAgICBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoLFxuICAgICAgICAgaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGggfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2ZpbGVQYXRoXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkbWVGaWxlRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGxldCByZWFkbWVGaWxlID0gbnVsbDtcblxuICBmaWxlcy5zb21lRmlsZSgoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCksXG4gICAgICAgICAgZmlsZVBhdGhSZWFkbWVGaWxlUGF0aCA9IGlzRmlsZVBhdGhSZWFkbWVGaWxlUGF0aChmaWxlUGF0aCk7XG5cbiAgICBpZiAoZmlsZVBhdGhSZWFkbWVGaWxlUGF0aCkge1xuICAgICAgcmVhZG1lRmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVhZG1lRmlsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZUZpbGVzRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGNvbnN0IGZ1cnRsZUZpbGVzID0gZmlsZXMucmVkdWNlRmlsZSgoZnVydGxlRmlsZXMsIGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgIGZpbGVQYXRoRnVydGxlRmlsZVBhdGggPSBpc0ZpbGVQYXRoRnVydGxlRmlsZVBhdGgoZmlsZVBhdGgpLFxuICAgICAgICAgIGZpbGVGdXJ0bGVGaWxlID0gZmlsZVBhdGhGdXJ0bGVGaWxlUGF0aDsgIC8vL1xuXG4gICAgaWYgKGZpbGVGdXJ0bGVGaWxlKSB7XG4gICAgICBjb25zdCBmdXJ0bGVGaWxlID0gZmlsZTsgIC8vL1xuXG4gICAgICBmdXJ0bGVGaWxlcy5wdXNoKGZ1cnRsZUZpbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdXJ0bGVGaWxlcztcbiAgfSwgW10pO1xuXG4gIHJldHVybiBmdXJ0bGVGaWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vbWluYWxGaWxlc0Zyb21GaWxlcyhmaWxlcykge1xuICBjb25zdCBub21pbmFsRmlsZXMgPSBmaWxlcy5yZWR1Y2VGaWxlKChub21pbmFsRmlsZXMsIGZpbGUpID0+IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgZmlsZVBhdGhOb21pbmFsRmlsZVBhdGggPSBpc0ZpbGVQYXRoTm9taW5hbEZpbGVQYXRoKGZpbGVQYXRoKSxcbiAgICAgIGZpbGVOb21pbmFsRmlsZSA9IGZpbGVQYXRoTm9taW5hbEZpbGVQYXRoOyAgLy8vXG5cbiAgICBpZiAoZmlsZU5vbWluYWxGaWxlKSB7XG4gICAgICBjb25zdCBub21pbmFsRmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgbm9taW5hbEZpbGVzLnB1c2gobm9taW5hbEZpbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub21pbmFsRmlsZXM7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gbm9taW5hbEZpbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWV0YUpTT05GaWxlRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGxldCBtZXRhSlNPTkZpbGUgPSBudWxsO1xuXG4gIGZpbGVzLnNvbWVGaWxlKChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBmaWxlUGF0aE1ldGFKU09ORmlsZVBhdGggPSBpc0ZpbGVQYXRoTWV0YUpTT05GaWxlUGF0aChmaWxlUGF0aCk7XG5cbiAgICBpZiAoZmlsZVBhdGhNZXRhSlNPTkZpbGVQYXRoKSB7XG4gICAgICBtZXRhSlNPTkZpbGUgPSBmaWxlOyAgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG1ldGFKU09ORmlsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbUdyYW1tYXJCTkZGaWxlc0Zyb21GaWxlcyhmaWxlcykge1xuICBjb25zdCBjdXN0b21HcmFtbWFyQk5GRmlsZXMgPSBmaWxlcy5yZWR1Y2VGaWxlKChjdXN0b21HcmFtbWFyQk5GRmlsZXMsIGZpbGUpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoQ3VzdG9tR3JhbW1hckJORkZpbGVQYXRoID0gaXNGaWxlUGF0aEN1c3RvbUdyYW1tYXJCTkZGaWxlUGF0aChmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgZmlsZUN1c3RvbUdyYW1tYXJCTkZGaWxlID0gZmlsZVBhdGhDdXN0b21HcmFtbWFyQk5GRmlsZVBhdGg7ICAvLy9cblxuICAgICAgICAgIGlmIChmaWxlQ3VzdG9tR3JhbW1hckJORkZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJCTkZGaWxlID0gZmlsZTsgIC8vL1xuXG4gICAgICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZXMucHVzaChjdXN0b21HcmFtbWFyQk5GRmlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUdyYW1tYXJCTkZGaWxlcztcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyQk5GRmlsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzRnJvbUZpbGVzKGZpbGVzKSB7XG4gIGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMgPSBmaWxlcy5yZWR1Y2VGaWxlKChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzLCBmaWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICAgICAgICBmaWxlUGF0aEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGggPSBpc0ZpbGVQYXRoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aChmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgZmlsZUN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSA9IGZpbGVQYXRoQ3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aDsgIC8vL1xuXG4gICAgICAgICAgaWYgKGZpbGVDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSA9IGZpbGU7ICAvLy9cblxuICAgICAgICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcy5wdXNoKGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXM7XG4gICAgICAgIH0sIFtdKTtcblxuICByZXR1cm4gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcztcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcmVhZG1lRmlsZUZyb21GaWxlcyxcbiAgICAgICAgIGZ1cnRsZUZpbGVzRnJvbUZpbGVzLFxuICAgICAgICAgbm9taW5hbEZpbGVzRnJvbUZpbGVzLFxuICAgICAgICAgbWV0YUpTT05GaWxlRnJvbUZpbGVzLFxuICAgICAgICAgY3VzdG9tR3JhbW1hckJORkZpbGVzRnJvbUZpbGVzLFxuICAgICAgICAgY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc0Zyb21GaWxlcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvZmlsZXNcIjtcblxuZnVuY3Rpb24gZ2V0UmVhZG1lRmlsZSgpIHtcbiAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKCksXG4gICAgICAgIHJlYWRtZUZpbGUgPSByZWFkbWVGaWxlRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gcmVhZG1lRmlsZTtcbn1cblxuZnVuY3Rpb24gZ2V0RnVydGxlRmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBmdXJ0bGVGaWxlcyA9IGZ1cnRsZUZpbGVzRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gZnVydGxlRmlsZXM7XG59XG5cbmZ1bmN0aW9uIGdldE5vbWluYWxGaWxlcygpIHtcbiAgY29uc3QgZmlsZXMgPSB0aGlzLmdldEZpbGVzKCksXG4gICAgICAgIG5vbWluYWxGaWxlcyA9IG5vbWluYWxGaWxlc0Zyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIG5vbWluYWxGaWxlcztcbn1cblxuZnVuY3Rpb24gZ2V0TWV0YUpTT05GaWxlKCkge1xuICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgbWV0YUpTT05GaWxlID0gbWV0YUpTT05GaWxlRnJvbUZpbGVzKGZpbGVzKTtcblxuICByZXR1cm4gbWV0YUpTT05GaWxlO1xufVxuXG5mdW5jdGlvbiBnZXRDdXN0b21HcmFtbWFyQk5GRmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyQk5GRmlsZXMgPSBjdXN0b21HcmFtbWFyQk5GRmlsZXNGcm9tRmlsZXMoZmlsZXMpO1xuXG4gIHJldHVybiBjdXN0b21HcmFtbWFyQk5GRmlsZXM7XG59XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMoKSB7XG4gIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc0Zyb21GaWxlcyhmaWxlcyk7XG5cbiAgcmV0dXJuIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXM7XG59XG5cbmNvbnN0IGZpbGVzTWl4aW5zID0ge1xuICBnZXRSZWFkbWVGaWxlLFxuICBnZXRGdXJ0bGVGaWxlcyxcbiAgZ2V0Tm9taW5hbEZpbGVzLFxuICBnZXRNZXRhSlNPTkZpbGUsXG4gIGdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcyxcbiAgZ2V0Q3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZmlsZXNNaXhpbnM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlcGVuZGVuY3kge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBzaG9ydGVuZWRWZXJzaW9uKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnNob3J0ZW5lZFZlcnNpb24gPSBzaG9ydGVuZWRWZXJzaW9uO1xuICB9XG5cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgZ2V0U2hvcnRlZFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIGFzU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmc7XG5cbiAgICBpZiAodGhpcy5zaG9ydGVuZWRWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzaG9ydGVuZWRWZXJzaW9uU3RyaW5nID0gdGhpcy5zaG9ydGVuZWRWZXJzaW9uLnRvU3RyaW5nKCk7XG5cbiAgICAgIHN0cmluZyA9IGAke3RoaXMubmFtZX1AJHtzaG9ydGVuZWRWZXJzaW9uU3RyaW5nfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmluZyA9IHRoaXMubmFtZTsgLy8vXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgY29uc3Qgc2hvcnRlbmVkVmVyc2lvbiA9IG51bGwsXG4gICAgICAgICAgZGVwZW5kZW5jeSA9IG5ldyBEZXBlbmRlbmN5KG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5hbWVBbmRTaG9ydGVuZWRWZXJzaW9uKG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pIHtcbiAgICBjb25zdCBkZXBlbmRlbmN5ID0gbmV3IERlcGVuZGVuY3kobmFtZSwgc2hvcnRlbmVkVmVyc2lvbik7XG5cbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBNQUpPUl9OVU1CRVJfTVVMVElQTElFUiwgTUlOT1JfTlVNQkVSX01VTFRJUExJRVIgfSBmcm9tIFwiLi9tdWx0aXBsZXJzXCI7XG5pbXBvcnQgeyBtYWpvck51bWJlckZyb21OdW1iZXIsIG1pbm9yTnVtYmVyRnJvbU51bWJlciwgbWFqb3JOdW1iZXJGcm9tU3RyaW5nLCBtaW5vck51bWJlckZyb21TdHJpbmcgfSBmcm9tIFwiLi91dGlsaXRpZXMvdmVyc2lvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaG9ydGVuZWRWZXJzaW9uIHtcbiAgY29uc3RydWN0b3IobWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKSB7XG4gICAgdGhpcy5tYWpvck51bWJlciA9IG1ham9yTnVtYmVyO1xuICAgIHRoaXMubWlub3JOdW1iZXIgPSBtaW5vck51bWJlcjtcbiAgfVxuXG4gIGdldE1ham9yTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLm1ham9yTnVtYmVyO1xuICB9XG5cbiAgZ2V0TWlub3JOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlub3JOdW1iZXI7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmcgPSBgJHt0aGlzLm1ham9yTnVtYmVyfS4ke3RoaXMubWlub3JOdW1iZXJ9YDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICB0b1ZlcnNpb25OdW1iZXIoKSB7XG4gICAgY29uc3QgdmVyc2lvbk51bWJlciA9IHRoaXMubWFqb3JOdW1iZXIgKiBNQUpPUl9OVU1CRVJfTVVMVElQTElFUiArIHRoaXMubWlub3JOdW1iZXIgKiBNSU5PUl9OVU1CRVJfTVVMVElQTElFUjtcblxuICAgIHJldHVybiB2ZXJzaW9uTnVtYmVyO1xuICB9XG5cbiAgZ2V0TGVhc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXIoKSB7XG4gICAgY29uc3QgdmVyc2lvbk51bWJlciA9IHRoaXMudG9WZXJzaW9uTnVtYmVyKCksXG4gICAgICAgICAgbGVhc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uTnVtYmVyOyAvLy9cblxuICAgIHJldHVybiBsZWFzdE1hdGNoaW5nVmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIGdldEdyZWF0ZXN0TWF0Y2hpbmdWZXJzaW9uTnVtYmVyKCkge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gdGhpcy5tYWpvck51bWJlciArIDEsXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSAwLFxuICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb24gPSBTaG9ydGVuZWRWZXJzaW9uLmZyb21NYWpvck51bWJlckFuZE1pbm9yTnVtYmVyKG1ham9yTnVtYmVyLCBtaW5vck51bWJlciksXG4gICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbk51bWJlciA9IHNob3J0ZW5lZFZlcnNpb24udG9WZXJzaW9uTnVtYmVyKCksXG4gICAgICAgICAgZ3JlYXRlc3RNYXRjaGluZ1ZlcnNpb25OdW1iZXIgPSBzaG9ydGVuZWRWZXJzaW9uTnVtYmVyIC0gMTtcblxuICAgIHJldHVybiBncmVhdGVzdE1hdGNoaW5nVmVyc2lvbk51bWJlcjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IG1ham9yTnVtYmVyID0gbWFqb3JOdW1iZXJGcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgbWlub3JOdW1iZXIgPSBtaW5vck51bWJlckZyb21TdHJpbmcoc3RyaW5nKSxcbiAgICAgICAgICBzaG9ydGVuZWRWZXJzaW9uID0gbmV3IFNob3J0ZW5lZFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKTtcblxuICAgIHJldHVybiBzaG9ydGVuZWRWZXJzaW9uO1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJzaW9uTnVtYmVyKHZlcnNpb25OdW1iZXIpIHtcbiAgICBjb25zdCBudW1iZXIgPSB2ZXJzaW9uTnVtYmVyLCAvLy9cbiAgICAgICAgICBtYWpvck51bWJlciA9IG1ham9yTnVtYmVyRnJvbU51bWJlcihudW1iZXIpLFxuICAgICAgICAgIG1pbm9yTnVtYmVyID0gbWlub3JOdW1iZXJGcm9tTnVtYmVyKG51bWJlciksXG4gICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IG5ldyBTaG9ydGVuZWRWZXJzaW9uKG1ham9yTnVtYmVyLCBtaW5vck51bWJlcik7XG5cbiAgICByZXR1cm4gc2hvcnRlbmVkVmVyc2lvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTWFqb3JOdW1iZXJBbmRNaW5vck51bWJlcihtYWpvck51bWJlciwgbWlub3JOdW1iZXIpIHtcbiAgICBjb25zdCBzaG9ydGVuZWRWZXJzaW9uID0gbmV3IFNob3J0ZW5lZFZlcnNpb24obWFqb3JOdW1iZXIsIG1pbm9yTnVtYmVyKTtcblxuICAgIHJldHVybiBzaG9ydGVuZWRWZXJzaW9uO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IERlcGVuZGVuY3kgZnJvbSBcIi4vZGVwZW5kZW5jeVwiO1xuaW1wb3J0IFNob3J0ZW5lZFZlcnNpb24gZnJvbSBcIi4vc2hvcnRlbmVkVmVyc2lvblwiO1xuXG5jb25zdCB7IGZvckVhY2ggfSA9IGFzeW5jaHJvbm91c1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVwZW5kZW5jaWVzIHtcbiAgY29uc3RydWN0b3IoYXJyYXkpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGFkZERlcGVuZGVuY3koZGVwZW5kZW5jeSkgeyB0aGlzLmFycmF5LnB1c2goZGVwZW5kZW5jeSk7IH1cblxuICBtYXBEZXBlbmRlbmN5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICBldmVyeURlcGVuZGVuY3koY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuZXZlcnkoY2FsbGJhY2spOyB9XG5cbiAgcmVkdWNlRGVwZW5kZW5jeShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmFycmF5LnJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKTsgfVxuXG4gIGZvckVhY2hEZXBlbmRlbmN5KGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICBhc3luY2hyb25vdXNGb3JFYWNoRGVwZW5kZW5jeShvcGVyYXRpb24sIGRvbmUpIHsgZm9yRWFjaCh0aGlzLmFycmF5LCBvcGVyYXRpb24sIGRvbmUpOyB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llc0pTT04gPSB0aGlzLmFycmF5LnJlZHVjZSgoZGVwZW5kZW5jaWVzSlNPTiwgZGVwZW5kZW5jeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRlcGVuZGVuY3kuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IGRlcGVuZGVuY3kuZ2V0U2hvcnRlZFZlcnNpb24oKSxcbiAgICAgICAgICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBzaG9ydGVuZWRWZXJzaW9uLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGRlcGVuZGVuY2llc0pTT05bbmFtZV0gPSBzaG9ydGVuZWRWZXJzaW9uU3RyaW5nO1xuICBcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNKU09OO1xuICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICBqc29uID0gZGVwZW5kZW5jaWVzSlNPTjsgLy8vXG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzSlNPTiA9IGpzb24sIC8vL1xuICAgICAgICAgIGRlcGVuZGVuY2llc0pTT05LZXlzID0gT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzSlNPTiksXG4gICAgICAgICAgbmFtZXMgPSBkZXBlbmRlbmNpZXNKU09OS2V5cywgLy8vXG4gICAgICAgICAgYXJyYXkgPSBuYW1lcy5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBkZXBlbmRlbmNpZXNKU09OW25hbWVdLFxuICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc2hvcnRlbmVkVmVyc2lvblN0cmluZywgIC8vL1xuICAgICAgICAgICAgICAgICAgc2hvcnRlbmVkVmVyc2lvbiA9IFNob3J0ZW5lZFZlcnNpb24uZnJvbVN0cmluZyhzdHJpbmcpLFxuICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IERlcGVuZGVuY3kuZnJvbU5hbWVBbmRTaG9ydGVuZWRWZXJzaW9uKG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBuZXcgRGVwZW5kZW5jaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBuZXcgRGVwZW5kZW5jaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUXVlcnkgfSBmcm9tIFwib2NjYW0tcXVlcnlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICBub2RlID0gbm9kZXMuc2hpZnQoKSB8fCBudWxsOyAvLy9cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZXNRdWVyeShleHByZXNzaW9uU3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBub2RlcyA9IHF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ1ZlcnNpb25TdHJpbmcoc3RyaW5nKSB7IHJldHVybiAvKD86MHwoWzEtOV1cXGQqKSlcXC4oPzowfChbMS05XVxcZCopKVxcLig/OjB8KFsxLTldXFxkKikpLy50ZXN0KHN0cmluZyk7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyhzdHJpbmcpIHsgcmV0dXJuIC8oPzowfChbMS05XVxcZCopKVxcLig/OjB8KFsxLTldXFxkKikpLy50ZXN0KHN0cmluZyk7IH1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFZFUlNJT05fUFJPUEVSVFlfTkFNRSA9IFwidmVyc2lvblwiO1xuZXhwb3J0IGNvbnN0IFJFUE9TSVRPUllfUFJPUEVSVFlfTkFNRSA9IFwicmVwb3NpdG9yeVwiO1xuZXhwb3J0IGNvbnN0IERFUEVOREVOQ0lFU19QUk9QRVJUWV9OQU1FID0gXCJkZXBlbmRlbmNpZXNcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgSlNPTkxleGVyLCBKU09OUGFyc2VyIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXJzXCI7XG5cbmltcG9ydCBWZXJzaW9uIGZyb20gXCIuLi92ZXJzaW9uXCI7XG5pbXBvcnQgRGVwZW5kZW5jeSBmcm9tIFwiLi4vZGVwZW5kZW5jeVwiO1xuaW1wb3J0IERlcGVuZGVuY2llcyBmcm9tIFwiLi4vZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgU2hvcnRlbmVkVmVyc2lvbiBmcm9tIFwiLi4vc2hvcnRlbmVkVmVyc2lvblwiO1xuXG5pbXBvcnQgeyBET1VCTEVfU1BBQ0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyB0cmltRG91YmxlUXVvdGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9jb250ZW50XCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBpc1N0cmluZ1ZlcnNpb25TdHJpbmcsIGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdmFsaWRhdGVcIjtcbmltcG9ydCB7IFZFUlNJT05fUFJPUEVSVFlfTkFNRSwgUkVQT1NJVE9SWV9QUk9QRVJUWV9OQU1FLCBERVBFTkRFTkNJRVNfUFJPUEVSVFlfTkFNRSB9IGZyb20gXCIuLi9wcm9wZXJ0eU5hbWVzXCI7XG5cbmNvbnN0IGpzb25MZXhlciA9IEpTT05MZXhlci5mcm9tTm90aGluZygpLFxuICAgICAganNvblBhcnNlciA9IEpTT05QYXJzZXIuZnJvbU5vdGhpbmcoKTtcblxuY29uc3QgZXJyb3JOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi8qL2Vycm9yXCIpLFxuICAgICAgcHJvcGVydHlOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi9wcm9wZXJ0eS9qc29uL29iamVjdC9wcm9wZXJ0eVwiKSxcbiAgICAgIGRvY3VtZW50UHJvcGVydHlOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi9kb2N1bWVudC9qc29uL29iamVjdC9wcm9wZXJ0eVwiKSxcbiAgICAgIHByb3BlcnR5U3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3Byb3BlcnR5L0BzdHJpbmctbGl0ZXJhbFwiKSxcbiAgICAgIHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9wcm9wZXJ0eS9qc29uL0BzdHJpbmctbGl0ZXJhbCFcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01ldGFKU09ORmlsZVZhbGlkKG1ldGFKU09ORmlsZSkge1xuICBsZXQgbWV0YUpTT05GaWxlVmFsaWQgPSBmYWxzZTtcblxuICBjb25zdCBkb2N1bWVudE5vZGUgPSBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSk7XG5cbiAgaWYgKGRvY3VtZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGVycm9yTm9kZXMgPSBlcnJvck5vZGVzUXVlcnkoZG9jdW1lbnROb2RlKSxcbiAgICAgICAgICBlcnJvck5vZGVzTGVuZ3RoID0gZXJyb3JOb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoZXJyb3JOb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25Gcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSksXG4gICAgICAgICAgICByZXBvc2l0b3J5ID0gcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICAgICAgbWV0YUpTT05GaWxlVmFsaWQgPSAoKHZlcnNpb24gIT09IG51bGwpICYmIChyZXBvc2l0b3J5ICE9PSBudWxsKSAmJiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ldGFKU09ORmlsZVZhbGlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWV0YUpTT05GaWxlVmVyc2lvbihtZXRhSlNPTkZpbGUsIHZlcnNpb24pIHtcbiAgY29uc3QgZG9jdW1lbnROb2RlID0gZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZShtZXRhSlNPTkZpbGUpLFxuICAgICAgICByZXBvc2l0b3J5ID0gcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBsZXQgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpO1xuXG4gIGNvbnN0IHN0cmluZyA9IHZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgZGVwZW5kZW5jaWVzSlNPTiA9IGRlcGVuZGVuY2llcy50b0pTT04oKTtcblxuICB2ZXJzaW9uID0gc3RyaW5nOyAgLy8vXG5cbiAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzSlNPTjsgIC8vL1xuXG4gIGNvbnN0IG1ldGFKU09OID0ge1xuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgcmVwb3NpdG9yeSxcbiAgICAgICAgICBkZXBlbmRlbmNpZXNcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YUpTT05TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShtZXRhSlNPTiwgbnVsbCwgRE9VQkxFX1NQQUNFKSxcbiAgICAgICAgbWV0YUpTT05GaWxlQ29udGVudCA9IG1ldGFKU09OU3RyaW5nOyAvLy9cblxuICBtZXRhSlNPTkZpbGUuc2V0Q29udGVudChtZXRhSlNPTkZpbGVDb250ZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSB7XG4gIGxldCBkb2N1bWVudE5vZGUgPSBudWxsO1xuXG4gIGlmIChtZXRhSlNPTkZpbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBjb250ZW50ID0gbWV0YUpTT05GaWxlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICB0b2tlbnMgPSBqc29uTGV4ZXIudG9rZW5pc2UoY29udGVudCksXG4gICAgICAgICAgbm9kZSA9IGpzb25QYXJzZXIucGFyc2UodG9rZW5zKTtcblxuICAgIGRvY3VtZW50Tm9kZSA9IG5vZGU7ICAvLy9cbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uRnJvbURvY3VtZW50Tm9kZShkb2N1bWVudE5vZGUpIHtcbiAgbGV0IHZlcnNpb24gPSBudWxsO1xuXG4gIGNvbnN0IGRvY3VtZW50UHJvcGVydHlOb2RlcyA9IGRvY3VtZW50UHJvcGVydHlOb2Rlc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBkb2N1bWVudFByb3BlcnR5Tm9kZXMuc29tZSgoZG9jdW1lbnRQcm9wZXJ0eU5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBkb2N1bWVudFByb3BlcnR5Tm9kZSwgIC8vL1xuICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09IFZFUlNJT05fUFJPUEVSVFlfTkFNRSkge1xuICAgICAgY29uc3Qgc3RyaW5nUHJvcGVydHlWYWx1ZSA9IHN0cmluZ1Byb3BlcnR5VmFsdWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSk7XG5cbiAgICAgIGlmIChzdHJpbmdQcm9wZXJ0eVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IHN0cmluZ1Byb3BlcnR5VmFsdWUsIC8vL1xuICAgICAgICAgICAgICBzdHJpbmdWZXJzaW9uU3RyaW5nID0gaXNTdHJpbmdWZXJzaW9uU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKHN0cmluZ1ZlcnNpb25TdHJpbmcpIHtcbiAgICAgICAgICB2ZXJzaW9uID0gVmVyc2lvbi5mcm9tU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSB7XG4gIGxldCByZXBvc2l0b3J5ID0gbnVsbDtcblxuICBjb25zdCBkb2N1bWVudFByb3BlcnR5Tm9kZXMgPSBkb2N1bWVudFByb3BlcnR5Tm9kZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgZG9jdW1lbnRQcm9wZXJ0eU5vZGVzLnNvbWUoKGRvY3VtZW50UHJvcGVydHlOb2RlKSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZG9jdW1lbnRQcm9wZXJ0eU5vZGUsICAvLy9cbiAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSk7XG5cbiAgICBpZiAocHJvcGVydHlOYW1lID09PSBSRVBPU0lUT1JZX1BST1BFUlRZX05BTUUpIHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXBvc2l0b3J5ID0gc3RyaW5nUHJvcGVydHlWYWx1ZTsgIC8vL1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlcG9zaXRvcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBsZXQgZGVwZW5kZW5jaWVzID0gbnVsbDtcblxuICBjb25zdCBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGVGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgaWYgKGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZSAhPT0gbnVsbCkge1xuICAgIGRlcGVuZGVuY2llcyA9IERlcGVuZGVuY2llcy5mcm9tTm90aGluZygpO1xuXG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlLCAgLy8vXG4gICAgICAgICAgcHJvcGVydHlOb2RlcyA9IHByb3BlcnR5Tm9kZXNRdWVyeShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgcHJvcGVydHlOb2Rlcy5mb3JFYWNoKChwcm9wZXJ0eU5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgc3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyA9IGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChzdHJpbmdTaG9ydGVuZWRWZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eU5hbWUsICAvLy9cbiAgICAgICAgICAgICAgICBzaG9ydGVuZWRWZXJzaW9uID0gU2hvcnRlbmVkVmVyc2lvbi5mcm9tU3RyaW5nKHN0cmluZyksXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IERlcGVuZGVuY3kuZnJvbU5hbWVBbmRTaG9ydGVuZWRWZXJzaW9uKG5hbWUsIHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZERlcGVuZGVuY3koZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXBlbmRlbmN5TmFtZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBsZXQgZGVwZW5kZW5jeU5hbWVzID0gbnVsbDtcblxuICBjb25zdCBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGVGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgaWYgKGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZSAhPT0gbnVsbCkge1xuICAgIGRlcGVuZGVuY3lOYW1lcyA9IFtdO1xuXG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlLCAgLy8vXG4gICAgICAgICAgcHJvcGVydHlOb2RlcyA9IHByb3BlcnR5Tm9kZXNRdWVyeShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgcHJvcGVydHlOb2Rlcy5mb3JFYWNoKChwcm9wZXJ0eU5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHN0cmluZ1Byb3BlcnR5VmFsdWUgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpO1xuXG4gICAgICBpZiAoc3RyaW5nUHJvcGVydHlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdQcm9wZXJ0eVZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgc3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyA9IGlzU3RyaW5nU2hvcnRlbmVkVmVyc2lvblN0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChzdHJpbmdTaG9ydGVuZWRWZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lRnJvbVByb3BlcnR5Tm9kZShwcm9wZXJ0eU5vZGUpLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lOYW1lID0gcHJvcGVydHlOYW1lOyAgLy8vXG5cbiAgICAgICAgICBkZXBlbmRlbmN5TmFtZXMucHVzaChkZXBlbmRlbmN5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmN5TmFtZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNNZXRhSlNPTkZpbGVWYWxpZCxcbiAgdXBkYXRlTWV0YUpTT05GaWxlVmVyc2lvbixcbiAgZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZSxcbiAgdmVyc2lvbkZyb21Eb2N1bWVudE5vZGUsXG4gIHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlLFxuICBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlLFxuICBkZXBlbmRlbmN5TmFtZXNGcm9tRG9jdW1lbnROb2RlXG59O1xuXG5mdW5jdGlvbiBwcm9wZXJ0eU5hbWVGcm9tUHJvcGVydHlOb2RlKHByb3BlcnR5Tm9kZSkge1xuICBjb25zdCBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUgPSBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVRdWVyeShwcm9wZXJ0eU5vZGUpLFxuICAgICAgICBwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVDb250ZW50ID0gcHJvcGVydHlTdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlLmdldENvbnRlbnQoKSxcbiAgICAgICAgcHJvcGVydHlOYW1lID0gdHJpbURvdWJsZVF1b3Rlcyhwcm9wZXJ0eVN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGVDb250ZW50KTsgLy8vXG5cbiAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nUHJvcGVydHlWYWx1ZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKSB7XG4gIGxldCBzdHJpbmdQcm9wZXJ0eVZhbHVlID0gbnVsbDtcblxuICBjb25zdCBwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlID0gcHJvcGVydHlKU09OU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZVF1ZXJ5KHByb3BlcnR5Tm9kZSk7XG5cbiAgaWYgKHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcm9wZXJ0eUpTT05TdHJpbmdMaXRlcmFsVGVybWluYWxOb2RlQ29udGVudCA9IHByb3BlcnR5SlNPTlN0cmluZ0xpdGVyYWxUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgc3RyaW5nUHJvcGVydHlWYWx1ZSA9IHRyaW1Eb3VibGVRdW90ZXMocHJvcGVydHlKU09OU3RyaW5nTGl0ZXJhbFRlcm1pbmFsTm9kZUNvbnRlbnQpOyAvLy9cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdQcm9wZXJ0eVZhbHVlO1xufVxuXG5mdW5jdGlvbiBkb2N1bWVudFByb3BlcnR5Tm9kZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSkge1xuICBjb25zdCBkb2N1bWVudFByb3BlcnR5Tm9kZXMgPSBkb2N1bWVudFByb3BlcnR5Tm9kZXNRdWVyeShkb2N1bWVudE5vZGUpO1xuXG4gIHJldHVybiBkb2N1bWVudFByb3BlcnR5Tm9kZXM7XG59XG5cbmZ1bmN0aW9uIGRlcGVuZGVuY2llc1Byb3BlcnR5Tm9kZUZyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKSB7XG4gIGxldCBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBudWxsO1xuXG4gIGNvbnN0IGRvY3VtZW50UHJvcGVydHlOb2RlcyA9IGRvY3VtZW50UHJvcGVydHlOb2Rlc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICBkb2N1bWVudFByb3BlcnR5Tm9kZXMuc29tZSgoZG9jdW1lbnRQcm9wZXJ0eU5vZGUpID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBkb2N1bWVudFByb3BlcnR5Tm9kZSwgIC8vL1xuICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZUZyb21Qcm9wZXJ0eU5vZGUocHJvcGVydHlOb2RlKTtcblxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09IERFUEVOREVOQ0lFU19QUk9QRVJUWV9OQU1FKSB7XG4gICAgICBkZXBlbmRlbmNpZXNQcm9wZXJ0eU5vZGUgPSBwcm9wZXJ0eU5vZGU7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGVwZW5kZW5jaWVzUHJvcGVydHlOb2RlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyB2ZXJzaW9uRnJvbURvY3VtZW50Tm9kZSwgcmVwb3NpdG9yeUZyb21Eb2N1bWVudE5vZGUsIGRlcGVuZGVuY2llc0Zyb21Eb2N1bWVudE5vZGUsIGRlcGVuZGVuY3lOYW1lc0Zyb21Eb2N1bWVudE5vZGUsIGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL21ldGFKU09OXCI7XG5cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgIGRvY3VtZW50Tm9kZSA9IGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSxcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb25Gcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbmZ1bmN0aW9uIGdldFJlcG9zaXRvcnkoKSB7XG4gIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgIGRvY3VtZW50Tm9kZSA9IGRvY3VtZW50Tm9kZUZyb21NZXRhSlNPTkZpbGUobWV0YUpTT05GaWxlKSxcbiAgICAgICAgcmVwb3NpdG9yeSA9IHJlcG9zaXRvcnlGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHJlcG9zaXRvcnk7XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcygpIHtcbiAgY29uc3QgbWV0YUpTT05GaWxlID0gdGhpcy5nZXRNZXRhSlNPTkZpbGUoKSxcbiAgICAgICAgZG9jdW1lbnROb2RlID0gZG9jdW1lbnROb2RlRnJvbU1ldGFKU09ORmlsZShtZXRhSlNPTkZpbGUpLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXNGcm9tRG9jdW1lbnROb2RlKGRvY3VtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIGRlcGVuZGVuY2llcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeU5hbWVzKCkge1xuICBjb25zdCBtZXRhSlNPTkZpbGUgPSB0aGlzLmdldE1ldGFKU09ORmlsZSgpLFxuICAgICAgICBkb2N1bWVudE5vZGUgPSBkb2N1bWVudE5vZGVGcm9tTWV0YUpTT05GaWxlKG1ldGFKU09ORmlsZSksXG4gICAgICAgIGRlcGVuZGVuY3lOYW1lcyA9IGRlcGVuZGVuY3lOYW1lc0Zyb21Eb2N1bWVudE5vZGUoZG9jdW1lbnROb2RlKTtcblxuICByZXR1cm4gZGVwZW5kZW5jeU5hbWVzO1xufVxuXG5jb25zdCBtZXRhSlNPTk1peGlucyA9IHtcbiAgZ2V0VmVyc2lvbixcbiAgZ2V0UmVwb3NpdG9yeSxcbiAgZ2V0RGVwZW5kZW5jaWVzLFxuICBnZXREZXBlbmRlbmN5TmFtZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1ldGFKU09OTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBmaWxlTmFtZUZyb21GaWxlUGF0aCB9IGZyb20gXCIuLi91dGlsaXRpZXMvbmFtZVwiO1xuaW1wb3J0IHsgVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSwgU1lNQk9MX1ZPQ0FCVUxBUllfRklMRV9OQU1FIH0gZnJvbSBcIi4uL2ZpbGVOYW1lc1wiO1xuXG5mdW5jdGlvbiBnZXRWb2NhYnVsYXJ5KHZvY2FidWxhcnlGaWxlTmFtZSkge1xuICBsZXQgdm9jYWJ1bGFyeSA9IEVNUFRZX1NUUklORztcblxuICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzID0gdGhpcy5nZXRDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzKCksXG4gICAgICAgIGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZSA9IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMuZmluZCgoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZVBhdGggPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUuZ2V0UGF0aCgpLFxuICAgICAgICAgICAgICBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVOYW1lID0gZmlsZU5hbWVGcm9tRmlsZVBhdGgoY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlUGF0aCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZU5hbWUgPT09IHZvY2FidWxhcnlGaWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSB8fCBudWxsO1xuXG4gIGlmIChjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVDb250ZW50ID0gY3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlLmdldENvbnRlbnQoKTtcblxuICAgIHZvY2FidWxhcnkgPSBjdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVDb250ZW50OyAgLy8vXG4gIH1cblxuICByZXR1cm4gdm9jYWJ1bGFyeTtcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZVZvY2FidWxhcnkoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gVFlQRV9WT0NBQlVMQVJZX0ZJTEVfTkFNRSwgLy8vXG4gICAgICAgIHZvY2FidWxhcnkgPSB0aGlzLmdldFZvY2FidWxhcnkoZmlsZU5hbWUpLFxuICAgICAgICB0eXBlVm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7ICAvLy9cblxuICByZXR1cm4gdHlwZVZvY2FidWxhcnk7XG59XG5cbmZ1bmN0aW9uIGdldFN5bWJvbFZvY2FidWxhcnkoKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gU1lNQk9MX1ZPQ0FCVUxBUllfRklMRV9OQU1FLCAvLy9cbiAgICAgICAgdm9jYWJ1bGFyeSA9IHRoaXMuZ2V0Vm9jYWJ1bGFyeShmaWxlTmFtZSksXG4gICAgICAgIHN5bWJvbFZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5OyAgLy8vXG5cbiAgcmV0dXJuIHN5bWJvbFZvY2FidWxhcnk7XG59XG5cbmNvbnN0IHZvY2FidWxhcnlNaXhpbnMgPSAge1xuICBnZXRWb2NhYnVsYXJ5LFxuICBnZXRUeXBlVm9jYWJ1bGFyeSxcbiAgZ2V0U3ltYm9sVm9jYWJ1bGFyeVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdm9jYWJ1bGFyeU1peGlucztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGF0aFV0aWxpdGllcywgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBGaWxlIGZyb20gXCIuL2ZpbGVcIjtcbmltcG9ydCBGaWxlcyBmcm9tIFwiLi9maWxlc1wiO1xuaW1wb3J0IERpcmVjdG9yeSBmcm9tIFwiLi9kaXJlY3RvcnlcIjtcbmltcG9ydCBibmZNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL2JuZlwiO1xuaW1wb3J0IGZpbGVzTWl4aW5zIGZyb20gXCIuL21peGlucy9maWxlc1wiO1xuaW1wb3J0IG1ldGFKU09OTWl4aW5zIGZyb20gXCIuL21peGlucy9tZXRhSlNPTlwiO1xuaW1wb3J0IHZvY2FidWxhcnlNaXhpbnMgZnJvbSBcIi4vbWl4aW5zL3ZvY2FidWxhcnlcIjtcblxuY29uc3QgeyBmaXJzdCwgZmlsdGVyIH0gPSBhcnJheVV0aWxpdGllcyxcbiAgICAgIHsgdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aCB9ID0gcGF0aFV0aWxpdGllcztcblxuY2xhc3MgRW50cmllcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRUb3Btb3N0RGlyZWN0b3J5TmFtZSgpIHtcbiAgICBsZXQgdG9wbW9zdERpcmVjdG9yeU5hbWUgPSBudWxsO1xuICAgIFxuICAgIGNvbnN0IGZpcnN0RW50cnkgPSBmaXJzdCh0aGlzLmFycmF5KTsgLy8vXG5cbiAgICBpZiAoZmlyc3RFbnRyeSkgeyAvLy9cbiAgICAgIGNvbnN0IGZpcnN0RW50cnlQYXRoID0gZmlyc3RFbnRyeS5nZXRQYXRoKCk7XG5cbiAgICAgIHRvcG1vc3REaXJlY3RvcnlOYW1lID0gdG9wbW9zdERpcmVjdG9yeU5hbWVGcm9tUGF0aChmaXJzdEVudHJ5UGF0aCk7XG5cbiAgICAgIGlmICh0b3Btb3N0RGlyZWN0b3J5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICB0b3Btb3N0RGlyZWN0b3J5TmFtZSA9IGZpcnN0RW50cnlQYXRoOyAgLy8vXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvcG1vc3REaXJlY3RvcnlOYW1lO1xuICB9XG5cbiAgcmVtb3ZlRmlsZUJ5UGF0aChwYXRoKSB7XG4gICAgZmlsdGVyKHRoaXMuYXJyYXksIChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgZW50cnlGaWxlID0gZW50cnkuaXNGaWxlKCk7XG5cbiAgICAgIGlmIChlbnRyeUZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGVudHJ5LCAvLy9cbiAgICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKTtcblxuICAgICAgICBpZiAoZmlsZVBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBmaW5kRmlsZShmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpLFxuICAgICAgICAgIGZpbGUgPSBmaWxlcy5maW5kRmlsZSgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGhNYXRjaGVzID0gZmlsZS5tYXRjaEZpbGVQYXRoKGZpbGVQYXRoKTtcblxuICAgICAgICAgICAgaWYgKGZpbGVQYXRoTWF0Y2hlcykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICBnZXRGaWxlcygpIHtcbiAgICBjb25zdCBmaWxlcyA9IEZpbGVzLmZyb21Ob3RoaW5nKCk7XG5cbiAgICB0aGlzLm1hcEVudHJ5KChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgZW50cnlGaWxlID0gZW50cnkuaXNGaWxlKCk7XG5cbiAgICAgIGlmIChlbnRyeUZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGVudHJ5OyAvLy9cblxuICAgICAgICBmaWxlcy5hZGRGaWxlKGZpbGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbGVzO1xuICB9XG5cbiAgZ2V0RmlsZVBhdGhzKCkge1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IHRoaXMucmVkdWNlRW50cnkoKGZpbGVQYXRocywgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5RmlsZSA9IGVudHJ5LmlzRmlsZSgpO1xuXG4gICAgICBpZiAoZW50cnlGaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBlbnRyeSwgLy8vXG4gICAgICAgICAgICAgIGZpbGVQYXRoID0gZmlsZS5nZXRQYXRoKCk7XG5cbiAgICAgICAgZmlsZVBhdGhzLnB1c2goZmlsZVBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsZVBhdGhzO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBmaWxlUGF0aHM7XG4gIH1cblxuICBnZXREaXJlY3RvcnlQYXRocygpIHtcbiAgICBjb25zdCBkaXJlY3RvcnlQYXRocyA9IHRoaXMucmVkdWNlRW50cnkoKGRpcmVjdG9yeVBhdGhzLCBlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgZW50cnlEaXJlY3RvcnkgPSBlbnRyeS5pc0RpcmVjdG9yeSgpO1xuXG4gICAgICBpZiAoZW50cnlEaXJlY3RvcnkpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0gZW50cnksIC8vL1xuICAgICAgICAgICAgICBkaXJlY3RvcnlQYXRoID0gZGlyZWN0b3J5LmdldFBhdGgoKTtcblxuICAgICAgICBkaXJlY3RvcnlQYXRocy5wdXNoKGRpcmVjdG9yeVBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0b3J5UGF0aHM7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIGRpcmVjdG9yeVBhdGhzO1xuICB9XG5cbiAgbWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5nZXRWZXJzaW9uKCksXG4gICAgICAgICAgdmVyc2lvbk1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uID0gdmVyc2lvbi5tYXRjaFNob3J0ZW5lZFZlcnNpb24oc2hvcnRlbmVkVmVyc2lvbik7XG5cbiAgICByZXR1cm4gdmVyc2lvbk1hdGNoZXNTaG9ydGVuZWRWZXJzaW9uO1xuICB9XG5cbiAgYWRkRmlsZShmaWxlKSB7XG4gICAgY29uc3QgZW50cnkgPSBmaWxlOyAvLy9cblxuICAgIHRoaXMuYWRkRW50cnkoZW50cnkpO1xuICB9XG5cbiAgYWRkRW50cnkoZW50cnkpIHsgdGhpcy5hcnJheS5wdXNoKGVudHJ5KTsgfVxuXG4gIGFkZERpcmVjdG9yeShkaXJlY3RvcnkpIHtcbiAgICBjb25zdCBlbnRyeSA9IGRpcmVjdG9yeTsgIC8vL1xuXG4gICAgdGhpcy5hZGRFbnRyeShlbnRyeSk7XG4gIH1cblxuICBmb3JFYWNoRmlsZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRGaWxlcygpO1xuXG4gICAgZmlsZXMuZm9yRWFjaEZpbGUoY2FsbGJhY2spO1xuICB9XG5cbiAgbWFwRW50cnkoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkubWFwKGNhbGxiYWNrKTsgfVxuXG4gIHNvbWVFbnRyeShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5zb21lKGNhbGxiYWNrKTsgfVxuXG4gIGV2ZXJ5RW50cnkoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuZXZlcnkoY2FsbGJhY2spOyB9XG5cbiAgZm9yRWFjaEVudHJ5KGNhbGxiYWNrKSB7IHRoaXMuYXJyYXkuZm9yRWFjaChjYWxsYmFjayk7IH1cblxuICByZWR1Y2VFbnRyeShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7IHJldHVybiB0aGlzLmFycmF5LnJlZHVjZShjYWxsYmFjaywgaW5pdGlhbFZhbHVlKTsgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlbnRyaWVzSlNPTiA9IHRoaXMuYXJyYXkubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cnlKU09OID0gZW50cnkudG9KU09OKCk7XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5SlNPTjtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBqc29uID0gZW50cmllc0pTT047IC8vL1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBFbnRyaWVzKGFycmF5KSxcbiAgICAgICAgICBlbnRyaWVzSlNPTiA9IGpzb247IC8vL1xuXG4gICAgZW50cmllc0pTT04ubWFwKChlbnRyeUpTT04pID0+IHtcbiAgICAgIGNvbnN0IGpzb24gPSBlbnRyeUpTT04sIC8vL1xuICAgICAgICAgICAgZmlsZSA9IEZpbGUuZnJvbUpTT04oanNvbiksXG4gICAgICAgICAgICBkaXJlY3RvcnkgPSBEaXJlY3RvcnkuZnJvbUpTT04oanNvbiksXG4gICAgICAgICAgICBlbnRyeSA9IGZpbGUgfHwgZGlyZWN0b3J5OyAgLy8vXG5cbiAgICAgIGVudHJpZXMuYWRkRW50cnkoZW50cnkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbUVudHJ5KGVudHJ5KSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXG4gICAgICAgICAgICBlbnRyeVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBFbnRyaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgZW50cmllcyA9IG5ldyBFbnRyaWVzKGFycmF5KTtcblxuICAgIHJldHVybiBlbnRyaWVzO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oRW50cmllcy5wcm90b3R5cGUsIGJuZk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCBmaWxlc01peGlucyk7XG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCBtZXRhSlNPTk1peGlucyk7XG5PYmplY3QuYXNzaWduKEVudHJpZXMucHJvdG90eXBlLCB2b2NhYnVsYXJ5TWl4aW5zKTtcblxuZXhwb3J0IGRlZmF1bHQgRW50cmllcztcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZm9yRWFjaEZpbGUoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuZW50cmllcy5mb3JFYWNoRmlsZShjYWxsYmFjayk7IH1cblxuZnVuY3Rpb24gZmluZEZpbGUoZmlsZVBhdGgpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5maW5kRmlsZShmaWxlUGF0aCk7IH1cblxuZnVuY3Rpb24gZ2V0Qk5GKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEJORigpOyB9XG5cbmZ1bmN0aW9uIGdldEZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEZpbGVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0VGVybUJORigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRUZXJtQk5GKCk7IH1cblxuZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRWZXJzaW9uKCk7IH1cblxuZnVuY3Rpb24gZ2V0RmlsZVBhdGhzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEZpbGVQYXRocygpOyB9XG5cbmZ1bmN0aW9uIGdldFZvY2FidWxhcnkoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0Vm9jYWJ1bGFyeSgpOyB9XG5cbmZ1bmN0aW9uIGdldFJlcG9zaXRvcnkoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0UmVwb3NpdG9yeSgpOyB9XG5cbmZ1bmN0aW9uIGdldFJlYWRtZUZpbGUoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0UmVhZG1lRmlsZSgpOyB9XG5cbmZ1bmN0aW9uIGdldFN0YXRlbWVudEJORigpIHsgcmV0dXJuIHRoaXMuZW50cmllcy5nZXRTdGF0ZW1lbnRCTkYoKTsgfVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGVwZW5kZW5jaWVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0VHlwZVZvY2FidWxhcnkoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0VHlwZVZvY2FidWxhcnkoKTsgfVxuXG5mdW5jdGlvbiBnZXRTeW1ib2xWb2NhYnVsYXJ5KCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldFN5bWJvbFZvY2FidWxhcnkoKTsgfVxuXG5mdW5jdGlvbiBnZXRNZXRhSlNPTkZpbGUoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0TWV0YUpTT05GaWxlKCk7IH1cblxuZnVuY3Rpb24gZ2V0RnVydGxlRmlsZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RnVydGxlRmlsZXMoKTsgfVxuXG5mdW5jdGlvbiBnZXROb21pbmFsRmlsZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0Tm9taW5hbEZpbGVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0b3J5UGF0aHMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGlyZWN0b3J5UGF0aHMoKTsgfVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5TmFtZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0RGVwZW5kZW5jeU5hbWVzKCk7IH1cblxuZnVuY3Rpb24gZ2V0Q3VzdG9tR3JhbW1hckJORkZpbGVzKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzLmdldEN1c3RvbUdyYW1tYXJCTkZGaWxlcygpOyB9XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUdyYW1tYXJWb2NhYnVsYXJ5RmlsZXMoKSB7IHJldHVybiB0aGlzLmVudHJpZXMuZ2V0Q3VzdG9tR3JhbW1hclZvY2FidWxhcnlGaWxlcygpOyB9XG5cbmNvbnN0IGVudHJpZXNNaXhpbnMgPSB7XG4gIGZvckVhY2hGaWxlLFxuICBmaW5kRmlsZSxcbiAgZ2V0Qk5GLFxuICBnZXRGaWxlcyxcbiAgZ2V0VGVybUJORixcbiAgZ2V0VmVyc2lvbixcbiAgZ2V0RmlsZVBhdGhzLFxuICBnZXRWb2NhYnVsYXJ5LFxuICBnZXRSZXBvc2l0b3J5LFxuICBnZXRSZWFkbWVGaWxlLFxuICBnZXRTdGF0ZW1lbnRCTkYsXG4gIGdldERlcGVuZGVuY2llcyxcbiAgZ2V0VHlwZVZvY2FidWxhcnksXG4gIGdldFN5bWJvbFZvY2FidWxhcnksXG4gIGdldE1ldGFKU09ORmlsZSxcbiAgZ2V0RnVydGxlRmlsZXMsXG4gIGdldE5vbWluYWxGaWxlcyxcbiAgZ2V0RGlyZWN0b3J5UGF0aHMsXG4gIGdldERlcGVuZGVuY3lOYW1lcyxcbiAgZ2V0Q3VzdG9tR3JhbW1hckJORkZpbGVzLFxuICBnZXRDdXN0b21HcmFtbWFyVm9jYWJ1bGFyeUZpbGVzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBlbnRyaWVzTWl4aW5zO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5pbXBvcnQgZW50cmllc01peGlucyBmcm9tIFwiLi9taXhpbnMvZW50cmllc1wiO1xuXG5jbGFzcyBQcm9qZWN0IHtcbiAgY29uc3RydWN0b3IobmFtZSwgZW50cmllcykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBlbnRyaWVzSlNPTiA9IHRoaXMuZW50cmllcy50b0pTT04oKSxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lLFxuICAgICAgICAgIGVudHJpZXMgPSBlbnRyaWVzSlNPTiwgIC8vL1xuICAgICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZW50cmllc1xuICAgICAgICAgIH07XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgbGV0IHsgZW50cmllcyB9ID0ganNvbjtcblxuICAgIGNvbnN0IHsgbmFtZSB9ID0ganNvbixcbiAgICAgICAgICBlbnRyaWVzSlNPTiA9IGVudHJpZXM7ICAvLy9cblxuICAgIGpzb24gPSBlbnRyaWVzSlNPTjsgLy8vXG5cbiAgICBlbnRyaWVzID0gRW50cmllcy5mcm9tSlNPTihqc29uKTsgLy8vXG5cbiAgICBjb25zdCBwcm9qZWN0ID0gbmV3IFByb2plY3QobmFtZSwgZW50cmllcyk7XG5cbiAgICByZXR1cm4gcHJvamVjdDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgY29uc3QgZW50cmllcyA9IEVudHJpZXMuZnJvbU5vdGhpbmcoKSxcbiAgICAgICAgICBwcm9qZWN0ID0gbmV3IFByb2plY3QobmFtZSwgZW50cmllcyk7XG5cbiAgICByZXR1cm4gcHJvamVjdDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTmFtZUFuZEVudHJpZXMobmFtZSwgZW50cmllcykge1xuICAgIGNvbnN0IHByb2plY3QgPSBuZXcgUHJvamVjdChuYW1lLCBlbnRyaWVzKTtcblxuICAgIHJldHVybiBwcm9qZWN0O1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oUHJvamVjdC5wcm90b3R5cGUsIGVudHJpZXNNaXhpbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRmlsZSBmcm9tIFwiLi9maWxlXCI7XG5pbXBvcnQgRW50cmllcyBmcm9tIFwiLi9lbnRyaWVzXCI7XG5pbXBvcnQgZW50cmllc01peGlucyBmcm9tIFwiLi9taXhpbnMvZW50cmllc1wiO1xuXG5pbXBvcnQgeyBET1VCTEVfU1BBQ0UgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGlzTWV0YUpTT05GaWxlVmFsaWQgfSBmcm9tIFwiLi91dGlsaXRpZXMvbWV0YUpTT05cIjtcbmltcG9ydCB7IGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGggfSBmcm9tIFwiLi91dGlsaXRpZXMvZmlsZVBhdGhcIjtcbmltcG9ydCB7IHJlYWRtZUZpbGVGcm9tRmlsZXMsIG1ldGFKU09ORmlsZUZyb21GaWxlcyB9IGZyb20gXCIuL3V0aWxpdGllcy9maWxlc1wiO1xuXG5jbGFzcyBSZWxlYXNlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgZW50cmllcykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcztcbiAgfVxuXG4gIHVwZGF0ZVZlcnNpb24odmVyc2lvbikge1xuICAgIGxldCByZXBvc2l0b3J5ID0gdGhpcy5nZXRSZXBvc2l0b3J5KCksXG4gICAgICAgIGRlcGVuZGVuY2llcyA9IHRoaXMuZ2V0RGVwZW5kZW5jaWVzKCk7XG5cbiAgICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAgIHJlcG9zaXRvcnlKU09OID0gcmVwb3NpdG9yeSwgIC8vL1xuICAgICAgICAgIGRlcGVuZGVuY2llc0pTT04gPSBkZXBlbmRlbmNpZXMudG9KU09OKCk7XG5cbiAgICB2ZXJzaW9uID0gdmVyc2lvblN0cmluZzsgIC8vL1xuICAgIHJlcG9zaXRvcnkgPSByZXBvc2l0b3J5SlNPTjsgIC8vL1xuICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc0pTT047ICAvLy9cblxuICAgIGNvbnN0IG1ldGFKU09ORmlsZSA9IHRoaXMuZ2V0TWV0YUpTT05GaWxlKCksXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICByZXBvc2l0b3J5LFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgRE9VQkxFX1NQQUNFKSxcbiAgICAgICAgICBmaWxlID0gbWV0YUpTT05GaWxlLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IGpzb25TdHJpbmc7IC8vL1xuXG4gICAgZmlsZS5zZXRDb250ZW50KGNvbnRlbnQpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGVudHJpZXNKU09OID0gdGhpcy5lbnRyaWVzLnRvSlNPTigpLFxuICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgICAgZW50cmllcyA9IGVudHJpZXNKU09OLCAgLy8vXG4gICAgICAgICAganNvbiA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlbnRyaWVzXG4gICAgICAgICAgfTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICBsZXQgeyBlbnRyaWVzIH0gPSBqc29uO1xuXG4gICAgY29uc3QgeyBuYW1lIH0gPSBqc29uLFxuICAgICAgICAgIGVudHJpZXNKU09OID0gZW50cmllczsgIC8vL1xuXG4gICAganNvbiA9IGVudHJpZXNKU09OOyAvLy9cblxuICAgIGVudHJpZXMgPSBFbnRyaWVzLmZyb21KU09OKGpzb24pOyAvLy9cblxuICAgIGNvbnN0IHJlbGVhc2UgPSBuZXcgUmVsZWFzZShuYW1lLCBlbnRyaWVzKTtcblxuICAgIHJldHVybiByZWxlYXNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21Qcm9qZWN0KHByb2plY3QpIHtcbiAgICBsZXQgcmVsZWFzZSA9IG51bGwsXG4gICAgICAgIGVudHJpZXMgPSBwcm9qZWN0LmdldEVudHJpZXMoKTtcblxuICAgIGNvbnN0IGVudHJpZXNSZWxlYXNhYmxlID0gYXJlRW50cmllc1JlbGVhc2FibGUoZW50cmllcyk7XG5cbiAgICBpZiAoZW50cmllc1JlbGVhc2FibGUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwcm9qZWN0LmdldE5hbWUoKSxcbiAgICAgICAgICAgIHJlbGVhc2VkRW50cmllcyA9IHJlbGVhc2VFbnRyaWVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgICAgIGVudHJpZXMgPSByZWxlYXNlZEVudHJpZXM7ICAvLy9cblxuICAgICAgcmVsZWFzZSA9IG5ldyBSZWxlYXNlKG5hbWUsIGVudHJpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWxlYXNlO1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKSB7XG4gICAgbGV0IHJlbGVhc2UgPSBudWxsO1xuXG4gICAgY29uc3QgZW50cmllc1JlbGVhc2FibGUgPSBhcmVFbnRyaWVzUmVsZWFzYWJsZShlbnRyaWVzKTtcblxuICAgIGlmIChlbnRyaWVzUmVsZWFzYWJsZSkge1xuICAgICAgcmVsZWFzZSA9IG5ldyBSZWxlYXNlKG5hbWUsIGVudHJpZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWxlYXNlO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oUmVsZWFzZS5wcm90b3R5cGUsIGVudHJpZXNNaXhpbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBSZWxlYXNlO1xuXG5mdW5jdGlvbiByZWxlYXNlRW50cmllc0Zyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgY29uc3QgcmVsZWFzZWRFbnRyaWVzID0gRW50cmllcy5mcm9tTm90aGluZygpLCAgLy8vXG4gICAgICAgIGZpbGVzID0gZW50cmllcy5nZXRGaWxlcygpO1xuXG4gIGZpbGVzLmZvckVhY2hGaWxlKChmaWxlKSA9PiB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBmaWxlLmdldFBhdGgoKSxcbiAgICAgICAgICBmaWxlUGF0aFJlbGVhc2VGaWxlUGF0aCA9IGlzRmlsZVBhdGhSZWxlYXNlRmlsZVBhdGgoZmlsZVBhdGgpO1xuXG4gICAgaWYgKGZpbGVQYXRoUmVsZWFzZUZpbGVQYXRoKSB7XG4gICAgICBjb25zdCBwYXRoID0gZmlsZVBhdGgsICAvLy9cbiAgICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKSxcbiAgICAgICAgICAgIHJlbGVhc2VkID0gdHJ1ZTtcblxuICAgICAgZmlsZSA9IEZpbGUuZnJvbVBhdGhDb250ZW50QW5kUmVsZWFzZWQocGF0aCwgY29udGVudCwgcmVsZWFzZWQpOyAgLy8vXG5cbiAgICAgIHJlbGVhc2VkRW50cmllcy5hZGRGaWxlKGZpbGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlbGVhc2VkRW50cmllcztcbn1cblxuZnVuY3Rpb24gYXJlRW50cmllc1JlbGVhc2FibGUoZW50cmllcykge1xuICBsZXQgZW50cmllc1JlbGVhc2FibGUgPSBmYWxzZTtcblxuICBjb25zdCBmaWxlcyA9IGVudHJpZXMuZ2V0RmlsZXMoKSxcbiAgICAgICAgcmVhZG1lRmlsZSA9IHJlYWRtZUZpbGVGcm9tRmlsZXMoZmlsZXMpLFxuICAgICAgICBtZXRhSlNPTkZpbGUgPSBtZXRhSlNPTkZpbGVGcm9tRmlsZXMoZmlsZXMpO1xuXG4gIGlmICgocmVhZG1lRmlsZSAhPT0gbnVsbCkgJiYgKG1ldGFKU09ORmlsZSAhPT0gbnVsbCkpIHtcbiAgICBjb25zdCBtZXRhSlNPTkZpbGVWYWxpZCA9IGlzTWV0YUpTT05GaWxlVmFsaWQobWV0YUpTT05GaWxlKTtcblxuICAgIGlmIChtZXRhSlNPTkZpbGVWYWxpZCkge1xuICAgICAgZW50cmllc1JlbGVhc2FibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbnRyaWVzUmVsZWFzYWJsZTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUHJvamVjdCBmcm9tIFwiLi9wcm9qZWN0XCI7XG5cbmNvbnN0IHsgZm9yRWFjaCB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0cyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7IHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDsgfVxuXG4gIGFkZFByb2plY3QocHJvamVjdCkgeyB0aGlzLmFycmF5LnB1c2gocHJvamVjdCk7IH1cblxuICBtYXBQcm9qZWN0KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICByZWR1Y2VQcm9qZWN0KGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHsgcmV0dXJuIHRoaXMuYXJyYXkucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbiAgZm9yRWFjaFByb2plY3QoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGFzeW5jaHJvbm91c0ZvckVhY2hQcm9qZWN0KGNhbGxiYWNrLCBkb25lKSB7IGZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2ssIGRvbmUpOyB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmFycmF5Lm1hcCgocHJvamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHJvamVjdEpTT04gPSBwcm9qZWN0LnRvSlNPTigpO1xuXG4gICAgICByZXR1cm4gcHJvamVjdEpTT047XG4gICAgfSk7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgYXJyYXkgPSBqc29uLm1hcCgoanNvbikgPT4geyAgLy8vXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gUHJvamVjdC5mcm9tSlNPTihqc29uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJvamVjdHMgPSBuZXcgUHJvamVjdHMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHByb2plY3RzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgcHJvamVjdHMgPSBuZXcgUHJvamVjdHMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHByb2plY3RzO1xuICB9XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgUmVsZWFzZSBmcm9tIFwiLi9yZWxlYXNlXCI7XG5cbmNvbnN0IHsgZm9yRWFjaCB9ID0gYXN5bmNocm9ub3VzVXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxlYXNlcyB7XG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7IHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDsgfVxuXG4gIGFkZFJlbGVhc2UocmVsZWFzZSkgeyB0aGlzLmFycmF5LnB1c2gocmVsZWFzZSk7IH1cblxuICBtYXBSZWxlYXNlKGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5Lm1hcChjYWxsYmFjayk7IH1cblxuICByZWR1Y2VSZWxlYXNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHsgcmV0dXJuIHRoaXMuYXJyYXkucmVkdWNlKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpOyB9XG5cbiAgZm9yRWFjaFJlbGVhc2UoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGFzeW5jaHJvbm91c0ZvckVhY2hSZWxlYXNlKGNhbGxiYWNrLCBkb25lKSB7IGZvckVhY2godGhpcy5hcnJheSwgY2FsbGJhY2ssIGRvbmUpOyB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmFycmF5Lm1hcCgocmVsZWFzZSkgPT4ge1xuICAgICAgY29uc3QgcmVsZWFzZUpTT04gPSByZWxlYXNlLnRvSlNPTigpO1xuXG4gICAgICByZXR1cm4gcmVsZWFzZUpTT047XG4gICAgfSk7XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgY29uc3QgYXJyYXkgPSBqc29uLm1hcCgoanNvbikgPT4geyAgLy8vXG4gICAgICAgICAgICBjb25zdCByZWxlYXNlID0gUmVsZWFzZS5mcm9tSlNPTihqc29uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2U7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgcmVsZWFzZXMgPSBuZXcgUmVsZWFzZXMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHJlbGVhc2VzO1xuICB9XG5cbiAgc3RhdGljIGZyb21Ob3RoaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW10sXG4gICAgICAgICAgcmVsZWFzZXMgPSBuZXcgUmVsZWFzZXMoYXJyYXkpO1xuXG4gICAgcmV0dXJuIHJlbGVhc2VzO1xuICB9XG59XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlIH0gZnJvbSBcIi4vZmlsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlcyB9IGZyb20gXCIuL2ZpbGVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFZlcnNpb24gfSBmcm9tIFwiLi92ZXJzaW9uXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVudHJpZXMgfSBmcm9tIFwiLi9lbnRyaWVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2plY3QgfSBmcm9tIFwiLi9wcm9qZWN0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlbGVhc2UgfSBmcm9tIFwiLi9yZWxlYXNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2plY3RzIH0gZnJvbSBcIi4vcHJvamVjdHNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVsZWFzZXMgfSBmcm9tIFwiLi9yZWxlYXNlc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEaXJlY3RvcnkgfSBmcm9tIFwiLi9kaXJlY3RvcnlcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmlsZU5hbWVzIH0gZnJvbSBcIi4vZmlsZU5hbWVzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlcGVuZGVuY3kgfSBmcm9tIFwiLi9kZXBlbmRlbmN5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERlcGVuZGVuY2llcyB9IGZyb20gXCIuL2RlcGVuZGVuY2llc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaG9ydGVuZWRWZXJzaW9uIH0gZnJvbSBcIi4vc2hvcnRlbmVkVmVyc2lvblwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb250ZW50VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2NvbnRlbnRcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmlsZVBhdGhVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvZmlsZVBhdGhcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbWV0YUpTT05VdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvbWV0YUpTT05cIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRW50cmllcywgbWV0YUpTT05VdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbW9kZWxcIjtcblxuaW1wb3J0IFJlbGVhc2VDb250ZXh0IGZyb20gXCIuLi9jb250ZXh0L3JlbGVhc2VcIjtcblxuaW1wb3J0IHsgY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyB9IGZyb20gXCIuLi91dGlsaXRpZXMvY3VzdG9tR3JhbW1hclwiO1xuXG5jb25zdCB7IGlzTWV0YUpTT05GaWxlVmFsaWQgfSA9IG1ldGFKU09OVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVsZWFzZUNvbnRleHRGcm9tSlNPTihqc29uLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgbG9nLCBjYWxsYmFjayB9ID0gY29udGV4dCxcbiAgICAgICAgeyBuYW1lIH0gPSBqc29uO1xuXG4gICh7Y29udGV4dH0gPSBqc29uKTsgLy8vXG5cbiAgbGV0IHsgZW50cmllcyB9ID0ganNvbjtcblxuICBqc29uID0gZW50cmllczsgLy8vXG5cbiAgZW50cmllcyA9IEVudHJpZXMuZnJvbUpTT04oanNvbik7XG5cbiAgY29uc3QgY29udGV4dEpTT04gPSBjb250ZXh0OyAgLy8vXG5cbiAganNvbiA9IGNvbnRleHRKU09OOyAvLy9cblxuICBjb25zdCBjdXN0b21HcmFtbWFyID0gY3VzdG9tR3JhbW1hckZyb21OYW1lQW5kRW50cmllcyhuYW1lLCBlbnRyaWVzKSxcbiAgICAgICAgcmVsZWFzZUNvbnRleHQgPSBSZWxlYXNlQ29udGV4dC5mcm9tTG9nTmFtZUpTT05FbnRyaWVzQ2FsbGJhY2tBbmRDdXN0b21HcmFtbWFyKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIpO1xuXG4gIHJldHVybiByZWxlYXNlQ29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VDb250ZXh0RnJvbVByb2plY3QocHJvamVjdCwgY29udGV4dCkge1xuICBsZXQgcmVsZWFzZUNvbnRleHQgPSBudWxsO1xuXG4gIGlmIChwcm9qZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgbWV0YUpTT05GaWxlID0gcHJvamVjdC5nZXRNZXRhSlNPTkZpbGUoKTtcblxuICAgIGlmIChtZXRhSlNPTkZpbGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1ldGFKU09ORmlsZVZhbGlkID0gaXNNZXRhSlNPTkZpbGVWYWxpZChtZXRhSlNPTkZpbGUpO1xuXG4gICAgICBpZiAobWV0YUpTT05GaWxlVmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBsb2csIGNhbGxiYWNrIH0gPSBjb250ZXh0LFxuICAgICAgICAgICAgICBuYW1lID0gcHJvamVjdC5nZXROYW1lKCksXG4gICAgICAgICAgICAgIGpzb24gPSBudWxsLFxuICAgICAgICAgICAgICBlbnRyaWVzID0gcHJvamVjdC5nZXRFbnRyaWVzKCksXG4gICAgICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBjdXN0b21HcmFtbWFyRnJvbU5hbWVBbmRFbnRyaWVzKG5hbWUsIGVudHJpZXMpO1xuXG4gICAgICAgIHJlbGVhc2VDb250ZXh0ID0gUmVsZWFzZUNvbnRleHQuZnJvbUxvZ05hbWVKU09ORW50cmllc0NhbGxiYWNrQW5kQ3VzdG9tR3JhbW1hcihsb2csIG5hbWUsIGpzb24sIGVudHJpZXMsIGNhbGxiYWNrLCBjdXN0b21HcmFtbWFyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVsZWFzZUNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxlYXNlQ29udGV4dEZyb21SZWxlYXNlKHJlbGVhc2UsIGNvbnRleHQpIHtcbiAgbGV0IHJlbGVhc2VDb250ZXh0ID0gbnVsbDtcblxuICBpZiAocmVsZWFzZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHsgbG9nLCBjYWxsYmFjayB9ID0gY29udGV4dCxcbiAgICAgICAgICBuYW1lID0gcmVsZWFzZS5nZXROYW1lKCksXG4gICAgICAgICAganNvbiA9IG51bGwsXG4gICAgICAgICAgZW50cmllcyA9IHJlbGVhc2UuZ2V0RW50cmllcygpLFxuICAgICAgICAgIGN1c3RvbUdyYW1tYXIgPSBjdXN0b21HcmFtbWFyRnJvbU5hbWVBbmRFbnRyaWVzKG5hbWUsIGVudHJpZXMpO1xuXG4gICAgcmVsZWFzZUNvbnRleHQgPSBSZWxlYXNlQ29udGV4dC5mcm9tTG9nTmFtZUpTT05FbnRyaWVzQ2FsbGJhY2tBbmRDdXN0b21HcmFtbWFyKGxvZywgbmFtZSwganNvbiwgZW50cmllcywgY2FsbGJhY2ssIGN1c3RvbUdyYW1tYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlbGVhc2VDb250ZXh0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlbGVhc2VDb250ZXh0RnJvbUpTT04sXG4gIHJlbGVhc2VDb250ZXh0RnJvbVByb2plY3QsXG4gIHJlbGVhc2VDb250ZXh0RnJvbVJlbGVhc2Vcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9nIH0gZnJvbSBcIi4vbG9nXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZW1lbnQgfSBmcm9tIFwiLi9lbGVtZW50XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbnRleHQgfSBmcm9tIFwiLi9jb250ZXh0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGVDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9maWxlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlbGVhc2VDb250ZXh0IH0gZnJvbSBcIi4vY29udGV4dC9yZWxlYXNlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCIuL25vblRlcm1pbmFsTm9kZVwiO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIFppcFBhc3MgfSBmcm9tIFwiLi9wYXNzL3ppcFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBc3luY1Bhc3MgfSBmcm9tIFwiLi9wYXNzL2FzeW5jXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbXBsZVBhc3MgfSBmcm9tIFwiLi9wYXNzL3NpbXBsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3J3YXJkUGFzcyB9IGZyb20gXCIuL3Bhc3MvZm9yd2FyZFwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFcXVpdmFsZW5jZVBhc3MgfSBmcm9tIFwiLi9wYXNzL2VxdWl2YWxlbmNlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgbm9kZVV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9ub2RlXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHF1ZXJ5VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbGVDb250ZXh0VXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2ZpbGVDb250ZXh0XCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcmlmaWNhdGlvblV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy92ZXJpZmljYXRpb25cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2FzeW5jaHJvbm91c1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyByZWxlYXNlQ29udGV4dFV0aWxpdGllcyB9IGZyb20gXCIuL3V0aWxpdGllcy9yZWxlYXNlQ29udGV4dFwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBlbGVtZW50cyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lKEVsZW1lbnQpIHtcbiAgY29uc3QgeyBuYW1lIH0gPSBFbGVtZW50O1xuXG4gIGVsZW1lbnRzW25hbWVdID0gRWxlbWVudDtcblxuICByZXR1cm4gRWxlbWVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudHM7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgU3RlcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5QXNzaWdubWVudCwgb2JqZWN0QXNzaWdtZW50LCB2YXJpYWJsZXNzQXNzaWdubWVudCkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMuYXJyYXlBc3NpZ25tZW50ID0gYXJyYXlBc3NpZ25tZW50O1xuICAgIHRoaXMub2JqZWN0QXNzaWdtZW50ID0gb2JqZWN0QXNzaWdtZW50O1xuICAgIHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQgPSB2YXJpYWJsZXNzQXNzaWdubWVudDtcbiAgfVxuXG4gIGdldEFycmF5QXNzaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheUFzc2lnbm1lbnQ7XG4gIH1cblxuICBnZXRPYmplY3RBc3NpZ21lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0QXNzaWdtZW50O1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzc0Fzc2lnbm1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQ7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMuYXJyYXlBc3NpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFycmF5QXNzaWdubWVudC5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub2JqZWN0QXNzaWdtZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm9iamVjdEFzc2lnbWVudC5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIGF3YWl0IHRoaXMudmFyaWFibGVzc0Fzc2lnbm1lbnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlN0ZXBcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIGdldE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgZXhjZXB0aW9uID0gbmV3IEV4Y2VwdGlvbihtZXNzYWdlKTtcblxuICAgIHJldHVybiBleGNlcHRpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IE5PREVfVFlQRSA9IFwiTm9kZVwiO1xuZXhwb3J0IGNvbnN0IE5PREVTX1RZUEUgPSBcIk5vZGVzXCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX1RZUEUgPSBcIlN0cmluZ1wiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUl9UWVBFID0gXCJOdW1iZXJcIjtcbmV4cG9ydCBjb25zdCBCT09MRUFOX1RZUEUgPSBcIkJvb2xlYW5cIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuY2xhc3MgTnVsbE5vZGUge1xuICBzdGF0aWMgZnJvbU5vdGhpbmcoKSB7XG4gICAgY29uc3QgbnVsbE5vZGUgPSBuZXcgTnVsbE5vZGUoKTtcblxuICAgIHJldHVybiBudWxsTm9kZTtcbiAgfVxufVxuXG5jb25zdCBudWxsTm9kZSA9IE51bGxOb2RlLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBkZWZhdWx0IG51bGxOb2RlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgTlVMTCA9IFwibnVsbFwiO1xuZXhwb3J0IGNvbnN0IFRSVUUgPSBcInRydWVcIjtcbmV4cG9ydCBjb25zdCBGQUxTRSA9IFwiZmFsc2VcIjtcbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuZXhwb3J0IGNvbnN0IE5PVF9FUVVBTF9UTyA9IFwiIT1cIjtcbmV4cG9ydCBjb25zdCBDT05KVU5DVElPTl9PUEVSQVRPUiA9IFwiJiZcIjtcbmV4cG9ydCBjb25zdCBESVNKVU5DVElPTl9PUEVSQVRPUiA9IFwifHxcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCkge1xuICBjb25zdCBzdHJpbmcgPSBzdHJpbmdMaXRlcmFsLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdMaXRlcmFsRnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgY29uc3Qgc3RyaW5nTGl0ZXJhbCA9IGBcIiR7c3RyaW5nfVwiYDtcblxuICByZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IG51bGxOb2RlIGZyb20gXCIuLi9udWxsTm9kZVwiO1xuXG5pbXBvcnQgeyBOVUxMIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi9zdHJpbmdMaXRlcmFsXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJuYXJ5U3RyaW5nRnJvbVRlcm0odGVybSkge1xuICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgdGVybmFyeVN0cmluZyA9IGBpZiAoJHt0ZXJtU3RyaW5nfSkgeyAuLi4gfSBlbHNlIHsgLi4uIH1gO1xuXG4gIHJldHVybiB0ZXJuYXJ5U3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVTdHJpbmdGcm9tTmFtZShuYW1lKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gbmFtZTsgIC8vL1xuXG4gIHJldHVybiB2YXJpYWJsZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW10aXZlU3RyaW5nRnJvbU5vZGUobm9kZSwgY29udGV4dCkge1xuICBjb25zdCBwcmltdGl2ZVN0cmluZyA9IChub2RlID09PSBudWxsTm9kZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOVUxMIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKTtcblxuICByZXR1cm4gcHJpbXRpdmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltdGl2ZVN0cmluZ0Zyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCBzdHJpbmcgPSBjb250ZXh0Lm5vZGVzQXNTdHJpbmcobm9kZXMpLFxuICAgICAgICBwcmltdGl2ZVN0cmluZyA9IHN0cmluZzsgIC8vL1xuXG4gIHJldHVybiBwcmltdGl2ZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1TdHJpbmdGcm9tUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCB0ZXJtU3RyaW5nO1xuXG4gIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICBpZiAocHJvcGVydHkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5U3RyaW5nID0gcHJvcGVydHkuZ2V0U3RyaW5nKCk7XG5cbiAgICAgIHRlcm1TdHJpbmcgPSBwcm9wZXJ0eVN0cmluZzsgIC8vL1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRlcm1TdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltdGl2ZVN0cmluZ0Zyb21Cb29sZWFuKGJvb2xlYW4pIHtcbiAgY29uc3QgZXhwcmVzc3Npb25TdHJpbmcgPSBgJHtib29sZWFufWA7XG5cbiAgcmV0dXJuIGV4cHJlc3NzaW9uU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5KSB7XG4gIGNvbnN0IHRlcm1zU3RyaW5nID0gdGVybXNBcnJheS5yZWR1Y2UoKHRlcm1zU3RyaW5nLCB0ZXJtKSA9PiB7XG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICB0ZXJtc1N0cmluZyA9ICh0ZXJtc1N0cmluZyA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICB0ZXJtU3RyaW5nIDpcbiAgICAgICAgICAgICAgICAgICAgIGAke3Rlcm1zU3RyaW5nfSwgJHt0ZXJtU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gdGVybXNTdHJpbmc7XG4gIH0sIG51bGwpOyAvLy9cblxuICByZXR1cm4gdGVybXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uU3RyaW5nRnJvbVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICBsZXQgZXhwcmVzc2lvblN0cmluZztcblxuICBwcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgaWYgKHByb3BlcnR5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eVN0cmluZyA9IHByb3BlcnR5LmdldFN0cmluZygpO1xuXG4gICAgICBleHByZXNzaW9uU3RyaW5nID0gcHJvcGVydHlTdHJpbmc7ICAvLy9cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBleHByZXNzaW9uU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbXRpdmVTdHJpbmdGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsKSB7XG4gIGNvbnN0IHN0cmluZyA9IHN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwpLFxuICAgICAgICBwcmltdGl2ZVN0cmluZyA9IHN0cmluZzsgIC8vL1xuXG4gIHJldHVybiBwcmltdGl2ZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVQcm9wZXJ0eVN0cmluZ0Zyb21OYW1lQW5kVHlwZShuYW1lLCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVTdHJpbmcgPSB0eXBlLCAgLy8vXG4gICAgICAgIG5hbWVTdHJpbmcgPSBuYW1lLCAgLy8vXG4gICAgICAgIG5vZGVQcm9wZXJ0eVN0cmluZyA9IGAke3R5cGVTdHJpbmd9ICR7bmFtZVN0cmluZ31gO1xuXG4gIHJldHVybiBub2RlUHJvcGVydHlTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZ0Zyb21Qcm9jZWR1cmUocHJvY2VkdXJlKSB7XG4gIGNvbnN0IHR5cGUgPSBwcm9jZWR1cmUuZ2V0VHlwZSgpLFxuICAgICAgICBsYWJlbCA9IHByb2NlZHVyZS5nZXRMYWJlbCgpLFxuICAgICAgICBwYXJhbWV0ZXJzID0gcHJvY2VkdXJlLmdldFBhcmFtZXRlcnMoKSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50ID0gcHJvY2VkdXJlLmdldFJldHVyblN0YXRlbWVudCgpLFxuICAgICAgICBsYWJlbFN0cmluZyA9IGxhYmVsLmdldFN0cmluZygpLFxuICAgICAgICBwYXJhbWV0ZXJzU3RyaW5nID0gcGFyYW1ldGVycy5nZXRTdHJpbmcoKSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50U3RyaW5nID0gcmV0dXJuU3RhdGVtZW50LmdldFN0cmluZygpLFxuICAgICAgICBwcm9jZWR1cmVEZWxjYXJhdGlvblN0cmluZyA9IGAke3R5cGV9ICR7bGFiZWxTdHJpbmcgfSgke3BhcmFtZXRlcnNTdHJpbmd9KSB7IC4uLiAke3JldHVyblN0YXRlbWVudFN0cmluZ30gfWA7XG5cbiAgcmV0dXJuIHByb2NlZHVyZURlbGNhcmF0aW9uU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQmxvY2tTdHJpbmdGcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnQpIHtcbiAgY29uc3QgcmV0dXJuU3RhdGVtZW50U3RyaW5nID0gcmV0dXJuU3RhdGVtZW50LmdldFN0cmluZygpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IGB7IC4uLiAke3JldHVyblN0YXRlbWVudFN0cmluZ30gfWA7XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVByb3BlcnRpZXNTdHJpbmdGcm9tTm9kZVByb3BlcnRpZXNBcnJheShub2RlUHJvcGVydGllc0FycmF5KSB7XG4gIGNvbnN0IG5vZGVQcm9wZXJ0aWVzU3RyaW5nID0gbm9kZVByb3BlcnRpZXNBcnJheS5yZWR1Y2UoKG5vZGVQcm9wZXJ0aWVzU3RyaW5nLCBub2RlUHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVQcm9wZXJ0eVN0cmluZyA9IG5vZGVQcm9wZXJ0eS5nZXRTdHJpbmcoKTtcblxuICAgICAgbm9kZVByb3BlcnRpZXNTdHJpbmcgPSAobm9kZVByb3BlcnRpZXNTdHJpbmcgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlUHJvcGVydHlTdHJpbmcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtub2RlUHJvcGVydGllc1N0cmluZ30sICR7bm9kZVByb3BlcnR5U3RyaW5nfWA7XG5cbiAgICAgIHJldHVybiBub2RlUHJvcGVydGllc1N0cmluZztcbiAgICB9LCBudWxsKTtcblxuICByZXR1cm4gbm9kZVByb3BlcnRpZXNTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlKHR5cGUsIHZhcmlhYmxlKSB7XG4gIGNvbnN0IHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA9IGAke3R5cGV9ICR7dmFyaWFibGVTdHJpbmd9ID0gLi4uIDtgO1xuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb21lU3RyaW5nRnJvbVZhcmlhYmxlQW5kQW5vbnltb3VzUHJvY2VkdXJlKHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlLmdldFN0cmluZygpLFxuICAgICAgICBzb21lU3RyaW5nID0gYFNvbWUoJHt2YXJpYWJsZVN0cmluZ30sICR7YW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nfSkgYDtcblxuICByZXR1cm4gc29tZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZXJ5U3RyaW5nRnJvbVZhcmlhYmxlQW5kQW5vbnltb3VzUHJvY2VkdXJlKHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlLmdldFN0cmluZygpLFxuICAgICAgICBldmVyeVN0cmluZyA9IGBFdmVyeSgke3ZhcmlhYmxlU3RyaW5nfSwgJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9KSBgO1xuXG4gIHJldHVybiBldmVyeVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZ0Zyb21WYXJpYWJsZUFzc2lnbm1lbnQodmFyaWFibGVBc3NpZ25tZW50KSB7XG4gIGNvbnN0IHZhcmlhYmxlID0gdmFyaWFibGVBc3NpZ25tZW50LmdldFZhcmlhYmxlKCksXG4gICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGUuZ2V0U3RyaW5nKCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA9IGAke3ZhcmlhYmxlU3RyaW5nfSA9IC4uLmA7XG5cbiAgcmV0dXJuIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2NlZHVyZVN0cmluZ0Zyb21UeXBlTGFiZWxQYXJhbWV0ZXJzQW5kUmV0dXJuQmxvY2sodHlwZSwgbGFiZWwsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gIGNvbnN0IHR5cGVTdHJpbmcgPSB0eXBlLCAgLy8vXG4gICAgICAgIGxhYmVsU3RyaW5nID0gbGFiZWwuZ2V0U3RyaW5nKCksXG4gICAgICAgIHBhcmFtZXRlcnNTdHJpbmcgPSBwYXJhbWV0ZXJzLmdldFN0cmluZygpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IHJldHVybkJsb2NrLmdldFN0cmluZygpLFxuICAgICAgICBwcm9jZWR1cmVTdHJpbmcgPSBgJHt0eXBlU3RyaW5nfSAke2xhYmVsU3RyaW5nfSgke3BhcmFtZXRlcnNTdHJpbmd9KSAke3JldHVybkJsb2NrU3RyaW5nfWA7XG5cbiAgcmV0dXJuIHByb2NlZHVyZVN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFub255bW91c1Byb2NlZHVyZVN0cmluZ0Zyb21UeXBlUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrKHR5cGUsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gIGNvbnN0IHR5cGVTdHJpbmcgPSB0eXBlLCAgLy8vXG4gICAgICAgIHBhcmFtZXRlcnNTdHJpbmcgPSBwYXJhbWV0ZXJzLmdldFN0cmluZygpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IHJldHVybkJsb2NrLmdldFN0cmluZygpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmcgPSBgJHt0eXBlU3RyaW5nfSAoJHtwYXJhbWV0ZXJzU3RyaW5nfSkgJHtyZXR1cm5CbG9ja1N0cmluZ31gO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudHNBcnJheSh0eXBlLCB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkpIHtcbiAgbGV0IHZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkucmVkdWNlKCh2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nLCB2YXJpYWJsZUFzc2lnbm1lbnQpID0+IHtcbiAgICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVmFyaWFibGVBc3NpZ25tZW50KHZhcmlhYmxlQXNzaWdubWVudCk7XG5cbiAgICB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nID0gKHZhcmlhYmxlQXNzaWdubWVudHNTdHJpbmcgPT09IG51bGwpID9cbiAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA6XG4gICAgICBgJHt2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nfSwgJHt2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmd9YDtcblxuICAgIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nO1xuICB9LCBudWxsKTsgLy8vXG5cbiAgdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZyA9IGAke3R5cGV9ICR7dmFyaWFibGVBc3NpZ25tZW50c1N0cmluZ30gO2A7IC8vL1xuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlU3RyaW5nRnJvbVZhcmlhYmxlSW5pdGlhbEV4cHJlc3Npb25BbmRBbm9ueW1vdXNQcm9jZWR1cmUodmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgaW5pdGlhbEV4cHJlc3Npb25TdHJpbmcgPSBpbml0aWFsRXhwcmVzc2lvbi5nZXRTdHJpbmcoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlLmdldFN0cmluZygpLFxuICAgICAgICByZWR1Y2VTdHJpbmcgPSBgUmVkdWNlKCR7dmFyaWFibGVTdHJpbmd9LCAke2Fub255bW91c1Byb2NlZHVyZVN0cmluZ30sICR7aW5pdGlhbEV4cHJlc3Npb25TdHJpbmd9KWA7XG5cbiAgcmV0dXJuIHJlZHVjZVN0cmluZztcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmltcG9ydCB7IE5PREVfVFlQRSwgTk9ERVNfVFlQRSwgU1RSSU5HX1RZUEUsIEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgcHJpbXRpdmVTdHJpbmdGcm9tTm9kZSwgcHJpbXRpdmVTdHJpbmdGcm9tTm9kZXMsIHByaW10aXZlU3RyaW5nRnJvbUJvb2xlYW4sIHByaW10aXZlU3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbWl0aXZlRnJvbU5vZGUobm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFByaW1pdGl2ZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIHByaW1pdGl2ZVN0cmluZyA9IHByaW10aXZlU3RyaW5nRnJvbU5vZGUobm9kZSwgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZVN0cmluZywgIC8vL1xuICAgICAgICB0eXBlID0gTk9ERV9UWVBFLFxuICAgICAgICB2YWx1ZSA9IG5vZGU7IC8vL1xuXG4gIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCB7IFByaW1pdGl2ZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIHByaW1pdGl2ZVN0cmluZyA9IHByaW10aXZlU3RyaW5nRnJvbU5vZGVzKG5vZGVzLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlU3RyaW5nLCAgLy8vXG4gICAgICAgIHR5cGUgPSBOT0RFU19UWVBFLFxuICAgICAgICB2YWx1ZSA9IG5vZGVzLCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcmltaXRpdmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBwcmltaXRpdmVTdHJpbmcgPSBwcmltdGl2ZVN0cmluZ0Zyb21Cb29sZWFuKGJvb2xlYW4pLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmVTdHJpbmcsICAvLy9cbiAgICAgICAgdHlwZSA9IEJPT0xFQU5fVFlQRSxcbiAgICAgICAgdmFsdWUgPSBib29sZWFuLCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW1pdGl2ZUZyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcmltaXRpdmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBwcmltaXRpdmVTdHJpbmcgPSBwcmltdGl2ZVN0cmluZ0Zyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwpLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmVTdHJpbmcsICAvLy9cbiAgICAgICAgdHlwZSA9IFNUUklOR19UWVBFLFxuICAgICAgICB2YWx1ZSA9IHN0cmluZ0xpdGVyYWwsICAvLy9cbiAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcHJpbWl0aXZlID0gbmV3IFByaW1pdGl2ZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHZhbHVlKTtcblxuICByZXR1cm4gcHJpbWl0aXZlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByaW1pdGl2ZUZyb21Ob2RlLFxuICBwcmltaXRpdmVGcm9tTm9kZXMsXG4gIHByaW1pdGl2ZUZyb21Cb29sZWFuLFxuICBwcmltaXRpdmVGcm9tU3RyaW5nTGl0ZXJhbFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGVsZW1lbnRzIGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5pbXBvcnQgeyBwcmltaXRpdmVGcm9tTm9kZSwgcHJpbWl0aXZlRnJvbU5vZGVzLCBwcmltaXRpdmVGcm9tQm9vbGVhbiwgcHJpbWl0aXZlRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3ByaW1pdGl2ZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tTm9kZShub2RlLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpO1xuXG4gIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm0gPSBuZXcgVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICB2YXJpYWJsZSA9IG51bGwsXG4gICAgICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCksXG4gICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZS5nZXRTdHJpbmcoKSxcbiAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICB2YXJpYWJsZSA9IG51bGwsXG4gICAgICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSBwcmltaXRpdmUuZ2V0U3RyaW5nKCksXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm0gPSBuZXcgVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBwcmltaXRpdmUpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21TdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmVGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBjb250ZXh0KSxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICBub2RlID0gbnVsbDtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlKTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgICAgc3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICBub2RlID0gbnVsbCxcbiAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlKTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICB0ZXJtRnJvbU5vZGUsXG4gIHRlcm1Gcm9tTm9kZXMsXG4gIHRlcm1Gcm9tQm9vbGVhbixcbiAgdGVybUZyb21TdHJpbmdMaXRlcmFsLFxuICB0ZXJtRnJvbVByaW1pdGl2ZVxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCwgYXN5bmNocm9ub3VzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFU19UWVBFLCBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZSwgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmNvbnN0IHsgYXN5bmNTb21lIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBTb21lIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGFub255bW91c1Byb2NlZHVyZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0QW5vbnltb3VzUHJvY2VkdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmFub255bW91c1Byb2NlZHVyZTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGF3YWl0IHRoaXMuYnJlYWsoY29udGV4dCk7XG5cbiAgICBjb25zdCBzb21lU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3NvbWVTdHJpbmd9JyBzb21lLi4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IE5PREVTX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVTX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgbm9kZXMgPSBwcmltaXRpdmVWYWx1ZSwgLy8vXG4gICAgICAgICAgYm9vbGVhbiA9IGF3YWl0IGFzeW5jU29tZShub2RlcywgYXN5bmMgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXJtO1xuXG4gICAgICAgICAgICB0ZXJtID0gdGVybUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgIHRlcm1zID0gVGVybXMuZnJvbVRlcm0odGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLmFub255bW91c1Byb2NlZHVyZS5jYWxsKHRlcm1zLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgICAgICAgICAgaWYgKHRlcm1UeXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgdHlwZSBpcyAnJHt0ZXJtVHlwZX0nIHdoZW4gaXQgc2hvdWxkIGJlIG9mIHR5cGUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgICAgICAgICBib29sZWFuID0gcHJpbWl0aXZlVmFsdWU7IC8vL1xuXG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbjtcbiAgICAgICAgICB9KTtcblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYC4uLmV2YWx1YXRlZCB0aGUgJyR7c29tZVN0cmluZ30nIHNvbWUgYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiU29tZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBUZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSwgbmVnYXRlZFRlcm0sIGxvZ2ljYWxUZXJtLCBicmFja2V0ZWRUZXJtLCBjb21wYXJpc29uVGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICB0aGlzLm5lZ2F0ZWRUZXJtID0gbmVnYXRlZFRlcm07XG4gICAgdGhpcy5sb2dpY2FsVGVybSA9IGxvZ2ljYWxUZXJtO1xuICAgIHRoaXMuYnJhY2tldGVkVGVybSA9IGJyYWNrZXRlZFRlcm07XG4gICAgdGhpcy5jb21wYXJpc29uVGVybSA9IGNvbXBhcmlzb25UZXJtO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRQcmltaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlO1xuICB9XG5cbiAgZ2V0TmVnYXRlZFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRlZFRlcm07XG4gIH1cblxuICBnZXRMb2dpY2FsVGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dpY2FsVGVybTtcbiAgfVxuXG4gIGdldEJyZWVkaW5nVGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5icmFja2V0ZWRUZXJtO1xuICB9XG5cbiAgZ2V0Q29tcGFyaXNvblRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyaXNvblRlcm07XG4gIH1cblxuICBnZXRQcmltaXRpdmVWYWx1ZSgpIHtcbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRoaXMucHJpbWl0aXZlLmdldFZhbHVlKCk7XG5cbiAgICByZXR1cm4gcHJpbWl0aXZlVmFsdWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnZhcmlhYmxlLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJpbWl0aXZlICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5wcmltaXRpdmUuZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubmVnYXRlZFRlcm0uZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2dpY2FsVGVybSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubG9naWNhbFRlcm0uZ2V0VHlwZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5icmFja2V0ZWRUZXJtICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5icmFja2V0ZWRUZXJtLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29tcGFyaXNvblRlcm0gIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLmNvbXBhcmlzb25UZXJtLmdldFR5cGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGlzQm9vbGVhbigpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICAgICAgYm9vbGVhbiA9ICh0eXBlID09PSBCT09MRUFOX1RZUEUpO1xuXG4gICAgcmV0dXJuIGJvb2xlYW47XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy52YXJpYWJsZSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByaW1pdGl2ZSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMucHJpbWl0aXZlLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMubmVnYXRlZFRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvZ2ljYWxUZXJtICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gdGhpcy5sb2dpY2FsVGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnJhY2tldGVkVGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMuYnJhY2tldGVkVGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29tcGFyaXNvblRlcm0gIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLmNvbXBhcmlzb25UZXJtLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgaXNFcXVhbFRvKHRlcm0pIHtcbiAgICBsZXQgZXF1YWxUbyA9IGZhbHNlO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGVybS5nZXRWYXJpYWJsZSgpO1xuXG4gICAgICBpZiAodmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgZXF1YWxUbyA9IHRoaXMudmFyaWFibGUuaXNFcXVhbFRvKHZhcmlhYmxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJpbWl0aXZlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmltaXRpdmUgPSB0ZXJtLmdldFByaW1pdGl2ZSgpO1xuXG4gICAgICBpZiAocHJpbWl0aXZlICE9PSBudWxsKSB7XG4gICAgICAgIGVxdWFsVG8gPSB0aGlzLnByaW1pdGl2ZS5pc0VxdWFsVG8ocHJpbWl0aXZlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXF1YWxUbztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJUZXJtXCI7XG5cbiAgc3RhdGljIGZyb21QcmltaXRpdmUocHJpbWl0aXZlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcHJpbWl0aXZlU3RyaW5nID0gcHJpbWl0aXZlLmdldFN0cmluZygpLFxuICAgICAgICAgIHN0cmluZyA9IHByaW1pdGl2ZVN0cmluZywgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGwsXG4gICAgICAgICAgdmFyaWFibGUgPSBudWxsLFxuICAgICAgICAgIG5lZ2F0ZWRUZXJtID0gbnVsbCxcbiAgICAgICAgICBsb2dpY2FsVGVybSA9IG51bGwsXG4gICAgICAgICAgYnJhY2tldGVkVGVybSA9IG51bGwsXG4gICAgICAgICAgY29tcGFyaXNvblRlcm0gPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB0ZXJtID0gbmV3IFRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcHJpbWl0aXZlLCBuZWdhdGVkVGVybSwgbG9naWNhbFRlcm0sIGJyYWNrZXRlZFRlcm0sIGNvbXBhcmlzb25UZXJtKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFRlcm1zIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGdldExlbmd0aCgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICBnZXRUZXJtKGluZGV4KSB7XG4gICAgY29uc3QgdGVybSA9IHRoaXMuYXJyYXlbaW5kZXhdIHx8IG51bGw7ICAvLy9cblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgYWRkVGVybSh0ZXJtKSB7XG4gICAgdGhpcy5hcnJheS5wdXNoKHRlcm0pO1xuICB9XG5cbiAgbWFwVGVybShjYWxsYmFjaykgeyByZXR1cm4gdGhpcy5hcnJheS5tYXAoY2FsbGJhY2spOyB9XG5cbiAgZm9yRWFjaFRlcm0oY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtc0FycmF5ID0gdGhpcy5tYXBUZXJtKCh0ZXJtKSA9PiB7XG4gICAgICAgICAgICB0ZXJtID0gdGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGVybXNTdHJpbmcgPSB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5KHRlcm1zQXJyYXksIGNvbnRleHQpLFxuICAgICAgICAgIHN0cmluZyA9IHRlcm1zU3RyaW5nLCAvLy9cbiAgICAgICAgICBhcnJheSA9IHRlcm1zQXJyYXksIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB0ZXJtcyA9IG5ldyBUZXJtcyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICAgIHJldHVybiB0ZXJtcztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJUZXJtc1wiO1xuXG4gIHN0YXRpYyBmcm9tVGVybSh0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybXNBcnJheSA9IFtcbiAgICAgICAgICAgIHRlcm1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHRlcm1zU3RyaW5nID0gdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSh0ZXJtc0FycmF5LCBjb250ZXh0KSxcbiAgICAgICAgICBzdHJpbmcgPSB0ZXJtc1N0cmluZywgLy8vXG4gICAgICAgICAgYXJyYXkgPSB0ZXJtc0FycmF5LCAvLy9cbiAgICAgICAgICBub2RlID0gbnVsbDtcblxuICAgIGNvbnRleHQgPSBudWxsO1xuXG4gICAgY29uc3QgdGVybXMgPSBuZXcgVGVybXMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgICByZXR1cm4gdGVybXM7XG4gIH1cbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIExhYmVsIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBjb21wYXJlUHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlTmFtZUNvbXBhcmVzID0gKHRoaXMubmFtZSA9PT0gcHJvY2VkdXJlTmFtZSk7XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlTmFtZUNvbXBhcmVzO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIkxhYmVsXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBFcnJvciBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXJ4dCwgc3RyaW5nLCBub2RlKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuICB9XG5cbiAgdmVyaWZ5KGNvbnRleHQpIHtcbiAgICBjb25zdCB2ZXJpZmllcyA9IGZhbHNlLFxuICAgICAgICAgIGVycm9yU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC53YXJuaW5nKGBUaGUgJyR7ZXJyb3JTdHJpbmd9JyBlcnJvciBjYW5ub3QgYmUgdmVyaWZpZWQuYCk7XG5cbiAgICByZXR1cm4gdmVyaWZpZXM7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiRXJyb3JcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVTX1RZUEUsIEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlLCB0ZXJtRnJvbUJvb2xlYW4gfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuY29uc3QgeyBhc3luY0V2ZXJ5IH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBFdmVyeSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgZXZlcnlTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7ZXZlcnlTdHJpbmd9JyBldmVyeS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFU19UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFU19UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gdGVybS5nZXROb2RlcygpLFxuICAgICAgICAgIGJvb2xlYW4gPSBhd2FpdCBhc3luY0V2ZXJ5KG5vZGVzLCBhc3luYyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRlcm07XG5cbiAgICAgICAgICAgIGNvbnN0IHsgVGVybXMgfSA9IGVsZW1lbnRzO1xuXG4gICAgICAgICAgICB0ZXJtID0gdGVybUZyb21Ob2RlKG5vZGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBjb25zdCB0ZXJtcyA9IFRlcm1zLmZyb21UZXJtKHRlcm0sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICB0ZXJtID0gYXdhaXQgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUuY2FsbCh0ZXJtcywgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXJtVHlwZSAhPT0gQk9PTEVBTl9UWVBFKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIHR5cGUgaXMgJyR7dGVybVR5cGV9JyB3aGVuIGl0IHNob3VsZCBiZSBvZiB0eXBlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJvb2xlYW4gPSB0ZXJtLmdldEJvb2xlYW4oKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW47XG4gICAgICAgICAgfSk7XG5cbiAgICB0ZXJtID0gdGVybUZyb21Cb29sZWFuKGJvb2xlYW4sIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGAuLi5ldmFsdWF0ZWQgdGhlICcke2V2ZXJ5U3RyaW5nfScgZXZlcnkgYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiRXZlcnlcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVTX1RZUEUgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvdGVybVwiO1xuXG5jb25zdCB7IGFzeW5jUmVkdWNlIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBSZWR1Y2UgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgaW5pdGlhbEV4cHJlc3Npb24sIGFub255bW91c1Byb2NlZHVyZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmluaXRpYWxFeHByZXNzaW9uID0gaW5pdGlhbEV4cHJlc3Npb247XG4gICAgdGhpcy5hbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmU7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldEluaXRpYWxFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0QW5vbnltb3VzUHJvY2VkdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmFub255bW91c1Byb2NlZHVyZTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGF3YWl0IHRoaXMuYnJlYWsoY29udGV4dCk7XG5cbiAgICBjb25zdCByZWR1Y2VTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cmVkdWNlU3RyaW5nfScgcmVkdWNlLi4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IE5PREVTX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVTX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSB0ZXJtLmdldE5vZGVzKCksXG4gICAgICAgICAgaW5pdGlhbEV4cHJlc3Npb24gPSBhd2FpdCB0aGlzLmluaXRpYWxFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgdGVybSA9IGF3YWl0IGFzeW5jUmVkdWNlKG5vZGVzLCBhc3luYyAoY3VycmVudEV4cHJlc3Npb24sIG5vZGUpID0+IHtcbiAgICAgIGxldCB0ZXJtO1xuXG4gICAgICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cztcblxuICAgICAgdGVybSA9IGN1cnJlbnRUZXJtOyAvLy9cblxuICAgICAgY29uc3QgdGVybXMgPSBUZXJtcy5mcm9tVGVybSh0ZXJtLCBjb250ZXh0KTtcblxuICAgICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgICAgdGVybXMuYWRkVGVybSh0ZXJtKTtcblxuICAgICAgdGVybSA9IGF3YWl0IHRoaXMuYW5vbnltb3VzUHJvY2VkdXJlLmNhbGwodGVybXMsIGNvbnRleHQpO1xuXG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9LCBpbml0aWFsRXhwcmVzc2lvbik7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYC4uLmV2YWx1YXRlZCB0aGUgJyR7cmVkdWNlU3RyaW5nfScgcmVkdWNlIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJlZHVjZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVGVybmFyeSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0sIGlmRXhwcmVzc2lvbiwgZWxzZUV4cHJlc3Npb24pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICAgIHRoaXMuaWZFeHByZXNzaW9uID0gaWZFeHByZXNzaW9uO1xuICAgIHRoaXMuZWxzZUV4cHJlc3Npb24gPSBlbHNlRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGdldFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGdldElmQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZFeHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0RWxzZUJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmVsc2VFeHByZXNzaW9uO1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgdGVybmFyeVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7dGVybmFyeVN0cmluZ30nIHRlcm5hcnkuLi5gKTtcblxuICAgIHRlcm0gPSB0aGlzLnRlcm0uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBCT09MRUFOX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyB0eXBlIGlzICcke3Rlcm1UeXBlfScgd2hlbiBpdCBzaG91bGQgYmUgb2YgdHlwZSAnJHtCT09MRUFOX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgYm9vbGVhbiA9IHByaW1pdGl2ZVZhbHVlOyAvLy9cblxuICAgIHRlcm0gPSBib29sZWFuID9cbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pZkV4cHJlc3Npb24uZXZhbHVhdGUoY29udGV4dCkgOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZWxzZUV4cHJlc3Npb24uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7dGVybmFyeVN0cmluZ30nIHRlcm5hcnkgYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVGVybmFyeVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgVmFyaWFibGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBuYW1lLCB0ZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudGVybSA9IHRlcm07XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBjb21wYXJlVmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSkge1xuICAgIGNvbnN0IGNvbXBhcmVzVG9WYXJpYWJsZU5hbWUgPSAodGhpcy5uYW1lID09PSB2YXJpYWJsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGNvbXBhcmVzVG9WYXJpYWJsZU5hbWU7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgdmFyaWFibGVTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUuLi5gKTtcblxuICAgIGNvbnN0IG5lc3RlZCA9IHRydWUsXG4gICAgICAgICAgdmFyaWFibGVOYW1lID0gdGhpcy5uYW1lLCAvLy9cbiAgICAgICAgICB2YXJpYWJsZVByZXNlbnQgPSBjb250ZXh0LmlzVmFyaWFibGVQcmVzZW50QnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lLCBuZXN0ZWQpO1xuXG4gICAgaWYgKCF2YXJpYWJsZVByZXNlbnQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUgaXMgbm90IHByZXNlbnQuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB2YXJpYWJsZSA9IGNvbnRleHQuZmluZFZhcmlhYmxlQnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lKSxcbiAgICAgICAgICB0ZXJtID0gdmFyaWFibGUuZ2V0VGVybSgpLFxuICAgICAgICAgIHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIGFzIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybS5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgYXNzaWduKHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCBuZXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgICB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICB2YXJpYWJsZU5hbWUgPSB0aGlzLm5hbWUsIC8vL1xuICAgICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKSwgLy8vXG4gICAgICAgICAgdmFyaWFibGVQcmVzZW50ID0gY29udGV4dC5pc1ZhcmlhYmxlUHJlc2VudEJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSwgbmVzdGVkKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEFzc2lnbmluZyB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gdG8gdGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUuLi5gKTtcblxuICAgIGlmICh2YXJpYWJsZVByZXNlbnQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3ZhcmlhYmxlU3RyaW5nfScgdmFyaWFibGUgaXMgYWxyZWFkeSBwcmVzZW50LmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpLFxuICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gdmFyaWFibGVUeXBlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt2YXJpYWJsZVN0cmluZ30gdmFyaWFibGUncyAnJHt2YXJpYWJsZVR5cGV9JyB0eXBlIGRvZXMgbm90IGNvbXBhcmUgdG8gdGhlIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuXG4gICAgY29uc3QgdmFyaWFibGUgPSB0aGlzOyAgLy8vXG5cbiAgICBjb250ZXh0LmFkZFZhcmlhYmxlKHZhcmlhYmxlKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmFzc2lnbmVkIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSB0byB0aGUgJyR7dmFyaWFibGVTdHJpbmd9JyB2YXJpYWJsZS5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJWYXJpYWJsZVwiO1xuXG4gIHN0YXRpYyBmcm9tUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWUgPSBwYXJhbWV0ZXIuZ2V0TmFtZSgpLFxuICAgICAgICAgIHRlcm0gPSBudWxsLFxuICAgICAgICAgIHZhcmlhYmxlU3RyaW5nID0gdmFyaWFibGVTdHJpbmdGcm9tTmFtZShuYW1lKSxcbiAgICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZVN0cmluZywgIC8vL1xuICAgICAgICAgIG5vZGUgPSBudWxsO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBjb25zdCB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIHRlcm0pO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG5cbiAgc3RhdGljIGZyb21OYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGNvbnN0IGFsaWFzZWROYW1lID0gbmFtZWRQYXJhbWV0ZXIuZ2V0QWxpYXNlZE5hbWUoKSxcbiAgICAgICAgICB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWUgPSBhbGlhc2VkTmFtZSwgLy8vXG4gICAgICAgICAgdGVybSA9IG51bGwsXG4gICAgICAgICAgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZVN0cmluZ0Zyb21OYW1lKG5hbWUpLFxuICAgICAgICAgIHN0cmluZyA9IHZhcmlhYmxlU3RyaW5nLCAgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIGNvbnN0IHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgdGVybSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRlcm1BbmRQYXJhbWV0ZXIodGVybSwgcGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdHlwZSA9IHBhcmFtZXRlci5nZXRUeXBlKCksXG4gICAgICAgICAgbmFtZSA9IHBhcmFtZXRlci5nZXROYW1lKCksXG4gICAgICAgICAgdmFyaWFibGVTdHJpbmcgPSB2YXJpYWJsZVN0cmluZ0Zyb21OYW1lKG5hbWUpLFxuICAgICAgICAgIHN0cmluZyA9IHZhcmlhYmxlU3RyaW5nLCAgLy8vXG4gICAgICAgICAgbm9kZSA9IG51bGw7XG5cbiAgICBjb250ZXh0ID0gbnVsbDtcblxuICAgIGNvbnN0IHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgdGVybSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBudWxsTm9kZSBmcm9tIFwiLi4vbnVsbE5vZGVcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIE5PREVTX1RZUEUsIFNUUklOR19UWVBFLCBOVU1CRVJfVFlQRSwgQk9PTEVBTl9UWVBFICB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5jb25zdCB7IG1hdGNoIH0gPSBhcnJheVV0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFByaW1pdGl2ZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICAgIHByaW1pdGl2ZSA9IHRoaXMsXG4gICAgICAgICAgdGVybSA9IFRlcm0uZnJvbVByaW1pdGl2ZShwcmltaXRpdmUsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBpc0VxdWFsVG8ocHJpbWl0aXZlKSB7XG4gICAgbGV0IGVxdWFsVG8gPSBmYWxzZTtcblxuICAgIGNvbnN0IHR5cGUgPSBwcmltaXRpdmUuZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBwcmltaXRpdmUuZ2V0VmFsdWUoKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgTk9ERV9UWVBFOiB7XG4gICAgICAgICAgY29uc3Qgbm9kZUEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBub2RlQiA9IHZhbHVlLCAgLy8vXG4gICAgICAgICAgICAgICAgbm9kZU1hdGNoZXMgPSBtYXRjaE5vZGUobm9kZUEsIG5vZGVCKTtcblxuICAgICAgICAgIGlmIChub2RlTWF0Y2hlcykge1xuICAgICAgICAgICAgZXF1YWxUbyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIE5PREVTX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBub2Rlc0EgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBub2Rlc0IgPSB2YWx1ZSwgIC8vL1xuICAgICAgICAgICAgICAgIG5vZGVzTWF0Y2ggPSBtYXRjaE5vZGVzKG5vZGVzQSwgbm9kZXNCKTtcblxuICAgICAgICAgIGlmIChub2Rlc01hdGNoKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgU1RSSU5HX1RZUEU6IHtcbiAgICAgICAgICBjb25zdCBzdHJpbmdMaXRlcmFsQSA9IHRoaXMudmFsdWUsIC8vL1xuICAgICAgICAgICAgICAgIHN0cmluZ0xpdGVyYWxCID0gdmFsdWU7ICAvLy9cblxuICAgICAgICAgIGlmIChzdHJpbmdMaXRlcmFsQSA9PT0gc3RyaW5nTGl0ZXJhbEIpIHtcbiAgICAgICAgICAgIGVxdWFsVG8gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBOVU1CRVJfVFlQRToge1xuICAgICAgICAgIGNvbnN0IG51bWJlckEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBudW1iZXJCID0gdmFsdWU7ICAvLy9cblxuICAgICAgICAgIGlmIChudW1iZXJBID09PSBudW1iZXJCKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQk9PTEVBTl9UWVBFOiB7XG4gICAgICAgICAgY29uc3QgYm9vbGVhbkEgPSB0aGlzLnZhbHVlLCAvLy9cbiAgICAgICAgICAgICAgICBib29sZWFuQiA9IHZhbHVlOyAgLy8vXG5cbiAgICAgICAgICBpZiAoYm9vbGVhbkEgPT09IGJvb2xlYW5CKSB7XG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcXVhbFRvO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlByaW1pdGl2ZVwiO1xufSk7XG5cbmZ1bmN0aW9uIG1hdGNoTm9kZShub2RlQSwgbm9kZUIpIHtcbiAgbGV0IG5vZGVNYXRjaGVzO1xuXG4gIGlmICgobm9kZUEgPT09IG51bGxOb2RlKSB8fCAobm9kZUIgPT09IG51bGxOb2RlKSkge1xuICAgIG5vZGVNYXRjaGVzID0gKG5vZGVBID09PSBub2RlQik7XG4gIH0gZWxzZSBpZiAobm9kZUEgPT09IG51bGxOb2RlKSB7XG4gICAgbm9kZU1hdGNoZXMgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChub2RlQiA9PT0gbnVsbE5vZGUpIHtcbiAgICBub2RlTWF0Y2hlcyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGVBTWF0Y2hlc05vZGVCID0gbm9kZUEubWF0Y2gobm9kZUIpO1xuXG4gICAgbm9kZU1hdGNoZXMgPSBub2RlQU1hdGNoZXNOb2RlQjsgIC8vL1xuICB9XG5cbiAgcmV0dXJuIG5vZGVNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBtYXRjaE5vZGVzKG5vZGVzQSwgbm9kZXNCKSB7XG4gIGNvbnN0IG5vZGVzTWF0Y2ggPSBtYXRjaChub2Rlc0EsIG5vZGVzQiwgKG5vZGVBLCBub2RlQikgPT4ge1xuICAgIGNvbnN0IG5vZGVNYXRjaGVzID0gbWF0Y2hOb2RlKG5vZGVBLCBub2RlQik7XG5cbiAgICBpZiAobm9kZU1hdGNoZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5vZGVzTWF0Y2g7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUmVmZXJlbmNlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVOYW1lKCkge1xuICAgIGNvbnN0IHByb2NlZHVyZU5hbWUgPSB0aGlzLm5hbWU7ICAvLy9cblxuICAgIHJldHVybiBwcm9jZWR1cmVOYW1lO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJlZmVyZW5jZVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUHJvY2VkdXJlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbGFiZWwsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB0aGlzLnJldHVybkJsb2NrID0gcmV0dXJuQmxvY2s7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXRMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1ldGVycztcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLnJldHVybkJsb2NrO1xuICB9XG5cbiAgaXNCb29sZWFuKCkge1xuICAgIGNvbnN0IHR5cGVCb29sZWFuVHlwZSA9ICh0aGlzLnR5cGUgPT09IEJPT0xFQU5fVFlQRSksXG4gICAgICAgICAgYm9vbGVhbiA9IHR5cGVCb29sZWFuVHlwZTsgIC8vL1xuXG4gICAgcmV0dXJuIGJvb2xlYW47XG4gIH1cblxuICBnZXROYW1lKCkgeyByZXR1cm4gdGhpcy5sYWJlbC5nZXROYW1lKCk7IH1cblxuICBnZXRSZXR1cm5TdGF0ZW1lbnQoKSB7IHJldHVybiB0aGlzLnJldHVybkJsb2NrLmdldFJldHVyblN0YXRlbWVudCgpOyB9XG5cbiAgY29tcGFyZVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSkgeyByZXR1cm4gdGhpcy5sYWJlbC5jb21wYXJlUHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTsgfVxuXG4gIGFzeW5jIGNhbGwodGVybXMsIGNvbnRleHQpIHtcbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgcHJvY2VkdXJlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ2FsbGluZyB0aGUgJyR7cHJvY2VkdXJlU3RyaW5nfScgcHJvY2VkdXJlLi4uYCk7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMuY29tcGFyZVRlcm1zKHRlcm1zLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHZhcmlhYmxlc0Zyb21UZXJtc0FuZFBhcmFtZXRlcnModGVybXMsIHRoaXMucGFyYW1ldGVycywgY29udGV4dCksXG4gICAgICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmV0dXJuQmxvY2suZXZhbHVhdGUodmFyaWFibGVzLCBjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdGVybVR5cGUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHtwcm9jZWR1cmVTdHJpbmd9JyBwcm9jZWR1cmUncyAnJHt0aGlzLnR5cGV9JyB0eXBlLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jYWxsZWQgdGhlICcke3Byb2NlZHVyZVN0cmluZ30nIHByb2NlZHVyZS5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlByb2NlZHVyZVwiO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZXNGcm9tVGVybXNBbmRQYXJhbWV0ZXJzKHRlcm1zLCBwYXJhbWV0ZXJzLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlcyA9IFtdO1xuXG4gIHRlcm1zLmZvckVhY2hUZXJtKCh0ZXJtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcnMuZ2V0UGFyYW1ldGVyKGluZGV4KTtcblxuICAgIGlmIChwYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgVmFyaWFibGUgfSA9IGVsZW1lbnRzLFxuICAgICAgICAgICAgdmFyaWFibGUgPSBWYXJpYWJsZS5mcm9tVGVybUFuZFBhcmFtZXRlcih0ZXJtLCBwYXJhbWV0ZXIsIGNvbnRleHQpO1xuXG4gICAgICB2YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdmFyaWFibGVzO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IE5PREVfVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Ob2RlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmNvbnN0IHsgZmlyc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgTm9kZVF1ZXJ5IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBub2RlUXVlcnlTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtub2RlUXVlcnlTdHJpbmd9JyBub2RlIHF1ZXJ5Li4uYCk7XG5cbiAgICBpZiAodGhpcy5xdWVyeSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBDYW5ub3QgZXZhbHVhdGUgdGhlICcke25vZGVRdWVyeVN0cmluZ30nIG5vZGUgcXVlcnkgYmVjYXVzZSBpdHMgZXhwcmVzc2lvbiBpcyBtYWxmb3JtZWQuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRlcm0gPSB0aGlzLnZhcmlhYmxlLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVR5cGUgPSB0ZXJtLmdldFR5cGUoKTtcblxuICAgIGlmICh0ZXJtVHlwZSAhPT0gTk9ERV9UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgbGV0IG5vZGU7XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKTtcblxuICAgIG5vZGUgPSBwcmltaXRpdmVWYWx1ZTsgIC8vL1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyBub2RlIGlzIG51bGwuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5xdWVyeS5leGVjdXRlKG5vZGUpLFxuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKG5vZGVzTGVuZ3RoICE9PSAxKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIG5vZGVzIGlzICR7bm9kZXNMZW5ndGh9IHdoZW4gaXQgc2hvdWxkIGJlIDEuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IGZpcnN0KG5vZGVzKTtcblxuICAgIG5vZGUgPSBmaXJzdE5vZGU7IC8vL1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtub2RlUXVlcnlTdHJpbmd9JyBub2RlIHF1ZXJ5IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5vZGVRdWVyeVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFBhcmFtZXRlciBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cblxuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICBjb21wYXJlVGVybSh0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgcGFyYW1ldGVyU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ29tcGFyaW5nIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSBhZ2FpbnN0IHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSB0ZXJtVHlwZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIncyAnJHt0aGlzLnR5cGV9JyB0eXBlLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJpbmcgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtIGFnYWluc3QgdGhlICcke3BhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlci5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQYXJhbWV0ZXJcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBQYXJhbWV0ZXJzIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGdldExlbmd0aCgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmFycmF5Lmxlbmd0aDtcblxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXIoaW5kZXgpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSB0aGlzLmFycmF5W2luZGV4XSB8fCBudWxsO1xuXG4gICAgcmV0dXJuIHBhcmFtZXRlcjtcbiAgfVxuXG4gIGZvckVhY2hQYXJhbWV0ZXIoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGNvbXBhcmVUZXJtcyh0ZXJtcywgY29udGV4dCkge1xuICAgIGNvbnN0IHRlcm1zU3RyaW5nID0gdGVybXMuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgcGFyYW1ldGVyc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgQ29tcGFyaW5nIHRoZSAnJHt0ZXJtc1N0cmluZ30nIHRlcm1zIGFnYWluc3QgdGhlICcke3BhcmFtZXRlcnNTdHJpbmd9JyBwYXJhbWV0ZXJzLi4uYCk7XG5cbiAgICBjb25zdCB0ZXJtc0xlbmd0aCA9IHRlcm1zLmdldExlbmd0aCgpLFxuICAgICAgICAgIHBhcmFtZXRlcnNMZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKHRlcm1zTGVuZ3RoICE9PSBwYXJhbWV0ZXJzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtc1N0cmluZ30nIGV4cHJlc3Npb25zIGFuZCAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycyBhcmUgbm90IG9mIHRoZSBzYW1lIGxlbmd0aC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGhpcy5mb3JFYWNoUGFyYW1ldGVyKChwYXJhbWV0ZXIsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtcy5nZXRUZXJtKGluZGV4KTtcblxuICAgICAgICBwYXJhbWV0ZXIuY29tcGFyZVRlcm0odGVybSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7dGVybXNTdHJpbmd9JyB0ZXJtcyBhZ2FpbnN0IHRoZSAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycy5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQYXJhbWV0ZXJzXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgTk9ERV9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGVzIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBOb2Rlc1F1ZXJ5IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICB9XG5cbiAgZ2V0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBub2Rlc1F1ZXJ5U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bm9kZXNRdWVyeVN0cmluZ30nIG5vZGVzIHF1ZXJ5Li4uYCk7XG5cbiAgICBpZiAodGhpcy5xdWVyeSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBDYW5ub3QgZXZhbHVhdGUgdGhlICcke25vZGVzUXVlcnlTdHJpbmd9JyBub2RlcyBxdWVyeSBiZWNhdXNlIGl0cyBleHByZXNzaW9uIGlzIG1hbGZvcm1lZC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGVybSA9IHRoaXMudmFyaWFibGUuZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgbm9kZTtcblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpO1xuXG4gICAgbm9kZSA9IHByaW1pdGl2ZVZhbHVlOyAgLy8vXG5cbiAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzIG5vZGUgaXMgbnVsbC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLnF1ZXJ5LmV4ZWN1dGUobm9kZSk7XG5cbiAgICB0ZXJtID0gdGVybUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bm9kZXNRdWVyeVN0cmluZ30nIG5vZGVzIHF1ZXJ5IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5vZGVzUXVlcnlcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIEV4cHJlc3Npb24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtLCBzb21lLCBldmVyeSwgcmVkdWNlLCB0ZXJuYXJ5LCBub2RlUXVlcnksIG5vZGVzUXVlcnksIHJldHVybkJsb2NrLCBwcm9jZWR1cmVDYWxsKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgICB0aGlzLnNvbWUgPSBzb21lO1xuICAgIHRoaXMuZXZlcnkgPSBldmVyeTtcbiAgICB0aGlzLnJlZHVjZSA9IHJlZHVjZTtcbiAgICB0aGlzLnRlcm5hcnkgPSB0ZXJuYXJ5O1xuICAgIHRoaXMubm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5O1xuICAgIHRoaXMubm9kZXNRdWVyeSA9IG5vZGVzUXVlcnk7XG4gICAgdGhpcy5yZXR1cm5CbG9jayA9IHJldHVybkJsb2NrO1xuICAgIHRoaXMucHJvY2VkdXJlQ2FsbCA9IHByb2NlZHVyZUNhbGw7XG4gIH1cblxuICBnZXRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnRlcm07XG4gIH1cblxuICBnZXRTb21lKCkge1xuICAgIHJldHVybiB0aGlzLnNvbWU7XG4gIH1cblxuICBnZXRFdmVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVyeTtcbiAgfVxuXG4gIGdldFJlZHVjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2U7XG4gIH1cblxuICBnZXRUZXJuYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRlcm5heTtcbiAgfVxuXG4gIGdldE5vZGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlUXVlcnk7XG4gIH1cblxuICBnZXROb2Rlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzUXVlcnk7XG4gIH1cblxuICBnZXRSZXR1cm5CbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXR1cm5CbG9jaztcbiAgfVxuXG4gIGdldFByb2NlZHVyZUNhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2VkdXJlQ2FsbDtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZXJtICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy50ZXJtLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc29tZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMuc29tZS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV2ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5ldmVyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlZHVjZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMucmVkdWNlLmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVybmFyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMudGVybmFyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGVRdWVyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubm9kZVF1ZXJ5LmdldFR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubm9kZXNRdWVyeSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IHRoaXMubm9kZXNRdWVyeS5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJldHVybkJsb2NrICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gdGhpcy5yZXR1cm5CbG9jay5nZXRUeXBlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2NlZHVyZUNhbGwgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSB0aGlzLnByb2NlZHVyZUNhbGwuZ2V0VHlwZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICAvLy9cbiAgICB9IGVsc2UgaWYgKHRoaXMudGVybSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubm9kZVF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gdGhpcy5ub2RlUXVlcnkuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vZGVzUXVlcnkgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSB0aGlzLm5vZGVzUXVlcnkuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNvbWUgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnNvbWUuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV2ZXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gYXdhaXQgIHRoaXMuZXZlcnkuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlZHVjZSAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmVkdWNlLmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZXJuYXJ5ICE9PSBudWxsKSB7XG4gICAgICB0ZXJtID0gYXdhaXQgdGhpcy50ZXJuYXJ5LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZXR1cm5CbG9jayAhPT0gbnVsbCkge1xuICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmV0dXJuQmxvY2suZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2NlZHVyZUNhbGwgIT09IG51bGwpIHtcbiAgICAgIHRlcm0gPSBhd2FpdCB0aGlzLnByb2NlZHVyZUNhbGwuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiRXhwcmVzc2lvblwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmNvbnN0IHsgcHVzaCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2NrQ29udGV4dCBleHRlbmRzIENvbnRleHQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCB2YXJpYWJsZXMpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcblxuICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzKG5lc3RlZCA9IHRydWUpIHtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcblxuICAgIHB1c2godmFyaWFibGVzLCB0aGlzLnZhcmlhYmxlcyk7XG5cbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzID0gY29udGV4dC5nZXRWYXJpYWJsZXMoKTtcblxuICAgICAgcHVzaCh2YXJpYWJsZXMsIGNvbnRleHRWYXJpYWJsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYWJsZXM7XG4gIH1cblxuICBhZGRWYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgIGNvbnN0IG5lc3RlZCA9IGZhbHNlLFxuICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlLmdldE5hbWUoKSxcbiAgICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlLmdldFN0cmluZygpLFxuICAgICAgICAgIHZhcmlhYmxlUHJlc2VudCA9IHRoaXMuaXNWYXJpYWJsZVByZXNlbnRCeVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUsIG5lc3RlZCk7XG5cbiAgICBpZiAodmFyaWFibGVQcmVzZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIGlzIGFscmVhZHkgcHJlc2VudC4nYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEFkZGVkIHRoZSAnJHt2YXJpYWJsZVN0cmluZ30nIHZhcmlhYmxlIHRvIHRoZSBjb250ZXh0LmApO1xuXG4gICAgdGhpcy52YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gIH1cblxuICBmaW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgcHJvY2VkdXJlID0gY29udGV4dC5maW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgfVxuXG4gIGlzUHJvY2VkdXJlUHJlc2VudEJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgIHByb2NlZHVyZVByZXNlbnQgPSBjb250ZXh0LmlzUHJvY2VkdXJlUHJlc2VudEJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKTtcblxuICAgIHJldHVybiBwcm9jZWR1cmVQcmVzZW50O1xuICB9XG5cbiAgZmluZFZhcmlhYmxlQnlWYXJpYWJsZU5hbWUodmFyaWFibGVOYW1lLCBuZXN0ZWQgPSB0cnVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gdGhpcy5nZXRWYXJpYWJsZXMobmVzdGVkKSxcbiAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlcy5maW5kKCh2YXJpYWJsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVDb21wYXJlc1RvVmFyaWFibGVOYW1lID0gdmFyaWFibGUuY29tcGFyZVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAodmFyaWFibGVDb21wYXJlc1RvVmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pIHx8IG51bGw7XG5cbiAgICByZXR1cm4gdmFyaWFibGU7XG4gIH1cblxuICBpc1ZhcmlhYmxlUHJlc2VudEJ5VmFyaWFibGVOYW1lKHZhcmlhYmxlTmFtZSwgbmVzdGVkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5maW5kVmFyaWFibGVCeVZhcmlhYmxlTmFtZSh2YXJpYWJsZU5hbWUsIG5lc3RlZCksXG4gICAgICAgICAgdmFyaWFibGVQcmVzZW50ID0gKHZhcmlhYmxlICE9PSBudWxsKTtcblxuICAgIHJldHVybiB2YXJpYWJsZVByZXNlbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVZhcmlhYmxlcyh2YXJpYWJsZXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBibG9ja0NvbnRleHQgPSBDb250ZXh0LmZyb21Ob3RoaW5nKEJsb2NrQ29udGV4dCwgdmFyaWFibGVzLCBjb250ZXh0KVxuXG4gICAgcmV0dXJuIGJsb2NrQ29udGV4dDtcbiAgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50LCBhc3luY2hyb25vdXNVdGlsaXRpZXMgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uL2V4Y2VwdGlvblwiO1xuaW1wb3J0IEJsb2NrQ29udGV4dCBmcm9tIFwiLi4vY29udGV4dC9ibG9ja1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuY29uc3QgeyBhc3luY0ZvckVhY2ggfSA9IGFzeW5jaHJvbm91c1V0aWxpdGllcztcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFJldHVybkJsb2NrIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgc3RlcHMsIG5vbnNlbnNpY2FsLCByZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgdGhpcy5ub25zZW5zaWNhbCA9IG5vbnNlbnNpY2FsO1xuICAgIHRoaXMucmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50O1xuICB9XG5cbiAgZ2V0U3RlcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHM7XG4gIH1cblxuICBpc05vbnNlbnNpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLm5vbnNlbnNpY2FsO1xuICB9XG5cbiAgZ2V0UmV0dXJuU3RhdGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJldHVyblN0YXRlbWVudDtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKHZhcmlhYmxlcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRleHQgPSB2YXJpYWJsZXM7ICAvLy9cblxuICAgICAgdmFyaWFibGVzID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuQmxvY2tTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3JldHVybkJsb2NrU3RyaW5nfScgcmV0dXJuIGJsb2NrLi4uYCk7XG5cbiAgICBpZiAodGhpcy5ub25zZW5zaWNhbCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgcmV0dXJuIGJsb2NrIGlzIG5vbnNlbnNpY2FsLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja0NvbnRleHQgPSBCbG9ja0NvbnRleHQuZnJvbVZhcmlhYmxlcyh2YXJpYWJsZXMsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dCA9IGJsb2NrQ29udGV4dDsgLy8vXG5cbiAgICBhd2FpdCBhc3luY0ZvckVhY2godGhpcy5zdGVwcywgYXN5bmMgKHN0ZXApID0+IHtcbiAgICAgIGF3YWl0IHN0ZXAuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ZXJtID0gdGhpcy5yZXR1cm5TdGF0ZW1lbnQuZXZhbHVhdGUoY29udGV4dCksXG4gICAgICAgICAgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGBFdmFsdWF0ZWQuLi4gdGhlICcke3JldHVybkJsb2NrU3RyaW5nfScgcmV0dXJuIGJsb2NrIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJldHVybkJsb2NrXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuaW1wb3J0IHsgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbUJvb2xlYW4gfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE5lZ2F0ZWRUZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IG5lZ2F0ZWRUZXJtU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtuZWdhdGVkVGVybVN0cmluZ30nIG5lZ2F0ZWQgdGVybS4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGVybVR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHt0ZXJtU3RyaW5nfScgbGVmdCB0ZXJtJ3MgdHlwZSBpcyAnJHt0ZXJtVHlwZX0nIHdoZW4gaXQgc2hvdWxkIGJlIG9mIHR5cGUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGxldCBib29sZWFuO1xuXG4gICAgY29uc3QgcHJpbWl0aXZlVmFsdWUgPSB0ZXJtLmdldFByaW1pdGl2ZVZhbHVlKCk7XG5cbiAgICBib29sZWFuID0gcHJpbWl0aXZlVmFsdWU7IC8vL1xuXG4gICAgYm9vbGVhbiA9ICFib29sZWFuO1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtuZWdhdGVkVGVybVN0cmluZ30nIG5lZ2F0ZWQgdGVybSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJOZWdhdGVkVGVybVwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybUZyb21Cb29sZWFuIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBMb2dpY2FsVGVybSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIGRpc2p1bmN0aW9uLCBsZWZ0VGVybSwgcmlnaHRUZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpc2p1bmN0aW9uID0gZGlzanVuY3Rpb247XG4gICAgdGhpcy5sZWZ0VGVybSA9IGxlZnRUZXJtO1xuICAgIHRoaXMucmlnaHRUZXJtID0gcmlnaHRUZXJtO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgaXNEaXNqdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNqdW5jdGlvbjtcbiAgfVxuXG4gIGdldExlZnRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLmxlZnRUZXJtO1xuICB9XG5cbiAgZ2V0UmlnaHRUZXJtKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0VGVybTtcbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBsZXQgdGVybTtcblxuICAgIGNvbnN0IGxvZ2ljYWxUZXJtU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtsb2dpY2FsVGVybVN0cmluZ30nIGxvZ2ljYWwgdGVybS4uLmApO1xuXG4gICAgY29uc3QgbGVmdFRlcm0gPSB0aGlzLmxlZnRUZXJtLmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIHJpZ2h0VGVybSA9IHRoaXMucmlnaHRUZXJtLmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIGxlZnRUZXJtVHlwZSA9IGxlZnRUZXJtLmdldFR5cGUoKSxcbiAgICAgICAgICByaWdodFRlcm1UeXBlID0gcmlnaHRUZXJtLmdldFR5cGUoKTtcblxuICAgIGlmIChsZWZ0VGVybVR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgbGVmdFRlcm1TdHJpbmcgPSBsZWZ0VGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke2xlZnRUZXJtU3RyaW5nfScgbGVmdCB0ZXJtJ3MgdHlwZSBpcyAnJHtsZWZ0VGVybVR5cGV9JyB3aGVuIGl0IHNob3VsZCBiZSBvZiB0eXBlICcke0JPT0xFQU5fVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRUZXJtVHlwZSAhPT0gQk9PTEVBTl9UWVBFKSB7XG4gICAgICBjb25zdCByaWdodFRlcm1TdHJpbmcgPSByaWdodFRlcm0uZ2V0U3RyaW5nKCksXG4gICAgICAgICAgICBtZXNzYWdlID0gYFRoZSAnJHtyaWdodFRlcm1TdHJpbmd9JyByaWdodCB0ZXJtJ3MgdHlwZSBpcyAnJHtyaWdodFRlcm1UeXBlfScgd2hlbiBpdCBzaG91bGQgYmUgb2YgdHlwZSAnJHtCT09MRUFOX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdFRlcm1QcmltaXRpdmVWYWx1ZSA9IGxlZnRUZXJtLmdldFByaW1pdGl2ZVZhbHVlKCksXG4gICAgICAgICAgcmlnaHRUZXJtUHJpbWl0aXZlVmFsdWUgPSByaWdodFRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBsZWZ0Qm9vbGVhbiA9bGVmdFRlcm1QcmltaXRpdmVWYWx1ZSwgLy8vXG4gICAgICAgICAgcmlnaHRCb29sZWFuID0gcmlnaHRUZXJtUHJpbWl0aXZlVmFsdWUsIC8vL1xuICAgICAgICAgIGJvb2xlYW4gPSB0aGlzLmRpc2p1bmN0aW9uID9cbiAgICAgICAgICAgICAgICAgICAgICAobGVmdEJvb2xlYW4gfHwgcmlnaHRCb29sZWFuKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAobGVmdEJvb2xlYW4gJiYgcmlnaHRCb29sZWFuKTtcblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7bG9naWNhbFRlcm1TdHJpbmd9JyBsb2dpY2FsIHRlcm0gYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiTG9naWNhbFRlcm1cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIEJyYWNrZXRlZFRlcm0gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0ZXJtKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgfVxuXG4gIGdldFRlcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybTtcbiAgfVxuXG4gIGdldFR5cGUoKSB7IHJldHVybiB0aGlzLnRlcm0uZ2V0VHlwZSgpOyB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgYnJhY2tldGVkVGVybVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7YnJhY2tldGVkVGVybVN0cmluZ30nIGJyYWNrZXRlZCB0ZXJtLi4uYCk7XG5cbiAgICB0ZXJtID0gdGhpcy50ZXJtLmV2YWx1YXRlKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0cmluZyA9IHRlcm0uZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke2JyYWNrZXRlZFRlcm1TdHJpbmd9JyBicmFja2V0ZWQgdGVybSBhcyAnJHt0ZXJtU3RyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJCcmFja2V0ZWRUZXJtXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tIFwiLi4vZXhjZXB0aW9uXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUHJvY2VkdXJlQ2FsbCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHJlZmVyZW5jZSwgdGVybXMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcbiAgICB0aGlzLnRlcm1zID0gdGVybXM7XG4gIH1cblxuICBnZXRSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlO1xuICB9XG5cbiAgZ2V0VGVybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVybXM7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVOYW1lKCkgeyByZXR1cm4gdGhpcy5yZWZlcmVuY2UuZ2V0UHJvY2VkdXJlTmFtZSgpOyB9XG5cbiAgYXN5bmMgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGF3YWl0IHRoaXMuYnJlYWsoY29udGV4dCk7XG5cbiAgICBjb25zdCBwcm9jZWR1cmVDYWxsU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cHJvY2VkdXJlQ2FsbFN0cmluZ30nIHByb2NlZHVyZSBjYWxsLi4uYCk7XG5cbiAgICBjb25zdCBwcm9jZWR1cmVOYW1lID0gdGhpcy5nZXRQcm9jZWR1cmVOYW1lKCksXG4gICAgICAgICAgcHJvY2VkdXJlUHJlc2VudCA9IGNvbnRleHQuaXNQcm9jZWR1cmVQcmVzZW50QnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpO1xuXG4gICAgaWYgKCFwcm9jZWR1cmVQcmVzZW50KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRoZSAnJHtwcm9jZWR1cmVDYWxsU3RyaW5nfSBwcm9jZWR1cmUgaXMgbm90IHByZXNlbnQuJ2AsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9jZWR1cmUgPSBjb250ZXh0LmZpbmRQcm9jZWR1cmVCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSksXG4gICAgICAgICAgdGVybXMgPSB0aGlzLnRlcm1zLmV2YWx1YXRlKGNvbnRleHQpLFxuICAgICAgICAgIHRlcm0gPSBhd2FpdCBwcm9jZWR1cmUuY2FsbCh0ZXJtcywgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7cHJvY2VkdXJlQ2FsbFN0cmluZ30nIHByb2NlZHVyZSBjYWxsIGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlByb2NlZHVyZUNhbGxcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbUJvb2xlYW4gfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Rlcm1cIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIENvbXBhcmlzb25UZXJtIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmVnYXRlZCwgbGVmdFRlcm0sIHJpZ2h0VGVybSkge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMubmVnYXRlZCA9IG5lZ2F0ZWQ7XG4gICAgdGhpcy5sZWZ0VGVybSA9IGxlZnRUZXJtO1xuICAgIHRoaXMucmlnaHRUZXJtID0gcmlnaHRUZXJtO1xuICB9XG5cbiAgaXNOZWdhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0ZWQ7XG4gIH1cblxuICBnZXRMZWZ0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0VGVybTtcbiAgfVxuXG4gIGdldFJpZ2h0VGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodFRlcm07XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCBjb21wYXJpc29uVGVybVN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7Y29tcGFyaXNvblRlcm1TdHJpbmd9JyBjb21wYXJpc29uIHRlcm0uLi5gKTtcblxuICAgIGNvbnN0IGxlZnRUZXJtID0gdGhpcy5sZWZ0VGVybS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICByaWdodFRlcm0gPSB0aGlzLnJpZ2h0VGVybS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICBsZWZ0VGVybVR5cGUgPSBsZWZ0VGVybS5nZXRUeXBlKCksXG4gICAgICAgICAgcmlnaHRUZXJtVHlwZSA9IHJpZ2h0VGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAobGVmdFRlcm1UeXBlICE9PSByaWdodFRlcm1UeXBlKSB7XG4gICAgICBjb25zdCBsZWZ0VGVybVN0cmluZyA9IGxlZnRUZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgcmlnaHRUZXJtU3RyaW5nID0gcmlnaHRUZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7bGVmdFRlcm1TdHJpbmd9JyBsZWZ0IHRlcm0ncyB0eXBlIGlzICcke2xlZnRUZXJtVHlwZX0nIHdoZXJlYXMgdGhlICcke3JpZ2h0VGVybVN0cmluZ30nIHJpZ2h0IHRlcm0ncyB0eXBlIGlzICcke3JpZ2h0VGVybVR5cGV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdFRlcm1FcXVhbFRvUmlnaHRUZXJtID0gbGVmdFRlcm0uaXNFcXVhbFRvKHJpZ2h0VGVybSk7XG5cbiAgICBsZXQgYm9vbGVhbiA9IGxlZnRUZXJtRXF1YWxUb1JpZ2h0VGVybTsgLy8vXG5cbiAgICBpZiAodGhpcy5uZWdhdGVkKSB7XG4gICAgICBib29sZWFuID0gIWJvb2xlYW47IC8vL1xuICAgIH1cblxuICAgIHRlcm0gPSB0ZXJtRnJvbUJvb2xlYW4oYm9vbGVhbiwgY29udGV4dCk7XG5cbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgJyR7Y29tcGFyaXNvblRlcm1TdHJpbmd9JyBjb21wYXJpc29uIHRlcm0gYXMgJyR7dGVybVN0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiQ29tcGFyaXNvblRlcm1cIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBOYW1lZFBhcmFtZXRlciBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGFsaWFzKSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGdldEFsaWFzKCkge1xuICAgIHJldHVybiB0aGlzLmFsaWFzO1xuICB9XG5cbiAgaXNBbGlhc2VkKCkge1xuICAgIGNvbnN0IGFsaWFzZWQgPSAodGhpcy5hbGlhcyAhPT0gbnVsbCk7XG5cbiAgICByZXR1cm4gYWxpYXNlZDtcbiAgfVxuXG4gIGdldEFsaWFzZWROYW1lKCkge1xuICAgIGNvbnN0IGFsaWFzZWQgPSB0aGlzLmlzQWxpYXNlZCgpLFxuICAgICAgICAgIGFsaWFzZWROYW1lID0gYWxpYXNlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpYXMgOiAgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lOyAvLy9cblxuICAgIHJldHVybiBhbGlhc2VkTmFtZTtcbiAgfVxuXG4gIGNvbXBhcmVUZXJtKHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7ICAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IHRlcm1UeXBlID0gdGVybS5nZXRUeXBlKCk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSB0ZXJtVHlwZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgJyR7dGhpcy50eXBlfScgdHlwZS5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyZWQgdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLmApO1xuICB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyQ29tcGFyZXM7XG5cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlckEgPSB0aGlzLCAgLy8vXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJCID0gbmFtZWRQYXJhbWV0ZXI7IC8vL1xuXG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJBU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXJBLmdldFN0cmluZygpLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyQlN0cmluZyA9IG5hbWVkUGFyYW1ldGVyQi5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJBU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyQlN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgY29uc3QgbmFtZSA9IG5hbWVkUGFyYW1ldGVyLmdldE5hbWUoKSxcbiAgICAgICAgICB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpO1xuXG4gICAgbmFtZWRQYXJhbWV0ZXJDb21wYXJlcyA9ICgodGhpcy5uYW1lID09PSBuYW1lKSAmJiAodGhpcy50eXBlID09PSB0eXBlKSk7XG5cbiAgICBpZiAobmFtZWRQYXJhbWV0ZXJDb21wYXJlcykge1xuICAgICAgY29udGV4dC5kZWJ1ZyhgLi4uY29tcGFyZWQgdGhlICcke25hbWVkUGFyYW1ldGVyQVN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlckJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVkUGFyYW1ldGVyQ29tcGFyZXM7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiTmFtZWRQYXJhbWV0ZXJcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3Rlcm1cIjtcbmltcG9ydCB7IE5PREVfVFlQRSwgTk9ERVNfVFlQRSB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgQXJyYXlBc3NpZ21lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcGFyYW1ldGVycykge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcnM7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgYXJyYXlBc3NpZ25tZW50U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHthcnJheUFzc2lnbm1lbnRTdHJpbmd9JyBhcnJheSBhc3NpZ25tZW50Li4uYCk7XG5cbiAgICBjb25zdCB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFU19UWVBFKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGV9JyB0eXBlIHNob3VsZCBiZSAnJHtOT0RFU19UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIG5vZGVzID0gcHJpbWl0aXZlVmFsdWUsIC8vL1xuICAgICAgICAgIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIHBhcmFtZXRlcnNMZW5ndGggPSB0aGlzLnBhcmFtZXRlcnMuZ2V0TGVuZ3RoKCk7XG5cbiAgICBpZiAocGFyYW1ldGVyc0xlbmd0aCA+IG5vZGVzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5wYXJhbWV0ZXJzLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbm9kZXNTdHJpbmcgPSBjb250ZXh0Lm5vZGVzQXNTdHJpbmcobm9kZXgpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgbGVuZ3RoIG9mIHRoZSAnJHtwYXJhbWV0ZXJzU3RyaW5nfScgcGFyYW1ldGVycyBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgJyR7bm9kZXNTdHJpbmd9JyBub2Rlcy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgdGhpcy5wYXJhbWV0ZXJzLmZvckVhY2hQYXJhbWV0ZXIoKHBhcmFtZXRlciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgICAgICB0aGlzLmV2YWx1YXRlUGFyYW1ldGVyKHBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke2FycmF5QXNzaWdubWVudFN0cmluZ30nIGFycmF5IGFzc2lnbm1lbnQuYCk7XG4gIH1cblxuICBldmFsdWF0ZVBhcmFtZXRlcihwYXJhbWV0ZXIsIGV4cHJlc3Npb24sIGNvbnRleHQpIHtcbiAgICBjb25zdCBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvbi5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBwYXJhbWV0ZXJTdHJpbmcgPSBwYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSAnJHtwYXJhbWV0ZXJTdHJpbmd9JyBwYXJhbWV0ZXIgYWdhaW5zdCB0aGUgJyR7ZXhwcmVzc2lvblN0cmluZ30nIGV4cHJlc3Npb24uLi5gKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlclR5cGUgPSBwYXJhbWV0ZXIuZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHBhcmFtZXRlclR5cGUgIT09IE5PREVfVFlQRSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgdHlwZSBvZiB0aGUgJyR7cGFyYW1ldGVyU3RyaW5nfScgcGFyYW1ldGVyIHNob3VsZCBiZSAnJHtOT0RFX1RZUEV9Jy5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3QgeyBWYXJpYWJsZSB9ID0gZWxlbWVudHMsXG4gICAgICAgICAgdmFyaWFibGUgPSBWYXJpYWJsZS5mcm9tUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGV4dCk7XG5cbiAgICB2YXJpYWJsZS5hc3NpZ24oZXhwcmVzc2lvbiwgY29udGV4dCk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke3BhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlciBhZ2FpbnN0IHRoZSAnJHtleHByZXNzaW9uU3RyaW5nfScgZXhwcmVzc2lvbi5gKTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJBcnJheUFzc2lnbm1lbnRcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIFJldHVyblN0YXRlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0pIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnRlcm0gPSB0ZXJtO1xuICB9XG5cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtO1xuICB9XG5cbiAgZXZhbHVhdGUoY29udGV4dCkge1xuICAgIGxldCB0ZXJtO1xuXG4gICAgY29uc3QgcmV0dXJuU3RhdGVtZW50U3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgIC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7cmV0dXJuU3RhdGVtZW50U3RyaW5nfScgcmV0dXJuIHN0YXRlbWVudC4uLmApO1xuXG4gICAgdGVybSA9IHRoaXMudGVybS5ldmFsdWF0ZShjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtyZXR1cm5TdGF0ZW1lbnRTdHJpbmd9JyByZXR1cm4gc3RhdGVtZW50IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlJldHVyblN0YXRlbWVudFwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE5hbWVkUGFyYW1ldGVycyBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KSB7XG4gICAgc3VwZXIoY29udGV4dCwgc3RyaW5nLCBub2RlKVxuXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBnZXRMZW5ndGgoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG5cbiAgZ2V0TmFtZWRQYXJhbWV0ZXIoaW5kZXgpIHtcbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlciA9IHRoaXMuYXJyYXlbaW5kZXhdIHx8IG51bGw7XG5cbiAgICByZXR1cm4gbmFtZWRQYXJhbWV0ZXI7XG4gIH1cblxuICBzb21lTmFtZWRQYXJhbWV0ZXIoY2FsbGJhY2spIHsgcmV0dXJuIHRoaXMuYXJyYXkuc29tZShjYWxsYmFjayk7IH1cblxuICBmb3JFYWNoTmFtZWRQYXJhbWV0ZXIoY2FsbGJhY2spIHsgdGhpcy5hcnJheS5mb3JFYWNoKGNhbGxiYWNrKTsgfVxuXG4gIGNvbXBhcmVUZXJtcyh0ZXJtcywgY29udGV4dCkge1xuICAgIGNvbnN0IHRlcm1zU3RyaW5nID0gdGVybXMuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke3Rlcm1zU3RyaW5nfScgdGVybXMgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJzU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVycy4uLmApO1xuXG4gICAgY29uc3QgdGVybXNMZW5ndGggPSB0ZXJtcy5nZXRMZW5ndGgoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlcnNMZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgaWYgKHRlcm1zTGVuZ3RoICE9PSBuYW1lZFBhcmFtZXRlcnNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1zU3RyaW5nfScgdGVybXMgYW5kICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMgYXJlIG5vdCBvZiB0aGUgc2FtZSBsZW5ndGguYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZm9yRWFjaE5hbWVkUGFyYW1ldGVyKChuYW1lZFBhcmFtZXRlciwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChuYW1lZFBhcmFtZXRlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0ZXJtID0gdGVybXMuZ2V0VGVybShpbmRleCk7XG5cbiAgICAgICAgbmFtZWRQYXJhbWV0ZXIuY29tcGFyZVRlcm0odGVybSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5jb21wYXJlZCB0aGUgJyR7dGVybXNTdHJpbmd9JyB0ZXJtcyB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzLmApO1xuICB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlcnNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZFBhcmFtZXRlciB3aXRoIHRoZSAnJHtuYW1lZFBhcmFtZXRlcnNTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXJzLi4uYCk7XG5cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlckEgPSBuYW1lZFBhcmFtZXRlciwgLy8vXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJDb21wYXJlcyA9IHRoaXMuc29tZU5hbWVkUGFyYW1ldGVyKChuYW1lZFBhcmFtZXRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWVkUGFyYW1ldGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyQiA9IG5hbWVkUGFyYW1ldGVyLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgbmFtZWRQYXJhbWV0ZXJCQ29tcGFyZXNUb05hbWVkUGFyYW1ldGVyQSA9IG5hbWVkUGFyYW1ldGVyQS5jb21wYXJlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXJCLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICBpZiAobmFtZWRQYXJhbWV0ZXJCQ29tcGFyZXNUb05hbWVkUGFyYW1ldGVyQSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICBpZiAoIW5hbWVkUGFyYW1ldGVyQ29tcGFyZXMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWRQYXJhbWV0ZXIgZG9lcyBub3QgY29tcGFyZSB0byBhbnkgb2YgdGhlICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkUGFyYW1ldGVyIHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyc1N0cmluZ30nIG5hbWVkIHBhcmFtZXRlcnMuYCk7XG4gIH1cblxuICBjb21wYXJlTmFtZWRQYXJhbWV0ZXJzKG5hbWVkUGFyYW1ldGVycywgY29udGV4dCkge1xuICAgIG5hbWVkUGFyYW1ldGVycy5mb3JFYWNoTmFtZWRQYXJhbWV0ZXIoKG5hbWVkUGFyYW1ldGVyKSA9PiB7XG4gICAgICBpZiAobmFtZWRQYXJhbWV0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb21wYXJlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIk5hbWVkUGFyYW1ldGVyc1wiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IG5vZGVQcm9wZXJ0eVN0cmluZ0Zyb21OYW1lQW5kVHlwZSB9IGZyb20gXCIuL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZVByb3BlcnR5IHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCB0eXBlLCBuYW1lKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgZ2V0U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgfVxuXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCkge1xuICAgIGxldCBuYW1lZFBhcmFtZXRlckNvbXBhcmVzO1xuXG4gICAgY29uc3Qgbm9kZVByb3BlcnR5U3RyaW5nID0gdGhpcy5zdHJpbmcsIC8vL1xuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBDb21wYXJpbmcgdGhlICcke25vZGVQcm9wZXJ0eVN0cmluZ30nIG5vZGUgcHJvcGVydHkgd2l0aCB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIuLi5gKTtcblxuICAgIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlci5nZXROYW1lKCksXG4gICAgICAgICAgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKTtcblxuICAgIG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMgPSAoKHRoaXMubmFtZSA9PT0gbmFtZSkgJiYgKHRoaXMudHlwZSA9PT0gdHlwZSkpO1xuXG4gICAgaWYgKG5hbWVkUGFyYW1ldGVyQ29tcGFyZXMpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtub2RlUHJvcGVydHlTdHJpbmd9JyBub2RlIHByb3BlcnR5IHdpdGggdGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLmApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lZFBhcmFtZXRlckNvbXBhcmVzO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlBhcmFtZXRlclwiO1xuXG4gIHN0YXRpYyBmcm9tTmFtZUFuZFR5cGUobmFtZSwgdHlwZSkge1xuICAgIGNvbnN0IG5vZGVQcm9wZXJ0eVN0cmluZyA9IG5vZGVQcm9wZXJ0eVN0cmluZ0Zyb21OYW1lQW5kVHlwZShuYW1lLCB0eXBlKSxcbiAgICAgICAgICBzdHJpbmcgPSBub2RlUHJvcGVydHlTdHJpbmcsICAvLy9cbiAgICAgICAgICBub2RlUHJvcGVydHkgPSBuZXcgTm9kZVByb3BlcnR5KHN0cmluZywgdHlwZSwgbmFtZSk7XG5cbiAgICByZXR1cm4gbm9kZVByb3BlcnR5O1xuICB9XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgY29uc3QgQ09OVEVOVF9QQVJBTUVURVJfTkFNRSA9IFwiY29udGVudFwiO1xuZXhwb3J0IGNvbnN0IFRFUk1JTkFMX1BBUkFNRVRFUl9OQU1FID0gXCJ0ZXJtaW5hbFwiO1xuZXhwb3J0IGNvbnN0IENISUxEX05PREVTX1BBUkFNRVRFUl9OQU1FID0gXCJjaGlsZE5vZGVzXCI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4vZXhjZXB0aW9uXCI7XG5pbXBvcnQgTm9kZVByb3BlcnR5IGZyb20gXCIuL25vZGVQcm9wZXJ0eVwiO1xuXG5pbXBvcnQgeyBOT0RFU19UWVBFLCBTVFJJTkdfVFlQRSwgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IG5vZGVQcm9wZXJ0aWVzU3RyaW5nRnJvbU5vZGVQcm9wZXJ0aWVzQXJyYXkgfSBmcm9tIFwiLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyBDT05URU5UX1BBUkFNRVRFUl9OQU1FLCBURVJNSU5BTF9QQVJBTUVURVJfTkFNRSwgQ0hJTERfTk9ERVNfUEFSQU1FVEVSX05BTUUgfSBmcm9tIFwiLi9wYXJhbWV0ZXJOYW1lc1wiO1xuXG5jbGFzcyBOb2RlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZywgYXJyYXkpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICB9XG5cbiAgZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXk7XG4gIH1cblxuICBzb21lTm9kZVByb3BlcnR5KGNhbGxiYWNrKSB7IHJldHVybiB0aGlzLmFycmF5LnNvbWUoY2FsbGJhY2spOyB9XG5cbiAgY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KSB7XG4gICAgY29uc3Qgbm9kZVByb3BlcnRpZXNTdHJpbmcgPSB0aGlzLnN0cmluZywgLy8vXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYENvbXBhcmluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgd2l0aCB0aGUgJyR7bm9kZVByb3BlcnRpZXNTdHJpbmd9JyBub2RlIHByb3BlcnRpZXMuLi5gKTtcblxuICAgIGNvbnN0IG5hbWVkUGFyYW1ldGVyc0NvbXBhcmUgPSB0aGlzLnNvbWVOb2RlUHJvcGVydHkoKG5vZGVQcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJDb21wYXJlc1RvTm9kZVByb3BlcnR5ID0gbm9kZVByb3BlcnR5LmNvbXBhcmVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgY29udGV4dCk7XG5cbiAgICAgIGlmIChuYW1lZFBhcmFtZXRlckNvbXBhcmVzVG9Ob2RlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIW5hbWVkUGFyYW1ldGVyc0NvbXBhcmUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIGRvZXMgbm90IGNvbXBtYXJlIHRvIGFueSBvZiB0aGUgJyR7bm9kZVByb3BlcnRpZXNTdHJpbmd9JyBub2RlIHByb3BlcnRpZXMuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmNvbXBhcmVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciB3aXRoIHRoZSAnJHtub2RlUHJvcGVydGllc1N0cmluZ30nIG5vZGUgcHJvcGVydGllcy5gKTtcbiAgfVxuXG4gIGNvbXBhcmVOYW1lZFBhcmFtZXRlcnMobmFtZWRQYXJhbWV0ZXJzLCBjb250ZXh0KSB7XG4gICAgbmFtZWRQYXJhbWV0ZXJzLmZvckVhY2hOYW1lZFBhcmFtZXRlcigobmFtZWRQYXJhbWV0ZXIpID0+IHtcbiAgICAgIHRoaXMuY29tcGFyZU5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTm90aGluZygpIHtcbiAgICBjb25zdCBub2RlUHJvcGVydGllc0FycmF5ID0gbm9kZVByb3BlcnRpZXNBcnJheUZyb21Ob3RoaW5nKCksXG4gICAgICAgICAgc3RyaW5nID0gbm9kZVByb3BlcnRpZXNTdHJpbmdGcm9tTm9kZVByb3BlcnRpZXNBcnJheShub2RlUHJvcGVydGllc0FycmF5KSxcbiAgICAgICAgICBhcnJheSA9IG5vZGVQcm9wZXJ0aWVzQXJyYXksICAvLy9cbiAgICAgICAgICBub2RlUHJvcGVydGllcyA9IG5ldyBOb2RlUHJvcGVydGllcyhzdHJpbmcsIGFycmF5KTtcblxuICAgIHJldHVybiBub2RlUHJvcGVydGllcztcbiAgfVxufVxuXG5jb25zdCBub2RlUHJvcGVydGllcyA9IE5vZGVQcm9wZXJ0aWVzLmZyb21Ob3RoaW5nKCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVQcm9wZXJ0aWVzO1xuXG5mdW5jdGlvbiBub2RlUHJvcGVydGllc0FycmF5RnJvbU5vdGhpbmcoKSB7XG4gIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgIFNUUklOR19UWVBFLFxuICAgICAgICAgIEJPT0xFQU5fVFlQRSxcbiAgICAgICAgICBOT0RFU19UWVBFLFxuICAgICAgICBdLFxuICAgICAgICBuYW1lcyA9IFtcbiAgICAgICAgICBDT05URU5UX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICAgIFRFUk1JTkFMX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICAgIENISUxEX05PREVTX1BBUkFNRVRFUl9OQU1FXG4gICAgICAgIF0sXG4gICAgICAgIG5vZGVQcm9wZXJ0aWVzQXJyYXkgPSBuYW1lcy5tYXAoKG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBub2RlUHJvcGVydHkgPSBOb2RlUHJvcGVydHkuZnJvbU5hbWVBbmRUeXBlKG5hbWUsIHR5cGUpO1xuXG4gICAgICAgICAgcmV0dXJuIG5vZGVQcm9wZXJ0eTtcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIG5vZGVQcm9wZXJ0aWVzQXJyYXk7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCBFeGNlcHRpb24gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvblwiO1xuaW1wb3J0IG5vZGVQcm9wZXJ0aWVzIGZyb20gXCIuLi8uLi9ub2RlUHJvcGVydGllc1wiO1xuXG5pbXBvcnQgeyBkZWZpbmUgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHNcIjtcbmltcG9ydCB7IHN0cmluZ0xpdGVyYWxGcm9tU3RyaW5nIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9zdHJpbmdMaXRlcmFsXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIE5PREVTX1RZUEUsIFNUUklOR19UWVBFLCBCT09MRUFOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHRlcm1Gcm9tTm9kZXMsIHRlcm1Gcm9tQm9vbGVhbiwgdGVybUZyb21TdHJpbmdMaXRlcmFsIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy90ZXJtXCI7XG5pbXBvcnQgeyBDT05URU5UX1BBUkFNRVRFUl9OQU1FLCBURVJNSU5BTF9QQVJBTUVURVJfTkFNRSwgQ0hJTERfTk9ERVNfUEFSQU1FVEVSX05BTUUgfSBmcm9tIFwiLi4vLi4vcGFyYW1ldGVyTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lKGNsYXNzIE9iamVjdEFzc2lnbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBuYW1lZFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG4gICAgdGhpcy5uYW1lZFBhcmFtZXRlcnMgPSBuYW1lZFBhcmFtZXRlcnM7XG4gIH1cblxuICBnZXRWYXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgfVxuXG4gIGdldE5hbWVkUGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lZFBhcmFtZXRlcnM7XG4gIH1cblxuICBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgY29uc3Qgb2JqZWN0QXNzaWdubWVudFN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7b2JqZWN0QXNzaWdubWVudFN0cmluZ30nIG9iamVjdCBhc3NpZ25tZW50Li4uYCk7XG5cbiAgICBjb25zdCB0ZXJtID0gdGhpcy52YXJpYWJsZS5ldmFsdWF0ZShjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRlcm1UeXBlICE9PSBOT0RFX1RZUEUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgc2hvdWxkIGJlICcke05PREVfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBub2RlUHJvcGVydGllcy5jb21wYXJlTmFtZWRQYXJhbWV0ZXJzKHRoaXMubmFtZWRQYXJhbWV0ZXJzLCBjb250ZXh0KTtcblxuICAgIHRoaXMubmFtZWRQYXJhbWV0ZXJzLmZvckVhY2hOYW1lZFBhcmFtZXRlcigobmFtZWRQYXJhbWV0ZXIpID0+IHtcbiAgICAgIHRoaXMuZXZhbHVhdGVOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LmRlYnVnKGAuLi5ldmFsdWF0ZWQgdGhlICcke29iamVjdEFzc2lnbm1lbnRTdHJpbmd9JyBvYmplY3QgYXNzaWdubWVudC5gKTtcbiAgfVxuXG4gIGV2YWx1YXRlTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIgYWdhaW5zdCB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0uLi5gKTtcblxuICAgIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlci5nZXROYW1lKCk7XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgQ09OVEVOVF9QQVJBTUVURVJfTkFNRToge1xuICAgICAgICB0ZXJtID0gdGhpcy5ldmFsdWF0ZUNvbnRlbnROYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgVEVSTUlOQUxfUEFSQU1FVEVSX05BTUU6IHtcbiAgICAgICAgdGVybSA9IHRoaXMuZXZhbHVhdGVUZXJtaW5hbE5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCB0ZXJtLCBjb250ZXh0KTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBDSElMRF9OT0RFU19QQVJBTUVURVJfTkFNRToge1xuICAgICAgICB0ZXJtID0gdGhpcy5ldmFsdWF0ZUNoaWxkTm9kZXNOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBWYXJpYWJsZSB9ID0gZWxlbWVudHMsXG4gICAgICAgICAgdmFyaWFibGUgPSBWYXJpYWJsZS5mcm9tTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIGNvbnRleHQpO1xuXG4gICAgdmFyaWFibGUuYXNzaWduKHRlcm0sIGNvbnRleHQpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIHBhcmFtZXRlciBuYW1lZCBhZ2FpbnN0IHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybS5gKTtcbiAgfVxuXG4gIGV2YWx1YXRlQ29udGVudE5hbWVkUGFyYW1ldGVyKG5hbWVkUGFyYW1ldGVyLCB0ZXJtLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdHlwZSA9IG5hbWVkUGFyYW1ldGVyLmdldFR5cGUoKSxcbiAgICAgICAgICBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgY29udGVudCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgaWYgKHR5cGUgIT09IFNUUklOR19UWVBFKSB7XG4gICAgICBjb25zdCBuYW1lZFBhcmFtZXRlclN0cmluZyA9IG5hbWVkUGFyYW1ldGVyLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7bmFtZWRQYXJhbWV0ZXJTdHJpbmd9JyBuYW1lZCBwYXJhbWV0ZXIncyB0eXBlIHNob3VsZCBiZSAnJHtTVFJJTkdfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBub2RlID0gcHJpbWl0aXZlVmFsdWUsICAvLy9cbiAgICAgICAgICBub2RlVGVybWluYWxOb2RlID0gbm9kZS5pc1Rlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKCFub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3Mgbm9kZSBtdXN0IGJlIHRlcm1pbmFsLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgc3RyaW5nID0gY29udGVudCwgIC8vL1xuICAgICAgICAgIHN0cmluZ0xpdGVyYWwgPSBzdHJpbmdMaXRlcmFsRnJvbVN0cmluZyhzdHJpbmcpO1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHRyaW5nID0gdGVybS5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQuZGVidWcoYC4uLmV2YWx1YXRlZCB0aGUgY29udGVudCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciBhcyAnJHt0ZXJtU3R0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBldmFsdWF0ZVRlcm1pbmFsTmFtZWRQYXJhbWV0ZXIobmFtZWRQYXJhbWV0ZXIsIHRlcm0sIGNvbnRleHQpIHtcbiAgICBjb25zdCB0eXBlID0gbmFtZWRQYXJhbWV0ZXIuZ2V0VHlwZSgpLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyU3RyaW5nID0gbmFtZWRQYXJhbWV0ZXIuZ2V0U3RyaW5nKCk7XG5cbiAgICBjb250ZXh0LnRyYWNlKGBFdmFsdWF0aW5nIHRoZSB0ZXJtaW5hbCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlci4uLmApO1xuXG4gICAgaWYgKHR5cGUgIT09IEJPT0xFQU5fVFlQRSkge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgdHlwZSBzaG91bGQgYmUgJyR7Qk9PTEVBTl9UWVBFfScuYCxcbiAgICAgICAgICAgIGV4Y2VwdGlvbiA9IEV4Y2VwdGlvbi5mcm9tTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW1pdGl2ZVZhbHVlID0gdGVybS5nZXRQcmltaXRpdmVWYWx1ZSgpLFxuICAgICAgICAgIG5vZGUgPSBwcmltaXRpdmVWYWx1ZSwgIC8vL1xuICAgICAgICAgIG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgICAgdGVybWluYWwgPSBub2RlVGVybWluYWxOb2RlOyAgLy8vXG5cbiAgICBjb25zdCBib29sZWFuID0gdGVybWluYWw7IC8vL1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tQm9vbGVhbihib29sZWFuLCBjb250ZXh0KTsgIC8vL1xuXG4gICAgY29uc3QgdGVybVN0dHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSB0ZXJtaW5hbCAnJHtuYW1lZFBhcmFtZXRlclN0cmluZ30nIG5hbWVkIHBhcmFtZXRlciBhcyAnJHt0ZXJtU3R0cmluZ30nLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBldmFsdWF0ZUNoaWxkTm9kZXNOYW1lZFBhcmFtZXRlcihuYW1lZFBhcmFtZXRlciwgdGVybSwgY29udGV4dCkge1xuICAgIGNvbnN0IHR5cGUgPSBuYW1lZFBhcmFtZXRlci5nZXRUeXBlKCksXG4gICAgICAgICAgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlIGNoaWxkIG5vZGVzICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyLi4uYCk7XG5cbiAgICBpZiAodHlwZSAhPT0gTk9ERVNfVFlQRSkge1xuICAgICAgY29uc3QgbmFtZWRQYXJhbWV0ZXJTdHJpbmcgPSBuYW1lZFBhcmFtZXRlci5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyJ3MgdHlwZSBzaG91bGQgYmUgJyR7Tk9ERVNfVFlQRX0nLmAsXG4gICAgICAgICAgICBleGNlcHRpb24gPSBFeGNlcHRpb24uZnJvbU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmltaXRpdmVWYWx1ZSA9IHRlcm0uZ2V0UHJpbWl0aXZlVmFsdWUoKSxcbiAgICAgICAgICBub2RlID0gcHJpbWl0aXZlVmFsdWUsICAvLy9cbiAgICAgICAgICBub2RlTm9uVGVybWluYWxOb2RlID0gbm9kZS5pc05vblRlcm1pbmFsTm9kZSgpO1xuXG4gICAgaWYgKCFub2RlTm9uVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gdGVybS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3Mgbm9kZSBtdXN0IGJlIG5vbi10ZXJtaW5hbC5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29uc3Qgbm9uVGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgIGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgIG5vZGVzID0gY2hpbGROb2RlczsgIC8vL1xuXG4gICAgdGVybSA9IHRlcm1Gcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgdGVybVN0dHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSBjaGlsZE5vZGVzICcke25hbWVkUGFyYW1ldGVyU3RyaW5nfScgbmFtZWQgcGFyYW1ldGVyIGFzICcke3Rlcm1TdHRyaW5nfScuYCk7XG5cbiAgICByZXR1cm4gdGVybTtcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJPYmplY3RBc3NpZ21lbnRcIjtcbn0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gXCIuLi8uLi9leGNlcHRpb25cIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5pbXBvcnQgeyB2YXJpYWJsZXNGcm9tVGVybXNBbmRQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3Byb2NlZHVyZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgQW5vbnltb3VzUHJvY2VkdXJlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5yZXR1cm5CbG9jayA9IHJldHVybkJsb2NrO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJzO1xuICB9XG5cbiAgZ2V0UmV0dXJuQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucmV0dXJuQmxvY2s7XG4gIH1cblxuICBhc3luYyBjYWxsKHRlcm1zLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTsgLy8vXG5cbiAgICBjb250ZXh0LnRyYWNlKGBDYWxsaW5nIHRoZSAnJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9JyBhbm9ueW1vdXMgcHJvY2VkdXJlLi4uYCk7XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMuY29tcGFyZVRlcm1zKHRlcm1zLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHZhcmlhYmxlc0Zyb21UZXJtc0FuZFBhcmFtZXRlcnModGVybXMsIHRoaXMucGFyYW1ldGVycywgY29udGV4dCksXG4gICAgICAgICAgdGVybSA9IGF3YWl0IHRoaXMucmV0dXJuQmxvY2suZXZhbHVhdGUodmFyaWFibGVzLCBjb250ZXh0KSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IHRlcm0uZ2V0VHlwZSgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdGVybVR5cGUpIHtcbiAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpLFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBUaGUgJyR7dGVybVN0cmluZ30nIHRlcm0ncyAnJHt0ZXJtVHlwZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9JyBhbm9ueW1vdXMgcHJvY2VkdXJlJ3MgJyR7dGhpcy50eXBlfScgdHlwZS5gLFxuICAgICAgICAgICAgZXhjZXB0aW9uID0gRXhjZXB0aW9uLmZyb21NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uY2FsbGVkIHRoZSAnJHthbm9ueW1vdXNQcm9jZWR1cmVTdHJpbmd9JyBhbm9ueW1vdXMgcHJvY2VkdXJlLmApO1xuXG4gICAgcmV0dXJuIHRlcm07XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiQW5vbnltb3VzUHJvY2VkdXJlXCI7XG59KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgZXhwcmVzc2lvbikge1xuICAgIHN1cGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSlcblxuICAgIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICB9XG5cbiAgZ2V0VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFibGU7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG4gIH1cblxuICBhc3luYyBldmFsdWF0ZShjb250ZXh0KSB7XG4gICAgbGV0IHRlcm07XG5cbiAgICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpOyAvLy9cblxuICAgIGNvbnRleHQudHJhY2UoYEV2YWx1YXRpbmcgdGhlICcke3ZhcmlhYmxlQXNzaWdubWVudFN0cmluZ30nIHZhcmlhYmxlIGFzc2lnbm1lbnQuLi5gKTtcblxuICAgIHRlcm0gPSBhd2FpdCB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoY29udGV4dCk7XG5cbiAgICB0aGlzLnZhcmlhYmxlLmFzc2lnbih0ZXJtLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHRlcm1TdHJpbmcgPSB0ZXJtLmdldFN0cmluZygpO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHt2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmd9JyB2YXJpYWJsZSBhc3NpZ25tZW50IGFzICcke3Rlcm1TdHJpbmd9Jy5gKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9XG5cbiAgc3RhdGljIG5hbWUgPSBcIlZhcmlhYmxlQXNzaWdubWVudFwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQsIGFzeW5jaHJvbm91c1V0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzXCI7XG5cbmNvbnN0IHsgYXN5bmNGb3JFYWNoIH0gPSBhc3luY2hyb25vdXNVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZShjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnRzIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheTtcbiAgfVxuXG4gIGFzeW5jIGV2YWx1YXRlKGNvbnRleHQpIHtcbiAgICBhd2FpdCB0aGlzLmJyZWFrKGNvbnRleHQpO1xuXG4gICAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50c1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7IC8vL1xuXG4gICAgY29udGV4dC50cmFjZShgRXZhbHVhdGluZyB0aGUgJyR7dmFyaWFibGVBc3NpZ25tZW50c1N0cmluZ30nIHZhcmlhYmxlIGFzc2lnbm1lbnRzLi4uYCk7XG5cbiAgICBhd2FpdCBhc3luY0ZvckVhY2godGhpcy5hcnJheSwgYXN5bmMgKHZhcmlhYmxlQXNzaWdubWVudCkgPT4ge1xuICAgICAgYXdhaXQgdmFyaWFibGVBc3NpZ25tZW50LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgY29udGV4dC5kZWJ1ZyhgLi4uZXZhbHVhdGVkIHRoZSAnJHt2YXJpYWJsZUFzc2lnbm1lbnRzU3RyaW5nfScgdmFyaWFibGUgYXNzaWdubWVudHMuYCk7XG4gIH1cblxuICBzdGF0aWMgbmFtZSA9IFwiVmFyaWFibGVBc3NpZ25tZW50c1wiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gXCIuLi8uLi9lbGVtZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmUoY2xhc3MgUHJvY2VkdXJlRGVjbGFyYXRpb24gZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgc3RyaW5nLCBub2RlLCBwcm9jZWR1cmUpIHtcbiAgICBzdXBlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUpXG5cbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnByb2NlZHVyZSA9IHByb2NlZHVyZTtcbiAgfVxuXG4gIGdldFByb2NlZHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZWR1cmU7XG4gIH1cblxuICB2ZXJpZnkoY29udGV4dCkge1xuICAgIGNvbnN0IHZlcmlmaWVzID0gdHJ1ZTtcblxuICAgIGNvbnN0IHByb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7cHJvY2VkdXJlRGVjbGFyYXRpb25TdHJpbmd9JyBwcm9jZWR1cmUgZGVjbGFyYXRpb24uLi5gKVxuXG4gICAgY29uc3QgcHJvY2VkdXJlID0gdGhpcy5nZXRQcm9jZWR1cmUoKTtcblxuICAgIGNvbnRleHQuYWRkUHJvY2VkdXJlKHByb2NlZHVyZSk7XG5cbiAgICBpZiAodmVyaWZpZXMpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZ30nIHByb2NlZHVyZSBkZWNsYXJhdGlvbi5gKVxuICAgIH1cblxuICAgIHJldHVybiB2ZXJpZmllcztcbiAgfVxuXG4gIHN0YXRpYyBuYW1lID0gXCJQcm9jZWR1cmVEZWNsYXJhdGlvblwiO1xufSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBTdGVwIGZyb20gXCIuL2VsZW1lbnQvc3RlcFwiO1xuaW1wb3J0IFNvbWUgZnJvbSBcIi4vZWxlbWVudC9zb21lXCI7XG5pbXBvcnQgVGVybSBmcm9tIFwiLi9lbGVtZW50L3Rlcm1cIjtcbmltcG9ydCBUZXJtcyBmcm9tIFwiLi9lbGVtZW50L3Rlcm1zXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4vZWxlbWVudC9sYWJlbFwiO1xuaW1wb3J0IEVycm9yIGZyb20gXCIuL2VsZW1lbnQvZXJyb3JcIjtcbmltcG9ydCBFdmVyeSBmcm9tIFwiLi9lbGVtZW50L2V2ZXJ5XCI7XG5pbXBvcnQgUmVkdWNlIGZyb20gXCIuL2VsZW1lbnQvcmVkdWNlXCI7XG5pbXBvcnQgVGVybmFyeSBmcm9tIFwiLi9lbGVtZW50L3Rlcm5hcnlcIjtcbmltcG9ydCBWYXJpYWJsZSBmcm9tIFwiLi9lbGVtZW50L3ZhcmlhYmxlXCI7XG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gXCIuL2VsZW1lbnQvcHJpbWl0aXZlXCI7XG5pbXBvcnQgUmVmZXJlbmNlIGZyb20gXCIuL2VsZW1lbnQvcmVmZXJlbmNlXCI7XG5pbXBvcnQgUHJvY2VkdXJlIGZyb20gXCIuL2VsZW1lbnQvcHJvY2VkdXJlXCI7XG5pbXBvcnQgTm9kZVF1ZXJ5IGZyb20gXCIuL2VsZW1lbnQvbm9kZVF1ZXJ5XCI7XG5pbXBvcnQgUGFyYW1ldGVyIGZyb20gXCIuL2VsZW1lbnQvcGFyYW1ldGVyXCI7XG5pbXBvcnQgUGFyYW1ldGVycyBmcm9tIFwiLi9lbGVtZW50L3BhcmFtZXRlcnNcIjtcbmltcG9ydCBOb2Rlc1F1ZXJ5IGZyb20gXCIuL2VsZW1lbnQvbm9kZXNRdWVyeVwiO1xuaW1wb3J0IEV4cHJlc3Npb24gZnJvbSBcIi4vZWxlbWVudC9leHByZXNzaW9uXCI7XG5pbXBvcnQgUmV0dXJuQmxvY2sgZnJvbSBcIi4vZWxlbWVudC9yZXR1cm5CbG9ja1wiO1xuaW1wb3J0IE5lZ2F0ZWRUZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9uZWdhdGVkXCI7XG5pbXBvcnQgTG9naWNhbFRlcm0gZnJvbSBcIi4vZWxlbWVudC90ZXJtL2xvZ2ljYWxcIjtcbmltcG9ydCBCcmFja2V0ZWRUZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9icmFja2V0ZWRcIjtcbmltcG9ydCBQcm9jZWR1cmVDYWxsIGZyb20gXCIuL2VsZW1lbnQvcHJvY2VkdXJlQ2FsbFwiO1xuaW1wb3J0IENvbXBhcmlzb25UZXJtIGZyb20gXCIuL2VsZW1lbnQvdGVybS9jb21wYXJpc29uXCI7XG5pbXBvcnQgTmFtZWRQYXJhbWV0ZXIgZnJvbSBcIi4vZWxlbWVudC9wYXJhbWV0ZXIvbmFtZWRcIjtcbmltcG9ydCBBcnJheUFzc2lnbWVudCBmcm9tIFwiLi9lbGVtZW50L2Fzc2lnbm1lbnQvYXJyYXlcIjtcbmltcG9ydCBSZXR1cm5TdGF0ZW1lbnQgZnJvbSBcIi4vZWxlbWVudC9zdGF0ZW1lbnQvcmV0dXJuXCI7XG5pbXBvcnQgTmFtZWRQYXJhbWV0ZXJzIGZyb20gXCIuL2VsZW1lbnQvcGFyYW1ldGVycy9uYW1lZFwiO1xuaW1wb3J0IE9iamVjdEFzc2lnbm1lbnQgZnJvbSBcIi4vZWxlbWVudC9hc3NpZ25tZW50L29iamVjdFwiO1xuaW1wb3J0IEFub255bW91c1Byb2NlZHVyZSBmcm9tIFwiLi9lbGVtZW50L3Byb2NlZHVyZS9hbm9ueW1vdXNcIjtcbmltcG9ydCBWYXJpYWJsZUFzc2lnbm1lbnQgZnJvbSBcIi4vZWxlbWVudC9hc3NpZ25tZW50L3ZhcmlhYmxlXCI7XG5pbXBvcnQgVmFyaWFibGVBc3NpZ25tZW50cyBmcm9tIFwiLi9lbGVtZW50L2Fzc2lnbm1lbnRzL3ZhcmlhYmxlXCI7XG5pbXBvcnQgUHJvY2VkdXJlRGVjbGFyYXRpb24gZnJvbSBcIi4vZWxlbWVudC9kZWNsYXJhdGlvbi9wcm9jZWR1cmVcIjtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRnVydGxlTGV4ZXIgYXMgRnVydGxlTGV4ZXJCYXNlIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXJzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZUxleGVyIGV4dGVuZHMgRnVydGxlTGV4ZXJCYXNlIHt9XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBTVEVQX1JVTEVfTkFNRSA9IFwic3RlcFwiO1xuZXhwb3J0IGNvbnN0IFNPTUVfUlVMRV9OQU1FID0gXCJzb21lXCI7XG5leHBvcnQgY29uc3QgVEVSTV9SVUxFX05BTUUgPSBcInRlcm1cIjtcbmV4cG9ydCBjb25zdCBURVJNU19SVUxFX05BTUUgPSBcInRlcm1zXCI7XG5leHBvcnQgY29uc3QgRVZFUllfUlVMRV9OQU1FID0gXCJldmVyeVwiO1xuZXhwb3J0IGNvbnN0IExBQkVMX1JVTEVfTkFNRSA9IFwibGFiZWxcIjtcbmV4cG9ydCBjb25zdCBFUlJPUl9SVUxFX05BTUUgPSBcImVycm9yXCI7XG5leHBvcnQgY29uc3QgUkVEVUNFX1JVTEVfTkFNRSA9IFwicmVkdWNlXCI7XG5leHBvcnQgY29uc3QgVEVSTkFSWV9SVUxFX05BTUUgPSBcInRlcm5hcnlcIjtcbmV4cG9ydCBjb25zdCBWQVJJQUJMRV9SVUxFX05BTUUgPSBcInZhcmlhYmxlXCI7XG5leHBvcnQgY29uc3QgTk9OU0VOU0VfUlVMRV9OQU1FID0gXCJub25zZW5zZVwiO1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1JVTEVfTkFNRSA9IFwiZG9jdW1lbnRcIjtcbmV4cG9ydCBjb25zdCBQUklNSVRJVkVfUlVMRV9OQU1FID0gXCJwcmltaXRpdmVcIjtcbmV4cG9ydCBjb25zdCBSRUZFUkVOQ0VfUlVMRV9OQU1FID0gXCJyZWZlcmVuY2VcIjtcbmV4cG9ydCBjb25zdCBQQVJBTUVURVJfUlVMRV9OQU1FID0gXCJwYXJhbWV0ZXJcIjtcbmV4cG9ydCBjb25zdCBOT0RFX1FVRVJZX1JVTEVfTkFNRSA9IFwibm9kZVF1ZXJ5XCI7XG5leHBvcnQgY29uc3QgRVhQUkVTU0lPTl9SVUxFX05BTUUgPSBcImV4cHJlc3Npb25cIjtcbmV4cG9ydCBjb25zdCBQQVJBTUVURVJTX1JVTEVfTkFNRSA9IFwicGFyYW1ldGVyc1wiO1xuZXhwb3J0IGNvbnN0IE5PREVTX1FVRVJZX1JVTEVfTkFNRSA9IFwibm9kZXNRdWVyeVwiO1xuZXhwb3J0IGNvbnN0IFJFVFVSTl9CTE9DS19SVUxFX05BTUUgPSBcInJldHVybkJsb2NrXCI7XG5leHBvcnQgY29uc3QgTE9HSUNBTF9URVJNX1JVTEVfTkFNRSA9IFwibG9naWNhbFRlcm1cIjtcbmV4cG9ydCBjb25zdCBORUdBVEVEX1RFUk1fUlVMRV9OQU1FID0gXCJuZWdhdGVkVGVybVwiO1xuZXhwb3J0IGNvbnN0IEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSA9IFwiYnJhY2tldGVkVGVybVwiO1xuZXhwb3J0IGNvbnN0IFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSA9IFwicHJvY2VkdXJlQ2FsbFwiO1xuZXhwb3J0IGNvbnN0IENPTVBBUklTT05fVEVSTV9SVUxFX05BTUUgPSBcImNvbXBhcmlzb25UZXJtXCI7XG5leHBvcnQgY29uc3QgTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRSA9IFwibmFtZWRQYXJhbWV0ZXJcIjtcbmV4cG9ydCBjb25zdCBOQU1FRF9QQVJBTUVURVJTX1JVTEVfTkFNRSA9IFwibmFtZWRQYXJhbWV0ZXJzXCI7XG5leHBvcnQgY29uc3QgUkVUVVJOX1NUQVRFTUVOVF9SVUxFX05BTUUgPSBcInJldHVyblN0YXRlbWVudFwiO1xuZXhwb3J0IGNvbnN0IEFSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FID0gXCJhcnJheUFzc2lnbm1lbnRcIjtcbmV4cG9ydCBjb25zdCBPQkpFQ1RfQVNTSUdOTUVOVF9SVUxFX05BTUUgPSBcIm9iamVjdEFzc2lnbm1lbnRcIjtcbmV4cG9ydCBjb25zdCBWQVJJQUJMRV9BU1NJR05NRU5UX1JVTEVfTkFNRSA9IFwidmFyaWFibGVBc3NpZ25tZW50XCI7XG5leHBvcnQgY29uc3QgQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUgPSBcImFub255bW91c1Byb2NlZHVyZVwiO1xuZXhwb3J0IGNvbnN0IFZBUklBQkxFX0FTU0lHTk1FTlRTX1JVTEVfTkFNRSA9IFwidmFyaWFibGVBc3NpZ25tZW50c1wiO1xuZXhwb3J0IGNvbnN0IFBST0NFRFVSRV9ERUNMQVJBVElPTl9SVUxFX05BTUUgPSBcInByb2NlZHVyZURlY2xhcmF0aW9uXCI7XG5cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBBUlJBWV9BU1NJR05NRU5UX1JVTEVfTkFNRSwgT0JKRUNUX0FTU0lHTk1FTlRfUlVMRV9OQU1FLCBWQVJJQUJMRV9BU1NJR05NRU5UU19SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RlcE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRBcnJheUFzc2lnbm1lbnROb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gQVJSQVlfQVNTSUdOTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICAgYXJyYXlBc3NpZ25tZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGFycmF5QXNzaWdubWVudE5vZGU7XG4gIH1cblxuICBnZXRPYmplY3RBc3NpZ25tZW50Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE9CSkVDVF9BU1NJR05NRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgICBvYmplY3RBc3NpZ25tZW50Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG9iamVjdEFzc2lnbm1lbnROb2RlO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVBc3NpZ25tZW50c05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9BU1NJR05NRU5UU19SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50c05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoU3RlcE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvbWVOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxvZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsb2VOb2RlO1xuICB9XG5cbiAgZ2V0QW5vbnltb3VzUHJvY2VkdXJlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEFOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FLFxuICAgICAgICAgIGFub255bW91c1Byb2NlZHVyZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShTb21lTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgUFJJTUlUSVZFX1JVTEVfTkFNRSxcbiAgICAgICAgIE5FR0FURURfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgQlJBQ0tFVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgQ09NUEFSSVNPTl9URVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgZ2V0UHJpbWl0aXZlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBSSU1JVElWRV9SVUxFX05BTUUsXG4gICAgICAgICAgcHJpbWl0aXZlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByaW1pdGl2ZU5vZGU7XG4gIH1cblxuICBnZXROZWdhdGVkVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBORUdBVEVEX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIG5lZ2F0ZWRUZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5lZ2F0ZWRUZXJtTm9kZTtcbiAgfVxuXG4gIGdldExvZ2ljYWxUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IExPR0lDQUxfVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgbG9naWNhbFRlcm1SdWxlTmFtZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGxvZ2ljYWxUZXJtUnVsZU5hbWU7XG4gIH1cblxuICBnZXRCcmFja2V0ZWRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICBicmFja2V0ZWRUZXJtUnVsZU5hbWUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBicmFja2V0ZWRUZXJtUnVsZU5hbWU7XG4gIH1cblxuICBnZXRDb21wYXJpc29uVGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIGNvbXBhcmlzb25Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gY29tcGFyaXNvbk5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkge1xuICAgIGlmIChwcmVjZWRlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZWNlZGVuY2UgPSBvcGFjaXR5OyAvLy9cblxuICAgICAgb3BhY2l0eSA9IGNoaWxkTm9kZXM7IC8vL1xuXG4gICAgICBjaGlsZE5vZGVzID0gcnVsZU5hbWU7ICAvLy9cblxuICAgICAgcnVsZU5hbWUgPSBDbGFzczsgLy8vXG5cbiAgICAgIENsYXNzID0gVGVybU5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgdGVybU5vZGUgPSBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVybU5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRUZXJtTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShUZXJtTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlcnlOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoRXZlcnlOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IFRZUEVfVE9LRU5fVFlQRSA9IFwidHlwZVwiO1xuZXhwb3J0IGNvbnN0IE5BTUVfVE9LRU5fVFlQRSA9IFwibmFtZVwiO1xuZXhwb3J0IGNvbnN0IE5VTExfVE9LRU5fVFlQRSA9IFwibnVsbFwiO1xuZXhwb3J0IGNvbnN0IE5VTUJFUl9UT0tFTl9UWVBFID0gXCJudW1iZXJcIjtcbmV4cG9ydCBjb25zdCBTUEVDSUFMX1RPS0VOX1RZUEUgPSBcInNwZWNpYWxcIjtcbmV4cG9ydCBjb25zdCBCT09MRUFOX1RPS0VOX1RZUEUgPSBcImJvb2xlYW5cIjtcbmV4cG9ydCBjb25zdCBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFID0gXCJzdHJpbmctbGl0ZXJhbFwiO1xuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5BTUVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKExhYmVsTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShFcnJvck5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFZBUklBQkxFX1JVTEVfTkFNRSwgRVhQUkVTU0lPTl9SVUxFX05BTUUsIEFOT05ZTU9VU19QUk9DRURVUkVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWR1Y2VOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb25Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZXhwcmVzc2lvbk5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBleHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIGdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmVkdWNlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSwgRVhQUkVTU0lPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIHNlY29uZCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm5hcnlOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0RXhwcmVzc2lvbk5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZXhwcmVzc2lvbk5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGV4cHJlc3Npb25Ob2RlcztcbiAgfVxuXG4gIGdldElmRXhwcmVzc2lvbk5vZGUoKSB7XG4gICAgY29uc3QgZmlyc3RFeHByZXNzaW9uTm9kZSA9IHRoaXMuZ2V0Rmlyc3RFeHByZXNzaW9uTm9kZSgpLFxuICAgICAgICAgIGlmRXhwcmVzc2lvbk5vZGUgPSBmaXJzdEV4cHJlc3Npb25Ob2RlOyAgLy8vXG5cbiAgICByZXR1cm4gaWZFeHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIGdldEVsc2VFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBzZWNvbmRFeHByZXNzaW9uTm9kZSA9IHRoaXMuZ2V0U2Vjb25kRXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgICBlbHNlRXhwcmVzc2lvbk5vZGUgPSBzZWNvbmRFeHByZXNzaW9uTm9kZTsgLy8vXG5cbiAgICByZXR1cm4gZWxzZUV4cHJlc3Npb25Ob2RlO1xuICB9XG5cbiAgZ2V0Rmlyc3RFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBleHByZXNzaW9uTm9kZXMgPSB0aGlzLmdldEV4cHJlc3Npb25Ob2RlcygpLFxuICAgICAgICAgIGZpcnN0RXhwcmVzc2lvbk5vZGUgPSBmaXJzdChleHByZXNzaW9uTm9kZXMpO1xuXG4gICAgcmV0dXJuIGZpcnN0RXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBnZXRTZWNvbmRFeHByZXNzaW9uTm9kZSgpIHtcbiAgICBjb25zdCBleHByZXNzaW9uTm9kZXMgPSB0aGlzLmdldEV4cHJlc3Npb25Ob2RlcygpLFxuICAgICAgICAgIHNlY29uZEV4cHJlc3Npb25Ob2RlID0gc2Vjb25kKGV4cHJlc3Npb25Ob2Rlcyk7XG5cbiAgICByZXR1cm4gc2Vjb25kRXhwcmVzc2lvbk5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFRlcm5hcnlOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKERvY3VtZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFyaWFibGVOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5BTUVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFZhcmlhYmxlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uc2Vuc2VOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShOb25zZW5zZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCBudWxsTm9kZSBmcm9tIFwiLi4vbnVsbE5vZGVcIjtcblxuaW1wb3J0IHsgTlVMTCwgVFJVRSwgRkFMU0UgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIFNUUklOR19UWVBFLCBOVU1CRVJfVFlQRSwgQk9PTEVBTl9UWVBFIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBOVUxMX1RPS0VOX1RZUEUsIE5VTUJFUl9UT0tFTl9UWVBFLCBCT09MRUFOX1RPS0VOX1RZUEUsIFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmltaXRpdmVOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZTtcblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUoKSxcbiAgICAgICAgICBudW1iZXIgPSB0aGlzLmdldE51bWJlcigpLFxuICAgICAgICAgIGJvb2xlYW4gPSB0aGlzLmdldEJvb2xlYW4oKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IE5PREVfVFlQRTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IE5VTUJFUl9UWVBFO1xuICAgIH0gZWxzZSBpZiAoYm9vbGVhbiAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IEJPT0xFQU5fVFlQRTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZ0xpdGVyYWwgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBTVFJJTkdfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIGxldCB2YWx1ZTtcblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUoKSxcbiAgICAgICAgICBudW1iZXIgPSB0aGlzLmdldE51bWJlcigpLFxuICAgICAgICAgIGJvb2xlYW4gPSB0aGlzLmdldEJvb2xlYW4oKSxcbiAgICAgICAgICBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCk7XG5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIC8vL1xuICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBub2RlOyAvLy9cbiAgICB9IGVsc2UgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBudW1iZXI7IC8vL1xuICAgIH0gZWxzZSBpZiAoYm9vbGVhbiAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBib29sZWFuOyAgLy8vXG4gICAgfSBlbHNlIGlmIChzdHJpbmdMaXRlcmFsICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ0xpdGVyYWw7ICAvLy9cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBnZXROb2RlKCkge1xuICAgIGxldCBub2RlID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5VTExfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgaWYgKGNvbnRlbnQgPT09IE5VTEwpIHtcbiAgICAgICAgbm9kZSA9IG51bGxOb2RlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldE51bWJlcigpIHtcbiAgICBsZXQgbnVtYmVyID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5VTUJFUl9UT0tFTl9UWVBFOyAvLy9cblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgaWYgKGNvbnRlbnQgPT09IFRSVUUpIHtcbiAgICAgICAgbnVtYmVyID0gTnVtYmVyKGNvbnRlbnQpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgZ2V0Qm9vbGVhbigpIHtcbiAgICBsZXQgYm9vbGVhbiA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBCT09MRUFOX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIGlmIChjb250ZW50ID09PSBUUlVFKSB7XG4gICAgICAgIGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudCA9PT0gRkFMU0UpIHtcbiAgICAgICAgYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gYm9vbGVhbjtcbiAgfVxuXG4gIGdldFN0cmluZ0xpdGVyYWwoKSB7XG4gICAgbGV0IHN0cmluZ0xpdGVyYWwgPSBudWxsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1RSSU5HX0xJVEVSQUxfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCA9IGNvbnRlbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcmltaXRpdmVOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5pbXBvcnQgeyBOQU1FX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZlcmVuY2VOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IE5BTUVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgbmFtZSA9IGNvbnRlbnQ7IC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJlZmVyZW5jZU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFRZUEVfVE9LRU5fVFlQRSwgTkFNRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uL3Rva2VuVHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyYW10ZXJOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0TmFtZSgpIHtcbiAgICBsZXQgbmFtZSA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG5hbWUgPSBjb250ZW50OyAvL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlID0gbnVsbDtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFRZUEVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgdHlwZSA9IGNvbnRlbnQ7IC8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7XG4gICAgaWYgKHByZWNlZGVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJlY2VkZW5jZSA9IG9wYWNpdHk7IC8vL1xuXG4gICAgICBvcGFjaXR5ID0gY2hpbGROb2RlczsgLy8vXG5cbiAgICAgIGNoaWxkTm9kZXMgPSBydWxlTmFtZTsgIC8vL1xuXG4gICAgICBydWxlTmFtZSA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJhbXRlck5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1ldGVyTm9kZSA9IE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJOb2RlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCB7IFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2RlUXVlcnlOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgZ2V0U3RyaW5nKCkge1xuICAgIGNvbnN0IHN0cmluZ0xpdGVyYWwgPSB0aGlzLmdldFN0cmluZ0xpdGVyYWwoKSxcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmdGcm9tU3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsKTtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICBnZXRTdHJpbmdMaXRlcmFsKCkge1xuICAgIGxldCBzdHJpbmdMaXRlcmFsO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1RSSU5HX0xJVEVSQUxfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgc3RyaW5nTGl0ZXJhbCA9IGNvbnRlbnQ7ICAvLy9cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTm9kZVF1ZXJ5Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBTT01FX1JVTEVfTkFNRSxcbiAgICAgICAgIEVWRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFRFVDRV9SVUxFX05BTUUsXG4gICAgICAgICBURVJOQVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgTk9ERVNfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgUkVUVVJOX0JMT0NLX1JVTEVfTkFNRSxcbiAgICAgICAgIFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhwcmVzc2lvbk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm1Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cblxuICBnZXRTb21lTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFNPTUVfUlVMRV9OQU1FLFxuICAgICAgICAgIHNvbWVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gc29tZU5vZGU7XG4gIH1cblxuICBnZXRFdmVyeU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBFVkVSWV9SVUxFX05BTUUsXG4gICAgICAgICAgZXZlcnlOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gZXZlcnlOb2RlO1xuICB9XG5cbiAgZ2V0UmVkdWNlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFRFVDRV9SVUxFX05BTUUsXG4gICAgICAgICAgcmVkdWNlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHJlZHVjZU5vZGU7XG4gIH1cblxuICBnZXRUZXJuYXJ5Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk5BUllfUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm5hcnlOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybmFyeU5vZGU7XG4gIH1cblxuICBnZXROb2RlUXVlcnlOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTk9ERV9RVUVSWV9SVUxFX05BTUUsXG4gICAgICAgICAgbm9kZVF1ZXJ5Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5vZGVRdWVyeU5vZGU7XG4gIH1cblxuICBnZXROb2Rlc1F1ZXJ5Tm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5PREVTX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgICBub2RlU1F1ZXJ5Tm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIG5vZGVTUXVlcnlOb2RlO1xuICB9XG5cbiAgZ2V0UmV0dXJuQmxvY2tOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUkVUVVJOX0JMT0NLX1JVTEVfTkFNRSxcbiAgICAgICAgICByZXR1cm5CbG9ja05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiByZXR1cm5CbG9ja05vZGU7XG4gIH1cblxuICBnZXRQcm9jZWR1cmVDYWxsTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSxcbiAgICAgICAgICBwcm9jZWR1cmVDYWxsTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHByb2NlZHVyZUNhbGxOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShFeHByZXNzaW9uTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgUEFSQU1FVEVSX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFyYW10ZXJzTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFBhcmFtZXRlck5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgICBwYXJhbWV0ZXJOb2RlcyA9IHRoaXMuZ2V0Tm9kZXNCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJOb2RlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7XG4gICAgaWYgKHByZWNlZGVuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJlY2VkZW5jZSA9IG9wYWNpdHk7IC8vL1xuXG4gICAgICBvcGFjaXR5ID0gY2hpbGROb2RlczsgLy8vXG5cbiAgICAgIGNoaWxkTm9kZXMgPSBydWxlTmFtZTsgIC8vL1xuXG4gICAgICBydWxlTmFtZSA9IENsYXNzOyAvLy9cblxuICAgICAgQ2xhc3MgPSBQYXJhbXRlcnNOb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtZXRlcnNOb2RlID0gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpO1xuXG4gICAgcmV0dXJuIHBhcmFtZXRlcnNOb2RlO1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuaW1wb3J0IHsgc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ0xpdGVyYWxcIjtcbmltcG9ydCB7IFNUUklOR19MSVRFUkFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb2Rlc1F1ZXJ5Tm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGdldFN0cmluZygpIHtcbiAgICBjb25zdCBzdHJpbmdMaXRlcmFsID0gdGhpcy5nZXRTdHJpbmdMaXRlcmFsKCksXG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nRnJvbVN0cmluZ0xpdGVyYWwoc3RyaW5nTGl0ZXJhbCk7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgZ2V0U3RyaW5nTGl0ZXJhbCgpIHtcbiAgICBsZXQgc3RyaW5nTGl0ZXJhbCA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBTVFJJTkdfTElURVJBTF9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBzdHJpbmdMaXRlcmFsID0gY29udGVudDsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIHN0cmluZ0xpdGVyYWw7XG4gIH1cblxuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShOb2Rlc1F1ZXJ5Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgU1RFUF9SVUxFX05BTUUsIE5PTlNFTlNFX1JVTEVfTkFNRSwgUkVUVVJOX1NUQVRFTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldHVybkJsb2NrTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIGlzTm9uc2Vuc2ljYWwoKSB7XG4gICAgY29uc3Qgbm9uc2Vuc2VOb2RlcyA9IHRoaXMuZ2V0Tm9uc2Vuc2VOb2RlcygpLFxuICAgICAgICAgIG5vbnNlbnNlTm9kZXNMZW5ndGggPSBub25zZW5zZU5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBub25zZW5zaWNhbCA9IChub25zZW5zZU5vZGVzTGVuZ3RoID4gMCk7XG5cbiAgICByZXR1cm4gbm9uc2Vuc2ljYWw7XG4gIH1cblxuICBnZXRTdGVwTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBTVEVQX1JVTEVfTkFNRSxcbiAgICAgICAgICBzdGVwTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gc3RlcE5vZGVzO1xuICB9XG5cbiAgZ2V0Tm9uc2Vuc2VOb2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5PTlNFTlNFX1JVTEVfTkFNRSxcbiAgICAgICAgICBub25zZW5zZU5vZGVzID0gdGhpcy5nZXROb2Rlc0J5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgICByZXR1cm4gbm9uc2Vuc2VOb2RlcztcbiAgfVxuXG4gIGdldFJldHVyblN0YXRlbWVudE5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBSRVRVUk5fU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgICByZXR1cm5TdGF0ZW1lbnQgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiByZXR1cm5TdGF0ZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFJldHVybkJsb2NrTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGFycmF5VXRpbGl0aWVzIH0gZnJvbSBcIm5lY2Vzc2FyeVwiO1xuXG5pbXBvcnQgVGVybU5vZGUgZnJvbSBcIi4uLy4uL25vZGUvdGVybVwiO1xuXG5pbXBvcnQgeyBURVJNX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcbmltcG9ydCB7IFNQRUNJQUxfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi8uLi90b2tlblR5cGVzXCI7XG5pbXBvcnQgeyBDT05KVU5DVElPTl9PUEVSQVRPUiwgRElTSlVOQ1RJT05fT1BFUkFUT1IgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IHsgZmlyc3QsIGxhc3QgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dpY2FsVGVybU5vZGUgZXh0ZW5kcyBUZXJtTm9kZSB7XG4gIGdldE9wZXJhdG9yKCkge1xuICAgIGxldCBvcGVyYXRvciA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBTUEVDSUFMX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIG9wZXJhdG9yID0gY29udGVudDsgLy8vXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gb3BlcmF0b3I7XG4gIH1cblxuICBpc0NvbmplY3Rpb24oKSB7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLmdldE9wZXJhdG9yKCksXG4gICAgICAgICAgY29uamVjdGlvbiA9IChvcGVyYXRvciA9PT0gQ09OSlVOQ1RJT05fT1BFUkFUT1IpO1xuXG4gICAgcmV0dXJuIGNvbmplY3Rpb247XG4gIH1cblxuICBpc0Rpc2p1bmN0aW9uKCkge1xuICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5nZXRPcGVyYXRvcigpLFxuICAgICAgICAgIGRpc2p1bmN0aW9uID0gKG9wZXJhdG9yID09PSBESVNKVU5DVElPTl9PUEVSQVRPUik7XG5cbiAgICByZXR1cm4gZGlzanVuY3Rpb247XG4gIH1cblxuICBnZXRUZXJtTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGVzO1xuICB9XG5cbiAgZ2V0TGVmdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IGZpcnN0RXhwcmVzaW9uTm9kZSA9IHRoaXMuZ2V0Rmlyc3RUZXJtTm9kZSgpLFxuICAgICAgICAgIGxlZnRUZXJtTm9kZSA9IGZpcnN0RXhwcmVzaW9uTm9kZTsgIC8vL1xuXG4gICAgcmV0dXJuIGxlZnRUZXJtTm9kZTtcbiAgfVxuXG4gIGdldFJpZ2h0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgbGFzdFRlcm1Ob2RlID0gdGhpcy5nZXRMYXN0VGVybU5vZGUoKSxcbiAgICAgICAgICByaWdodFRlcm1Ob2RlID0gbGFzdFRlcm1Ob2RlOyAvLy9cblxuICAgIHJldHVybiByaWdodFRlcm1Ob2RlO1xuICB9XG5cbiAgZ2V0TGFzdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgbGFzdFRlcm1Ob2RlID0gbGFzdCh0ZXJtTm9kZXMpO1xuXG4gICAgcmV0dXJuIGxhc3RUZXJtTm9kZTtcbiAgfVxuXG4gIGdldEZpcnN0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgdGVybU5vZGVzID0gdGhpcy5nZXRUZXJtTm9kZXMoKSxcbiAgICAgICAgICBmaXJzdFRlcm1Ob2RlID0gZmlyc3QodGVybU5vZGVzKTtcblxuICAgIHJldHVybiBmaXJzdFRlcm1Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gVGVybU5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKExvZ2ljYWxUZXJtTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXJtTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS90ZXJtXCI7XG5cbmltcG9ydCB7IFRFUk1fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZWdhdGVkVGVybU5vZGUgZXh0ZW5kcyBUZXJtTm9kZSB7XG4gIGdldFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICAgdGVybU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB0ZXJtTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFRlcm1Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShOZWdhdGVkVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBOb25UZXJtaW5hbE5vZGUgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IFRFUk1TX1JVTEVfTkFNRSwgUkVGRVJFTkNFX1JVTEVfTkFNRSB9IGZyb20gXCIuLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvY2VkdXJlQ2FsbE5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBnZXRUZXJtc05vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNU19SVUxFX05BTUUsXG4gICAgICAgICAgdGVybXNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybXNOb2RlO1xuICB9XG5cbiAgZ2V0UmVmZXJlbmNlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFRkVSRU5DRV9SVUxFX05BTUUsXG4gICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHJlZmVyZW5jZU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFByb2NlZHVyZUNhbGxOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRlcm1Ob2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1cIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyYWNrZXRlZFRlcm1Ob2RlIGV4dGVuZHMgVGVybU5vZGUge1xuICBnZXRUZXJtTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFRFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgIHRlcm1Ob2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBUZXJtTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQnJhY2tldGVkVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IFRlcm1Ob2RlIGZyb20gXCIuLi8uLi9ub2RlL3Rlcm1cIjtcblxuaW1wb3J0IHsgTk9UX0VRVUFMX1RPIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBTUEVDSUFMX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuXG5jb25zdCB7IGZpcnN0LCBzZWNvbmQgfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wYXJpc29uVGVybU5vZGUgZXh0ZW5kcyBUZXJtTm9kZSB7XG4gIGlzTmVnYXRlZCgpIHtcbiAgICBsZXQgbmVnYXRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gU1BFQ0lBTF9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBpZiAoY29udGVudCA9PT0gTk9UX0VRVUFMX1RPKSB7XG4gICAgICAgIG5lZ2F0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIG5lZ2F0ZWQ7XG4gIH1cblxuICBnZXRUZXJtTm9kZXMoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdGVybU5vZGVzO1xuICB9XG5cbiAgZ2V0TGVmdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IGZpcnN0VGVybU5vZGUgPSB0aGlzLmdldEZpcnN0VGVybU5vZGUoKSxcbiAgICAgICAgICBsZWZ0VGVybU5vZGUgPSBmaXJzdFRlcm1Ob2RlOyAvLy9cblxuICAgIHJldHVybiBsZWZ0VGVybU5vZGU7XG4gIH1cblxuICBnZXRSaWdodFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHNlY29uZFRlcm1Ob2RlID0gdGhpcy5nZXRTZWNvbmRUZXJtTm9kZSgpLFxuICAgICAgICAgIHJpZ2h0VGVybU5vZGUgPSBzZWNvbmRUZXJtTm9kZTsgIC8vL1xuXG4gICAgcmV0dXJuIHJpZ2h0VGVybU5vZGU7XG4gIH1cblxuICBnZXRGaXJzdFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgZmlyc3RUZXJtTm9kZSA9IGZpcnN0KHRlcm1Ob2Rlcyk7XG5cbiAgICByZXR1cm4gZmlyc3RUZXJtTm9kZTtcbiAgfVxuXG4gIGdldFNlY29uZFRlcm1Ob2RlKCkge1xuICAgIGNvbnN0IHRlcm1Ob2RlcyA9IHRoaXMuZ2V0VGVybU5vZGVzKCksXG4gICAgICAgICAgc2Vjb25kVGVybU5vZGUgPSBzZWNvbmQodGVybU5vZGVzKTtcblxuICAgIHJldHVybiBzZWNvbmRUZXJtTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFRlcm1Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDb21wYXJpc29uVGVybU5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFyYW10ZXJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL3BhcmFtZXRlclwiO1xuXG5pbXBvcnQgeyBOQU1FX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYW1lZFBhcmFtdGVyTm9kZSBleHRlbmRzIFBhcmFtdGVyTm9kZSB7XG4gIGdldEFsaWFzKCkge1xuICAgIGxldCBhbGlhcyA9IG51bGw7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBOQU1FX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgICBhbGlhcyA9IGNvbnRlbnQ7IC8vXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiBhbGlhcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIFBhcmFtdGVyTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZWRQYXJhbXRlck5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgUGFyYW10ZXJzTm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9wYXJhbWV0ZXJzXCI7XG5cbmltcG9ydCB7IE5BTUVEX1BBUkFNRVRFUl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hbWVkUGFyYW10ZXJzTm9kZSBleHRlbmRzIFBhcmFtdGVyc05vZGUge1xuICBnZXROYW1lZFBhcmFtZXRlck5vZGVzKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgICBuYW1lZFBhcmFtdGVyTm9kZXMgPSB0aGlzLmdldE5vZGVzQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gbmFtZWRQYXJhbXRlck5vZGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gUGFyYW10ZXJzTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoTmFtZWRQYXJhbXRlcnNOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZW1lbnROb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RhdGVtZW50Tm9kZSBmcm9tIFwiLi4vLi4vbm9kZS9zdGF0ZW1lbnRcIjtcblxuaW1wb3J0IHsgVEVSTV9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJldHVyblN0YXRlbWVudE5vZGUgZXh0ZW5kcyBTdGF0ZW1lbnROb2RlIHtcbiAgZ2V0VGVybU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgICB0ZXJtTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHRlcm1Ob2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gU3RhdGVtZW50Tm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoUmV0dXJuU3RhdGVtZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXNzaWdubWVudHJOb2RlIGV4dGVuZHMgTm9uVGVybWluYWxOb2RlIHtcbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIE5vblRlcm1pbmFsTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXNzaWdubWVudHJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL2Fzc2lnbm1lbnRcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBQQVJBTUVURVJTX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJyYXlBc3NpZ25tZW50Tm9kZSBleHRlbmRzIEFzc2lnbm1lbnRyTm9kZSB7XG4gIGdldFZhcmlhYmxlTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgICB2YXJpYWJsZU5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZU5vZGU7XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJzTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFBBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgIHBhcmFtZXRlcnNOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcGFyYW1ldGVyc05vZGU7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBBc3NpZ25tZW50ck5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKEFycmF5QXNzaWdubWVudE5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgQXNzaWdubWVudHJOb2RlIGZyb20gXCIuLi8uLi9ub2RlL2Fzc2lnbm1lbnRcIjtcblxuaW1wb3J0IHsgVkFSSUFCTEVfUlVMRV9OQU1FLCBOQU1FRF9QQVJBTUVURVJTX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0QXNzaWdubWVudE5vZGUgZXh0ZW5kcyBBc3NpZ25tZW50ck5vZGUge1xuICBnZXRWYXJpYWJsZU5vZGUoKSB7XG4gICAgY29uc3QgcnVsZU5hbWUgPSBWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgICAgdmFyaWFibGVOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdmFyaWFibGVOb2RlO1xuICB9XG5cbiAgZ2V0TmFtZWRQYXJhbWV0ZXJzTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IE5BTUVEX1BBUkFNRVRFUlNfUlVMRV9OQU1FLFxuICAgICAgICAgIG5hbWVkUGFyYW1ldGVyc05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBuYW1lZFBhcmFtZXRlcnNOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gQXNzaWdubWVudHJOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShPYmplY3RBc3NpZ25tZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvY2VkdXJlTm9kZSBleHRlbmRzIE5vblRlcm1pbmFsTm9kZSB7XG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQ2xhc3MsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBOb25UZXJtaW5hbE5vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb2NlZHVyZU5vZGUgZnJvbSBcIi4uLy4uL25vZGUvcHJvY2VkdXJlXCI7XG5cbmltcG9ydCB7IFRZUEVfVE9LRU5fVFlQRSB9IGZyb20gXCIuLi8uLi90b2tlblR5cGVzXCI7XG5pbXBvcnQgeyBQQVJBTUVURVJTX1JVTEVfTkFNRSwgUkVUVVJOX0JMT0NLX1JVTEVfTkFNRSB9IGZyb20gXCIuLi8uLi9ydWxlTmFtZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5vbnltb3VzUHJvY2VkdXJlTm9kZSBleHRlbmRzIFByb2NlZHVyZU5vZGUge1xuICBnZXRUeXBlKCkge1xuICAgIGxldCB0eXBlO1xuXG4gICAgY29uc3QgdG9rZW5UeXBlID0gVFlQRV9UT0tFTl9UWVBFO1xuXG4gICAgdGhpcy5zb21lVGVybWluYWxOb2RlKCh0ZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICB0eXBlID0gY29udGVudDsgIC8vL1xuICAgIH0sIHRva2VuVHlwZSk7XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnNOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICAgcGFyYW1ldGVyc05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJzTm9kZTtcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICAgcmV0dXJuQmxvY2tOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcmV0dXJuQmxvY2tOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gUHJvY2VkdXJlTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoQW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBBc3NpZ25tZW50ck5vZGUgZnJvbSBcIi4uLy4uL25vZGUvYXNzaWdubWVudFwiO1xuXG5pbXBvcnQgeyBWQVJJQUJMRV9SVUxFX05BTUUsIEVYUFJFU1NJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uLy4uL3J1bGVOYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnROb2RlIGV4dGVuZHMgQXNzaWdubWVudHJOb2RlIHtcbiAgZ2V0VmFyaWFibGVOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlTm9kZTtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb25Ob2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICAgZXhwcmVzc2lvbk5vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBleHByZXNzaW9uTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UocnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpIHsgcmV0dXJuIEFzc2lnbm1lbnRyTm9kZS5mcm9tUnVsZU5hbWVDaGlsZE5vZGVzT3BhY2l0eUFuZFByZWNlZGVuY2UoVmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBBc3NpZ25tZW50c05vZGUgZnJvbSBcIi4uLy4uL25vZGUvYXNzaWdubWVudFwiO1xuXG5pbXBvcnQgeyBUWVBFX1RPS0VOX1RZUEUgfSBmcm9tIFwiLi4vLi4vdG9rZW5UeXBlc1wiO1xuaW1wb3J0IHsgVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhcmlhYmxlQXNzaWdubWVudHNOb2RlIGV4dGVuZHMgQXNzaWdubWVudHNOb2RlIHtcbiAgZ2V0VHlwZSgpIHtcbiAgICBsZXQgdHlwZTtcblxuICAgIGNvbnN0IHRva2VuVHlwZSA9IFRZUEVfVE9LRU5fVFlQRTtcblxuICAgIHRoaXMuc29tZVRlcm1pbmFsTm9kZSgodGVybWluYWxOb2RlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgdHlwZSA9IGNvbnRlbnQ7ICAvLy9cbiAgICB9LCB0b2tlblR5cGUpO1xuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRWYXJpYWJsZUFzc2lnbm1lbnROb2RlcygpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgIHZhcmlhYmxlQXNzaW5nbm1lbnROb2RzcyA9IHRoaXMuZ2V0Tm9kZXNCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYWJsZUFzc2luZ25tZW50Tm9kc3M7XG4gIH1cblxuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKSB7IHJldHVybiBBc3NpZ25tZW50c05vZGUuZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKFZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSk7IH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgTm9uVGVybWluYWxOb2RlIH0gZnJvbSBcIm9jY2FtLWxhbmd1YWdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNsYXJhdGlvbk5vZGUgZXh0ZW5kcyBOb25UZXJtaW5hbE5vZGUge1xuICBzdGF0aWMgZnJvbVJ1bGVOYW1lQ2hpbGROb2Rlc09wYWNpdHlBbmRQcmVjZWRlbmNlKENsYXNzLCBydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gTm9uVGVybWluYWxOb2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShDbGFzcywgcnVsZU5hbWUsIGNoaWxkTm9kZXMsIG9wYWNpdHksIHByZWNlZGVuY2UpOyB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEZWNsYXJhdGlvbk5vZGUgZnJvbSBcIi4uLy4uL25vZGUvZGVjbGFyYXRpb25cIjtcblxuaW1wb3J0IHsgVFlQRV9UT0tFTl9UWVBFIH0gZnJvbSBcIi4uLy4uL3Rva2VuVHlwZXNcIjtcbmltcG9ydCB7IExBQkVMX1JVTEVfTkFNRSwgUEFSQU1FVEVSU19SVUxFX05BTUUsIFJFVFVSTl9CTE9DS19SVUxFX05BTUUgfSBmcm9tIFwiLi4vLi4vcnVsZU5hbWVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSBleHRlbmRzIERlY2xhcmF0aW9uTm9kZSB7XG4gIGdldFR5cGUoKSB7XG4gICAgbGV0IHR5cGU7XG5cbiAgICBjb25zdCB0b2tlblR5cGUgPSBUWVBFX1RPS0VOX1RZUEU7XG5cbiAgICB0aGlzLnNvbWVUZXJtaW5hbE5vZGUoKHRlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCk7XG5cbiAgICAgIHR5cGUgPSBjb250ZW50OyAgLy8vXG4gICAgfSwgdG9rZW5UeXBlKTtcblxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZ2V0TGFiZWxOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gTEFCRUxfUlVMRV9OQU1FLFxuICAgICAgICAgIGxhYmVsTm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5UnVsZU5hbWUocnVsZU5hbWUpO1xuXG4gICAgcmV0dXJuIGxhYmVsTm9kZTtcbiAgfVxuXG4gIGdldFBhcmFtZXRlcnNOb2RlKCkge1xuICAgIGNvbnN0IHJ1bGVOYW1lID0gUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICAgcGFyYW1ldGVyc05vZGUgPSB0aGlzLmdldE5vZGVCeVJ1bGVOYW1lKHJ1bGVOYW1lKTtcblxuICAgIHJldHVybiBwYXJhbWV0ZXJzTm9kZTtcbiAgfVxuXG4gIGdldFJldHVybkJsb2NrTm9kZSgpIHtcbiAgICBjb25zdCBydWxlTmFtZSA9IFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICAgcmV0dXJuQmxvY2tOb2RlID0gdGhpcy5nZXROb2RlQnlSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICByZXR1cm4gcmV0dXJuQmxvY2tOb2RlO1xuICB9XG5cbiAgc3RhdGljIGZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShydWxlTmFtZSwgY2hpbGROb2Rlcywgb3BhY2l0eSwgcHJlY2VkZW5jZSkgeyByZXR1cm4gRGVjbGFyYXRpb25Ob2RlLmZyb21SdWxlTmFtZUNoaWxkTm9kZXNPcGFjaXR5QW5kUHJlY2VkZW5jZShQcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIHJ1bGVOYW1lLCBjaGlsZE5vZGVzLCBvcGFjaXR5LCBwcmVjZWRlbmNlKTsgfVxufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgU3RlcE5vZGUgZnJvbSBcIi4vbm9kZS9zdGVwXCI7XG5pbXBvcnQgU29tZU5vZGUgZnJvbSBcIi4vbm9kZS9zb21lXCI7XG5pbXBvcnQgVGVybU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJtXCI7XG5pbXBvcnQgVGVybXNOb2RlIGZyb20gXCIuL25vZGUvdGVybXNcIjtcbmltcG9ydCBFdmVyeU5vZGUgZnJvbSBcIi4vbm9kZS9ldmVyeVwiO1xuaW1wb3J0IExhYmVsTm9kZSBmcm9tIFwiLi9ub2RlL2xhYmVsXCI7XG5pbXBvcnQgRXJyb3JOb2RlIGZyb20gXCIuL25vZGUvZXJyb3JcIjtcbmltcG9ydCBSZWR1Y2VOb2RlIGZyb20gXCIuL25vZGUvcmVkdWNlXCI7XG5pbXBvcnQgVGVybmFyeU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJuYXJ5XCI7XG5pbXBvcnQgRG9jdW1lbnROb2RlIGZyb20gXCIuL25vZGUvZG9jdW1lbnRcIjtcbmltcG9ydCBWYXJpYWJsZU5vZGUgZnJvbSBcIi4vbm9kZS92YXJpYWJsZVwiO1xuaW1wb3J0IE5vbnNlbnNlTm9kZSBmcm9tIFwiLi9ub2RlL25vbnNlbnNlXCI7XG5pbXBvcnQgUHJpbWl0aXZlTm9kZSBmcm9tIFwiLi9ub2RlL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IFJlZmVyZW5jZU5vZGUgZnJvbSBcIi4vbm9kZS9yZWZlcmVuY2VcIjtcbmltcG9ydCBQYXJhbWV0ZXJOb2RlIGZyb20gXCIuL25vZGUvcGFyYW1ldGVyXCI7XG5pbXBvcnQgTm9kZVF1ZXJ5Tm9kZSBmcm9tIFwiLi9ub2RlL25vZGVRdWVyeVwiO1xuaW1wb3J0IEV4cHJlc3Npb25Ob2RlIGZyb20gXCIuL25vZGUvZXhwcmVzc2lvblwiO1xuaW1wb3J0IFBhcmFtZXRlcnNOb2RlIGZyb20gXCIuL25vZGUvcGFyYW1ldGVyc1wiO1xuaW1wb3J0IE5vZGVzUXVlcnlOb2RlIGZyb20gXCIuL25vZGUvbm9kZXNRdWVyeVwiO1xuaW1wb3J0IFJldHVybkJsb2NrTm9kZSBmcm9tIFwiLi9ub2RlL3JldHVybkJsb2NrXCI7XG5pbXBvcnQgTG9naWNhbFRlcm1Ob2RlIGZyb20gXCIuL25vZGUvdGVybS9sb2dpY2FsXCI7XG5pbXBvcnQgTmVnYXRlZFRlcm1Ob2RlIGZyb20gXCIuL25vZGUvdGVybS9uZWdhdGVkXCI7XG5pbXBvcnQgUHJvY2VkdXJlQ2FsbE5vZGUgZnJvbSBcIi4vbm9kZS9wcm9jZWR1cmVDYWxsXCI7XG5pbXBvcnQgQnJhY2tldGVkVGVybU5vZGUgZnJvbSBcIi4vbm9kZS90ZXJtL2JyYWNrZXRlZFwiO1xuaW1wb3J0IENvbXBhcmlzb25UZXJtTm9kZSBmcm9tIFwiLi9ub2RlL3Rlcm0vY29tcGFyaXNvblwiO1xuaW1wb3J0IE5hbWVkUGFyYW1ldGVyTm9kZSBmcm9tIFwiLi9ub2RlL3BhcmFtZXRlci9uYW1lZFwiO1xuaW1wb3J0IE5hbWVkUGFyYW1ldGVyc05vZGUgZnJvbSBcIi4vbm9kZS9wYXJhbWV0ZXJzL25hbWVkXCI7XG5pbXBvcnQgUmV0dXJuU3RhdGVtZW50Tm9kZSBmcm9tIFwiLi9ub2RlL3N0YXRlbWVudC9yZXR1cm5cIjtcbmltcG9ydCBBcnJheUFzc2lnbm1lbnROb2RlIGZyb20gXCIuL25vZGUvYXNzaWdubWVudC9hcnJheVwiO1xuaW1wb3J0IE9iamVjdEFzc2lnbm1lbnROb2RlIGZyb20gXCIuL25vZGUvYXNzaWdubWVudC9vYmplY3RcIjtcbmltcG9ydCBBbm9ueW1vdXNQcm9jZWR1cmVOb2RlIGZyb20gXCIuL25vZGUvcHJvY2VkdXJlL2Fub3ltb3VzXCI7XG5pbXBvcnQgVmFyaWFibGVBc3NpZ25tZW50Tm9kZSBmcm9tIFwiLi9ub2RlL2Fzc2lnbm1lbnQvdmFyaWFibGVcIjtcbmltcG9ydCBWYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSBmcm9tIFwiLi9ub2RlL2Fzc2lnbm1lbnRzL3ZhcmlhYmxlXCI7XG5pbXBvcnQgUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlIGZyb20gXCIuL25vZGUvZGVjbGFyYXRpb24vcHJvY2VkdXJlXCI7XG5cbmltcG9ydCB7IFNURVBfUlVMRV9OQU1FLFxuICAgICAgICAgU09NRV9SVUxFX05BTUUsXG4gICAgICAgICBURVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIFRFUk1TX1JVTEVfTkFNRSxcbiAgICAgICAgIEVWRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIExBQkVMX1JVTEVfTkFNRSxcbiAgICAgICAgIEVSUk9SX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFRFVDRV9SVUxFX05BTUUsXG4gICAgICAgICBURVJOQVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIERPQ1VNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PTlNFTlNFX1JVTEVfTkFNRSxcbiAgICAgICAgIFBSSU1JVElWRV9SVUxFX05BTUUsXG4gICAgICAgICBSRUZFUkVOQ0VfUlVMRV9OQU1FLFxuICAgICAgICAgUEFSQU1FVEVSX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVfUVVFUllfUlVMRV9OQU1FLFxuICAgICAgICAgRVhQUkVTU0lPTl9SVUxFX05BTUUsXG4gICAgICAgICBQQVJBTUVURVJTX1JVTEVfTkFNRSxcbiAgICAgICAgIE5PREVTX1FVRVJZX1JVTEVfTkFNRSxcbiAgICAgICAgIFJFVFVSTl9CTE9DS19SVUxFX05BTUUsXG4gICAgICAgICBMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FLFxuICAgICAgICAgTkVHQVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIEJSQUNLRVRFRF9URVJNX1JVTEVfTkFNRSxcbiAgICAgICAgIFBST0NFRFVSRV9DQUxMX1JVTEVfTkFNRSxcbiAgICAgICAgIENPTVBBUklTT05fVEVSTV9SVUxFX05BTUUsXG4gICAgICAgICBOQU1FRF9QQVJBTUVURVJfUlVMRV9OQU1FLFxuICAgICAgICAgTkFNRURfUEFSQU1FVEVSU19SVUxFX05BTUUsXG4gICAgICAgICBSRVRVUk5fU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIEFSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgT0JKRUNUX0FTU0lHTk1FTlRfUlVMRV9OQU1FLFxuICAgICAgICAgVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUUsXG4gICAgICAgICBBTk9OWU1PVVNfUFJPQ0VEVVJFX1JVTEVfTkFNRSxcbiAgICAgICAgIFZBUklBQkxFX0FTU0lHTk1FTlRTX1JVTEVfTkFNRSxcbiAgICAgICAgIFBST0NFRFVSRV9ERUNMQVJBVElPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi9ydWxlTmFtZXNcIjtcblxuY29uc3QgTm9uVGVybWluYWxOb2RlTWFwID0ge1xuICBbU1RFUF9SVUxFX05BTUVdOiBTdGVwTm9kZSxcbiAgW1NPTUVfUlVMRV9OQU1FXTogU29tZU5vZGUsXG4gIFtURVJNX1JVTEVfTkFNRV06IFRlcm1Ob2RlLFxuICBbVEVSTVNfUlVMRV9OQU1FXTogVGVybXNOb2RlLFxuICBbRVZFUllfUlVMRV9OQU1FXTogRXZlcnlOb2RlLFxuICBbTEFCRUxfUlVMRV9OQU1FXTogTGFiZWxOb2RlLFxuICBbRVJST1JfUlVMRV9OQU1FXTogRXJyb3JOb2RlLFxuICBbUkVEVUNFX1JVTEVfTkFNRV06IFJlZHVjZU5vZGUsXG4gIFtURVJOQVJZX1JVTEVfTkFNRV06IFRlcm5hcnlOb2RlLFxuICBbVkFSSUFCTEVfUlVMRV9OQU1FXTogVmFyaWFibGVOb2RlLFxuICBbTk9OU0VOU0VfUlVMRV9OQU1FXTogTm9uc2Vuc2VOb2RlLFxuICBbRE9DVU1FTlRfUlVMRV9OQU1FXTogRG9jdW1lbnROb2RlLFxuICBbUFJJTUlUSVZFX1JVTEVfTkFNRV06IFByaW1pdGl2ZU5vZGUsXG4gIFtSRUZFUkVOQ0VfUlVMRV9OQU1FXTogUmVmZXJlbmNlTm9kZSxcbiAgW1BBUkFNRVRFUl9SVUxFX05BTUVdOiBQYXJhbWV0ZXJOb2RlLFxuICBbTk9ERV9RVUVSWV9SVUxFX05BTUVdOiBOb2RlUXVlcnlOb2RlLFxuICBbRVhQUkVTU0lPTl9SVUxFX05BTUVdOiBFeHByZXNzaW9uTm9kZSxcbiAgW1BBUkFNRVRFUlNfUlVMRV9OQU1FXTogUGFyYW1ldGVyc05vZGUsXG4gIFtOT0RFU19RVUVSWV9SVUxFX05BTUVdOiBOb2Rlc1F1ZXJ5Tm9kZSxcbiAgW1JFVFVSTl9CTE9DS19SVUxFX05BTUVdOiBSZXR1cm5CbG9ja05vZGUsXG4gIFtMT0dJQ0FMX1RFUk1fUlVMRV9OQU1FXTogTG9naWNhbFRlcm1Ob2RlLFxuICBbTkVHQVRFRF9URVJNX1JVTEVfTkFNRV06IE5lZ2F0ZWRUZXJtTm9kZSxcbiAgW1BST0NFRFVSRV9DQUxMX1JVTEVfTkFNRV06IFByb2NlZHVyZUNhbGxOb2RlLFxuICBbQlJBQ0tFVEVEX1RFUk1fUlVMRV9OQU1FXTogQnJhY2tldGVkVGVybU5vZGUsXG4gIFtDT01QQVJJU09OX1RFUk1fUlVMRV9OQU1FXTogQ29tcGFyaXNvblRlcm1Ob2RlLFxuICBbTkFNRURfUEFSQU1FVEVSX1JVTEVfTkFNRV06IE5hbWVkUGFyYW1ldGVyTm9kZSxcbiAgW05BTUVEX1BBUkFNRVRFUlNfUlVMRV9OQU1FXTogTmFtZWRQYXJhbWV0ZXJzTm9kZSxcbiAgW1JFVFVSTl9TVEFURU1FTlRfUlVMRV9OQU1FXTogUmV0dXJuU3RhdGVtZW50Tm9kZSxcbiAgW0FSUkFZX0FTU0lHTk1FTlRfUlVMRV9OQU1FXTogQXJyYXlBc3NpZ25tZW50Tm9kZSxcbiAgW09CSkVDVF9BU1NJR05NRU5UX1JVTEVfTkFNRV06IE9iamVjdEFzc2lnbm1lbnROb2RlLFxuICBbQU5PTllNT1VTX1BST0NFRFVSRV9SVUxFX05BTUVdOiBBbm9ueW1vdXNQcm9jZWR1cmVOb2RlLFxuICBbVkFSSUFCTEVfQVNTSUdOTUVOVF9SVUxFX05BTUVdOiBWYXJpYWJsZUFzc2lnbm1lbnROb2RlLFxuICBbVkFSSUFCTEVfQVNTSUdOTUVOVFNfUlVMRV9OQU1FXTogVmFyaWFibGVBc3NpZ25tZW50c05vZGUsXG4gIFtQUk9DRURVUkVfREVDTEFSQVRJT05fUlVMRV9OQU1FXTogUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOb25UZXJtaW5hbE5vZGVNYXA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE5vblRlcm1pbmFsTm9kZSB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgRnVydGxlUGFyc2VyIGFzIEZ1cnRsZVBhcnNlckJhc2UgfSBmcm9tIFwib2NjYW0tZ3JhbW1hcnNcIjtcblxuaW1wb3J0IE5vblRlcm1pbmFsTm9kZU1hcCBmcm9tIFwiLi4vbm9uVGVybWluYWxOb2RlTWFwXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1cnRsZVBhcnNlciBleHRlbmRzIEZ1cnRsZVBhcnNlckJhc2Uge1xuICBzdGF0aWMgTm9uVGVybWluYWxOb2RlTWFwID0gTm9uVGVybWluYWxOb2RlTWFwO1xuXG4gIHN0YXRpYyBkZWZhdWx0Tm9uVGVybWluYWxOb2RlID0gTm9uVGVybWluYWxOb2RlO1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJvY2NhbS1xdWVyeVwiO1xuXG5pbXBvcnQgZWxlbWVudHMgZnJvbSBcIi4uL2VsZW1lbnRzXCI7XG5cbmltcG9ydCB7IEJPT0xFQU5fVFlQRSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgdGVybmFyeVN0cmluZ0Zyb21UZXJtLFxuICAgICAgICAgdmFyaWFibGVTdHJpbmdGcm9tTmFtZSxcbiAgICAgICAgIHRlcm1TdHJpbmdGcm9tUHJvcGVydGllcyxcbiAgICAgICAgIGV4cHJlc3Npb25TdHJpbmdGcm9tUHJvcGVydGllcyxcbiAgICAgICAgIHByb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nRnJvbVByb2NlZHVyZSxcbiAgICAgICAgIHJldHVybkJsb2NrU3RyaW5nRnJvbVJldHVyblN0YXRlbWVudE5vZGUsXG4gICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlLFxuICAgICAgICAgc29tZVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSxcbiAgICAgICAgIGV2ZXJ5U3RyaW5nRnJvbVZhcmlhYmxlQW5kQW5vbnltb3VzUHJvY2VkdXJlLFxuICAgICAgICAgcHJvY2VkdXJlU3RyaW5nRnJvbVR5cGVMYWJlbFBhcmFtZXRlcnNBbmRSZXR1cm5CbG9jayxcbiAgICAgICAgIGFub255bW91c1Byb2NlZHVyZVN0cmluZ0Zyb21UeXBlUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrLFxuICAgICAgICAgdmFyaWFibGVBc3NpZ25tZW50U3RyaW5nRnJvbVR5cGVBbmRWYXJpYWJsZUFzc2lnbm1lbnRzQXJyYXksXG4gICAgICAgICByZWR1Y2VTdHJpbmdGcm9tVmFyaWFibGVJbml0aWFsRXhwcmVzc2lvbkFuZEFub255bW91c1Byb2NlZHVyZSB9IGZyb20gXCIuLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwRnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgU3RlcCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBzdGVwTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgYXJyYXlBc3NpZ25tZW50ID0gYXJyYXlBc3NpZ25tZW50RnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgb2JqZWN0QXNzaWdtZW50ID0gb2JqZWN0QXNzaWdubWVudEZyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uID0gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3Qgc3RlcCA9IG5ldyBTdGVwKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXlBc3NpZ25tZW50LCBvYmplY3RBc3NpZ21lbnQsIHZhcmlhYmxlc0RlY2xhcmF0aW9uKTtcblxuICByZXR1cm4gc3RlcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvbWVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBTb21lIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHNvbWVOb2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBzb21lU3RyaW5nID0gc29tZVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSh2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSxcbiAgICAgICAgc3RyaW5nID0gc29tZVN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHNvbWUgPSBuZXcgU29tZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHZhcmlhYmxlLCBhbm9ueW1vdXNQcm9jZWR1cmUpO1xuXG4gIHJldHVybiBzb21lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdGVybU5vZGUsICAvLy9cbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5lZ2F0ZWRUZXJtID0gbmVnYXRlZFRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBsb2dpY2FsVGVybSA9IGxvZ2ljYWxUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgYnJhY2tldGVkVGVybSA9IGJyYWNrZXRlZFRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBjb21wYXJpc29uVGVybSA9IGNvbXBhcmlzb25UZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICB2YXJpYWJsZSxcbiAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgbmVnYXRlZFRlcm0sXG4gICAgICAgICAgbG9naWNhbFRlcm0sXG4gICAgICAgICAgYnJhY2tldGVkVGVybSxcbiAgICAgICAgICBjb21wYXJpc29uVGVybVxuICAgICAgICBdLFxuICAgICAgICB0ZXJtU3RyaW5nID0gdGVybVN0cmluZ0Zyb21Qcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSB0ZXJtU3RyaW5nOyAgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybSA9IG5ldyBUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHByaW1pdGl2ZSwgbmVnYXRlZFRlcm0sIGxvZ2ljYWxUZXJtLCBicmFja2V0ZWRUZXJtLCBjb21wYXJpc29uVGVybSk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0Zyb21UZXJtc05vZGUodGVybXNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgVGVybXMgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdGVybXNOb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHRlcm1Ob2RlcyA9IHRlcm1zTm9kZS5nZXRUZXJtTm9kZXMoKSxcbiAgICAgICAgdGVybXNBcnJheSA9IHRlcm1zQXJyYXlGcm9tVGVybU5vZGVzKHRlcm1Ob2RlcywgY29udGV4dCksXG4gICAgICAgIGFycmF5ID0gdGVybXNBcnJheTsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgdGVybXMgPSBuZXcgVGVybXMoY29udGV4dCwgc3RyaW5nLCBub2RlLCBhcnJheSk7XG5cbiAgcmV0dXJuIHRlcm1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JGcm9tRXJyb3JOb2RlKGVycm9yTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEVycm9yIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGVycm9yTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNvbnRleHQsIHN0cmluZywgbm9kZSk7XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlcnlGcm9tRXZlcnlOb2RlKGV2ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEV2ZXJ5IH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGV2ZXJ5Tm9kZSwgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tRXZlcnlOb2RlKGV2ZXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21FdmVyeU5vZGUoZXZlcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgZXZlcnlTdHJpbmcgPSBldmVyeVN0cmluZ0Zyb21WYXJpYWJsZUFuZEFub255bW91c1Byb2NlZHVyZSh2YXJpYWJsZSwgYW5vbnltb3VzUHJvY2VkdXJlKSxcbiAgICAgICAgc3RyaW5nID0gZXZlcnlTdHJpbmc7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGV2ZXJ5ID0gbmV3IEV2ZXJ5KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGFub255bW91c1Byb2NlZHVyZSk7XG5cbiAgcmV0dXJuIGV2ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxGcm9tTGFiZWxOb2RlKGxhYmVsTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IExhYmVsIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGxhYmVsTm9kZSxcbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIG5hbWUgPSBuYW1lRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IGxhYmVsID0gbmV3IExhYmVsKGNvbnRleHQsIHN0cmluZywgbm9kZSwgbmFtZSk7XG5cbiAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFJlZHVjZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSByZWR1Y2VOb2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgaW5pdGlhbEV4cHJlc3Npb24gPSBpbml0aWFsRXhwcmVzc2lvbkZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBhbm9ueW1vdXNQcm9jZWR1cmUgPSBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmVkdWNlU3RyaW5nID0gcmVkdWNlU3RyaW5nRnJvbVZhcmlhYmxlSW5pdGlhbEV4cHJlc3Npb25BbmRBbm9ueW1vdXNQcm9jZWR1cmUodmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpLFxuICAgICAgICBzdHJpbmcgPSByZWR1Y2VTdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZWR1Y2UgPSBuZXcgUmVkdWNlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIGluaXRpYWxFeHByZXNzaW9uLCBhbm9ueW1vdXNQcm9jZWR1cmUpO1xuXG4gIHJldHVybiByZWR1Y2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJuYXJ5RnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgVGVybmFyeSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSB0ZXJuYXJ5Tm9kZSwgLy8vXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgaWZFeHByZXNzaW9uID0gaWZFeHByZXNzaW9uRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgZWxzZUV4cHJlc3Npb24gPSBlbHNlRXhwcmVzc2lvbkZyb21UZXJuYXJ5Tm9kZSh0ZXJuYXJ5Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHRlcm5hcnlTdHJpbmcgPSB0ZXJuYXJ5U3RyaW5nRnJvbVRlcm0odGVybSksXG4gICAgICAgIHN0cmluZyA9IHRlcm5hcnlTdHJpbmc7IC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm5hcnkgPSBuZXcgVGVybmFyeShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0sIGlmRXhwcmVzc2lvbiwgZWxzZUV4cHJlc3Npb24pO1xuXG4gIHJldHVybiB0ZXJuYXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHZhcmlhYmxlTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5hbWUgPSBuYW1lRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCB2YXJpYWJsZSA9IG5ldyBWYXJpYWJsZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGV4cHJlc3Npb24pO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZUZyb21SZWZlcmVuY2VOb2RlKHJlZmVyZW5jZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBSZWZlcmVuY2UgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcmVmZXJlbmNlTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICBuYW1lID0gbmFtZUZyb21SZWZlcmVuY2VOb2RlKHJlZmVyZW5jZU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHJlZmVyZW5jZSA9IG5ldyBSZWZlcmVuY2UoY29udGV4dCwgc3RyaW5nLCBub2RlLCBuYW1lKTtcblxuICByZXR1cm4gcmVmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyRnJvbVBhcmFtZXRlck5vZGUocGFyYW1ldGVyTm9kZSwgY29udGV4dCkge1xuICBsZXQgcGFyYW1ldGVyID0gbnVsbDtcblxuICBjb25zdCB0eXBlID0gdHlwZUZyb21QYXJhbmV0ZXJOb2RlKHBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgY29uc3QgeyBQYXJhbWV0ZXIgfSA9IGVsZW1lbnRzLFxuICAgICAgICAgIG5vZGUgPSBwYXJhbWV0ZXJOb2RlLCAvLy9cbiAgICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgICBuYW1lID0gbmFtZUZyb21QYXJhbmV0ZXJOb2RlKHBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gICAgY29udGV4dCA9IG51bGw7XG5cbiAgICBwYXJhbWV0ZXIgPSBuZXcgUGFyYW1ldGVyKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1ldGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVF1ZXJ5RnJvbU5vZGVRdWVyeU5vZGUobm9kZVF1ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IE5vZGVRdWVyeSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBub2RlUXVlcnlOb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tTm9kZVF1ZXJ5Tm9kZShub2RlUXVlcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcXVlcnkgPSBxdWVyeUZyb21Ob2RlUXVlcnlOb2RlKG5vZGVRdWVyeU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVRdWVyeSA9IG5ldyBOb2RlUXVlcnkoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgcXVlcnkpO1xuXG4gIHJldHVybiBub2RlUXVlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJpbWl0aXZlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHByaW1pdGl2ZU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUZyb21QcmltaXRpdmVOb2RlKHByaW1pdGl2ZU5vZGUsIGNvbnRleHQpO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByaW1pdGl2ZSA9IG5ldyBQcmltaXRpdmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCB2YWx1ZSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnlGcm9tTm9kZXNRdWVyeU5vZGUobm9kZXNRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOb2Rlc1F1ZXJ5IH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IG5vZGVzUXVlcnlOb2RlLCAgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbU5vZGVzUXVlcnlOb2RlKG5vZGVzUXVlcnlOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcXVlcnkgPSBxdWVyeUZyb21Ob2Rlc1F1ZXJ5Tm9kZShub2Rlc1F1ZXJ5Tm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3Qgbm9kZXNRdWVyeSA9IG5ldyBOb2Rlc1F1ZXJ5KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHF1ZXJ5KTtcblxuICByZXR1cm4gbm9kZXNRdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtZXRlcnNGcm9tUGFyYW1ldGVyc05vZGUocGFyYW1ldGVyc05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQYXJhbWV0ZXJzIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHBhcmFtZXRlcnNOb2RlLCAgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICBwYXJhbXRlcnNBcnJheSA9IHBhcmFtdGVyc0FycmF5RnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgYXJyYXkgPSBwYXJhbXRlcnNBcnJheTsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBQYXJhbWV0ZXJzKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpO1xuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEV4cHJlc3Npb24gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gZXhwcmVzc2lvbk5vZGUsICAvLy9cbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBzb21lID0gc29tZUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIGV2ZXJ5ID0gZXZlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICByZWR1Y2UgPSByZWR1Y2VGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICB0ZXJuYXJ5ID0gdGVybmFyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vZGVRdWVyeSA9IG5vZGVRdWVyeUZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuQmxvY2sgPSByZXR1cm5CbG9ja0Zyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIHByb2NlZHVyZUNhbGwgPSBwcm9jZWR1cmVDYWxsRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICB0ZXJtLFxuICAgICAgICAgIHNvbWUsXG4gICAgICAgICAgZXZlcnksXG4gICAgICAgICAgcmVkdWNlLFxuICAgICAgICAgIHRlcm5hcnksXG4gICAgICAgICAgbm9kZVF1ZXJ5LFxuICAgICAgICAgIG5vZGVzUXVlcnksXG4gICAgICAgICAgcmV0dXJuQmxvY2ssXG4gICAgICAgICAgcHJvY2VkdXJlQ2FsbFxuICAgICAgICBdLFxuICAgICAgICBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvblN0cmluZ0Zyb21Qcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSBleHByZXNzaW9uU3RyaW5nOyAgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdGVybSwgc29tZSwgZXZlcnksIHJlZHVjZSwgdGVybmFyeSwgbm9kZVF1ZXJ5LCBub2Rlc1F1ZXJ5LCByZXR1cm5CbG9jaywgcHJvY2VkdXJlQ2FsbCk7XG5cbiAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5CbG9ja0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUmV0dXJuQmxvY2sgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gcmV0dXJuQmxvY2tOb2RlLCAvLy9cbiAgICAgICAgc3RlcHMgPSBzdGVwc0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgbm9uc2Vuc2ljYWwgPSBub25zZW5zaWNhbEZyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50RnJvbVJldHVybkJsb2NrTm9kZShyZXR1cm5CbG9ja05vZGUsIGNvbnRleHQpLFxuICAgICAgICByZXR1cm5CbG9ja1N0cmluZyA9IHJldHVybkJsb2NrU3RyaW5nRnJvbVJldHVyblN0YXRlbWVudE5vZGUocmV0dXJuU3RhdGVtZW50KSxcbiAgICAgICAgc3RyaW5nID0gcmV0dXJuQmxvY2tTdHJpbmc7ICAvLy9cblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZXR1cm5CbG9jayA9IG5ldyBSZXR1cm5CbG9jayhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHN0ZXBzLCBub25zZW5zaWNhbCwgcmV0dXJuU3RhdGVtZW50KTtcblxuICByZXR1cm4gcmV0dXJuQmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVDYWxsRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUHJvY2VkdXJlQ2FsbCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcm9jZWR1cmVDYWxsTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2VGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpLFxuICAgICAgICB0ZXJtcyA9IHRlcm1zRnJvbVByb2NlZHVyZUNhbGxOb2RlKHByb2NlZHVyZUNhbGxOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBwcm9jZWR1cmVDYWxsID0gbmV3IFByb2NlZHVyZUNhbGwoY29udGV4dCwgc3RyaW5nLCBub2RlLCByZWZlcmVuY2UsIHRlcm1zKTtcblxuICByZXR1cm4gcHJvY2VkdXJlQ2FsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVkUGFyYW1ldGVyRnJvbU5hbWVkUGFyYW1ldGVyTm9kZShuYW1lZFBhcmFtZXRlck5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOYW1lZFBhcmFtZXRlciB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBuYW1lZFBhcmFtZXRlck5vZGUsICAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHR5cGUgPSB0eXBlRnJvbU5hbWVkUGFyYW1ldGVyTm9kZShuYW1lZFBhcmFtZXRlck5vZGUsIGNvbnRleHQpLFxuICAgICAgICBuYW1lID0gbmFtZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgYWxpYXMgPSBhbGlhc0Zyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBuYW1lZFBhcmFtZXRlciA9IG5ldyBOYW1lZFBhcmFtZXRlcihjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIG5hbWUsIGFsaWFzKTtcblxuICByZXR1cm4gbmFtZWRQYXJhbWV0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZFBhcmFtZXRlcnNGcm9tTmFtZWRQYXJhbWV0ZXJzTm9kZShuYW1lZFBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgTmFtZWRQYXJhbWV0ZXJzIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IG5hbWVkUGFyYW1ldGVyc05vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgbmFtZWRQYXJhbWV0ZXJOb2RlcyA9IG5hbWVkUGFyYW1ldGVyc05vZGUuZ2V0TmFtZWRQYXJhbWV0ZXJOb2RlcygpLFxuICAgICAgICBuYW1lZFBhcmFtZXRlcnNBcnJheSA9IG5hbWVkUGFyYW10ZXJzQXJyYXlGcm9tTmFtZWRQYXJhbWV0ZXJOb2RlcyhuYW1lZFBhcmFtZXRlck5vZGVzLCBjb250ZXh0KSxcbiAgICAgICAgYXJyYXkgPSBuYW1lZFBhcmFtZXRlcnNBcnJheTsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgbmFtZWRQYXJhbWV0ZXJzID0gbmV3IE5hbWVkUGFyYW1ldGVycyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gbmFtZWRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlBc3NpZ25tZW50RnJvbUFycmF5QXNzaWdubWVudE5vZGUoYXJyYXlBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEFycmF5QXNzaWdubWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBhcnJheUFzc2lnbm1lbnROb2RlLCAvLy9cbiAgICAgICAgc3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobm9kZSksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCBhcnJheUFzc2lnbm1lbnQgPSBuZXcgQXJyYXlBc3NpZ25tZW50KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdmFyaWFibGUsIHBhcmFtZXRlcnMpO1xuXG4gIHJldHVybiBhcnJheUFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnRGcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgUmV0dXJuU3RhdGVtZW50IH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHJldHVyblN0YXRlbWVudE5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KTtcblxuICBjb250ZXh0ID0gbnVsbDtcblxuICBjb25zdCByZXR1cm5TdGF0ZW1lbnQgPSBuZXcgUmV0dXJuU3RhdGVtZW50KGNvbnRleHQsIHN0cmluZywgbm9kZSwgdGVybSk7XG5cbiAgcmV0dXJuIHJldHVyblN0YXRlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVkUGFyYW1ldGVyc0Zyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuYW1lZFBhcmFtZXRlcnNOb2RlID0gb2JqZWN0QXNzaWdubWVudE5vZGUuZ2V0TmFtZWRQYXJhbWV0ZXJzTm9kZSgpLFxuICAgICAgICBuYW1lZFBhcmFtZXRlcnMgPSBuYW1lZFBhcmFtZXRlcnNGcm9tTmFtZWRQYXJhbWV0ZXJzTm9kZShuYW1lZFBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gbmFtZWRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0QXNzaWdubWVudEZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IE9iamVjdEFzc2lnbWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBvYmplY3RBc3NpZ25tZW50Tm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIG5hbWVkUGFyYW1ldGVycyA9IG5hbWVkUGFyYW1ldGVyc0Zyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3Qgb2JqZWN0QXNzaWdubWVudCA9IG5ldyBPYmplY3RBc3NpZ21lbnQoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgbmFtZWRQYXJhbWV0ZXJzKTtcblxuICByZXR1cm4gb2JqZWN0QXNzaWdubWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBBbm9ueW1vdXNQcm9jZWR1cmUgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgIC8vL1xuICAgICAgICB0eXBlID0gdHlwZUZyb21Qcm9jZWR1cmVBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVyc0Zyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICByZXR1cm5CbG9jayA9IHJldHVybkJsb2NrRnJvbUFub255bW91c1Byb2NlZHVyZU5vZGUoYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5vbnltb3VzUHJvY2VkdXJlU3RyaW5nID0gYW5vbnltb3VzUHJvY2VkdXJlU3RyaW5nRnJvbVR5cGVQYXJhbWV0ZXJzQW5kUmV0dXJuQmxvY2sodHlwZSwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spLFxuICAgICAgICBzdHJpbmcgPSBub255bW91c1Byb2NlZHVyZVN0cmluZzsgLy8vXG5cbiAgY29udGV4dCA9IG51bGw7XG5cbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlID0gbmV3IEFub255bW91c1Byb2NlZHVyZShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIHBhcmFtZXRlcnMsIHJldHVybkJsb2NrKTtcblxuICByZXR1cm4gYW5vbnltb3VzUHJvY2VkdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlQXNzaWdubWVudHMgfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gdmFyaWFibGVBc3NpZ25tZW50c05vZGUsIC8vL1xuICAgICAgICB0eXBlID0gdHlwZUZyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudHNBcnJheSA9IHZhcmlhYmxlQXNzaWdubWVudHNBcnJheUZyb21UeXBlQW5kVmFyaWFibGVBc3NpZ25tZW50c05vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmdGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudHNBcnJheSh0eXBlLCB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkpLFxuICAgICAgICBhcnJheSA9IHZhcmlhYmxlQXNzaWdubWVudHNBcnJheSwgLy8vXG4gICAgICAgIHN0cmluZyA9IHZhcmlhYmxlQXNzaWdubWVudFN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHZhcmlhYmxlQXNzaWdubWVudHMgPSBuZXcgVmFyaWFibGVBc3NpZ25tZW50cyhjb250ZXh0LCBzdHJpbmcsIG5vZGUsIGFycmF5KTtcblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2NlZHVyZURlY2xhcmF0aW9uRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBQcm9jZWR1cmVEZWNsYXJhdGlvbiB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsICAvLy9cbiAgICAgICAgcHJvY2VkdXJlID0gcHJvY2VkdXJlRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZyA9IHByb2NlZHVyZURlY2xhcmF0aW9uU3RyaW5nRnJvbVByb2NlZHVyZShwcm9jZWR1cmUpLFxuICAgICAgICBzdHJpbmcgPSBwcm9jZWR1cmVEZWNsYXJhdGlvblN0cmluZzsgIC8vL1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHByb2NlZHVyZURlY2xhcmF0aW9uID0gbmV3IFByb2NlZHVyZURlY2xhcmF0aW9uKGNvbnRleHQsIHN0cmluZywgbm9kZSwgcHJvY2VkdXJlKTtcblxuICByZXR1cm4gcHJvY2VkdXJlRGVjbGFyYXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbmFtZSA9IGxhYmVsTm9kZS5nZXROYW1lKCk7XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbVRlcm5hcnlOb2RlKHRlcm5hcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1Ob2RlID0gdGVybmFyeU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB0ZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gc29tZU5vZGUuZ2V0VmFyaWFibGVOb2RlKCksIC8vL1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCB2YXJpYWJsZSA9IG51bGw7XG5cbiAgY29uc3QgdmFyaWFibGVOb2RlID0gdGVybU5vZGUuZ2V0VmFyaWFibGVOb2RlKCk7XG5cbiAgaWYgKHZhcmlhYmxlTm9kZSAhPT0gbnVsbCkge1xuICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUpIHtcbiAgY29uc3QgbmFtZSA9IHZhcmlhYmxlTm9kZS5nZXROYW1lKCk7XG5cbiAgcmV0dXJuIG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IG51bGw7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmltaXRpdmVGcm9tVGVybU5vZGUodGVybU5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHByaW1pdGl2ZSA9IG51bGw7XG5cbiAgY29uc3QgcHJpbWl0aXZlTm9kZSA9IHRlcm1Ob2RlLmdldFByaW1pdGl2ZU5vZGUoKTtcblxuICBpZiAocHJpbWl0aXZlTm9kZSAhPT0gbnVsbCkge1xuICAgIHByaW1pdGl2ZSA9IHByaW1pdGl2ZUZyb21QcmltaXRpdmVOb2RlKHByaW1pdGl2ZU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHByaW1pdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbUV2ZXJ5Tm9kZShldmVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gZXZlcnlOb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tUGFyYW5ldGVyTm9kZShwYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBwYXJhbWV0ZXJOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVGcm9tUGFyYW5ldGVyTm9kZShwYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSBwYXJhbWV0ZXJOb2RlLmdldE5hbWUoKTtcblxuICByZXR1cm4gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVGcm9tUmVmZXJlbmNlTm9kZShyZWZlcmVuY2VOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSByZWZlcmVuY2VOb2RlLmdldE5hbWUoKTtcblxuICByZXR1cm4gbmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBwcmltaXRpdmVOb2RlLmdldFR5cGUoKTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSByZWR1Y2VOb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVZhcmlhYmxlTm9kZSh2YXJpYWJsZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiB2YXJpYWJsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IHRlcm1Ob2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0VGVybU5vZGUoKTtcblxuICBpZiAodGVybU5vZGUgIT09IG51bGwpIHtcbiAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvbWVGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHNvbWUgPSBudWxsO1xuXG4gIGNvbnN0IHNvbWVOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0U29tZU5vZGUoKTtcblxuICBpZiAoc29tZU5vZGUgIT09IG51bGwpIHtcbiAgICBzb21lID0gc29tZUZyb21Tb21lTm9kZShzb21lTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gc29tZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5RnJvbU5vZGVRdWVyeU5vZGUobm9kZVF1ZXJ5Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBzdHJpbmcgPSBub2RlUXVlcnlOb2RlLmdldFN0cmluZygpLFxuICAgICAgICBleHByZXNzaW9uU3RyaW5nID0gc3RyaW5nLCAgLy8vXG4gICAgICAgIHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVGcm9tUHJpbWl0aXZlTm9kZShwcmltaXRpdmVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhbHVlID0gcHJpbWl0aXZlTm9kZS5nZXRWYWx1ZSgpO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5RnJvbU5vZGVzUXVlcnlOb2RlKG5vZGVzUXVlcnlOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHN0cmluZyA9IG5vZGVzUXVlcnlOb2RlLmdldFN0cmluZygpLFxuICAgICAgICBleHByZXNzaW9uU3RyaW5nID0gc3RyaW5nLCAgLy8vXG4gICAgICAgIHF1ZXJ5ID0gUXVlcnkuZnJvbUV4cHJlc3Npb25TdHJpbmcoZXhwcmVzc2lvblN0cmluZyk7XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IGV2ZXJ5ID0gbnVsbDtcblxuICBjb25zdCBldmVyeU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXRFdmVyeU5vZGUoKTtcblxuICBpZiAoZXZlcnlOb2RlICE9PSBudWxsKSB7XG4gICAgZXZlcnkgPSBldmVyeUZyb21FdmVyeU5vZGUoZXZlcnlOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBldmVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZWRUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBuZWdhdGVkVGVybSA9IG51bGw7XG5cbiAgY29uc3QgbmVnYXRlZFRlcm1Ob2RlID0gdGVybU5vZGUuZ2V0TmVnYXRlZFRlcm1Ob2RlKCk7XG5cbiAgaWYgKG5lZ2F0ZWRUZXJtTm9kZSAhPT0gbnVsbCkge1xuICAgIG5lZ2F0ZWRUZXJtID0gbmVnYXRlZFRlcm1Gcm9tTmVnYXRlZFRlcm1Ob2RlKG5lZ2F0ZWRUZXJtTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gbmVnYXRlZFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dpY2FsVGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCkge1xuICBsZXQgbG9naWNhbFRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IGxvZ2ljYWxUZXJtTm9kZSA9IHRlcm1Ob2RlLmdldExvZ2ljYWxUZXJtTm9kZSgpO1xuXG4gIGlmIChsb2dpY2FsVGVybU5vZGUgIT09IG51bGwpIHtcbiAgICBsb2dpY2FsVGVybSA9IGxvZ2ljYWxUZXJtRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGxvZ2ljYWxUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBCT09MRUFOX1RZUEU7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbU5lZ2F0ZWRUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IEJPT0xFQU5fVFlQRTtcblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Gcm9tTmVnYXRlZFRlcm1Ob2RlKG5lZ2F0ZWRUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0ZXJtTm9kZSA9IG5lZ2F0ZWRUZXJtTm9kZS5nZXRUZXJtTm9kZSgpLFxuICAgICAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uTm9kZSA9IHJlZHVjZU5vZGUuZ2V0RXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCByZWR1Y2UgPSBudWxsO1xuXG4gIGNvbnN0IHJlZHVjZU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXRSZWR1Y2VOb2RlKCk7XG5cbiAgaWYgKHJlZHVjZU5vZGUgIT09IG51bGwpIHtcbiAgICByZWR1Y2UgPSByZWR1Y2VGcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiByZWR1Y2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwc0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHN0ZXBOb2RlcyA9IHJldHVybkJsb2NrTm9kZS5nZXRTdGVwTm9kZXMoKSxcbiAgICAgICAgc3RlcHMgPSBzdGVwTm9kZXMubWFwKChzdGVwTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwRnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KTtcblxuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gc3RlcHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21Ob2RlUXVlcnlOb2RlKG5vZGVRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gbm9kZVF1ZXJ5Tm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJuYXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCB0ZXJuYXJ5ID0gbnVsbDtcblxuICBjb25zdCB0ZXJuYXJ5Tm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFRlcm5hcnlOb2RlKCk7XG5cbiAgaWYgKHRlcm5hcnlOb2RlICE9PSBudWxsKSB7XG4gICAgdGVybmFyeSA9IHRlcm5hcnlGcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRlcm5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFja2V0ZWRUZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBicmFja2V0ZWRUZXJtID0gbnVsbDtcblxuICBjb25zdCBicmFja2V0ZWRUZXJtTm9kZSA9IHRlcm1Ob2RlLmdldEJyYWNrZXRlZFRlcm1Ob2RlKCk7XG5cbiAgaWYgKGJyYWNrZXRlZFRlcm1Ob2RlICE9PSBudWxsKSB7XG4gICAgYnJhY2tldGVkVGVybSA9IGJyYWNrZXRlZFRlcm1Gcm9tQnJhY2tldGVkVGVybU5vZGUoYnJhY2tldGVkVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNrZXRlZFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtRnJvbUJyYWNrZXRlZFRlcm1Ob2RlKGJyYWNrZXRlZFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRlcm1Ob2RlID0gYnJhY2tldGVkVGVybU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICB0ZXJtID0gdGVybUZyb21UZXJtTm9kZSh0ZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJpc29uVGVybUZyb21UZXJtTm9kZSh0ZXJtTk9kZSwgY29udGV4dCkge1xuICBsZXQgY29tcGFyaXNvblRlcm0gPSBudWxsO1xuXG4gIGNvbnN0IGNvbXBhcmlzb25UZXJtTm9kZSA9IHRlcm1OT2RlLmdldENvbXBhcmlzb25UZXJtTm9kZSgpO1xuXG4gIGlmIChjb21wYXJpc29uVGVybU5vZGUgIT09IG51bGwpIHtcbiAgICBjb21wYXJpc29uVGVybSA9IGNvbXBhcmlzb25UZXJtRnJvbUNvbXBhcmlzb25UZXJtTm9kZShjb21wYXJpc29uVGVybU5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmlzb25UZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tTm9kZXNRdWVyeU5vZGUobm9kZXNRdWVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVOb2RlID0gbm9kZXNRdWVyeU5vZGUuZ2V0VmFyaWFibGVOb2RlKCksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybXNGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybXNOb2RlID0gcHJvY2VkdXJlQ2FsbE5vZGUuZ2V0VGVybXNOb2RlKCksXG4gICAgICAgIHRlcm1zID0gdGVybXNGcm9tVGVybXNOb2RlKHRlcm1zTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHRlcm1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHR5cGUgPSBuYW1lZFBhcmFtZXRlck5vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IG5hbWUgPSBuYW1lZFBhcmFtZXRlck5vZGUuZ2V0TmFtZSgpO1xuXG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVmdFRlcm1Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBsZWZ0VGVybU5vZGUgPSBsb2dpY2FsVGVybU5vZGUuZ2V0TGVmdFRlcm1Ob2RlKCksXG4gICAgbGVmdFRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKGxlZnRUZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGxlZnRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlBc3NpZ25tZW50RnJvbVN0ZXBOb2RlKHN0ZXBOb2RlLCBjb250ZXh0KSB7XG4gIGxldCBhcnJheUFzc2lnbm1lbnQgPSBudWxsO1xuXG4gIGNvbnN0IGFycmF5QXNzaWdubWVudE5vZGUgPSBzdGVwTm9kZS5nZXRBcnJheUFzc2lnbm1lbnROb2RlKCk7XG5cbiAgaWYgKGFycmF5QXNzaWdubWVudE5vZGUgIT09IG51bGwpIHtcbiAgICBhcnJheUFzc2lnbm1lbnQgPSBhcnJheUFzc2lnbm1lbnRGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBhcnJheUFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZkV4cHJlc3Npb25Gcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgaWZFeHByZXNzaW9uTm9kZSA9IHRlcm5hcnlOb2RlLmdldElmRXhwcmVzc2lvbk5vZGUoKSxcbiAgICAgICAgaWZFeHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShpZkV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaWZFeHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZVF1ZXJ5RnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBub2RlUXVlcnkgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVRdWVyeU5vZGUgPSBleHByZXNzaW9uTm9kZS5nZXROb2RlUXVlcnlOb2RlKCk7XG5cbiAgaWYgKG5vZGVRdWVyeU5vZGUgIT09IG51bGwpIHtcbiAgICBub2RlUXVlcnkgPSBub2RlUXVlcnlGcm9tTm9kZVF1ZXJ5Tm9kZShub2RlUXVlcnlOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBub2RlUXVlcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGlhc0Zyb21OYW1lZFBhcmFtZXRlck5vZGUobmFtZWRQYXJhbWV0ZXJOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFsaWFzID0gbmFtZWRQYXJhbWV0ZXJOb2RlLmdldEFsaWFzKCk7XG5cbiAgcmV0dXJuIGFsaWFzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybUZyb21SZXR1cm5TdGF0ZW1lbnROb2RlKHJldHVyblN0YXRlbWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybU5vZGUgPSByZXR1cm5TdGF0ZW1lbnROb2RlLmdldFRlcm1Ob2RlKCksXG4gICAgICAgIHRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEFzc2lnbm1lbnRGcm9tU3RlcE5vZGUoc3RlcE5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IG9iamVjdEFzc2lnbm1lbnQgPSBudWxsO1xuXG4gIGNvbnN0IG9iamVjdEFzc2lnbm1lbnROb2RlID0gc3RlcE5vZGUuZ2V0T2JqZWN0QXNzaWdubWVudE5vZGUoKTtcblxuICBpZiAob2JqZWN0QXNzaWdubWVudE5vZGUgIT09IG51bGwpIHtcbiAgICBvYmplY3RBc3NpZ25tZW50ID0gb2JqZWN0QXNzaWdubWVudEZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0QXNzaWdubWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzUXVlcnlGcm9tRXhwcmVzc2lvbk5vZGUoZXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IG5vZGVzUXVlcnkgPSBudWxsO1xuXG4gIGNvbnN0IG5vZGVzUXVlcnlOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0Tm9kZXNRdWVyeU5vZGUoKTtcblxuICBpZiAobm9kZXNRdWVyeU5vZGUgIT09IG51bGwpIHtcbiAgICBub2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeUZyb21Ob2Rlc1F1ZXJ5Tm9kZShub2Rlc1F1ZXJ5Tm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gbm9kZXNRdWVyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJpZ2h0VGVybUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHJpZ2h0VGVybU5vZGUgPSBsb2dpY2FsVGVybU5vZGUuZ2V0UmlnaHRUZXJtTm9kZSgpLFxuICAgICAgIHJpZ2h0VGVybSA9IHRlcm1Gcm9tVGVybU5vZGUocmlnaHRUZXJtTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJpZ2h0VGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZWRGcm9tQ29tcGFyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBuZWdhdGVkID0gY29tcGFyaXNvblRlcm1Ob2RlLmlzTmVnYXRlZCgpO1xuXG4gIHJldHVybiBuZWdhdGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxzZUV4cHJlc3Npb25Gcm9tVGVybmFyeU5vZGUodGVybmFyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZWxzZUV4cHJlc3Npb25Ob2RlID0gdGVybmFyeU5vZGUuZ2V0RWxzZUV4cHJlc3Npb25Ob2RlKCksXG4gICAgICAgIGVsc2VFeHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShlbHNlRXhwcmVzc2lvbk5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBlbHNlRXhwcmVzc2lvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkJsb2NrRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCByZXR1cm5CbG9jayA9IG51bGw7XG5cbiAgY29uc3QgcmV0dXJuQmxvY2tOb2RlID0gZXhwcmVzc2lvbk5vZGUuZ2V0UmV0dXJuQmxvY2tOb2RlKCk7XG5cbiAgaWYgKHJldHVybkJsb2NrTm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybkJsb2NrID0gcmV0dXJuQmxvY2tGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmV0dXJuQmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbm9ueW1vdXNQcm9jZWR1cmVGcm9tU29tZU5vZGUoc29tZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IHNvbWVOb2RlLmdldEFub255bW91c1Byb2NlZHVyZU5vZGUoKSxcbiAgICAgICAgYW5vbnltb3VzUHJvY2VkdXJlID0gYW5vbnltb3VzUHJvY2VkdXJlRnJvbUFub255bW91c1Byb2NlZHVyZU5vZGUoYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGFub255bW91c1Byb2NlZHVyZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vbnNlbnNpY2FsRnJvbVJldHVybkJsb2NrTm9kZShyZXR1cm5CbG9ja05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3Qgbm9uc2Vuc2ljYWwgPSByZXR1cm5CbG9ja05vZGUuaXNOb25zZW5zaWNhbCgpO1xuXG4gIHJldHVybiBub25zZW5zaWNhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmVyZW5jZUZyb21Qcm9jZWR1cmVDYWxsTm9kZShwcm9jZWR1cmVDYWxsTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByZWZlcmVuY2VOb2RlID0gcHJvY2VkdXJlQ2FsbE5vZGUuZ2V0UmVmZXJlbmNlTm9kZSgpLFxuICAgICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2VGcm9tUmVmZXJlbmNlTm9kZShyZWZlcmVuY2VOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmVmZXJlbmNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVmdFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBsZWZ0VGVybU5vZGUgPSBjb21wYXJpc29uVGVybU5vZGUuZ2V0TGVmdFRlcm1Ob2RlKCksXG4gICAgICAgIGxlZnRUZXJtID0gdGVybUZyb21UZXJtTm9kZShsZWZ0VGVybU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBsZWZ0VGVybTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc2p1bmN0aW9uRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZGlzanVuY3Rpb24gPSBsb2dpY2FsVGVybU5vZGUuaXNEaXNqdW5jdGlvbigpO1xuXG4gIHJldHVybiBkaXNqdW5jdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZWRUZXJtRnJvbU5lZ2F0ZWRUZXJtTm9kZShuZWdhdGVkVGVybU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBOZWdhdGVkVGVybSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBuZWdhdGVkVGVybU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgdGVybU5vZGUgPSBuZWdhdGVkVGVybU5vZGUuZ2V0VGVybU5vZGUoKSxcbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tTmVnYXRlZFRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgdGVybSA9IHRlcm1Gcm9tTmVnYXRlZFRlcm1Ob2RlKG5lZ2F0ZWRUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIG5lZ2F0ZWRUZXJtID0gbmV3IE5lZ2F0ZWRUZXJtKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgdGVybSk7XG5cbiAgcmV0dXJuIG5lZ2F0ZWRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9naWNhbFRlcm1Gcm9tTG9naWNhbFRlcm1Ob2RlKGxvZ2ljYWxUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IExvZ2ljYWxUZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGxvZ2ljYWxUZXJtTm9kZSwgLy8vXG4gICAgICAgIHN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKG5vZGUpLFxuICAgICAgICB0eXBlID0gdHlwZUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgZGlzanVuY3Rpb24gPSBkaXNqdW5jdGlvbkZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgbGVmdFRlcm0gPSBsZWZ0VGVybUZyb21Mb2dpY2FsVGVybU5vZGUobG9naWNhbFRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgcmlnaHRUZXJtID0gcmlnaHRUZXJtRnJvbUxvZ2ljYWxUZXJtTm9kZShsb2dpY2FsVGVybU5vZGUsIGNvbnRleHQpLFxuICAgICAgICBsb2dpY2FsVGVybSA9IG5ldyBMb2dpY2FsVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHR5cGUsIGRpc2p1bmN0aW9uLCBsZWZ0VGVybSwgcmlnaHRUZXJtKTtcblxuICByZXR1cm4gbG9naWNhbFRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21UeXBlQW5kVmFyaWFibGVOb2RlKHR5cGUsIHZhcmlhYmxlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IHZhcmlhYmxlTm9kZSwgIC8vL1xuICAgICAgICBuYW1lID0gbmFtZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlKSxcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tVHlwZUFuZFZhcmlhYmxlTm9kZSh0eXBlLCB2YXJpYWJsZU5vZGUsIGNvbnRleHQpLFxuICAgICAgICB2YXJpYWJsZVN0cmluZyA9IHZhcmlhYmxlU3RyaW5nRnJvbU5hbWUobmFtZSksXG4gICAgICAgIHN0cmluZyA9IHZhcmlhYmxlU3RyaW5nLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKGNvbnRleHQsIHN0cmluZywgbm9kZSwgdHlwZSwgbmFtZSwgZXhwcmVzc2lvbik7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVBc3NpZ25tZW50c0Zyb21TdGVwTm9kZShzdGVwTm9kZSwgY29udGV4dCkge1xuICBsZXQgdmFyaWFibGVBc3NpZ25tZW50cyA9IG51bGw7XG5cbiAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50c05vZGUgPSBzdGVwTm9kZS5nZXRWYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSgpO1xuXG4gIGlmICh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSAhPT0gbnVsbCkge1xuICAgIHZhcmlhYmxlQXNzaWdubWVudHMgPSB2YXJpYWJsZUFzc2lnbm1lbnRzRnJvbVZhcmlhYmxlQXNzaWdubWVudHNOb2RlKHZhcmlhYmxlQXNzaWdubWVudHNOb2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB2YXJpYWJsZUFzc2lnbm1lbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5vbnltb3VzUHJvY2VkdXJlRnJvbUV2ZXJ5Tm9kZShldmVyeU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgYW5vbnltb3VzUHJvY2VkdXJlTm9kZSA9IGV2ZXJ5Tm9kZS5nZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsRXhwcmVzc2lvbkZyb21SZWR1Y2VOb2RlKHJlZHVjZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Gcm9tUmVkdWNlTm9kZShyZWR1Y2VOb2RlLCBjb250ZXh0KSxcbiAgICAgICAgaW5pdGlhbEV4cHJlc3Npb24gPSBleHByZXNzaW9uOyAvLy9cblxuICByZXR1cm4gaW5pdGlhbEV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVDYWxsRnJvbUV4cHJlc3Npb25Ob2RlKGV4cHJlc3Npb25Ob2RlLCBjb250ZXh0KSB7XG4gIGxldCBwcm9jZWR1cmVDYWxsID0gbnVsbDtcblxuICBjb25zdCBwcm9jZWR1cmVDYWxsTm9kZSA9IGV4cHJlc3Npb25Ob2RlLmdldFByb2NlZHVyZUNhbGxOb2RlKCk7XG5cbiAgaWYgKHByb2NlZHVyZUNhbGxOb2RlICE9PSBudWxsKSB7XG4gICAgcHJvY2VkdXJlQ2FsbCA9IHByb2NlZHVyZUNhbGxGcm9tUHJvY2VkdXJlQ2FsbE5vZGUocHJvY2VkdXJlQ2FsbE5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHByb2NlZHVyZUNhbGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByaWdodFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByaWdodFRlcm1Ob2RlID0gY29tcGFyaXNvblRlcm1Ob2RlLmdldFJpZ2h0VGVybU5vZGUoKSxcbiAgICAgICAgcmlnaHRUZXJtID0gdGVybUZyb21UZXJtTm9kZShyaWdodFRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmlnaHRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tQXJyYXlBc3NpZ25tZW50Tm9kZShhcnJheUFzc2lnbm1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhcmlhYmxlTm9kZSA9IGFycmF5QXNzaWdubWVudE5vZGUuZ2V0VmFyaWFibGVOb2RlKCksXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVmFyaWFibGVOb2RlKHZhcmlhYmxlTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHZhcmlhYmxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21WYXJpYWJsZUFzc2lnbm1lbnRzTm9kZSh2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB0eXBlID0gdmFyaWFibGVBc3NpZ25tZW50c05vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5vbnltb3VzUHJvY2VkdXJlRnJvbVJlZHVjZU5vZGUocmVkdWNlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBhbm9ueW1vdXNQcm9jZWR1cmVOb2RlID0gcmVkdWNlTm9kZS5nZXRBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKCksXG4gICAgICAgIGFub255bW91c1Byb2NlZHVyZSA9IGFub255bW91c1Byb2NlZHVyZUZyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBhbm9ueW1vdXNQcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUZyb21PYmplY3RBc3NpZ25tZW50Tm9kZShvYmplY3RBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSBvYmplY3RBc3NpZ25tZW50Tm9kZS5nZXRWYXJpYWJsZU5vZGUoKSxcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZUZyb21WYXJpYWJsZU5vZGUodmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZS5nZXRUeXBlKCk7XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByZXNzaW9uRnJvbVR5cGVBbmRWYXJpYWJsZU5vZGUodHlwZSwgdmFyaWFibGVOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSBudWxsO1xuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyYW1ldGVyc0Zyb21BcnJheUFzc2lnbm1lbnROb2RlKGFycmF5QXNzaWdubWVudE5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyYW1ldGVyc05vZGUgPSBhcnJheUFzc2lnbm1lbnROb2RlLmdldFBhcmFtZXRlcnNOb2RlKCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcGFyYW1ldGVycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhYmVsRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgbGFiZWxOb2RlID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlLmdldExhYmVsTm9kZSgpLFxuICAgICAgICBsYWJlbCA9IGxhYmVsRnJvbUxhYmVsTm9kZShsYWJlbE5vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblN0YXRlbWVudEZyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHJldHVyblN0YXRlbWVudE5vZGUgPSByZXR1cm5CbG9ja05vZGUuZ2V0UmV0dXJuU3RhdGVtZW50Tm9kZSgpLFxuICAgICAgICByZXR1cm5TdGF0ZW1lbnQgPSByZXR1cm5TdGF0ZW1lbnRGcm9tUmV0dXJuU3RhdGVtZW50Tm9kZShyZXR1cm5TdGF0ZW1lbnROb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmV0dXJuU3RhdGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhY2tldGVkVGVybUZyb21CcmFja2V0ZWRUZXJtTm9kZShicmFja2V0ZWRUZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IEJyYWNrZXRlZFRlcm0gfSA9IGVsZW1lbnRzLFxuICAgICAgICBub2RlID0gYnJhY2tldGVkVGVybU5vZGUsIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSwgIC8vL1xuICAgICAgICB0ZXJtID0gdGVybUZyb21CcmFja2V0ZWRUZXJtTm9kZShicmFja2V0ZWRUZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGJyYWNrZXRlZFRlcm0gPSBuZXcgQnJhY2tldGVkVGVybShjb250ZXh0LCBzdHJpbmcsIG5vZGUsIHRlcm0pO1xuXG4gIHJldHVybiBicmFja2V0ZWRUZXJtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwcmVzc2lvbkZyb21WYXJpYWJsZUFzc2lnbm1lbnROb2RlKHZhcmlhYmxlQXNzaWdtZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCBleHByZXNzaW9uTm9kZSA9IHZhcmlhYmxlQXNzaWdtZW50Tm9kZS5nZXRFeHByZXNzaW9uTm9kZSgpLFxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbkZyb21FeHByZXNzaW9uTm9kZShleHByZXNzaW9uTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJhbWV0ZXJzRnJvbUFub255bW91c1Byb2NlZHVyZU5vZGUoYW5vbnltb3VzUHJvY2VkdXJlTm9kZSwgY29udGV4dCkge1xuICBjb25zdCBwYXJhbWV0ZXJzTm9kZSA9IGFub255bW91c1Byb2NlZHVyZU5vZGUuZ2V0UGFyYW1ldGVyc05vZGUoKSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tUGFyYW1ldGVyc05vZGUocGFyYW1ldGVyc05vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyaXNvblRlcm1Gcm9tQ29tcGFyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IENvbXBhcmlzb25UZXJtIH0gPSBlbGVtZW50cyxcbiAgICAgICAgbm9kZSA9IGNvbXBhcmlzb25UZXJtTm9kZSwgIC8vL1xuICAgICAgICBzdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhub2RlKSxcbiAgICAgICAgbmVnYXRlZCA9IG5lZ2F0ZWRGcm9tQ29tcGFyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIGxlZnRUZXJtID0gbGVmdFRlcm1Gcm9tQ29tcHpyaXNvblRlcm1Ob2RlKGNvbXBhcmlzb25UZXJtTm9kZSwgY29udGV4dCksXG4gICAgICAgIHJpZ2h0VGVybSA9IHJpZ2h0VGVybUZyb21Db21wenJpc29uVGVybU5vZGUoY29tcGFyaXNvblRlcm1Ob2RlLCBjb250ZXh0KSxcbiAgICAgICAgY29tcGFyaXNvblRlcm0gPSBuZXcgQ29tcGFyaXNvblRlcm0oY29udGV4dCwgc3RyaW5nLCBub2RlLCBuZWdhdGVkLCBsZWZ0VGVybSwgcmlnaHRUZXJtKTtcblxuICByZXR1cm4gY29tcGFyaXNvblRlcm07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5CbG9ja0Zyb21Bbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcmV0dXJuQmxvY2tOb2RlID0gYW5vbnltb3VzUHJvY2VkdXJlTm9kZS5nZXRSZXR1cm5CbG9ja05vZGUoKSxcbiAgICAgICAgcmV0dXJuQmxvY2sgPSByZXR1cm5CbG9ja0Zyb21SZXR1cm5CbG9ja05vZGUocmV0dXJuQmxvY2tOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gcmV0dXJuQmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZWR1cmVGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFByb2NlZHVyZSB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsICAvLy9cbiAgICAgICAgdHlwZSA9IHR5cGVGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIGxhYmVsID0gbGFiZWxGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICByZXR1cm5CbG9jayA9IHJldHVybkJsb2NrRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpLFxuICAgICAgICBwcm9jZWR1cmVTdHJpbmcgPSBwcm9jZWR1cmVTdHJpbmdGcm9tVHlwZUxhYmVsUGFyYW1ldGVyc0FuZFJldHVybkJsb2NrKHR5cGUsIGxhYmVsLCBwYXJhbWV0ZXJzLCByZXR1cm5CbG9jayksXG4gICAgICAgIHN0cmluZyA9IHByb2NlZHVyZVN0cmluZywgLy8vXG4gICAgICAgIHByb2NlZHVyZSA9IG5ldyBQcm9jZWR1cmUoY29udGV4dCwgc3RyaW5nLCBub2RlLCB0eXBlLCBsYWJlbCwgcGFyYW1ldGVycywgcmV0dXJuQmxvY2spO1xuXG4gIHJldHVybiBwcm9jZWR1cmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJhbWV0ZXJzRnJvbVByb2NlZHVyZURlY2xhcmF0aW9uTm9kZShwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgcGFyYW1ldGVyc05vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUuZ2V0UGFyYW1ldGVyc05vZGUoKSxcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnNGcm9tUGFyYW1ldGVyc05vZGUocGFyYW1ldGVyc05vZGUsIGNvbnRleHQpO1xuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUZyb21Qcm9jZWR1cmVBbm9ueW1vdXNQcm9jZWR1cmVOb2RlKGFub255bW91c1Byb2NlZHVyZU5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdHlwZSA9IGFub255bW91c1Byb2NlZHVyZU5vZGUuZ2V0VHlwZSgpO1xuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQmxvY2tGcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCkge1xuICBjb25zdCByZXR1cm5CbG9ja05vZGUgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUuZ2V0UmV0dXJuQmxvY2tOb2RlKCksXG4gICAgICAgIHJldHVybkJsb2NrID0gcmV0dXJuQmxvY2tGcm9tUmV0dXJuQmxvY2tOb2RlKHJldHVybkJsb2NrTm9kZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIHJldHVybkJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGVGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB2YXJpYWJsZU5vZGUgPSB2YXJpYWJsZUFzc2lnbm1lbnROb2RlLmdldFZhcmlhYmxlTm9kZSgpLFxuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlRnJvbVR5cGVBbmRWYXJpYWJsZU5vZGUodHlwZSwgdmFyaWFibGVOb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gdmFyaWFibGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWJsZUFzc2lnbm1lbnRGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IFZhcmlhYmxlQXNzaWdubWVudCB9ID0gZWxlbWVudHMsXG4gICAgICAgIG5vZGUgPSB2YXJpYWJsZUFzc2lnbm1lbnROb2RlLCAgLy8vXG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGVGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uRnJvbVZhcmlhYmxlQXNzaWdubWVudE5vZGUodmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCksXG4gICAgICAgIHZhcmlhYmxlQXNzaWdubWVudFN0cmluZyA9IHZhcmlhYmxlQXNzaWdubWVudFN0cmluZ0Zyb21UeXBlQW5kVmFyaWFibGUodHlwZSwgdmFyaWFibGUsIGNvbnRleHQpLFxuICAgICAgICBzdHJpbmcgPSB2YXJpYWJsZUFzc2lnbm1lbnRTdHJpbmcsICAvLy9cbiAgICAgICAgYXNzaWdubWVudCA9IG5ldyBWYXJpYWJsZUFzc2lnbm1lbnQoY29udGV4dCwgc3RyaW5nLCBub2RlLCB2YXJpYWJsZSwgZXhwcmVzc2lvbik7XG5cbiAgcmV0dXJuIGFzc2lnbm1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0FycmF5RnJvbVRlcm1Ob2Rlcyh0ZXJtTm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgdGVybXNBcnJheSA9IHRlcm1Ob2Rlcy5tYXAoKHRlcm1Ob2RlKSA9PiB7IC8vL1xuICAgIGNvbnN0IHRlcm0gPSB0ZXJtRnJvbVRlcm1Ob2RlKHRlcm1Ob2RlLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9KTtcblxuICByZXR1cm4gdGVybXNBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmFtdGVyc0FycmF5RnJvbVBhcmFtZXRlcnNOb2RlKHBhcmFtZXRlcnNOb2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBhcmFtZXRlck5vZGVzID0gcGFyYW1ldGVyc05vZGUuZ2V0UGFyYW1ldGVyTm9kZXMoKSxcbiAgICAgICAgcGFyYW10ZXJzQXJyYXkgPSBwYXJhbWV0ZXJOb2Rlcy5tYXAoKHBhcmFtZXRlck5vZGUpID0+IHsgLy8vXG4gICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyRnJvbVBhcmFtZXRlck5vZGUocGFyYW1ldGVyTm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyO1xuICAgICAgICB9KTtcblxuICByZXR1cm4gcGFyYW10ZXJzQXJyYXk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYW1lZFBhcmFtdGVyc0FycmF5RnJvbU5hbWVkUGFyYW1ldGVyTm9kZXMobmFtZWRQYXJhbWV0ZXJOb2RlcywgY29udGV4dCkge1xuICBjb25zdCBuYW1lZFBhcmFtdGVyc0FycmF5ID0gbmFtZWRQYXJhbWV0ZXJOb2Rlcy5tYXAoKG5hbWVkUGFyYW1ldGVyTm9kZSkgPT4geyAvLy9cbiAgICBjb25zdCBuYW1lZFBhcmFtZXRlciA9IG5hbWVkUGFyYW1ldGVyRnJvbU5hbWVkUGFyYW1ldGVyTm9kZShuYW1lZFBhcmFtZXRlck5vZGUsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIG5hbWVkUGFyYW1ldGVyO1xuICB9KTtcblxuICByZXR1cm4gbmFtZWRQYXJhbXRlcnNBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlQXNzaWdubWVudHNBcnJheUZyb21UeXBlQW5kVmFyaWFibGVBc3NpZ25tZW50c05vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50c05vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgdmFyaWFibGVBc3NpZ25tZW50Tm9kZXMgPSB2YXJpYWJsZUFzc2lnbm1lbnRzTm9kZS5nZXRWYXJpYWJsZUFzc2lnbm1lbnROb2RlcygpLFxuICAgICAgICB2YXJpYWJsZUFzc2lnbm1lbnRzQXJyYXkgPSB2YXJpYWJsZUFzc2lnbm1lbnROb2Rlcy5tYXAoKHZhcmlhYmxlQXNzaWdubWVudE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCB2YXJpYWJsZUFzc2lnbm1lbnQgPSB2YXJpYWJsZUFzc2lnbm1lbnRGcm9tVHlwZUFuZFZhcmlhYmxlQXNzaWdubWVudE5vZGUodHlwZSwgdmFyaWFibGVBc3NpZ25tZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50O1xuICAgICAgICB9KTtcblxuICByZXR1cm4gdmFyaWFibGVBc3NpZ25tZW50c0FycmF5O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBTaW1wbGVQYXNzLCBxdWVyeVV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1sYW5ndWFnZXNcIjtcblxuaW1wb3J0IHsgZXJyb3JGcm9tRXJyb3JOb2RlLCBwcm9jZWR1cmVEZWNsYXJhdGlvbkZyb21Qcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2VsZW1lbnRcIjtcblxuY29uc3QgeyBub2RlUXVlcnkgfSA9IHF1ZXJ5VXRpbGl0aWVzO1xuXG5jb25zdCBlcnJvck5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9lcnJvclwiKSxcbiAgICAgIHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3Byb2NlZHVyZURlY2xhcmF0aW9uXCIpO1xuXG5jbGFzcyBUb3BMZXZlbFBhc3MgZXh0ZW5kcyBTaW1wbGVQYXNzIHtcbiAgc3RhdGljIG1hcHMgPSBbXG4gICAge1xuICAgICAgbm9kZVF1ZXJ5OiBlcnJvck5vZGVRdWVyeSxcbiAgICAgIHJ1bjogKGVycm9yTm9kZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JGcm9tRXJyb3JOb2RlKGVycm9yTm9kZSwgY29udGV4dCksXG4gICAgICAgICAgICAgIGVycm9yVmVyaWZpZXMgPSBlcnJvci52ZXJpZnkoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGVycm9yVmVyaWZpZXMpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbm9kZVF1ZXJ5OiBwcm9jZWR1cmVEZWNsYXJhdGlvbk5vZGVRdWVyeSxcbiAgICAgIHJ1bjogKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHByb2NlZHVyZURlY2xhcmF0aW9uID0gcHJvY2VkdXJlRGVjbGFyYXRpb25Gcm9tUHJvY2VkdXJlRGVjbGFyYXRpb25Ob2RlKHByb2NlZHVyZURlY2xhcmF0aW9uTm9kZSwgY29udGV4dCksXG4gICAgICAgICAgICAgIHByb2NlZHVyZURlY2xhcmF0aW9uVmVyaWZpZXMgPSBwcm9jZWR1cmVEZWNsYXJhdGlvbi52ZXJpZnkoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKHByb2NlZHVyZURlY2xhcmF0aW9uVmVyaWZpZXMpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cblxuY29uc3QgdG9wTGV2ZWxQYXNzID0gbmV3IFRvcExldmVsUGFzcygpO1xuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5RmlsZShmaWxlTm9kZSwgY29udGV4dCkge1xuICBsZXQgZmlsZVZlcmlmaWVzID0gZmFsc2U7XG5cbiAgY29uc3Qgbm9kZSA9IGZpbGVOb2RlLCAvLy9cbiAgICAgICAgc3VjZXNzID0gdG9wTGV2ZWxQYXNzLnJ1bihub2RlLCBjb250ZXh0KTtcblxuICBpZiAoc3VjZXNzKSB7XG4gICAgZmlsZVZlcmlmaWVzID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmaWxlVmVyaWZpZXM7XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGxleGVyVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWxleGVyc1wiO1xuXG5pbXBvcnQgRnVydGxlTGV4ZXIgZnJvbSBcIi4uL2Z1cnRsZS9sZXhlclwiO1xuXG5jb25zdCB7IGxleGVyRnJvbVJ1bGVzLCBydWxlc0Zyb21FbnRyaWVzIH0gPSBsZXhlclV0aWxpdGllcztcblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZUxleGVyRnJvbU5vdGhpbmcoQ2xhc3MpIHtcbiAgaWYgKENsYXNzID09PSB1bmRlZmluZWQpIHtcbiAgICBDbGFzcyA9IEZ1cnRsZUxleGVyOyAgLy8vXG4gIH1cblxuICBjb25zdCB7IGVudHJpZXMgfSA9IEZ1cnRsZUxleGVyO1xuXG4gIGxldCBydWxlcztcblxuICBydWxlcyA9IHJ1bGVzRnJvbUVudHJpZXMoZW50cmllcyk7XG5cbiAgY29uc3QgZnVydGxlTGV4ZXIgPSBsZXhlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBmdXJ0bGVMZXhlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1cnRsZUxleGVyRnJvbUVudHJpZXMoQ2xhc3MsIGVudHJpZXMpIHtcbiAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGVudHJpZXMgPSBDbGFzczsgIC8vL1xuXG4gICAgQ2xhc3MgPSBGdXJ0bGVMZXhlcjsgIC8vL1xuICB9XG5cbiAgbGV0IHJ1bGVzO1xuXG4gIHJ1bGVzID0gcnVsZXNGcm9tRW50cmllcyhlbnRyaWVzKTtcblxuICBjb25zdCBmdXJ0bGVMZXhlciA9IGxleGVyRnJvbVJ1bGVzKENsYXNzLCBydWxlcyk7XG5cbiAgcmV0dXJuIGZ1cnRsZUxleGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZ1cnRsZUxleGVyRnJvbUVudHJpZXMsXG4gIGZ1cnRsZUxleGVyRnJvbU5vdGhpbmdcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnNlclV0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1wYXJzZXJzXCI7XG5pbXBvcnQgeyBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uIH0gZnJvbSBcIm9jY2FtLWdyYW1tYXItdXRpbGl0aWVzXCI7XG5cbmltcG9ydCBGdXJ0bGVQYXJzZXIgZnJvbSBcIi4uL2Z1cnRsZS9wYXJzZXJcIjtcblxuY29uc3QgeyBydWxlc0Zyb21CTkYsIHBhcnNlckZyb21SdWxlcywgcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZSB9ID0gcGFyc2VyVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gZnVydGxlUGFyc2VyRnJvbUJORihDbGFzcywgYm5mKSB7XG4gIGlmIChibmYgPT09IHVuZGVmaW5lZCkge1xuICAgIGJuZiA9IENsYXNzOyAgLy8vXG5cbiAgICBDbGFzcyA9IEZ1cnRsZVBhcnNlcjsgIC8vL1xuICB9XG5cbiAgbGV0IHJ1bGVzO1xuXG4gIHJ1bGVzID0gcnVsZXNGcm9tQk5GKGJuZik7XG5cbiAgcnVsZXMgPSBlbGltaW5hdGVMZWZ0UmVjdXJzaW9uKHJ1bGVzKTsgIC8vL1xuXG4gIGNvbnN0IGZ1cnRsZVBhcnNlciA9IHBhcnNlckZyb21SdWxlcyhDbGFzcywgcnVsZXMpO1xuXG4gIHJldHVybiBmdXJ0bGVQYXJzZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdXJ0bGVQYXJzZXJGcm9tTm90aGluZyhDbGFzcykge1xuICBpZiAoQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIENsYXNzID0gRnVydGxlUGFyc2VyOyAgLy8vXG4gIH1cblxuICBjb25zdCB7IGJuZiB9ID0gRnVydGxlUGFyc2VyO1xuXG4gIGxldCBydWxlcztcblxuICBydWxlcyA9IHJ1bGVzRnJvbUJORihibmYpO1xuXG4gIHJ1bGVzID0gZWxpbWluYXRlTGVmdFJlY3Vyc2lvbihydWxlcyk7ICAvLy9cblxuICBjb25zdCBmdXJ0bGVQYXJzZXIgPSBwYXJzZXJGcm9tUnVsZXMoQ2xhc3MsIHJ1bGVzKTtcblxuICByZXR1cm4gZnVydGxlUGFyc2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVydGxlUGFyc2VyRnJvbUJORkFuZFN0YXJ0UnVsZU5hbWUoQ2xhc3MsIGJuZiwgc3RhcnRSdWxlTmFtZSkge1xuICBpZiAoc3RhcnRSdWxlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRSdWxlTmFtZSA9IGJuZjsgIC8vL1xuXG4gICAgYm5mID0gQ2xhc3M7ICAvLy9cblxuICAgIENsYXNzID0gRnVydGxlUGFyc2VyOyAgLy8vXG4gIH1cblxuICBsZXQgcnVsZXM7XG5cbiAgcnVsZXMgPSBydWxlc0Zyb21CTkYoYm5mKTtcblxuICBydWxlcyA9IGVsaW1pbmF0ZUxlZnRSZWN1cnNpb24ocnVsZXMpOyAgLy8vXG5cbiAgY29uc3QgZnVydGxlUGFyc2VyID0gcGFyc2VyRnJvbVJ1bGVzQW5kU3RhcnRSdWxlTmFtZShDbGFzcywgcnVsZXMsIHN0YXJ0UnVsZU5hbWUpO1xuXG4gIHJldHVybiBmdXJ0bGVQYXJzZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZnVydGxlUGFyc2VyRnJvbUJORixcbiAgZnVydGxlUGFyc2VyRnJvbU5vdGhpbmcsXG4gIGZ1cnRsZVBhcnNlckZyb21CTkZBbmRTdGFydFJ1bGVOYW1lXG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRnVydGxlTGV4ZXIgZnJvbSBcIi4uL2Z1cnRsZS9sZXhlclwiO1xuaW1wb3J0IEZ1cnRsZVBhcnNlciBmcm9tIFwiLi4vZnVydGxlL3BhcnNlclwiO1xuXG5pbXBvcnQgeyBmdXJ0bGVMZXhlckZyb21Ob3RoaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9sZXhlcnNcIjtcbmltcG9ydCB7IGZ1cnRsZVBhcnNlckZyb21Ob3RoaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9wYXJzZXJzXCI7XG5cbmV4cG9ydCBjb25zdCBmdXJ0bGVMZXhlciA9IGZ1cnRsZUxleGVyRnJvbU5vdGhpbmcoRnVydGxlTGV4ZXIpO1xuXG5leHBvcnQgY29uc3QgZnVydGxlUGFyc2VyID0gZnVydGxlUGFyc2VyRnJvbU5vdGhpbmcoRnVydGxlUGFyc2VyKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgRmlsZUNvbnRleHQgfSBmcm9tIFwib2NjYW0tbGFuZ3VhZ2VzXCI7XG5cbmltcG9ydCB7IHZlcmlmeUZpbGUgfSBmcm9tIFwiLi4vLi4vcHJvY2Vzcy92ZXJpZnlcIjtcbmltcG9ydCB7IGZ1cnRsZUxleGVyLCBmdXJ0bGVQYXJzZXIgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2Z1cnRsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXJ0bGVGaWxlQ29udGV4dCBleHRlbmRzIEZpbGVDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgZmlsZVBhdGgsIHRva2Vucywgbm9kZSwgcHJvY2VkdXJlcykge1xuICAgIHN1cGVyKGNvbnRleHQsIGZpbGVQYXRoLCB0b2tlbnMsIG5vZGUpO1xuXG4gICAgdGhpcy5wcm9jZWR1cmVzID0gcHJvY2VkdXJlcztcbiAgfVxuXG4gIGdldFByb2NlZHVyZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IGluY2x1ZGVSZWxlYXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2V0UHJvY2VkdXJlcygpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VkdXJlcztcblxuICAgIHJldHVybiBwcm9jZWR1cmVzO1xuICB9XG5cbiAgZ2V0TGV4ZXIoKSB7XG4gICAgY29uc3QgbGV4ZXIgPSBmdXJ0bGVMZXhlcjsgIC8vL1xuXG4gICAgcmV0dXJuIGxleGVyO1xuICB9XG5cbiAgZ2V0UGFyc2VyKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IGZ1cnRsZVBhcnNlcjsgIC8vL1xuXG4gICAgcmV0dXJuIHBhcnNlcjtcbiAgfVxuXG4gIGdldExhYmVscyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSBbXTtcblxuICAgIHJldHVybiBsYWJlbHM7XG4gIH1cblxuICBnZXRUeXBlcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHR5cGVzO1xuICB9XG5cbiAgZ2V0UnVsZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgcnVsZXMgPSBbXVxuXG4gICAgcmV0dXJuIHJ1bGVzO1xuICB9XG5cbiAgZ2V0QXhpb21zKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGF4aW9tcyA9IFtdO1xuXG4gICAgcmV0dXJuIGF4aW9tcztcbiAgfVxuXG4gIGdldExlbW1hcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBsZW1tYXMgPSBbXTtcblxuICAgIHJldHVybiBsZW1tYXM7XG4gIH1cblxuICBnZXRUaGVvcmVtcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCB0aGVvcmVtcyA9IFtdO1xuXG4gICAgcmV0dXJuIHRoZW9yZW1zO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVzKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtdO1xuXG4gICAgcmV0dXJuIHZhcmlhYmxlcztcbiAgfVxuXG4gIGdldE1ldGFMZW1tYXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YUxlbW1hcyA9IFtdO1xuXG4gICAgcmV0dXJuIG1ldGFMZW1tYXM7XG4gIH1cblxuICBnZXRDb25qZWN0dXJlcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCBjb25qZWN0dXJlcyA9IFtdO1xuXG4gICAgcmV0dXJuIGNvbmplY3R1cmVzO1xuICB9XG5cbiAgZ2V0Q29tYmluYXRvcnMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgY29tYmluYXRvcnMgPSBbXTtcblxuICAgIHJldHVybiBjb21iaW5hdG9ycztcbiAgfVxuXG4gIGdldFR5cGVQcmVmaXhlcyhpbmNsdWRlUmVsZWFzZSA9IHRydWUpIHtcbiAgICBjb25zdCB0eXBlUHJlZml4ZXMgPSBbXTtcblxuICAgIHJldHVybiB0eXBlUHJlZml4ZXM7XG4gIH1cblxuICBnZXRDb25zdHJ1Y3RvcnMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JzID0gW107XG5cbiAgICByZXR1cm4gY29uc3RydWN0b3JzO1xuICB9XG5cbiAgZ2V0TWV0YXRoZW9yZW1zKGluY2x1ZGVSZWxlYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGF0aGVvcmVtcyA9IFtdO1xuXG4gICAgcmV0dXJuIG1ldGF0aGVvcmVtcztcbiAgfVxuXG4gIGdldE1ldGF2YXJpYWJsZXMoaW5jbHVkZVJlbGVhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YXZhcmlhYmxlcyA9IFtdO1xuXG4gICAgcmV0dXJuIG1ldGF2YXJpYWJsZXM7XG4gIH1cblxuICBhZGRQcm9jZWR1cmUocHJvY2VkdXJlKSB7XG4gICAgY29uc3QgcHJvY2VkdXJlU3RyaW5nID0gcHJvY2VkdXJlLmdldFN0cmluZygpO1xuXG4gICAgdGhpcy5wcm9jZWR1cmVzLnB1c2gocHJvY2VkdXJlKTtcblxuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5nZXRGaWxlUGF0aCgpO1xuXG4gICAgdGhpcy5kZWJ1ZyhgQWRkZWQgdGhlICcke3Byb2NlZHVyZVN0cmluZ30nIHByb2NlZHVyZSB0byB0aGUgJyR7ZmlsZVBhdGh9JyBmaWxlIGNvbnRleHQuYCk7XG4gIH1cblxuICBmaW5kUHJvY2VkdXJlQnlQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpIHtcbiAgICBjb25zdCBwcm9jZWR1cmVzID0gdGhpcy5nZXRQcm9jZWR1cmVzKCksXG4gICAgICAgICAgcHJvY2VkdXJlID0gcHJvY2VkdXJlcy5maW5kKChwcm9jZWR1cmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2NlZHVyZUNvbXBhcmVzVG9Qcm9jZWR1cmVOYW1lID0gcHJvY2VkdXJlLmNvbXBhcmVQcm9jZWR1cmVOYW1lKHByb2NlZHVyZU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAocHJvY2VkdXJlQ29tcGFyZXNUb1Byb2NlZHVyZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkgfHwgbnVsbDtcblxuICAgIHJldHVybiBwcm9jZWR1cmU7XG4gIH1cblxuICBpc1Byb2NlZHVyZVByZXNlbnRCeVByb2NlZHVyZU5hbWUocHJvY2VkdXJlTmFtZSkge1xuICAgIGNvbnN0IHByb2NlZHVyZSA9IHRoaXMuZmluZFByb2NlZHVyZUJ5UHJvY2VkdXJlTmFtZShwcm9jZWR1cmVOYW1lKSxcbiAgICAgICAgICBwcm9jZWR1cmVQcmVzZW50ID0gKHByb2NlZHVyZSAhPT0gbnVsbCk7XG5cbiAgICByZXR1cm4gcHJvY2VkdXJlUHJlc2VudDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMucHJvY2VkdXJlcyA9IFtdO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgLy8vXG4gIH1cblxuICBhc3luYyB2ZXJpZnlGaWxlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUoKSxcbiAgICAgICAgICBjb250ZXh0ID0gdGhpcywgLy8vXG4gICAgICAgICAgZmlsZU5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgZmlsZVZlcmlmaWVzID0gdmVyaWZ5RmlsZShmaWxlTm9kZSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZmlsZVZlcmlmaWVzO1xuICB9XG5cbiAgc3RhdGljIGZyb21GaWxlKGZpbGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwcm9jZWR1cmVzID0gW10sXG4gICAgICAgICAgZnVydGxlRmlsZUNvbnRleHQgPSBGaWxlQ29udGV4dC5mcm9tRmlsZShGdXJ0bGVGaWxlQ29udGV4dCwgZmlsZSwgcHJvY2VkdXJlcywgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZnVydGxlRmlsZUNvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZnJvbUZpbGVQYXRoKGZpbGVQYXRoLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcHJvY2VkdXJlcyA9IG51bGwsXG4gICAgICAgICAgZnVydGxlRmlsZUNvbnRleHQgPSBpbGVDb250ZXh0LmZyb21GaWxlUGF0aChGdXJ0bGVGaWxlQ29udGV4dCwgZmlsZVBhdGgsIHByb2NlZHVyZXMsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGZ1cnRsZUZpbGVDb250ZXh0O1xuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBlbGVtZW50cyBmcm9tIFwiLi4vZWxlbWVudHNcIjtcblxuaW1wb3J0IHsgdGVybXNTdHJpbmdGcm9tVGVybXNBcnJheSB9IGZyb20gXCIuLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyB0ZXJtRnJvbU5vZGUsIHRlcm1Gcm9tUHJpbWl0aXZlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy90ZXJtXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtc0Zyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdGVybXNBcnJheSA9IHRlcm1zQXJyYXlGcm9tTm9kZXMobm9kZXMsIGNvbnRleHQpLFxuICAgICAgICB0ZXJtc1N0cmluZyA9IHRlcm1zU3RyaW5nRnJvbVRlcm1zQXJyYXkodGVybXNBcnJheSksXG4gICAgICAgIHN0cmluZyA9IHRlcm1zU3RyaW5nLCAvLy9cbiAgICAgICAgYXJyYXkgPSB0ZXJtc0FycmF5LCAgLy8vXG4gICAgICAgIG5vZGUgPSBudWxsO1xuXG4gIGNvbnRleHQgPSBudWxsO1xuXG4gIGNvbnN0IHRlcm1zID0gbmV3IFRlcm1zKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpO1xuXG4gIHJldHVybiB0ZXJtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1zRnJvbVByaW1pdGl2ZXMocHJpbWl0aXZlcykge1xuICBjb25zdCB7IFRlcm1zIH0gPSBlbGVtZW50cyxcbiAgICAgICAgdGVybXNBcnJheSA9IHRlcm1zQXJyYXlGcm9tUHJpbWl0aXZlcyhwcmltaXRpdmVzKSxcbiAgICAgICAgdGVybXNTdHJpbmcgPSB0ZXJtc1N0cmluZ0Zyb21UZXJtc0FycmF5KHRlcm1zQXJyYXkpLFxuICAgICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgICAgc3RyaW5nID0gdGVybXNTdHJpbmcsIC8vL1xuICAgICAgICBhcnJheSA9IHRlcm1zQXJyYXksICAvLy9cbiAgICAgICAgbm9kZSA9IG51bGwsXG4gICAgICAgIHRlcm1zID0gbmV3IFRlcm1zKGNvbnRleHQsIHN0cmluZywgbm9kZSwgYXJyYXkpO1xuXG4gIHJldHVybiB0ZXJtcztcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICB0ZXJtc0Zyb21Ob2RlcyxcbiAgdGVybXNGcm9tUHJpbWl0aXZlc1xufTtcblxuZnVuY3Rpb24gdGVybXNBcnJheUZyb21Ob2Rlcyhub2RlcywgY29udGV4dCkge1xuICBjb25zdCB0ZXJtc0FycmF5ID0gbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgY29uc3QgdGVybSA9IHRlcm1Gcm9tTm9kZShub2RlLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9KTtcblxuICByZXR1cm4gdGVybXNBcnJheTtcbn1cblxuZnVuY3Rpb24gdGVybXNBcnJheUZyb21QcmltaXRpdmVzKHByaW1pdGl2ZXMpIHtcbiAgY29uc3QgdGVybXNBcnJheSA9IHByaW1pdGl2ZXMubWFwKChwcmltaXRpdmUpID0+IHtcbiAgICBjb25zdCB0ZXJtID0gdGVybUZyb21QcmltaXRpdmUocHJpbWl0aXZlKTtcblxuICAgIHJldHVybiB0ZXJtO1xuICB9KTtcblxuICByZXR1cm4gdGVybXNBcnJheTtcbn1cblxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgXCIuL3ByZWFtYmxlXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGVybXMgfSBmcm9tIFwiLi9lbGVtZW50L3Rlcm1zXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlTGV4ZXIgfSBmcm9tIFwiLi9mdXJ0bGUvbGV4ZXJcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnVydGxlUGFyc2VyIH0gZnJvbSBcIi4vZnVydGxlL3BhcnNlclwiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGdXJ0bGVGaWxlQ29udGV4dCB9IGZyb20gXCIuL2NvbnRleHQvZmlsZS9mdXJ0bGVcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyB0ZXJtVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3Rlcm1cIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdGVybXNVdGlsaXRpZXMgfSBmcm9tIFwiLi91dGlsaXRpZXMvdGVybXNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgbGV4ZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL2xleGVyc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZXJzVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3BhcnNlcnNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJpbWl0aXZlVXRpbGl0aWVzIH0gZnJvbSBcIi4vdXRpbGl0aWVzL3ByaW1pdGl2ZVwiO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5jb25zdCBTdWJIZWFkaW5nID0gd2l0aFN0eWxlLmgyYFxuXG4gIG1hcmdpbjogMXJlbSAwIDAuNXJlbSAwO1xuICBmb250LXNpemU6IDJyZW07XG4gIFxuICA6Zmlyc3Qtb2YtdHlwZSB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgfVxuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCBTdWJIZWFkaW5nO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBTaXplYWJsZURpdiB9IGZyb20gXCJlYXN5LWxheW91dFwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoU2l6ZWFibGVEaXYpYFxuXG4gIHdpZHRoOiA4MHJlbTtcbiAgbWluLXdpZHRoOiA0OHJlbTtcbiAgXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBUZXh0YXJlYSB9IGZyb20gXCJlYXN5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShUZXh0YXJlYSlgXG5cbiAgYm9yZGVyOiAxcHggc29saWQgZGFya2dyZXk7XG4gIGhlaWdodDogMzZyZW07XG4gIHJlc2l6ZTogdmVydGljYWw7XG4gIHBhZGRpbmc6IDAuMjVyZW07XG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xuICBsaW5lLWhlaWdodDogMS41cmVtO1xuICB3aGl0ZS1zcGFjZTogcHJlO1xuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuXG5gO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGV4dGFyZWEgZnJvbSBcIi4uL3RleHRhcmVhXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJORlRleHRhcmVhIGV4dGVuZHMgVGV4dGFyZWEge1xuICBnZXRCTkYoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgYm5mID0gdmFsdWU7IC8vL1xuXG4gICAgcmV0dXJuIGJuZjtcbiAgfVxuXG4gIHNldEJORihibmYpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGJuZjtcblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBnZXRCTkYgPSB0aGlzLmdldEJORi5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldEJORiA9IHRoaXMuc2V0Qk5GLmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIGdldEJORixcbiAgICAgIHNldEJORlxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJibmZcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCJcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHdpdGhTdHlsZSBmcm9tIFwiZWFzeS13aXRoLXN0eWxlXCI7ICAvLy9cblxuaW1wb3J0IHsgSW5wdXQgfSBmcm9tIFwiZWFzeVwiO1xuXG5jbGFzcyBSdWxlTmFtZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICBnZXRSdWxlTmFtZSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBydWxlTmFtZSA9IHZhbHVlOyAvLy9cblxuICAgIHJldHVybiBydWxlTmFtZTtcbiAgfVxuXG4gIHNldFJ1bGVOYW1lKHJ1bGVOYW1lKSB7XG4gICAgY29uc3QgdmFsdWUgPSBydWxlTmFtZTsgLy8vXG5cbiAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHBhcmVudENvbnRleHQoKSB7XG4gICAgY29uc3QgZ2V0UnVsZU5hbWUgPSB0aGlzLmdldFJ1bGVOYW1lLmJpbmQodGhpcyksXG4gICAgICAgICAgc2V0UnVsZU5hbWUgPSB0aGlzLnNldFJ1bGVOYW1lLmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFJ1bGVOYW1lLFxuICAgICAgc2V0UnVsZU5hbWVcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcGVydGllcyA9IHtcbiAgICBjbGFzc05hbWU6IFwicnVsZS1uYW1lXCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZShSdWxlTmFtZUlucHV0KWBcblxuICBib3JkZXI6IDFweCBzb2xpZCBkYXJrZ3JleTtcbiAgcGFkZGluZzogMC4yNXJlbTtcbiAgZm9udC1zaXplOiAxLjJyZW07XG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gIFxuYDtcbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5pbXBvcnQgeyBFTVBUWV9TVFJJTkcgfSBmcm9tIFwiLi4vLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRva2Vuc1RleHRhcmVhIGV4dGVuZHMgVGV4dGFyZWEge1xuICBzZXRUb2tlbnModG9rZW5zKSB7XG4gICAgbGV0IGxpbmVOdW1iZXIgPSAxLFxuICAgICAgICBwcmV2aW91c1Rva2VuID0gbnVsbDtcblxuICAgIGNvbnN0IGh0bWwgPSB0b2tlbnMucmVkdWNlKChodG1sLCB0b2tlbikgPT4ge1xuICAgICAgY29uc3QgdG9rZW5IVE1MID0gdG9rZW4uYXNIVE1MKCk7XG5cbiAgICAgIGlmIChwcmV2aW91c1Rva2VuID09PSBudWxsKSB7XG4gICAgICAgIGh0bWwgKz0gYCR7bGluZU51bWJlcisrfTogYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW5FbmRPZkxpbmVUb2tlbiA9IHByZXZpb3VzVG9rZW4uaXNFbmRPZkxpbmVUb2tlbigpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1Rva2VuRW5kT2ZMaW5lVG9rZW4pIHtcbiAgICAgICAgICBodG1sICs9IGAke2xpbmVOdW1iZXIrK306IGA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaHRtbCArPSB0b2tlbkhUTUw7XG5cbiAgICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcblxuICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSwgRU1QVFlfU1RSSU5HKTtcblxuICAgIHRoaXMuaHRtbChodG1sKTtcbiAgfVxuXG4gIGNsZWFyVG9rZW5zKCkge1xuICAgIGNvbnN0IGh0bWwgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICB0aGlzLmh0bWwoaHRtbCk7XG4gIH1cblxuICBwYXJlbnRDb250ZXh0KCkge1xuICAgIGNvbnN0IHNldFRva2VucyA9IHRoaXMuc2V0VG9rZW5zLmJpbmQodGhpcyksXG4gICAgICAgICAgY2xlYXJUb2tlbnMgPSB0aGlzLmNsZWFyVG9rZW5zLmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHNldFRva2VucyxcbiAgICAgIGNsZWFyVG9rZW5zXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInRva2Vuc1wiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIixcbiAgICByZWFkT25seTogdHJ1ZVxuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVGV4dGFyZWEgZnJvbSBcIi4uL3RleHRhcmVhXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgZ2V0Q29udGVudCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBjb250ZW50ID0gdmFsdWU7IC8vL1xuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbnRlbnQ7ICAvLy9cblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBnZXRDb250ZW50ID0gdGhpcy5nZXRDb250ZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgc2V0Q29udGVudCA9IHRoaXMuc2V0Q29udGVudC5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRDb250ZW50LFxuICAgICAgc2V0Q29udGVudFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb250ZW50XCIsXG4gICAgc3BlbGxDaGVjazogXCJmYWxzZVwiXG4gIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUZXh0YXJlYSBmcm9tIFwiLi4vdGV4dGFyZWFcIjtcblxuaW1wb3J0IHsgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uLy4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJzZVRyZWVUZXh0YXJlYSBleHRlbmRzIFRleHRhcmVhIHtcbiAgc2V0UGFyc2VUcmVlKHBhcnNlVHJlZSkge1xuICAgIGlmIChwYXJzZVRyZWUgIT09IG51bGwpIHtcbiAgICAgIHBhcnNlVHJlZS5zaGlmdExpbmUoKTsgIC8vXG5cbiAgICAgIGNvbnN0IHBhcnNlVHJlZVN0cmluZyA9IHBhcnNlVHJlZS5hc1N0cmluZygpLFxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVRyZWVTdHJpbmc7ICAvLy9cblxuICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJQYXJzZVRyZWUoKTtcbiAgICB9XG4gIH1cblxuICBjbGVhclBhcnNlVHJlZSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IEVNUFRZX1NUUklORztcblxuICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICB9XG5cbiAgcGFyZW50Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXRQYXJzZVRyZWUgPSB0aGlzLnNldFBhcnNlVHJlZS5iaW5kKHRoaXMpLFxuICAgICAgICAgIGNsZWFyUGFyc2VUcmVlID0gdGhpcy5jbGVhclBhcnNlVHJlZS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBzZXRQYXJzZVRyZWUsXG4gICAgICBjbGVhclBhcnNlVHJlZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wZXJ0aWVzID0ge1xuICAgIGNsYXNzTmFtZTogXCJ0b2tlbnNcIixcbiAgICBzcGVsbENoZWNrOiBcImZhbHNlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbiAgfTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFRleHRhcmVhIGZyb20gXCIuLi90ZXh0YXJlYVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXhpY2FsRW50cmllc1RleHRhcmVhIGV4dGVuZHMgVGV4dGFyZWEge1xuICBnZXRMZXhpY2FsRW50cmllcygpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgICBsZXhpY2FsRW50cmllcyA9IEpTT04ucGFyc2UodmFsdWUpO1xuXG4gICAgcmV0dXJuIGxleGljYWxFbnRyaWVzO1xuICB9XG5cbiAgc2V0TGV4aWNhbEVudHJpZXMobGV4aWNhbEVudHJpZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGxleGljYWxFbnRyaWVzLCBudWxsLCBcIiAgXCIpO1xuXG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBwYXJlbnRDb250ZXh0KCkge1xuICAgIGNvbnN0IGdldExleGljYWxFbnRyaWVzID0gdGhpcy5nZXRMZXhpY2FsRW50cmllcy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHNldExleGljYWxFbnRyaWVzID0gdGhpcy5zZXRMZXhpY2FsRW50cmllcy5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICBnZXRMZXhpY2FsRW50cmllcyxcbiAgICAgIHNldExleGljYWxFbnRyaWVzXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcImxleGljYWwtZW50cmllc1wiLFxuICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIlxuICB9O1xufVxuIiwgIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSBcImVhc3lcIjtcbmltcG9ydCB7IFJvd3NEaXYsIENvbHVtbkRpdiwgQ29sdW1uc0RpdiwgVmVydGljYWxTcGxpdHRlckRpdiB9IGZyb20gXCJlYXN5LWxheW91dFwiO1xuaW1wb3J0IHsgRnVydGxlTGV4ZXIsRnVydGxlUGFyc2VyLCBsZXhlcnNVdGlsaXRpZXMsIHBhcnNlcnNVdGlsaXRpZXMgfSBmcm9tIFwiLi4vaW5kZXhcIjsgLy8vXG5cbmltcG9ydCBTdWJIZWFkaW5nIGZyb20gXCIuL3ZpZXcvc3ViSGVhZGluZ1wiO1xuaW1wb3J0IFNpemVhYmxlRGl2IGZyb20gXCIuL3ZpZXcvZGl2L3NpemVhYmxlXCI7XG5pbXBvcnQgQk5GVGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS9ibmZcIjtcbmltcG9ydCBSdWxlTmFtZUlucHV0IGZyb20gXCIuL3ZpZXcvaW5wdXQvcnVsZU5hbWVcIjtcbmltcG9ydCBUb2tlbnNUZXh0YXJlYSBmcm9tIFwiLi92aWV3L3RleHRhcmVhL3Rva2Vuc1wiO1xuaW1wb3J0IENvbnRlbnRUZXh0YXJlYSBmcm9tIFwiLi92aWV3L3RleHRhcmVhL2NvbnRlbnRcIjtcbmltcG9ydCBQYXJzZVRyZWVUZXh0YXJlYSBmcm9tIFwiLi92aWV3L3RleHRhcmVhL3BhcnNlVHJlZVwiO1xuaW1wb3J0IExleGljYWxFbnRyaWVzVGV4dGFyZWEgZnJvbSBcIi4vdmlldy90ZXh0YXJlYS9sZXhpY2FsRW50cmllc1wiO1xuXG5jb25zdCB7IGZ1cnRsZVBhcnNlckZyb21CTkYgfSA9IHBhcnNlcnNVdGlsaXRpZXMsXG4gICAgICB7IGZ1cnRsZUxleGVyRnJvbUVudHJpZXMgfSA9IGxleGVyc1V0aWxpdGllcztcblxuY29uc3QgeyBibmYgfSA9IEZ1cnRsZVBhcnNlcixcbiAgICAgIHsgZW50cmllcyB9ID0gRnVydGxlTGV4ZXI7XG5cbmNsYXNzIFZpZXcgZXh0ZW5kcyBFbGVtZW50IHtcbiAga2V5VXBIYW5kbGVyID0gKGV2ZW50LCBlbGVtZW50KSA9PiB7XG4gICAgLy8gdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuZ2V0VG9rZW5zKCksXG4gICAgICAgICAgICBwYXJzZVRyZWUgPSB0aGlzLmdldFBhcnNlVHJlZSh0b2tlbnMpO1xuXG4gICAgICB0aGlzLnNldFRva2Vucyh0b2tlbnMpO1xuXG4gICAgICB0aGlzLnNldFBhcnNlVHJlZShwYXJzZVRyZWUpO1xuICAgIC8vIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgLy9cbiAgICAvLyAgIHRoaXMuY2xlYXJUb2tlbnMoKTtcbiAgICAvL1xuICAgIC8vICAgdGhpcy5jbGVhclBhcnNlVHJlZSgpO1xuICAgIC8vIH1cbiAgfVxuXG4gIGdldFRva2VucygpIHtcbiAgICBjb25zdCBsZXhpY2FsRW50cmllcyA9IHRoaXMuZ2V0TGV4aWNhbEVudHJpZXMoKSxcbiAgICAgICAgICBlbnRyaWVzID0gbGV4aWNhbEVudHJpZXMsIC8vL1xuICAgICAgICAgIGZ1cnRsZUxleGVyID0gZnVydGxlTGV4ZXJGcm9tRW50cmllcyhlbnRyaWVzKSxcbiAgICAgICAgICBsZXhlciA9IGZ1cnRsZUxleGVyLCAgLy8vXG4gICAgICAgICAgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudCgpLFxuICAgICAgICAgIHRva2VucyA9IGxleGVyLnRva2VuaXNlKGNvbnRlbnQpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGdldFBhcnNlVHJlZSh0b2tlbnMpIHtcbiAgICBsZXQgcGFyc2VUcmVlID0gbnVsbDtcblxuICAgIGNvbnN0IGJuZiA9IHRoaXMuZ2V0Qk5GKCksXG4gICAgICAgICAgZnVydGxlUGFyc2VyID0gZnVydGxlUGFyc2VyRnJvbUJORihibmYpLFxuICAgICAgICAgIHBhcnNlciA9IGZ1cnRsZVBhcnNlciwgIC8vL1xuICAgICAgICAgIHJ1bGVOYW1lID0gdGhpcy5nZXRSdWxlTmFtZSgpLFxuICAgICAgICAgIHJ1bGVNYXAgPSBwYXJzZXIuZ2V0UnVsZU1hcCgpLFxuICAgICAgICAgIHJ1bGUgPSBydWxlTWFwW3J1bGVOYW1lXSxcbiAgICAgICAgICBub2RlID0gcGFyc2VyLnBhcnNlKHRva2VucywgcnVsZSk7XG5cbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcGFyc2VUcmVlID0gbm9kZS5hc1BhcnNlVHJlZSh0b2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZVRyZWU7XG4gIH1cblxuICBjaGlsZEVsZW1lbnRzKCkge1xuICAgIHJldHVybiAoXG5cbiAgICAgIDxDb2x1bW5zRGl2PlxuICAgICAgICA8U2l6ZWFibGVEaXY+XG4gICAgICAgICAgPFJvd3NEaXY+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgTGV4aWNhbCBlbnRyaWVzXG4gICAgICAgICAgICA8L1N1YkhlYWRpbmc+XG4gICAgICAgICAgICA8TGV4aWNhbEVudHJpZXNUZXh0YXJlYSBvbktleVVwPXt0aGlzLmtleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBCTkZcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxCTkZUZXh0YXJlYSBvbktleVVwPXt0aGlzLmtleVVwSGFuZGxlcn0gLz5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBSdWxlIG5hbWVcbiAgICAgICAgICAgIDwvU3ViSGVhZGluZz5cbiAgICAgICAgICAgIDxSdWxlTmFtZUlucHV0IG9uS2V5VXA9e3RoaXMua2V5VXBIYW5kbGVyfSAvPlxuICAgICAgICAgIDwvUm93c0Rpdj5cbiAgICAgICAgPC9TaXplYWJsZURpdj5cbiAgICAgICAgPFZlcnRpY2FsU3BsaXR0ZXJEaXYgLz5cbiAgICAgICAgPENvbHVtbkRpdj5cbiAgICAgICAgICA8Um93c0Rpdj5cbiAgICAgICAgICAgIDxTdWJIZWFkaW5nPlxuICAgICAgICAgICAgICBDb250ZW50XG4gICAgICAgICAgICA8L1N1YkhlYWRpbmc+XG4gICAgICAgICAgICA8Q29udGVudFRleHRhcmVhIG9uS2V5VXA9e3RoaXMua2V5VXBIYW5kbGVyfSAvPlxuICAgICAgICAgICAgPFN1YkhlYWRpbmc+XG4gICAgICAgICAgICAgIFRva2Vuc1xuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPFRva2Vuc1RleHRhcmVhIC8+XG4gICAgICAgICAgICA8U3ViSGVhZGluZz5cbiAgICAgICAgICAgICAgUGFyc2UgdHJlZVxuICAgICAgICAgICAgPC9TdWJIZWFkaW5nPlxuICAgICAgICAgICAgPFBhcnNlVHJlZVRleHRhcmVhIC8+XG4gICAgICAgICAgPC9Sb3dzRGl2PlxuICAgICAgICA8L0NvbHVtbkRpdj5cbiAgICAgIDwvQ29sdW1uc0Rpdj5cblxuICAgICk7XG4gIH1cblxuICBpbml0aWFsaXNlKCkge1xuICAgIHRoaXMuYXNzaWduQ29udGV4dCgpO1xuXG4gICAgY29uc3QgeyBpbml0aWFsQ29udGVudCwgaW5pdGlhbFJ1bGVOYW1lIH0gPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGNvbnRlbnQgPSBpbml0aWFsQ29udGVudCwgLy8vXG4gICAgICAgICAgcnVsZU5hbWUgPSBpbml0aWFsUnVsZU5hbWUsIC8vL1xuICAgICAgICAgIGxleGljYWxFbnRyaWVzID0gZW50cmllczsgLy8vXG5cbiAgICB0aGlzLnNldEJORihibmYpO1xuXG4gICAgdGhpcy5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG4gICAgdGhpcy5zZXRSdWxlTmFtZShydWxlTmFtZSk7XG5cbiAgICB0aGlzLnNldExleGljYWxFbnRyaWVzKGxleGljYWxFbnRyaWVzKTtcblxuICAgIHRoaXMua2V5VXBIYW5kbGVyKCk7XG4gIH1cblxuICBzdGF0aWMgaW5pdGlhbFJ1bGVOYW1lID0gXCJ2YXJpYWJsZUFzc2lnbm1lbnRcIjtcblxuICBzdGF0aWMgaW5pdGlhbENvbnRlbnQgPSBgQm9vbGVhbiB2YXJpYWJsZUJvdW5kID0gaXNWYXJpYWJsZUJvdW5kKHRlcm1Ob2RlLCBzdGF0ZW1lbnROb2RlKTtgO1xuXG4gIHN0YXRpYyB0YWdOYW1lID0gXCJkaXZcIjtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BlcnRpZXMgPSB7XG4gICAgY2xhc3NOYW1lOiBcInZpZXdcIlxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGUoVmlldylgXG5cbiAgcGFkZGluZzogMXJlbTtcbiBcbmA7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcImp1eHRhcG9zZVwiO1xuXG5pbXBvcnQgd2l0aFN0eWxlIGZyb20gXCJlYXN5LXdpdGgtc3R5bGVcIjsgIC8vL1xuXG5pbXBvcnQgeyBCb2R5IH0gZnJvbSBcImVhc3lcIjtcblxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vZXhhbXBsZS92aWV3XCI7XG5cbmNvbnN0IHsgcmVuZGVyU3R5bGVzIH0gPSB3aXRoU3R5bGU7XG5cbnJlbmRlclN0eWxlcygpO1xuXG5jb25zdCBib2R5ID0gbmV3IEJvZHkoKTtcblxuYm9keS5tb3VudChcblxuICA8Vmlldy8+XG5cbik7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7O0FBQUE7Ozs7O21DQUVBLFdBQUE7OztlQUFxQjs7O0FBQU4sdUJBQU07TUFDbkIsWUFBWSxLQUFLLE1BQU07QUFDckIsYUFBSyxNQUFNO0FBQ1gsYUFBSyxPQUFPOztNQUdkLFNBQVM7QUFDUCxlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7YUFHUCxlQUFlLFlBQVk7QUFDaEMsY0FBTSxDQUFFLFdBQVcsY0FBZSxZQUM1QixNQUFNLFdBQ04sT0FBTyxZQUNQLFNBQVMsSUFBSSxPQUFPLEtBQUs7QUFFL0IsZUFBTzs7Ozs7O0FDdEJYOzs7OzttQ0FFQSxXQUFBOzs7ZUFBcUI7OztBQUFOLHVCQUFNO01BQ25CLFlBQVksS0FBSyxNQUFNLE9BQU8sUUFBUTtBQUNwQyxhQUFLLE1BQU07QUFDWCxhQUFLLE9BQU87QUFDWixhQUFLLFFBQVE7QUFDYixhQUFLLFNBQVM7O01BR2hCLFNBQVM7QUFDUCxlQUFPLEtBQUs7O01BR2QsVUFBVTtBQUNSLGVBQU8sS0FBSzs7TUFHZCxXQUFXO0FBQ1QsZUFBTyxLQUFLOztNQUdkLFlBQVk7QUFDVixlQUFPLEtBQUs7O01BR2QsV0FBVztBQUNULGNBQU0sUUFBUyxLQUFLLFFBQVEsS0FBSztBQUVqQyxlQUFPOztNQUdULFlB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USxXQUNmLE9BQU8sT0FBTyxNQUFNLFFBQVE7QUFFbEMsWUFBSSxTQUFTLE1BQU07QUFDakIsc0JBQVksS0FBSyxZQUFZOztBQUcvQixlQUFPOztNQUdULGdCQUFnQjtBQUNkLGVBRUUsc0JBQUEsY0FBQyxZQUFBLFlBQVUsTUFDVCxzQkFBQSxjQUFDLFVBQUEsU0FBVyxNQUNWLHNCQUFBLGNBQUMsWUFBQSxTQUFPLE1BQ04sc0JBQUEsY0FBQyxZQUFBLFNBQVUsTUFBQyxvQkFHWixzQkFBQSxjQUFDLGdCQUFBLFNBQXNCO1VBQUMsU0FBUyxLQUFLO1lBQ3RDLHNCQUFBLGNBQUMsWUFBQSxTQUFVLE1BQUMsUUFHWixzQkFBQSxjQUFDLEtBQUEsU0FBVztVQUFDLFNBQVMsS0FBSztZQUMzQixzQkFBQSxjQUFDLFlBQUEsU0FBVSxNQUFDLGNBR1osc0JBQUEsY0FBQyxVQUFBLFNBQWE7VUFBQyxTQUFTLEtBQUs7Y0FHakMsc0JBQUEsY0FBQyxZQUFBLHFCQUFtQixPQUNwQixzQkFBQSxjQUFDLFlBQUEsV0FBUyxNQUNSLHNCQUFBLGNBQUMsWUFBQSxTQUFPLE1BQ04sc0JBQUEsY0FBQyxZQUFBLFNBQVUsTUFBQyxZQUdaLHNCQUFBLGNBQUMsU0FBQSxTQUFlO1VBQUMsU0FBUyxLQUFLO1lBQy9CLHNCQUFBLGNBQUMsWUFBQSxTQUFVLE1BQUMsV0FHWixzQkFBQSxjQUFDLFFBQUEsU0FBYyxPQUNmLHNCQUFBLGNBQUMsWUFBQSxTQUFVLE1BQUMsZUFHWixzQkFBQSxjQUFDLFdBQUEsU0FBaUI7O01BUTVCLGFBQWE7QUFDWCxhQUFLO0FBRUwsY0FBTSxDQUFFLGdCQUFnQixtQkFBb0IsS0FBSyxhQUMzQyxVQUFVLGdCQUNWLFdBQVcsaUJBQ1gsaUJBQWlCO0FBRXZCLGFBQUssT0FBTztBQUVaLGFBQUssV0FBVztBQUVoQixhQUFLLFlBQVk7QUFFakIsYUFBSyxrQkFBa0I7QUFFdkIsYUFBSzs7O0FBR0Esa0JBNUdULE1BNEdTLG1CQUFrQjtBQUVsQixrQkE5R1QsTUE4R1Msa0JBQWlCO0FBRWpCLGtCQWhIVCxNQWdIUyxXQUFVO0FBRVYsa0JBbEhULE1Ba0hTLHFCQUFvQjtNQUN6QixXQUFXOztRQUlmLFdBQWUsSUFBQSxlQUFBLFNBQVU7Ozs7Ozs7O0FDOUl6Qjs7Ozs7Ozs7Ozs7Ozs7QUFVQSxRQUFNLENBQUUsZ0JBQWlCLGVBQUE7QUFFekI7QUFFQSxRQUFNLE9BQU8sSUFBSSxNQUFBO0FBRWpCLFNBQUssTUFFSCxzQkFBQSxjQUFDLE1BQUEsU0FBSTs7IiwKICAibmFtZXMiOiBbXQp9Cg==
